[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Autorest.CSharp.Core.GeneratorPageableHelpers : object {
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Autorest.CSharp.Core.GeneratorPageableHelpers/<CreateAsyncPageable>d__8`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
}
internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.AsyncLockWithValue`1 : object {
    private object _syncObj;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters;
    private bool _isLocked;
    private bool _hasValue;
    private long _index;
    [NullableAttribute("2")]
private T _value;
    public bool HasValue { get; }
    public AsyncLockWithValue`1(T value);
    public bool get_HasValue();
    [NullableContextAttribute("2")]
public bool TryGetValue(T& value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.AsyncLockWithValue`1/<GetLockOrValueAsync>d__11")]
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken);
    private void SetValue(T value, Int64& lockIndex);
    private void Reset(Int64& lockIndex);
    private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter);
}
internal static class Azure.Core.AuthorizationChallengeParser : object {
    [NullableContextAttribute("1")]
public static string GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter);
    internal static bool TryGetNextChallenge(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& challengeKey);
    internal static bool TryGetNextParameter(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& paramKey, ReadOnlySpan`1& paramValue, char separator);
}
[AttributeUsageAttribute("1")]
internal class Azure.Core.AzureResourceProviderNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ResourceProviderNamespace>k__BackingField;
    public string ResourceProviderNamespace { get; }
    public AzureResourceProviderNamespaceAttribute(string resourceProviderNamespace);
    [CompilerGeneratedAttribute]
public string get_ResourceProviderNamespace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("68")]
internal class Azure.Core.CallerShouldAuditAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; public set; }
    public CallerShouldAuditAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Azure.Core.CodeGenClientAttribute : CodeGenTypeAttribute {
    [CompilerGeneratedAttribute]
private Type <ParentClient>k__BackingField;
    public Type ParentClient { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenClientAttribute(string originalName);
    [CompilerGeneratedAttribute]
public Type get_ParentClient();
    [CompilerGeneratedAttribute]
public void set_ParentClient(Type value);
}
[AttributeUsageAttribute("384")]
internal class Azure.Core.CodeGenMemberAttribute : CodeGenTypeAttribute {
    [NullableContextAttribute("1")]
public CodeGenMemberAttribute(string originalName);
}
[AttributeUsageAttribute("28")]
internal class Azure.Core.CodeGenModelAttribute : CodeGenTypeAttribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Usage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Formats>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Usage { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Formats { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenModelAttribute(string originalName);
    [CompilerGeneratedAttribute]
public String[] get_Usage();
    [CompilerGeneratedAttribute]
public void set_Usage(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Formats();
    [CompilerGeneratedAttribute]
public void set_Formats(String[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Azure.Core.CodeGenOverrideServiceVersionsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Versions>k__BackingField;
    public String[] Versions { get; }
    public CodeGenOverrideServiceVersionsAttribute(String[] versions);
    [CompilerGeneratedAttribute]
public String[] get_Versions();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
internal class Azure.Core.CodeGenSerializationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <SerializationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializationValueHook>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeserializationValueHook>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BicepSerializationValueHook>k__BackingField;
    public string PropertyName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] SerializationPath { get; }
    public string SerializationValueHook { get; public set; }
    public string DeserializationValueHook { get; public set; }
    public string BicepSerializationValueHook { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenSerializationAttribute(string propertyName);
    [NullableContextAttribute("1")]
public CodeGenSerializationAttribute(string propertyName, string serializationName);
    [NullableContextAttribute("1")]
public CodeGenSerializationAttribute(string propertyName, String[] serializationPath);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public String[] get_SerializationPath();
    [CompilerGeneratedAttribute]
public string get_SerializationValueHook();
    [CompilerGeneratedAttribute]
public void set_SerializationValueHook(string value);
    [CompilerGeneratedAttribute]
public string get_DeserializationValueHook();
    [CompilerGeneratedAttribute]
public void set_DeserializationValueHook(string value);
    [CompilerGeneratedAttribute]
public string get_BicepSerializationValueHook();
    [CompilerGeneratedAttribute]
public void set_BicepSerializationValueHook(string value);
}
[AttributeUsageAttribute("28")]
internal class Azure.Core.CodeGenSuppressAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <Parameters>k__BackingField;
    public string Member { get; }
    public Type[] Parameters { get; }
    public CodeGenSuppressAttribute(string member, Type[] parameters);
    [CompilerGeneratedAttribute]
public string get_Member();
    [CompilerGeneratedAttribute]
public Type[] get_Parameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Azure.Core.CodeGenSuppressTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Typename>k__BackingField;
    public string Typename { get; }
    public CodeGenSuppressTypeAttribute(string typename);
    [CompilerGeneratedAttribute]
public string get_Typename();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Azure.Core.CodeGenTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <OriginalName>k__BackingField;
    public string OriginalName { get; }
    public CodeGenTypeAttribute(string originalName);
    [CompilerGeneratedAttribute]
public string get_OriginalName();
}
internal class Azure.Core.FixedDelayWithNoJitterStrategy : DelayStrategy {
    private static TimeSpan DefaultDelay;
    private TimeSpan _delay;
    public FixedDelayWithNoJitterStrategy(Nullable`1<TimeSpan> suggestedDelay);
    private static FixedDelayWithNoJitterStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.FormUrlEncodedContent : RequestContent {
    private List`1<KeyValuePair`2<string, string>> _values;
    private Encoding Latin1;
    private Byte[] _bytes;
    public void Add(string parameter, string value);
    private void BuildIfNeeded();
    [AsyncStateMachineAttribute("Azure.Core.FormUrlEncodedContent/<WriteToAsync>d__5")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
    private Byte[] GetContentByteArray(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static string Encode(string data);
}
[AttributeUsageAttribute("64")]
internal class Azure.Core.ForwardsClientCallsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <SkipChecks>k__BackingField;
    public bool SkipChecks { get; }
    public ForwardsClientCallsAttribute(bool skipChecks);
    [CompilerGeneratedAttribute]
public bool get_SkipChecks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.HttpMessageSanitizer : object {
    private static string LogAllValue;
    private bool _logAllHeaders;
    private bool _logFullQueries;
    private String[] _allowedQueryParameters;
    private string _redactedPlaceholder;
    private HashSet`1<string> _allowedHeaders;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static StringBuilder s_cachedStringBuilder;
    private static int MaxCachedStringBuilderCapacity;
    internal static HttpMessageSanitizer Default;
    public HttpMessageSanitizer(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder);
    private static HttpMessageSanitizer();
    public string SanitizeHeader(string name, string value);
    public string SanitizeUrl(string url);
    private static StringBuilder RentStringBuilder(int capacity);
    private static string ToStringAndReturnStringBuilder(StringBuilder builder);
    [CompilerGeneratedAttribute]
internal static StringBuilder <SanitizeUrl>g__AppendReadOnlySpan|11_0(StringBuilder builder, ReadOnlySpan`1<char> span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.HttpPipelineExtensions : object {
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessMessageAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<Response> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response ProcessMessage(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessHeadAsBoolMessageAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<bool>> ProcessHeadAsBoolMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [ExtensionAttribute]
public static Response`1<bool> ProcessHeadAsBoolMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [NullableContextAttribute("0")]
private static ValueTuple`2<CancellationToken, ErrorOptions> ApplyRequestContext(RequestContext requestContext);
}
internal interface Azure.Core.IOperation {
    public abstract virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Azure.Core.IOperation`1 {
    public abstract virtual ValueTask`1<OperationState`1<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
internal interface Azure.Core.IOperationSource`1 {
    public abstract virtual T CreateResult(Response response, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<T> CreateResultAsync(Response response, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IUtf8JsonSerializable {
    public abstract virtual void Write(Utf8JsonWriter writer);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IXmlSerializable {
    public abstract virtual void Write(XmlWriter writer, string nameHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.NextLinkOperationImplementation : object {
    internal static string NotSet;
    internal static string RehydrationTokenVersion;
    private static string ApiVersionParam;
    private static String[] FailureStates;
    private static String[] SuccessStates;
    private HeaderSource _headerSource;
    private Uri _startRequestUri;
    private OperationFinalStateVia _finalStateVia;
    private HttpPipeline _pipeline;
    [NullableAttribute("2")]
private string _apiVersion;
    [NullableAttribute("2")]
private string _lastKnownLocation;
    private string _nextRequestUri;
    [CompilerGeneratedAttribute]
private string <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestMethod <RequestMethod>k__BackingField;
    public string OperationId { get; private set; }
    public RequestMethod RequestMethod { get; }
    private NextLinkOperationImplementation(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, HeaderSource headerSource, string lastKnownLocation, OperationFinalStateVia finalStateVia, string apiVersion, string operationId, bool isNextRequestPolling);
    private static NextLinkOperationImplementation();
    [CompilerGeneratedAttribute]
public string get_OperationId();
    [CompilerGeneratedAttribute]
private void set_OperationId(string value);
    [CompilerGeneratedAttribute]
public RequestMethod get_RequestMethod();
    public static IOperation Create(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    public static IOperation`1<T> Create(IOperationSource`1<T> operationSource, HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    public static IOperation`1<T> Create(IOperationSource`1<T> operationSource, IOperation operation);
    public static IOperation Create(HttpPipeline pipeline, RehydrationToken rehydrationToken);
    private static string ParseOperationId(Uri startRequestUri, string nextRequestUri);
    public RehydrationToken GetRehydrationToken();
    public static RehydrationToken GetRehydrationToken(RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia);
    public static RehydrationToken GetRehydrationToken(RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, string headerSource, string lastKnownLocation, string finalStateVia, string operationId);
    [NullableContextAttribute("2")]
private static string ConstructStringValue(string value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<UpdateStateAsync>d__29")]
public sealed virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
    private static OperationState GetOperationStateFromFinalResponse(RequestMethod requestMethod, Response response);
    private void UpdateNextRequestUri(ResponseHeaders headers);
    internal static string AppendOrReplaceApiVersion(string uri, string apiVersion);
    [NullableContextAttribute("0")]
internal static bool TryGetApiVersion(Uri startRequestUri, ReadOnlySpan`1& apiVersion);
    [NullableContextAttribute("2")]
private string GetFinalUri(string resourceLocation);
    private Response GetResponse(string uri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<GetResponseAsync>d__36")]
private ValueTask`1<Response> GetResponseAsync(string uri, CancellationToken cancellationToken);
    private HttpMessage CreateRequest(string uri);
    private static bool IsFinalState(Response response, HeaderSource headerSource, Nullable`1& failureState, String& resourceLocation);
    private static string GetRequiredString(JsonElement& element);
    private static bool ShouldIgnoreHeader(RequestMethod method, Response response);
    private static HeaderSource GetHeaderSource(RequestMethod requestMethod, Uri requestUri, Response response, string apiVersion, String& nextRequestUri, Boolean& isNextRequestPolling);
    private static void AssertNotNull(T value, string name);
}
internal enum Azure.Core.OperationFinalStateVia : Enum {
    public int value__;
    public static OperationFinalStateVia AzureAsyncOperation;
    public static OperationFinalStateVia Location;
    public static OperationFinalStateVia OriginalUri;
    public static OperationFinalStateVia OperationLocation;
    public static OperationFinalStateVia LocationOverride;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.OperationHelpers : object {
    public static T GetValue(T& value);
    [NullableContextAttribute("0")]
public static T GetValue(Nullable`1& value);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__2`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__3`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__6")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__7")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal : OperationInternalBase {
    private OperationInternal`1<VoidValue> _internalOperation;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public OperationInternal(IOperation operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    internal OperationInternal(OperationState finalState);
    public static OperationInternal Succeeded(Response rawResponse);
    public static OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal/<UpdateStatusAsync>d__9")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal`1 : OperationInternalBase {
    private IOperation`1<T> _operation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLockWithValue`1<OperationState`1<T>> _stateLock;
    private Response _rawResponse;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    public T Value { get; }
    public OperationInternal`1(IOperation`1<T> operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    internal OperationInternal`1(OperationState`1<T> finalState);
    public static OperationInternal`1<T> Succeeded(Response rawResponse, T value);
    public static OperationInternal`1<T> Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    public bool get_HasValue();
    public T get_Value();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__15")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__16")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__19")]
private ValueTask`1<Response`1<T>> WaitForCompletionAsync(bool async, Nullable`1<TimeSpan> pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<UpdateStatusAsync>d__20")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    private static Response GetResponseFromState(OperationState`1<T> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.OperationInternalBase : object {
    private ClientDiagnostics _diagnostics;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> _scopeAttributes;
    [NullableAttribute("2")]
private DelayStrategy _fallbackStrategy;
    private AsyncLockWithValue`1<Response> _responseLock;
    private string _waitForCompletionResponseScopeName;
    protected string _updateStatusScopeName;
    protected string _waitForCompletionScopeName;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    protected OperationInternalBase(Response rawResponse);
    protected OperationInternalBase(ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    public abstract virtual Response get_RawResponse();
    public abstract virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<UpdateStatusAsync>d__13")]
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__15")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__16")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__19")]
protected ValueTask`1<Response> WaitForCompletionResponseAsync(bool async, Nullable`1<TimeSpan> pollingInterval, string scopeName, CancellationToken cancellationToken);
    protected abstract virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    protected DiagnosticScope CreateScope(string scopeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationPoller : object {
    private DelayStrategy _delayStrategy;
    [NullableContextAttribute("2")]
public OperationPoller(DelayStrategy strategy);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__6`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__8`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__10")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__11")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<Delay>d__12")]
private static ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState : ValueType {
    [CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    [NullableAttribute("2")]
public RequestFailedException OperationFailedException { get; }
    private OperationState(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException operationFailedException);
    [CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    public static OperationState Success(Response rawResponse);
    public static OperationState Failure(Response rawResponse, RequestFailedException operationFailedException);
    public static OperationState Pending(Response rawResponse);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    [NullableAttribute("1")]
public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    public T Value { get; }
    public RequestFailedException OperationFailedException { get; }
    private OperationState`1(Response rawResponse, bool hasCompleted, bool hasSucceeded, T value, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    [NullableContextAttribute("1")]
public static OperationState`1<T> Success(Response rawResponse, T value);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Failure(Response rawResponse, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Pending(Response rawResponse);
}
internal static class Azure.Core.Page : object {
    [NullableContextAttribute("1")]
public static Page`1<T> FromValues(IEnumerable`1<T> values, string continuationToken, Response response);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.PageableHelpers : object {
    private static Byte[] DefaultItemPropertyName;
    private static Byte[] DefaultNextLinkPropertyName;
    private static PageableHelpers();
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.PageableHelpers/<CreateAsyncPageable>d__10`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
    private static ValueTuple`2<List`1<T>, string> ParseResponseForBinaryData(Response response, Byte[] itemPropertyName, Byte[] nextLinkPropertyName);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static object <ParseResponseForBinaryData>g__ReadBinaryData|19_0(Utf8JsonReader& r, ReadOnlyMemory`1& content);
}
internal static class Azure.Core.Pipeline.ActivityExtensions : object {
    [CompilerGeneratedAttribute]
private static bool <SupportsActivitySource>k__BackingField;
    public static bool SupportsActivitySource { get; private set; }
    private static ActivityExtensions();
    [CompilerGeneratedAttribute]
public static bool get_SupportsActivitySource();
    [CompilerGeneratedAttribute]
private static void set_SupportsActivitySource(bool value);
    public static void ResetFeatureSwitch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
    public ClientDiagnostics(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities);
    public ClientDiagnostics(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities);
    internal static HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics);
    internal static string GetResourceProviderNamespace(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Pipeline.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    internal static string OpenTelemetrySchemaAttribute;
    internal static string OpenTelemetrySchemaVersion;
    private static object AzureSdkScopeValue;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    [RequiresUnreferencedCodeAttribute("The diagnosticSourceArgs are used in a call to DiagnosticSource.Write, all necessary properties need to be preserved on the type being passed in using DynamicDependency attributes.")]
internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public void AddAttribute(string name, string value);
    public void AddIntegerAttribute(string name, int value);
    public void AddLongAttribute(string name, long value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, object> attributes);
    public void Start();
    public void SetDisplayName(string displayName);
    public void SetStartTime(DateTime dateTime);
    public void SetTraceContext(string traceparent, string tracestate);
    public sealed virtual void Dispose();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(Exception exception);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(string errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    private bool _isStable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ActivitySource> ActivitySources;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable);
    private static DiagnosticScopeFactory();
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public DiagnosticScope CreateScope(string name, ActivityKind kind);
    private ActivitySource GetActivitySource(string ns, string name);
}
internal class Azure.Core.Pipeline.StorageRequestFailedDetailsParser : RequestFailedDetailsParser {
    [NullableContextAttribute("1")]
public virtual bool TryParse(Response response, ResponseError& error, IDictionary`2& data);
}
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.TaskExtensions : object {
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T EnsureCompleted(Task`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(Task task);
    [ExtensionAttribute]
public static T EnsureCompleted(ValueTask`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(ValueTask task);
    [ExtensionAttribute]
public static Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async);
    [ConditionalAttribute("DEBUG")]
private static void VerifyTaskCompleted(bool isCompleted);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ProtocolOperation`1 : Operation`1<T> {
    private Func`2<Response, T> _resultSelector;
    private OperationInternal`1<T> _operation;
    private IOperation _nextLinkOperation;
    public string Id { get; }
    public T Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal ProtocolOperation`1(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, string scopeName, Func`2<Response, T> resultSelector);
    public virtual string get_Id();
    public virtual T get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperation`1/<Azure-Core-IOperation<T>-UpdateStateAsync>d__17")]
private sealed virtual override ValueTask`1<OperationState`1<T>> Azure.Core.IOperation<T>.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ProtocolOperationHelpers : object {
    public static Operation`1<TTo> Convert(Operation`1<TFrom> operation, Func`2<Response, TTo> convertFunc, ClientDiagnostics diagnostics, string scopeName);
    public static ValueTask`1<Operation`1<VoidValue>> ProcessMessageWithoutResponseValueAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<VoidValue> ProcessMessageWithoutResponseValue(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static ValueTask`1<Operation`1<BinaryData>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<BinaryData> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperationHelpers/<ProcessMessageAsync>d__5`1")]
public static ValueTask`1<Operation`1<T>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
    public static Operation`1<T> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
}
internal class Azure.Core.RawRequestUriBuilder : RequestUriBuilder {
    [NullableAttribute("1")]
private static string SchemeSeparator;
    private static char HostSeparator;
    private static char PortSeparator;
    [NullableAttribute("1")]
private static Char[] HostOrPort;
    private static char QueryBeginSeparator;
    private static char QueryContinueSeparator;
    private static char QueryValueSeparator;
    private Nullable`1<RawWritingPosition> _position;
    private static RawRequestUriBuilder();
    private static void GetQueryParts(ReadOnlySpan`1<char> queryUnparsed, ReadOnlySpan`1& name, ReadOnlySpan`1& value);
    [NullableContextAttribute("1")]
public void AppendRaw(string value, bool escape);
    private void AppendRaw(ReadOnlySpan`1<char> value, bool escape);
    [NullableContextAttribute("1")]
public void AppendRawNextLink(string nextLink, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestHeaderExtensions : object {
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, bool value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, float value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, double value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, int value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, long value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, TimeSpan value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Guid value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Byte[] value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, BinaryData value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string prefix, IDictionary`2<string, string> headersToAdd);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, ETag value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, MatchConditions conditions);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, RequestConditions conditions, string format);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestUriBuilderExtensions : object {
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, float value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, double value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, int value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, IEnumerable`1<string> value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, float value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, double value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, decimal value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, int value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, string format, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.ResponseHeadersExtensions : object {
    private static String[] KnownFormats;
    private static ResponseHeadersExtensions();
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Byte[]& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, T& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string prefix, IDictionary`2& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ResponseWithHeaders : object {
    public static ResponseWithHeaders`2<T, THeaders> FromValue(T value, THeaders headers, Response rawResponse);
    public static ResponseWithHeaders`1<THeaders> FromValue(THeaders headers, Response rawResponse);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.ResponseWithHeaders`1 : object {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public THeaders Headers { get; }
    public ResponseWithHeaders`1(THeaders headers, Response rawResponse);
    public Response GetRawResponse();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`1<THeaders> self);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ResponseWithHeaders`2 : Response`1<T> {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public T Value { get; }
    public THeaders Headers { get; }
    public ResponseWithHeaders`2(T value, THeaders headers, Response rawResponse);
    public virtual Response GetRawResponse();
    [CompilerGeneratedAttribute]
public virtual T get_Value();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`2<T, THeaders> self);
}
internal class Azure.Core.SequentialDelayStrategy : DelayStrategy {
    [NullableAttribute("1")]
private static TimeSpan[] _pollingSequence;
    private static TimeSpan _maxDelay;
    private static SequentialDelayStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.StringRequestContent : RequestContent {
    private Byte[] _bytes;
    public StringRequestContent(string value);
    [AsyncStateMachineAttribute("Azure.Core.StringRequestContent/<WriteToAsync>d__2")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.TypeFormatters : object {
    private static string RoundtripZFormat;
    [CompilerGeneratedAttribute]
private static string <DefaultNumberFormat>k__BackingField;
    public static string DefaultNumberFormat { get; }
    private static TypeFormatters();
    [CompilerGeneratedAttribute]
public static string get_DefaultNumberFormat();
    public static string ToString(bool value);
    public static string ToString(DateTime value, string format);
    public static string ToString(DateTimeOffset value, string format);
    public static string ToString(TimeSpan value, string format);
    public static string ToString(Byte[] value, string format);
    public static string ToBase64UrlString(Byte[] value);
    public static Byte[] FromBase64UrlString(string value);
    private static int GetNumBase64PaddingCharsToAddForDecode(int inputLength);
    public static DateTimeOffset ParseDateTimeOffset(string value, string format);
    public static TimeSpan ParseTimeSpan(string value, string format);
    [NullableContextAttribute("2")]
public static string ConvertToString(object value, string format);
}
[IsReadOnlyAttribute]
internal class Azure.Core.VoidValue : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XElementExtensions : object {
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64Value(XElement element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffsetValue(XElement element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpanValue(XElement element, string format);
    [ExtensionAttribute]
public static object GetObjectValue(XElement element, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.XmlWriterContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private XmlWriter <XmlWriter>k__BackingField;
    public XmlWriter XmlWriter { get; }
    [CompilerGeneratedAttribute]
public XmlWriter get_XmlWriter();
    [AsyncStateMachineAttribute("Azure.Core.XmlWriterContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XmlWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteObjectValue(XmlWriter writer, object value, string nameHint);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, Byte[] value, string format);
}
internal class Azure.NoBodyResponse`1 : Response`1<T> {
    private Response _response;
    public bool HasValue { get; }
    public T Value { get; }
    public NoBodyResponse`1(Response response);
    public virtual bool get_HasValue();
    public virtual T get_Value();
    public virtual Response GetRawResponse();
    public virtual string ToString();
}
internal class Azure.Storage.AggregatingProgressIncrementer : object {
    private long _currentValue;
    private IProgress`1<long> _innerHandler;
    [CompilerGeneratedAttribute]
private static AggregatingProgressIncrementer <None>k__BackingField;
    public static AggregatingProgressIncrementer None { get; }
    public long Current { get; }
    public AggregatingProgressIncrementer(IProgress`1<long> innerHandler);
    private static AggregatingProgressIncrementer();
    public Stream CreateProgressIncrementingStream(Stream stream);
    public sealed virtual void Report(long bytes);
    public void Reset();
    [CompilerGeneratedAttribute]
public static AggregatingProgressIncrementer get_None();
    public long get_Current();
}
[ExtensionAttribute]
internal static class Azure.Storage.BufferExtensions : object {
    [ExtensionAttribute]
public static IDisposable RentDisposable(ArrayPool`1<T> pool, int minimumLength, T[]& array);
    [ExtensionAttribute]
public static IDisposable RentAsMemoryDisposable(ArrayPool`1<T> pool, int minimumLength, Memory`1& memory);
    [ExtensionAttribute]
public static IDisposable RentAsSpanDisposable(ArrayPool`1<T> pool, int minimumLength, Span`1& span);
    [ExtensionAttribute]
public static T[] Clear(T[] array);
}
internal class Azure.Storage.ChecksumCalculatingStream : Stream {
    private Stream _stream;
    private AppendChecksumCalculation _appendChecksumCalculation;
    private long _initialPosition;
    private long _nextToBeChecksummedPosition;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private ChecksumCalculatingStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation, bool isReadMode);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public static Stream GetReadStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation);
    public static Stream GetWriteStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<ReadAsync>d__30")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<ReadSeekableInternal>d__31")]
private Task`1<int> ReadSeekableInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<ReadUnseekableInternal>d__32")]
private Task`1<int> ReadUnseekableInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<WriteAsync>d__34")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<WriteInternal>d__35")]
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<FlushAsync>d__38")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Close();
    public virtual void SetLength(long value);
    private void AssertCanRead();
    private void AssertCanWrite();
}
internal static class Azure.Storage.Common.Argument : object {
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static void AssertEnumDefined(Type enumType, object value, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    public static void AssertNull(T value, string name, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Storage.Common.AzureSasCredentialSynchronousPolicy : HttpPipelineSynchronousPolicy {
    private AzureSasCredential _credential;
    public AzureSasCredentialSynchronousPolicy(AzureSasCredential credential);
    public virtual void OnSendingRequest(HttpMessage message);
}
[DefaultMemberAttribute("Item")]
internal class Azure.Storage.Common.ChangeTrackingDictionary`2 : object {
    private IDictionary`2<TKey, TValue> _innerDictionary;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ChangeTrackingDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public ChangeTrackingDictionary`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    public bool get_IsUndefined();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public IDictionary`2<TKey, TValue> EnsureDictionary();
    [IteratorStateMachineAttribute("Azure.Storage.Common.ChangeTrackingDictionary`2/<<GetEnumerator>g__enumerateEmpty|21_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__enumerateEmpty|21_0();
}
[DefaultMemberAttribute("Item")]
internal class Azure.Storage.Common.ChangeTrackingList`1 : object {
    private IList`1<T> _innerList;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ChangeTrackingList`1(IList`1<T> innerList);
    public ChangeTrackingList`1(IReadOnlyList`1<T> innerList);
    public bool get_IsUndefined();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public void Reset();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public IList`1<T> EnsureList();
    [IteratorStateMachineAttribute("Azure.Storage.Common.ChangeTrackingList`1/<<GetEnumerator>g__enumerateEmpty|14_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<T> <GetEnumerator>g__enumerateEmpty|14_0();
}
[ExtensionAttribute]
internal static class Azure.Storage.Common.ModelSerializationExtensions : object {
    internal static ModelReaderWriterOptions WireOptions;
    private static ModelSerializationExtensions();
    [ExtensionAttribute]
public static object GetObject(JsonElement element);
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64(JsonElement element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffset(JsonElement element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpan(JsonElement element, string format);
    [ExtensionAttribute]
public static char GetChar(JsonElement element);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ThrowNonNullablePropertyIsNull(JsonProperty property);
    [ExtensionAttribute]
public static string GetRequiredString(JsonElement element);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTime value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, char value);
    [ExtensionAttribute]
public static void WriteBase64StringValue(Utf8JsonWriter writer, Byte[] value, string format);
    [ExtensionAttribute]
public static void WriteNumberValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteObjectValue(Utf8JsonWriter writer, T value);
    [ExtensionAttribute]
public static void WriteObjectValue(Utf8JsonWriter writer, object value);
}
internal class Azure.Storage.Common.MultipartFormDataRequestContent : RequestContent {
    private MultipartFormDataContent _multipartContent;
    private static Random _random;
    private static Char[] _boundaryValues;
    public string ContentType { get; }
    internal HttpContent HttpContent { get; }
    private static MultipartFormDataRequestContent();
    public string get_ContentType();
    internal HttpContent get_HttpContent();
    private static string CreateBoundary();
    public void Add(string content, string name, string filename, string contentType);
    public void Add(int content, string name, string filename, string contentType);
    public void Add(long content, string name, string filename, string contentType);
    public void Add(float content, string name, string filename, string contentType);
    public void Add(double content, string name, string filename, string contentType);
    public void Add(decimal content, string name, string filename, string contentType);
    public void Add(bool content, string name, string filename, string contentType);
    public void Add(Stream content, string name, string filename, string contentType);
    public void Add(Byte[] content, string name, string filename, string contentType);
    public void Add(BinaryData content, string name, string filename, string contentType);
    private void Add(HttpContent content, string name, string filename, string contentType);
    public static void AddFilenameHeader(HttpContent content, string name, string filename);
    public static void AddContentTypeHeader(HttpContent content, string contentType);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Common.MultipartFormDataRequestContent/<WriteToAsync>d__24")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public virtual void Dispose();
}
internal static class Azure.Storage.Common.Optional : object {
    public static bool IsCollectionDefined(IEnumerable`1<T> collection);
    public static bool IsCollectionDefined(IDictionary`2<TKey, TValue> collection);
    public static bool IsCollectionDefined(IReadOnlyDictionary`2<TKey, TValue> collection);
    public static bool IsDefined(Nullable`1<T> value);
    public static bool IsDefined(object value);
    public static bool IsDefined(JsonElement value);
    public static bool IsDefined(string value);
}
internal static class Azure.Storage.Common.RequestContentHelper : object {
    public static RequestContent FromEnumerable(IEnumerable`1<T> enumerable);
    public static RequestContent FromEnumerable(IEnumerable`1<BinaryData> enumerable);
    public static RequestContent FromEnumerable(ReadOnlySpan`1<T> span);
    public static RequestContent FromDictionary(IDictionary`2<string, TValue> dictionary);
    public static RequestContent FromDictionary(IDictionary`2<string, BinaryData> dictionary);
    public static RequestContent FromObject(object value);
    public static RequestContent FromObject(BinaryData value);
}
internal class Azure.Storage.Common.Utf8JsonRequestContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private Utf8JsonWriter <JsonWriter>k__BackingField;
    public Utf8JsonWriter JsonWriter { get; }
    [CompilerGeneratedAttribute]
public Utf8JsonWriter get_JsonWriter();
    [AsyncStateMachineAttribute("Azure.Storage.Common.Utf8JsonRequestContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
internal static class Azure.Storage.CompatSwitches : object {
    private static Nullable`1<bool> _disableRequestConditionsValidation;
    private static Nullable`1<bool> _disableExpectContinueHeader;
    public static bool DisableRequestConditionsValidation { get; }
    public static bool DisableExpectContinueHeader { get; }
    public static bool get_DisableRequestConditionsValidation();
    public static bool get_DisableExpectContinueHeader();
}
internal static class Azure.Storage.Constants : object {
    public static int KB;
    public static int MB;
    public static int GB;
    public static long TB;
    public static int Base16;
    public static int MaxReliabilityRetries;
    public static int MaxIdleTimeMs;
    public static string DefaultSasVersion;
    public static int MaxHashRequestDownloadRange;
    public static int DefaultBufferSize;
    public static int LargeBufferSize;
    public static int LargeUploadThreshold;
    public static int DefaultStreamingDownloadSize;
    public static int DefaultStreamCopyBufferSize;
    public static int DefaultDownloadCopyBufferSize;
    public static int StorageCrc64SizeInBytes;
    public static int MD5SizeInBytes;
    public static bool DefaultTrimBlobNameSlashes;
    public static string CloseAllHandles;
    public static string Wildcard;
    public static string BlockNameFormat;
    public static string SasTimeFormatSeconds;
    public static string SasTimeFormatSubSeconds;
    public static string SasTimeFormatMinutes;
    public static string SasTimeFormatDays;
    public static string SnapshotParameterName;
    public static string VersionIdParameterName;
    public static string ShareSnapshotParameterName;
    public static string Https;
    public static string Http;
    public static string PercentSign;
    public static string EncodedPercentSign;
    public static string QueryDelimiter;
    public static string PathBackSlashDelimiter;
    public static string FalseName;
    public static string TrueName;
    public static string ErrorCode;
    public static string ErrorMessage;
    public static string CommaString;
    public static char CommaChar;
    public static string ContentTypeApplicationXml;
    public static string ContentTypeApplicationJson;
    public static string ErrorPropertyKey;
    public static string DetailPropertyKey;
    public static string MessagePropertyKey;
    public static string CodePropertyKey;
    public static string Iso8601Format;
    public static string DisableRequestConditionsValidationSwitchName;
    public static string DisableRequestConditionsValidationEnvVar;
    public static string DisableExpectContinueHeaderSwitchName;
    public static string DisableExpectContinueHeaderEnvVar;
    public static string DefaultScope;
}
[ExtensionAttribute]
internal static class Azure.Storage.ContentHasher : object {
    internal static int GetHashSizeInBytes(StorageChecksumAlgorithm algorithm);
    [ExtensionAttribute]
internal static UploadTransferValidationOptions ToUploadTransferValidationOptions(GetHashResult hashResult);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<AssertResponseHashMatchInternal>d__3")]
public static Task AssertResponseHashMatchInternal(Stream content, StorageChecksumAlgorithm algorithm, Response response, bool async, CancellationToken cancellationToken);
    public static void AssertResponseHashMatch(Byte[] content, int offset, int count, StorageChecksumAlgorithm algorithm, Response response);
    private static void AssertResponseHashMatch(GetHashResult computedHash, StorageChecksumAlgorithm algorithm, Response response);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<GetHashOrDefaultInternal>d__6")]
public static Task`1<GetHashResult> GetHashOrDefaultInternal(Stream content, UploadTransferValidationOptions options, bool async, CancellationToken cancellationToken);
    public static GetHashResult GetHashOrDefault(BinaryData content, UploadTransferValidationOptions options);
    private static bool GetHashOrDefaultTryFromOptions(UploadTransferValidationOptions options, GetHashResult& result);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<GetHashInternal>d__9")]
public static Task`1<GetHashResult> GetHashInternal(Stream content, StorageChecksumAlgorithm algorithmIdentifier, bool async, CancellationToken cancellationToken);
    public static GetHashResult GetHash(BinaryData content, StorageChecksumAlgorithm algorithmIdentifier);
    public static ValueTuple`4<Stream, GetFinalStreamHash, int, IDisposable> SetupChecksumCalculatingReadStream(Stream stream, StorageChecksumAlgorithm algorithmIdentifier);
    private static IHasher GetHasher(StorageChecksumAlgorithm algorithmIdentifier);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<ComputeHashInternal>d__14")]
private static Task`1<Byte[]> ComputeHashInternal(Stream content, IHasher hasher, bool async, CancellationToken cancellationToken);
    public static IHasher GetHasherFromAlgorithmId(StorageChecksumAlgorithm algorithm);
    public static ValueTuple`2<ReadOnlyMemory`1<byte>, StorageChecksumAlgorithm> GetResponseChecksumOrDefault(Response response);
    [CompilerGeneratedAttribute]
internal static Byte[] <GetHash>g__computeCrc|10_0(StorageCrc64HashAlgorithm nonCryptographicHashAlgorithm, <>c__DisplayClass10_0& );
}
internal class Azure.Storage.DisposableBucket : object {
    [CompilerGeneratedAttribute]
private List`1<IDisposable> <Disposables>k__BackingField;
    private List`1<IDisposable> Disposables { get; }
    [CompilerGeneratedAttribute]
private List`1<IDisposable> get_Disposables();
    public void Add(IDisposable disposable);
    public sealed virtual void Dispose();
}
internal class Azure.Storage.Errors : object {
    public static ArgumentException AccountMismatch(string accountNameCredential, string accountNameValue);
    public static InvalidOperationException AccountSasMissingData();
    public static ArgumentNullException ArgumentNull(string paramName);
    public static ArgumentException InvalidArgument(string paramName);
    public static ArgumentException InvalidResourceType(char s);
    public static InvalidOperationException TaskIncomplete();
    public static FormatException InvalidFormat(string err);
    public static ArgumentException ParsingConnectionStringFailed();
    public static ArgumentOutOfRangeException InvalidSasProtocol(string protocol, string sasProtocol);
    public static ArgumentException InvalidService(char s);
    public static ArgumentException InsufficientStorageTransferOptions(long streamLength, long statedMaxBlockSize, long necessaryMinBlockSize);
    public static InvalidDataException HashMismatch(string hashHeaderName);
    public static InvalidDataException ChecksumMismatch(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static InvalidDataException HashMismatchOnStreamedDownload(string mismatchedRange);
    public static ArgumentException PrecalculatedHashNotSupportedOnSplit();
    public static ArgumentException CannotDeferTransactionalHashVerification();
    public static ArgumentException CannotInitializeWriteStreamWithData();
    internal static void VerifyStreamPosition(Stream stream, string streamName);
    public static void ThrowIfParamNull(object obj, string paramName);
    internal static void CheckCryptKeySize(int keySizeInBytes);
    public static CryptographicException CryptographyAuthTagMismatch();
    public static ArgumentException CryptographyPlaintextCiphertextLengthMismatch();
    public static ArgumentException CryptographyInvalidNonceLength();
    public static ArgumentException CryptographyInvalidTagLength();
    public static ArgumentException CannotBothBeNotNull(string param0, string param1);
    public static ArgumentOutOfRangeException MustBeGreaterThanOrEqualTo(string paramName, long value);
    public static ArgumentOutOfRangeException MustBeLessThanOrEqualTo(string paramName, long value);
    public static ArgumentOutOfRangeException MustBeBetweenInclusive(string paramName, long lower, long upper, long actual);
    public static ArgumentOutOfRangeException MustBeGreaterThanValueOrEqualToOtherValue(string paramName, long value0, long value1);
    public static ArgumentException StreamMustBeReadable(string paramName);
    public static InvalidOperationException StreamMustBeAtPosition0();
    public static InvalidOperationException TokenCredentialsRequireHttps();
    public static ArgumentException SasCredentialRequiresUriWithoutSas(Uri uri);
    public static InvalidOperationException SasMissingData(string paramName);
    public static InvalidOperationException SasDataNotAllowed(string paramName, string paramNameNotAllowed);
    public static InvalidOperationException SasDataInConjunction(string paramName, string paramName2);
    public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName, string clientParam);
    public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName);
    public static InvalidOperationException SasServiceNotMatching(string builderParam, string builderName, string expectedService);
    public static InvalidOperationException SasClientMissingData(string paramName);
    public static InvalidOperationException SasBuilderEmptyParam(string builderName, string paramName, string sasType);
    public static InvalidOperationException SasIncorrectResourceType(string builderName, string builderParam, string value, string clientName);
    public static ArgumentException InvalidPermission(char s);
    public static ArgumentException ParsingHttpRangeFailed();
    public static AccessViolationException UnableAccessArray();
    public static NotImplementedException NotImplemented();
    public static AuthenticationException InvalidCredentials(string fullName);
    public static ArgumentException SeekOutsideBufferRange(long index, long inclusiveRangeStart, long exclusiveRangeEnd);
    public static ArgumentException VersionNotSupported(string paramName);
    public static RequestFailedException ClientRequestIdMismatch(Response response, string echo, string original);
    public static ArgumentException TransactionalHashingNotSupportedWithClientSideEncryption();
    public static void VerifyHttpsTokenAuth(Uri uri);
}
internal class Azure.Storage.ExpectContinueOnThrottlePolicy : HttpPipelineSynchronousPolicy {
    private long _lastThrottleTicks;
    private long _throttleIntervalTicks;
    [CompilerGeneratedAttribute]
private long <ContentLengthThreshold>k__BackingField;
    public TimeSpan ThrottleInterval { get; public set; }
    public long ContentLengthThreshold { get; public set; }
    public TimeSpan get_ThrottleInterval();
    public void set_ThrottleInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public long get_ContentLengthThreshold();
    [CompilerGeneratedAttribute]
public void set_ContentLengthThreshold(long value);
    public virtual void OnSendingRequest(HttpMessage message);
    public virtual void OnReceivedResponse(HttpMessage message);
}
internal class Azure.Storage.ExpectContinuePolicy : HttpPipelineSynchronousPolicy {
    [CompilerGeneratedAttribute]
private long <ContentLengthThreshold>k__BackingField;
    public long ContentLengthThreshold { get; public set; }
    [CompilerGeneratedAttribute]
public long get_ContentLengthThreshold();
    [CompilerGeneratedAttribute]
public void set_ContentLengthThreshold(long value);
    public virtual void OnSendingRequest(HttpMessage message);
}
internal class Azure.Storage.Files.DataLake.DataLakeClientConfiguration : StorageClientConfiguration {
    [CompilerGeneratedAttribute]
private DataLakeClientOptions <ClientOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DataLakeCustomerProvidedKey> <CustomerProvidedKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferValidationOptions <TransferValidation>k__BackingField;
    public DataLakeClientOptions ClientOptions { get; internal set; }
    public Nullable`1<DataLakeCustomerProvidedKey> CustomerProvidedKey { get; internal set; }
    public TransferValidationOptions TransferValidation { get; }
    public DataLakeClientConfiguration(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics, DataLakeClientOptions clientOptions, Nullable`1<DataLakeCustomerProvidedKey> customerProvidedKey);
    public DataLakeClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics, DataLakeClientOptions clientOptions, Nullable`1<DataLakeCustomerProvidedKey> customerProvidedKey);
    public DataLakeClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics, DataLakeClientOptions clientOptions, Nullable`1<DataLakeCustomerProvidedKey> customerProvidedKey);
    public DataLakeClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics, DataLakeClientOptions clientOptions, Nullable`1<DataLakeCustomerProvidedKey> customerProvidedKey);
    internal DataLakeClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics, DataLakeClientOptions clientOptions, Nullable`1<DataLakeCustomerProvidedKey> customerProvidedKey);
    [CompilerGeneratedAttribute]
public DataLakeClientOptions get_ClientOptions();
    [CompilerGeneratedAttribute]
internal void set_ClientOptions(DataLakeClientOptions value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<DataLakeCustomerProvidedKey> get_CustomerProvidedKey();
    [CompilerGeneratedAttribute]
internal virtual void set_CustomerProvidedKey(Nullable`1<DataLakeCustomerProvidedKey> value);
    [CompilerGeneratedAttribute]
public virtual TransferValidationOptions get_TransferValidation();
    internal static DataLakeClientConfiguration DeepCopy(DataLakeClientConfiguration originalClientConfiguration);
}
public class Azure.Storage.Files.DataLake.DataLakeClientOptions : ClientOptions {
    internal static ServiceVersion LatestVersion;
    [CompilerGeneratedAttribute]
private ServiceVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DataLakeCustomerProvidedKey> <CustomerProvidedKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <GeoRedundantSecondaryUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTenantDiscovery>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DataLakeAudience> <Audience>k__BackingField;
    public ServiceVersion Version { get; }
    public Nullable`1<DataLakeCustomerProvidedKey> CustomerProvidedKey { get; public set; }
    public Uri GeoRedundantSecondaryUri { get; public set; }
    public bool EnableTenantDiscovery { get; public set; }
    public TransferValidationOptions TransferValidation { get; }
    public Nullable`1<DataLakeAudience> Audience { get; public set; }
    public DataLakeClientOptions(ServiceVersion version);
    [CompilerGeneratedAttribute]
public ServiceVersion get_Version();
    [CompilerGeneratedAttribute]
public Nullable`1<DataLakeCustomerProvidedKey> get_CustomerProvidedKey();
    [CompilerGeneratedAttribute]
public void set_CustomerProvidedKey(Nullable`1<DataLakeCustomerProvidedKey> value);
    [CompilerGeneratedAttribute]
public Uri get_GeoRedundantSecondaryUri();
    [CompilerGeneratedAttribute]
public void set_GeoRedundantSecondaryUri(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableTenantDiscovery();
    [CompilerGeneratedAttribute]
public void set_EnableTenantDiscovery(bool value);
    [CompilerGeneratedAttribute]
public TransferValidationOptions get_TransferValidation();
    private void AddHeadersAndQueryParameters();
    internal HttpPipeline Build(HttpPipelinePolicy authentication);
    internal HttpPipeline Build(object credentials);
    [CompilerGeneratedAttribute]
public Nullable`1<DataLakeAudience> get_Audience();
    [CompilerGeneratedAttribute]
public void set_Audience(Nullable`1<DataLakeAudience> value);
}
public class Azure.Storage.Files.DataLake.DataLakeDirectoryClient : DataLakePathClient {
    public DataLakeDirectoryClient(Uri directoryUri);
    public DataLakeDirectoryClient(Uri directoryUri, DataLakeClientOptions options);
    public DataLakeDirectoryClient(string connectionString, string fileSystemName, string directoryPath);
    public DataLakeDirectoryClient(string connectionString, string fileSystemName, string directoryPath, DataLakeClientOptions options);
    public DataLakeDirectoryClient(Uri directoryUri, StorageSharedKeyCredential credential);
    public DataLakeDirectoryClient(Uri directoryUri, StorageSharedKeyCredential credential, DataLakeClientOptions options);
    public DataLakeDirectoryClient(Uri directoryUri, AzureSasCredential credential);
    public DataLakeDirectoryClient(Uri directoryUri, AzureSasCredential credential, DataLakeClientOptions options);
    public DataLakeDirectoryClient(Uri directoryUri, TokenCredential credential);
    public DataLakeDirectoryClient(Uri directoryUri, TokenCredential credential, DataLakeClientOptions options);
    internal DataLakeDirectoryClient(Uri directoryUri, HttpPipelinePolicy authentication, DataLakeClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential);
    internal DataLakeDirectoryClient(Uri directoryUri, HttpPipelinePolicy authentication, DataLakeClientOptions options, AzureSasCredential sasCredential);
    internal DataLakeDirectoryClient(Uri directoryUri, HttpPipelinePolicy authentication, DataLakeClientOptions options, TokenCredential tokenCredential);
    internal DataLakeDirectoryClient(Uri directoryUri, DataLakeClientConfiguration clientConfiguration);
    internal DataLakeDirectoryClient(Uri fileSystemUri, string directoryPath, DataLakeClientConfiguration clientConfiguration);
    public DataLakeDirectoryClient WithCustomerProvidedKey(Nullable`1<DataLakeCustomerProvidedKey> customerProvidedKey);
    public virtual DataLakeFileClient GetFileClient(string fileName);
    public virtual DataLakeDirectoryClient GetSubDirectoryClient(string subdirectoryName);
    public virtual Response`1<PathInfo> Create(DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<CreateAsync>d__20")]
public virtual Task`1<Response`1<PathInfo>> CreateAsync(DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PathInfo> Create(PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<CreateAsync>d__22")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PathInfo>> CreateAsync(PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> CreateIfNotExists(DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<CreateIfNotExistsAsync>d__24")]
public virtual Task`1<Response`1<PathInfo>> CreateIfNotExistsAsync(DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PathInfo> CreateIfNotExists(PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<CreateIfNotExistsAsync>d__26")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PathInfo>> CreateIfNotExistsAsync(PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, CancellationToken cancellationToken);
    public virtual Response Delete(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<DeleteAsync>d__28")]
public virtual Task`1<Response> DeleteAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<bool> DeleteIfExists(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<DeleteIfExistsAsync>d__30")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeDirectoryClient> Rename(string destinationPath, string destinationFileSystem, DataLakeRequestConditions sourceConditions, DataLakeRequestConditions destinationConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<RenameAsync>d__32")]
public virtual Task`1<Response`1<DataLakeDirectoryClient>> RenameAsync(string destinationPath, string destinationFileSystem, DataLakeRequestConditions sourceConditions, DataLakeRequestConditions destinationConditions, CancellationToken cancellationToken);
    public virtual Response`1<PathAccessControl> GetAccessControl(Nullable`1<bool> userPrincipalName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<GetAccessControlAsync>d__34")]
public virtual Task`1<Response`1<PathAccessControl>> GetAccessControlAsync(Nullable`1<bool> userPrincipalName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<PathInfo> SetAccessControlList(IList`1<PathAccessControlItem> accessControlList, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<SetAccessControlListAsync>d__36")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<PathInfo>> SetAccessControlListAsync(IList`1<PathAccessControlItem> accessControlList, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<PathInfo> SetPermissions(PathPermissions permissions, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<SetPermissionsAsync>d__38")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<PathInfo>> SetPermissionsAsync(PathPermissions permissions, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathProperties> GetProperties(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<GetPropertiesAsync>d__40")]
public virtual Task`1<Response`1<PathProperties>> GetPropertiesAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> SetHttpHeaders(PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<SetHttpHeadersAsync>d__42")]
public virtual Task`1<Response`1<PathInfo>> SetHttpHeadersAsync(PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> SetMetadata(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<SetMetadataAsync>d__44")]
public virtual Task`1<Response`1<PathInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeFileClient> CreateFile(string fileName, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<CreateFileAsync>d__46")]
public virtual Task`1<Response`1<DataLakeFileClient>> CreateFileAsync(string fileName, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<DataLakeFileClient> CreateFile(string fileName, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<CreateFileAsync>d__48")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<DataLakeFileClient>> CreateFileAsync(string fileName, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response DeleteFile(string fileName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<DeleteFileAsync>d__50")]
public virtual Task`1<Response> DeleteFileAsync(string fileName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeDirectoryClient> CreateSubDirectory(string path, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<CreateSubDirectoryAsync>d__52")]
public virtual Task`1<Response`1<DataLakeDirectoryClient>> CreateSubDirectoryAsync(string path, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<DataLakeDirectoryClient> CreateSubDirectory(string path, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<CreateSubDirectoryAsync>d__54")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<DataLakeDirectoryClient>> CreateSubDirectoryAsync(string path, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response DeleteSubDirectory(string path, string continuation, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeDirectoryClient/<DeleteSubDirectoryAsync>d__56")]
public virtual Task`1<Response> DeleteSubDirectoryAsync(string path, string continuation, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Pageable`1<PathItem> GetPaths(bool recursive, bool userPrincipalName, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<PathItem> GetPathsAsync(bool recursive, bool userPrincipalName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasPermissions permissions, DateTimeOffset expiresOn);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasPermissions permissions, DateTimeOffset expiresOn, String& stringToSign);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasBuilder builder);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasBuilder builder, String& stringToSign);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__0(PathResourceType resourceType, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__1(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__2(PathResourceType resourceType, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__3(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response> <>n__4(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<bool>> <>n__5(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<DataLakePathClient>> <>n__6(string destinationPath, string destinationFileSystem, DataLakeRequestConditions sourceConditions, DataLakeRequestConditions destinationConditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathAccessControl>> <>n__7(Nullable`1<bool> userPrincipalName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__8(IList`1<PathAccessControlItem> accessControlList, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__9(PathPermissions permissions, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathProperties>> <>n__10(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__11(PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__12(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.DataLake.DataLakeErrors : object {
    public static ArgumentException EntityIdAndInvalidAccessControlType(string s);
    public static ArgumentException PathAccessControlItemStringInvalidLength(string s);
    public static ArgumentException PathAccessControlItemStringInvalidPrefix(string s);
    public static ArgumentException RemovePathAccessControlItemInvalidString(string s);
    public static ArgumentException RemovePathAccessControlItemStringInvalidPrefix(string s);
    public static ArgumentException PathPermissionsOctalInvalidLength(string s);
    public static ArgumentException PathPermissionsOctalInvalidFirstDigit(string s);
    public static ArgumentException PathPermissionsSymbolicInvalidLength(string s);
    public static ArgumentException RolePermissionsSymbolicInvalidCharacter(string s);
    public static ArgumentException RolePermissionsSymbolicInvalidLength(string s);
    public static DataLakeAclChangeFailedException ChangeAclRequestFailed(RequestFailedException exception, string continuationToken);
    public static DataLakeAclChangeFailedException ChangeAclFailed(Exception exception, string continuationToken);
    internal static void VerifyHttpsCustomerProvidedKey(Uri uri, Nullable`1<DataLakeCustomerProvidedKey> customerProvidedKey);
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.DataLakeExtensions : object {
    [ExtensionAttribute]
internal static FileSystemItem ToFileSystemItem(BlobContainerItem containerItem);
    [ExtensionAttribute]
internal static FileSystemProperties ToFileSystemProperties(BlobContainerProperties containerProperties);
    [ExtensionAttribute]
internal static FileDownloadDetails ToFileDownloadDetails(BlobDownloadDetails blobDownloadProperties, string encryptionContext, string accessControlList);
    [ExtensionAttribute]
internal static FileDownloadInfo ToFileDownloadInfo(Response`1<BlobDownloadInfo> blobDownloadInfoResponse);
    [ExtensionAttribute]
internal static FileDownloadInfo ToFileDownloadInfo(Response`1<BlobDownloadStreamingResult> blobDownloadStreamingResultResponse);
    [ExtensionAttribute]
internal static PathProperties ToPathProperties(Response`1<BlobProperties> blobPropertiesResponse);
    [ExtensionAttribute]
internal static PathInfo ToPathInfo(BlobInfo blobInfo);
    [ExtensionAttribute]
internal static DataLakeLease ToDataLakeLease(BlobLease blobLease);
    [ExtensionAttribute]
internal static BlobHttpHeaders ToBlobHttpHeaders(PathHttpHeaders pathHttpHeaders);
    [ExtensionAttribute]
internal static BlobRequestConditions ToBlobRequestConditions(DataLakeRequestConditions dataLakeRequestConditions);
    [ExtensionAttribute]
internal static PathItem ToPathItem(Dictionary`2<string, string> dictionary);
    private static IDictionary`2<string, string> ToMetadata(string rawMetdata);
    [ExtensionAttribute]
internal static FileSystemAccessPolicy ToFileSystemAccessPolicy(BlobContainerAccessPolicy blobContainerAccessPolicy);
    [ExtensionAttribute]
internal static IEnumerable`1<DataLakeSignedIdentifier> ToDataLakeSignedIdentifiers(IEnumerable`1<BlobSignedIdentifier> blobSignedIdentifiers);
    [ExtensionAttribute]
internal static DataLakeSignedIdentifier ToDataLakeSignedIdentifier(BlobSignedIdentifier blobSignedIdentifier);
    [ExtensionAttribute]
internal static DataLakeAccessPolicy ToDataLakeAccessPolicy(BlobAccessPolicy blobAccessPolicy);
    [ExtensionAttribute]
internal static IEnumerable`1<BlobSignedIdentifier> ToBlobSignedIdentifiers(IEnumerable`1<DataLakeSignedIdentifier> dataLakeSignedIdentifiers);
    [ExtensionAttribute]
internal static BlobSignedIdentifier ToBlobSignedIdentifier(DataLakeSignedIdentifier dataLakeSignedIdentifier);
    [ExtensionAttribute]
internal static BlobAccessPolicy ToBlobAccessPolicy(DataLakeAccessPolicy dataLakeAccessPolicy);
    [ExtensionAttribute]
internal static BlobQueryOptions ToBlobQueryOptions(DataLakeQueryOptions options);
    [ExtensionAttribute]
internal static BlobQueryTextOptions ToBlobQueryTextConfiguration(DataLakeQueryTextOptions textConfiguration, bool isInput);
    [ExtensionAttribute]
internal static BlobQueryJsonTextOptions ToBlobQueryJsonTextConfiguration(DataLakeQueryJsonTextOptions options);
    [ExtensionAttribute]
internal static BlobQueryCsvTextOptions ToBlobQueryCsvTextConfiguration(DataLakeQueryCsvTextOptions options);
    [ExtensionAttribute]
internal static BlobQueryArrowOptions ToBlobQueryArrowOptions(DataLakeQueryArrowOptions options);
    [ExtensionAttribute]
internal static BlobQueryParquetTextOptions ToBlobQueryParquetTextOptions(DataLakeQueryParquetTextOptions options);
    [ExtensionAttribute]
internal static IList`1<BlobQueryArrowField> ToBlobQueryArrowFields(IList`1<DataLakeQueryArrowField> arrowFields);
    [ExtensionAttribute]
internal static BlobQueryArrowField ToBlobQueryArrowField(DataLakeQueryArrowField arrowField);
    [ExtensionAttribute]
internal static BlobQueryArrowFieldType ToBlobQueryArrowFieldType(DataLakeQueryArrowFieldType fieldType);
    [ExtensionAttribute]
internal static DataLakeQueryError ToDataLakeQueryError(BlobQueryError error);
    [ExtensionAttribute]
internal static BlobOpenReadOptions ToBlobOpenReadOptions(DataLakeOpenReadOptions options);
    [ExtensionAttribute]
internal static BlobDownloadOptions ToBlobBaseDownloadOptions(DataLakeFileReadOptions options);
    [ExtensionAttribute]
internal static BlobDownloadToOptions ToBlobBaseDownloadToOptions(DataLakeFileReadToOptions options);
    [ExtensionAttribute]
internal static PathSegment ToPathSegment(ResponseWithHeaders`2<PathList, FileSystemListPathsHeaders> response);
    [ExtensionAttribute]
internal static IEnumerable`1<PathItem> ToPathItems(PathList pathList);
    [ExtensionAttribute]
internal static PathItem ToPathItem(Path path);
    internal static Nullable`1<DateTimeOffset> ParseFileTimeString(string fileTimeString);
    [ExtensionAttribute]
internal static PathInfo ToPathInfo(ResponseWithHeaders`1<PathCreateHeaders> response);
    [ExtensionAttribute]
internal static PathAccessControl ToPathAccessControl(ResponseWithHeaders`1<PathGetPropertiesHeaders> response);
    [ExtensionAttribute]
internal static PathInfo ToPathInfo(ResponseWithHeaders`1<PathSetAccessControlHeaders> response);
    [ExtensionAttribute]
internal static PathInfo ToPathInfo(ResponseWithHeaders`1<PathFlushDataHeaders> response);
    [ExtensionAttribute]
internal static PathInfo ToPathInfo(ResponseWithHeaders`1<PathSetExpiryHeaders> response);
    [ExtensionAttribute]
internal static PathDeletedSegment ToPathDeletedSegment(ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, FileSystemListBlobHierarchySegmentHeaders> response);
    [ExtensionAttribute]
internal static PathHierarchyDeletedItem ToPathHierarchyDeletedItem(BlobItemInternal blobItemInternal);
    [ExtensionAttribute]
internal static DataLakeServiceProperties ToDataLakeServiceProperties(BlobServiceProperties blobServiceProperties);
    [ExtensionAttribute]
internal static DataLakeAnalyticsLogging ToDataLakeAnalyticsLogging(BlobAnalyticsLogging blobAnalyticsLogging);
    [ExtensionAttribute]
internal static DataLakeMetrics ToDataLakeMetrics(BlobMetrics blobMetrics);
    [ExtensionAttribute]
internal static DataLakeRetentionPolicy ToDataLakeRetentionPolicy(BlobRetentionPolicy blobRetentionPolicy);
    [ExtensionAttribute]
internal static IList`1<DataLakeCorsRule> ToDataLakeCorsRules(IList`1<BlobCorsRule> blobCorsRules);
    [ExtensionAttribute]
internal static DataLakeCorsRule ToDataLakeCorsRule(BlobCorsRule blobCorsRule);
    [ExtensionAttribute]
internal static DataLakeStaticWebsite ToDataLakeStaticWebsite(BlobStaticWebsite blobStaticWebsite);
    [ExtensionAttribute]
internal static BlobServiceProperties ToBlobServiceProperties(DataLakeServiceProperties dataLakeServiceProperties);
    [ExtensionAttribute]
internal static BlobMetrics ToBlobMetrics(DataLakeMetrics dataLakeMetrics);
    [ExtensionAttribute]
internal static BlobRetentionPolicy ToBlobRetentionPolicy(DataLakeRetentionPolicy dataLakeRetentionPolicy);
    [ExtensionAttribute]
internal static IList`1<BlobCorsRule> ToBlobCorsRules(IList`1<DataLakeCorsRule> dataLakeCorsRules);
    [ExtensionAttribute]
internal static BlobCorsRule ToBlobCorsRule(DataLakeCorsRule dataLakeCorsRule);
    [ExtensionAttribute]
internal static BlobAnalyticsLogging ToBlobAnalyticsLogging(DataLakeAnalyticsLogging dataLakeAnalyticsLogging);
    [ExtensionAttribute]
internal static BlobStaticWebsite ToBlobStaticWebsite(DataLakeStaticWebsite dataLakeStaticWebsite);
    [ExtensionAttribute]
internal static BlobContainerEncryptionScopeOptions ToBlobContainerEncryptionScopeOptions(DataLakeFileSystemEncryptionScopeOptions encryptionScopeOptions);
    [ExtensionAttribute]
internal static Nullable`1<CustomerProvidedKey> ToBlobCustomerProvidedKey(Nullable`1<DataLakeCustomerProvidedKey> dataLakeCustomerProvidedKey);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(RequestConditions requestConditions, DataLakeRequestConditionProperty invalidConditions, string operationName, string parameterName);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(DataLakeRequestConditions requestConditions, DataLakeRequestConditionProperty invalidConditions, string operationName, string parameterName);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(RequestConditions requestConditions, DataLakeRequestConditionProperty invalidConditions, List`1& invalidList);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(DataLakeRequestConditions requestConditions, DataLakeRequestConditionProperty invalidConditions, List`1& invalidList);
    [ExtensionAttribute]
internal static string ToPermissionsString(DataLakeAccountSasPermissions permissions);
    [ExtensionAttribute]
internal static string ToPermissionsString(DataLakeFileSystemSasPermissions permissions);
    [ExtensionAttribute]
internal static string ToPermissionsString(DataLakeSasPermissions permissions);
}
public class Azure.Storage.Files.DataLake.DataLakeFileClient : DataLakePathClient {
    [EditorBrowsableAttribute("1")]
public int MaxUploadBytes { get; }
    public long MaxUploadLongBytes { get; }
    public DataLakeFileClient(Uri fileUri);
    public DataLakeFileClient(Uri fileUri, DataLakeClientOptions options);
    public DataLakeFileClient(string connectionString, string fileSystemName, string filePath);
    public DataLakeFileClient(string connectionString, string fileSystemName, string filePath, DataLakeClientOptions options);
    public DataLakeFileClient(Uri fileUri, StorageSharedKeyCredential credential);
    public DataLakeFileClient(Uri fileUri, StorageSharedKeyCredential credential, DataLakeClientOptions options);
    public DataLakeFileClient(Uri fileUri, AzureSasCredential credential);
    public DataLakeFileClient(Uri fileUri, AzureSasCredential credential, DataLakeClientOptions options);
    public DataLakeFileClient(Uri fileUri, TokenCredential credential);
    public DataLakeFileClient(Uri fileUri, TokenCredential credential, DataLakeClientOptions options);
    internal DataLakeFileClient(Uri fileUri, HttpPipelinePolicy authentication, DataLakeClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential);
    internal DataLakeFileClient(Uri fileUri, HttpPipelinePolicy authentication, DataLakeClientOptions options, AzureSasCredential sasCredential);
    internal DataLakeFileClient(Uri fileUri, HttpPipelinePolicy authentication, DataLakeClientOptions options, TokenCredential tokenCredential);
    internal DataLakeFileClient(Uri fileUri, DataLakeClientConfiguration clientConfiguration);
    internal DataLakeFileClient(Uri fileSystemUri, string filePath, DataLakeClientConfiguration clientConfiguration);
    public virtual int get_MaxUploadBytes();
    public virtual long get_MaxUploadLongBytes();
    public DataLakeFileClient WithCustomerProvidedKey(Nullable`1<DataLakeCustomerProvidedKey> customerProvidedKey);
    public virtual Response`1<PathInfo> Create(DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<CreateAsync>d__22")]
public virtual Task`1<Response`1<PathInfo>> CreateAsync(DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PathInfo> Create(PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<CreateAsync>d__24")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PathInfo>> CreateAsync(PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> CreateIfNotExists(DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<CreateIfNotExistsAsync>d__26")]
public virtual Task`1<Response`1<PathInfo>> CreateIfNotExistsAsync(DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PathInfo> CreateIfNotExists(PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<CreateIfNotExistsAsync>d__28")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PathInfo>> CreateIfNotExistsAsync(PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, CancellationToken cancellationToken);
    public virtual Response Delete(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<DeleteAsync>d__30")]
public virtual Task`1<Response> DeleteAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<bool> DeleteIfExists(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<DeleteIfExistsAsync>d__32")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeFileClient> Rename(string destinationPath, string destinationFileSystem, DataLakeRequestConditions sourceConditions, DataLakeRequestConditions destinationConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<RenameAsync>d__34")]
public virtual Task`1<Response`1<DataLakeFileClient>> RenameAsync(string destinationPath, string destinationFileSystem, DataLakeRequestConditions sourceConditions, DataLakeRequestConditions destinationConditions, CancellationToken cancellationToken);
    public virtual Response`1<PathAccessControl> GetAccessControl(Nullable`1<bool> userPrincipalName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<GetAccessControlAsync>d__36")]
public virtual Task`1<Response`1<PathAccessControl>> GetAccessControlAsync(Nullable`1<bool> userPrincipalName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<PathInfo> SetAccessControlList(IList`1<PathAccessControlItem> accessControlList, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<SetAccessControlListAsync>d__38")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<PathInfo>> SetAccessControlListAsync(IList`1<PathAccessControlItem> accessControlList, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<PathInfo> SetPermissions(PathPermissions permissions, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<SetPermissionsAsync>d__40")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<PathInfo>> SetPermissionsAsync(PathPermissions permissions, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathProperties> GetProperties(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<GetPropertiesAsync>d__42")]
public virtual Task`1<Response`1<PathProperties>> GetPropertiesAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> SetHttpHeaders(PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<SetHttpHeadersAsync>d__44")]
public virtual Task`1<Response`1<PathInfo>> SetHttpHeadersAsync(PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> SetMetadata(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<SetMetadataAsync>d__46")]
public virtual Task`1<Response`1<PathInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response Append(Stream content, long offset, DataLakeFileAppendOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<AppendAsync>d__48")]
public virtual Task`1<Response> AppendAsync(Stream content, long offset, DataLakeFileAppendOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response Append(Stream content, long offset, Byte[] contentHash, string leaseId, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<AppendAsync>d__50")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> AppendAsync(Stream content, long offset, Byte[] contentHash, string leaseId, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<AppendInternal>d__51")]
internal virtual Task`1<Response> AppendInternal(Stream content, Nullable`1<long> offset, UploadTransferValidationOptions validationOptionsOverride, string leaseId, Nullable`1<DataLakeLeaseAction> leaseAction, Nullable`1<TimeSpan> leaseDuration, string proposedLeaseId, IProgress`1<long> progressHandler, Nullable`1<bool> flush, bool async, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> Flush(long position, DataLakeFileFlushOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PathInfo> Flush(long position, Nullable`1<bool> retainUncommittedData, Nullable`1<bool> close, PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<FlushAsync>d__54")]
public virtual Task`1<Response`1<PathInfo>> FlushAsync(long position, DataLakeFileFlushOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<FlushAsync>d__55")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PathInfo>> FlushAsync(long position, Nullable`1<bool> retainUncommittedData, Nullable`1<bool> close, PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<FlushInternal>d__56")]
internal virtual Task`1<Response`1<PathInfo>> FlushInternal(long position, Nullable`1<bool> retainUncommittedData, Nullable`1<bool> close, PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, Nullable`1<DataLakeLeaseAction> leaseAction, Nullable`1<TimeSpan> leaseDuration, string proposedLeaseId, bool async, CancellationToken cancellationToken);
    public virtual Response`1<FileDownloadInfo> Read();
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ReadAsync>d__58")]
public virtual Task`1<Response`1<FileDownloadInfo>> ReadAsync();
    public virtual Response`1<FileDownloadInfo> Read(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ReadAsync>d__60")]
public virtual Task`1<Response`1<FileDownloadInfo>> ReadAsync(CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<FileDownloadInfo> Read(HttpRange range, DataLakeRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ReadAsync>d__62")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<FileDownloadInfo>> ReadAsync(HttpRange range, DataLakeRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken);
    public virtual Response`1<FileDownloadInfo> Read(DataLakeFileReadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ReadAsync>d__64")]
public virtual Task`1<Response`1<FileDownloadInfo>> ReadAsync(DataLakeFileReadOptions options, CancellationToken cancellationToken);
    public virtual Response ReadTo(Stream destination, DataLakeFileReadToOptions options, CancellationToken cancellationToken);
    public virtual Response ReadTo(string path, DataLakeFileReadToOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ReadToAsync>d__67")]
public virtual Task`1<Response> ReadToAsync(Stream destination, DataLakeFileReadToOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ReadToAsync>d__68")]
public virtual Task`1<Response> ReadToAsync(string path, DataLakeFileReadToOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response ReadTo(Stream destination, DataLakeRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response ReadTo(string path, DataLakeRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ReadToAsync>d__71")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> ReadToAsync(Stream destination, DataLakeRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ReadToAsync>d__72")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> ReadToAsync(string path, DataLakeRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> Upload(Stream content, DataLakeFileUploadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PathInfo> Upload(Stream content, PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, IProgress`1<long> progressHandler, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> Upload(Stream content);
    [ForwardsClientCallsAttribute]
public virtual Response`1<PathInfo> Upload(Stream content, bool overwrite, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<PathInfo>> UploadAsync(Stream content, DataLakeFileUploadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PathInfo>> UploadAsync(Stream content, PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, IProgress`1<long> progressHandler, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<PathInfo>> UploadAsync(Stream content);
    [ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<PathInfo>> UploadAsync(Stream content, bool overwrite, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<PathInfo> Upload(string path, DataLakeFileUploadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ForwardsClientCallsAttribute]
public virtual Response`1<PathInfo> Upload(string path, PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, IProgress`1<long> progressHandler, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<PathInfo> Upload(string path);
    [ForwardsClientCallsAttribute]
public virtual Response`1<PathInfo> Upload(string path, bool overwrite, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<UploadAsync>d__85")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<PathInfo>> UploadAsync(string path, DataLakeFileUploadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<UploadAsync>d__86")]
[EditorBrowsableAttribute("1")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<PathInfo>> UploadAsync(string path, PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, IProgress`1<long> progressHandler, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<UploadAsync>d__87")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<PathInfo>> UploadAsync(string path);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<UploadAsync>d__88")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<PathInfo>> UploadAsync(string path, bool overwrite, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<StagedUploadInternal>d__89")]
internal Task`1<Response`1<PathInfo>> StagedUploadInternal(Stream content, DataLakeFileUploadOptions options, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<StagedUploadInternal>d__90")]
internal Task`1<Response`1<PathInfo>> StagedUploadInternal(string path, DataLakeFileUploadOptions options, bool async, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> ScheduleDeletion(DataLakeFileScheduleDeletionOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ScheduleDeletionAsync>d__92")]
public virtual Task`1<Response`1<PathInfo>> ScheduleDeletionAsync(DataLakeFileScheduleDeletionOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<ScheduleDeletionInternal>d__93")]
private Task`1<Response`1<PathInfo>> ScheduleDeletionInternal(DataLakeFileScheduleDeletionOptions options, bool async, CancellationToken cancellationToken);
    public virtual Response`1<FileDownloadInfo> Query(string querySqlExpression, DataLakeQueryOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<QueryAsync>d__95")]
public virtual Task`1<Response`1<FileDownloadInfo>> QueryAsync(string querySqlExpression, DataLakeQueryOptions options, CancellationToken cancellationToken);
    public virtual Stream OpenRead(DataLakeOpenReadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<OpenReadAsync>d__97")]
public virtual Task`1<Stream> OpenReadAsync(DataLakeOpenReadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Stream OpenRead(long position, Nullable`1<int> bufferSize, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Stream OpenRead(bool allowfileModifications, long position, Nullable`1<int> bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<OpenReadAsync>d__100")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Stream> OpenReadAsync(long position, Nullable`1<int> bufferSize, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<OpenReadAsync>d__101")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Stream> OpenReadAsync(bool allowfileModifications, long position, Nullable`1<int> bufferSize, CancellationToken cancellationToken);
    public virtual Stream OpenWrite(bool overwrite, DataLakeFileOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<OpenWriteAsync>d__103")]
public virtual Task`1<Stream> OpenWriteAsync(bool overwrite, DataLakeFileOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileClient/<OpenWriteInternal>d__104")]
private Task`1<Stream> OpenWriteInternal(bool overwrite, DataLakeFileOpenWriteOptions options, bool async, CancellationToken cancellationToken);
    internal PartitionedUploader`2<DataLakeFileUploadOptions, PathInfo> GetPartitionedUploader(StorageTransferOptions transferOptions, UploadTransferValidationOptions validationOptions, ArrayPool`1<byte> arrayPool, string operationName);
    internal static Behaviors<DataLakeFileUploadOptions, PathInfo> GetPartitionedUploaderBehaviors(DataLakeFileClient client);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__0(PathResourceType resourceType, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__1(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__2(PathResourceType resourceType, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__3(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response> <>n__4(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<bool>> <>n__5(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<DataLakePathClient>> <>n__6(string destinationPath, string destinationFileSystem, DataLakeRequestConditions sourceConditions, DataLakeRequestConditions destinationConditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathAccessControl>> <>n__7(Nullable`1<bool> userPrincipalName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__8(IList`1<PathAccessControlItem> accessControlList, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__9(PathPermissions permissions, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathProperties>> <>n__10(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__11(PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Response`1<PathInfo>> <>n__12(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
}
public class Azure.Storage.Files.DataLake.DataLakeFileSystemClient : object {
    internal BlobContainerClient _containerClient;
    private Uri _uri;
    private Uri _blobUri;
    private Uri _dfsUri;
    private DataLakeClientConfiguration _clientConfiguration;
    private string _accountName;
    private string _name;
    private FileSystemRestClient _fileSystemRestClient;
    private FileSystemRestClient _blobFileSystemRestClient;
    private DataLakeServiceClient _parentServiceClient;
    internal BlobContainerClient ContainerClient { get; }
    public Uri Uri { get; }
    internal DataLakeClientConfiguration ClientConfiguration { get; }
    public string AccountName { get; }
    public string Name { get; }
    public bool CanGenerateSasUri { get; }
    internal FileSystemRestClient FileSystemRestClient { get; }
    internal FileSystemRestClient BlobFileSystemRestClient { get; }
    public DataLakeFileSystemClient(Uri fileSystemUri);
    public DataLakeFileSystemClient(Uri fileSystemUri, DataLakeClientOptions options);
    public DataLakeFileSystemClient(string connectionString, string fileSystemName);
    public DataLakeFileSystemClient(string connectionString, string fileSystemName, DataLakeClientOptions options);
    public DataLakeFileSystemClient(Uri fileSystemUri, StorageSharedKeyCredential credential);
    public DataLakeFileSystemClient(Uri fileSystemUri, StorageSharedKeyCredential credential, DataLakeClientOptions options);
    public DataLakeFileSystemClient(Uri fileSystemUri, AzureSasCredential credential);
    public DataLakeFileSystemClient(Uri fileSystemUri, AzureSasCredential credential, DataLakeClientOptions options);
    public DataLakeFileSystemClient(Uri fileSystemUri, TokenCredential credential);
    public DataLakeFileSystemClient(Uri fileSystemUri, TokenCredential credential, DataLakeClientOptions options);
    internal DataLakeFileSystemClient(Uri fileSystemUri, HttpPipelinePolicy authentication, DataLakeClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    internal DataLakeFileSystemClient(Uri fileSystemUri, DataLakeClientConfiguration clientConfiguration);
    internal virtual BlobContainerClient get_ContainerClient();
    public virtual Uri get_Uri();
    internal virtual DataLakeClientConfiguration get_ClientConfiguration();
    public virtual string get_AccountName();
    public virtual string get_Name();
    public virtual bool get_CanGenerateSasUri();
    internal virtual FileSystemRestClient get_FileSystemRestClient();
    internal virtual FileSystemRestClient get_BlobFileSystemRestClient();
    private ValueTuple`2<FileSystemRestClient, FileSystemRestClient> BuildFileSystemRestClients(Uri dfsUri, Uri blobUri);
    public virtual DataLakeDirectoryClient GetDirectoryClient(string directoryName);
    internal virtual DataLakeDirectoryClient GetRootDirectoryClient();
    public virtual DataLakeFileClient GetFileClient(string fileName);
    private void SetNameFieldsIfNull();
    public virtual Response`1<FileSystemInfo> Create(DataLakeFileSystemCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<CreateAsync>d__45")]
public virtual Task`1<Response`1<FileSystemInfo>> CreateAsync(DataLakeFileSystemCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<FileSystemInfo> Create(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<CreateAsync>d__47")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<FileSystemInfo>> CreateAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    public virtual Response`1<FileSystemInfo> CreateIfNotExists(DataLakeFileSystemCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<CreateIfNotExistsAsync>d__49")]
public virtual Task`1<Response`1<FileSystemInfo>> CreateIfNotExistsAsync(DataLakeFileSystemCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<FileSystemInfo> CreateIfNotExists(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<CreateIfNotExistsAsync>d__51")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<FileSystemInfo>> CreateIfNotExistsAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    public virtual Response Delete(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<DeleteAsync>d__53")]
public virtual Task`1<Response> DeleteAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<bool> DeleteIfExists(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<DeleteIfExistsAsync>d__55")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<bool> Exists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<ExistsAsync>d__57")]
public virtual Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken);
    public virtual Response`1<FileSystemProperties> GetProperties(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<GetPropertiesAsync>d__59")]
public virtual Task`1<Response`1<FileSystemProperties>> GetPropertiesAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<FileSystemInfo> SetMetadata(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<SetMetadataAsync>d__61")]
public virtual Task`1<Response`1<FileSystemInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Pageable`1<PathItem> GetPaths(string path, bool recursive, bool userPrincipalName, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<PathItem> GetPathsAsync(string path, bool recursive, bool userPrincipalName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<GetPathsInternal>d__64")]
internal Task`1<Response`1<PathSegment>> GetPathsInternal(string path, bool recursive, bool userPrincipalName, string continuation, Nullable`1<int> maxResults, string operationName, bool async, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeDirectoryClient> CreateDirectory(string path, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<CreateDirectoryAsync>d__66")]
public virtual Task`1<Response`1<DataLakeDirectoryClient>> CreateDirectoryAsync(string path, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<DataLakeDirectoryClient> CreateDirectory(string path, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<CreateDirectoryAsync>d__68")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<DataLakeDirectoryClient>> CreateDirectoryAsync(string path, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response DeleteDirectory(string path, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<DeleteDirectoryAsync>d__70")]
public virtual Task`1<Response> DeleteDirectoryAsync(string path, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeFileClient> CreateFile(string path, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<CreateFileAsync>d__72")]
public virtual Task`1<Response`1<DataLakeFileClient>> CreateFileAsync(string path, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<DataLakeFileClient> CreateFile(string path, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<CreateFileAsync>d__74")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<DataLakeFileClient>> CreateFileAsync(string path, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response DeleteFile(string path, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<DeleteFileAsync>d__76")]
public virtual Task`1<Response> DeleteFileAsync(string path, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<FileSystemAccessPolicy> GetAccessPolicy(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<GetAccessPolicyAsync>d__78")]
public virtual Task`1<Response`1<FileSystemAccessPolicy>> GetAccessPolicyAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<FileSystemInfo> SetAccessPolicy(PublicAccessType accessType, IEnumerable`1<DataLakeSignedIdentifier> permissions, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<SetAccessPolicyAsync>d__80")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<FileSystemInfo>> SetAccessPolicyAsync(PublicAccessType accessType, IEnumerable`1<DataLakeSignedIdentifier> permissions, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeFileSystemSasPermissions permissions, DateTimeOffset expiresOn);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeFileSystemSasPermissions permissions, DateTimeOffset expiresOn, String& stringToSign);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasBuilder builder);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasBuilder builder, String& stringToSign);
    public virtual Pageable`1<PathDeletedItem> GetDeletedPaths(string pathPrefix, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<PathDeletedItem> GetDeletedPathsAsync(string pathPrefix, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<GetDeletedPathsInternal>d__87")]
internal Task`1<Response`1<PathDeletedSegment>> GetDeletedPathsInternal(string pathPrefix, string continuation, Nullable`1<int> maxResults, string operationName, bool async, CancellationToken cancellationToken);
    public virtual Response`1<DataLakePathClient> UndeletePath(string deletedPath, string deletionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<UndeletePathAsync>d__89")]
public virtual Task`1<Response`1<DataLakePathClient>> UndeletePathAsync(string deletedPath, string deletionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileSystemClient/<UndeletePathInternal>d__90")]
internal Task`1<Response`1<DataLakePathClient>> UndeletePathInternal(string deletedPath, string deletionId, bool async, CancellationToken cancellationToken);
    internal virtual DataLakePathClient GetPathClient(string path);
    protected internal virtual DataLakeServiceClient GetParentServiceClientCore();
}
internal class Azure.Storage.Files.DataLake.DataLakeFileWriteStream : StorageWriteStream {
    private DataLakeFileClient _fileClient;
    private DataLakeRequestConditions _conditions;
    private Nullable`1<bool> _closeEvent;
    private long _writeIndex;
    public DataLakeFileWriteStream(DataLakeFileClient fileClient, long bufferSize, long position, DataLakeRequestConditions conditions, IProgress`1<long> progressHandler, UploadTransferValidationOptions validationOptions, Nullable`1<bool> closeEvent);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileWriteStream/<AppendInternal>d__5")]
protected virtual Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeFileWriteStream/<CommitInternal>d__6")]
protected virtual Task CommitInternal(bool async, CancellationToken cancellationToken);
    protected virtual void ValidateBufferSize(long bufferSize);
}
public class Azure.Storage.Files.DataLake.DataLakeLeaseClient : object {
    private BlobLeaseClient _blobLeaseClient;
    public static TimeSpan InfiniteLeaseDuration;
    private ClientDiagnostics _clientDiagnostics;
    public Uri Uri { get; }
    public string LeaseId { get; }
    internal ClientDiagnostics ClientDiagnostics { get; }
    public DataLakeLeaseClient(DataLakePathClient client, string leaseId);
    public DataLakeLeaseClient(DataLakeFileSystemClient client, string leaseId);
    private static DataLakeLeaseClient();
    public Uri get_Uri();
    public virtual string get_LeaseId();
    internal virtual ClientDiagnostics get_ClientDiagnostics();
    public virtual Response`1<DataLakeLease> Acquire(TimeSpan duration, RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeLeaseClient/<AcquireAsync>d__13")]
public virtual Task`1<Response`1<DataLakeLease>> AcquireAsync(TimeSpan duration, RequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeLease> Renew(RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeLeaseClient/<RenewAsync>d__15")]
public virtual Task`1<Response`1<DataLakeLease>> RenewAsync(RequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<ReleasedObjectInfo> Release(RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeLeaseClient/<ReleaseAsync>d__17")]
public virtual Task`1<Response`1<ReleasedObjectInfo>> ReleaseAsync(RequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeLease> Change(string proposedId, RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeLeaseClient/<ChangeAsync>d__19")]
public virtual Task`1<Response`1<DataLakeLease>> ChangeAsync(string proposedId, RequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeLease> Break(Nullable`1<TimeSpan> breakPeriod, RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeLeaseClient/<BreakAsync>d__21")]
public virtual Task`1<Response`1<DataLakeLease>> BreakAsync(Nullable`1<TimeSpan> breakPeriod, RequestConditions conditions, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Azure.Storage.Files.DataLake.DataLakeLeaseClientExtensions : object {
    [ExtensionAttribute]
public static DataLakeLeaseClient GetDataLakeLeaseClient(DataLakePathClient client, string leaseId);
    [ExtensionAttribute]
public static DataLakeLeaseClient GetDataLakeLeaseClient(DataLakeFileSystemClient client, string leaseId);
}
public class Azure.Storage.Files.DataLake.DataLakePathClient : object {
    internal BlockBlobClient _blockBlobClient;
    internal DataLakeFileSystemClient _fileSystemClient;
    private Uri _uri;
    private Uri _blobUri;
    private Uri _dfsUri;
    private DataLakeClientConfiguration _clientConfiguration;
    private string _accountName;
    private string _fileSystemName;
    private string _path;
    private string _name;
    private PathRestClient _pathRestClient;
    private PathRestClient _blobPathRestClient;
    private DataLakeFileSystemClient _parentFileSystemClient;
    private DataLakeDirectoryClient _parentDirectoryClient;
    internal BlockBlobClient BlobClient { get; }
    internal DataLakeFileSystemClient FileSystemClient { get; }
    internal Uri BlobUri { get; }
    internal Uri DfsUri { get; }
    public Uri Uri { get; }
    internal DataLakeClientConfiguration ClientConfiguration { get; }
    public string AccountName { get; }
    public string FileSystemName { get; }
    public string Path { get; }
    public string Name { get; }
    public bool CanGenerateSasUri { get; }
    internal PathRestClient PathRestClient { get; }
    internal PathRestClient BlobPathRestClient { get; }
    public DataLakePathClient(Uri pathUri);
    public DataLakePathClient(Uri pathUri, DataLakeClientOptions options);
    public DataLakePathClient(string connectionString, string fileSystemName, string path);
    public DataLakePathClient(string connectionString, string fileSystemName, string path, DataLakeClientOptions options);
    public DataLakePathClient(Uri pathUri, StorageSharedKeyCredential credential);
    public DataLakePathClient(Uri pathUri, StorageSharedKeyCredential credential, DataLakeClientOptions options);
    public DataLakePathClient(Uri pathUri, AzureSasCredential credential);
    public DataLakePathClient(Uri pathUri, AzureSasCredential credential, DataLakeClientOptions options);
    public DataLakePathClient(Uri pathUri, TokenCredential credential);
    public DataLakePathClient(Uri pathUri, TokenCredential credential, DataLakeClientOptions options);
    public DataLakePathClient(DataLakeFileSystemClient fileSystemClient, string path);
    internal DataLakePathClient(Uri pathUri, ClientDiagnostics diagnostics, DataLakeClientOptions options);
    internal DataLakePathClient(Uri pathUri, HttpPipelinePolicy authentication, DataLakeClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    internal DataLakePathClient(Uri pathUri, DataLakeClientConfiguration clientConfiguration);
    internal DataLakePathClient(Uri fileSystemUri, string directoryOrFilePath, DataLakeClientConfiguration clientConfiguration);
    internal virtual BlockBlobClient get_BlobClient();
    internal virtual DataLakeFileSystemClient get_FileSystemClient();
    internal virtual Uri get_BlobUri();
    internal virtual Uri get_DfsUri();
    public virtual Uri get_Uri();
    internal virtual DataLakeClientConfiguration get_ClientConfiguration();
    public virtual string get_AccountName();
    public virtual string get_FileSystemName();
    public virtual string get_Path();
    public virtual string get_Name();
    public virtual bool get_CanGenerateSasUri();
    internal virtual PathRestClient get_PathRestClient();
    internal virtual PathRestClient get_BlobPathRestClient();
    private ValueTuple`2<PathRestClient, PathRestClient> BuildPathRestClients(Uri dfsUri, Uri blobUri);
    public DataLakePathClient WithCustomerProvidedKey(Nullable`1<DataLakeCustomerProvidedKey> customerProvidedKey);
    internal static string BuildMetadataString(IDictionary`2<string, string> metadata);
    internal virtual void SetNameFieldsIfNull();
    public virtual Response`1<PathInfo> Create(PathResourceType resourceType, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<CreateAsync>d__60")]
public virtual Task`1<Response`1<PathInfo>> CreateAsync(PathResourceType resourceType, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PathInfo> Create(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<CreateAsync>d__62")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PathInfo>> CreateAsync(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<CreateInternal>d__63")]
internal virtual Task`1<Response`1<PathInfo>> CreateInternal(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, string owner, string group, IList`1<PathAccessControlItem> accessControlList, string leaseId, Nullable`1<TimeSpan> leaseDuration, Nullable`1<TimeSpan> timeToExpire, Nullable`1<DateTimeOffset> expiresOn, string encryptionContext, DataLakeRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> CreateIfNotExists(PathResourceType resourceType, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<CreateIfNotExistsAsync>d__65")]
public virtual Task`1<Response`1<PathInfo>> CreateIfNotExistsAsync(PathResourceType resourceType, DataLakePathCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PathInfo> CreateIfNotExists(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<CreateIfNotExistsAsync>d__67")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PathInfo>> CreateIfNotExistsAsync(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<CreateIfNotExistsInternal>d__68")]
private Task`1<Response`1<PathInfo>> CreateIfNotExistsInternal(PathResourceType resourceType, PathHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, string permissions, string umask, string owner, string group, IList`1<PathAccessControlItem> accessControlList, string leaseId, Nullable`1<TimeSpan> leaseDuration, Nullable`1<TimeSpan> timeToExpire, Nullable`1<DateTimeOffset> expiresOn, string encryptionContext, bool async, CancellationToken cancellationToken);
    public virtual Response`1<bool> Exists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<ExistsAsync>d__70")]
public virtual Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken);
    public virtual Response Delete(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<DeleteAsync>d__72")]
public virtual Task`1<Response> DeleteAsync(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<DeleteInternal>d__73")]
private Task`1<Response> DeleteInternal(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<bool> DeleteIfExists(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<DeleteIfExistsAsync>d__75")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<DeleteIfExistsInternal>d__76")]
private Task`1<Response`1<bool>> DeleteIfExistsInternal(Nullable`1<bool> recursive, DataLakeRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<DataLakePathClient> Rename(string destinationPath, string destinationFileSystem, DataLakeRequestConditions sourceConditions, DataLakeRequestConditions destinationConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<RenameAsync>d__78")]
public virtual Task`1<Response`1<DataLakePathClient>> RenameAsync(string destinationPath, string destinationFileSystem, DataLakeRequestConditions sourceConditions, DataLakeRequestConditions destinationConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<RenameInternal>d__79")]
private Task`1<Response`1<DataLakePathClient>> RenameInternal(string destinationPath, string destinationFileSystem, DataLakeRequestConditions sourceConditions, DataLakeRequestConditions destinationConditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<PathAccessControl> GetAccessControl(Nullable`1<bool> userPrincipalName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<GetAccessControlAsync>d__81")]
public virtual Task`1<Response`1<PathAccessControl>> GetAccessControlAsync(Nullable`1<bool> userPrincipalName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<GetAccessControlInternal>d__82")]
private Task`1<Response`1<PathAccessControl>> GetAccessControlInternal(Nullable`1<bool> userPrincipalName, DataLakeRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<PathInfo> SetAccessControlList(IList`1<PathAccessControlItem> accessControlList, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<SetAccessControlListAsync>d__84")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<PathInfo>> SetAccessControlListAsync(IList`1<PathAccessControlItem> accessControlList, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<SetAccessControlListInternal>d__85")]
private Task`1<Response`1<PathInfo>> SetAccessControlListInternal(IList`1<PathAccessControlItem> accessControlList, string owner, string group, DataLakeRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<AccessControlChangeResult> SetAccessControlRecursive(IList`1<PathAccessControlItem> accessControlList, string continuationToken, AccessControlChangeOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<SetAccessControlRecursiveAsync>d__87")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<AccessControlChangeResult>> SetAccessControlRecursiveAsync(IList`1<PathAccessControlItem> accessControlList, string continuationToken, AccessControlChangeOptions options, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<AccessControlChangeResult> UpdateAccessControlRecursive(IList`1<PathAccessControlItem> accessControlList, string continuationToken, AccessControlChangeOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<UpdateAccessControlRecursiveAsync>d__89")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<AccessControlChangeResult>> UpdateAccessControlRecursiveAsync(IList`1<PathAccessControlItem> accessControlList, string continuationToken, AccessControlChangeOptions options, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<AccessControlChangeResult> RemoveAccessControlRecursive(IList`1<RemovePathAccessControlItem> accessControlList, string continuationToken, AccessControlChangeOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<RemoveAccessControlRecursiveAsync>d__91")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<AccessControlChangeResult>> RemoveAccessControlRecursiveAsync(IList`1<RemovePathAccessControlItem> accessControlList, string continuationToken, AccessControlChangeOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<SetAccessControlRecursiveInternal>d__92")]
private Task`1<Response`1<AccessControlChangeResult>> SetAccessControlRecursiveInternal(string operationName, string accessControlList, PathSetAccessControlRecursiveMode mode, string continuationToken, AccessControlChangeOptions options, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<PathInfo> SetPermissions(PathPermissions permissions, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<SetPermissionsAsync>d__94")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<PathInfo>> SetPermissionsAsync(PathPermissions permissions, string owner, string group, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<SetPermissionsInternal>d__95")]
private Task`1<Response`1<PathInfo>> SetPermissionsInternal(PathPermissions permissions, string owner, string group, DataLakeRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<PathProperties> GetProperties(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<GetPropertiesAsync>d__97")]
public virtual Task`1<Response`1<PathProperties>> GetPropertiesAsync(DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> SetHttpHeaders(PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<SetHttpHeadersAsync>d__99")]
public virtual Task`1<Response`1<PathInfo>> SetHttpHeadersAsync(PathHttpHeaders httpHeaders, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PathInfo> SetMetadata(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakePathClient/<SetMetadataAsync>d__101")]
public virtual Task`1<Response`1<PathInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasPermissions permissions, DateTimeOffset expiresOn);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasPermissions permissions, DateTimeOffset expiresOn, String& stringToSign);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasBuilder builder);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Uri GenerateSasUri(DataLakeSasBuilder builder, String& stringToSign);
    protected internal virtual DataLakeFileSystemClient GetParentFileSystemClientCore();
    protected internal virtual DataLakeDirectoryClient GetParentDirectoryClientCore();
}
internal class Azure.Storage.Files.DataLake.DataLakeQueryErrorHandler : object {
    private Action`1<DataLakeQueryError> _errorHandler;
    public DataLakeQueryErrorHandler(Action`1<DataLakeQueryError> errorHandler);
    public void Handle(BlobQueryError blobQueryError);
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.DataLakeSerializationExtensions : object {
    [ExtensionAttribute]
internal static SetAccessControlRecursiveResponse DeserializeSetAccessControlRecursiveResponse(JsonElement element);
    [ExtensionAttribute]
internal static AclFailedEntry DeserializeAclFailedEntry(JsonElement element);
}
public class Azure.Storage.Files.DataLake.DataLakeServiceClient : object {
    private BlobServiceClient _blobServiceClient;
    private Uri _uri;
    private Uri _blobUri;
    private DataLakeClientConfiguration _clientConfiguration;
    private string _accountName;
    public Uri Uri { get; }
    internal DataLakeClientConfiguration ClientConfiguration { get; }
    public string AccountName { get; }
    public bool CanGenerateAccountSasUri { get; }
    public DataLakeServiceClient(Uri serviceUri);
    public DataLakeServiceClient(Uri serviceUri, DataLakeClientOptions options);
    public DataLakeServiceClient(string connectionString);
    public DataLakeServiceClient(string connectionString, DataLakeClientOptions options);
    public DataLakeServiceClient(Uri serviceUri, StorageSharedKeyCredential credential);
    public DataLakeServiceClient(Uri serviceUri, StorageSharedKeyCredential credential, DataLakeClientOptions options);
    public DataLakeServiceClient(Uri serviceUri, AzureSasCredential credential);
    public DataLakeServiceClient(Uri serviceUri, AzureSasCredential credential, DataLakeClientOptions options);
    public DataLakeServiceClient(Uri serviceUri, TokenCredential credential);
    public DataLakeServiceClient(Uri serviceUri, TokenCredential credential, DataLakeClientOptions options);
    internal DataLakeServiceClient(Uri fileSystemUri, DataLakeClientConfiguration clientConfiguration);
    internal DataLakeServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, DataLakeClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    public virtual Uri get_Uri();
    internal virtual DataLakeClientConfiguration get_ClientConfiguration();
    public virtual string get_AccountName();
    public virtual bool get_CanGenerateAccountSasUri();
    public virtual DataLakeFileSystemClient GetFileSystemClient(string fileSystemName);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response`1<UserDelegationKey> GetUserDelegationKey(Nullable`1<DateTimeOffset> startsOn, DateTimeOffset expiresOn, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeServiceClient/<GetUserDelegationKeyAsync>d__29")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response`1<UserDelegationKey>> GetUserDelegationKeyAsync(Nullable`1<DateTimeOffset> startsOn, DateTimeOffset expiresOn, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Pageable`1<FileSystemItem> GetFileSystems(FileSystemTraits traits, FileSystemStates states, string prefix, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual AsyncPageable`1<FileSystemItem> GetFileSystemsAsync(FileSystemTraits traits, FileSystemStates states, string prefix, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ForwardsClientCallsAttribute]
public virtual Pageable`1<FileSystemItem> GetFileSystems(FileSystemTraits traits, string prefix, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ForwardsClientCallsAttribute]
public virtual AsyncPageable`1<FileSystemItem> GetFileSystemsAsync(FileSystemTraits traits, string prefix, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeFileSystemClient> CreateFileSystem(string fileSystemName, DataLakeFileSystemCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeServiceClient/<CreateFileSystemAsync>d__35")]
public virtual Task`1<Response`1<DataLakeFileSystemClient>> CreateFileSystemAsync(string fileSystemName, DataLakeFileSystemCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<DataLakeFileSystemClient> CreateFileSystem(string fileSystemName, PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeServiceClient/<CreateFileSystemAsync>d__37")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<DataLakeFileSystemClient>> CreateFileSystemAsync(string fileSystemName, PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    public virtual Response DeleteFileSystem(string fileSystemName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeServiceClient/<DeleteFileSystemAsync>d__39")]
public virtual Task`1<Response> DeleteFileSystemAsync(string fileSystemName, DataLakeRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<DataLakeFileSystemClient> UndeleteFileSystem(string deletedFileSystemName, string deleteFileSystemVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeServiceClient/<UndeleteFileSystemAsync>d__41")]
public virtual Task`1<Response`1<DataLakeFileSystemClient>> UndeleteFileSystemAsync(string deletedFileSystemName, string deleteFileSystemVersion, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public Uri GenerateAccountSasUri(AccountSasPermissions permissions, DateTimeOffset expiresOn, AccountSasResourceTypes resourceTypes);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public Uri GenerateAccountSasUri(AccountSasPermissions permissions, DateTimeOffset expiresOn, AccountSasResourceTypes resourceTypes, String& stringToSign);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public Uri GenerateAccountSasUri(AccountSasBuilder builder);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public Uri GenerateAccountSasUri(AccountSasBuilder builder, String& stringToSign);
    public virtual Response`1<DataLakeServiceProperties> GetProperties(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeServiceClient/<GetPropertiesAsync>d__47")]
public virtual Task`1<Response`1<DataLakeServiceProperties>> GetPropertiesAsync(CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Response SetProperties(DataLakeServiceProperties properties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.DataLakeServiceClient/<SetPropertiesAsync>d__49")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public virtual Task`1<Response> SetPropertiesAsync(DataLakeServiceProperties properties, CancellationToken cancellationToken);
}
public class Azure.Storage.Files.DataLake.DataLakeUriBuilder : object {
    private Uri _uri;
    private bool _isIPStyleUri;
    private string _scheme;
    private string _host;
    private int _port;
    private string _accountName;
    private string _fileSystemName;
    private string _directoryOrFilePath;
    private string _snapshot;
    private DataLakeSasQueryParameters _sas;
    private string _query;
    public string Scheme { get; public set; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public string AccountName { get; public set; }
    public string FileSystemName { get; public set; }
    public string DirectoryOrFilePath { get; public set; }
    public string Snapshot { get; public set; }
    public DataLakeSasQueryParameters Sas { get; public set; }
    internal string LastDirectoryOrFileName { get; }
    public string Query { get; public set; }
    public DataLakeUriBuilder(Uri uri);
    public string get_Scheme();
    public void set_Scheme(string value);
    public string get_Host();
    public void set_Host(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_AccountName();
    public void set_AccountName(string value);
    public string get_FileSystemName();
    public void set_FileSystemName(string value);
    public string get_DirectoryOrFilePath();
    public void set_DirectoryOrFilePath(string value);
    public string get_Snapshot();
    public void set_Snapshot(string value);
    public DataLakeSasQueryParameters get_Sas();
    public void set_Sas(DataLakeSasQueryParameters value);
    internal string get_LastDirectoryOrFileName();
    public string get_Query();
    public void set_Query(string value);
    public Uri ToUri();
    internal Uri ToBlobUri();
    internal Uri ToDfsUri();
    public virtual string ToString();
    private void ResetUri();
    private RequestUriBuilder BuildUri();
}
internal class Azure.Storage.Files.DataLake.FileSystemCreateHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string NamespaceEnabled { get; }
    public FileSystemCreateHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_NamespaceEnabled();
}
internal class Azure.Storage.Files.DataLake.FileSystemDeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public FileSystemDeleteHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Files.DataLake.FileSystemGetPropertiesHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string Properties { get; }
    public string NamespaceEnabled { get; }
    public FileSystemGetPropertiesHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_Properties();
    public string get_NamespaceEnabled();
}
internal class Azure.Storage.Files.DataLake.FileSystemListBlobHierarchySegmentHeaders : object {
    private Response _response;
    public string ContentType { get; }
    public string Version { get; }
    public FileSystemListBlobHierarchySegmentHeaders(Response response);
    public string get_ContentType();
    public string get_Version();
}
internal class Azure.Storage.Files.DataLake.FileSystemListPathsHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string Continuation { get; }
    public FileSystemListPathsHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_Continuation();
}
internal class Azure.Storage.Files.DataLake.FileSystemRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _resource;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public FileSystemRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string resource, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateCreateRequest(Nullable`1<int> timeout, string properties);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.FileSystemRestClient/<CreateAsync>d__9")]
public Task`1<ResponseWithHeaders`1<FileSystemCreateHeaders>> CreateAsync(Nullable`1<int> timeout, string properties, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileSystemCreateHeaders> Create(Nullable`1<int> timeout, string properties, CancellationToken cancellationToken);
    internal HttpMessage CreateSetPropertiesRequest(Nullable`1<int> timeout, string properties, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.FileSystemRestClient/<SetPropertiesAsync>d__12")]
public Task`1<ResponseWithHeaders`1<FileSystemSetPropertiesHeaders>> SetPropertiesAsync(Nullable`1<int> timeout, string properties, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileSystemSetPropertiesHeaders> SetProperties(Nullable`1<int> timeout, string properties, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.FileSystemRestClient/<GetPropertiesAsync>d__15")]
public Task`1<ResponseWithHeaders`1<FileSystemGetPropertiesHeaders>> GetPropertiesAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileSystemGetPropertiesHeaders> GetProperties(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateDeleteRequest(Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.FileSystemRestClient/<DeleteAsync>d__18")]
public Task`1<ResponseWithHeaders`1<FileSystemDeleteHeaders>> DeleteAsync(Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileSystemDeleteHeaders> Delete(Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateListPathsRequest(bool recursive, Nullable`1<int> timeout, string continuation, string path, Nullable`1<int> maxResults, Nullable`1<bool> upn);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.FileSystemRestClient/<ListPathsAsync>d__21")]
public Task`1<ResponseWithHeaders`2<PathList, FileSystemListPathsHeaders>> ListPathsAsync(bool recursive, Nullable`1<int> timeout, string continuation, string path, Nullable`1<int> maxResults, Nullable`1<bool> upn, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<PathList, FileSystemListPathsHeaders> ListPaths(bool recursive, Nullable`1<int> timeout, string continuation, string path, Nullable`1<int> maxResults, Nullable`1<bool> upn, CancellationToken cancellationToken);
    internal HttpMessage CreateListBlobHierarchySegmentRequest(string prefix, string delimiter, string marker, Nullable`1<int> maxResults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<ListBlobsShowOnly> showonly, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.FileSystemRestClient/<ListBlobHierarchySegmentAsync>d__24")]
public Task`1<ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, FileSystemListBlobHierarchySegmentHeaders>> ListBlobHierarchySegmentAsync(string prefix, string delimiter, string marker, Nullable`1<int> maxResults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<ListBlobsShowOnly> showonly, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, FileSystemListBlobHierarchySegmentHeaders> ListBlobHierarchySegment(string prefix, string delimiter, string marker, Nullable`1<int> maxResults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<ListBlobsShowOnly> showonly, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateListBlobHierarchySegmentNextPageRequest(string nextLink, string prefix, string delimiter, string marker, Nullable`1<int> maxResults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<ListBlobsShowOnly> showonly, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.FileSystemRestClient/<ListBlobHierarchySegmentNextPageAsync>d__27")]
public Task`1<ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, FileSystemListBlobHierarchySegmentHeaders>> ListBlobHierarchySegmentNextPageAsync(string nextLink, string prefix, string delimiter, string marker, Nullable`1<int> maxResults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<ListBlobsShowOnly> showonly, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, FileSystemListBlobHierarchySegmentHeaders> ListBlobHierarchySegmentNextPage(string nextLink, string prefix, string delimiter, string marker, Nullable`1<int> maxResults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<ListBlobsShowOnly> showonly, Nullable`1<int> timeout, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.DataLake.FileSystemSetPropertiesHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public FileSystemSetPropertiesHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
public class Azure.Storage.Files.DataLake.Models.AccessControlChangeCounters : ValueType {
    [CompilerGeneratedAttribute]
private long <ChangedDirectoriesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ChangedFilesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FailedChangesCount>k__BackingField;
    public long ChangedDirectoriesCount { get; internal set; }
    public long ChangedFilesCount { get; internal set; }
    public long FailedChangesCount { get; internal set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_ChangedDirectoriesCount();
    [CompilerGeneratedAttribute]
internal void set_ChangedDirectoriesCount(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_ChangedFilesCount();
    [CompilerGeneratedAttribute]
internal void set_ChangedFilesCount(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_FailedChangesCount();
    [CompilerGeneratedAttribute]
internal void set_FailedChangesCount(long value);
}
public class Azure.Storage.Files.DataLake.Models.AccessControlChangeFailure : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public string Name { get; internal set; }
    public bool IsDirectory { get; internal set; }
    public string ErrorMessage { get; internal set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsDirectory();
    [CompilerGeneratedAttribute]
internal void set_IsDirectory(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
internal void set_ErrorMessage(string value);
}
public class Azure.Storage.Files.DataLake.Models.AccessControlChangeOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxBatches>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ContinueOnFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<Response`1<AccessControlChanges>> <ProgressHandler>k__BackingField;
    public Nullable`1<int> BatchSize { get; public set; }
    public Nullable`1<int> MaxBatches { get; public set; }
    public Nullable`1<bool> ContinueOnFailure { get; public set; }
    public IProgress`1<Response`1<AccessControlChanges>> ProgressHandler { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxBatches();
    [CompilerGeneratedAttribute]
public void set_MaxBatches(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ContinueOnFailure();
    [CompilerGeneratedAttribute]
public void set_ContinueOnFailure(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public IProgress`1<Response`1<AccessControlChanges>> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<Response`1<AccessControlChanges>> value);
}
public class Azure.Storage.Files.DataLake.Models.AccessControlChangeResult : ValueType {
    [CompilerGeneratedAttribute]
private AccessControlChangeCounters <Counters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessControlChangeFailure[] <BatchFailures>k__BackingField;
    public AccessControlChangeCounters Counters { get; internal set; }
    public string ContinuationToken { get; internal set; }
    public AccessControlChangeFailure[] BatchFailures { get; internal set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AccessControlChangeCounters get_Counters();
    [CompilerGeneratedAttribute]
internal void set_Counters(AccessControlChangeCounters value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ContinuationToken();
    [CompilerGeneratedAttribute]
internal void set_ContinuationToken(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AccessControlChangeFailure[] get_BatchFailures();
    [CompilerGeneratedAttribute]
internal void set_BatchFailures(AccessControlChangeFailure[] value);
}
public class Azure.Storage.Files.DataLake.Models.AccessControlChanges : ValueType {
    [CompilerGeneratedAttribute]
private AccessControlChangeFailure[] <BatchFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessControlChangeCounters <BatchCounters>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessControlChangeCounters <AggregateCounters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    public AccessControlChangeFailure[] BatchFailures { get; internal set; }
    public AccessControlChangeCounters BatchCounters { get; internal set; }
    public AccessControlChangeCounters AggregateCounters { get; internal set; }
    public string ContinuationToken { get; internal set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AccessControlChangeFailure[] get_BatchFailures();
    [CompilerGeneratedAttribute]
internal void set_BatchFailures(AccessControlChangeFailure[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AccessControlChangeCounters get_BatchCounters();
    [CompilerGeneratedAttribute]
internal void set_BatchCounters(AccessControlChangeCounters value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AccessControlChangeCounters get_AggregateCounters();
    [CompilerGeneratedAttribute]
internal void set_AggregateCounters(AccessControlChangeCounters value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ContinuationToken();
    [CompilerGeneratedAttribute]
internal void set_ContinuationToken(string value);
}
public enum Azure.Storage.Files.DataLake.Models.AccessControlType : Enum {
    public int value__;
    public static AccessControlType Other;
    public static AccessControlType User;
    public static AccessControlType Group;
    public static AccessControlType Mask;
}
internal class Azure.Storage.Files.DataLake.Models.AclFailedEntry : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public string Name { get; public set; }
    public string Type { get; public set; }
    public string ErrorMessage { get; public set; }
    internal AclFailedEntry(string name, string type, string errorMessage);
    internal static AclFailedEntry DeserializeAclFailedEntry(JsonElement element);
    internal static AclFailedEntry FromResponse(Response response);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
}
internal class Azure.Storage.Files.DataLake.Models.BlobHierarchyListSegment : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<BlobPrefix> <BlobPrefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<BlobItemInternal> <BlobItems>k__BackingField;
    public IReadOnlyList`1<BlobPrefix> BlobPrefixes { get; }
    public IReadOnlyList`1<BlobItemInternal> BlobItems { get; }
    internal BlobHierarchyListSegment(IEnumerable`1<BlobItemInternal> blobItems);
    internal BlobHierarchyListSegment(IReadOnlyList`1<BlobPrefix> blobPrefixes, IReadOnlyList`1<BlobItemInternal> blobItems);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<BlobPrefix> get_BlobPrefixes();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<BlobItemInternal> get_BlobItems();
    internal static BlobHierarchyListSegment DeserializeBlobHierarchyListSegment(XElement element);
}
internal class Azure.Storage.Files.DataLake.Models.BlobItemInternal : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsCurrentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobPropertiesInternal <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeletionId>k__BackingField;
    public string Name { get; }
    public bool Deleted { get; }
    public string Snapshot { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsCurrentVersion { get; }
    public BlobPropertiesInternal Properties { get; }
    public string DeletionId { get; }
    internal BlobItemInternal(string name, bool deleted, string snapshot, BlobPropertiesInternal properties);
    internal BlobItemInternal(string name, bool deleted, string snapshot, string versionId, Nullable`1<bool> isCurrentVersion, BlobPropertiesInternal properties, string deletionId);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Deleted();
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsCurrentVersion();
    [CompilerGeneratedAttribute]
public BlobPropertiesInternal get_Properties();
    [CompilerGeneratedAttribute]
public string get_DeletionId();
    internal static BlobItemInternal DeserializeBlobItemInternal(XElement element);
}
internal class Azure.Storage.Files.DataLake.Models.BlobPrefix : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    internal BlobPrefix(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    internal static BlobPrefix DeserializeBlobPrefix(XElement element);
}
internal class Azure.Storage.Files.DataLake.Models.BlobPropertiesInternal : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentMD5>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BlobSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CopyCompletionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyStatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncrementalCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RemainingRetentionDays>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AccessTierInferred>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomerProvidedKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <AccessTierChangeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TagCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsSealed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastAccessedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeleteTime>k__BackingField;
    public Nullable`1<DateTimeOffset> CreationTime { get; }
    public DateTimeOffset LastModified { get; }
    public string Etag { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentType { get; }
    public string ContentEncoding { get; }
    public string ContentLanguage { get; }
    public Byte[] ContentMD5 { get; }
    public string ContentDisposition { get; }
    public string CacheControl { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public string CopyId { get; }
    public string CopySource { get; }
    public string CopyProgress { get; }
    public Nullable`1<DateTimeOffset> CopyCompletionTime { get; }
    public string CopyStatusDescription { get; }
    public Nullable`1<bool> ServerEncrypted { get; }
    public Nullable`1<bool> IncrementalCopy { get; }
    public string DestinationSnapshot { get; }
    public Nullable`1<DateTimeOffset> DeletedTime { get; }
    public Nullable`1<int> RemainingRetentionDays { get; }
    public Nullable`1<bool> AccessTierInferred { get; }
    public string CustomerProvidedKeySha256 { get; }
    public string EncryptionScope { get; }
    public Nullable`1<DateTimeOffset> AccessTierChangeTime { get; }
    public Nullable`1<int> TagCount { get; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; }
    public Nullable`1<bool> IsSealed { get; }
    public Nullable`1<DateTimeOffset> LastAccessedOn { get; }
    public Nullable`1<DateTimeOffset> DeleteTime { get; }
    internal BlobPropertiesInternal(DateTimeOffset lastModified, string etag);
    internal BlobPropertiesInternal(Nullable`1<DateTimeOffset> creationTime, DateTimeOffset lastModified, string etag, Nullable`1<long> contentLength, string contentType, string contentEncoding, string contentLanguage, Byte[] contentMD5, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, string copyId, string copySource, string copyProgress, Nullable`1<DateTimeOffset> copyCompletionTime, string copyStatusDescription, Nullable`1<bool> serverEncrypted, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<DateTimeOffset> deletedTime, Nullable`1<int> remainingRetentionDays, Nullable`1<bool> accessTierInferred, string customerProvidedKeySha256, string encryptionScope, Nullable`1<DateTimeOffset> accessTierChangeTime, Nullable`1<int> tagCount, Nullable`1<DateTimeOffset> expiresOn, Nullable`1<bool> isSealed, Nullable`1<DateTimeOffset> lastAccessedOn, Nullable`1<DateTimeOffset> deleteTime);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreationTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
public string get_Etag();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ContentLength();
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
public Byte[] get_ContentMD5();
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BlobSequenceNumber();
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
public string get_CopySource();
    [CompilerGeneratedAttribute]
public string get_CopyProgress();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CopyCompletionTime();
    [CompilerGeneratedAttribute]
public string get_CopyStatusDescription();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ServerEncrypted();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncrementalCopy();
    [CompilerGeneratedAttribute]
public string get_DestinationSnapshot();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedTime();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RemainingRetentionDays();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AccessTierInferred();
    [CompilerGeneratedAttribute]
public string get_CustomerProvidedKeySha256();
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_AccessTierChangeTime();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TagCount();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSealed();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastAccessedOn();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeleteTime();
    internal static BlobPropertiesInternal DeserializeBlobPropertiesInternal(XElement element);
}
public enum Azure.Storage.Files.DataLake.Models.CopyStatus : Enum {
    public int value__;
    public static CopyStatus Pending;
    public static CopyStatus Success;
    public static CopyStatus Aborted;
    public static CopyStatus Failed;
}
public class Azure.Storage.Files.DataLake.Models.DataLakeAccessOptions : object {
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Umask>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PathAccessControlItem> <AccessControlList>k__BackingField;
    public string Permissions { get; public set; }
    public string Umask { get; public set; }
    public string Owner { get; public set; }
    public string Group { get; public set; }
    public IList`1<PathAccessControlItem> AccessControlList { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(string value);
    [CompilerGeneratedAttribute]
public string get_Umask();
    [CompilerGeneratedAttribute]
public void set_Umask(string value);
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(string value);
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public IList`1<PathAccessControlItem> get_AccessControlList();
    [CompilerGeneratedAttribute]
public void set_AccessControlList(IList`1<PathAccessControlItem> value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeAccessPolicy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <PolicyStartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <PolicyExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    public Nullable`1<DateTimeOffset> PolicyStartsOn { get; public set; }
    public Nullable`1<DateTimeOffset> PolicyExpiresOn { get; public set; }
    [EditorBrowsableAttribute("1")]
public DateTimeOffset StartsOn { get; public set; }
    [EditorBrowsableAttribute("1")]
public DateTimeOffset ExpiresOn { get; public set; }
    public string Permissions { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_PolicyStartsOn();
    [CompilerGeneratedAttribute]
public void set_PolicyStartsOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_PolicyExpiresOn();
    [CompilerGeneratedAttribute]
public void set_PolicyExpiresOn(Nullable`1<DateTimeOffset> value);
    public DateTimeOffset get_StartsOn();
    public void set_StartsOn(DateTimeOffset value);
    public DateTimeOffset get_ExpiresOn();
    public void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(string value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeAclChangeFailedException : Exception {
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    public string ContinuationToken { get; }
    public DataLakeAclChangeFailedException(string message, Exception exception, string continuationToken);
    public DataLakeAclChangeFailedException(string message, RequestFailedException exception, string continuationToken);
    protected DataLakeAclChangeFailedException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_ContinuationToken();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeAnalyticsLogging : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Delete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Read>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Write>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeRetentionPolicy <RetentionPolicy>k__BackingField;
    public string Version { get; public set; }
    public bool Delete { get; public set; }
    public bool Read { get; public set; }
    public bool Write { get; public set; }
    public DataLakeRetentionPolicy RetentionPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Delete();
    [CompilerGeneratedAttribute]
public void set_Delete(bool value);
    [CompilerGeneratedAttribute]
public bool get_Read();
    [CompilerGeneratedAttribute]
public void set_Read(bool value);
    [CompilerGeneratedAttribute]
public bool get_Write();
    [CompilerGeneratedAttribute]
public void set_Write(bool value);
    [CompilerGeneratedAttribute]
public DataLakeRetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(DataLakeRetentionPolicy value);
}
[IsReadOnlyAttribute]
public class Azure.Storage.Files.DataLake.Models.DataLakeAudience : ValueType {
    private string _value;
    private static string _defaultAudience;
    [CompilerGeneratedAttribute]
private static DataLakeAudience <DefaultAudience>k__BackingField;
    public static DataLakeAudience DefaultAudience { get; }
    public DataLakeAudience(string value);
    private static DataLakeAudience();
    [CompilerGeneratedAttribute]
public static DataLakeAudience get_DefaultAudience();
    public static DataLakeAudience CreateDataLakeServiceAccountAudience(string storageAccountName);
    public static bool op_Equality(DataLakeAudience left, DataLakeAudience right);
    public static bool op_Inequality(DataLakeAudience left, DataLakeAudience right);
    public static DataLakeAudience op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DataLakeAudience other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    internal string CreateDefaultScope();
}
public class Azure.Storage.Files.DataLake.Models.DataLakeCorsRule : object {
    [CompilerGeneratedAttribute]
private string <AllowedOrigins>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowedHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExposedHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAgeInSeconds>k__BackingField;
    public string AllowedOrigins { get; public set; }
    public string AllowedMethods { get; public set; }
    public string AllowedHeaders { get; public set; }
    public string ExposedHeaders { get; public set; }
    public int MaxAgeInSeconds { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AllowedOrigins();
    [CompilerGeneratedAttribute]
public void set_AllowedOrigins(string value);
    [CompilerGeneratedAttribute]
public string get_AllowedMethods();
    [CompilerGeneratedAttribute]
public void set_AllowedMethods(string value);
    [CompilerGeneratedAttribute]
public string get_AllowedHeaders();
    [CompilerGeneratedAttribute]
public void set_AllowedHeaders(string value);
    [CompilerGeneratedAttribute]
public string get_ExposedHeaders();
    [CompilerGeneratedAttribute]
public void set_ExposedHeaders(string value);
    [CompilerGeneratedAttribute]
public int get_MaxAgeInSeconds();
    [CompilerGeneratedAttribute]
public void set_MaxAgeInSeconds(int value);
}
[IsReadOnlyAttribute]
public class Azure.Storage.Files.DataLake.Models.DataLakeCustomerProvidedKey : ValueType {
    [CompilerGeneratedAttribute]
private string <EncryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeyHash>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeEncryptionAlgorithmType <EncryptionAlgorithm>k__BackingField;
    public string EncryptionKey { get; }
    public string EncryptionKeyHash { get; }
    public DataLakeEncryptionAlgorithmType EncryptionAlgorithm { get; }
    public DataLakeCustomerProvidedKey(string key);
    public DataLakeCustomerProvidedKey(Byte[] key);
    [CompilerGeneratedAttribute]
public string get_EncryptionKey();
    [CompilerGeneratedAttribute]
public string get_EncryptionKeyHash();
    [CompilerGeneratedAttribute]
public DataLakeEncryptionAlgorithmType get_EncryptionAlgorithm();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DataLakeCustomerProvidedKey left, DataLakeCustomerProvidedKey right);
    public static bool op_Inequality(DataLakeCustomerProvidedKey left, DataLakeCustomerProvidedKey right);
    public sealed virtual bool Equals(DataLakeCustomerProvidedKey other);
    public virtual string ToString();
}
public enum Azure.Storage.Files.DataLake.Models.DataLakeEncryptionAlgorithmType : Enum {
    public int value__;
    public static DataLakeEncryptionAlgorithmType Aes256;
}
public class Azure.Storage.Files.DataLake.Models.DataLakeFileAppendOptions : object {
    [CompilerGeneratedAttribute]
private string <LeaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DataLakeLeaseAction> <LeaseAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProposedLeaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Flush>k__BackingField;
    public string LeaseId { get; public set; }
    public Nullable`1<DataLakeLeaseAction> LeaseAction { get; public set; }
    public Nullable`1<TimeSpan> LeaseDuration { get; public set; }
    public string ProposedLeaseId { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public Byte[] ContentHash { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    public Nullable`1<bool> Flush { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LeaseId();
    [CompilerGeneratedAttribute]
public void set_LeaseId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DataLakeLeaseAction> get_LeaseAction();
    [CompilerGeneratedAttribute]
public void set_LeaseAction(Nullable`1<DataLakeLeaseAction> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_LeaseDuration();
    [CompilerGeneratedAttribute]
public void set_LeaseDuration(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public string get_ProposedLeaseId();
    [CompilerGeneratedAttribute]
public void set_ProposedLeaseId(string value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Flush();
    [CompilerGeneratedAttribute]
public void set_Flush(Nullable`1<bool> value);
}
public enum Azure.Storage.Files.DataLake.Models.DataLakeFileExpirationOrigin : Enum {
    public int value__;
    public static DataLakeFileExpirationOrigin CreationTime;
    public static DataLakeFileExpirationOrigin Now;
}
public class Azure.Storage.Files.DataLake.Models.DataLakeFileFlushOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <RetainUncommittedData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Close>k__BackingField;
    [CompilerGeneratedAttribute]
private PathHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DataLakeLeaseAction> <LeaseAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProposedLeaseId>k__BackingField;
    public Nullable`1<bool> RetainUncommittedData { get; public set; }
    public Nullable`1<bool> Close { get; public set; }
    public PathHttpHeaders HttpHeaders { get; public set; }
    public DataLakeRequestConditions Conditions { get; public set; }
    public Nullable`1<DataLakeLeaseAction> LeaseAction { get; public set; }
    public Nullable`1<TimeSpan> LeaseDuration { get; public set; }
    public string ProposedLeaseId { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_RetainUncommittedData();
    [CompilerGeneratedAttribute]
public void set_RetainUncommittedData(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Close();
    [CompilerGeneratedAttribute]
public void set_Close(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public PathHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(PathHttpHeaders value);
    [CompilerGeneratedAttribute]
public DataLakeRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(DataLakeRequestConditions value);
    [CompilerGeneratedAttribute]
public Nullable`1<DataLakeLeaseAction> get_LeaseAction();
    [CompilerGeneratedAttribute]
public void set_LeaseAction(Nullable`1<DataLakeLeaseAction> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_LeaseDuration();
    [CompilerGeneratedAttribute]
public void set_LeaseDuration(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public string get_ProposedLeaseId();
    [CompilerGeneratedAttribute]
public void set_ProposedLeaseId(string value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeFileOpenWriteOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeRequestConditions <OpenConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Close>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public Nullable`1<long> BufferSize { get; public set; }
    public DataLakeRequestConditions OpenConditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public Nullable`1<bool> Close { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public DataLakeRequestConditions get_OpenConditions();
    [CompilerGeneratedAttribute]
public void set_OpenConditions(DataLakeRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Close();
    [CompilerGeneratedAttribute]
public void set_Close(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeFileReadOptions : object {
    [CompilerGeneratedAttribute]
private HttpRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private DownloadTransferValidationOptions <TransferValidation>k__BackingField;
    public HttpRange Range { get; public set; }
    public DataLakeRequestConditions Conditions { get; public set; }
    public DownloadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public HttpRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(HttpRange value);
    [CompilerGeneratedAttribute]
public DataLakeRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(DataLakeRequestConditions value);
    [CompilerGeneratedAttribute]
public DownloadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(DownloadTransferValidationOptions value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeFileReadToOptions : object {
    [CompilerGeneratedAttribute]
private DataLakeRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageTransferOptions <TransferOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private DownloadTransferValidationOptions <TransferValidation>k__BackingField;
    public DataLakeRequestConditions Conditions { get; public set; }
    public StorageTransferOptions TransferOptions { get; public set; }
    public DownloadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public DataLakeRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(DataLakeRequestConditions value);
    [CompilerGeneratedAttribute]
public StorageTransferOptions get_TransferOptions();
    [CompilerGeneratedAttribute]
public void set_TransferOptions(StorageTransferOptions value);
    [CompilerGeneratedAttribute]
public DownloadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(DownloadTransferValidationOptions value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeFileScheduleDeletionOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <TimeToExpire>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DataLakeFileExpirationOrigin> <SetExpiryRelativeTo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    public Nullable`1<TimeSpan> TimeToExpire { get; private set; }
    public Nullable`1<DataLakeFileExpirationOrigin> SetExpiryRelativeTo { get; private set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; private set; }
    public DataLakeFileScheduleDeletionOptions(Nullable`1<DateTimeOffset> expiresOn);
    public DataLakeFileScheduleDeletionOptions(TimeSpan timeToExpire, DataLakeFileExpirationOrigin setRelativeTo);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_TimeToExpire();
    [CompilerGeneratedAttribute]
private void set_TimeToExpire(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DataLakeFileExpirationOrigin> get_SetExpiryRelativeTo();
    [CompilerGeneratedAttribute]
private void set_SetExpiryRelativeTo(Nullable`1<DataLakeFileExpirationOrigin> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
private void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeFileSystemCreateOptions : object {
    [CompilerGeneratedAttribute]
private PublicAccessType <PublicAccessType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeFileSystemEncryptionScopeOptions <EncryptionScopeOptions>k__BackingField;
    public PublicAccessType PublicAccessType { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public DataLakeFileSystemEncryptionScopeOptions EncryptionScopeOptions { get; public set; }
    [CompilerGeneratedAttribute]
public PublicAccessType get_PublicAccessType();
    [CompilerGeneratedAttribute]
public void set_PublicAccessType(PublicAccessType value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public DataLakeFileSystemEncryptionScopeOptions get_EncryptionScopeOptions();
    [CompilerGeneratedAttribute]
public void set_EncryptionScopeOptions(DataLakeFileSystemEncryptionScopeOptions value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeFileSystemEncryptionScopeOptions : object {
    [CompilerGeneratedAttribute]
private string <DefaultEncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventEncryptionScopeOverride>k__BackingField;
    public string DefaultEncryptionScope { get; public set; }
    public bool PreventEncryptionScopeOverride { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultEncryptionScope();
    [CompilerGeneratedAttribute]
public void set_DefaultEncryptionScope(string value);
    [CompilerGeneratedAttribute]
public bool get_PreventEncryptionScopeOverride();
    [CompilerGeneratedAttribute]
public void set_PreventEncryptionScopeOverride(bool value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeFileUploadOptions : object {
    [CompilerGeneratedAttribute]
private PathHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Umask>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Close>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageTransferOptions <TransferOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionContext>k__BackingField;
    public PathHttpHeaders HttpHeaders { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public string Permissions { get; public set; }
    public string Umask { get; public set; }
    public DataLakeRequestConditions Conditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public Nullable`1<bool> Close { get; public set; }
    public StorageTransferOptions TransferOptions { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    public string EncryptionContext { get; public set; }
    [CompilerGeneratedAttribute]
public PathHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(PathHttpHeaders value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(string value);
    [CompilerGeneratedAttribute]
public string get_Umask();
    [CompilerGeneratedAttribute]
public void set_Umask(string value);
    [CompilerGeneratedAttribute]
public DataLakeRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(DataLakeRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Close();
    [CompilerGeneratedAttribute]
public void set_Close(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public StorageTransferOptions get_TransferOptions();
    [CompilerGeneratedAttribute]
public void set_TransferOptions(StorageTransferOptions value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
    [CompilerGeneratedAttribute]
public string get_EncryptionContext();
    [CompilerGeneratedAttribute]
public void set_EncryptionContext(string value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeLease : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LeaseTime>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public string LeaseId { get; internal set; }
    public Nullable`1<int> LeaseTime { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_LeaseId();
    [CompilerGeneratedAttribute]
internal void set_LeaseId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LeaseTime();
    [CompilerGeneratedAttribute]
internal void set_LeaseTime(Nullable`1<int> value);
}
public enum Azure.Storage.Files.DataLake.Models.DataLakeLeaseAction : Enum {
    public int value__;
    public static DataLakeLeaseAction Acquire;
    public static DataLakeLeaseAction AutoRenew;
    public static DataLakeLeaseAction Release;
    public static DataLakeLeaseAction AcquireRelease;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.Models.DataLakeLeaseActionExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(DataLakeLeaseAction value);
    [ExtensionAttribute]
public static DataLakeLeaseAction ToDataLakeLeaseAction(string value);
}
public enum Azure.Storage.Files.DataLake.Models.DataLakeLeaseDuration : Enum {
    public int value__;
    public static DataLakeLeaseDuration Infinite;
    public static DataLakeLeaseDuration Fixed;
}
public enum Azure.Storage.Files.DataLake.Models.DataLakeLeaseState : Enum {
    public int value__;
    public static DataLakeLeaseState Available;
    public static DataLakeLeaseState Leased;
    public static DataLakeLeaseState Expired;
    public static DataLakeLeaseState Breaking;
    public static DataLakeLeaseState Broken;
}
public enum Azure.Storage.Files.DataLake.Models.DataLakeLeaseStatus : Enum {
    public int value__;
    public static DataLakeLeaseStatus Locked;
    public static DataLakeLeaseStatus Unlocked;
}
public class Azure.Storage.Files.DataLake.Models.DataLakeMetrics : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeRetentionPolicy <RetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeApis>k__BackingField;
    public string Version { get; public set; }
    public bool Enabled { get; public set; }
    public DataLakeRetentionPolicy RetentionPolicy { get; public set; }
    public Nullable`1<bool> IncludeApis { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public DataLakeRetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(DataLakeRetentionPolicy value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeApis();
    [CompilerGeneratedAttribute]
public void set_IncludeApis(Nullable`1<bool> value);
}
public static class Azure.Storage.Files.DataLake.Models.DataLakeModelFactory : object {
    public static FileDownloadDetails FileDownloadDetails(DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, ETag eTag, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, DateTimeOffset copyCompletionTime, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, DataLakeLeaseDuration leaseDuration, DataLakeLeaseState leaseState, DataLakeLeaseStatus leaseStatus, string acceptRanges, bool isServerEncrypted, string encryptionKeySha256, Byte[] contentHash, DateTimeOffset createdOn, string encryptionContext, IList`1<PathAccessControlItem> accessControlList);
    [EditorBrowsableAttribute("1")]
public static FileDownloadDetails FileDownloadDetails(DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, ETag eTag, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, DateTimeOffset copyCompletionTime, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, DataLakeLeaseDuration leaseDuration, DataLakeLeaseState leaseState, DataLakeLeaseStatus leaseStatus, string acceptRanges, bool isServerEncrypted, string encryptionKeySha256, Byte[] contentHash, DateTimeOffset createdOn, string encryptionContext);
    [EditorBrowsableAttribute("1")]
public static FileDownloadDetails FileDownloadDetails(DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, ETag eTag, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, DateTimeOffset copyCompletionTime, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, DataLakeLeaseDuration leaseDuration, DataLakeLeaseState leaseState, DataLakeLeaseStatus leaseStatus, string acceptRanges, bool isServerEncrypted, string encryptionKeySha256, Byte[] contentHash, DateTimeOffset createdOn);
    [EditorBrowsableAttribute("1")]
public static FileDownloadDetails FileDownloadDetails(DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, ETag eTag, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, DateTimeOffset copyCompletionTime, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, DataLakeLeaseDuration leaseDuration, DataLakeLeaseState leaseState, DataLakeLeaseStatus leaseStatus, string acceptRanges, bool isServerEncrypted, string encryptionKeySha256, Byte[] contentHash);
    public static FileDownloadInfo FileDownloadInfo(long contentLength, Stream content, Byte[] contentHash, FileDownloadDetails properties);
    public static FileSystemInfo FileSystemInfo(ETag etag, DateTimeOffset lastModified);
    public static FileSystemItem FileSystemItem(string name, Nullable`1<bool> isDeleted, string versionId, FileSystemProperties properties);
    [EditorBrowsableAttribute("1")]
public static FileSystemItem FileSystemItem(string name, FileSystemProperties properties);
    public static FileSystemProperties FileSystemProperties(DateTimeOffset lastModified, Nullable`1<DataLakeLeaseStatus> leaseStatus, Nullable`1<DataLakeLeaseState> leaseState, Nullable`1<DataLakeLeaseDuration> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<bool> hasLegalHold, ETag eTag, IDictionary`2<string, string> metadata, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<int> remainingRetentionDays);
    [EditorBrowsableAttribute("1")]
public static FileSystemProperties FileSystemProperties(DateTimeOffset lastModified, Nullable`1<DataLakeLeaseStatus> leaseStatus, Nullable`1<DataLakeLeaseState> leaseState, Nullable`1<DataLakeLeaseDuration> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<bool> hasLegalHold, ETag eTag);
    public static DataLakeLease Lease(ETag eTag, DateTimeOffset lastModified, string leaseId, Nullable`1<int> leaseTime);
    public static PathAccessControl PathAccessControl(string owner, string group, PathPermissions permissions, IList`1<PathAccessControlItem> acl);
    public static PathContentInfo PathContentInfo(string contentHash, ETag eTag, DateTimeOffset lastModified, string acceptRanges, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, long contentLength, string contentRange, string contentType, IDictionary`2<string, string> metadata);
    public static PathCreateInfo PathCreateInfo(PathInfo pathInfo, string continuation);
    public static PathInfo PathInfo(ETag eTag, DateTimeOffset lastModified);
    public static PathItem PathItem(string name, Nullable`1<bool> isDirectory, DateTimeOffset lastModified, ETag eTag, Nullable`1<long> contentLength, string owner, string group, string permissions, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> expiresOn, string encryptionContext);
    [EditorBrowsableAttribute("1")]
public static PathItem PathItem(string name, Nullable`1<bool> isDirectory, DateTimeOffset lastModified, ETag eTag, Nullable`1<long> contentLength, string owner, string group, string permissions, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> expiresOn);
    [EditorBrowsableAttribute("1")]
public static PathItem PathItem(string name, Nullable`1<bool> isDirectory, DateTimeOffset lastModified, ETag eTag, Nullable`1<long> contentLength, string owner, string group, string permissions);
    public static PathProperties PathProperties(DateTimeOffset lastModified, DateTimeOffset creationTime, IDictionary`2<string, string> metadata, DateTimeOffset copyCompletionTime, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, bool isIncrementalCopy, DataLakeLeaseDuration leaseDuration, DataLakeLeaseState leaseState, DataLakeLeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, string acceptRanges, bool isServerEncrypted, string encryptionKeySha256, string accessTier, string archiveStatus, DateTimeOffset accessTierChangeTime, bool isDirectory, string encryptionContext, string owner, string group, string permissions, IList`1<PathAccessControlItem> accessControlList);
    [EditorBrowsableAttribute("1")]
public static PathProperties PathProperties(DateTimeOffset lastModified, DateTimeOffset creationTime, IDictionary`2<string, string> metadata, DateTimeOffset copyCompletionTime, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, bool isIncrementalCopy, DataLakeLeaseDuration leaseDuration, DataLakeLeaseState leaseState, DataLakeLeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, string acceptRanges, bool isServerEncrypted, string encryptionKeySha256, string accessTier, string archiveStatus, DateTimeOffset accessTierChangeTime, bool isDirectory, string encryptionContext, string owner, string group, string permissions);
    [EditorBrowsableAttribute("1")]
public static PathProperties PathProperties(DateTimeOffset lastModified, DateTimeOffset creationTime, IDictionary`2<string, string> metadata, DateTimeOffset copyCompletionTime, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, bool isIncrementalCopy, DataLakeLeaseDuration leaseDuration, DataLakeLeaseState leaseState, DataLakeLeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, string acceptRanges, bool isServerEncrypted, string encryptionKeySha256, string accessTier, string archiveStatus, DateTimeOffset accessTierChangeTime, bool isDirectory, string encryptionContext);
    [EditorBrowsableAttribute("1")]
public static PathProperties PathProperties(DateTimeOffset lastModified, DateTimeOffset creationTime, IDictionary`2<string, string> metadata, DateTimeOffset copyCompletionTime, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, bool isIncrementalCopy, DataLakeLeaseDuration leaseDuration, DataLakeLeaseState leaseState, DataLakeLeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, string acceptRanges, bool isServerEncrypted, string encryptionKeySha256, string accessTier, string archiveStatus, DateTimeOffset accessTierChangeTime, bool isDirectory);
    [EditorBrowsableAttribute("1")]
public static PathProperties PathProperties(DateTimeOffset lastModified, DateTimeOffset creationTime, IDictionary`2<string, string> metadata, DateTimeOffset copyCompletionTime, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, bool isIncrementalCopy, DataLakeLeaseDuration leaseDuration, DataLakeLeaseState leaseState, DataLakeLeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, string acceptRanges, bool isServerEncrypted, string encryptionKeySha256, string accessTier, string archiveStatus, DateTimeOffset accessTierChangeTime);
    public static UserDelegationKey UserDelegationKey(string signedObjectId, string signedTenantId, DateTimeOffset signedStart, DateTimeOffset signedExpiry, string signedService, string signedVersion, string value);
    public static DataLakeQueryError DataLakeQueryError(string name, string description, bool isFatal, long position);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeOpenReadOptions : object {
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private DownloadTransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowModifications>k__BackingField;
    public long Position { get; public set; }
    public Nullable`1<int> BufferSize { get; public set; }
    public DataLakeRequestConditions Conditions { get; public set; }
    public DownloadTransferValidationOptions TransferValidation { get; public set; }
    internal bool AllowModifications { get; }
    public DataLakeOpenReadOptions(bool allowModifications);
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public DataLakeRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(DataLakeRequestConditions value);
    [CompilerGeneratedAttribute]
public DownloadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(DownloadTransferValidationOptions value);
    [CompilerGeneratedAttribute]
internal bool get_AllowModifications();
}
public class Azure.Storage.Files.DataLake.Models.DataLakePathCreateOptions : object {
    [CompilerGeneratedAttribute]
private PathHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeAccessOptions <AccessOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakePathScheduleDeletionOptions <ScheduleDeletionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionContext>k__BackingField;
    public PathHttpHeaders HttpHeaders { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public DataLakeAccessOptions AccessOptions { get; public set; }
    public string LeaseId { get; public set; }
    public Nullable`1<TimeSpan> LeaseDuration { get; public set; }
    public DataLakePathScheduleDeletionOptions ScheduleDeletionOptions { get; public set; }
    public DataLakeRequestConditions Conditions { get; public set; }
    public string EncryptionContext { get; public set; }
    [CompilerGeneratedAttribute]
public PathHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(PathHttpHeaders value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public DataLakeAccessOptions get_AccessOptions();
    [CompilerGeneratedAttribute]
public void set_AccessOptions(DataLakeAccessOptions value);
    [CompilerGeneratedAttribute]
public string get_LeaseId();
    [CompilerGeneratedAttribute]
public void set_LeaseId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_LeaseDuration();
    [CompilerGeneratedAttribute]
public void set_LeaseDuration(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public DataLakePathScheduleDeletionOptions get_ScheduleDeletionOptions();
    [CompilerGeneratedAttribute]
public void set_ScheduleDeletionOptions(DataLakePathScheduleDeletionOptions value);
    [CompilerGeneratedAttribute]
public DataLakeRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(DataLakeRequestConditions value);
    [CompilerGeneratedAttribute]
public string get_EncryptionContext();
    [CompilerGeneratedAttribute]
public void set_EncryptionContext(string value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakePathScheduleDeletionOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <TimeToExpire>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    public Nullable`1<TimeSpan> TimeToExpire { get; private set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; private set; }
    public DataLakePathScheduleDeletionOptions(Nullable`1<DateTimeOffset> expiresOn);
    public DataLakePathScheduleDeletionOptions(Nullable`1<TimeSpan> timeToExpire);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_TimeToExpire();
    [CompilerGeneratedAttribute]
private void set_TimeToExpire(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
private void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeQueryArrowField : object {
    [CompilerGeneratedAttribute]
private DataLakeQueryArrowFieldType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    public DataLakeQueryArrowFieldType Type { get; public set; }
    public string Name { get; public set; }
    public int Precision { get; public set; }
    public int Scale { get; public set; }
    [CompilerGeneratedAttribute]
public DataLakeQueryArrowFieldType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(DataLakeQueryArrowFieldType value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(int value);
    [CompilerGeneratedAttribute]
public int get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(int value);
}
public enum Azure.Storage.Files.DataLake.Models.DataLakeQueryArrowFieldType : Enum {
    public int value__;
    public static DataLakeQueryArrowFieldType Int64;
    public static DataLakeQueryArrowFieldType Bool;
    public static DataLakeQueryArrowFieldType Timestamp;
    public static DataLakeQueryArrowFieldType String;
    public static DataLakeQueryArrowFieldType Double;
    public static DataLakeQueryArrowFieldType Decimal;
}
public class Azure.Storage.Files.DataLake.Models.DataLakeQueryArrowOptions : DataLakeQueryTextOptions {
    [CompilerGeneratedAttribute]
private IList`1<DataLakeQueryArrowField> <Schema>k__BackingField;
    public IList`1<DataLakeQueryArrowField> Schema { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<DataLakeQueryArrowField> get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(IList`1<DataLakeQueryArrowField> value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeQueryCsvTextOptions : DataLakeQueryTextOptions {
    [CompilerGeneratedAttribute]
private string <RecordSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColumnSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <QuotationCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <EscapeCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasHeaders>k__BackingField;
    public string RecordSeparator { get; public set; }
    public string ColumnSeparator { get; public set; }
    public Nullable`1<char> QuotationCharacter { get; public set; }
    public Nullable`1<char> EscapeCharacter { get; public set; }
    public bool HasHeaders { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RecordSeparator();
    [CompilerGeneratedAttribute]
public void set_RecordSeparator(string value);
    [CompilerGeneratedAttribute]
public string get_ColumnSeparator();
    [CompilerGeneratedAttribute]
public void set_ColumnSeparator(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_QuotationCharacter();
    [CompilerGeneratedAttribute]
public void set_QuotationCharacter(Nullable`1<char> value);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_EscapeCharacter();
    [CompilerGeneratedAttribute]
public void set_EscapeCharacter(Nullable`1<char> value);
    [CompilerGeneratedAttribute]
public bool get_HasHeaders();
    [CompilerGeneratedAttribute]
public void set_HasHeaders(bool value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeQueryError : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFatal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public string Name { get; internal set; }
    public string Description { get; internal set; }
    public bool IsFatal { get; internal set; }
    public long Position { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
internal void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFatal();
    [CompilerGeneratedAttribute]
internal void set_IsFatal(bool value);
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(long value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeQueryJsonTextOptions : DataLakeQueryTextOptions {
    [CompilerGeneratedAttribute]
private string <RecordSeparator>k__BackingField;
    public string RecordSeparator { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RecordSeparator();
    [CompilerGeneratedAttribute]
public void set_RecordSeparator(string value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeQueryOptions : object {
    [CompilerGeneratedAttribute]
private DataLakeQueryTextOptions <InputTextConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeQueryTextOptions <OutputTextConfiguration>k__BackingField;
    private object _objectLock;
    internal Action`1<DataLakeQueryError> _errorHandler;
    [CompilerGeneratedAttribute]
private DataLakeRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    public DataLakeQueryTextOptions InputTextConfiguration { get; public set; }
    public DataLakeQueryTextOptions OutputTextConfiguration { get; public set; }
    public DataLakeRequestConditions Conditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    [CompilerGeneratedAttribute]
public DataLakeQueryTextOptions get_InputTextConfiguration();
    [CompilerGeneratedAttribute]
public void set_InputTextConfiguration(DataLakeQueryTextOptions value);
    [CompilerGeneratedAttribute]
public DataLakeQueryTextOptions get_OutputTextConfiguration();
    [CompilerGeneratedAttribute]
public void set_OutputTextConfiguration(DataLakeQueryTextOptions value);
    public void add_ErrorHandler(Action`1<DataLakeQueryError> value);
    public void remove_ErrorHandler(Action`1<DataLakeQueryError> value);
    [CompilerGeneratedAttribute]
public DataLakeRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(DataLakeRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeQueryParquetTextOptions : DataLakeQueryTextOptions {
}
public abstract class Azure.Storage.Files.DataLake.Models.DataLakeQueryTextOptions : object {
}
[FlagsAttribute]
internal enum Azure.Storage.Files.DataLake.Models.DataLakeRequestConditionProperty : Enum {
    public int value__;
    public static DataLakeRequestConditionProperty None;
    public static DataLakeRequestConditionProperty LeaseId;
    public static DataLakeRequestConditionProperty TagConditions;
    public static DataLakeRequestConditionProperty IfModifiedSince;
    public static DataLakeRequestConditionProperty IfUnmodifiedSince;
    public static DataLakeRequestConditionProperty IfMatch;
    public static DataLakeRequestConditionProperty IfNoneMatch;
}
public class Azure.Storage.Files.DataLake.Models.DataLakeRequestConditions : RequestConditions {
    [CompilerGeneratedAttribute]
private string <LeaseId>k__BackingField;
    public string LeaseId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LeaseId();
    [CompilerGeneratedAttribute]
public void set_LeaseId(string value);
    public virtual string ToString();
    internal virtual void AddConditions(StringBuilder conditions);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeRetentionPolicy : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Days>k__BackingField;
    public bool Enabled { get; public set; }
    public Nullable`1<int> Days { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Days();
    [CompilerGeneratedAttribute]
public void set_Days(Nullable`1<int> value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeServiceProperties : object {
    [CompilerGeneratedAttribute]
private DataLakeAnalyticsLogging <Logging>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeMetrics <HourMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeMetrics <MinuteMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DataLakeCorsRule> <Cors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultServiceVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeRetentionPolicy <DeleteRetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeStaticWebsite <StaticWebsite>k__BackingField;
    public DataLakeAnalyticsLogging Logging { get; public set; }
    public DataLakeMetrics HourMetrics { get; public set; }
    public DataLakeMetrics MinuteMetrics { get; public set; }
    public IList`1<DataLakeCorsRule> Cors { get; public set; }
    public string DefaultServiceVersion { get; public set; }
    public DataLakeRetentionPolicy DeleteRetentionPolicy { get; public set; }
    public DataLakeStaticWebsite StaticWebsite { get; public set; }
    [CompilerGeneratedAttribute]
public DataLakeAnalyticsLogging get_Logging();
    [CompilerGeneratedAttribute]
public void set_Logging(DataLakeAnalyticsLogging value);
    [CompilerGeneratedAttribute]
public DataLakeMetrics get_HourMetrics();
    [CompilerGeneratedAttribute]
public void set_HourMetrics(DataLakeMetrics value);
    [CompilerGeneratedAttribute]
public DataLakeMetrics get_MinuteMetrics();
    [CompilerGeneratedAttribute]
public void set_MinuteMetrics(DataLakeMetrics value);
    [CompilerGeneratedAttribute]
public IList`1<DataLakeCorsRule> get_Cors();
    [CompilerGeneratedAttribute]
public void set_Cors(IList`1<DataLakeCorsRule> value);
    [CompilerGeneratedAttribute]
public string get_DefaultServiceVersion();
    [CompilerGeneratedAttribute]
public void set_DefaultServiceVersion(string value);
    [CompilerGeneratedAttribute]
public DataLakeRetentionPolicy get_DeleteRetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_DeleteRetentionPolicy(DataLakeRetentionPolicy value);
    [CompilerGeneratedAttribute]
public DataLakeStaticWebsite get_StaticWebsite();
    [CompilerGeneratedAttribute]
public void set_StaticWebsite(DataLakeStaticWebsite value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeSignedIdentifier : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeAccessPolicy <AccessPolicy>k__BackingField;
    public string Id { get; public set; }
    public DataLakeAccessPolicy AccessPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public DataLakeAccessPolicy get_AccessPolicy();
    [CompilerGeneratedAttribute]
public void set_AccessPolicy(DataLakeAccessPolicy value);
}
public class Azure.Storage.Files.DataLake.Models.DataLakeStaticWebsite : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDocument404Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultIndexDocumentPath>k__BackingField;
    public bool Enabled { get; public set; }
    public string IndexDocument { get; public set; }
    public string ErrorDocument404Path { get; public set; }
    public string DefaultIndexDocumentPath { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public string get_IndexDocument();
    [CompilerGeneratedAttribute]
public void set_IndexDocument(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDocument404Path();
    [CompilerGeneratedAttribute]
public void set_ErrorDocument404Path(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultIndexDocumentPath();
    [CompilerGeneratedAttribute]
public void set_DefaultIndexDocumentPath(string value);
}
[CodeGenModelAttribute("EncryptionAlgorithmType")]
internal enum Azure.Storage.Files.DataLake.Models.EncryptionAlgorithmTypeInternal : Enum {
    public int value__;
    public static EncryptionAlgorithmTypeInternal None;
    public static EncryptionAlgorithmTypeInternal AES256;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.Models.EncryptionAlgorithmTypeInternalExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(EncryptionAlgorithmTypeInternal value);
    [ExtensionAttribute]
public static EncryptionAlgorithmTypeInternal ToEncryptionAlgorithmTypeInternal(string value);
}
public class Azure.Storage.Files.DataLake.Models.FileDownloadDetails : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentRange>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CopyCompletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyStatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyStatus <CopyStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeLeaseDuration <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeLeaseState <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeLeaseStatus <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AcceptRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PathAccessControlItem> <AccessControlList>k__BackingField;
    public DateTimeOffset LastModified { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public string ContentRange { get; internal set; }
    public ETag ETag { get; internal set; }
    public string ContentEncoding { get; internal set; }
    public string CacheControl { get; internal set; }
    public string ContentDisposition { get; internal set; }
    public string ContentLanguage { get; internal set; }
    public DateTimeOffset CopyCompletedOn { get; internal set; }
    public string CopyStatusDescription { get; internal set; }
    public string CopyId { get; internal set; }
    public string CopyProgress { get; internal set; }
    public Uri CopySource { get; internal set; }
    public CopyStatus CopyStatus { get; internal set; }
    public DataLakeLeaseDuration LeaseDuration { get; internal set; }
    public DataLakeLeaseState LeaseState { get; internal set; }
    public DataLakeLeaseStatus LeaseStatus { get; internal set; }
    public string AcceptRanges { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    public string EncryptionKeySha256 { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public DateTimeOffset CreatedOn { get; internal set; }
    public string EncryptionContext { get; internal set; }
    public IList`1<PathAccessControlItem> AccessControlList { get; internal set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ContentRange();
    [CompilerGeneratedAttribute]
internal void set_ContentRange(string value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
internal void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
internal void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
internal void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
internal void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CopyCompletedOn();
    [CompilerGeneratedAttribute]
internal void set_CopyCompletedOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_CopyStatusDescription();
    [CompilerGeneratedAttribute]
internal void set_CopyStatusDescription(string value);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
internal void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public string get_CopyProgress();
    [CompilerGeneratedAttribute]
internal void set_CopyProgress(string value);
    [CompilerGeneratedAttribute]
public Uri get_CopySource();
    [CompilerGeneratedAttribute]
internal void set_CopySource(Uri value);
    [CompilerGeneratedAttribute]
public CopyStatus get_CopyStatus();
    [CompilerGeneratedAttribute]
internal void set_CopyStatus(CopyStatus value);
    [CompilerGeneratedAttribute]
public DataLakeLeaseDuration get_LeaseDuration();
    [CompilerGeneratedAttribute]
internal void set_LeaseDuration(DataLakeLeaseDuration value);
    [CompilerGeneratedAttribute]
public DataLakeLeaseState get_LeaseState();
    [CompilerGeneratedAttribute]
internal void set_LeaseState(DataLakeLeaseState value);
    [CompilerGeneratedAttribute]
public DataLakeLeaseStatus get_LeaseStatus();
    [CompilerGeneratedAttribute]
internal void set_LeaseStatus(DataLakeLeaseStatus value);
    [CompilerGeneratedAttribute]
public string get_AcceptRanges();
    [CompilerGeneratedAttribute]
internal void set_AcceptRanges(string value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKeySha256();
    [CompilerGeneratedAttribute]
internal void set_EncryptionKeySha256(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_EncryptionContext();
    [CompilerGeneratedAttribute]
internal void set_EncryptionContext(string value);
    [CompilerGeneratedAttribute]
public IList`1<PathAccessControlItem> get_AccessControlList();
    [CompilerGeneratedAttribute]
internal void set_AccessControlList(IList`1<PathAccessControlItem> value);
}
public class Azure.Storage.Files.DataLake.Models.FileDownloadInfo : object {
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private FileDownloadDetails <Properties>k__BackingField;
    public long ContentLength { get; internal set; }
    public Stream Content { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public FileDownloadDetails Properties { get; internal set; }
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
internal void set_ContentLength(long value);
    [CompilerGeneratedAttribute]
public Stream get_Content();
    [CompilerGeneratedAttribute]
internal void set_Content(Stream value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public FileDownloadDetails get_Properties();
    [CompilerGeneratedAttribute]
internal void set_Properties(FileDownloadDetails value);
}
internal class Azure.Storage.Files.DataLake.Models.FileSystem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ETag>k__BackingField;
    public string Name { get; }
    public string LastModified { get; }
    public string ETag { get; }
    internal FileSystem(string name, string lastModified, string eTag);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_LastModified();
    [CompilerGeneratedAttribute]
public string get_ETag();
    internal static FileSystem DeserializeFileSystem(JsonElement element);
    internal static FileSystem FromResponse(Response response);
}
public class Azure.Storage.Files.DataLake.Models.FileSystemAccessPolicy : object {
    [CompilerGeneratedAttribute]
private PublicAccessType <DataLakePublicAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DataLakeSignedIdentifier> <SignedIdentifiers>k__BackingField;
    public PublicAccessType DataLakePublicAccess { get; internal set; }
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public IEnumerable`1<DataLakeSignedIdentifier> SignedIdentifiers { get; internal set; }
    [CompilerGeneratedAttribute]
public PublicAccessType get_DataLakePublicAccess();
    [CompilerGeneratedAttribute]
internal void set_DataLakePublicAccess(PublicAccessType value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<DataLakeSignedIdentifier> get_SignedIdentifiers();
    [CompilerGeneratedAttribute]
internal void set_SignedIdentifiers(IEnumerable`1<DataLakeSignedIdentifier> value);
}
public class Azure.Storage.Files.DataLake.Models.FileSystemInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
}
public class Azure.Storage.Files.DataLake.Models.FileSystemItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemProperties <Properties>k__BackingField;
    public string Name { get; internal set; }
    public Nullable`1<bool> IsDeleted { get; internal set; }
    public string VersionId { get; internal set; }
    public FileSystemProperties Properties { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsDeleted();
    [CompilerGeneratedAttribute]
internal void set_IsDeleted(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
internal void set_VersionId(string value);
    [CompilerGeneratedAttribute]
public FileSystemProperties get_Properties();
    [CompilerGeneratedAttribute]
internal void set_Properties(FileSystemProperties value);
}
internal class Azure.Storage.Files.DataLake.Models.FileSystemList : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FileSystem> <Filesystems>k__BackingField;
    public IReadOnlyList`1<FileSystem> Filesystems { get; }
    internal FileSystemList(IReadOnlyList`1<FileSystem> filesystems);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FileSystem> get_Filesystems();
    internal static FileSystemList DeserializeFileSystemList(JsonElement element);
    internal static FileSystemList FromResponse(Response response);
}
public class Azure.Storage.Files.DataLake.Models.FileSystemProperties : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DataLakeLeaseStatus> <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DataLakeLeaseState> <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DataLakeLeaseDuration> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PublicAccessType> <PublicAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasLegalHold>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RemainingRetentionDays>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultEncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PreventEncryptionScopeOverride>k__BackingField;
    public DateTimeOffset LastModified { get; internal set; }
    public Nullable`1<DataLakeLeaseStatus> LeaseStatus { get; internal set; }
    public Nullable`1<DataLakeLeaseState> LeaseState { get; internal set; }
    public Nullable`1<DataLakeLeaseDuration> LeaseDuration { get; internal set; }
    public Nullable`1<PublicAccessType> PublicAccess { get; internal set; }
    public Nullable`1<bool> HasImmutabilityPolicy { get; internal set; }
    public Nullable`1<bool> HasLegalHold { get; internal set; }
    public ETag ETag { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public Nullable`1<DateTimeOffset> DeletedOn { get; internal set; }
    public Nullable`1<int> RemainingRetentionDays { get; internal set; }
    public string DefaultEncryptionScope { get; internal set; }
    public Nullable`1<bool> PreventEncryptionScopeOverride { get; internal set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Nullable`1<DataLakeLeaseStatus> get_LeaseStatus();
    [CompilerGeneratedAttribute]
internal void set_LeaseStatus(Nullable`1<DataLakeLeaseStatus> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DataLakeLeaseState> get_LeaseState();
    [CompilerGeneratedAttribute]
internal void set_LeaseState(Nullable`1<DataLakeLeaseState> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DataLakeLeaseDuration> get_LeaseDuration();
    [CompilerGeneratedAttribute]
internal void set_LeaseDuration(Nullable`1<DataLakeLeaseDuration> value);
    [CompilerGeneratedAttribute]
public Nullable`1<PublicAccessType> get_PublicAccess();
    [CompilerGeneratedAttribute]
internal void set_PublicAccess(Nullable`1<PublicAccessType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HasImmutabilityPolicy();
    [CompilerGeneratedAttribute]
internal void set_HasImmutabilityPolicy(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HasLegalHold();
    [CompilerGeneratedAttribute]
internal void set_HasLegalHold(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedOn();
    [CompilerGeneratedAttribute]
internal void set_DeletedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RemainingRetentionDays();
    [CompilerGeneratedAttribute]
internal void set_RemainingRetentionDays(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_DefaultEncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_DefaultEncryptionScope(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PreventEncryptionScopeOverride();
    [CompilerGeneratedAttribute]
internal void set_PreventEncryptionScopeOverride(Nullable`1<bool> value);
}
[FlagsAttribute]
public enum Azure.Storage.Files.DataLake.Models.FileSystemStates : Enum {
    public int value__;
    public static FileSystemStates None;
    public static FileSystemStates Deleted;
    public static FileSystemStates System;
}
[FlagsAttribute]
public enum Azure.Storage.Files.DataLake.Models.FileSystemTraits : Enum {
    public int value__;
    public static FileSystemTraits None;
    public static FileSystemTraits Metadata;
}
internal class Azure.Storage.Files.DataLake.Models.GetDeletedPathAsyncCollection : StorageCollectionEnumerator`1<PathDeletedItem> {
    private DataLakeFileSystemClient _client;
    private string _path;
    private string _operationName;
    public GetDeletedPathAsyncCollection(DataLakeFileSystemClient client, string path, string operationName);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.Models.GetDeletedPathAsyncCollection/<GetNextPageAsync>d__4")]
public virtual ValueTask`1<Page`1<PathDeletedItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.DataLake.Models.GetFileSystemsAsyncCollection : object {
    private BlobServiceClient _client;
    private FileSystemTraits _traits;
    private FileSystemStates _states;
    private string _prefix;
    public GetFileSystemsAsyncCollection(BlobServiceClient client, FileSystemTraits traits, FileSystemStates states, string prefix);
    private static Page`1<FileSystemItem> ConvertPage(Page`1<BlobContainerItem> page);
    private static FileSystemItem ConvertItem(BlobContainerItem item);
    private static AsyncPageable`1<BlobContainerItem> ConvertCollection(GetFileSystemsAsyncCollection collection, CancellationToken cancellationToken);
    public Pageable`1<FileSystemItem> ToSyncCollection(CancellationToken cancellationToken);
    public AsyncPageable`1<FileSystemItem> ToAsyncCollection(CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.DataLake.Models.GetPathsAsyncCollection : StorageCollectionEnumerator`1<PathItem> {
    private DataLakeFileSystemClient _client;
    private string _path;
    private Nullable`1<bool> _recursive;
    private Nullable`1<bool> _upn;
    private string _operationName;
    public GetPathsAsyncCollection(DataLakeFileSystemClient client, string path, Nullable`1<bool> recursive, Nullable`1<bool> upn, string operationName);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.Models.GetPathsAsyncCollection/<GetNextPageAsync>d__6")]
public virtual ValueTask`1<Page`1<PathItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.DataLake.Models.ListBlobsHierarchySegmentResponse : object {
    [CompilerGeneratedAttribute]
private string <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobHierarchyListSegment <Segment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    public string ServiceEndpoint { get; }
    public string ContainerName { get; }
    public string Prefix { get; }
    public string Marker { get; }
    public Nullable`1<int> MaxResults { get; }
    public string Delimiter { get; }
    public BlobHierarchyListSegment Segment { get; }
    public string NextMarker { get; }
    internal ListBlobsHierarchySegmentResponse(string serviceEndpoint, string containerName, BlobHierarchyListSegment segment);
    internal ListBlobsHierarchySegmentResponse(string serviceEndpoint, string containerName, string prefix, string marker, Nullable`1<int> maxResults, string delimiter, BlobHierarchyListSegment segment, string nextMarker);
    [CompilerGeneratedAttribute]
public string get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
public string get_ContainerName();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Marker();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxResults();
    [CompilerGeneratedAttribute]
public string get_Delimiter();
    [CompilerGeneratedAttribute]
public BlobHierarchyListSegment get_Segment();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    internal static ListBlobsHierarchySegmentResponse DeserializeListBlobsHierarchySegmentResponse(XElement element);
}
internal enum Azure.Storage.Files.DataLake.Models.ListBlobsIncludeItem : Enum {
    public int value__;
    public static ListBlobsIncludeItem Copy;
    public static ListBlobsIncludeItem Deleted;
    public static ListBlobsIncludeItem Metadata;
    public static ListBlobsIncludeItem Snapshots;
    public static ListBlobsIncludeItem Uncommittedblobs;
    public static ListBlobsIncludeItem Versions;
    public static ListBlobsIncludeItem Tags;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.Models.ListBlobsIncludeItemExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ListBlobsIncludeItem value);
    [ExtensionAttribute]
public static ListBlobsIncludeItem ToListBlobsIncludeItem(string value);
}
[IsReadOnlyAttribute]
internal class Azure.Storage.Files.DataLake.Models.ListBlobsShowOnly : ValueType {
    private string _value;
    private static string DeletedValue;
    [CompilerGeneratedAttribute]
private static ListBlobsShowOnly <Deleted>k__BackingField;
    public static ListBlobsShowOnly Deleted { get; }
    public ListBlobsShowOnly(string value);
    private static ListBlobsShowOnly();
    [CompilerGeneratedAttribute]
public static ListBlobsShowOnly get_Deleted();
    public static bool op_Equality(ListBlobsShowOnly left, ListBlobsShowOnly right);
    public static bool op_Inequality(ListBlobsShowOnly left, ListBlobsShowOnly right);
    public static ListBlobsShowOnly op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ListBlobsShowOnly other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Azure.Storage.Files.DataLake.Models.Path : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpiryTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Etag>k__BackingField;
    public string Name { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Owner { get; }
    public string Group { get; }
    public string Permissions { get; }
    public string EncryptionScope { get; }
    public string CreationTime { get; }
    public string ExpiryTime { get; }
    public string EncryptionContext { get; }
    public string ContentLength { get; }
    public string IsDirectory { get; }
    public string Etag { get; }
    internal Path(string name, Nullable`1<DateTimeOffset> lastModified, string owner, string group, string permissions, string encryptionScope, string creationTime, string expiryTime, string encryptionContext, string contentLength, string isDirectory, string etag);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastModified();
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public string get_CreationTime();
    [CompilerGeneratedAttribute]
public string get_ExpiryTime();
    [CompilerGeneratedAttribute]
public string get_EncryptionContext();
    [CompilerGeneratedAttribute]
public string get_ContentLength();
    [CompilerGeneratedAttribute]
public string get_IsDirectory();
    [CompilerGeneratedAttribute]
public string get_Etag();
    internal static Path DeserializePath(JsonElement element);
    internal static Path FromResponse(Response response);
}
public class Azure.Storage.Files.DataLake.Models.PathAccessControl : object {
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private PathPermissions <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PathAccessControlItem> <AccessControlList>k__BackingField;
    public string Owner { get; internal set; }
    public string Group { get; internal set; }
    public PathPermissions Permissions { get; internal set; }
    public IEnumerable`1<PathAccessControlItem> AccessControlList { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(string value);
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
internal void set_Group(string value);
    [CompilerGeneratedAttribute]
public PathPermissions get_Permissions();
    [CompilerGeneratedAttribute]
internal void set_Permissions(PathPermissions value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PathAccessControlItem> get_AccessControlList();
    [CompilerGeneratedAttribute]
internal void set_AccessControlList(IEnumerable`1<PathAccessControlItem> value);
}
[ExtensionAttribute]
public static class Azure.Storage.Files.DataLake.Models.PathAccessControlExtensions : object {
    public static RolePermissions ParseOctalRolePermissions(char c);
    public static RolePermissions ParseSymbolicRolePermissions(string s, bool allowStickyBit);
    [ExtensionAttribute]
public static string ToOctalRolePermissions(RolePermissions rolePermissions);
    [ExtensionAttribute]
public static string ToSymbolicRolePermissions(RolePermissions rolePermissions);
    [ExtensionAttribute]
public static string ToSymbolicRolePermissions(RolePermissions rolePermissions, bool stickyBit);
    public static string ToAccessControlListString(IList`1<PathAccessControlItem> accessControlList);
    public static IList`1<PathAccessControlItem> ParseAccessControlList(string s);
}
public class Azure.Storage.Files.DataLake.Models.PathAccessControlItem : object {
    [CompilerGeneratedAttribute]
private bool <DefaultScope>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessControlType <AccessControlType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityId>k__BackingField;
    [CompilerGeneratedAttribute]
private RolePermissions <Permissions>k__BackingField;
    public bool DefaultScope { get; public set; }
    public AccessControlType AccessControlType { get; public set; }
    public string EntityId { get; public set; }
    public RolePermissions Permissions { get; public set; }
    public PathAccessControlItem(AccessControlType accessControlType, RolePermissions permissions, bool defaultScope, string entityId);
    [CompilerGeneratedAttribute]
public bool get_DefaultScope();
    [CompilerGeneratedAttribute]
public void set_DefaultScope(bool value);
    [CompilerGeneratedAttribute]
public AccessControlType get_AccessControlType();
    [CompilerGeneratedAttribute]
public void set_AccessControlType(AccessControlType value);
    [CompilerGeneratedAttribute]
public string get_EntityId();
    [CompilerGeneratedAttribute]
public void set_EntityId(string value);
    [CompilerGeneratedAttribute]
public RolePermissions get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(RolePermissions value);
    public virtual string ToString();
    public static PathAccessControlItem Parse(string s);
    internal static AccessControlType ParseAccesControlType(string s);
}
public class Azure.Storage.Files.DataLake.Models.PathContentInfo : object {
    [CompilerGeneratedAttribute]
private string <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AcceptRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentRange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    public string ContentHash { get; internal set; }
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public string AcceptRanges { get; internal set; }
    public string CacheControl { get; internal set; }
    public string ContentDisposition { get; internal set; }
    public string ContentEncoding { get; internal set; }
    public string ContentLanguage { get; internal set; }
    public long ContentLength { get; internal set; }
    public string ContentRange { get; internal set; }
    public string ContentType { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(string value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_AcceptRanges();
    [CompilerGeneratedAttribute]
internal void set_AcceptRanges(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
internal void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
internal void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
internal void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
internal void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
internal void set_ContentLength(long value);
    [CompilerGeneratedAttribute]
public string get_ContentRange();
    [CompilerGeneratedAttribute]
internal void set_ContentRange(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
}
public class Azure.Storage.Files.DataLake.Models.PathCreateInfo : object {
    [CompilerGeneratedAttribute]
private PathInfo <PathInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Continuation>k__BackingField;
    public PathInfo PathInfo { get; internal set; }
    public string Continuation { get; internal set; }
    [CompilerGeneratedAttribute]
public PathInfo get_PathInfo();
    [CompilerGeneratedAttribute]
internal void set_PathInfo(PathInfo value);
    [CompilerGeneratedAttribute]
public string get_Continuation();
    [CompilerGeneratedAttribute]
internal void set_Continuation(string value);
}
public class Azure.Storage.Files.DataLake.Models.PathDeletedItem : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeletionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RemainingRetentionDays>k__BackingField;
    public string Path { get; internal set; }
    public string DeletionId { get; internal set; }
    public Nullable`1<DateTimeOffset> DeletedOn { get; internal set; }
    public Nullable`1<int> RemainingRetentionDays { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_DeletionId();
    [CompilerGeneratedAttribute]
internal void set_DeletionId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedOn();
    [CompilerGeneratedAttribute]
internal void set_DeletedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RemainingRetentionDays();
    [CompilerGeneratedAttribute]
internal void set_RemainingRetentionDays(Nullable`1<int> value);
}
internal class Azure.Storage.Files.DataLake.Models.PathDeletedSegment : object {
    [CompilerGeneratedAttribute]
private string <Continuation>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PathHierarchyDeletedItem> <DeletedPaths>k__BackingField;
    public string Continuation { get; internal set; }
    public IEnumerable`1<PathHierarchyDeletedItem> DeletedPaths { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Continuation();
    [CompilerGeneratedAttribute]
internal void set_Continuation(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PathHierarchyDeletedItem> get_DeletedPaths();
    [CompilerGeneratedAttribute]
internal void set_DeletedPaths(IEnumerable`1<PathHierarchyDeletedItem> value);
}
[IsReadOnlyAttribute]
internal class Azure.Storage.Files.DataLake.Models.PathExpiryOptions : ValueType {
    private string _value;
    private static string NeverExpireValue;
    private static string RelativeToCreationValue;
    private static string RelativeToNowValue;
    private static string AbsoluteValue;
    [CompilerGeneratedAttribute]
private static PathExpiryOptions <NeverExpire>k__BackingField;
    [CompilerGeneratedAttribute]
private static PathExpiryOptions <RelativeToCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private static PathExpiryOptions <RelativeToNow>k__BackingField;
    [CompilerGeneratedAttribute]
private static PathExpiryOptions <Absolute>k__BackingField;
    public static PathExpiryOptions NeverExpire { get; }
    public static PathExpiryOptions RelativeToCreation { get; }
    public static PathExpiryOptions RelativeToNow { get; }
    public static PathExpiryOptions Absolute { get; }
    public PathExpiryOptions(string value);
    private static PathExpiryOptions();
    [CompilerGeneratedAttribute]
public static PathExpiryOptions get_NeverExpire();
    [CompilerGeneratedAttribute]
public static PathExpiryOptions get_RelativeToCreation();
    [CompilerGeneratedAttribute]
public static PathExpiryOptions get_RelativeToNow();
    [CompilerGeneratedAttribute]
public static PathExpiryOptions get_Absolute();
    public static bool op_Equality(PathExpiryOptions left, PathExpiryOptions right);
    public static bool op_Inequality(PathExpiryOptions left, PathExpiryOptions right);
    public static PathExpiryOptions op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PathExpiryOptions other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
public enum Azure.Storage.Files.DataLake.Models.PathGetPropertiesAction : Enum {
    public int value__;
    public static PathGetPropertiesAction GetAccessControl;
    public static PathGetPropertiesAction GetStatus;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.Models.PathGetPropertiesActionExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(PathGetPropertiesAction value);
    [ExtensionAttribute]
public static PathGetPropertiesAction ToPathGetPropertiesAction(string value);
}
internal class Azure.Storage.Files.DataLake.Models.PathHierarchyDeletedItem : object {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private PathDeletedItem <Path>k__BackingField;
    public string Prefix { get; internal set; }
    public PathDeletedItem Path { get; internal set; }
    public bool IsPrefix { get; }
    public bool IsPath { get; }
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
internal void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public PathDeletedItem get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(PathDeletedItem value);
    public bool get_IsPrefix();
    public bool get_IsPath();
}
public class Azure.Storage.Files.DataLake.Models.PathHttpHeaders : object {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    public string ContentType { get; public set; }
    public Byte[] ContentHash { get; public set; }
    public string ContentEncoding { get; public set; }
    public string ContentLanguage { get; public set; }
    public string ContentDisposition { get; public set; }
    public string CacheControl { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
public void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public void set_CacheControl(string value);
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
public class Azure.Storage.Files.DataLake.Models.PathInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
}
public class Azure.Storage.Files.DataLake.Models.PathItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionContext>k__BackingField;
    public string Name { get; internal set; }
    public Nullable`1<bool> IsDirectory { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public ETag ETag { get; internal set; }
    public Nullable`1<long> ContentLength { get; internal set; }
    public string Owner { get; internal set; }
    public string Group { get; internal set; }
    public string Permissions { get; internal set; }
    public Nullable`1<DateTimeOffset> CreatedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; internal set; }
    public string EncryptionScope { get; internal set; }
    public string EncryptionContext { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsDirectory();
    [CompilerGeneratedAttribute]
internal void set_IsDirectory(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ContentLength();
    [CompilerGeneratedAttribute]
internal void set_ContentLength(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(string value);
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
internal void set_Group(string value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
internal void set_Permissions(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionContext();
    [CompilerGeneratedAttribute]
internal void set_EncryptionContext(string value);
}
public enum Azure.Storage.Files.DataLake.Models.PathLeaseAction : Enum {
    public int value__;
    public static PathLeaseAction Acquire;
    public static PathLeaseAction Break;
    public static PathLeaseAction Change;
    public static PathLeaseAction Renew;
    public static PathLeaseAction Release;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.Models.PathLeaseActionExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(PathLeaseAction value);
    [ExtensionAttribute]
public static PathLeaseAction ToPathLeaseAction(string value);
}
internal class Azure.Storage.Files.DataLake.Models.PathList : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Path> <Paths>k__BackingField;
    public IReadOnlyList`1<Path> Paths { get; }
    internal PathList(IReadOnlyList`1<Path> paths);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Path> get_Paths();
    internal static PathList DeserializePathList(JsonElement element);
    internal static PathList FromResponse(Response response);
}
public class Azure.Storage.Files.DataLake.Models.PathPermissions : object {
    [CompilerGeneratedAttribute]
private RolePermissions <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private RolePermissions <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private RolePermissions <Other>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StickyBit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtendedAcls>k__BackingField;
    public RolePermissions Owner { get; public set; }
    public RolePermissions Group { get; public set; }
    public RolePermissions Other { get; public set; }
    public bool StickyBit { get; public set; }
    public bool ExtendedAcls { get; public set; }
    public PathPermissions(RolePermissions owner, RolePermissions group, RolePermissions other, bool stickyBit, bool extendedInfoInAcl);
    [CompilerGeneratedAttribute]
public RolePermissions get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(RolePermissions value);
    [CompilerGeneratedAttribute]
public RolePermissions get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(RolePermissions value);
    [CompilerGeneratedAttribute]
public RolePermissions get_Other();
    [CompilerGeneratedAttribute]
public void set_Other(RolePermissions value);
    [CompilerGeneratedAttribute]
public bool get_StickyBit();
    [CompilerGeneratedAttribute]
public void set_StickyBit(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExtendedAcls();
    [CompilerGeneratedAttribute]
public void set_ExtendedAcls(bool value);
    public static PathPermissions ParseOctalPermissions(string s);
    public static PathPermissions ParseSymbolicPermissions(string s);
    public string ToOctalPermissions();
    public string ToSymbolicPermissions();
}
public class Azure.Storage.Files.DataLake.Models.PathProperties : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CopyCompletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyStatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyStatus <CopyStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIncrementalCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeLeaseDuration <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeLeaseState <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private DataLakeLeaseStatus <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AcceptRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArchiveStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <AccessTierChangedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PathAccessControlItem> <AccessControlList>k__BackingField;
    public DateTimeOffset LastModified { get; internal set; }
    public DateTimeOffset CreatedOn { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public DateTimeOffset CopyCompletedOn { get; internal set; }
    public string CopyStatusDescription { get; internal set; }
    public string CopyId { get; internal set; }
    public string CopyProgress { get; internal set; }
    public Uri CopySource { get; internal set; }
    public CopyStatus CopyStatus { get; internal set; }
    public bool IsIncrementalCopy { get; internal set; }
    public DataLakeLeaseDuration LeaseDuration { get; internal set; }
    public DataLakeLeaseState LeaseState { get; internal set; }
    public DataLakeLeaseStatus LeaseStatus { get; internal set; }
    public long ContentLength { get; internal set; }
    public string ContentType { get; internal set; }
    public ETag ETag { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public string ContentEncoding { get; internal set; }
    public string ContentDisposition { get; internal set; }
    public string ContentLanguage { get; internal set; }
    public string CacheControl { get; internal set; }
    public string AcceptRanges { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    public string EncryptionKeySha256 { get; internal set; }
    public string AccessTier { get; internal set; }
    public string ArchiveStatus { get; internal set; }
    public DateTimeOffset AccessTierChangedOn { get; internal set; }
    public DateTimeOffset ExpiresOn { get; internal set; }
    public string EncryptionScope { get; internal set; }
    public string EncryptionContext { get; internal set; }
    public string Owner { get; internal set; }
    public string Group { get; internal set; }
    public string Permissions { get; internal set; }
    public bool IsDirectory { get; internal set; }
    public IList`1<PathAccessControlItem> AccessControlList { get; public set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CopyCompletedOn();
    [CompilerGeneratedAttribute]
internal void set_CopyCompletedOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_CopyStatusDescription();
    [CompilerGeneratedAttribute]
internal void set_CopyStatusDescription(string value);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
internal void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public string get_CopyProgress();
    [CompilerGeneratedAttribute]
internal void set_CopyProgress(string value);
    [CompilerGeneratedAttribute]
public Uri get_CopySource();
    [CompilerGeneratedAttribute]
internal void set_CopySource(Uri value);
    [CompilerGeneratedAttribute]
public CopyStatus get_CopyStatus();
    [CompilerGeneratedAttribute]
internal void set_CopyStatus(CopyStatus value);
    [CompilerGeneratedAttribute]
public bool get_IsIncrementalCopy();
    [CompilerGeneratedAttribute]
internal void set_IsIncrementalCopy(bool value);
    [CompilerGeneratedAttribute]
public DataLakeLeaseDuration get_LeaseDuration();
    [CompilerGeneratedAttribute]
internal void set_LeaseDuration(DataLakeLeaseDuration value);
    [CompilerGeneratedAttribute]
public DataLakeLeaseState get_LeaseState();
    [CompilerGeneratedAttribute]
internal void set_LeaseState(DataLakeLeaseState value);
    [CompilerGeneratedAttribute]
public DataLakeLeaseStatus get_LeaseStatus();
    [CompilerGeneratedAttribute]
internal void set_LeaseStatus(DataLakeLeaseStatus value);
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
internal void set_ContentLength(long value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
internal void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
internal void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
internal void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
internal void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_AcceptRanges();
    [CompilerGeneratedAttribute]
internal void set_AcceptRanges(string value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKeySha256();
    [CompilerGeneratedAttribute]
internal void set_EncryptionKeySha256(string value);
    [CompilerGeneratedAttribute]
public string get_AccessTier();
    [CompilerGeneratedAttribute]
internal void set_AccessTier(string value);
    [CompilerGeneratedAttribute]
public string get_ArchiveStatus();
    [CompilerGeneratedAttribute]
internal void set_ArchiveStatus(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_AccessTierChangedOn();
    [CompilerGeneratedAttribute]
internal void set_AccessTierChangedOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionContext();
    [CompilerGeneratedAttribute]
internal void set_EncryptionContext(string value);
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(string value);
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
internal void set_Group(string value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
internal void set_Permissions(string value);
    public bool get_IsDirectory();
    internal void set_IsDirectory(bool value);
    [CompilerGeneratedAttribute]
public IList`1<PathAccessControlItem> get_AccessControlList();
    [CompilerGeneratedAttribute]
public void set_AccessControlList(IList`1<PathAccessControlItem> value);
}
public enum Azure.Storage.Files.DataLake.Models.PathRenameMode : Enum {
    public int value__;
    public static PathRenameMode Legacy;
    public static PathRenameMode Posix;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.Models.PathRenameModeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(PathRenameMode value);
    [ExtensionAttribute]
public static PathRenameMode ToPathRenameMode(string value);
}
public enum Azure.Storage.Files.DataLake.Models.PathResourceType : Enum {
    public int value__;
    public static PathResourceType Directory;
    public static PathResourceType File;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.Models.PathResourceTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(PathResourceType value);
    [ExtensionAttribute]
public static PathResourceType ToPathResourceType(string value);
}
internal class Azure.Storage.Files.DataLake.Models.PathSegment : object {
    [CompilerGeneratedAttribute]
private string <Continuation>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PathItem> <Paths>k__BackingField;
    public string Continuation { get; internal set; }
    public IEnumerable`1<PathItem> Paths { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Continuation();
    [CompilerGeneratedAttribute]
internal void set_Continuation(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PathItem> get_Paths();
    [CompilerGeneratedAttribute]
internal void set_Paths(IEnumerable`1<PathItem> value);
}
internal enum Azure.Storage.Files.DataLake.Models.PathSetAccessControlRecursiveMode : Enum {
    public int value__;
    public static PathSetAccessControlRecursiveMode Set;
    public static PathSetAccessControlRecursiveMode Modify;
    public static PathSetAccessControlRecursiveMode Remove;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.Models.PathSetAccessControlRecursiveModeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(PathSetAccessControlRecursiveMode value);
    [ExtensionAttribute]
public static PathSetAccessControlRecursiveMode ToPathSetAccessControlRecursiveMode(string value);
}
public enum Azure.Storage.Files.DataLake.Models.PathUpdateAction : Enum {
    public int value__;
    public static PathUpdateAction Append;
    public static PathUpdateAction Flush;
    public static PathUpdateAction SetProperties;
    public static PathUpdateAction SetAccessControl;
    public static PathUpdateAction SetAccessControlRecursive;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.DataLake.Models.PathUpdateActionExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(PathUpdateAction value);
    [ExtensionAttribute]
public static PathUpdateAction ToPathUpdateAction(string value);
}
public enum Azure.Storage.Files.DataLake.Models.PublicAccessType : Enum {
    public int value__;
    public static PublicAccessType None;
    public static PublicAccessType FileSystem;
    public static PublicAccessType Path;
}
[IsReadOnlyAttribute]
public class Azure.Storage.Files.DataLake.Models.ReleasedObjectInfo : ValueType {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    public ETag ETag { get; }
    public DateTimeOffset LastModified { get; }
    public ReleasedObjectInfo(ETag eTag, DateTimeOffset lastModified);
    internal ReleasedObjectInfo(PathInfo info);
    internal ReleasedObjectInfo(FileSystemInfo info);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReleasedObjectInfo other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static bool op_Equality(ReleasedObjectInfo left, ReleasedObjectInfo right);
    public static bool op_Inequality(ReleasedObjectInfo left, ReleasedObjectInfo right);
}
public class Azure.Storage.Files.DataLake.Models.RemovePathAccessControlItem : object {
    [CompilerGeneratedAttribute]
private bool <DefaultScope>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessControlType <AccessControlType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityId>k__BackingField;
    public bool DefaultScope { get; }
    public AccessControlType AccessControlType { get; }
    public string EntityId { get; }
    public RemovePathAccessControlItem(AccessControlType accessControlType, bool defaultScope, string entityId);
    [CompilerGeneratedAttribute]
public bool get_DefaultScope();
    [CompilerGeneratedAttribute]
public AccessControlType get_AccessControlType();
    [CompilerGeneratedAttribute]
public string get_EntityId();
    public virtual string ToString();
    public static RemovePathAccessControlItem Parse(string serializedAccessControl);
    public static string ToAccessControlListString(IList`1<RemovePathAccessControlItem> accessControlList);
    public static IList`1<RemovePathAccessControlItem> ParseAccessControlList(string s);
}
[FlagsAttribute]
public enum Azure.Storage.Files.DataLake.Models.RolePermissions : Enum {
    public int value__;
    public static RolePermissions None;
    public static RolePermissions Execute;
    public static RolePermissions Write;
    public static RolePermissions Read;
}
internal class Azure.Storage.Files.DataLake.Models.SetAccessControlRecursiveResponse : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DirectoriesSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FilesSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FailureCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AclFailedEntry> <FailedEntries>k__BackingField;
    public Nullable`1<int> DirectoriesSuccessful { get; public set; }
    public Nullable`1<int> FilesSuccessful { get; public set; }
    public Nullable`1<int> FailureCount { get; public set; }
    public IReadOnlyList`1<AclFailedEntry> FailedEntries { get; public set; }
    internal SetAccessControlRecursiveResponse(Nullable`1<int> directoriesSuccessful, Nullable`1<int> filesSuccessful, Nullable`1<int> failureCount, IReadOnlyList`1<AclFailedEntry> failedEntries);
    internal static SetAccessControlRecursiveResponse DeserializeSetAccessControlRecursiveResponse(JsonElement element);
    internal static SetAccessControlRecursiveResponse FromResponse(Response response);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DirectoriesSuccessful();
    [CompilerGeneratedAttribute]
public void set_DirectoriesSuccessful(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FilesSuccessful();
    [CompilerGeneratedAttribute]
public void set_FilesSuccessful(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FailureCount();
    [CompilerGeneratedAttribute]
public void set_FailureCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AclFailedEntry> get_FailedEntries();
    [CompilerGeneratedAttribute]
public void set_FailedEntries(IReadOnlyList`1<AclFailedEntry> value);
}
internal class Azure.Storage.Files.DataLake.Models.StorageError : object {
    [CompilerGeneratedAttribute]
private StorageErrorError <Error>k__BackingField;
    public StorageErrorError Error { get; }
    internal StorageError(StorageErrorError error);
    [CompilerGeneratedAttribute]
public StorageErrorError get_Error();
    internal static StorageError DeserializeStorageError(XElement element);
    internal static StorageError DeserializeStorageError(JsonElement element);
    internal static StorageError FromResponse(Response response);
}
internal class Azure.Storage.Files.DataLake.Models.StorageErrorError : object {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Code { get; }
    public string Message { get; }
    internal StorageErrorError(string code, string message);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public string get_Message();
    internal static StorageErrorError DeserializeStorageErrorError(XElement element);
    internal static StorageErrorError DeserializeStorageErrorError(JsonElement element);
    internal static StorageErrorError FromResponse(Response response);
}
public class Azure.Storage.Files.DataLake.Models.UserDelegationKey : object {
    [CompilerGeneratedAttribute]
private string <SignedObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignedTenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignedStartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignedExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignedService>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string SignedObjectId { get; internal set; }
    public string SignedTenantId { get; internal set; }
    public DateTimeOffset SignedStartsOn { get; internal set; }
    public DateTimeOffset SignedExpiresOn { get; internal set; }
    public string SignedService { get; internal set; }
    public string SignedVersion { get; internal set; }
    public string Value { get; internal set; }
    internal UserDelegationKey(UserDelegationKey blobUserDelegationKey);
    [CompilerGeneratedAttribute]
public string get_SignedObjectId();
    [CompilerGeneratedAttribute]
internal void set_SignedObjectId(string value);
    [CompilerGeneratedAttribute]
public string get_SignedTenantId();
    [CompilerGeneratedAttribute]
internal void set_SignedTenantId(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignedStartsOn();
    [CompilerGeneratedAttribute]
internal void set_SignedStartsOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignedExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_SignedExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_SignedService();
    [CompilerGeneratedAttribute]
internal void set_SignedService(string value);
    [CompilerGeneratedAttribute]
public string get_SignedVersion();
    [CompilerGeneratedAttribute]
internal void set_SignedVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(string value);
}
internal class Azure.Storage.Files.DataLake.PathAppendDataHeaders : object {
    private Response _response;
    public string Version { get; }
    public Byte[] ContentMD5 { get; }
    public Byte[] XMsContentCrc64 { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public Nullable`1<bool> LeaseRenewed { get; }
    public PathAppendDataHeaders(Response response);
    public string get_Version();
    public Byte[] get_ContentMD5();
    public Byte[] get_XMsContentCrc64();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public Nullable`1<bool> get_LeaseRenewed();
}
internal class Azure.Storage.Files.DataLake.PathCreateHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string Continuation { get; }
    public Nullable`1<long> ContentLength { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public PathCreateHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_Continuation();
    public Nullable`1<long> get_ContentLength();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
}
internal class Azure.Storage.Files.DataLake.PathDeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public string Continuation { get; }
    public string DeletionId { get; }
    public PathDeleteHeaders(Response response);
    public string get_Version();
    public string get_Continuation();
    public string get_DeletionId();
}
internal class Azure.Storage.Files.DataLake.PathFlushDataHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<long> ContentLength { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public Nullable`1<bool> LeaseRenewed { get; }
    public PathFlushDataHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<long> get_ContentLength();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public Nullable`1<bool> get_LeaseRenewed();
}
internal class Azure.Storage.Files.DataLake.PathGetPropertiesHeaders : object {
    private Response _response;
    public string AcceptRanges { get; }
    public string CacheControl { get; }
    public string ContentDisposition { get; }
    public string ContentEncoding { get; }
    public string ContentLanguage { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentRange { get; }
    public string ContentType { get; }
    public string ContentMD5 { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string ResourceType { get; }
    public string Properties { get; }
    public string Owner { get; }
    public string Group { get; }
    public string Permissions { get; }
    public string ACL { get; }
    public string LeaseDuration { get; }
    public string LeaseState { get; }
    public string LeaseStatus { get; }
    public PathGetPropertiesHeaders(Response response);
    public string get_AcceptRanges();
    public string get_CacheControl();
    public string get_ContentDisposition();
    public string get_ContentEncoding();
    public string get_ContentLanguage();
    public Nullable`1<long> get_ContentLength();
    public string get_ContentRange();
    public string get_ContentType();
    public string get_ContentMD5();
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_ResourceType();
    public string get_Properties();
    public string get_Owner();
    public string get_Group();
    public string get_Permissions();
    public string get_ACL();
    public string get_LeaseDuration();
    public string get_LeaseState();
    public string get_LeaseStatus();
}
internal class Azure.Storage.Files.DataLake.PathLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string LeaseId { get; }
    public string LeaseTime { get; }
    public PathLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_LeaseId();
    public string get_LeaseTime();
}
internal class Azure.Storage.Files.DataLake.PathReadHeaders : object {
    private Response _response;
    public string AcceptRanges { get; }
    public string CacheControl { get; }
    public string ContentDisposition { get; }
    public string ContentEncoding { get; }
    public string ContentLanguage { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentRange { get; }
    public string ContentType { get; }
    public string ContentMD5 { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string ResourceType { get; }
    public string Properties { get; }
    public string LeaseDuration { get; }
    public string LeaseState { get; }
    public string LeaseStatus { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string XMsContentMd5 { get; }
    public PathReadHeaders(Response response);
    public string get_AcceptRanges();
    public string get_CacheControl();
    public string get_ContentDisposition();
    public string get_ContentEncoding();
    public string get_ContentLanguage();
    public Nullable`1<long> get_ContentLength();
    public string get_ContentRange();
    public string get_ContentType();
    public string get_ContentMD5();
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_ResourceType();
    public string get_Properties();
    public string get_LeaseDuration();
    public string get_LeaseState();
    public string get_LeaseStatus();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_XMsContentMd5();
}
internal class Azure.Storage.Files.DataLake.PathRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    private Nullable`1<int> _xMsLeaseDuration;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public PathRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version, Nullable`1<int> xMsLeaseDuration);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateCreateRequest(Nullable`1<int> timeout, Nullable`1<PathResourceType> resource, string continuation, Nullable`1<PathRenameMode> mode, string cacheControl, string contentEncoding, string contentLanguage, string contentDisposition, string contentType, string renameSource, string leaseId, string sourceLeaseId, string properties, string permissions, string umask, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string owner, string group, string acl, string proposedLeaseId, Nullable`1<long> leaseDuration, Nullable`1<PathExpiryOptions> expiryOptions, string expiresOn, string encryptionContext);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<CreateAsync>d__9")]
public Task`1<ResponseWithHeaders`1<PathCreateHeaders>> CreateAsync(Nullable`1<int> timeout, Nullable`1<PathResourceType> resource, string continuation, Nullable`1<PathRenameMode> mode, string cacheControl, string contentEncoding, string contentLanguage, string contentDisposition, string contentType, string renameSource, string leaseId, string sourceLeaseId, string properties, string permissions, string umask, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string owner, string group, string acl, string proposedLeaseId, Nullable`1<long> leaseDuration, Nullable`1<PathExpiryOptions> expiryOptions, string expiresOn, string encryptionContext, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PathCreateHeaders> Create(Nullable`1<int> timeout, Nullable`1<PathResourceType> resource, string continuation, Nullable`1<PathRenameMode> mode, string cacheControl, string contentEncoding, string contentLanguage, string contentDisposition, string contentType, string renameSource, string leaseId, string sourceLeaseId, string properties, string permissions, string umask, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string owner, string group, string acl, string proposedLeaseId, Nullable`1<long> leaseDuration, Nullable`1<PathExpiryOptions> expiryOptions, string expiresOn, string encryptionContext, CancellationToken cancellationToken);
    internal HttpMessage CreateUpdateRequest(PathUpdateAction action, PathSetAccessControlRecursiveMode mode, Stream body, Nullable`1<int> timeout, Nullable`1<int> maxRecords, string continuation, Nullable`1<bool> forceFlag, Nullable`1<long> position, Nullable`1<bool> retainUncommittedData, Nullable`1<bool> close, Nullable`1<long> contentLength, Byte[] contentMD5, string leaseId, string cacheControl, string contentType, string contentDisposition, string contentEncoding, string contentLanguage, string properties, string owner, string group, string permissions, string acl, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<UpdateAsync>d__12")]
public Task`1<ResponseWithHeaders`2<SetAccessControlRecursiveResponse, PathUpdateHeaders>> UpdateAsync(PathUpdateAction action, PathSetAccessControlRecursiveMode mode, Stream body, Nullable`1<int> timeout, Nullable`1<int> maxRecords, string continuation, Nullable`1<bool> forceFlag, Nullable`1<long> position, Nullable`1<bool> retainUncommittedData, Nullable`1<bool> close, Nullable`1<long> contentLength, Byte[] contentMD5, string leaseId, string cacheControl, string contentType, string contentDisposition, string contentEncoding, string contentLanguage, string properties, string owner, string group, string permissions, string acl, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<SetAccessControlRecursiveResponse, PathUpdateHeaders> Update(PathUpdateAction action, PathSetAccessControlRecursiveMode mode, Stream body, Nullable`1<int> timeout, Nullable`1<int> maxRecords, string continuation, Nullable`1<bool> forceFlag, Nullable`1<long> position, Nullable`1<bool> retainUncommittedData, Nullable`1<bool> close, Nullable`1<long> contentLength, Byte[] contentMD5, string leaseId, string cacheControl, string contentType, string contentDisposition, string contentEncoding, string contentLanguage, string properties, string owner, string group, string permissions, string acl, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateLeaseRequest(PathLeaseAction xMsLeaseAction, Nullable`1<int> timeout, Nullable`1<int> xMsLeaseBreakPeriod, string leaseId, string proposedLeaseId, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<LeaseAsync>d__15")]
public Task`1<ResponseWithHeaders`1<PathLeaseHeaders>> LeaseAsync(PathLeaseAction xMsLeaseAction, Nullable`1<int> timeout, Nullable`1<int> xMsLeaseBreakPeriod, string leaseId, string proposedLeaseId, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PathLeaseHeaders> Lease(PathLeaseAction xMsLeaseAction, Nullable`1<int> timeout, Nullable`1<int> xMsLeaseBreakPeriod, string leaseId, string proposedLeaseId, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateReadRequest(Nullable`1<int> timeout, string range, string leaseId, Nullable`1<bool> xMsRangeGetContentMd5, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<ReadAsync>d__18")]
public Task`1<ResponseWithHeaders`2<Stream, PathReadHeaders>> ReadAsync(Nullable`1<int> timeout, string range, string leaseId, Nullable`1<bool> xMsRangeGetContentMd5, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<Stream, PathReadHeaders> Read(Nullable`1<int> timeout, string range, string leaseId, Nullable`1<bool> xMsRangeGetContentMd5, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(Nullable`1<int> timeout, Nullable`1<PathGetPropertiesAction> action, Nullable`1<bool> upn, string leaseId, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<GetPropertiesAsync>d__21")]
public Task`1<ResponseWithHeaders`1<PathGetPropertiesHeaders>> GetPropertiesAsync(Nullable`1<int> timeout, Nullable`1<PathGetPropertiesAction> action, Nullable`1<bool> upn, string leaseId, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PathGetPropertiesHeaders> GetProperties(Nullable`1<int> timeout, Nullable`1<PathGetPropertiesAction> action, Nullable`1<bool> upn, string leaseId, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateDeleteRequest(Nullable`1<int> timeout, Nullable`1<bool> recursive, string continuation, string leaseId, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, Nullable`1<bool> paginated);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<DeleteAsync>d__24")]
public Task`1<ResponseWithHeaders`1<PathDeleteHeaders>> DeleteAsync(Nullable`1<int> timeout, Nullable`1<bool> recursive, string continuation, string leaseId, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, Nullable`1<bool> paginated, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PathDeleteHeaders> Delete(Nullable`1<int> timeout, Nullable`1<bool> recursive, string continuation, string leaseId, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, Nullable`1<bool> paginated, CancellationToken cancellationToken);
    internal HttpMessage CreateSetAccessControlRequest(Nullable`1<int> timeout, string leaseId, string owner, string group, string permissions, string acl, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<SetAccessControlAsync>d__27")]
public Task`1<ResponseWithHeaders`1<PathSetAccessControlHeaders>> SetAccessControlAsync(Nullable`1<int> timeout, string leaseId, string owner, string group, string permissions, string acl, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PathSetAccessControlHeaders> SetAccessControl(Nullable`1<int> timeout, string leaseId, string owner, string group, string permissions, string acl, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateSetAccessControlRecursiveRequest(PathSetAccessControlRecursiveMode mode, Nullable`1<int> timeout, string continuation, Nullable`1<bool> forceFlag, Nullable`1<int> maxRecords, string acl);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<SetAccessControlRecursiveAsync>d__30")]
public Task`1<ResponseWithHeaders`2<SetAccessControlRecursiveResponse, PathSetAccessControlRecursiveHeaders>> SetAccessControlRecursiveAsync(PathSetAccessControlRecursiveMode mode, Nullable`1<int> timeout, string continuation, Nullable`1<bool> forceFlag, Nullable`1<int> maxRecords, string acl, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<SetAccessControlRecursiveResponse, PathSetAccessControlRecursiveHeaders> SetAccessControlRecursive(PathSetAccessControlRecursiveMode mode, Nullable`1<int> timeout, string continuation, Nullable`1<bool> forceFlag, Nullable`1<int> maxRecords, string acl, CancellationToken cancellationToken);
    internal HttpMessage CreateFlushDataRequest(Nullable`1<int> timeout, Nullable`1<long> position, Nullable`1<bool> retainUncommittedData, Nullable`1<bool> close, Nullable`1<long> contentLength, Byte[] contentMD5, string leaseId, Nullable`1<DataLakeLeaseAction> leaseAction, Nullable`1<long> leaseDuration, string proposedLeaseId, string cacheControl, string contentType, string contentDisposition, string contentEncoding, string contentLanguage, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<FlushDataAsync>d__33")]
public Task`1<ResponseWithHeaders`1<PathFlushDataHeaders>> FlushDataAsync(Nullable`1<int> timeout, Nullable`1<long> position, Nullable`1<bool> retainUncommittedData, Nullable`1<bool> close, Nullable`1<long> contentLength, Byte[] contentMD5, string leaseId, Nullable`1<DataLakeLeaseAction> leaseAction, Nullable`1<long> leaseDuration, string proposedLeaseId, string cacheControl, string contentType, string contentDisposition, string contentEncoding, string contentLanguage, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PathFlushDataHeaders> FlushData(Nullable`1<int> timeout, Nullable`1<long> position, Nullable`1<bool> retainUncommittedData, Nullable`1<bool> close, Nullable`1<long> contentLength, Byte[] contentMD5, string leaseId, Nullable`1<DataLakeLeaseAction> leaseAction, Nullable`1<long> leaseDuration, string proposedLeaseId, string cacheControl, string contentType, string contentDisposition, string contentEncoding, string contentLanguage, string ifMatch, string ifNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, CancellationToken cancellationToken);
    internal HttpMessage CreateAppendDataRequest(Stream body, Nullable`1<long> position, Nullable`1<int> timeout, Nullable`1<long> contentLength, Byte[] transactionalContentHash, Byte[] transactionalContentCrc64, string leaseId, Nullable`1<DataLakeLeaseAction> leaseAction, Nullable`1<long> leaseDuration, string proposedLeaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<bool> flush);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<AppendDataAsync>d__36")]
public Task`1<ResponseWithHeaders`1<PathAppendDataHeaders>> AppendDataAsync(Stream body, Nullable`1<long> position, Nullable`1<int> timeout, Nullable`1<long> contentLength, Byte[] transactionalContentHash, Byte[] transactionalContentCrc64, string leaseId, Nullable`1<DataLakeLeaseAction> leaseAction, Nullable`1<long> leaseDuration, string proposedLeaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<bool> flush, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PathAppendDataHeaders> AppendData(Stream body, Nullable`1<long> position, Nullable`1<int> timeout, Nullable`1<long> contentLength, Byte[] transactionalContentHash, Byte[] transactionalContentCrc64, string leaseId, Nullable`1<DataLakeLeaseAction> leaseAction, Nullable`1<long> leaseDuration, string proposedLeaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<bool> flush, CancellationToken cancellationToken);
    internal HttpMessage CreateSetExpiryRequest(PathExpiryOptions expiryOptions, Nullable`1<int> timeout, string expiresOn);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<SetExpiryAsync>d__39")]
public Task`1<ResponseWithHeaders`1<PathSetExpiryHeaders>> SetExpiryAsync(PathExpiryOptions expiryOptions, Nullable`1<int> timeout, string expiresOn, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PathSetExpiryHeaders> SetExpiry(PathExpiryOptions expiryOptions, Nullable`1<int> timeout, string expiresOn, CancellationToken cancellationToken);
    internal HttpMessage CreateUndeleteRequest(Nullable`1<int> timeout, string undeleteSource);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.PathRestClient/<UndeleteAsync>d__42")]
public Task`1<ResponseWithHeaders`1<PathUndeleteHeaders>> UndeleteAsync(Nullable`1<int> timeout, string undeleteSource, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PathUndeleteHeaders> Undelete(Nullable`1<int> timeout, string undeleteSource, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.DataLake.PathSetAccessControlHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public PathSetAccessControlHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Files.DataLake.PathSetAccessControlRecursiveHeaders : object {
    private Response _response;
    public string Continuation { get; }
    public string Version { get; }
    public PathSetAccessControlRecursiveHeaders(Response response);
    public string get_Continuation();
    public string get_Version();
}
internal class Azure.Storage.Files.DataLake.PathSetExpiryHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public PathSetExpiryHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Files.DataLake.PathUndeleteHeaders : object {
    private Response _response;
    public string ResourceType { get; }
    public string Version { get; }
    public PathUndeleteHeaders(Response response);
    public string get_ResourceType();
    public string get_Version();
}
internal class Azure.Storage.Files.DataLake.PathUpdateHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string AcceptRanges { get; }
    public string CacheControl { get; }
    public string ContentDisposition { get; }
    public string ContentEncoding { get; }
    public string ContentLanguage { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentRange { get; }
    public string ContentType { get; }
    public string ContentMD5 { get; }
    public string Properties { get; }
    public string XMsContinuation { get; }
    public string Version { get; }
    public PathUpdateHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_AcceptRanges();
    public string get_CacheControl();
    public string get_ContentDisposition();
    public string get_ContentEncoding();
    public string get_ContentLanguage();
    public Nullable`1<long> get_ContentLength();
    public string get_ContentRange();
    public string get_ContentType();
    public string get_ContentMD5();
    public string get_Properties();
    public string get_XMsContinuation();
    public string get_Version();
}
internal class Azure.Storage.Files.DataLake.ServiceListFileSystemsHeaders : object {
    private Response _response;
    public string Version { get; }
    public string Continuation { get; }
    public string ContentType { get; }
    public ServiceListFileSystemsHeaders(Response response);
    public string get_Version();
    public string get_Continuation();
    public string get_ContentType();
}
internal class Azure.Storage.Files.DataLake.ServiceRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public ServiceRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateListFileSystemsRequest(string prefix, string continuation, Nullable`1<int> maxResults, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.DataLake.ServiceRestClient/<ListFileSystemsAsync>d__8")]
public Task`1<ResponseWithHeaders`2<FileSystemList, ServiceListFileSystemsHeaders>> ListFileSystemsAsync(string prefix, string continuation, Nullable`1<int> maxResults, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<FileSystemList, ServiceListFileSystemsHeaders> ListFileSystems(string prefix, string continuation, Nullable`1<int> maxResults, Nullable`1<int> timeout, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Azure.Storage.Files.DataLake.Specialized.SpecializedDataLakeExtensions : object {
    [ExtensionAttribute]
public static DataLakeServiceClient GetParentServiceClient(DataLakeFileSystemClient client);
    [ExtensionAttribute]
public static DataLakeFileSystemClient GetParentFileSystemClient(DataLakePathClient client);
    [ExtensionAttribute]
public static DataLakeDirectoryClient GetParentDirectoryClient(DataLakePathClient client);
}
internal class Azure.Storage.GeoRedundantReadPolicy : HttpPipelineSynchronousPolicy {
    private string _secondaryStorageHost;
    public GeoRedundantReadPolicy(Uri secondaryStorageUri);
    public virtual void OnSendingRequest(HttpMessage message);
}
internal class Azure.Storage.HashAlgorithmHasher : object {
    private HashAlgorithm _hashAlgorithm;
    public int HashSizeInBytes { get; }
    public HashAlgorithmHasher(HashAlgorithm hashAlgorithm);
    public sealed virtual int get_HashSizeInBytes();
    [AsyncStateMachineAttribute("Azure.Storage.HashAlgorithmHasher/<ComputeHashInternal>d__4")]
public sealed virtual Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);
    public sealed virtual void AppendHash(ReadOnlySpan`1<byte> content);
    public sealed virtual int GetFinalHash(Span`1<byte> hashDestination);
    public sealed virtual void Dispose();
    private static int BitsToBytes(int bits);
}
internal interface Azure.Storage.IHasher {
    public int HashSizeInBytes { get; }
    public abstract virtual int get_HashSizeInBytes();
    public abstract virtual Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);
    public abstract virtual void AppendHash(ReadOnlySpan`1<byte> content);
    public abstract virtual int GetFinalHash(Span`1<byte> hashDestination);
}
[ExtensionAttribute]
internal static class Azure.Storage.IHasherExtensions : object {
    [ExtensionAttribute]
public static Memory`1<byte> GetFinalHash(IHasher hasher);
}
[ExtensionAttribute]
internal static class Azure.Storage.LoggingExtensions : object {
    [ExtensionAttribute]
public static IDisposable BeginLoggingScope(HttpPipeline pipeline, string className, string member);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogMethodEnter(HttpPipeline pipeline, string className, string member, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogMethodExit(HttpPipeline pipeline, string className, string member, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogException(HttpPipeline pipeline, Exception ex, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogTrace(HttpPipeline pipeline, string message);
}
internal class Azure.Storage.NonCryptographicHashAlgorithmHasher : object {
    private static int _streamBufferSize;
    private NonCryptographicHashAlgorithm _nonCryptographicHashAlgorithm;
    public int HashSizeInBytes { get; }
    public NonCryptographicHashAlgorithmHasher(NonCryptographicHashAlgorithm nonCryptographicHashAlgorithm);
    public sealed virtual int get_HashSizeInBytes();
    [AsyncStateMachineAttribute("Azure.Storage.NonCryptographicHashAlgorithmHasher/<ComputeHashInternal>d__5")]
public sealed virtual Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);
    public sealed virtual void AppendHash(ReadOnlySpan`1<byte> content);
    public sealed virtual int GetFinalHash(Span`1<byte> hashDestination);
    public sealed virtual void Dispose();
}
internal class Azure.Storage.NonDisposingStream : Stream {
    private Stream _innerStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public NonDisposingStream(Stream innerStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
}
internal class Azure.Storage.PartitionedUploader`2 : object {
    public static InitializeDestinationInternal<TServiceSpecificData, TCompleteUploadReturn> InitializeNoOp;
    private InitializeDestinationInternal<TServiceSpecificData, TCompleteUploadReturn> _initializeDestinationInternal;
    private SingleUploadStreamingInternal<TServiceSpecificData, TCompleteUploadReturn> _singleUploadStreamingInternal;
    private SingleUploadBinaryDataInternal<TServiceSpecificData, TCompleteUploadReturn> _singleUploadBinaryDataInternal;
    private UploadPartitionStreamingInternal<TServiceSpecificData, TCompleteUploadReturn> _uploadPartitionStreamingInternal;
    private UploadPartitionBinaryDataInternal<TServiceSpecificData, TCompleteUploadReturn> _uploadPartitionBinaryDataInternal;
    private CommitPartitionedUploadInternal<TServiceSpecificData, TCompleteUploadReturn> _commitPartitionedUploadInternal;
    private CreateScope<TServiceSpecificData, TCompleteUploadReturn> _createScope;
    private int _maxWorkerCount;
    private ArrayPool`1<byte> _arrayPool;
    private long _singleUploadThreshold;
    private Nullable`1<long> _blockSize;
    private StorageChecksumAlgorithm _validationAlgorithm;
    private Func`1<Memory`1<byte>> _masterCrcSupplier;
    private string _operationName;
    private bool UseMasterCrc { get; }
    private UploadTransferValidationOptions ValidationOptions { get; }
    public PartitionedUploader`2(Behaviors<TServiceSpecificData, TCompleteUploadReturn> behaviors, StorageTransferOptions transferOptions, UploadTransferValidationOptions transferValidation, ArrayPool`1<byte> arrayPool, string operationName);
    private static PartitionedUploader`2();
    private bool get_UseMasterCrc();
    private UploadTransferValidationOptions get_ValidationOptions();
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInternal>d__32")]
public Task`1<Response`1<TCompleteUploadReturn>> UploadInternal(BinaryData content, TServiceSpecificData args, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInternal>d__33")]
public Task`1<Response`1<TCompleteUploadReturn>> UploadInternal(Stream content, Nullable`1<long> expectedContentLength, TServiceSpecificData args, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<BufferAndOptionalChecksumStreamInternal>d__34")]
private Task`1<ValueTuple`2<Stream, UploadTransferValidationOptions>> BufferAndOptionalChecksumStreamInternal(Stream source, long minCount, long maxCount, UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInSequenceInternal>d__35`1")]
private Task`1<Response`1<TCompleteUploadReturn>> UploadInSequenceInternal(TContent content, Nullable`1<long> contentLength, long partitionSize, TServiceSpecificData args, IProgress`1<long> progressHandler, GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> partitionContentAsync, StageContentPartitionAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> stageContentAsync, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInParallelAsync>d__36`1")]
private Task`1<Response`1<TCompleteUploadReturn>> UploadInParallelAsync(TContent content, Nullable`1<long> contentLength, long blockSize, TServiceSpecificData args, IProgress`1<long> progressHandler, GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> partitionContentAsync, StageContentPartitionAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> stageContentAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<StageStreamPartitionInternal>d__37")]
private Task StageStreamPartitionInternal(Stream partition, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<StageBinaryDataPartitionInternal>d__38")]
private Task StageBinaryDataPartitionInternal(BinaryData content, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetContentPartitionsBinaryDataInternal>d__39")]
private IAsyncEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, BinaryData>> GetContentPartitionsBinaryDataInternal(BinaryData content, Nullable`1<long> contentLength, long blockSize, bool async, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetBinaryDataPartitions>d__40")]
private IEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, BinaryData>> GetBinaryDataPartitions(BinaryData content, int blockSize);
    private static GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, Stream> GetStreamPartitioner(GetNextStreamPartition<TServiceSpecificData, TCompleteUploadReturn> partitionCreator);
    [AsyncIteratorStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetStreamPartitionsAsync>d__42")]
private static IAsyncEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, Stream>> GetStreamPartitionsAsync(Stream stream, Nullable`1<long> streamLength, long blockSize, GetNextStreamPartition<TServiceSpecificData, TCompleteUploadReturn> getNextPartition, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetBufferedPartitionInternal>d__43")]
private Task`1<ValueTuple`2<Stream, ReadOnlyMemory`1<byte>>> GetBufferedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetStreamedPartitionInternal>d__44")]
private Task`1<ValueTuple`2<Stream, ReadOnlyMemory`1<byte>>> GetStreamedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Azure.Storage.PathExtensions : object {
    [ExtensionAttribute]
public static string GetParentPath(string path, char delimiter);
}
internal class Azure.Storage.ProgressIncrementingStream : Stream {
    private Stream _innerStream;
    private AggregatingProgressIncrementer _incrementer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public ProgressIncrementingStream(Stream stream, AggregatingProgressIncrementer incrementer);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Azure.Storage.ProgressIncrementingStream/<FlushAsync>d__12")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ProgressIncrementingStream/<ReadAsync>d__20")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ProgressIncrementingStream/<WriteAsync>d__28")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
[FlagsAttribute]
public enum Azure.Storage.Sas.DataLakeAccountSasPermissions : Enum {
    public int value__;
    public static DataLakeAccountSasPermissions Read;
    public static DataLakeAccountSasPermissions Add;
    public static DataLakeAccountSasPermissions Create;
    public static DataLakeAccountSasPermissions Write;
    public static DataLakeAccountSasPermissions Delete;
    public static DataLakeAccountSasPermissions List;
    public static DataLakeAccountSasPermissions All;
}
[FlagsAttribute]
public enum Azure.Storage.Sas.DataLakeFileSystemSasPermissions : Enum {
    public int value__;
    public static DataLakeFileSystemSasPermissions Read;
    public static DataLakeFileSystemSasPermissions Add;
    public static DataLakeFileSystemSasPermissions Create;
    public static DataLakeFileSystemSasPermissions Write;
    public static DataLakeFileSystemSasPermissions Delete;
    public static DataLakeFileSystemSasPermissions List;
    public static DataLakeFileSystemSasPermissions Move;
    public static DataLakeFileSystemSasPermissions Execute;
    public static DataLakeFileSystemSasPermissions ManageOwnership;
    public static DataLakeFileSystemSasPermissions ManageAccessControl;
    public static DataLakeFileSystemSasPermissions All;
}
public class Azure.Storage.Sas.DataLakeSasBuilder : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SasProtocol <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private SasIPRange <IPRange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileSystemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreauthorizedAgentObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AgentObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    private Nullable`1<int> _directoryDepth;
    private static List`1<char> s_validPermissionsInOrder;
    [EditorBrowsableAttribute("1")]
public string Version { get; public set; }
    public SasProtocol Protocol { get; public set; }
    public DateTimeOffset StartsOn { get; public set; }
    public DateTimeOffset ExpiresOn { get; public set; }
    public string Permissions { get; private set; }
    public SasIPRange IPRange { get; public set; }
    public string Identifier { get; public set; }
    public string FileSystemName { get; public set; }
    public string Path { get; public set; }
    public Nullable`1<bool> IsDirectory { get; public set; }
    public string Resource { get; public set; }
    public string CacheControl { get; public set; }
    public string ContentDisposition { get; public set; }
    public string ContentEncoding { get; public set; }
    public string ContentLanguage { get; public set; }
    public string ContentType { get; public set; }
    public string PreauthorizedAgentObjectId { get; public set; }
    public string AgentObjectId { get; public set; }
    public string CorrelationId { get; public set; }
    public string EncryptionScope { get; public set; }
    public DataLakeSasBuilder(DataLakeSasPermissions permissions, DateTimeOffset expiresOn);
    public DataLakeSasBuilder(DataLakeFileSystemSasPermissions permissions, DateTimeOffset expiresOn);
    private static DataLakeSasBuilder();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public SasProtocol get_Protocol();
    [CompilerGeneratedAttribute]
public void set_Protocol(SasProtocol value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartsOn();
    [CompilerGeneratedAttribute]
public void set_StartsOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
private void set_Permissions(string value);
    [CompilerGeneratedAttribute]
public SasIPRange get_IPRange();
    [CompilerGeneratedAttribute]
public void set_IPRange(SasIPRange value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public string get_FileSystemName();
    [CompilerGeneratedAttribute]
public void set_FileSystemName(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsDirectory();
    [CompilerGeneratedAttribute]
public void set_IsDirectory(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
public void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_PreauthorizedAgentObjectId();
    [CompilerGeneratedAttribute]
public void set_PreauthorizedAgentObjectId(string value);
    [CompilerGeneratedAttribute]
public string get_AgentObjectId();
    [CompilerGeneratedAttribute]
public void set_AgentObjectId(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public void set_EncryptionScope(string value);
    public void SetPermissions(DataLakeSasPermissions permissions);
    public void SetPermissions(DataLakeAccountSasPermissions permissions);
    public void SetPermissions(DataLakeFileSystemSasPermissions permissions);
    public void SetPermissions(string rawPermissions, bool normalize);
    public void SetPermissions(string rawPermissions);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public DataLakeSasQueryParameters ToSasQueryParameters(StorageSharedKeyCredential sharedKeyCredential);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public DataLakeSasQueryParameters ToSasQueryParameters(StorageSharedKeyCredential sharedKeyCredential, String& stringToSign);
    private string ToStringToSign(StorageSharedKeyCredential sharedKeyCredential);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public DataLakeSasQueryParameters ToSasQueryParameters(UserDelegationKey userDelegationKey, string accountName);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-datalake")]
public DataLakeSasQueryParameters ToSasQueryParameters(UserDelegationKey userDelegationKey, string accountName, String& stringToSign);
    private string ToStringToSign(UserDelegationKey userDelegationKey, string accountName);
    private static string GetCanonicalName(string account, string fileSystemName, string path);
    private static string ComputeHMACSHA256(string userDelegationKeyValue, string message);
    internal void EnsureState();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    internal static DataLakeSasBuilder DeepCopy(DataLakeSasBuilder originalDataLakeSasBuilder);
}
[FlagsAttribute]
public enum Azure.Storage.Sas.DataLakeSasPermissions : Enum {
    public int value__;
    public static DataLakeSasPermissions Read;
    public static DataLakeSasPermissions Add;
    public static DataLakeSasPermissions Create;
    public static DataLakeSasPermissions Write;
    public static DataLakeSasPermissions Delete;
    public static DataLakeSasPermissions List;
    public static DataLakeSasPermissions Move;
    public static DataLakeSasPermissions Execute;
    public static DataLakeSasPermissions ManageOwnership;
    public static DataLakeSasPermissions ManageAccessControl;
    public static DataLakeSasPermissions All;
}
public class Azure.Storage.Sas.DataLakeSasQueryParameters : SasQueryParameters {
    [CompilerGeneratedAttribute]
private UserDelegationKeyProperties <KeyProperties>k__BackingField;
    internal UserDelegationKeyProperties KeyProperties { get; internal set; }
    public string KeyObjectId { get; }
    public string KeyTenantId { get; }
    public DateTimeOffset KeyStartsOn { get; }
    public DateTimeOffset KeyExpiresOn { get; }
    public string KeyService { get; }
    public string KeyVersion { get; }
    public static DataLakeSasQueryParameters Empty { get; }
    internal DataLakeSasQueryParameters(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string keyOid, string keyTid, DateTimeOffset keyStart, DateTimeOffset keyExpiry, string keyService, string keyVersion, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth, string encryptionScope);
    internal DataLakeSasQueryParameters(Dictionary`2<string, string> values);
    [CompilerGeneratedAttribute]
internal UserDelegationKeyProperties get_KeyProperties();
    [CompilerGeneratedAttribute]
internal void set_KeyProperties(UserDelegationKeyProperties value);
    public string get_KeyObjectId();
    public string get_KeyTenantId();
    public DateTimeOffset get_KeyStartsOn();
    public DateTimeOffset get_KeyExpiresOn();
    public string get_KeyService();
    public string get_KeyVersion();
    public static DataLakeSasQueryParameters get_Empty();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Azure.Storage.Sas.SasExtensions : object {
    private static string NoneName;
    private static string HttpsName;
    private static string HttpsAndHttpName;
    private static string HttpAndHttpsName;
    [ExtensionAttribute]
internal static string ToPermissionsString(AccountSasResourceTypes resourceTypes);
    internal static AccountSasResourceTypes ParseResourceTypes(string s);
    [ExtensionAttribute]
internal static string ToProtocolString(SasProtocol protocol);
    public static SasProtocol ParseProtocol(string s);
    [ExtensionAttribute]
internal static string ToPermissionsString(AccountSasServices services);
    internal static AccountSasServices ParseAccountServices(string s);
    internal static string FormatTimesForSasSigning(DateTimeOffset time);
    internal static void AddToBuilder(StringBuilder sb, string key, string value);
    internal static string ValidateAndSanitizeRawPermissions(string permissions, List`1<char> validPermissionsInOrder);
}
[ExtensionAttribute]
internal static class Azure.Storage.Sas.SasQueryParametersExtensions : object {
    [ExtensionAttribute]
internal static void ParseKeyProperties(DataLakeSasQueryParameters parameters, IDictionary`2<string, string> values);
}
internal class Azure.Storage.Sas.SasQueryParametersInternals : SasQueryParameters {
    [CompilerGeneratedAttribute]
private static string <DefaultSasVersionInternal>k__BackingField;
    internal static string DefaultSasVersionInternal { get; internal set; }
    private static SasQueryParametersInternals();
    [CompilerGeneratedAttribute]
internal static string get_DefaultSasVersionInternal();
    [CompilerGeneratedAttribute]
internal static void set_DefaultSasVersionInternal(string value);
    internal static SasQueryParameters Create(IDictionary`2<string, string> values);
    internal static SasQueryParameters Create(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth, string encryptionScope);
}
internal class Azure.Storage.Sas.UserDelegationKeyProperties : object {
    [CompilerGeneratedAttribute]
private string <ObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    internal string ObjectId { get; internal set; }
    internal string TenantId { get; internal set; }
    internal DateTimeOffset StartsOn { get; internal set; }
    internal DateTimeOffset ExpiresOn { get; internal set; }
    internal string Service { get; internal set; }
    internal string Version { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_ObjectId();
    [CompilerGeneratedAttribute]
internal void set_ObjectId(string value);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_StartsOn();
    [CompilerGeneratedAttribute]
internal void set_StartsOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
internal string get_Service();
    [CompilerGeneratedAttribute]
internal void set_Service(string value);
    [CompilerGeneratedAttribute]
internal string get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(string value);
    public void AppendProperties(StringBuilder stringBuilder);
}
internal interface Azure.Storage.Shared.ISupportsTenantIdChallenges {
    public bool EnableTenantDiscovery { get; }
    public abstract virtual bool get_EnableTenantDiscovery();
}
internal class Azure.Storage.Shared.PooledMemoryStream : Stream {
    private static int DefaultMaxArrayPoolRentalSize;
    [CompilerGeneratedAttribute]
private int <MaxArraySize>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayPool`1<byte> <ArrayPool>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BufferPartition> <BufferSet>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public int MaxArraySize { get; }
    public ArrayPool`1<byte> ArrayPool { get; }
    private List`1<BufferPartition> BufferSet { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PooledMemoryStream(ArrayPool`1<byte> arrayPool, int maxArraySize);
    [CompilerGeneratedAttribute]
public int get_MaxArraySize();
    [CompilerGeneratedAttribute]
public ArrayPool`1<byte> get_ArrayPool();
    [CompilerGeneratedAttribute]
private List`1<BufferPartition> get_BufferSet();
    [AsyncStateMachineAttribute("Azure.Storage.Shared.PooledMemoryStream/<BufferStreamPartitionInternal>d__13")]
internal static Task`1<PooledMemoryStream> BufferStreamPartitionInternal(Stream stream, long minCount, long maxCount, ArrayPool`1<byte> arrayPool, Nullable`1<int> maxArrayPoolRentalSize, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.PooledMemoryStream/<ReadLoopInternal>d__14")]
private static Task`1<int> ReadLoopInternal(Stream stream, Byte[] buffer, int offset, int minCount, int maxCount, bool async, CancellationToken cancellationToken);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
public virtual long get_Position();
    [CompilerGeneratedAttribute]
public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private ValueTuple`3<Byte[], int, long> GetBufferFromPosition();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    public void Clear();
    private void AssertPositionInBounds();
    private BufferPartition GetLatestBufferWithAvailableSpaceOrDefault();
    private static long Min(long val1, long val2, long val3);
}
internal class Azure.Storage.Shared.StorageClientConfiguration : object {
    [CompilerGeneratedAttribute]
private HttpPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageSharedKeyCredential <SharedKeyCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCredential <TokenCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureSasCredential <SasCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    public HttpPipeline Pipeline { get; private set; }
    public StorageSharedKeyCredential SharedKeyCredential { get; private set; }
    public TokenCredential TokenCredential { get; private set; }
    public AzureSasCredential SasCredential { get; private set; }
    public ClientDiagnostics ClientDiagnostics { get; private set; }
    public StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics);
    public StorageClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics);
    public StorageClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics);
    internal StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics);
    internal StorageClientConfiguration(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics);
    [CompilerGeneratedAttribute]
public virtual HttpPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
private void set_Pipeline(HttpPipeline value);
    [CompilerGeneratedAttribute]
public virtual StorageSharedKeyCredential get_SharedKeyCredential();
    [CompilerGeneratedAttribute]
private void set_SharedKeyCredential(StorageSharedKeyCredential value);
    [CompilerGeneratedAttribute]
public virtual TokenCredential get_TokenCredential();
    [CompilerGeneratedAttribute]
private void set_TokenCredential(TokenCredential value);
    [CompilerGeneratedAttribute]
public virtual AzureSasCredential get_SasCredential();
    [CompilerGeneratedAttribute]
private void set_SasCredential(AzureSasCredential value);
    [CompilerGeneratedAttribute]
public virtual ClientDiagnostics get_ClientDiagnostics();
    [CompilerGeneratedAttribute]
private void set_ClientDiagnostics(ClientDiagnostics value);
}
[ExtensionAttribute]
internal static class Azure.Storage.Shared.StorageExtensions : object {
    [ExtensionAttribute]
public static string EscapePath(string path, bool trimOuterSlashes);
    [ExtensionAttribute]
public static string UnescapePath(string path, bool trimOuterSlashes);
    public static string GenerateBlockId(long offset);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageExtensions/<GetCopyAuthorizationHeaderAsync>d__3")]
[ExtensionAttribute]
public static Task`1<HttpAuthorization> GetCopyAuthorizationHeaderAsync(TokenCredential tokenCredential, CancellationToken cancellationToken);
    public static IDisposable CreateClientSideEncryptionScope(ClientSideEncryptionVersion version);
}
internal abstract class Azure.Storage.Shared.StorageWriteStream : Stream {
    protected long _position;
    protected long _bufferSize;
    protected IProgress`1<long> _progressHandler;
    protected PooledMemoryStream _buffer;
    private ArrayPool`1<byte> _bufferPool;
    private StorageChecksumAlgorithm _checksumAlgorithm;
    private StorageCrc64HashAlgorithm _masterCrcChecksummer;
    private Memory`1<byte> _composedCrc;
    private Memory`1<byte> _userProvidedChecksum;
    private IHasher _bufferChecksumer;
    private bool _disposed;
    private DisposableBucket _accumulatedDisposables;
    private bool UseMasterCrc { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected StorageWriteStream(long position, long bufferSize, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidation, PooledMemoryStream buffer, ArrayPool`1<byte> bufferPool);
    private bool get_UseMasterCrc();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<WriteAsync>d__30")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<WriteInternal>d__31")]
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<FlushAsync>d__33")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<FlushInternal>d__34")]
private Task FlushInternal(bool async, CancellationToken cancellationToken);
    protected virtual Task CommitInternal(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<AppendAndClearBufferInternal>d__36")]
private Task AppendAndClearBufferInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    protected abstract virtual Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    protected abstract virtual void ValidateBufferSize(long bufferSize);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<WriteToBufferInternal>d__39")]
protected Task WriteToBufferInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    protected static void ValidateWriteParameters(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void ValidateCallerCrcIfAny();
    protected IDisposable FinalizeAndReplaceBufferChecksum(UploadTransferValidationOptions& validationOptions);
}
[ExtensionAttribute]
internal static class Azure.Storage.Shared.StreamExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<long> GetPositionOrDefault(Stream content);
}
internal abstract class Azure.Storage.Shared.WindowStream : Stream {
    [CompilerGeneratedAttribute]
private Stream <InnerStream>k__BackingField;
    private Stream InnerStream { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    private WindowStream(Stream stream);
    [CompilerGeneratedAttribute]
private Stream get_InnerStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public static Stream GetWindow(Stream stream, long maxWindowLength);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.WindowStream/<ReadAsync>d__14")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.WindowStream/<ReadInternal>d__15")]
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    protected abstract virtual int AdjustCount(int count);
    protected abstract virtual void ReportInnerStreamRead(int resultRead);
}
internal class Azure.Storage.SharedAccessSignatureCredentials : object {
    [CompilerGeneratedAttribute]
private string <SasToken>k__BackingField;
    public string SasToken { get; }
    public SharedAccessSignatureCredentials(string sasToken);
    [CompilerGeneratedAttribute]
public string get_SasToken();
}
internal class Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy : BearerTokenAuthenticationPolicy {
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _scopes;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) tenantId;
    private bool _enableTenantDiscovery;
    public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, string scope, bool enableTenantDiscovery);
    public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, IEnumerable`1<string> scopes, bool enableTenantDiscovery);
    protected virtual void AuthorizeRequest(HttpMessage message);
    protected virtual ValueTask AuthorizeRequestAsync(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy/<AuthorizeRequestInternal>d__7")]
private ValueTask AuthorizeRequestInternal(HttpMessage message, bool async);
    protected virtual bool AuthorizeRequestOnChallenge(HttpMessage message);
    protected virtual ValueTask`1<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy/<AuthorizeRequestOnChallengeInternalAsync>d__10")]
private ValueTask`1<bool> AuthorizeRequestOnChallengeInternalAsync(HttpMessage message, bool async);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageClientOptions : object {
    private static string StorageScope;
    [ExtensionAttribute]
public static void Initialize(ClientOptions options);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(StorageSharedKeyCredential credential);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(AzureSasCredential credential, Uri resourceUri);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(TokenCredential credential, string scope, ClientOptions options);
    public static HttpPipelinePolicy GetAuthenticationPolicy(object credentials, string scope, ClientOptions options);
    [ExtensionAttribute]
public static HttpPipeline Build(ClientOptions options, HttpPipelinePolicy authentication, Uri geoRedundantSecondaryStorageUri, Request100ContinueOptions expectContinue);
    [ExtensionAttribute]
public static HttpPipeline Build(ClientOptions options, object credentials, Uri geoRedundantSecondaryStorageUri, Request100ContinueOptions expectContinue);
}
internal abstract class Azure.Storage.StorageCollectionEnumerator`1 : object {
    public abstract virtual ValueTask`1<Page`1<T>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    public Pageable`1<T> ToSyncCollection(CancellationToken cancellationToken);
    public AsyncPageable`1<T> ToAsyncCollection(CancellationToken cancellationToken);
}
internal class Azure.Storage.StorageConnectionString : object {
    private static KeyValuePair`2<string, Func`2<string, bool>> s_useDevelopmentStorageSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_developmentStorageProxyUriSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_defaultEndpointsProtocolSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountNameSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountKeyNameSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountKeySetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_blobEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_queueEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_fileEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_tableEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_blobSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_queueSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_fileSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_tableSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_endpointSuffixSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_sharedAccessSignatureSetting;
    private static StorageConnectionString s_devStoreAccount;
    [CompilerGeneratedAttribute]
private bool <IsDevStoreAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultEndpoints>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <BlobStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <QueueStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <TableStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <FileStorageUri>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Credentials>k__BackingField;
    internal string _accountName;
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> s_validCredentials;
    internal static bool UseV1MD5 { get; }
    public static StorageConnectionString DevelopmentStorageAccount { get; }
    internal bool IsDevStoreAccount { get; internal set; }
    internal string EndpointSuffix { get; internal set; }
    internal IDictionary`2<string, string> Settings { get; internal set; }
    internal bool DefaultEndpoints { get; internal set; }
    public Uri BlobEndpoint { get; }
    public Uri QueueEndpoint { get; }
    public Uri TableEndpoint { get; }
    public Uri FileEndpoint { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> BlobStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> QueueStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> TableStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> FileStorageUri { get; public set; }
    public object Credentials { get; public set; }
    public StorageConnectionString(object storageCredentials, ValueTuple`2<Uri, Uri> blobStorageUri, ValueTuple`2<Uri, Uri> queueStorageUri, ValueTuple`2<Uri, Uri> tableStorageUri, ValueTuple`2<Uri, Uri> fileStorageUri);
    private static StorageConnectionString();
    internal static bool get_UseV1MD5();
    public static StorageConnectionString get_DevelopmentStorageAccount();
    [CompilerGeneratedAttribute]
internal bool get_IsDevStoreAccount();
    [CompilerGeneratedAttribute]
internal void set_IsDevStoreAccount(bool value);
    [CompilerGeneratedAttribute]
internal string get_EndpointSuffix();
    [CompilerGeneratedAttribute]
internal void set_EndpointSuffix(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
internal bool get_DefaultEndpoints();
    [CompilerGeneratedAttribute]
internal void set_DefaultEndpoints(bool value);
    public Uri get_BlobEndpoint();
    public Uri get_QueueEndpoint();
    public Uri get_TableEndpoint();
    public Uri get_FileEndpoint();
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_BlobStorageUri();
    [CompilerGeneratedAttribute]
public void set_BlobStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_QueueStorageUri();
    [CompilerGeneratedAttribute]
public void set_QueueStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_TableStorageUri();
    [CompilerGeneratedAttribute]
public void set_TableStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_FileStorageUri();
    [CompilerGeneratedAttribute]
public void set_FileStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public object get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(object value);
    public static StorageConnectionString Parse(string connectionString);
    public static bool TryParse(string connectionString, StorageConnectionString& account);
    private static StorageConnectionString GetDevelopmentStorageAccount(Uri proxyUri);
    internal static bool ParseCore(string connectionString, StorageConnectionString& accountInformation, Action`1<string> error);
    private static IDictionary`2<string, string> ParseStringIntoSettings(string connectionString, Action`1<string> error);
    private static KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, String[] validValues);
    private static KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, Func`2<string, bool> isValid);
    private static bool IsValidBase64String(string settingValue);
    private static bool IsValidUri(string settingValue);
    private static bool IsValidDomain(string settingValue);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AllRequired(KeyValuePair`2[] requiredSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> Optional(KeyValuePair`2[] optionalSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AtLeastOne(KeyValuePair`2[] atLeastOneSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> None(KeyValuePair`2[] atLeastOneSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesAll(Func`2[] filters);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesOne(Func`2[] filters);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesExactly(Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> filter);
    private static bool MatchesSpecification(IDictionary`2<string, string> settings, Func`2[] constraints);
    private static object GetCredentials(IDictionary`2<string, string> settings);
    private static ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructFileEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructFileEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructTableEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructTableEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructUris(string scheme, string accountName, string hostNamePrefix, string endpointSuffix, string sasToken);
    [CompilerGeneratedAttribute]
internal static string <ParseCore>g__settingOrDefault|70_0(string key, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
internal static bool <ParseCore>g__s_isValidEndpointPair|70_1(string primary, string secondary);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<Uri, Uri> <ParseCore>g__createStorageUri|70_2(string primary, string secondary, string sasToken, Func`2<IDictionary`2<string, string>, ValueTuple`2<Uri, Uri>> factory, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
internal static Uri <ParseCore>g__CreateUri|70_3(string endpoint, string sasToken);
}
internal static class Azure.Storage.StorageCrc64Calculator : object {
    private static ulong poly;
    private static UInt64[] m_u1;
    private static UInt64[] m_u32;
    private static UInt64[] m_uX2N;
    private static ulong m_uComplement;
    private static int m_uBitWidth;
    private static StorageCrc64Calculator();
    public static ulong ComputeSlicedSafe(ReadOnlySpan`1<byte> src, ulong uCrc);
    internal static ulong Concatenate(ulong uInitialCrcAB, ulong uInitialCrcA, ulong uFinalCrcA, ulong uSizeA, ulong uInitialCrcB, ulong uFinalCrcB, ulong uSizeB);
    private static ulong MulX_N(ulong a, ulong uSize);
    private static ulong MulPoly(ulong a, ulong b);
    private static ulong MulPolyUnrolled(ulong a, ulong b);
}
internal static class Azure.Storage.StorageCrc64Composer : object {
    public static Memory`1<byte> Compose(ValueTuple`2[] partitions);
    public static Memory`1<byte> Compose(IEnumerable`1<ValueTuple`2<Byte[], long>> partitions);
    public static ulong Compose(IEnumerable`1<ValueTuple`2<ulong, long>> partitions);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageExceptionExtensions : object {
    [ExtensionAttribute]
public static string GetErrorCode(Response response, string errorCode);
    [ExtensionAttribute]
public static bool IsUnavailable(Response`1<T> response);
    [ExtensionAttribute]
public static Response`1<T> AsNoBodyResponse(Response rawResponse);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageProgressExtensions : object {
    [ExtensionAttribute]
public static Stream WithProgress(Stream stream, IProgress`1<long> progressHandler);
}
internal class Azure.Storage.StorageRequestValidationPipelinePolicy : HttpPipelineSynchronousPolicy {
    public virtual void OnReceivedResponse(HttpMessage message);
}
internal class Azure.Storage.StorageResponseClassifier : ResponseClassifier {
    [CompilerGeneratedAttribute]
private Uri <SecondaryStorageUri>k__BackingField;
    public Uri SecondaryStorageUri { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_SecondaryStorageUri();
    [CompilerGeneratedAttribute]
public void set_SecondaryStorageUri(Uri value);
    public virtual bool IsRetriableResponse(HttpMessage message);
    public virtual bool IsErrorResponse(HttpMessage message);
}
internal class Azure.Storage.StorageServerTimeoutPolicy : HttpPipelineSynchronousPolicy {
    private static string QueryParameterKeyWithEqualSign;
    [CompilerGeneratedAttribute]
private static StorageServerTimeoutPolicy <Shared>k__BackingField;
    public static StorageServerTimeoutPolicy Shared { get; }
    private static StorageServerTimeoutPolicy();
    [CompilerGeneratedAttribute]
public static StorageServerTimeoutPolicy get_Shared();
    public virtual void OnSendingRequest(HttpMessage message);
}
internal class Azure.Storage.StorageSharedKeyCredentialInternals : StorageSharedKeyCredential {
    private StorageSharedKeyCredentialInternals(string accountName, string accountKey);
    internal static string ComputeSasSignature(StorageSharedKeyCredential credential, string message);
}
internal class Azure.Storage.StorageSharedKeyPipelinePolicy : HttpPipelineSynchronousPolicy {
    private static bool IncludeXMsDate;
    private StorageSharedKeyCredential _credentials;
    private static HeaderComparer s_headerComparer;
    public StorageSharedKeyPipelinePolicy(StorageSharedKeyCredential credentials);
    private static StorageSharedKeyPipelinePolicy();
    public virtual void OnSendingRequest(HttpMessage message);
    private string BuildStringToSign(HttpMessage message);
    private static void BuildCanonicalizedHeaders(StringBuilder stringBuilder, HttpMessage message);
    private void BuildCanonicalizedResource(StringBuilder stringBuilder, Uri resource);
}
internal class Azure.Storage.StorageTelemetryPolicy : HttpPipelineSynchronousPolicy {
    private static string CseIdentifierV2;
    private static string CseIdentifierV1;
    [CompilerGeneratedAttribute]
private static StorageTelemetryPolicy <Shared>k__BackingField;
    public static StorageTelemetryPolicy Shared { get; }
    private static StorageTelemetryPolicy();
    [CompilerGeneratedAttribute]
public static StorageTelemetryPolicy get_Shared();
    public virtual void OnSendingRequest(HttpMessage message);
    private static void ApplyAzFeatures(HttpMessage message, AzFeatures azFeatures);
    private static string Serialize(AzFeatures azFeatures);
    private static string TransformUserAgent(string userAgent, string injection);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageVersionExtensions : object {
    public static ServiceVersion LatestVersion;
    internal static ServiceVersion MaxVersion;
    [ExtensionAttribute]
public static string ToVersionString(ServiceVersion version);
    [ExtensionAttribute]
public static ServiceVersion AsBlobsVersion(ServiceVersion version);
}
[ExtensionAttribute]
internal static class Azure.Storage.StreamExtensions : object {
    [ExtensionAttribute]
public static Stream WithNoDispose(Stream stream);
    [ExtensionAttribute]
public static Nullable`1<long> GetLengthOrDefault(Stream content);
    [AsyncStateMachineAttribute("Azure.Storage.StreamExtensions/<ReadInternal>d__2")]
[ExtensionAttribute]
public static Task`1<int> ReadInternal(Stream stream, Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.StreamExtensions/<WriteInternal>d__3")]
[ExtensionAttribute]
public static Task WriteInternal(Stream stream, Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task CopyToInternal(Stream src, Stream dest, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.StreamExtensions/<CopyToInternal>d__5")]
[ExtensionAttribute]
public static Task CopyToInternal(Stream src, Stream dest, int bufferSize, bool async, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Azure.Storage.TransferValidationOptionsExtensions : object {
    [ExtensionAttribute]
public static StorageChecksumAlgorithm ResolveAuto(StorageChecksumAlgorithm checksumAlgorithm);
    [ExtensionAttribute]
public static UploadTransferValidationOptions ToValidationOptions(Byte[] md5);
    [ExtensionAttribute]
public static DownloadTransferValidationOptions ToValidationOptions(bool requestTransactionalMD5);
    [ExtensionAttribute]
public static void CopyTo(TransferValidationOptions source, TransferValidationOptions dest);
    [ExtensionAttribute]
public static void CopyTo(UploadTransferValidationOptions source, UploadTransferValidationOptions dest);
    [ExtensionAttribute]
public static void CopyTo(DownloadTransferValidationOptions source, DownloadTransferValidationOptions dest);
}
[ExtensionAttribute]
internal static class Azure.Storage.UriExtensions : object {
    [ExtensionAttribute]
public static Uri AppendToPath(Uri uri, string segment);
    [ExtensionAttribute]
public static IDictionary`2<string, string> GetQueryParameters(Uri uri);
    [ExtensionAttribute]
public static string GetAccountNameFromDomain(Uri uri, string serviceSubDomain);
    public static string GetAccountNameFromDomain(string host, string serviceSubDomain);
    [ExtensionAttribute]
public static string GetPath(Uri uri);
    [ExtensionAttribute]
public static bool IsHostIPEndPointStyle(Uri uri);
    [ExtensionAttribute]
internal static void AppendQueryParameter(StringBuilder sb, string key, string value);
}
internal class Azure.Storage.UriQueryParamsCollection : Dictionary`2<string, string> {
    public UriQueryParamsCollection(string encodedQueryParamString);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.Azure.DataLakeClientBuilderExtensions : object {
    [ExtensionAttribute]
public static IAzureClientBuilder`2<DataLakeServiceClient, DataLakeClientOptions> AddDataLakeServiceClient(TBuilder builder, Uri serviceUri);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<DataLakeServiceClient, DataLakeClientOptions> AddDataLakeServiceClient(TBuilder builder, Uri serviceUri, StorageSharedKeyCredential sharedKeyCredential);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<DataLakeServiceClient, DataLakeClientOptions> AddDataLakeServiceClient(TBuilder builder, TConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
