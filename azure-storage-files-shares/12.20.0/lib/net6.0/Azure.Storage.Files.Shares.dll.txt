[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Autorest.CSharp.Core.GeneratorPageableHelpers : object {
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Autorest.CSharp.Core.GeneratorPageableHelpers/<CreateAsyncPageable>d__8`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
}
internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
internal class Azure.Core.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private static int DefaultInitialBufferSize;
    [CompilerGeneratedAttribute]
private int <WrittenCount>k__BackingField;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; private set; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    [CompilerGeneratedAttribute]
public int get_WrittenCount();
    [CompilerGeneratedAttribute]
private void set_WrittenCount(int value);
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.AsyncLockWithValue`1 : object {
    private object _syncObj;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters;
    private bool _isLocked;
    private bool _hasValue;
    private long _index;
    [NullableAttribute("2")]
private T _value;
    public bool HasValue { get; }
    public AsyncLockWithValue`1(T value);
    public bool get_HasValue();
    [NullableContextAttribute("2")]
public bool TryGetValue(T& value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.AsyncLockWithValue`1/<GetLockOrValueAsync>d__11")]
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken);
    private void SetValue(T value, Int64& lockIndex);
    private void Reset(Int64& lockIndex);
    private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter);
}
internal static class Azure.Core.AuthorizationChallengeParser : object {
    [NullableContextAttribute("1")]
public static string GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter);
    internal static bool TryGetNextChallenge(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& challengeKey);
    internal static bool TryGetNextParameter(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& paramKey, ReadOnlySpan`1& paramValue, char separator);
}
[AttributeUsageAttribute("1")]
internal class Azure.Core.AzureResourceProviderNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ResourceProviderNamespace>k__BackingField;
    public string ResourceProviderNamespace { get; }
    public AzureResourceProviderNamespaceAttribute(string resourceProviderNamespace);
    [CompilerGeneratedAttribute]
public string get_ResourceProviderNamespace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("68")]
internal class Azure.Core.CallerShouldAuditAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; public set; }
    public CallerShouldAuditAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.CancellationHelper : object {
    private static string s_cancellationMessage;
    private static CancellationHelper();
    internal static bool ShouldWrapInOperationCanceledException(Exception exception, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
internal static Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken, string message);
    [NullableContextAttribute("2")]
private static void ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken);
    internal static void ThrowIfCancellationRequested(CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Azure.Core.CodeGenClientAttribute : CodeGenTypeAttribute {
    [CompilerGeneratedAttribute]
private Type <ParentClient>k__BackingField;
    public Type ParentClient { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenClientAttribute(string originalName);
    [CompilerGeneratedAttribute]
public Type get_ParentClient();
    [CompilerGeneratedAttribute]
public void set_ParentClient(Type value);
}
[AttributeUsageAttribute("384")]
internal class Azure.Core.CodeGenMemberAttribute : CodeGenTypeAttribute {
    [NullableContextAttribute("1")]
public CodeGenMemberAttribute(string originalName);
}
[AttributeUsageAttribute("28")]
internal class Azure.Core.CodeGenModelAttribute : CodeGenTypeAttribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Usage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Formats>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Usage { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Formats { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenModelAttribute(string originalName);
    [CompilerGeneratedAttribute]
public String[] get_Usage();
    [CompilerGeneratedAttribute]
public void set_Usage(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Formats();
    [CompilerGeneratedAttribute]
public void set_Formats(String[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Azure.Core.CodeGenOverrideServiceVersionsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Versions>k__BackingField;
    public String[] Versions { get; }
    public CodeGenOverrideServiceVersionsAttribute(String[] versions);
    [CompilerGeneratedAttribute]
public String[] get_Versions();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
internal class Azure.Core.CodeGenSerializationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <SerializationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializationValueHook>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeserializationValueHook>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BicepSerializationValueHook>k__BackingField;
    public string PropertyName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] SerializationPath { get; }
    public string SerializationValueHook { get; public set; }
    public string DeserializationValueHook { get; public set; }
    public string BicepSerializationValueHook { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenSerializationAttribute(string propertyName);
    [NullableContextAttribute("1")]
public CodeGenSerializationAttribute(string propertyName, string serializationName);
    [NullableContextAttribute("1")]
public CodeGenSerializationAttribute(string propertyName, String[] serializationPath);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public String[] get_SerializationPath();
    [CompilerGeneratedAttribute]
public string get_SerializationValueHook();
    [CompilerGeneratedAttribute]
public void set_SerializationValueHook(string value);
    [CompilerGeneratedAttribute]
public string get_DeserializationValueHook();
    [CompilerGeneratedAttribute]
public void set_DeserializationValueHook(string value);
    [CompilerGeneratedAttribute]
public string get_BicepSerializationValueHook();
    [CompilerGeneratedAttribute]
public void set_BicepSerializationValueHook(string value);
}
[AttributeUsageAttribute("28")]
internal class Azure.Core.CodeGenSuppressAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <Parameters>k__BackingField;
    public string Member { get; }
    public Type[] Parameters { get; }
    public CodeGenSuppressAttribute(string member, Type[] parameters);
    [CompilerGeneratedAttribute]
public string get_Member();
    [CompilerGeneratedAttribute]
public Type[] get_Parameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Azure.Core.CodeGenSuppressTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Typename>k__BackingField;
    public string Typename { get; }
    public CodeGenSuppressTypeAttribute(string typename);
    [CompilerGeneratedAttribute]
public string get_Typename();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Azure.Core.CodeGenTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <OriginalName>k__BackingField;
    public string OriginalName { get; }
    public CodeGenTypeAttribute(string originalName);
    [CompilerGeneratedAttribute]
public string get_OriginalName();
}
internal class Azure.Core.FixedDelayWithNoJitterStrategy : DelayStrategy {
    private static TimeSpan DefaultDelay;
    private TimeSpan _delay;
    public FixedDelayWithNoJitterStrategy(Nullable`1<TimeSpan> suggestedDelay);
    private static FixedDelayWithNoJitterStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.FormUrlEncodedContent : RequestContent {
    private List`1<KeyValuePair`2<string, string>> _values;
    private Encoding Latin1;
    private Byte[] _bytes;
    public void Add(string parameter, string value);
    private void BuildIfNeeded();
    [AsyncStateMachineAttribute("Azure.Core.FormUrlEncodedContent/<WriteToAsync>d__5")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
    private Byte[] GetContentByteArray(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static string Encode(string data);
}
[AttributeUsageAttribute("64")]
internal class Azure.Core.ForwardsClientCallsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <SkipChecks>k__BackingField;
    public bool SkipChecks { get; }
    public ForwardsClientCallsAttribute(bool skipChecks);
    [CompilerGeneratedAttribute]
public bool get_SkipChecks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.HttpMessageSanitizer : object {
    private static string LogAllValue;
    private bool _logAllHeaders;
    private bool _logFullQueries;
    private String[] _allowedQueryParameters;
    private string _redactedPlaceholder;
    private HashSet`1<string> _allowedHeaders;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static StringBuilder s_cachedStringBuilder;
    private static int MaxCachedStringBuilderCapacity;
    internal static HttpMessageSanitizer Default;
    public HttpMessageSanitizer(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder);
    private static HttpMessageSanitizer();
    public string SanitizeHeader(string name, string value);
    public string SanitizeUrl(string url);
    private static StringBuilder RentStringBuilder(int capacity);
    private static string ToStringAndReturnStringBuilder(StringBuilder builder);
    [CompilerGeneratedAttribute]
internal static StringBuilder <SanitizeUrl>g__AppendReadOnlySpan|11_0(StringBuilder builder, ReadOnlySpan`1<char> span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.HttpPipelineExtensions : object {
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessMessageAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<Response> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response ProcessMessage(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessHeadAsBoolMessageAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<bool>> ProcessHeadAsBoolMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [ExtensionAttribute]
public static Response`1<bool> ProcessHeadAsBoolMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [NullableContextAttribute("0")]
private static ValueTuple`2<CancellationToken, ErrorOptions> ApplyRequestContext(RequestContext requestContext);
}
internal interface Azure.Core.IOperation {
    public abstract virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Azure.Core.IOperation`1 {
    public abstract virtual ValueTask`1<OperationState`1<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
internal interface Azure.Core.IOperationSource`1 {
    public abstract virtual T CreateResult(Response response, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<T> CreateResultAsync(Response response, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IUtf8JsonSerializable {
    public abstract virtual void Write(Utf8JsonWriter writer);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IXmlSerializable {
    public abstract virtual void Write(XmlWriter writer, string nameHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.NextLinkOperationImplementation : object {
    internal static string NotSet;
    internal static string RehydrationTokenVersion;
    private static string ApiVersionParam;
    private static String[] FailureStates;
    private static String[] SuccessStates;
    private HeaderSource _headerSource;
    private Uri _startRequestUri;
    private OperationFinalStateVia _finalStateVia;
    private HttpPipeline _pipeline;
    [NullableAttribute("2")]
private string _apiVersion;
    [NullableAttribute("2")]
private string _lastKnownLocation;
    private string _nextRequestUri;
    [CompilerGeneratedAttribute]
private string <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestMethod <RequestMethod>k__BackingField;
    public string OperationId { get; private set; }
    public RequestMethod RequestMethod { get; }
    private NextLinkOperationImplementation(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, HeaderSource headerSource, string lastKnownLocation, OperationFinalStateVia finalStateVia, string apiVersion, string operationId, bool isNextRequestPolling);
    private static NextLinkOperationImplementation();
    [CompilerGeneratedAttribute]
public string get_OperationId();
    [CompilerGeneratedAttribute]
private void set_OperationId(string value);
    [CompilerGeneratedAttribute]
public RequestMethod get_RequestMethod();
    public static IOperation Create(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    public static IOperation`1<T> Create(IOperationSource`1<T> operationSource, HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    public static IOperation`1<T> Create(IOperationSource`1<T> operationSource, IOperation operation);
    public static IOperation Create(HttpPipeline pipeline, RehydrationToken rehydrationToken);
    private static string ParseOperationId(Uri startRequestUri, string nextRequestUri);
    public RehydrationToken GetRehydrationToken();
    public static RehydrationToken GetRehydrationToken(RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia);
    public static RehydrationToken GetRehydrationToken(RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, string headerSource, string lastKnownLocation, string finalStateVia, string operationId);
    [NullableContextAttribute("2")]
private static string ConstructStringValue(string value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<UpdateStateAsync>d__29")]
public sealed virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
    private static OperationState GetOperationStateFromFinalResponse(RequestMethod requestMethod, Response response);
    private void UpdateNextRequestUri(ResponseHeaders headers);
    internal static string AppendOrReplaceApiVersion(string uri, string apiVersion);
    [NullableContextAttribute("0")]
internal static bool TryGetApiVersion(Uri startRequestUri, ReadOnlySpan`1& apiVersion);
    [NullableContextAttribute("2")]
private string GetFinalUri(string resourceLocation);
    private Response GetResponse(string uri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<GetResponseAsync>d__36")]
private ValueTask`1<Response> GetResponseAsync(string uri, CancellationToken cancellationToken);
    private HttpMessage CreateRequest(string uri);
    private static bool IsFinalState(Response response, HeaderSource headerSource, Nullable`1& failureState, String& resourceLocation);
    private static string GetRequiredString(JsonElement& element);
    private static bool ShouldIgnoreHeader(RequestMethod method, Response response);
    private static HeaderSource GetHeaderSource(RequestMethod requestMethod, Uri requestUri, Response response, string apiVersion, String& nextRequestUri, Boolean& isNextRequestPolling);
    private static void AssertNotNull(T value, string name);
}
internal enum Azure.Core.OperationFinalStateVia : Enum {
    public int value__;
    public static OperationFinalStateVia AzureAsyncOperation;
    public static OperationFinalStateVia Location;
    public static OperationFinalStateVia OriginalUri;
    public static OperationFinalStateVia OperationLocation;
    public static OperationFinalStateVia LocationOverride;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.OperationHelpers : object {
    public static T GetValue(T& value);
    [NullableContextAttribute("0")]
public static T GetValue(Nullable`1& value);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__2`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__3`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__6")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__7")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal : OperationInternalBase {
    private OperationInternal`1<VoidValue> _internalOperation;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public OperationInternal(IOperation operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    internal OperationInternal(OperationState finalState);
    public static OperationInternal Succeeded(Response rawResponse);
    public static OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal/<UpdateStatusAsync>d__9")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal`1 : OperationInternalBase {
    private IOperation`1<T> _operation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLockWithValue`1<OperationState`1<T>> _stateLock;
    private Response _rawResponse;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    public T Value { get; }
    public OperationInternal`1(IOperation`1<T> operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    internal OperationInternal`1(OperationState`1<T> finalState);
    public static OperationInternal`1<T> Succeeded(Response rawResponse, T value);
    public static OperationInternal`1<T> Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    public bool get_HasValue();
    public T get_Value();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__15")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__16")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__19")]
private ValueTask`1<Response`1<T>> WaitForCompletionAsync(bool async, Nullable`1<TimeSpan> pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<UpdateStatusAsync>d__20")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    private static Response GetResponseFromState(OperationState`1<T> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.OperationInternalBase : object {
    private ClientDiagnostics _diagnostics;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> _scopeAttributes;
    [NullableAttribute("2")]
private DelayStrategy _fallbackStrategy;
    private AsyncLockWithValue`1<Response> _responseLock;
    private string _waitForCompletionResponseScopeName;
    protected string _updateStatusScopeName;
    protected string _waitForCompletionScopeName;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    protected OperationInternalBase(Response rawResponse);
    protected OperationInternalBase(ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    public abstract virtual Response get_RawResponse();
    public abstract virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<UpdateStatusAsync>d__13")]
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__15")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__16")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__19")]
protected ValueTask`1<Response> WaitForCompletionResponseAsync(bool async, Nullable`1<TimeSpan> pollingInterval, string scopeName, CancellationToken cancellationToken);
    protected abstract virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    protected DiagnosticScope CreateScope(string scopeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationPoller : object {
    private DelayStrategy _delayStrategy;
    [NullableContextAttribute("2")]
public OperationPoller(DelayStrategy strategy);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__6`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__8`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__10")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__11")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<Delay>d__12")]
private static ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState : ValueType {
    [CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    [NullableAttribute("2")]
public RequestFailedException OperationFailedException { get; }
    private OperationState(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException operationFailedException);
    [CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    public static OperationState Success(Response rawResponse);
    public static OperationState Failure(Response rawResponse, RequestFailedException operationFailedException);
    public static OperationState Pending(Response rawResponse);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    [NullableAttribute("1")]
public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    public T Value { get; }
    public RequestFailedException OperationFailedException { get; }
    private OperationState`1(Response rawResponse, bool hasCompleted, bool hasSucceeded, T value, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    [NullableContextAttribute("1")]
public static OperationState`1<T> Success(Response rawResponse, T value);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Failure(Response rawResponse, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Pending(Response rawResponse);
}
internal static class Azure.Core.Page : object {
    [NullableContextAttribute("1")]
public static Page`1<T> FromValues(IEnumerable`1<T> values, string continuationToken, Response response);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.PageableHelpers : object {
    private static Byte[] DefaultItemPropertyName;
    private static Byte[] DefaultNextLinkPropertyName;
    private static PageableHelpers();
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.PageableHelpers/<CreateAsyncPageable>d__10`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
    private static ValueTuple`2<List`1<T>, string> ParseResponseForBinaryData(Response response, Byte[] itemPropertyName, Byte[] nextLinkPropertyName);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static object <ParseResponseForBinaryData>g__ReadBinaryData|19_0(Utf8JsonReader& r, ReadOnlyMemory`1& content);
}
internal static class Azure.Core.Pipeline.ActivityExtensions : object {
    [CompilerGeneratedAttribute]
private static bool <SupportsActivitySource>k__BackingField;
    public static bool SupportsActivitySource { get; private set; }
    private static ActivityExtensions();
    [CompilerGeneratedAttribute]
public static bool get_SupportsActivitySource();
    [CompilerGeneratedAttribute]
private static void set_SupportsActivitySource(bool value);
    public static void ResetFeatureSwitch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
    public ClientDiagnostics(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities);
    public ClientDiagnostics(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities);
    internal static HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics);
    internal static string GetResourceProviderNamespace(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Pipeline.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    internal static string OpenTelemetrySchemaAttribute;
    internal static string OpenTelemetrySchemaVersion;
    private static object AzureSdkScopeValue;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    [RequiresUnreferencedCodeAttribute("The diagnosticSourceArgs are used in a call to DiagnosticSource.Write, all necessary properties need to be preserved on the type being passed in using DynamicDependency attributes.")]
internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public void AddAttribute(string name, string value);
    public void AddIntegerAttribute(string name, int value);
    public void AddLongAttribute(string name, long value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, object> attributes);
    public void Start();
    public void SetDisplayName(string displayName);
    public void SetStartTime(DateTime dateTime);
    public void SetTraceContext(string traceparent, string tracestate);
    public sealed virtual void Dispose();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(Exception exception);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(string errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    private bool _isStable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ActivitySource> ActivitySources;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable);
    private static DiagnosticScopeFactory();
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public DiagnosticScope CreateScope(string name, ActivityKind kind);
    private ActivitySource GetActivitySource(string ns, string name);
}
internal static class Azure.Core.Pipeline.RetriableStream : object {
    public static Stream Create(Func`2<long, Stream> responseFactory, Func`2<long, ValueTask`1<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries);
    [AsyncStateMachineAttribute("Azure.Core.Pipeline.RetriableStream/<CreateAsync>d__1")]
public static Task`1<Stream> CreateAsync(Func`2<long, Stream> responseFactory, Func`2<long, ValueTask`1<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries);
    public static Stream Create(Stream initialResponse, Func`2<long, Stream> streamFactory, Func`2<long, ValueTask`1<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries);
}
internal class Azure.Core.Pipeline.StorageRequestFailedDetailsParser : RequestFailedDetailsParser {
    [NullableContextAttribute("1")]
public virtual bool TryParse(Response response, ResponseError& error, IDictionary`2& data);
}
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.TaskExtensions : object {
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T EnsureCompleted(Task`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(Task task);
    [ExtensionAttribute]
public static T EnsureCompleted(ValueTask`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(ValueTask task);
    [ExtensionAttribute]
public static Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async);
    [ConditionalAttribute("DEBUG")]
private static void VerifyTaskCompleted(bool isCompleted);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ProtocolOperation`1 : Operation`1<T> {
    private Func`2<Response, T> _resultSelector;
    private OperationInternal`1<T> _operation;
    private IOperation _nextLinkOperation;
    public string Id { get; }
    public T Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal ProtocolOperation`1(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, string scopeName, Func`2<Response, T> resultSelector);
    public virtual string get_Id();
    public virtual T get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperation`1/<Azure-Core-IOperation<T>-UpdateStateAsync>d__17")]
private sealed virtual override ValueTask`1<OperationState`1<T>> Azure.Core.IOperation<T>.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ProtocolOperationHelpers : object {
    public static Operation`1<TTo> Convert(Operation`1<TFrom> operation, Func`2<Response, TTo> convertFunc, ClientDiagnostics diagnostics, string scopeName);
    public static ValueTask`1<Operation`1<VoidValue>> ProcessMessageWithoutResponseValueAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<VoidValue> ProcessMessageWithoutResponseValue(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static ValueTask`1<Operation`1<BinaryData>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<BinaryData> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperationHelpers/<ProcessMessageAsync>d__5`1")]
public static ValueTask`1<Operation`1<T>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
    public static Operation`1<T> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
}
internal class Azure.Core.RawRequestUriBuilder : RequestUriBuilder {
    [NullableAttribute("1")]
private static string SchemeSeparator;
    private static char HostSeparator;
    private static char PortSeparator;
    [NullableAttribute("1")]
private static Char[] HostOrPort;
    private static char QueryBeginSeparator;
    private static char QueryContinueSeparator;
    private static char QueryValueSeparator;
    private Nullable`1<RawWritingPosition> _position;
    private static RawRequestUriBuilder();
    private static void GetQueryParts(ReadOnlySpan`1<char> queryUnparsed, ReadOnlySpan`1& name, ReadOnlySpan`1& value);
    [NullableContextAttribute("1")]
public void AppendRaw(string value, bool escape);
    private void AppendRaw(ReadOnlySpan`1<char> value, bool escape);
    [NullableContextAttribute("1")]
public void AppendRawNextLink(string nextLink, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestHeaderExtensions : object {
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, bool value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, float value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, double value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, int value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, long value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, TimeSpan value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Guid value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Byte[] value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, BinaryData value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string prefix, IDictionary`2<string, string> headersToAdd);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, ETag value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, MatchConditions conditions);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, RequestConditions conditions, string format);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestUriBuilderExtensions : object {
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, float value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, double value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, int value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, IEnumerable`1<string> value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, float value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, double value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, decimal value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, int value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, string format, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.ResponseHeadersExtensions : object {
    private static String[] KnownFormats;
    private static ResponseHeadersExtensions();
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Byte[]& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, T& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string prefix, IDictionary`2& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ResponseWithHeaders : object {
    public static ResponseWithHeaders`2<T, THeaders> FromValue(T value, THeaders headers, Response rawResponse);
    public static ResponseWithHeaders`1<THeaders> FromValue(THeaders headers, Response rawResponse);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.ResponseWithHeaders`1 : object {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public THeaders Headers { get; }
    public ResponseWithHeaders`1(THeaders headers, Response rawResponse);
    public Response GetRawResponse();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`1<THeaders> self);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ResponseWithHeaders`2 : Response`1<T> {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public T Value { get; }
    public THeaders Headers { get; }
    public ResponseWithHeaders`2(T value, THeaders headers, Response rawResponse);
    public virtual Response GetRawResponse();
    [CompilerGeneratedAttribute]
public virtual T get_Value();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`2<T, THeaders> self);
}
internal class Azure.Core.SequentialDelayStrategy : DelayStrategy {
    [NullableAttribute("1")]
private static TimeSpan[] _pollingSequence;
    private static TimeSpan _maxDelay;
    private static SequentialDelayStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.StringRequestContent : RequestContent {
    private Byte[] _bytes;
    public StringRequestContent(string value);
    [AsyncStateMachineAttribute("Azure.Core.StringRequestContent/<WriteToAsync>d__2")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.TypeFormatters : object {
    private static string RoundtripZFormat;
    [CompilerGeneratedAttribute]
private static string <DefaultNumberFormat>k__BackingField;
    public static string DefaultNumberFormat { get; }
    private static TypeFormatters();
    [CompilerGeneratedAttribute]
public static string get_DefaultNumberFormat();
    public static string ToString(bool value);
    public static string ToString(DateTime value, string format);
    public static string ToString(DateTimeOffset value, string format);
    public static string ToString(TimeSpan value, string format);
    public static string ToString(Byte[] value, string format);
    public static string ToBase64UrlString(Byte[] value);
    public static Byte[] FromBase64UrlString(string value);
    private static int GetNumBase64PaddingCharsToAddForDecode(int inputLength);
    public static DateTimeOffset ParseDateTimeOffset(string value, string format);
    public static TimeSpan ParseTimeSpan(string value, string format);
    [NullableContextAttribute("2")]
public static string ConvertToString(object value, string format);
}
[IsReadOnlyAttribute]
internal class Azure.Core.VoidValue : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XElementExtensions : object {
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64Value(XElement element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffsetValue(XElement element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpanValue(XElement element, string format);
    [ExtensionAttribute]
public static object GetObjectValue(XElement element, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.XmlWriterContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private XmlWriter <XmlWriter>k__BackingField;
    public XmlWriter XmlWriter { get; }
    [CompilerGeneratedAttribute]
public XmlWriter get_XmlWriter();
    [AsyncStateMachineAttribute("Azure.Core.XmlWriterContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XmlWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteObjectValue(XmlWriter writer, object value, string nameHint);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, Byte[] value, string format);
}
internal class Azure.NoBodyResponse`1 : Response`1<T> {
    private Response _response;
    public bool HasValue { get; }
    public T Value { get; }
    public NoBodyResponse`1(Response response);
    public virtual bool get_HasValue();
    public virtual T get_Value();
    public virtual Response GetRawResponse();
    public virtual string ToString();
}
internal class Azure.Storage.AggregatingProgressIncrementer : object {
    private long _currentValue;
    private IProgress`1<long> _innerHandler;
    [CompilerGeneratedAttribute]
private static AggregatingProgressIncrementer <None>k__BackingField;
    public static AggregatingProgressIncrementer None { get; }
    public long Current { get; }
    public AggregatingProgressIncrementer(IProgress`1<long> innerHandler);
    private static AggregatingProgressIncrementer();
    public Stream CreateProgressIncrementingStream(Stream stream);
    public sealed virtual void Report(long bytes);
    public void Reset();
    [CompilerGeneratedAttribute]
public static AggregatingProgressIncrementer get_None();
    public long get_Current();
}
[ExtensionAttribute]
internal static class Azure.Storage.BufferExtensions : object {
    [ExtensionAttribute]
public static IDisposable RentDisposable(ArrayPool`1<T> pool, int minimumLength, T[]& array);
    [ExtensionAttribute]
public static IDisposable RentAsMemoryDisposable(ArrayPool`1<T> pool, int minimumLength, Memory`1& memory);
    [ExtensionAttribute]
public static IDisposable RentAsSpanDisposable(ArrayPool`1<T> pool, int minimumLength, Span`1& span);
    [ExtensionAttribute]
public static T[] Clear(T[] array);
}
internal class Azure.Storage.ChecksumCalculatingStream : Stream {
    private Stream _stream;
    private AppendChecksumCalculation _appendChecksumCalculation;
    private long _initialPosition;
    private long _nextToBeChecksummedPosition;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private ChecksumCalculatingStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation, bool isReadMode);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public static Stream GetReadStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation);
    public static Stream GetWriteStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<ReadAsync>d__30")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<ReadSeekableInternal>d__31")]
private Task`1<int> ReadSeekableInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<ReadUnseekableInternal>d__32")]
private Task`1<int> ReadUnseekableInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<WriteAsync>d__34")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<WriteInternal>d__35")]
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<FlushAsync>d__38")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Close();
    public virtual void SetLength(long value);
    private void AssertCanRead();
    private void AssertCanWrite();
}
internal static class Azure.Storage.Common.Argument : object {
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static void AssertEnumDefined(Type enumType, object value, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    public static void AssertNull(T value, string name, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Storage.Common.AzureSasCredentialSynchronousPolicy : HttpPipelineSynchronousPolicy {
    private AzureSasCredential _credential;
    public AzureSasCredentialSynchronousPolicy(AzureSasCredential credential);
    public virtual void OnSendingRequest(HttpMessage message);
}
[DefaultMemberAttribute("Item")]
internal class Azure.Storage.Common.ChangeTrackingDictionary`2 : object {
    private IDictionary`2<TKey, TValue> _innerDictionary;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ChangeTrackingDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public ChangeTrackingDictionary`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    public bool get_IsUndefined();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public IDictionary`2<TKey, TValue> EnsureDictionary();
    [IteratorStateMachineAttribute("Azure.Storage.Common.ChangeTrackingDictionary`2/<<GetEnumerator>g__enumerateEmpty|21_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__enumerateEmpty|21_0();
}
[DefaultMemberAttribute("Item")]
internal class Azure.Storage.Common.ChangeTrackingList`1 : object {
    private IList`1<T> _innerList;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ChangeTrackingList`1(IList`1<T> innerList);
    public ChangeTrackingList`1(IReadOnlyList`1<T> innerList);
    public bool get_IsUndefined();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public void Reset();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public IList`1<T> EnsureList();
    [IteratorStateMachineAttribute("Azure.Storage.Common.ChangeTrackingList`1/<<GetEnumerator>g__enumerateEmpty|14_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<T> <GetEnumerator>g__enumerateEmpty|14_0();
}
[ExtensionAttribute]
internal static class Azure.Storage.Common.ModelSerializationExtensions : object {
    internal static ModelReaderWriterOptions WireOptions;
    private static ModelSerializationExtensions();
    [ExtensionAttribute]
public static object GetObject(JsonElement element);
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64(JsonElement element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffset(JsonElement element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpan(JsonElement element, string format);
    [ExtensionAttribute]
public static char GetChar(JsonElement element);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ThrowNonNullablePropertyIsNull(JsonProperty property);
    [ExtensionAttribute]
public static string GetRequiredString(JsonElement element);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTime value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, char value);
    [ExtensionAttribute]
public static void WriteBase64StringValue(Utf8JsonWriter writer, Byte[] value, string format);
    [ExtensionAttribute]
public static void WriteNumberValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteObjectValue(Utf8JsonWriter writer, T value);
    [ExtensionAttribute]
public static void WriteObjectValue(Utf8JsonWriter writer, object value);
}
internal class Azure.Storage.Common.MultipartFormDataRequestContent : RequestContent {
    private MultipartFormDataContent _multipartContent;
    private static Random _random;
    private static Char[] _boundaryValues;
    public string ContentType { get; }
    internal HttpContent HttpContent { get; }
    private static MultipartFormDataRequestContent();
    public string get_ContentType();
    internal HttpContent get_HttpContent();
    private static string CreateBoundary();
    public void Add(string content, string name, string filename, string contentType);
    public void Add(int content, string name, string filename, string contentType);
    public void Add(long content, string name, string filename, string contentType);
    public void Add(float content, string name, string filename, string contentType);
    public void Add(double content, string name, string filename, string contentType);
    public void Add(decimal content, string name, string filename, string contentType);
    public void Add(bool content, string name, string filename, string contentType);
    public void Add(Stream content, string name, string filename, string contentType);
    public void Add(Byte[] content, string name, string filename, string contentType);
    public void Add(BinaryData content, string name, string filename, string contentType);
    private void Add(HttpContent content, string name, string filename, string contentType);
    public static void AddFilenameHeader(HttpContent content, string name, string filename);
    public static void AddContentTypeHeader(HttpContent content, string contentType);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Common.MultipartFormDataRequestContent/<WriteToAsync>d__24")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public virtual void Dispose();
}
internal static class Azure.Storage.Common.Optional : object {
    public static bool IsCollectionDefined(IEnumerable`1<T> collection);
    public static bool IsCollectionDefined(IDictionary`2<TKey, TValue> collection);
    public static bool IsCollectionDefined(IReadOnlyDictionary`2<TKey, TValue> collection);
    public static bool IsDefined(Nullable`1<T> value);
    public static bool IsDefined(object value);
    public static bool IsDefined(JsonElement value);
    public static bool IsDefined(string value);
}
internal static class Azure.Storage.Common.RequestContentHelper : object {
    public static RequestContent FromEnumerable(IEnumerable`1<T> enumerable);
    public static RequestContent FromEnumerable(IEnumerable`1<BinaryData> enumerable);
    public static RequestContent FromEnumerable(ReadOnlySpan`1<T> span);
    public static RequestContent FromDictionary(IDictionary`2<string, TValue> dictionary);
    public static RequestContent FromDictionary(IDictionary`2<string, BinaryData> dictionary);
    public static RequestContent FromObject(object value);
    public static RequestContent FromObject(BinaryData value);
}
internal class Azure.Storage.Common.Utf8JsonRequestContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private Utf8JsonWriter <JsonWriter>k__BackingField;
    public Utf8JsonWriter JsonWriter { get; }
    [CompilerGeneratedAttribute]
public Utf8JsonWriter get_JsonWriter();
    [AsyncStateMachineAttribute("Azure.Storage.Common.Utf8JsonRequestContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
internal static class Azure.Storage.CompatSwitches : object {
    private static Nullable`1<bool> _disableRequestConditionsValidation;
    private static Nullable`1<bool> _disableExpectContinueHeader;
    public static bool DisableRequestConditionsValidation { get; }
    public static bool DisableExpectContinueHeader { get; }
    public static bool get_DisableRequestConditionsValidation();
    public static bool get_DisableExpectContinueHeader();
}
internal static class Azure.Storage.Constants : object {
    public static int KB;
    public static int MB;
    public static int GB;
    public static long TB;
    public static int Base16;
    public static int MaxReliabilityRetries;
    public static int MaxIdleTimeMs;
    public static string DefaultSasVersion;
    public static int MaxHashRequestDownloadRange;
    public static int DefaultBufferSize;
    public static int LargeBufferSize;
    public static int LargeUploadThreshold;
    public static int DefaultStreamingDownloadSize;
    public static int DefaultStreamCopyBufferSize;
    public static int DefaultDownloadCopyBufferSize;
    public static int StorageCrc64SizeInBytes;
    public static int MD5SizeInBytes;
    public static bool DefaultTrimBlobNameSlashes;
    public static string CloseAllHandles;
    public static string Wildcard;
    public static string BlockNameFormat;
    public static string SasTimeFormatSeconds;
    public static string SasTimeFormatSubSeconds;
    public static string SasTimeFormatMinutes;
    public static string SasTimeFormatDays;
    public static string SnapshotParameterName;
    public static string VersionIdParameterName;
    public static string ShareSnapshotParameterName;
    public static string Https;
    public static string Http;
    public static string PercentSign;
    public static string EncodedPercentSign;
    public static string QueryDelimiter;
    public static string PathBackSlashDelimiter;
    public static string FalseName;
    public static string TrueName;
    public static string ErrorCode;
    public static string ErrorMessage;
    public static string CommaString;
    public static char CommaChar;
    public static string ContentTypeApplicationXml;
    public static string ContentTypeApplicationJson;
    public static string ErrorPropertyKey;
    public static string DetailPropertyKey;
    public static string MessagePropertyKey;
    public static string CodePropertyKey;
    public static string Iso8601Format;
    public static string DisableRequestConditionsValidationSwitchName;
    public static string DisableRequestConditionsValidationEnvVar;
    public static string DisableExpectContinueHeaderSwitchName;
    public static string DisableExpectContinueHeaderEnvVar;
    public static string DefaultScope;
}
[ExtensionAttribute]
internal static class Azure.Storage.ContentHasher : object {
    internal static int GetHashSizeInBytes(StorageChecksumAlgorithm algorithm);
    [ExtensionAttribute]
internal static UploadTransferValidationOptions ToUploadTransferValidationOptions(GetHashResult hashResult);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<AssertResponseHashMatchInternal>d__3")]
public static Task AssertResponseHashMatchInternal(Stream content, StorageChecksumAlgorithm algorithm, Response response, bool async, CancellationToken cancellationToken);
    public static void AssertResponseHashMatch(Byte[] content, int offset, int count, StorageChecksumAlgorithm algorithm, Response response);
    private static void AssertResponseHashMatch(GetHashResult computedHash, StorageChecksumAlgorithm algorithm, Response response);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<GetHashOrDefaultInternal>d__6")]
public static Task`1<GetHashResult> GetHashOrDefaultInternal(Stream content, UploadTransferValidationOptions options, bool async, CancellationToken cancellationToken);
    public static GetHashResult GetHashOrDefault(BinaryData content, UploadTransferValidationOptions options);
    private static bool GetHashOrDefaultTryFromOptions(UploadTransferValidationOptions options, GetHashResult& result);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<GetHashInternal>d__9")]
public static Task`1<GetHashResult> GetHashInternal(Stream content, StorageChecksumAlgorithm algorithmIdentifier, bool async, CancellationToken cancellationToken);
    public static GetHashResult GetHash(BinaryData content, StorageChecksumAlgorithm algorithmIdentifier);
    public static ValueTuple`4<Stream, GetFinalStreamHash, int, IDisposable> SetupChecksumCalculatingReadStream(Stream stream, StorageChecksumAlgorithm algorithmIdentifier);
    private static IHasher GetHasher(StorageChecksumAlgorithm algorithmIdentifier);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<ComputeHashInternal>d__14")]
private static Task`1<Byte[]> ComputeHashInternal(Stream content, IHasher hasher, bool async, CancellationToken cancellationToken);
    public static IHasher GetHasherFromAlgorithmId(StorageChecksumAlgorithm algorithm);
    public static ValueTuple`2<ReadOnlyMemory`1<byte>, StorageChecksumAlgorithm> GetResponseChecksumOrDefault(Response response);
    [CompilerGeneratedAttribute]
internal static Byte[] <GetHash>g__computeCrc|10_0(StorageCrc64HashAlgorithm nonCryptographicHashAlgorithm, <>c__DisplayClass10_0& );
}
internal class Azure.Storage.DisposableBucket : object {
    [CompilerGeneratedAttribute]
private List`1<IDisposable> <Disposables>k__BackingField;
    private List`1<IDisposable> Disposables { get; }
    [CompilerGeneratedAttribute]
private List`1<IDisposable> get_Disposables();
    public void Add(IDisposable disposable);
    public sealed virtual void Dispose();
}
internal class Azure.Storage.Errors : object {
    public static ArgumentException AccountMismatch(string accountNameCredential, string accountNameValue);
    public static InvalidOperationException AccountSasMissingData();
    public static ArgumentNullException ArgumentNull(string paramName);
    public static ArgumentException InvalidArgument(string paramName);
    public static ArgumentException InvalidResourceType(char s);
    public static InvalidOperationException TaskIncomplete();
    public static FormatException InvalidFormat(string err);
    public static ArgumentException ParsingConnectionStringFailed();
    public static ArgumentOutOfRangeException InvalidSasProtocol(string protocol, string sasProtocol);
    public static ArgumentException InvalidService(char s);
    public static ArgumentException InsufficientStorageTransferOptions(long streamLength, long statedMaxBlockSize, long necessaryMinBlockSize);
    public static InvalidDataException HashMismatch(string hashHeaderName);
    public static InvalidDataException ChecksumMismatch(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static InvalidDataException HashMismatchOnStreamedDownload(string mismatchedRange);
    public static ArgumentException PrecalculatedHashNotSupportedOnSplit();
    public static ArgumentException CannotDeferTransactionalHashVerification();
    public static ArgumentException CannotInitializeWriteStreamWithData();
    internal static void VerifyStreamPosition(Stream stream, string streamName);
    public static void ThrowIfParamNull(object obj, string paramName);
    internal static void CheckCryptKeySize(int keySizeInBytes);
    public static CryptographicException CryptographyAuthTagMismatch();
    public static ArgumentException CryptographyPlaintextCiphertextLengthMismatch();
    public static ArgumentException CryptographyInvalidNonceLength();
    public static ArgumentException CryptographyInvalidTagLength();
    public static ArgumentException CannotBothBeNotNull(string param0, string param1);
    public static ArgumentOutOfRangeException MustBeGreaterThanOrEqualTo(string paramName, long value);
    public static ArgumentOutOfRangeException MustBeLessThanOrEqualTo(string paramName, long value);
    public static ArgumentOutOfRangeException MustBeBetweenInclusive(string paramName, long lower, long upper, long actual);
    public static ArgumentOutOfRangeException MustBeGreaterThanValueOrEqualToOtherValue(string paramName, long value0, long value1);
    public static ArgumentException StreamMustBeReadable(string paramName);
    public static InvalidOperationException StreamMustBeAtPosition0();
    public static InvalidOperationException TokenCredentialsRequireHttps();
    public static ArgumentException SasCredentialRequiresUriWithoutSas(Uri uri);
    public static InvalidOperationException SasMissingData(string paramName);
    public static InvalidOperationException SasDataNotAllowed(string paramName, string paramNameNotAllowed);
    public static InvalidOperationException SasDataInConjunction(string paramName, string paramName2);
    public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName, string clientParam);
    public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName);
    public static InvalidOperationException SasServiceNotMatching(string builderParam, string builderName, string expectedService);
    public static InvalidOperationException SasClientMissingData(string paramName);
    public static InvalidOperationException SasBuilderEmptyParam(string builderName, string paramName, string sasType);
    public static InvalidOperationException SasIncorrectResourceType(string builderName, string builderParam, string value, string clientName);
    public static ArgumentException InvalidPermission(char s);
    public static ArgumentException ParsingHttpRangeFailed();
    public static AccessViolationException UnableAccessArray();
    public static NotImplementedException NotImplemented();
    public static AuthenticationException InvalidCredentials(string fullName);
    public static ArgumentException SeekOutsideBufferRange(long index, long inclusiveRangeStart, long exclusiveRangeEnd);
    public static ArgumentException VersionNotSupported(string paramName);
    public static RequestFailedException ClientRequestIdMismatch(Response response, string echo, string original);
    public static ArgumentException TransactionalHashingNotSupportedWithClientSideEncryption();
    public static void VerifyHttpsTokenAuth(Uri uri);
}
internal class Azure.Storage.ExpectContinueOnThrottlePolicy : HttpPipelineSynchronousPolicy {
    private long _lastThrottleTicks;
    private long _throttleIntervalTicks;
    [CompilerGeneratedAttribute]
private long <ContentLengthThreshold>k__BackingField;
    public TimeSpan ThrottleInterval { get; public set; }
    public long ContentLengthThreshold { get; public set; }
    public TimeSpan get_ThrottleInterval();
    public void set_ThrottleInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public long get_ContentLengthThreshold();
    [CompilerGeneratedAttribute]
public void set_ContentLengthThreshold(long value);
    public virtual void OnSendingRequest(HttpMessage message);
    public virtual void OnReceivedResponse(HttpMessage message);
}
internal class Azure.Storage.ExpectContinuePolicy : HttpPipelineSynchronousPolicy {
    [CompilerGeneratedAttribute]
private long <ContentLengthThreshold>k__BackingField;
    public long ContentLengthThreshold { get; public set; }
    [CompilerGeneratedAttribute]
public long get_ContentLengthThreshold();
    [CompilerGeneratedAttribute]
public void set_ContentLengthThreshold(long value);
    public virtual void OnSendingRequest(HttpMessage message);
}
internal class Azure.Storage.Files.Shares.DirectoryCreateHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string FilePermissionKey { get; }
    public string FileAttributes { get; }
    public Nullable`1<DateTimeOffset> FileCreationTime { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Nullable`1<DateTimeOffset> FileChangeTime { get; }
    public string FileId { get; }
    public string FileParentId { get; }
    public DirectoryCreateHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_FilePermissionKey();
    public string get_FileAttributes();
    public Nullable`1<DateTimeOffset> get_FileCreationTime();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Nullable`1<DateTimeOffset> get_FileChangeTime();
    public string get_FileId();
    public string get_FileParentId();
}
internal class Azure.Storage.Files.Shares.DirectoryDeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public DirectoryDeleteHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.DirectoryForceCloseHandlesHeaders : object {
    private Response _response;
    public string Version { get; }
    public string Marker { get; }
    public Nullable`1<int> NumberOfHandlesClosed { get; }
    public Nullable`1<int> NumberOfHandlesFailedToClose { get; }
    public DirectoryForceCloseHandlesHeaders(Response response);
    public string get_Version();
    public string get_Marker();
    public Nullable`1<int> get_NumberOfHandlesClosed();
    public Nullable`1<int> get_NumberOfHandlesFailedToClose();
}
internal class Azure.Storage.Files.Shares.DirectoryGetPropertiesHeaders : object {
    private Response _response;
    public IDictionary`2<string, string> Metadata { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string FileAttributes { get; }
    public Nullable`1<DateTimeOffset> FileCreationTime { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Nullable`1<DateTimeOffset> FileChangeTime { get; }
    public string FilePermissionKey { get; }
    public string FileId { get; }
    public string FileParentId { get; }
    public DirectoryGetPropertiesHeaders(Response response);
    public IDictionary`2<string, string> get_Metadata();
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_FileAttributes();
    public Nullable`1<DateTimeOffset> get_FileCreationTime();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Nullable`1<DateTimeOffset> get_FileChangeTime();
    public string get_FilePermissionKey();
    public string get_FileId();
    public string get_FileParentId();
}
internal class Azure.Storage.Files.Shares.DirectoryListFilesAndDirectoriesSegmentHeaders : object {
    private Response _response;
    public string ContentType { get; }
    public string Version { get; }
    public DirectoryListFilesAndDirectoriesSegmentHeaders(Response response);
    public string get_ContentType();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.DirectoryListHandlesHeaders : object {
    private Response _response;
    public string ContentType { get; }
    public string Version { get; }
    public DirectoryListHandlesHeaders(Response response);
    public string get_ContentType();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.DirectoryRenameHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string FilePermissionKey { get; }
    public string FileAttributes { get; }
    public Nullable`1<DateTimeOffset> FileCreationTime { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Nullable`1<DateTimeOffset> FileChangeTime { get; }
    public string FileId { get; }
    public string FileParentId { get; }
    public DirectoryRenameHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_FilePermissionKey();
    public string get_FileAttributes();
    public Nullable`1<DateTimeOffset> get_FileCreationTime();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Nullable`1<DateTimeOffset> get_FileChangeTime();
    public string get_FileId();
    public string get_FileParentId();
}
internal class Azure.Storage.Files.Shares.DirectoryRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    private Nullable`1<bool> _allowTrailingDot;
    private Nullable`1<ShareTokenIntent> _fileRequestIntent;
    private Nullable`1<bool> _allowSourceTrailingDot;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public DirectoryRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version, Nullable`1<bool> allowTrailingDot, Nullable`1<ShareTokenIntent> fileRequestIntent, Nullable`1<bool> allowSourceTrailingDot);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateCreateRequest(string fileAttributes, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<CreateAsync>d__11")]
public Task`1<ResponseWithHeaders`1<DirectoryCreateHeaders>> CreateAsync(string fileAttributes, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<DirectoryCreateHeaders> Create(string fileAttributes, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(string sharesnapshot, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<GetPropertiesAsync>d__14")]
public Task`1<ResponseWithHeaders`1<DirectoryGetPropertiesHeaders>> GetPropertiesAsync(string sharesnapshot, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<DirectoryGetPropertiesHeaders> GetProperties(string sharesnapshot, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateDeleteRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<DeleteAsync>d__17")]
public Task`1<ResponseWithHeaders`1<DirectoryDeleteHeaders>> DeleteAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<DirectoryDeleteHeaders> Delete(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateSetPropertiesRequest(string fileAttributes, Nullable`1<int> timeout, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<SetPropertiesAsync>d__20")]
public Task`1<ResponseWithHeaders`1<DirectorySetPropertiesHeaders>> SetPropertiesAsync(string fileAttributes, Nullable`1<int> timeout, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<DirectorySetPropertiesHeaders> SetProperties(string fileAttributes, Nullable`1<int> timeout, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, CancellationToken cancellationToken);
    internal HttpMessage CreateSetMetadataRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<SetMetadataAsync>d__23")]
public Task`1<ResponseWithHeaders`1<DirectorySetMetadataHeaders>> SetMetadataAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<DirectorySetMetadataHeaders> SetMetadata(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    internal HttpMessage CreateListFilesAndDirectoriesSegmentRequest(string prefix, string sharesnapshot, string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, IEnumerable`1<ListFilesIncludeType> include, Nullable`1<bool> includeExtendedInfo);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<ListFilesAndDirectoriesSegmentAsync>d__26")]
public Task`1<ResponseWithHeaders`2<ListFilesAndDirectoriesSegmentResponse, DirectoryListFilesAndDirectoriesSegmentHeaders>> ListFilesAndDirectoriesSegmentAsync(string prefix, string sharesnapshot, string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, IEnumerable`1<ListFilesIncludeType> include, Nullable`1<bool> includeExtendedInfo, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListFilesAndDirectoriesSegmentResponse, DirectoryListFilesAndDirectoriesSegmentHeaders> ListFilesAndDirectoriesSegment(string prefix, string sharesnapshot, string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, IEnumerable`1<ListFilesIncludeType> include, Nullable`1<bool> includeExtendedInfo, CancellationToken cancellationToken);
    internal HttpMessage CreateListHandlesRequest(string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, string sharesnapshot, Nullable`1<bool> recursive);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<ListHandlesAsync>d__29")]
public Task`1<ResponseWithHeaders`2<ListHandlesResponse, DirectoryListHandlesHeaders>> ListHandlesAsync(string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, string sharesnapshot, Nullable`1<bool> recursive, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListHandlesResponse, DirectoryListHandlesHeaders> ListHandles(string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, string sharesnapshot, Nullable`1<bool> recursive, CancellationToken cancellationToken);
    internal HttpMessage CreateForceCloseHandlesRequest(string handleId, Nullable`1<int> timeout, string marker, string sharesnapshot, Nullable`1<bool> recursive);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<ForceCloseHandlesAsync>d__32")]
public Task`1<ResponseWithHeaders`1<DirectoryForceCloseHandlesHeaders>> ForceCloseHandlesAsync(string handleId, Nullable`1<int> timeout, string marker, string sharesnapshot, Nullable`1<bool> recursive, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<DirectoryForceCloseHandlesHeaders> ForceCloseHandles(string handleId, Nullable`1<int> timeout, string marker, string sharesnapshot, Nullable`1<bool> recursive, CancellationToken cancellationToken);
    internal HttpMessage CreateRenameRequest(string renameSource, Nullable`1<int> timeout, Nullable`1<bool> replaceIfExists, Nullable`1<bool> ignoreReadOnly, string sourceLeaseId, string destinationLeaseId, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, IDictionary`2<string, string> metadata, CopyFileSmbInfo copyFileSmbInfo);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<RenameAsync>d__35")]
public Task`1<ResponseWithHeaders`1<DirectoryRenameHeaders>> RenameAsync(string renameSource, Nullable`1<int> timeout, Nullable`1<bool> replaceIfExists, Nullable`1<bool> ignoreReadOnly, string sourceLeaseId, string destinationLeaseId, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, IDictionary`2<string, string> metadata, CopyFileSmbInfo copyFileSmbInfo, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<DirectoryRenameHeaders> Rename(string renameSource, Nullable`1<int> timeout, Nullable`1<bool> replaceIfExists, Nullable`1<bool> ignoreReadOnly, string sourceLeaseId, string destinationLeaseId, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, IDictionary`2<string, string> metadata, CopyFileSmbInfo copyFileSmbInfo, CancellationToken cancellationToken);
    internal HttpMessage CreateListFilesAndDirectoriesSegmentNextPageRequest(string nextLink, string prefix, string sharesnapshot, string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, IEnumerable`1<ListFilesIncludeType> include, Nullable`1<bool> includeExtendedInfo);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.DirectoryRestClient/<ListFilesAndDirectoriesSegmentNextPageAsync>d__38")]
public Task`1<ResponseWithHeaders`2<ListFilesAndDirectoriesSegmentResponse, DirectoryListFilesAndDirectoriesSegmentHeaders>> ListFilesAndDirectoriesSegmentNextPageAsync(string nextLink, string prefix, string sharesnapshot, string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, IEnumerable`1<ListFilesIncludeType> include, Nullable`1<bool> includeExtendedInfo, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListFilesAndDirectoriesSegmentResponse, DirectoryListFilesAndDirectoriesSegmentHeaders> ListFilesAndDirectoriesSegmentNextPage(string nextLink, string prefix, string sharesnapshot, string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, IEnumerable`1<ListFilesIncludeType> include, Nullable`1<bool> includeExtendedInfo, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.Shares.DirectorySetMetadataHeaders : object {
    private Response _response;
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public DirectorySetMetadataHeaders(Response response);
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
}
internal class Azure.Storage.Files.Shares.DirectorySetPropertiesHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string FilePermissionKey { get; }
    public string FileAttributes { get; }
    public Nullable`1<DateTimeOffset> FileCreationTime { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Nullable`1<DateTimeOffset> FileChangeTime { get; }
    public string FileId { get; }
    public string FileParentId { get; }
    public DirectorySetPropertiesHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_FilePermissionKey();
    public string get_FileAttributes();
    public Nullable`1<DateTimeOffset> get_FileCreationTime();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Nullable`1<DateTimeOffset> get_FileChangeTime();
    public string get_FileId();
    public string get_FileParentId();
}
internal class Azure.Storage.Files.Shares.FileAbortCopyHeaders : object {
    private Response _response;
    public string Version { get; }
    public FileAbortCopyHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.FileAcquireLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public FileAcquireLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.FileBreakLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public FileBreakLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.FileChangeLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public FileChangeLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.FileCreateHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string FilePermissionKey { get; }
    public string FileAttributes { get; }
    public Nullable`1<DateTimeOffset> FileCreationTime { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Nullable`1<DateTimeOffset> FileChangeTime { get; }
    public string FileId { get; }
    public string FileParentId { get; }
    public FileCreateHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_FilePermissionKey();
    public string get_FileAttributes();
    public Nullable`1<DateTimeOffset> get_FileCreationTime();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Nullable`1<DateTimeOffset> get_FileChangeTime();
    public string get_FileId();
    public string get_FileParentId();
}
internal class Azure.Storage.Files.Shares.FileDeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public FileDeleteHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.FileDownloadHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentType { get; }
    public string ContentRange { get; }
    public Byte[] ContentMD5 { get; }
    public string ContentEncoding { get; }
    public string CacheControl { get; }
    public string ContentDisposition { get; }
    public string ContentLanguage { get; }
    public string Version { get; }
    public string AcceptRanges { get; }
    public Nullable`1<DateTimeOffset> CopyCompletionTime { get; }
    public string CopyStatusDescription { get; }
    public string CopyId { get; }
    public string CopyProgress { get; }
    public string CopySource { get; }
    public Nullable`1<CopyStatus> CopyStatus { get; }
    public Byte[] FileContentMD5 { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string FileAttributes { get; }
    public Nullable`1<DateTimeOffset> FileCreationTime { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Nullable`1<DateTimeOffset> FileChangeTime { get; }
    public string FilePermissionKey { get; }
    public string FileId { get; }
    public string FileParentId { get; }
    public Nullable`1<ShareLeaseDuration> LeaseDuration { get; }
    public Nullable`1<ShareLeaseState> LeaseState { get; }
    public Nullable`1<ShareLeaseStatus> LeaseStatus { get; }
    public FileDownloadHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public IDictionary`2<string, string> get_Metadata();
    public Nullable`1<long> get_ContentLength();
    public string get_ContentType();
    public string get_ContentRange();
    public Byte[] get_ContentMD5();
    public string get_ContentEncoding();
    public string get_CacheControl();
    public string get_ContentDisposition();
    public string get_ContentLanguage();
    public string get_Version();
    public string get_AcceptRanges();
    public Nullable`1<DateTimeOffset> get_CopyCompletionTime();
    public string get_CopyStatusDescription();
    public string get_CopyId();
    public string get_CopyProgress();
    public string get_CopySource();
    public Nullable`1<CopyStatus> get_CopyStatus();
    public Byte[] get_FileContentMD5();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_FileAttributes();
    public Nullable`1<DateTimeOffset> get_FileCreationTime();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Nullable`1<DateTimeOffset> get_FileChangeTime();
    public string get_FilePermissionKey();
    public string get_FileId();
    public string get_FileParentId();
    public Nullable`1<ShareLeaseDuration> get_LeaseDuration();
    public Nullable`1<ShareLeaseState> get_LeaseState();
    public Nullable`1<ShareLeaseStatus> get_LeaseStatus();
}
internal class Azure.Storage.Files.Shares.FileForceCloseHandlesHeaders : object {
    private Response _response;
    public string Version { get; }
    public string Marker { get; }
    public Nullable`1<int> NumberOfHandlesClosed { get; }
    public Nullable`1<int> NumberOfHandlesFailedToClose { get; }
    public FileForceCloseHandlesHeaders(Response response);
    public string get_Version();
    public string get_Marker();
    public Nullable`1<int> get_NumberOfHandlesClosed();
    public Nullable`1<int> get_NumberOfHandlesFailedToClose();
}
internal class Azure.Storage.Files.Shares.FileGetPropertiesHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public string FileType { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentType { get; }
    public Byte[] ContentMD5 { get; }
    public string ContentEncoding { get; }
    public string CacheControl { get; }
    public string ContentDisposition { get; }
    public string ContentLanguage { get; }
    public string Version { get; }
    public Nullable`1<DateTimeOffset> CopyCompletionTime { get; }
    public string CopyStatusDescription { get; }
    public string CopyId { get; }
    public string CopyProgress { get; }
    public string CopySource { get; }
    public Nullable`1<CopyStatus> CopyStatus { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string FileAttributes { get; }
    public Nullable`1<DateTimeOffset> FileCreationTime { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Nullable`1<DateTimeOffset> FileChangeTime { get; }
    public string FilePermissionKey { get; }
    public string FileId { get; }
    public string FileParentId { get; }
    public Nullable`1<ShareLeaseDuration> LeaseDuration { get; }
    public Nullable`1<ShareLeaseState> LeaseState { get; }
    public Nullable`1<ShareLeaseStatus> LeaseStatus { get; }
    public FileGetPropertiesHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public IDictionary`2<string, string> get_Metadata();
    public string get_FileType();
    public Nullable`1<long> get_ContentLength();
    public string get_ContentType();
    public Byte[] get_ContentMD5();
    public string get_ContentEncoding();
    public string get_CacheControl();
    public string get_ContentDisposition();
    public string get_ContentLanguage();
    public string get_Version();
    public Nullable`1<DateTimeOffset> get_CopyCompletionTime();
    public string get_CopyStatusDescription();
    public string get_CopyId();
    public string get_CopyProgress();
    public string get_CopySource();
    public Nullable`1<CopyStatus> get_CopyStatus();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_FileAttributes();
    public Nullable`1<DateTimeOffset> get_FileCreationTime();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Nullable`1<DateTimeOffset> get_FileChangeTime();
    public string get_FilePermissionKey();
    public string get_FileId();
    public string get_FileParentId();
    public Nullable`1<ShareLeaseDuration> get_LeaseDuration();
    public Nullable`1<ShareLeaseState> get_LeaseState();
    public Nullable`1<ShareLeaseStatus> get_LeaseStatus();
}
internal class Azure.Storage.Files.Shares.FileGetRangeListHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<long> FileContentLength { get; }
    public string Version { get; }
    public FileGetRangeListHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<long> get_FileContentLength();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.FileListHandlesHeaders : object {
    private Response _response;
    public string ContentType { get; }
    public string Version { get; }
    public FileListHandlesHeaders(Response response);
    public string get_ContentType();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.FileReleaseLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public FileReleaseLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.FileRenameHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string FilePermissionKey { get; }
    public string FileAttributes { get; }
    public Nullable`1<DateTimeOffset> FileCreationTime { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Nullable`1<DateTimeOffset> FileChangeTime { get; }
    public string FileId { get; }
    public string FileParentId { get; }
    public FileRenameHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_FilePermissionKey();
    public string get_FileAttributes();
    public Nullable`1<DateTimeOffset> get_FileCreationTime();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Nullable`1<DateTimeOffset> get_FileChangeTime();
    public string get_FileId();
    public string get_FileParentId();
}
internal class Azure.Storage.Files.Shares.FileRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    private string _fileRangeWriteFromUrl;
    private Nullable`1<bool> _allowTrailingDot;
    private Nullable`1<ShareTokenIntent> _fileRequestIntent;
    private Nullable`1<bool> _allowSourceTrailingDot;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public FileRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version, string fileRangeWriteFromUrl, Nullable`1<bool> allowTrailingDot, Nullable`1<ShareTokenIntent> fileRequestIntent, Nullable`1<bool> allowSourceTrailingDot);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateCreateRequest(long fileContentLength, string fileAttributes, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, FileHttpHeaders fileHttpHeaders, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<CreateAsync>d__12")]
public Task`1<ResponseWithHeaders`1<FileCreateHeaders>> CreateAsync(long fileContentLength, string fileAttributes, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, FileHttpHeaders fileHttpHeaders, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileCreateHeaders> Create(long fileContentLength, string fileAttributes, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, FileHttpHeaders fileHttpHeaders, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateDownloadRequest(Nullable`1<int> timeout, string range, Nullable`1<bool> rangeGetContentMD5, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<DownloadAsync>d__15")]
public Task`1<ResponseWithHeaders`2<Stream, FileDownloadHeaders>> DownloadAsync(Nullable`1<int> timeout, string range, Nullable`1<bool> rangeGetContentMD5, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<Stream, FileDownloadHeaders> Download(Nullable`1<int> timeout, string range, Nullable`1<bool> rangeGetContentMD5, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(string sharesnapshot, Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<GetPropertiesAsync>d__18")]
public Task`1<ResponseWithHeaders`1<FileGetPropertiesHeaders>> GetPropertiesAsync(string sharesnapshot, Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileGetPropertiesHeaders> GetProperties(string sharesnapshot, Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateDeleteRequest(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<DeleteAsync>d__21")]
public Task`1<ResponseWithHeaders`1<FileDeleteHeaders>> DeleteAsync(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileDeleteHeaders> Delete(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateSetHttpHeadersRequest(string fileAttributes, Nullable`1<int> timeout, Nullable`1<long> fileContentLength, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, FileHttpHeaders fileHttpHeaders, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<SetHttpHeadersAsync>d__24")]
public Task`1<ResponseWithHeaders`1<FileSetHttpHeadersHeaders>> SetHttpHeadersAsync(string fileAttributes, Nullable`1<int> timeout, Nullable`1<long> fileContentLength, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, FileHttpHeaders fileHttpHeaders, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileSetHttpHeadersHeaders> SetHttpHeaders(string fileAttributes, Nullable`1<int> timeout, Nullable`1<long> fileContentLength, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, FileHttpHeaders fileHttpHeaders, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateSetMetadataRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<SetMetadataAsync>d__27")]
public Task`1<ResponseWithHeaders`1<FileSetMetadataHeaders>> SetMetadataAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileSetMetadataHeaders> SetMetadata(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<int> duration, string proposedLeaseId);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<AcquireLeaseAsync>d__30")]
public Task`1<ResponseWithHeaders`1<FileAcquireLeaseHeaders>> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<int> duration, string proposedLeaseId, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileAcquireLeaseHeaders> AcquireLease(Nullable`1<int> timeout, Nullable`1<int> duration, string proposedLeaseId, CancellationToken cancellationToken);
    internal HttpMessage CreateReleaseLeaseRequest(string leaseId, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<ReleaseLeaseAsync>d__33")]
public Task`1<ResponseWithHeaders`1<FileReleaseLeaseHeaders>> ReleaseLeaseAsync(string leaseId, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileReleaseLeaseHeaders> ReleaseLease(string leaseId, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateChangeLeaseRequest(string leaseId, Nullable`1<int> timeout, string proposedLeaseId);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<ChangeLeaseAsync>d__36")]
public Task`1<ResponseWithHeaders`1<FileChangeLeaseHeaders>> ChangeLeaseAsync(string leaseId, Nullable`1<int> timeout, string proposedLeaseId, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileChangeLeaseHeaders> ChangeLease(string leaseId, Nullable`1<int> timeout, string proposedLeaseId, CancellationToken cancellationToken);
    internal HttpMessage CreateBreakLeaseRequest(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<BreakLeaseAsync>d__39")]
public Task`1<ResponseWithHeaders`1<FileBreakLeaseHeaders>> BreakLeaseAsync(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileBreakLeaseHeaders> BreakLease(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateUploadRangeRequest(string range, ShareFileRangeWriteType fileRangeWrite, long contentLength, Nullable`1<int> timeout, Byte[] contentMD5, Nullable`1<FileLastWrittenMode> fileLastWrittenMode, Stream optionalbody, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<UploadRangeAsync>d__42")]
public Task`1<ResponseWithHeaders`1<FileUploadRangeHeaders>> UploadRangeAsync(string range, ShareFileRangeWriteType fileRangeWrite, long contentLength, Nullable`1<int> timeout, Byte[] contentMD5, Nullable`1<FileLastWrittenMode> fileLastWrittenMode, Stream optionalbody, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileUploadRangeHeaders> UploadRange(string range, ShareFileRangeWriteType fileRangeWrite, long contentLength, Nullable`1<int> timeout, Byte[] contentMD5, Nullable`1<FileLastWrittenMode> fileLastWrittenMode, Stream optionalbody, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateUploadRangeFromURLRequest(string range, string copySource, long contentLength, Nullable`1<int> timeout, string sourceRange, Byte[] sourceContentCrc64, string copySourceAuthorization, Nullable`1<FileLastWrittenMode> fileLastWrittenMode, SourceModifiedAccessConditions sourceModifiedAccessConditions, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<UploadRangeFromURLAsync>d__45")]
public Task`1<ResponseWithHeaders`1<FileUploadRangeFromURLHeaders>> UploadRangeFromURLAsync(string range, string copySource, long contentLength, Nullable`1<int> timeout, string sourceRange, Byte[] sourceContentCrc64, string copySourceAuthorization, Nullable`1<FileLastWrittenMode> fileLastWrittenMode, SourceModifiedAccessConditions sourceModifiedAccessConditions, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileUploadRangeFromURLHeaders> UploadRangeFromURL(string range, string copySource, long contentLength, Nullable`1<int> timeout, string sourceRange, Byte[] sourceContentCrc64, string copySourceAuthorization, Nullable`1<FileLastWrittenMode> fileLastWrittenMode, SourceModifiedAccessConditions sourceModifiedAccessConditions, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateGetRangeListRequest(string sharesnapshot, string prevsharesnapshot, Nullable`1<int> timeout, string range, Nullable`1<bool> supportRename, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<GetRangeListAsync>d__48")]
public Task`1<ResponseWithHeaders`2<ShareFileRangeList, FileGetRangeListHeaders>> GetRangeListAsync(string sharesnapshot, string prevsharesnapshot, Nullable`1<int> timeout, string range, Nullable`1<bool> supportRename, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ShareFileRangeList, FileGetRangeListHeaders> GetRangeList(string sharesnapshot, string prevsharesnapshot, Nullable`1<int> timeout, string range, Nullable`1<bool> supportRename, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateStartCopyRequest(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string filePermission, string filePermissionKey, CopyFileSmbInfo copyFileSmbInfo, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<StartCopyAsync>d__51")]
public Task`1<ResponseWithHeaders`1<FileStartCopyHeaders>> StartCopyAsync(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string filePermission, string filePermissionKey, CopyFileSmbInfo copyFileSmbInfo, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileStartCopyHeaders> StartCopy(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string filePermission, string filePermissionKey, CopyFileSmbInfo copyFileSmbInfo, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateAbortCopyRequest(string copyId, Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<AbortCopyAsync>d__54")]
public Task`1<ResponseWithHeaders`1<FileAbortCopyHeaders>> AbortCopyAsync(string copyId, Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileAbortCopyHeaders> AbortCopy(string copyId, Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateListHandlesRequest(string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, string sharesnapshot);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<ListHandlesAsync>d__57")]
public Task`1<ResponseWithHeaders`2<ListHandlesResponse, FileListHandlesHeaders>> ListHandlesAsync(string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, string sharesnapshot, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListHandlesResponse, FileListHandlesHeaders> ListHandles(string marker, Nullable`1<int> maxresults, Nullable`1<int> timeout, string sharesnapshot, CancellationToken cancellationToken);
    internal HttpMessage CreateForceCloseHandlesRequest(string handleId, Nullable`1<int> timeout, string marker, string sharesnapshot);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<ForceCloseHandlesAsync>d__60")]
public Task`1<ResponseWithHeaders`1<FileForceCloseHandlesHeaders>> ForceCloseHandlesAsync(string handleId, Nullable`1<int> timeout, string marker, string sharesnapshot, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileForceCloseHandlesHeaders> ForceCloseHandles(string handleId, Nullable`1<int> timeout, string marker, string sharesnapshot, CancellationToken cancellationToken);
    internal HttpMessage CreateRenameRequest(string renameSource, Nullable`1<int> timeout, Nullable`1<bool> replaceIfExists, Nullable`1<bool> ignoreReadOnly, string sourceLeaseId, string destinationLeaseId, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, IDictionary`2<string, string> metadata, CopyFileSmbInfo copyFileSmbInfo, FileHttpHeaders fileHttpHeaders);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.FileRestClient/<RenameAsync>d__63")]
public Task`1<ResponseWithHeaders`1<FileRenameHeaders>> RenameAsync(string renameSource, Nullable`1<int> timeout, Nullable`1<bool> replaceIfExists, Nullable`1<bool> ignoreReadOnly, string sourceLeaseId, string destinationLeaseId, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, IDictionary`2<string, string> metadata, CopyFileSmbInfo copyFileSmbInfo, FileHttpHeaders fileHttpHeaders, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<FileRenameHeaders> Rename(string renameSource, Nullable`1<int> timeout, Nullable`1<bool> replaceIfExists, Nullable`1<bool> ignoreReadOnly, string sourceLeaseId, string destinationLeaseId, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, string filePermissionKey, IDictionary`2<string, string> metadata, CopyFileSmbInfo copyFileSmbInfo, FileHttpHeaders fileHttpHeaders, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.Shares.FileSetHttpHeadersHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string FilePermissionKey { get; }
    public string FileAttributes { get; }
    public Nullable`1<DateTimeOffset> FileCreationTime { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Nullable`1<DateTimeOffset> FileChangeTime { get; }
    public string FileId { get; }
    public string FileParentId { get; }
    public FileSetHttpHeadersHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_FilePermissionKey();
    public string get_FileAttributes();
    public Nullable`1<DateTimeOffset> get_FileCreationTime();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Nullable`1<DateTimeOffset> get_FileChangeTime();
    public string get_FileId();
    public string get_FileParentId();
}
internal class Azure.Storage.Files.Shares.FileSetMetadataHeaders : object {
    private Response _response;
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public FileSetMetadataHeaders(Response response);
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public Nullable`1<DateTimeOffset> get_LastModified();
}
internal class Azure.Storage.Files.Shares.FileStartCopyHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string CopyId { get; }
    public Nullable`1<CopyStatus> CopyStatus { get; }
    public FileStartCopyHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_CopyId();
    public Nullable`1<CopyStatus> get_CopyStatus();
}
internal class Azure.Storage.Files.Shares.FileUploadRangeFromURLHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] XMsContentCrc64 { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public Byte[] ContentMD5 { get; }
    public FileUploadRangeFromURLHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_XMsContentCrc64();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
    public Byte[] get_ContentMD5();
}
internal class Azure.Storage.Files.Shares.FileUploadRangeHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public Nullable`1<DateTimeOffset> FileLastWriteTime { get; }
    public FileUploadRangeHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public Nullable`1<DateTimeOffset> get_FileLastWriteTime();
}
internal enum Azure.Storage.Files.Shares.Models.AccessRight : Enum {
    public int value__;
    public static AccessRight Read;
    public static AccessRight Write;
    public static AccessRight Delete;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.AccessRightExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(AccessRight value);
    [ExtensionAttribute]
public static AccessRight ToAccessRight(string value);
}
internal class Azure.Storage.Files.Shares.Models.ClearRange : object {
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private long <End>k__BackingField;
    public long Start { get; }
    public long End { get; }
    internal ClearRange(long start, long end);
    [CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
public long get_End();
    internal static ClearRange DeserializeClearRange(XElement element);
}
public class Azure.Storage.Files.Shares.Models.CloseHandlesResult : object {
    [CompilerGeneratedAttribute]
private int <ClosedHandlesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FailedHandlesCount>k__BackingField;
    public int ClosedHandlesCount { get; internal set; }
    public int FailedHandlesCount { get; internal set; }
    [CompilerGeneratedAttribute]
public int get_ClosedHandlesCount();
    [CompilerGeneratedAttribute]
internal void set_ClosedHandlesCount(int value);
    [CompilerGeneratedAttribute]
public int get_FailedHandlesCount();
    [CompilerGeneratedAttribute]
internal void set_FailedHandlesCount(int value);
}
[FlagsAttribute]
public enum Azure.Storage.Files.Shares.Models.CopyableFileSmbProperties : Enum {
    public int value__;
    public static CopyableFileSmbProperties None;
    public static CopyableFileSmbProperties FileAttributes;
    public static CopyableFileSmbProperties CreatedOn;
    public static CopyableFileSmbProperties LastWrittenOn;
    public static CopyableFileSmbProperties ChangedOn;
    public static CopyableFileSmbProperties All;
}
internal class Azure.Storage.Files.Shares.Models.CopyFileSmbInfo : object {
    [CompilerGeneratedAttribute]
private string <FileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileCreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileLastWriteTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileChangeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PermissionCopyMode> <FilePermissionCopyMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IgnoreReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SetArchiveAttribute>k__BackingField;
    public string FileAttributes { get; public set; }
    public string FileCreationTime { get; public set; }
    public string FileLastWriteTime { get; public set; }
    public string FileChangeTime { get; public set; }
    public Nullable`1<PermissionCopyMode> FilePermissionCopyMode { get; public set; }
    public Nullable`1<bool> IgnoreReadOnly { get; public set; }
    public Nullable`1<bool> SetArchiveAttribute { get; public set; }
    internal CopyFileSmbInfo(string fileAttributes, string fileCreationTime, string fileLastWriteTime, string fileChangeTime, Nullable`1<PermissionCopyMode> filePermissionCopyMode, Nullable`1<bool> ignoreReadOnly, Nullable`1<bool> setArchiveAttribute);
    [CompilerGeneratedAttribute]
public string get_FileAttributes();
    [CompilerGeneratedAttribute]
public void set_FileAttributes(string value);
    [CompilerGeneratedAttribute]
public string get_FileCreationTime();
    [CompilerGeneratedAttribute]
public void set_FileCreationTime(string value);
    [CompilerGeneratedAttribute]
public string get_FileLastWriteTime();
    [CompilerGeneratedAttribute]
public void set_FileLastWriteTime(string value);
    [CompilerGeneratedAttribute]
public string get_FileChangeTime();
    [CompilerGeneratedAttribute]
public void set_FileChangeTime(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<PermissionCopyMode> get_FilePermissionCopyMode();
    [CompilerGeneratedAttribute]
public void set_FilePermissionCopyMode(Nullable`1<PermissionCopyMode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IgnoreReadOnly();
    [CompilerGeneratedAttribute]
public void set_IgnoreReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SetArchiveAttribute();
    [CompilerGeneratedAttribute]
public void set_SetArchiveAttribute(Nullable`1<bool> value);
}
[CodeGenModelAttribute("CopyStatusType")]
public enum Azure.Storage.Files.Shares.Models.CopyStatus : Enum {
    public int value__;
    public static CopyStatus Pending;
    public static CopyStatus Success;
    public static CopyStatus Aborted;
    public static CopyStatus Failed;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.CopyStatusExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(CopyStatus value);
    [ExtensionAttribute]
public static CopyStatus ToCopyStatus(string value);
}
internal enum Azure.Storage.Files.Shares.Models.DeleteSnapshotsOptionType : Enum {
    public int value__;
    public static DeleteSnapshotsOptionType Include;
    public static DeleteSnapshotsOptionType IncludeLeased;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.DeleteSnapshotsOptionTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(DeleteSnapshotsOptionType value);
    [ExtensionAttribute]
public static DeleteSnapshotsOptionType ToDeleteSnapshotsOptionType(string value);
}
internal class Azure.Storage.Files.Shares.Models.DirectoryItem : object {
    [CompilerGeneratedAttribute]
private StringEncoded <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileId>k__BackingField;
    [CompilerGeneratedAttribute]
private FileProperty <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PermissionKey>k__BackingField;
    public StringEncoded Name { get; }
    public string FileId { get; }
    public FileProperty Properties { get; }
    public string Attributes { get; }
    public string PermissionKey { get; }
    internal DirectoryItem(StringEncoded name);
    internal DirectoryItem(StringEncoded name, string fileId, FileProperty properties, string attributes, string permissionKey);
    [CompilerGeneratedAttribute]
public StringEncoded get_Name();
    [CompilerGeneratedAttribute]
public string get_FileId();
    [CompilerGeneratedAttribute]
public FileProperty get_Properties();
    [CompilerGeneratedAttribute]
public string get_Attributes();
    [CompilerGeneratedAttribute]
public string get_PermissionKey();
    internal static DirectoryItem DeserializeDirectoryItem(XElement element);
}
internal class Azure.Storage.Files.Shares.Models.FileHttpHeaders : object {
    [CompilerGeneratedAttribute]
private string <FileContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileCacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileContentMD5>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileContentDisposition>k__BackingField;
    public string FileContentType { get; public set; }
    public string FileContentEncoding { get; public set; }
    public string FileContentLanguage { get; public set; }
    public string FileCacheControl { get; public set; }
    public Byte[] FileContentMD5 { get; public set; }
    public string FileContentDisposition { get; public set; }
    internal FileHttpHeaders(string fileContentType, string fileContentEncoding, string fileContentLanguage, string fileCacheControl, Byte[] fileContentMD5, string fileContentDisposition);
    [CompilerGeneratedAttribute]
public string get_FileContentType();
    [CompilerGeneratedAttribute]
public void set_FileContentType(string value);
    [CompilerGeneratedAttribute]
public string get_FileContentEncoding();
    [CompilerGeneratedAttribute]
public void set_FileContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_FileContentLanguage();
    [CompilerGeneratedAttribute]
public void set_FileContentLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_FileCacheControl();
    [CompilerGeneratedAttribute]
public void set_FileCacheControl(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_FileContentMD5();
    [CompilerGeneratedAttribute]
public void set_FileContentMD5(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_FileContentDisposition();
    [CompilerGeneratedAttribute]
public void set_FileContentDisposition(string value);
}
internal class Azure.Storage.Files.Shares.Models.FileItem : object {
    [CompilerGeneratedAttribute]
private StringEncoded <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileId>k__BackingField;
    [CompilerGeneratedAttribute]
private FileProperty <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PermissionKey>k__BackingField;
    public StringEncoded Name { get; }
    public string FileId { get; }
    public FileProperty Properties { get; }
    public string Attributes { get; }
    public string PermissionKey { get; }
    internal FileItem(StringEncoded name, FileProperty properties);
    internal FileItem(StringEncoded name, string fileId, FileProperty properties, string attributes, string permissionKey);
    [CompilerGeneratedAttribute]
public StringEncoded get_Name();
    [CompilerGeneratedAttribute]
public string get_FileId();
    [CompilerGeneratedAttribute]
public FileProperty get_Properties();
    [CompilerGeneratedAttribute]
public string get_Attributes();
    [CompilerGeneratedAttribute]
public string get_PermissionKey();
    internal static FileItem DeserializeFileItem(XElement element);
}
public enum Azure.Storage.Files.Shares.Models.FileLastWrittenMode : Enum {
    public int value__;
    public static FileLastWrittenMode Now;
    public static FileLastWrittenMode Preserve;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.FileLastWrittenModeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(FileLastWrittenMode value);
    [ExtensionAttribute]
public static FileLastWrittenMode ToFileLastWrittenMode(string value);
}
public class Azure.Storage.Files.Shares.Models.FileLeaseReleaseInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
}
public static class Azure.Storage.Files.Shares.Models.FileModelFactory : object {
    public static CloseHandlesResult ClosedHandlesInfo(int closedHandlesCount);
    public static CloseHandlesResult ClosedHandlesInfo(int closedHandlesCount, int failedHandlesCount);
}
public enum Azure.Storage.Files.Shares.Models.FilePermissionFormat : Enum {
    public int value__;
    public static FilePermissionFormat Sddl;
    public static FilePermissionFormat Binary;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.FilePermissionFormatExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(FilePermissionFormat value);
    [ExtensionAttribute]
public static FilePermissionFormat ToFilePermissionFormat(string value);
}
internal class Azure.Storage.Files.Shares.Models.FileProperty : object {
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastAccessTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastWriteTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ChangeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Etag>k__BackingField;
    public long ContentLength { get; }
    public Nullable`1<DateTimeOffset> CreationTime { get; }
    public Nullable`1<DateTimeOffset> LastAccessTime { get; }
    public Nullable`1<DateTimeOffset> LastWriteTime { get; }
    public Nullable`1<DateTimeOffset> ChangeTime { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Etag { get; }
    internal FileProperty(long contentLength);
    internal FileProperty(long contentLength, Nullable`1<DateTimeOffset> creationTime, Nullable`1<DateTimeOffset> lastAccessTime, Nullable`1<DateTimeOffset> lastWriteTime, Nullable`1<DateTimeOffset> changeTime, Nullable`1<DateTimeOffset> lastModified, string etag);
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreationTime();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastAccessTime();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastWriteTime();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ChangeTime();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastModified();
    [CompilerGeneratedAttribute]
public string get_Etag();
    internal static FileProperty DeserializeFileProperty(XElement element);
}
internal class Azure.Storage.Files.Shares.Models.FileRange : object {
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private long <End>k__BackingField;
    public long Start { get; }
    public long End { get; }
    internal FileRange(long start, long end);
    [CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
public long get_End();
    internal static FileRange DeserializeFileRange(XElement element);
}
internal class Azure.Storage.Files.Shares.Models.FilesAndDirectoriesListSegment : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DirectoryItem> <DirectoryItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FileItem> <FileItems>k__BackingField;
    public IReadOnlyList`1<DirectoryItem> DirectoryItems { get; }
    public IReadOnlyList`1<FileItem> FileItems { get; }
    internal FilesAndDirectoriesListSegment(IEnumerable`1<DirectoryItem> directoryItems, IEnumerable`1<FileItem> fileItems);
    internal FilesAndDirectoriesListSegment(IReadOnlyList`1<DirectoryItem> directoryItems, IReadOnlyList`1<FileItem> fileItems);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DirectoryItem> get_DirectoryItems();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FileItem> get_FileItems();
    internal static FilesAndDirectoriesListSegment DeserializeFilesAndDirectoriesListSegment(XElement element);
}
public class Azure.Storage.Files.Shares.Models.FileSmbProperties : object {
    [CompilerGeneratedAttribute]
private Nullable`1<NtfsFileAttributes> <FileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePermissionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <FileCreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <FileLastWrittenOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <FileChangedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentId>k__BackingField;
    public Nullable`1<NtfsFileAttributes> FileAttributes { get; public set; }
    public string FilePermissionKey { get; public set; }
    public Nullable`1<DateTimeOffset> FileCreatedOn { get; public set; }
    public Nullable`1<DateTimeOffset> FileLastWrittenOn { get; public set; }
    public Nullable`1<DateTimeOffset> FileChangedOn { get; public set; }
    public string FileId { get; internal set; }
    public string ParentId { get; internal set; }
    [CompilerGeneratedAttribute]
public Nullable`1<NtfsFileAttributes> get_FileAttributes();
    [CompilerGeneratedAttribute]
public void set_FileAttributes(Nullable`1<NtfsFileAttributes> value);
    [CompilerGeneratedAttribute]
public string get_FilePermissionKey();
    [CompilerGeneratedAttribute]
public void set_FilePermissionKey(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_FileCreatedOn();
    [CompilerGeneratedAttribute]
public void set_FileCreatedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_FileLastWrittenOn();
    [CompilerGeneratedAttribute]
public void set_FileLastWrittenOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_FileChangedOn();
    [CompilerGeneratedAttribute]
public void set_FileChangedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_FileId();
    [CompilerGeneratedAttribute]
internal void set_FileId(string value);
    [CompilerGeneratedAttribute]
public string get_ParentId();
    [CompilerGeneratedAttribute]
internal void set_ParentId(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
public static class Azure.Storage.Files.Shares.Models.FilesModelFactory : object {
    public static ShareDirectoryProperties StorageDirectoryProperties(IDictionary`2<string, string> metadata, ETag eTag, DateTimeOffset lastModified, bool isServerEncrypted, string fileAttributes, DateTimeOffset fileCreationTime, DateTimeOffset fileLastWriteTime, DateTimeOffset fileChangeTime, string filePermissionKey, string fileId, string fileParentId);
    public static ShareFileDownloadDetails StorageFileDownloadProperties(DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentType, string contentRange, ETag eTag, IEnumerable`1<string> contentEncoding, string cacheControl, string contentDisposition, IEnumerable`1<string> contentLanguage, string acceptRanges, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, Byte[] fileContentHash, bool isServiceEncrypted);
    public static ShareFileDownloadInfo StorageFileDownloadInfo(DateTimeOffset lastModified, IEnumerable`1<string> contentLanguage, string acceptRanges, DateTimeOffset copyCompletionTime, string copyStatusDescription, string contentDisposition, string copyProgress, Uri copySource, CopyStatus copyStatus, Byte[] fileContentHash, bool isServerEncrypted, string cacheControl, string fileAttributes, IEnumerable`1<string> contentEncoding, DateTimeOffset fileCreationTime, Byte[] contentHash, DateTimeOffset fileLastWriteTime, ETag eTag, DateTimeOffset fileChangeTime, string contentRange, string filePermissionKey, string contentType, string fileId, long contentLength, string fileParentId, IDictionary`2<string, string> metadata, Stream content, string copyId);
    public static ShareFileInfo StorageFileInfo(ETag eTag, DateTimeOffset lastModified, bool isServerEncrypted, string filePermissionKey, string fileAttributes, DateTimeOffset fileCreationTime, DateTimeOffset fileLastWriteTime, DateTimeOffset fileChangeTime, string fileId, string fileParentId);
    public static ShareFileItem ShareFileItem(bool isDirectory, string name, Nullable`1<long> fileSize, string id, ShareFileItemProperties properties, Nullable`1<NtfsFileAttributes> fileAttributes, string permissionKey);
    [EditorBrowsableAttribute("1")]
public static ShareFileItem StorageFileItem(bool isDirectory, string name, Nullable`1<long> fileSize);
    public static ShareFileProperties StorageFileProperties(DateTimeOffset lastModified, IDictionary`2<string, string> metadata, long contentLength, string contentType, ETag eTag, Byte[] contentHash, IEnumerable`1<string> contentEncoding, string cacheControl, string contentDisposition, IEnumerable`1<string> contentLanguage, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, string copySource, CopyStatus copyStatus, bool isServerEncrypted, string fileAttributes, DateTimeOffset fileCreationTime, DateTimeOffset fileLastWriteTime, DateTimeOffset fileChangeTime, string filePermissionKey, string fileId, string fileParentId);
    public static ShareFileProperties StorageFileProperties(DateTimeOffset lastModified, IDictionary`2<string, string> metadata, long contentLength, string contentType, ETag eTag, Byte[] contentHash, IEnumerable`1<string> contentEncoding, string cacheControl, string contentDisposition, IEnumerable`1<string> contentLanguage, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, string copySource, CopyStatus copyStatus, bool isServerEncrypted, NtfsFileAttributes fileAttributes, DateTimeOffset fileCreationTime, DateTimeOffset fileLastWriteTime, DateTimeOffset fileChangeTime, string filePermissionKey, string fileId, string fileParentId);
}
internal class Azure.Storage.Files.Shares.Models.GetDirectoryHandlesAsyncCollection : StorageCollectionEnumerator`1<ShareFileHandle> {
    private ShareDirectoryClient _client;
    private Nullable`1<bool> _recursive;
    public GetDirectoryHandlesAsyncCollection(ShareDirectoryClient client, Nullable`1<bool> recursive);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Models.GetDirectoryHandlesAsyncCollection/<GetNextPageAsync>d__3")]
public virtual ValueTask`1<Page`1<ShareFileHandle>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.Shares.Models.GetFileHandlesAsyncCollection : StorageCollectionEnumerator`1<ShareFileHandle> {
    private ShareFileClient _client;
    public GetFileHandlesAsyncCollection(ShareFileClient client);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Models.GetFileHandlesAsyncCollection/<GetNextPageAsync>d__2")]
public virtual ValueTask`1<Page`1<ShareFileHandle>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.Shares.Models.GetFilesAndDirectoriesAsyncCollection : StorageCollectionEnumerator`1<ShareFileItem> {
    private ShareDirectoryClient _client;
    private string _prefix;
    private Nullable`1<ShareFileTraits> _traits;
    private Nullable`1<bool> _includeExtendedInfo;
    public GetFilesAndDirectoriesAsyncCollection(ShareDirectoryClient client, string prefix, Nullable`1<ShareFileTraits> traits, Nullable`1<bool> includeExtendedInfo);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Models.GetFilesAndDirectoriesAsyncCollection/<GetNextPageAsync>d__5")]
public virtual ValueTask`1<Page`1<ShareFileItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.Shares.Models.GetSharesAsyncCollection : StorageCollectionEnumerator`1<ShareItem> {
    private ShareServiceClient _client;
    private ShareTraits _traits;
    private ShareStates _states;
    private string _prefix;
    public GetSharesAsyncCollection(ShareServiceClient client, ShareTraits traits, ShareStates states, string prefix);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Models.GetSharesAsyncCollection/<GetNextPageAsync>d__5")]
public virtual ValueTask`1<Page`1<ShareItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.Shares.Models.HandleItem : object {
    [CompilerGeneratedAttribute]
private string <HandleId>k__BackingField;
    [CompilerGeneratedAttribute]
private StringEncoded <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientIp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <OpenTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastReconnectTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AccessRight> <AccessRightList>k__BackingField;
    public string HandleId { get; }
    public StringEncoded Path { get; }
    public string FileId { get; }
    public string ParentId { get; }
    public string SessionId { get; }
    public string ClientIp { get; }
    public string ClientName { get; }
    public DateTimeOffset OpenTime { get; }
    public Nullable`1<DateTimeOffset> LastReconnectTime { get; }
    public IReadOnlyList`1<AccessRight> AccessRightList { get; }
    internal HandleItem(string handleId, StringEncoded path, string fileId, string sessionId, string clientIp, string clientName, DateTimeOffset openTime);
    internal HandleItem(string handleId, StringEncoded path, string fileId, string parentId, string sessionId, string clientIp, string clientName, DateTimeOffset openTime, Nullable`1<DateTimeOffset> lastReconnectTime, IReadOnlyList`1<AccessRight> accessRightList);
    [CompilerGeneratedAttribute]
public string get_HandleId();
    [CompilerGeneratedAttribute]
public StringEncoded get_Path();
    [CompilerGeneratedAttribute]
public string get_FileId();
    [CompilerGeneratedAttribute]
public string get_ParentId();
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public string get_ClientIp();
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_OpenTime();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastReconnectTime();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AccessRight> get_AccessRightList();
    internal static HandleItem DeserializeHandleItem(XElement element);
}
internal class Azure.Storage.Files.Shares.Models.ListFilesAndDirectoriesSegmentResponse : object {
    [CompilerGeneratedAttribute]
private string <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShareName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShareSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Encoded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private StringEncoded <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private FilesAndDirectoriesListSegment <Segment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectoryId>k__BackingField;
    public string ServiceEndpoint { get; }
    public string ShareName { get; }
    public string ShareSnapshot { get; }
    public Nullable`1<bool> Encoded { get; }
    public string DirectoryPath { get; }
    public StringEncoded Prefix { get; }
    public string Marker { get; }
    public Nullable`1<int> MaxResults { get; }
    public FilesAndDirectoriesListSegment Segment { get; }
    public string NextMarker { get; }
    public string DirectoryId { get; }
    internal ListFilesAndDirectoriesSegmentResponse(string serviceEndpoint, string shareName, string directoryPath, StringEncoded prefix, FilesAndDirectoriesListSegment segment, string nextMarker);
    internal ListFilesAndDirectoriesSegmentResponse(string serviceEndpoint, string shareName, string shareSnapshot, Nullable`1<bool> encoded, string directoryPath, StringEncoded prefix, string marker, Nullable`1<int> maxResults, FilesAndDirectoriesListSegment segment, string nextMarker, string directoryId);
    [CompilerGeneratedAttribute]
public string get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
public string get_ShareName();
    [CompilerGeneratedAttribute]
public string get_ShareSnapshot();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Encoded();
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
public StringEncoded get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Marker();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxResults();
    [CompilerGeneratedAttribute]
public FilesAndDirectoriesListSegment get_Segment();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    [CompilerGeneratedAttribute]
public string get_DirectoryId();
    internal static ListFilesAndDirectoriesSegmentResponse DeserializeListFilesAndDirectoriesSegmentResponse(XElement element);
}
internal enum Azure.Storage.Files.Shares.Models.ListFilesIncludeType : Enum {
    public int value__;
    public static ListFilesIncludeType Timestamps;
    public static ListFilesIncludeType Etag;
    public static ListFilesIncludeType Attributes;
    public static ListFilesIncludeType PermissionKey;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.ListFilesIncludeTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ListFilesIncludeType value);
    [ExtensionAttribute]
public static ListFilesIncludeType ToListFilesIncludeType(string value);
}
internal class Azure.Storage.Files.Shares.Models.ListHandlesResponse : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<HandleItem> <HandleList>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    public IReadOnlyList`1<HandleItem> HandleList { get; }
    public string NextMarker { get; }
    internal ListHandlesResponse(string nextMarker);
    internal ListHandlesResponse(IReadOnlyList`1<HandleItem> handleList, string nextMarker);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<HandleItem> get_HandleList();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    internal static ListHandlesResponse DeserializeListHandlesResponse(XElement element);
}
internal enum Azure.Storage.Files.Shares.Models.ListSharesIncludeType : Enum {
    public int value__;
    public static ListSharesIncludeType Snapshots;
    public static ListSharesIncludeType Metadata;
    public static ListSharesIncludeType Deleted;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.ListSharesIncludeTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ListSharesIncludeType value);
    [ExtensionAttribute]
public static ListSharesIncludeType ToListSharesIncludeType(string value);
}
internal class Azure.Storage.Files.Shares.Models.ListSharesResponse : object {
    [CompilerGeneratedAttribute]
private string <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ShareItemInternal> <ShareItems>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    public string ServiceEndpoint { get; }
    public string Prefix { get; }
    public string Marker { get; }
    public Nullable`1<int> MaxResults { get; }
    public IReadOnlyList`1<ShareItemInternal> ShareItems { get; }
    public string NextMarker { get; }
    internal ListSharesResponse(string serviceEndpoint, string nextMarker);
    internal ListSharesResponse(string serviceEndpoint, string prefix, string marker, Nullable`1<int> maxResults, IReadOnlyList`1<ShareItemInternal> shareItems, string nextMarker);
    [CompilerGeneratedAttribute]
public string get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Marker();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxResults();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ShareItemInternal> get_ShareItems();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    internal static ListSharesResponse DeserializeListSharesResponse(XElement element);
}
[FlagsAttribute]
public enum Azure.Storage.Files.Shares.Models.NtfsFileAttributes : Enum {
    public int value__;
    public static NtfsFileAttributes ReadOnly;
    public static NtfsFileAttributes Hidden;
    public static NtfsFileAttributes System;
    public static NtfsFileAttributes None;
    public static NtfsFileAttributes Directory;
    public static NtfsFileAttributes Archive;
    public static NtfsFileAttributes Temporary;
    public static NtfsFileAttributes Offline;
    public static NtfsFileAttributes NotContentIndexed;
    public static NtfsFileAttributes NoScrubData;
}
[CodeGenModelAttribute("PermissionCopyModeType")]
public enum Azure.Storage.Files.Shares.Models.PermissionCopyMode : Enum {
    public int value__;
    public static PermissionCopyMode Source;
    public static PermissionCopyMode Override;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.PermissionCopyModeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(PermissionCopyMode value);
    [ExtensionAttribute]
public static PermissionCopyMode ToPermissionCopyMode(string value);
}
public class Azure.Storage.Files.Shares.Models.PermissionInfo : object {
    [CompilerGeneratedAttribute]
private string <FilePermissionKey>k__BackingField;
    public string FilePermissionKey { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_FilePermissionKey();
    [CompilerGeneratedAttribute]
internal void set_FilePermissionKey(string value);
}
[CodeGenModelAttribute("AccessPolicy")]
public class Azure.Storage.Files.Shares.Models.ShareAccessPolicy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <PolicyStartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <PolicyExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CodeGenMemberAttribute("Start")]
public Nullable`1<DateTimeOffset> PolicyStartsOn { get; public set; }
    [CodeGenMemberAttribute("Expiry")]
public Nullable`1<DateTimeOffset> PolicyExpiresOn { get; public set; }
    [CodeGenMemberAttribute("Permission")]
public string Permissions { get; public set; }
    [EditorBrowsableAttribute("1")]
public DateTimeOffset StartsOn { get; public set; }
    [EditorBrowsableAttribute("1")]
public DateTimeOffset ExpiresOn { get; public set; }
    internal ShareAccessPolicy(Nullable`1<DateTimeOffset> policyStartsOn, Nullable`1<DateTimeOffset> policyExpiresOn, string permissions);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static ShareAccessPolicy DeserializeShareAccessPolicy(XElement element);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_PolicyStartsOn();
    [CompilerGeneratedAttribute]
public void set_PolicyStartsOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_PolicyExpiresOn();
    [CompilerGeneratedAttribute]
public void set_PolicyExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(string value);
    public DateTimeOffset get_StartsOn();
    public void set_StartsOn(DateTimeOffset value);
    public DateTimeOffset get_ExpiresOn();
    public void set_ExpiresOn(DateTimeOffset value);
}
[IsReadOnlyAttribute]
public class Azure.Storage.Files.Shares.Models.ShareAccessTier : ValueType {
    private string _value;
    private static string TransactionOptimizedValue;
    private static string HotValue;
    private static string CoolValue;
    [CompilerGeneratedAttribute]
private static ShareAccessTier <TransactionOptimized>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareAccessTier <Hot>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareAccessTier <Cool>k__BackingField;
    public static ShareAccessTier TransactionOptimized { get; }
    public static ShareAccessTier Hot { get; }
    public static ShareAccessTier Cool { get; }
    public ShareAccessTier(string value);
    private static ShareAccessTier();
    [CompilerGeneratedAttribute]
public static ShareAccessTier get_TransactionOptimized();
    [CompilerGeneratedAttribute]
public static ShareAccessTier get_Hot();
    [CompilerGeneratedAttribute]
public static ShareAccessTier get_Cool();
    public static bool op_Equality(ShareAccessTier left, ShareAccessTier right);
    public static bool op_Inequality(ShareAccessTier left, ShareAccessTier right);
    public static ShareAccessTier op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ShareAccessTier other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class Azure.Storage.Files.Shares.Models.ShareAudience : ValueType {
    private string _value;
    private static string _defaultAudience;
    [CompilerGeneratedAttribute]
private static ShareAudience <DefaultAudience>k__BackingField;
    public static ShareAudience DefaultAudience { get; }
    public ShareAudience(string value);
    private static ShareAudience();
    [CompilerGeneratedAttribute]
public static ShareAudience get_DefaultAudience();
    public static ShareAudience CreateShareServiceAccountAudience(string storageAccountName);
    public static bool op_Equality(ShareAudience left, ShareAudience right);
    public static bool op_Inequality(ShareAudience left, ShareAudience right);
    public static ShareAudience op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ShareAudience other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    internal string CreateDefaultScope();
}
[CodeGenModelAttribute("CorsRule")]
public class Azure.Storage.Files.Shares.Models.ShareCorsRule : object {
    [CompilerGeneratedAttribute]
private string <AllowedOrigins>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowedHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExposedHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAgeInSeconds>k__BackingField;
    public string AllowedOrigins { get; public set; }
    public string AllowedMethods { get; public set; }
    public string AllowedHeaders { get; public set; }
    public string ExposedHeaders { get; public set; }
    public int MaxAgeInSeconds { get; public set; }
    internal ShareCorsRule(string allowedOrigins, string allowedMethods, string allowedHeaders, string exposedHeaders, int maxAgeInSeconds);
    [CompilerGeneratedAttribute]
public string get_AllowedOrigins();
    [CompilerGeneratedAttribute]
public void set_AllowedOrigins(string value);
    [CompilerGeneratedAttribute]
public string get_AllowedMethods();
    [CompilerGeneratedAttribute]
public void set_AllowedMethods(string value);
    [CompilerGeneratedAttribute]
public string get_AllowedHeaders();
    [CompilerGeneratedAttribute]
public void set_AllowedHeaders(string value);
    [CompilerGeneratedAttribute]
public string get_ExposedHeaders();
    [CompilerGeneratedAttribute]
public void set_ExposedHeaders(string value);
    [CompilerGeneratedAttribute]
public int get_MaxAgeInSeconds();
    [CompilerGeneratedAttribute]
public void set_MaxAgeInSeconds(int value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static ShareCorsRule DeserializeShareCorsRule(XElement element);
}
public class Azure.Storage.Files.Shares.Models.ShareCreateOptions : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <QuotaInGB>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareAccessTier> <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareProtocols> <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareRootSquash> <RootSquash>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableSnapshotVirtualDirectoryAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnablePaidBursting>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PaidBurstingMaxIops>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PaidBurstingMaxBandwidthMibps>k__BackingField;
    public IDictionary`2<string, string> Metadata { get; public set; }
    public Nullable`1<int> QuotaInGB { get; public set; }
    public Nullable`1<ShareAccessTier> AccessTier { get; public set; }
    public Nullable`1<ShareProtocols> Protocols { get; public set; }
    public Nullable`1<ShareRootSquash> RootSquash { get; public set; }
    public Nullable`1<bool> EnableSnapshotVirtualDirectoryAccess { get; public set; }
    public Nullable`1<bool> EnablePaidBursting { get; public set; }
    public Nullable`1<long> PaidBurstingMaxIops { get; public set; }
    public Nullable`1<long> PaidBurstingMaxBandwidthMibps { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_QuotaInGB();
    [CompilerGeneratedAttribute]
public void set_QuotaInGB(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareAccessTier> get_AccessTier();
    [CompilerGeneratedAttribute]
public void set_AccessTier(Nullable`1<ShareAccessTier> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareProtocols> get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(Nullable`1<ShareProtocols> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareRootSquash> get_RootSquash();
    [CompilerGeneratedAttribute]
public void set_RootSquash(Nullable`1<ShareRootSquash> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableSnapshotVirtualDirectoryAccess();
    [CompilerGeneratedAttribute]
public void set_EnableSnapshotVirtualDirectoryAccess(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnablePaidBursting();
    [CompilerGeneratedAttribute]
public void set_EnablePaidBursting(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_PaidBurstingMaxIops();
    [CompilerGeneratedAttribute]
public void set_PaidBurstingMaxIops(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_PaidBurstingMaxBandwidthMibps();
    [CompilerGeneratedAttribute]
public void set_PaidBurstingMaxBandwidthMibps(Nullable`1<long> value);
}
public class Azure.Storage.Files.Shares.Models.ShareDeleteOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<ShareSnapshotsDeleteOption> <ShareSnapshotsDeleteOption>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    public Nullable`1<ShareSnapshotsDeleteOption> ShareSnapshotsDeleteOption { get; public set; }
    public ShareFileRequestConditions Conditions { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<ShareSnapshotsDeleteOption> get_ShareSnapshotsDeleteOption();
    [CompilerGeneratedAttribute]
public void set_ShareSnapshotsDeleteOption(Nullable`1<ShareSnapshotsDeleteOption> value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
}
public class Azure.Storage.Files.Shares.Models.ShareDirectoryCreateOptions : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFilePermission <FilePermission>k__BackingField;
    public IDictionary`2<string, string> Metadata { get; public set; }
    public FileSmbProperties SmbProperties { get; public set; }
    public ShareFilePermission FilePermission { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
    [CompilerGeneratedAttribute]
public ShareFilePermission get_FilePermission();
    [CompilerGeneratedAttribute]
public void set_FilePermission(ShareFilePermission value);
}
public class Azure.Storage.Files.Shares.Models.ShareDirectoryGetFilesAndDirectoriesOptions : object {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileTraits <Traits>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeExtendedInfo>k__BackingField;
    public string Prefix { get; public set; }
    public ShareFileTraits Traits { get; public set; }
    public Nullable`1<bool> IncludeExtendedInfo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public ShareFileTraits get_Traits();
    [CompilerGeneratedAttribute]
public void set_Traits(ShareFileTraits value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeExtendedInfo();
    [CompilerGeneratedAttribute]
public void set_IncludeExtendedInfo(Nullable`1<bool> value);
}
public class Azure.Storage.Files.Shares.Models.ShareDirectoryInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public FileSmbProperties SmbProperties { get; public set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
}
public class Azure.Storage.Files.Shares.Models.ShareDirectoryProperties : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    public FileSmbProperties SmbProperties { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
}
public class Azure.Storage.Files.Shares.Models.ShareDirectorySetHttpHeadersOptions : object {
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFilePermission <FilePermission>k__BackingField;
    public FileSmbProperties SmbProperties { get; public set; }
    public ShareFilePermission FilePermission { get; public set; }
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
    [CompilerGeneratedAttribute]
public ShareFilePermission get_FilePermission();
    [CompilerGeneratedAttribute]
public void set_FilePermission(ShareFilePermission value);
}
[IsReadOnlyAttribute]
public class Azure.Storage.Files.Shares.Models.ShareErrorCode : ValueType {
    private string _value;
    private static string AccountAlreadyExistsValue;
    private static string AccountBeingCreatedValue;
    private static string AccountIsDisabledValue;
    private static string AuthenticationFailedValue;
    private static string AuthorizationFailureValue;
    private static string ConditionHeadersNotSupportedValue;
    private static string ConditionNotMetValue;
    private static string EmptyMetadataKeyValue;
    private static string InsufficientAccountPermissionsValue;
    private static string InternalErrorValue;
    private static string InvalidAuthenticationInfoValue;
    private static string InvalidHeaderValueValue;
    private static string InvalidHttpVerbValue;
    private static string InvalidInputValue;
    private static string InvalidMd5Value;
    private static string InvalidMetadataValue;
    private static string InvalidQueryParameterValueValue;
    private static string InvalidRangeValue;
    private static string InvalidResourceNameValue;
    private static string InvalidUriValue;
    private static string InvalidXmlDocumentValue;
    private static string InvalidXmlNodeValueValue;
    private static string Md5MismatchValue;
    private static string MetadataTooLargeValue;
    private static string MissingContentLengthHeaderValue;
    private static string MissingRequiredQueryParameterValue;
    private static string MissingRequiredHeaderValue;
    private static string MissingRequiredXmlNodeValue;
    private static string MultipleConditionHeadersNotSupportedValue;
    private static string OperationTimedOutValue;
    private static string OutOfRangeInputValue;
    private static string OutOfRangeQueryParameterValueValue;
    private static string RequestBodyTooLargeValue;
    private static string ResourceTypeMismatchValue;
    private static string RequestUrlFailedToParseValue;
    private static string ResourceAlreadyExistsValue;
    private static string ResourceNotFoundValue;
    private static string ServerBusyValue;
    private static string UnsupportedHeaderValue;
    private static string UnsupportedXmlNodeValue;
    private static string UnsupportedQueryParameterValue;
    private static string UnsupportedHttpVerbValue;
    private static string CannotDeleteFileOrDirectoryValue;
    private static string ClientCacheFlushDelayValue;
    private static string DeletePendingValue;
    private static string DirectoryNotEmptyValue;
    private static string FileLockConflictValue;
    private static string InvalidFileOrDirectoryPathNameValue;
    private static string ParentNotFoundValue;
    private static string ReadOnlyAttributeValue;
    private static string ShareAlreadyExistsValue;
    private static string ShareBeingDeletedValue;
    private static string ShareDisabledValue;
    private static string ShareNotFoundValue;
    private static string SharingViolationValue;
    private static string ShareSnapshotInProgressValue;
    private static string ShareSnapshotCountExceededValue;
    private static string ShareSnapshotOperationNotSupportedValue;
    private static string ShareHasSnapshotsValue;
    private static string PreviousSnapshotNotFoundValue;
    private static string ContainerQuotaDowngradeNotAllowedValue;
    private static string AuthorizationSourceIPMismatchValue;
    private static string AuthorizationProtocolMismatchValue;
    private static string AuthorizationPermissionMismatchValue;
    private static string AuthorizationServiceMismatchValue;
    private static string AuthorizationResourceTypeMismatchValue;
    private static string FeatureVersionMismatchValue;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AccountAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AccountBeingCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AccountIsDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AuthenticationFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AuthorizationFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ConditionHeadersNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ConditionNotMet>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <EmptyMetadataKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InsufficientAccountPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InternalError>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidAuthenticationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidHeaderValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidHttpVerb>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidInput>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidMd5>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidQueryParameterValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidRange>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidUri>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidXmlDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidXmlNodeValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <Md5Mismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <MetadataTooLarge>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <MissingContentLengthHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <MissingRequiredQueryParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <MissingRequiredHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <MissingRequiredXmlNode>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <MultipleConditionHeadersNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <OperationTimedOut>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <OutOfRangeInput>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <OutOfRangeQueryParameterValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <RequestBodyTooLarge>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ResourceTypeMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <RequestUrlFailedToParse>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ResourceAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ResourceNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ServerBusy>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <UnsupportedHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <UnsupportedXmlNode>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <UnsupportedQueryParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <UnsupportedHttpVerb>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <CannotDeleteFileOrDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ClientCacheFlushDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <DeletePending>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <DirectoryNotEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <FileLockConflict>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <InvalidFileOrDirectoryPathName>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ParentNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ReadOnlyAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ShareAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ShareBeingDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ShareDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ShareNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <SharingViolation>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ShareSnapshotInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ShareSnapshotCountExceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ShareSnapshotOperationNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ShareHasSnapshots>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <PreviousSnapshotNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <ContainerQuotaDowngradeNotAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AuthorizationSourceIPMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AuthorizationProtocolMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AuthorizationPermissionMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AuthorizationServiceMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <AuthorizationResourceTypeMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static ShareErrorCode <FeatureVersionMismatch>k__BackingField;
    public static ShareErrorCode AccountAlreadyExists { get; }
    public static ShareErrorCode AccountBeingCreated { get; }
    public static ShareErrorCode AccountIsDisabled { get; }
    public static ShareErrorCode AuthenticationFailed { get; }
    public static ShareErrorCode AuthorizationFailure { get; }
    public static ShareErrorCode ConditionHeadersNotSupported { get; }
    public static ShareErrorCode ConditionNotMet { get; }
    public static ShareErrorCode EmptyMetadataKey { get; }
    public static ShareErrorCode InsufficientAccountPermissions { get; }
    public static ShareErrorCode InternalError { get; }
    public static ShareErrorCode InvalidAuthenticationInfo { get; }
    public static ShareErrorCode InvalidHeaderValue { get; }
    public static ShareErrorCode InvalidHttpVerb { get; }
    public static ShareErrorCode InvalidInput { get; }
    public static ShareErrorCode InvalidMd5 { get; }
    public static ShareErrorCode InvalidMetadata { get; }
    public static ShareErrorCode InvalidQueryParameterValue { get; }
    public static ShareErrorCode InvalidRange { get; }
    public static ShareErrorCode InvalidResourceName { get; }
    public static ShareErrorCode InvalidUri { get; }
    public static ShareErrorCode InvalidXmlDocument { get; }
    public static ShareErrorCode InvalidXmlNodeValue { get; }
    public static ShareErrorCode Md5Mismatch { get; }
    public static ShareErrorCode MetadataTooLarge { get; }
    public static ShareErrorCode MissingContentLengthHeader { get; }
    public static ShareErrorCode MissingRequiredQueryParameter { get; }
    public static ShareErrorCode MissingRequiredHeader { get; }
    public static ShareErrorCode MissingRequiredXmlNode { get; }
    public static ShareErrorCode MultipleConditionHeadersNotSupported { get; }
    public static ShareErrorCode OperationTimedOut { get; }
    public static ShareErrorCode OutOfRangeInput { get; }
    public static ShareErrorCode OutOfRangeQueryParameterValue { get; }
    public static ShareErrorCode RequestBodyTooLarge { get; }
    public static ShareErrorCode ResourceTypeMismatch { get; }
    public static ShareErrorCode RequestUrlFailedToParse { get; }
    public static ShareErrorCode ResourceAlreadyExists { get; }
    public static ShareErrorCode ResourceNotFound { get; }
    public static ShareErrorCode ServerBusy { get; }
    public static ShareErrorCode UnsupportedHeader { get; }
    public static ShareErrorCode UnsupportedXmlNode { get; }
    public static ShareErrorCode UnsupportedQueryParameter { get; }
    public static ShareErrorCode UnsupportedHttpVerb { get; }
    public static ShareErrorCode CannotDeleteFileOrDirectory { get; }
    public static ShareErrorCode ClientCacheFlushDelay { get; }
    public static ShareErrorCode DeletePending { get; }
    public static ShareErrorCode DirectoryNotEmpty { get; }
    public static ShareErrorCode FileLockConflict { get; }
    public static ShareErrorCode InvalidFileOrDirectoryPathName { get; }
    public static ShareErrorCode ParentNotFound { get; }
    public static ShareErrorCode ReadOnlyAttribute { get; }
    public static ShareErrorCode ShareAlreadyExists { get; }
    public static ShareErrorCode ShareBeingDeleted { get; }
    public static ShareErrorCode ShareDisabled { get; }
    public static ShareErrorCode ShareNotFound { get; }
    public static ShareErrorCode SharingViolation { get; }
    public static ShareErrorCode ShareSnapshotInProgress { get; }
    public static ShareErrorCode ShareSnapshotCountExceeded { get; }
    public static ShareErrorCode ShareSnapshotOperationNotSupported { get; }
    public static ShareErrorCode ShareHasSnapshots { get; }
    public static ShareErrorCode PreviousSnapshotNotFound { get; }
    public static ShareErrorCode ContainerQuotaDowngradeNotAllowed { get; }
    public static ShareErrorCode AuthorizationSourceIPMismatch { get; }
    public static ShareErrorCode AuthorizationProtocolMismatch { get; }
    public static ShareErrorCode AuthorizationPermissionMismatch { get; }
    public static ShareErrorCode AuthorizationServiceMismatch { get; }
    public static ShareErrorCode AuthorizationResourceTypeMismatch { get; }
    public static ShareErrorCode FeatureVersionMismatch { get; }
    public ShareErrorCode(string value);
    private static ShareErrorCode();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AccountAlreadyExists();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AccountBeingCreated();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AccountIsDisabled();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AuthenticationFailed();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AuthorizationFailure();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ConditionHeadersNotSupported();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ConditionNotMet();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_EmptyMetadataKey();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InsufficientAccountPermissions();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InternalError();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidAuthenticationInfo();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidHeaderValue();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidHttpVerb();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidInput();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidMd5();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidMetadata();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidQueryParameterValue();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidRange();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidResourceName();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidUri();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidXmlDocument();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidXmlNodeValue();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_Md5Mismatch();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_MetadataTooLarge();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_MissingContentLengthHeader();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_MissingRequiredQueryParameter();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_MissingRequiredHeader();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_MissingRequiredXmlNode();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_MultipleConditionHeadersNotSupported();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_OperationTimedOut();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_OutOfRangeInput();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_OutOfRangeQueryParameterValue();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_RequestBodyTooLarge();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ResourceTypeMismatch();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_RequestUrlFailedToParse();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ResourceAlreadyExists();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ResourceNotFound();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ServerBusy();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_UnsupportedHeader();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_UnsupportedXmlNode();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_UnsupportedQueryParameter();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_UnsupportedHttpVerb();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_CannotDeleteFileOrDirectory();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ClientCacheFlushDelay();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_DeletePending();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_DirectoryNotEmpty();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_FileLockConflict();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_InvalidFileOrDirectoryPathName();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ParentNotFound();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ReadOnlyAttribute();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ShareAlreadyExists();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ShareBeingDeleted();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ShareDisabled();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ShareNotFound();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_SharingViolation();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ShareSnapshotInProgress();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ShareSnapshotCountExceeded();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ShareSnapshotOperationNotSupported();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ShareHasSnapshots();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_PreviousSnapshotNotFound();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_ContainerQuotaDowngradeNotAllowed();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AuthorizationSourceIPMismatch();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AuthorizationProtocolMismatch();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AuthorizationPermissionMismatch();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AuthorizationServiceMismatch();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_AuthorizationResourceTypeMismatch();
    [CompilerGeneratedAttribute]
public static ShareErrorCode get_FeatureVersionMismatch();
    public static bool op_Equality(ShareErrorCode left, ShareErrorCode right);
    public static bool op_Inequality(ShareErrorCode left, ShareErrorCode right);
    public static ShareErrorCode op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ShareErrorCode other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(ShareErrorCode code, string value);
    public static bool op_Inequality(ShareErrorCode code, string value);
    public static bool op_Equality(string value, ShareErrorCode code);
    public static bool op_Inequality(string value, ShareErrorCode code);
    public bool Equals(string value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileCopyInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyStatus <CopyStatus>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public string CopyId { get; internal set; }
    public CopyStatus CopyStatus { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
internal void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public CopyStatus get_CopyStatus();
    [CompilerGeneratedAttribute]
internal void set_CopyStatus(CopyStatus value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileCopyOptions : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePermission>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PermissionCopyMode> <FilePermissionCopyMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IgnoreReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Archive>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyableFileSmbProperties <SmbPropertiesToCopy>k__BackingField;
    public IDictionary`2<string, string> Metadata { get; public set; }
    public FileSmbProperties SmbProperties { get; public set; }
    public string FilePermission { get; public set; }
    public Nullable`1<PermissionCopyMode> FilePermissionCopyMode { get; public set; }
    public Nullable`1<bool> IgnoreReadOnly { get; public set; }
    public Nullable`1<bool> Archive { get; public set; }
    public ShareFileRequestConditions Conditions { get; public set; }
    public CopyableFileSmbProperties SmbPropertiesToCopy { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
    [CompilerGeneratedAttribute]
public string get_FilePermission();
    [CompilerGeneratedAttribute]
public void set_FilePermission(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<PermissionCopyMode> get_FilePermissionCopyMode();
    [CompilerGeneratedAttribute]
public void set_FilePermissionCopyMode(Nullable`1<PermissionCopyMode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IgnoreReadOnly();
    [CompilerGeneratedAttribute]
public void set_IgnoreReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Archive();
    [CompilerGeneratedAttribute]
public void set_Archive(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public CopyableFileSmbProperties get_SmbPropertiesToCopy();
    [CompilerGeneratedAttribute]
public void set_SmbPropertiesToCopy(CopyableFileSmbProperties value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileCreateOptions : object {
    [CompilerGeneratedAttribute]
private ShareFileHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFilePermission <FilePermission>k__BackingField;
    public ShareFileHttpHeaders HttpHeaders { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public FileSmbProperties SmbProperties { get; public set; }
    public ShareFilePermission FilePermission { get; public set; }
    [CompilerGeneratedAttribute]
public ShareFileHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(ShareFileHttpHeaders value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
    [CompilerGeneratedAttribute]
public ShareFilePermission get_FilePermission();
    [CompilerGeneratedAttribute]
public void set_FilePermission(ShareFilePermission value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileDownloadDetails : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentRange>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AcceptRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CopyCompletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyStatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyStatus <CopyStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareLeaseDuration <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareLeaseState <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareLeaseStatus <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    public DateTimeOffset LastModified { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public string ContentRange { get; internal set; }
    public ETag ETag { get; internal set; }
    public IEnumerable`1<string> ContentEncoding { get; internal set; }
    public string CacheControl { get; internal set; }
    public string ContentDisposition { get; internal set; }
    public IEnumerable`1<string> ContentLanguage { get; internal set; }
    public string AcceptRanges { get; internal set; }
    public DateTimeOffset CopyCompletedOn { get; internal set; }
    public string CopyStatusDescription { get; internal set; }
    public string CopyId { get; internal set; }
    public string CopyProgress { get; internal set; }
    public Uri CopySource { get; internal set; }
    public CopyStatus CopyStatus { get; internal set; }
    public Byte[] FileContentHash { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    public ShareLeaseDuration LeaseDuration { get; internal set; }
    public ShareLeaseState LeaseState { get; internal set; }
    public ShareLeaseStatus LeaseStatus { get; internal set; }
    public FileSmbProperties SmbProperties { get; public set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ContentRange();
    [CompilerGeneratedAttribute]
internal void set_ContentRange(string value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ContentEncoding();
    [CompilerGeneratedAttribute]
internal void set_ContentEncoding(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
internal void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
internal void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ContentLanguage();
    [CompilerGeneratedAttribute]
internal void set_ContentLanguage(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_AcceptRanges();
    [CompilerGeneratedAttribute]
internal void set_AcceptRanges(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CopyCompletedOn();
    [CompilerGeneratedAttribute]
internal void set_CopyCompletedOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_CopyStatusDescription();
    [CompilerGeneratedAttribute]
internal void set_CopyStatusDescription(string value);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
internal void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public string get_CopyProgress();
    [CompilerGeneratedAttribute]
internal void set_CopyProgress(string value);
    [CompilerGeneratedAttribute]
public Uri get_CopySource();
    [CompilerGeneratedAttribute]
internal void set_CopySource(Uri value);
    [CompilerGeneratedAttribute]
public CopyStatus get_CopyStatus();
    [CompilerGeneratedAttribute]
internal void set_CopyStatus(CopyStatus value);
    [CompilerGeneratedAttribute]
public Byte[] get_FileContentHash();
    [CompilerGeneratedAttribute]
internal void set_FileContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
    [CompilerGeneratedAttribute]
public ShareLeaseDuration get_LeaseDuration();
    [CompilerGeneratedAttribute]
internal void set_LeaseDuration(ShareLeaseDuration value);
    [CompilerGeneratedAttribute]
public ShareLeaseState get_LeaseState();
    [CompilerGeneratedAttribute]
internal void set_LeaseState(ShareLeaseState value);
    [CompilerGeneratedAttribute]
public ShareLeaseStatus get_LeaseStatus();
    [CompilerGeneratedAttribute]
internal void set_LeaseStatus(ShareLeaseStatus value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileDownloadInfo : object {
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileDownloadDetails <Details>k__BackingField;
    public long ContentLength { get; internal set; }
    public Stream Content { get; internal set; }
    public string ContentType { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public ShareFileDownloadDetails Details { get; internal set; }
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
internal void set_ContentLength(long value);
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_Content();
    [CompilerGeneratedAttribute]
internal void set_Content(Stream value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public ShareFileDownloadDetails get_Details();
    [CompilerGeneratedAttribute]
internal void set_Details(ShareFileDownloadDetails value);
    public sealed virtual void Dispose();
}
public class Azure.Storage.Files.Shares.Models.ShareFileDownloadOptions : object {
    [CompilerGeneratedAttribute]
private HttpRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private DownloadTransferValidationOptions <TransferValidation>k__BackingField;
    public HttpRange Range { get; public set; }
    public ShareFileRequestConditions Conditions { get; public set; }
    public DownloadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public HttpRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(HttpRange value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public DownloadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(DownloadTransferValidationOptions value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileGetRangeListDiffOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<HttpRange> <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreviousSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeRenames>k__BackingField;
    public Nullable`1<HttpRange> Range { get; public set; }
    public string Snapshot { get; public set; }
    public ShareFileRequestConditions Conditions { get; public set; }
    public string PreviousSnapshot { get; public set; }
    public Nullable`1<bool> IncludeRenames { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<HttpRange> get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(Nullable`1<HttpRange> value);
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
public void set_Snapshot(string value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public string get_PreviousSnapshot();
    [CompilerGeneratedAttribute]
public void set_PreviousSnapshot(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeRenames();
    [CompilerGeneratedAttribute]
public void set_IncludeRenames(Nullable`1<bool> value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileGetRangeListOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<HttpRange> <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    public Nullable`1<HttpRange> Range { get; public set; }
    public string Snapshot { get; public set; }
    public ShareFileRequestConditions Conditions { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<HttpRange> get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(Nullable`1<HttpRange> value);
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
public void set_Snapshot(string value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileHandle : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <OpenedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastReconnectedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HandleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientIp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareFileHandleAccessRights> <AccessRights>k__BackingField;
    public Nullable`1<DateTimeOffset> OpenedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> LastReconnectedOn { get; internal set; }
    public string HandleId { get; }
    public string Path { get; }
    public string FileId { get; }
    public string ParentId { get; }
    public string SessionId { get; }
    public string ClientIp { get; }
    public string ClientName { get; }
    public Nullable`1<ShareFileHandleAccessRights> AccessRights { get; }
    internal ShareFileHandle(string handleId, string path, string fileId, string parentId, string sessionId, string clientIp, string clientName, Nullable`1<DateTimeOffset> openedOn, Nullable`1<DateTimeOffset> lastReconnectedOn, Nullable`1<ShareFileHandleAccessRights> accessRights);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_OpenedOn();
    [CompilerGeneratedAttribute]
internal void set_OpenedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastReconnectedOn();
    [CompilerGeneratedAttribute]
internal void set_LastReconnectedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_HandleId();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_FileId();
    [CompilerGeneratedAttribute]
public string get_ParentId();
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public string get_ClientIp();
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public Nullable`1<ShareFileHandleAccessRights> get_AccessRights();
}
[FlagsAttribute]
public enum Azure.Storage.Files.Shares.Models.ShareFileHandleAccessRights : Enum {
    public int value__;
    public static ShareFileHandleAccessRights None;
    public static ShareFileHandleAccessRights Read;
    public static ShareFileHandleAccessRights Write;
    public static ShareFileHandleAccessRights Delete;
}
[CodeGenModelAttribute("ShareFileHandle")]
internal class Azure.Storage.Files.Shares.Models.ShareFileHandleInternal : object {
}
public class Azure.Storage.Files.Shares.Models.ShareFileHttpHeaders : object {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    public string ContentType { get; public set; }
    public Byte[] ContentHash { get; public set; }
    public String[] ContentEncoding { get; public set; }
    public String[] ContentLanguage { get; public set; }
    public string ContentDisposition { get; public set; }
    public string CacheControl { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public String[] get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_ContentLanguage();
    [CompilerGeneratedAttribute]
public void set_ContentLanguage(String[] value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public void set_CacheControl(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
public class Azure.Storage.Files.Shares.Models.ShareFileInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    public FileSmbProperties SmbProperties { get; public set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileItem : object {
    [CompilerGeneratedAttribute]
private bool <IsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileItemProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NtfsFileAttributes> <FileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PermissionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <FileSize>k__BackingField;
    public bool IsDirectory { get; }
    public string Name { get; }
    public string Id { get; }
    public ShareFileItemProperties Properties { get; }
    public Nullable`1<NtfsFileAttributes> FileAttributes { get; }
    public string PermissionKey { get; }
    public Nullable`1<long> FileSize { get; }
    internal ShareFileItem(bool isDirectory, string name, string id, ShareFileItemProperties properties, Nullable`1<NtfsFileAttributes> fileAttributes, string permissionKey, Nullable`1<long> fileSize);
    [CompilerGeneratedAttribute]
public bool get_IsDirectory();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public ShareFileItemProperties get_Properties();
    [CompilerGeneratedAttribute]
public Nullable`1<NtfsFileAttributes> get_FileAttributes();
    [CompilerGeneratedAttribute]
public string get_PermissionKey();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_FileSize();
}
public class Azure.Storage.Files.Shares.Models.ShareFileItemProperties : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastAccessedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastWrittenOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ChangedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ETag> <ETag>k__BackingField;
    public Nullable`1<DateTimeOffset> CreatedOn { get; }
    public Nullable`1<DateTimeOffset> LastAccessedOn { get; }
    public Nullable`1<DateTimeOffset> LastWrittenOn { get; }
    public Nullable`1<DateTimeOffset> ChangedOn { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<ETag> ETag { get; }
    internal ShareFileItemProperties(Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> lastAccessedOn, Nullable`1<DateTimeOffset> lastWrittenOn, Nullable`1<DateTimeOffset> changedOn, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ETag> eTag);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreatedOn();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastAccessedOn();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastWrittenOn();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ChangedOn();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastModified();
    [CompilerGeneratedAttribute]
public Nullable`1<ETag> get_ETag();
}
public class Azure.Storage.Files.Shares.Models.ShareFileLease : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LeaseTime>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public string LeaseId { get; internal set; }
    public Nullable`1<int> LeaseTime { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_LeaseId();
    [CompilerGeneratedAttribute]
internal void set_LeaseId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LeaseTime();
    [CompilerGeneratedAttribute]
internal void set_LeaseTime(Nullable`1<int> value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileModifiedException : Exception {
    [CompilerGeneratedAttribute]
private Uri <ResourceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ExpectedETag>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ActualETag>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpRange <Range>k__BackingField;
    public Uri ResourceUri { get; }
    public ETag ExpectedETag { get; }
    public ETag ActualETag { get; }
    public HttpRange Range { get; }
    public ShareFileModifiedException(string message, Uri resourceUri, ETag expectedETag, ETag actualETag, HttpRange range);
    protected ShareFileModifiedException(SerializationInfo info, StreamingContext streamingContext);
    [CompilerGeneratedAttribute]
public Uri get_ResourceUri();
    [CompilerGeneratedAttribute]
public ETag get_ExpectedETag();
    [CompilerGeneratedAttribute]
public ETag get_ActualETag();
    [CompilerGeneratedAttribute]
public HttpRange get_Range();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Azure.Storage.Files.Shares.Models.ShareFileOpenReadOptions : object {
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private DownloadTransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowModifications>k__BackingField;
    public long Position { get; public set; }
    public Nullable`1<int> BufferSize { get; public set; }
    public ShareFileRequestConditions Conditions { get; public set; }
    public DownloadTransferValidationOptions TransferValidation { get; public set; }
    internal bool AllowModifications { get; }
    public ShareFileOpenReadOptions(bool allowModifications);
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public DownloadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(DownloadTransferValidationOptions value);
    [CompilerGeneratedAttribute]
internal bool get_AllowModifications();
}
public class Azure.Storage.Files.Shares.Models.ShareFileOpenWriteOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <OpenConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public Nullable`1<long> BufferSize { get; public set; }
    public ShareFileRequestConditions OpenConditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public Nullable`1<long> MaxSize { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_OpenConditions();
    [CompilerGeneratedAttribute]
public void set_OpenConditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxSize();
    [CompilerGeneratedAttribute]
public void set_MaxSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
}
public class Azure.Storage.Files.Shares.Models.ShareFilePermission : object {
    [CompilerGeneratedAttribute]
private Nullable`1<FilePermissionFormat> <PermissionFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permission>k__BackingField;
    public Nullable`1<FilePermissionFormat> PermissionFormat { get; public set; }
    public string Permission { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<FilePermissionFormat> get_PermissionFormat();
    [CompilerGeneratedAttribute]
public void set_PermissionFormat(Nullable`1<FilePermissionFormat> value);
    [CompilerGeneratedAttribute]
public string get_Permission();
    [CompilerGeneratedAttribute]
public void set_Permission(string value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileProperties : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CopyCompletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyStatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyStatus <CopyStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareLeaseDuration <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareLeaseState <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareLeaseStatus <LeaseStatus>k__BackingField;
    public DateTimeOffset LastModified { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public long ContentLength { get; internal set; }
    public string ContentType { get; internal set; }
    public ETag ETag { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public IEnumerable`1<string> ContentEncoding { get; internal set; }
    public string CacheControl { get; internal set; }
    public string ContentDisposition { get; internal set; }
    public IEnumerable`1<string> ContentLanguage { get; internal set; }
    public DateTimeOffset CopyCompletedOn { get; internal set; }
    public string CopyStatusDescription { get; internal set; }
    public string CopyId { get; internal set; }
    public string CopyProgress { get; internal set; }
    public string CopySource { get; internal set; }
    public CopyStatus CopyStatus { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    public FileSmbProperties SmbProperties { get; public set; }
    public ShareLeaseDuration LeaseDuration { get; internal set; }
    public ShareLeaseState LeaseState { get; internal set; }
    public ShareLeaseStatus LeaseStatus { get; internal set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
internal void set_ContentLength(long value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ContentEncoding();
    [CompilerGeneratedAttribute]
internal void set_ContentEncoding(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
internal void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
internal void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ContentLanguage();
    [CompilerGeneratedAttribute]
internal void set_ContentLanguage(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CopyCompletedOn();
    [CompilerGeneratedAttribute]
internal void set_CopyCompletedOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_CopyStatusDescription();
    [CompilerGeneratedAttribute]
internal void set_CopyStatusDescription(string value);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
internal void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public string get_CopyProgress();
    [CompilerGeneratedAttribute]
internal void set_CopyProgress(string value);
    [CompilerGeneratedAttribute]
public string get_CopySource();
    [CompilerGeneratedAttribute]
internal void set_CopySource(string value);
    [CompilerGeneratedAttribute]
public CopyStatus get_CopyStatus();
    [CompilerGeneratedAttribute]
internal void set_CopyStatus(CopyStatus value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
    [CompilerGeneratedAttribute]
public ShareLeaseDuration get_LeaseDuration();
    [CompilerGeneratedAttribute]
internal void set_LeaseDuration(ShareLeaseDuration value);
    [CompilerGeneratedAttribute]
public ShareLeaseState get_LeaseState();
    [CompilerGeneratedAttribute]
internal void set_LeaseState(ShareLeaseState value);
    [CompilerGeneratedAttribute]
public ShareLeaseStatus get_LeaseStatus();
    [CompilerGeneratedAttribute]
internal void set_LeaseStatus(ShareLeaseStatus value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileRangeInfo : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<HttpRange> <Ranges>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<HttpRange> <ClearRanges>k__BackingField;
    public DateTimeOffset LastModified { get; internal set; }
    public ETag ETag { get; internal set; }
    public long FileContentLength { get; internal set; }
    public IEnumerable`1<HttpRange> Ranges { get; internal set; }
    public IEnumerable`1<HttpRange> ClearRanges { get; internal set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public long get_FileContentLength();
    [CompilerGeneratedAttribute]
internal void set_FileContentLength(long value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<HttpRange> get_Ranges();
    [CompilerGeneratedAttribute]
internal void set_Ranges(IEnumerable`1<HttpRange> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<HttpRange> get_ClearRanges();
    [CompilerGeneratedAttribute]
internal void set_ClearRanges(IEnumerable`1<HttpRange> value);
}
internal class Azure.Storage.Files.Shares.Models.ShareFileRangeList : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FileRange> <Ranges>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ClearRange> <ClearRanges>k__BackingField;
    public IReadOnlyList`1<FileRange> Ranges { get; }
    public IReadOnlyList`1<ClearRange> ClearRanges { get; }
    internal ShareFileRangeList(IReadOnlyList`1<FileRange> ranges, IReadOnlyList`1<ClearRange> clearRanges);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FileRange> get_Ranges();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ClearRange> get_ClearRanges();
    internal static ShareFileRangeList DeserializeShareFileRangeList(XElement element);
}
[CodeGenModelAttribute("FileRangeWriteType")]
public enum Azure.Storage.Files.Shares.Models.ShareFileRangeWriteType : Enum {
    public int value__;
    public static ShareFileRangeWriteType Update;
    public static ShareFileRangeWriteType Clear;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.ShareFileRangeWriteTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ShareFileRangeWriteType value);
    [ExtensionAttribute]
public static ShareFileRangeWriteType ToShareFileRangeWriteType(string value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileRenameOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReplaceIfExists>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IgnoreReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <SourceConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <DestinationConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePermission>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FilePermissionFormat> <FilePermissionFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    public Nullable`1<bool> ReplaceIfExists { get; public set; }
    public Nullable`1<bool> IgnoreReadOnly { get; public set; }
    public ShareFileRequestConditions SourceConditions { get; public set; }
    public ShareFileRequestConditions DestinationConditions { get; public set; }
    public FileSmbProperties SmbProperties { get; public set; }
    public string FilePermission { get; public set; }
    public Nullable`1<FilePermissionFormat> FilePermissionFormat { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public string ContentType { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReplaceIfExists();
    [CompilerGeneratedAttribute]
public void set_ReplaceIfExists(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IgnoreReadOnly();
    [CompilerGeneratedAttribute]
public void set_IgnoreReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_SourceConditions();
    [CompilerGeneratedAttribute]
public void set_SourceConditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_DestinationConditions();
    [CompilerGeneratedAttribute]
public void set_DestinationConditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
    [CompilerGeneratedAttribute]
public string get_FilePermission();
    [CompilerGeneratedAttribute]
public void set_FilePermission(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<FilePermissionFormat> get_FilePermissionFormat();
    [CompilerGeneratedAttribute]
public void set_FilePermissionFormat(Nullable`1<FilePermissionFormat> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
}
[CodeGenModelAttribute("LeaseAccessConditions")]
public class Azure.Storage.Files.Shares.Models.ShareFileRequestConditions : object {
    [CompilerGeneratedAttribute]
private string <LeaseId>k__BackingField;
    public string LeaseId { get; public set; }
    internal ShareFileRequestConditions(string leaseId);
    [CompilerGeneratedAttribute]
public string get_LeaseId();
    [CompilerGeneratedAttribute]
public void set_LeaseId(string value);
    public virtual string ToString();
}
public class Azure.Storage.Files.Shares.Models.ShareFileSetHttpHeadersOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <NewSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSmbProperties <SmbProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFilePermission <FilePermission>k__BackingField;
    public Nullable`1<long> NewSize { get; public set; }
    public ShareFileHttpHeaders HttpHeaders { get; public set; }
    public FileSmbProperties SmbProperties { get; public set; }
    public ShareFilePermission FilePermission { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_NewSize();
    [CompilerGeneratedAttribute]
public void set_NewSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public ShareFileHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(ShareFileHttpHeaders value);
    [CompilerGeneratedAttribute]
public FileSmbProperties get_SmbProperties();
    [CompilerGeneratedAttribute]
public void set_SmbProperties(FileSmbProperties value);
    [CompilerGeneratedAttribute]
public ShareFilePermission get_FilePermission();
    [CompilerGeneratedAttribute]
public void set_FilePermission(ShareFilePermission value);
}
[FlagsAttribute]
public enum Azure.Storage.Files.Shares.Models.ShareFileTraits : Enum {
    public int value__;
    public static ShareFileTraits None;
    public static ShareFileTraits Timestamps;
    public static ShareFileTraits ETag;
    public static ShareFileTraits Attributes;
    public static ShareFileTraits PermissionKey;
    public static ShareFileTraits All;
}
public class Azure.Storage.Files.Shares.Models.ShareFileUploadInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileUploadOptions : object {
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageTransferOptions <TransferOptions>k__BackingField;
    public IProgress`1<long> ProgressHandler { get; public set; }
    public ShareFileRequestConditions Conditions { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    public StorageTransferOptions TransferOptions { get; public set; }
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
    [CompilerGeneratedAttribute]
public StorageTransferOptions get_TransferOptions();
    [CompilerGeneratedAttribute]
public void set_TransferOptions(StorageTransferOptions value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileUploadRangeFromUriOptions : object {
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpAuthorization <SourceAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FileLastWrittenMode> <FileLastWrittenMode>k__BackingField;
    public ShareFileRequestConditions Conditions { get; public set; }
    public HttpAuthorization SourceAuthentication { get; public set; }
    public Nullable`1<FileLastWrittenMode> FileLastWrittenMode { get; public set; }
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public HttpAuthorization get_SourceAuthentication();
    [CompilerGeneratedAttribute]
public void set_SourceAuthentication(HttpAuthorization value);
    [CompilerGeneratedAttribute]
public Nullable`1<FileLastWrittenMode> get_FileLastWrittenMode();
    [CompilerGeneratedAttribute]
public void set_FileLastWrittenMode(Nullable`1<FileLastWrittenMode> value);
}
public class Azure.Storage.Files.Shares.Models.ShareFileUploadRangeOptions : object {
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FileLastWrittenMode> <FileLastWrittenMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public ShareFileRequestConditions Conditions { get; public set; }
    public Nullable`1<FileLastWrittenMode> FileLastWrittenMode { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [EditorBrowsableAttribute("1")]
public Byte[] TransactionalContentHash { get; public set; }
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
    [CompilerGeneratedAttribute]
public Nullable`1<FileLastWrittenMode> get_FileLastWrittenMode();
    [CompilerGeneratedAttribute]
public void set_FileLastWrittenMode(Nullable`1<FileLastWrittenMode> value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
    public Byte[] get_TransactionalContentHash();
    public void set_TransactionalContentHash(Byte[] value);
}
public class Azure.Storage.Files.Shares.Models.ShareInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
}
public class Azure.Storage.Files.Shares.Models.ShareItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareProperties <Properties>k__BackingField;
    public string Name { get; internal set; }
    public string Snapshot { get; internal set; }
    public Nullable`1<bool> IsDeleted { get; internal set; }
    public string VersionId { get; internal set; }
    public ShareProperties Properties { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
internal void set_Snapshot(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsDeleted();
    [CompilerGeneratedAttribute]
internal void set_IsDeleted(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
internal void set_VersionId(string value);
    [CompilerGeneratedAttribute]
public ShareProperties get_Properties();
    [CompilerGeneratedAttribute]
internal void set_Properties(ShareProperties value);
}
internal class Azure.Storage.Files.Shares.Models.ShareItemInternal : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Deleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SharePropertiesInternal <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Metadata>k__BackingField;
    public string Name { get; }
    public string Snapshot { get; }
    public Nullable`1<bool> Deleted { get; }
    public string Version { get; }
    public SharePropertiesInternal Properties { get; }
    public IReadOnlyDictionary`2<string, string> Metadata { get; }
    internal ShareItemInternal(string name, SharePropertiesInternal properties);
    internal ShareItemInternal(string name, string snapshot, Nullable`1<bool> deleted, string version, SharePropertiesInternal properties, IReadOnlyDictionary`2<string, string> metadata);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Deleted();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public SharePropertiesInternal get_Properties();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Metadata();
    internal static ShareItemInternal DeserializeShareItemInternal(XElement element);
}
[CodeGenModelAttribute("LeaseDurationType")]
public enum Azure.Storage.Files.Shares.Models.ShareLeaseDuration : Enum {
    public int value__;
    public static ShareLeaseDuration Infinite;
    public static ShareLeaseDuration Fixed;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.ShareLeaseDurationExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ShareLeaseDuration value);
    [ExtensionAttribute]
public static ShareLeaseDuration ToShareLeaseDuration(string value);
}
[CodeGenModelAttribute("LeaseStateType")]
public enum Azure.Storage.Files.Shares.Models.ShareLeaseState : Enum {
    public int value__;
    public static ShareLeaseState Available;
    public static ShareLeaseState Leased;
    public static ShareLeaseState Expired;
    public static ShareLeaseState Breaking;
    public static ShareLeaseState Broken;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.ShareLeaseStateExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ShareLeaseState value);
    [ExtensionAttribute]
public static ShareLeaseState ToShareLeaseState(string value);
}
[CodeGenModelAttribute("LeaseStatusType")]
public enum Azure.Storage.Files.Shares.Models.ShareLeaseStatus : Enum {
    public int value__;
    public static ShareLeaseStatus Locked;
    public static ShareLeaseStatus Unlocked;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.ShareLeaseStatusExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ShareLeaseStatus value);
    [ExtensionAttribute]
public static ShareLeaseStatus ToShareLeaseStatus(string value);
}
[CodeGenModelAttribute("Metrics")]
public class Azure.Storage.Files.Shares.Models.ShareMetrics : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareRetentionPolicy <RetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeApis>k__BackingField;
    public string Version { get; public set; }
    public bool Enabled { get; public set; }
    public ShareRetentionPolicy RetentionPolicy { get; public set; }
    [CodeGenMemberAttribute("IncludeAPIs")]
public Nullable`1<bool> IncludeApis { get; public set; }
    internal ShareMetrics(string version, bool enabled, Nullable`1<bool> includeApis, ShareRetentionPolicy retentionPolicy);
    internal ShareMetrics(string version, bool enabled);
    internal ShareMetrics(bool skipInitialization);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public ShareRetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(ShareRetentionPolicy value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static ShareMetrics DeserializeShareMetrics(XElement element);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeApis();
    [CompilerGeneratedAttribute]
public void set_IncludeApis(Nullable`1<bool> value);
}
[CodeGenTypeAttribute("StorageFilesSharesModelFactory")]
public static class Azure.Storage.Files.Shares.Models.ShareModelFactory : object {
    public static ShareFileRangeInfo ShareFileRangeInfo(DateTimeOffset lastModified, ETag eTag, long fileContentLength, IEnumerable`1<HttpRange> ranges);
    [EditorBrowsableAttribute("1")]
public static StorageClosedHandlesSegment StorageClosedHandlesSegment(string marker, int numberOfHandlesClosed);
    public static ShareProperties ShareProperties(string accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<int> provisionedIops, Nullable`1<int> provisionedIngressMBps, Nullable`1<int> provisionedEgressMBps, Nullable`1<DateTimeOffset> nextAllowedQuotaDowngradeTime, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<int> remainingRetentionDays, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> accessTierChangeTime, string accessTierTransitionState, Nullable`1<ShareLeaseStatus> leaseStatus, Nullable`1<ShareLeaseState> leaseState, Nullable`1<ShareLeaseDuration> leaseDuration, Nullable`1<int> quotaInGB, IDictionary`2<string, string> metadata, Nullable`1<ShareProtocols> protocols, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> enablePaidBursting, Nullable`1<long> paidBurstingMaxIops, Nullable`1<long> paidBustingMaxBandwidthMibps);
    [EditorBrowsableAttribute("1")]
public static ShareProperties ShareProperties(string accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<int> provisionedIops, Nullable`1<int> provisionedIngressMBps, Nullable`1<int> provisionedEgressMBps, Nullable`1<DateTimeOffset> nextAllowedQuotaDowngradeTime, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<int> remainingRetentionDays, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> accessTierChangeTime, string accessTierTransitionState, Nullable`1<ShareLeaseStatus> leaseStatus, Nullable`1<ShareLeaseState> leaseState, Nullable`1<ShareLeaseDuration> leaseDuration, Nullable`1<int> quotaInGB, IDictionary`2<string, string> metadata, Nullable`1<ShareProtocols> protocols, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess);
    [EditorBrowsableAttribute("1")]
public static ShareProperties ShareProperties(Nullable`1<DateTimeOffset> lastModified, Nullable`1<ETag> eTag, Nullable`1<int> provisionedIops, Nullable`1<int> provisionedIngressMBps, Nullable`1<int> provisionedEgressMBps, Nullable`1<DateTimeOffset> nextAllowedQuotaDowngradeTime, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<int> remainingRetentionDays, Nullable`1<int> quotaInGB, IDictionary`2<string, string> metadata);
    [EditorBrowsableAttribute("1")]
public static ShareProperties ShareProperties(string accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<int> provisionedIops, Nullable`1<int> provisionedIngressMBps, Nullable`1<int> provisionedEgressMBps, Nullable`1<DateTimeOffset> nextAllowedQuotaDowngradeTime, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<int> remainingRetentionDays, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> accessTierChangeTime, string accessTierTransitionState, Nullable`1<ShareLeaseStatus> leaseStatus, Nullable`1<ShareLeaseState> leaseState, Nullable`1<ShareLeaseDuration> leaseDuration, Nullable`1<int> quotaInGB, IDictionary`2<string, string> metadata, Nullable`1<ShareProtocols> protocols, Nullable`1<ShareRootSquash> rootSquash);
    [EditorBrowsableAttribute("1")]
public static ShareProperties ShareProperties(string accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<int> provisionedIops, Nullable`1<int> provisionedIngressMBps, Nullable`1<int> provisionedEgressMBps, Nullable`1<DateTimeOffset> nextAllowedQuotaDowngradeTime, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<int> remainingRetentionDays, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> accessTierChangeTime, string accessTierTransitionState, Nullable`1<ShareLeaseStatus> leaseStatus, Nullable`1<ShareLeaseState> leaseState, Nullable`1<ShareLeaseDuration> leaseDuration, Nullable`1<int> quotaInGB, IDictionary`2<string, string> metadata);
    [EditorBrowsableAttribute("1")]
public static ShareProperties ShareProperties(Nullable`1<DateTimeOffset> lastModified, Nullable`1<ETag> eTag, Nullable`1<int> provisionedIops, Nullable`1<int> provisionedIngressMBps, Nullable`1<int> provisionedEgressMBps, Nullable`1<DateTimeOffset> nextAllowedQuotaDowngradeTime, Nullable`1<int> quotaInGB, IDictionary`2<string, string> metadata);
    [EditorBrowsableAttribute("1")]
public static ShareProperties ShareProperties(Nullable`1<DateTimeOffset> lastModified, Nullable`1<ETag> eTag, Nullable`1<int> quotaInGB, IDictionary`2<string, string> metadata);
    public static ShareItem ShareItem(string name, ShareProperties properties, string snapshot, Nullable`1<bool> isDeleted, string versionId);
    [EditorBrowsableAttribute("1")]
public static ShareItem ShareItem(string name, ShareProperties properties, string snapshot);
    public static ShareFileHandle ShareFileHandle(string handleId, string path, string fileId, string sessionId, string clientIp, string clientName, string parentId, Nullable`1<DateTimeOffset> openedOn, Nullable`1<DateTimeOffset> lastReconnectedOn, Nullable`1<ShareFileHandleAccessRights> accessRights);
    [EditorBrowsableAttribute("1")]
public static ShareFileHandle ShareFileHandle(string handleId, string path, string fileId, string sessionId, string clientIp, string parentId, Nullable`1<DateTimeOffset> openedOn, Nullable`1<DateTimeOffset> lastReconnectedOn, Nullable`1<ShareFileHandleAccessRights> accessRights);
    [EditorBrowsableAttribute("1")]
public static ShareFileHandle ShareFileHandle(string handleId, string path, string fileId, string sessionId, string clientIp, string parentId, Nullable`1<DateTimeOffset> openedOn, Nullable`1<DateTimeOffset> lastReconnectedOn);
    public static ShareFileCopyInfo ShareFileCopyInfo(ETag eTag, DateTimeOffset lastModified, string copyId, CopyStatus copyStatus);
    public static PermissionInfo PermissionInfo(string filePermissionKey);
    public static ShareFileLease ShareFileLease(ETag eTag, DateTimeOffset lastModified, string leaseId);
    public static ShareFileUploadInfo ShareFileUploadInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, bool isServerEncrypted);
    public static ShareInfo ShareInfo(ETag eTag, DateTimeOffset lastModified);
    public static ShareSnapshotInfo ShareSnapshotInfo(string snapshot, ETag eTag, DateTimeOffset lastModified);
    public static ShareStatistics ShareStatistics(long shareUsageInBytes);
    public static StorageClosedHandlesSegment StorageClosedHandlesSegment(string marker, int numberOfHandlesClosed, int numberOfHandlesFailedToClose);
    public static FileLeaseReleaseInfo FileLeaseReleaseInfo(ETag eTag, DateTimeOffset lastModified);
    public static ShareFileItemProperties ShareFileItemProperties(Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> lastAccessedOn, Nullable`1<DateTimeOffset> lastWrittenOn, Nullable`1<DateTimeOffset> changedOn, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ETag> etag);
    [EditorBrowsableAttribute("1")]
public static ShareStatistics ShareStatistics(int shareUsageBytes);
}
internal class Azure.Storage.Files.Shares.Models.SharePermission : object {
    [CompilerGeneratedAttribute]
private string <Permission>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FilePermissionFormat> <Format>k__BackingField;
    public string Permission { get; public set; }
    public Nullable`1<FilePermissionFormat> Format { get; public set; }
    public SharePermission(string permission);
    internal SharePermission(string permission, Nullable`1<FilePermissionFormat> format);
    [CompilerGeneratedAttribute]
public string get_Permission();
    [CompilerGeneratedAttribute]
public void set_Permission(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<FilePermissionFormat> get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(Nullable`1<FilePermissionFormat> value);
    private sealed virtual override void Azure.Core.IUtf8JsonSerializable.Write(Utf8JsonWriter writer);
    internal static SharePermission DeserializeSharePermission(JsonElement element);
    internal static SharePermission FromResponse(Response response);
    internal virtual RequestContent ToRequestContent();
}
public class Azure.Storage.Files.Shares.Models.ShareProperties : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ETag> <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProvisionedIops>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProvisionedIngressMBps>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProvisionedEgressMBps>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProvisionedBandwidthMiBps>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <NextAllowedQuotaDowngradeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RemainingRetentionDays>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <AccessTierChangeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessTierTransitionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareLeaseStatus> <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareLeaseState> <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareLeaseDuration> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareProtocols> <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareRootSquash> <RootSquash>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <QuotaInGB>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableSnapshotVirtualDirectoryAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnablePaidBursting>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PaidBurstingMaxIops>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PaidBurstingMaxBandwidthMibps>k__BackingField;
    public Nullable`1<DateTimeOffset> LastModified { get; internal set; }
    public Nullable`1<ETag> ETag { get; internal set; }
    public Nullable`1<int> ProvisionedIops { get; internal set; }
    [EditorBrowsableAttribute("1")]
public Nullable`1<int> ProvisionedIngressMBps { get; internal set; }
    [EditorBrowsableAttribute("1")]
public Nullable`1<int> ProvisionedEgressMBps { get; internal set; }
    public Nullable`1<int> ProvisionedBandwidthMiBps { get; internal set; }
    public Nullable`1<DateTimeOffset> NextAllowedQuotaDowngradeTime { get; internal set; }
    public Nullable`1<DateTimeOffset> DeletedOn { get; internal set; }
    public Nullable`1<int> RemainingRetentionDays { get; internal set; }
    public string AccessTier { get; internal set; }
    public Nullable`1<DateTimeOffset> AccessTierChangeTime { get; internal set; }
    public string AccessTierTransitionState { get; internal set; }
    public Nullable`1<ShareLeaseStatus> LeaseStatus { get; internal set; }
    public Nullable`1<ShareLeaseState> LeaseState { get; internal set; }
    public Nullable`1<ShareLeaseDuration> LeaseDuration { get; internal set; }
    public Nullable`1<ShareProtocols> Protocols { get; internal set; }
    public Nullable`1<ShareRootSquash> RootSquash { get; internal set; }
    public Nullable`1<int> QuotaInGB { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public Nullable`1<bool> EnableSnapshotVirtualDirectoryAccess { get; internal set; }
    public Nullable`1<bool> EnablePaidBursting { get; internal set; }
    public Nullable`1<long> PaidBurstingMaxIops { get; internal set; }
    public Nullable`1<long> PaidBurstingMaxBandwidthMibps { get; internal set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ETag> get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(Nullable`1<ETag> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProvisionedIops();
    [CompilerGeneratedAttribute]
internal void set_ProvisionedIops(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProvisionedIngressMBps();
    [CompilerGeneratedAttribute]
internal void set_ProvisionedIngressMBps(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProvisionedEgressMBps();
    [CompilerGeneratedAttribute]
internal void set_ProvisionedEgressMBps(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProvisionedBandwidthMiBps();
    [CompilerGeneratedAttribute]
internal void set_ProvisionedBandwidthMiBps(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_NextAllowedQuotaDowngradeTime();
    [CompilerGeneratedAttribute]
internal void set_NextAllowedQuotaDowngradeTime(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedOn();
    [CompilerGeneratedAttribute]
internal void set_DeletedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RemainingRetentionDays();
    [CompilerGeneratedAttribute]
internal void set_RemainingRetentionDays(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_AccessTier();
    [CompilerGeneratedAttribute]
internal void set_AccessTier(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_AccessTierChangeTime();
    [CompilerGeneratedAttribute]
internal void set_AccessTierChangeTime(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_AccessTierTransitionState();
    [CompilerGeneratedAttribute]
internal void set_AccessTierTransitionState(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareLeaseStatus> get_LeaseStatus();
    [CompilerGeneratedAttribute]
internal void set_LeaseStatus(Nullable`1<ShareLeaseStatus> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareLeaseState> get_LeaseState();
    [CompilerGeneratedAttribute]
internal void set_LeaseState(Nullable`1<ShareLeaseState> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareLeaseDuration> get_LeaseDuration();
    [CompilerGeneratedAttribute]
internal void set_LeaseDuration(Nullable`1<ShareLeaseDuration> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareProtocols> get_Protocols();
    [CompilerGeneratedAttribute]
internal void set_Protocols(Nullable`1<ShareProtocols> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareRootSquash> get_RootSquash();
    [CompilerGeneratedAttribute]
internal void set_RootSquash(Nullable`1<ShareRootSquash> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_QuotaInGB();
    [CompilerGeneratedAttribute]
internal void set_QuotaInGB(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableSnapshotVirtualDirectoryAccess();
    [CompilerGeneratedAttribute]
internal void set_EnableSnapshotVirtualDirectoryAccess(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnablePaidBursting();
    [CompilerGeneratedAttribute]
internal void set_EnablePaidBursting(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_PaidBurstingMaxIops();
    [CompilerGeneratedAttribute]
internal void set_PaidBurstingMaxIops(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_PaidBurstingMaxBandwidthMibps();
    [CompilerGeneratedAttribute]
internal void set_PaidBurstingMaxBandwidthMibps(Nullable`1<long> value);
}
internal class Azure.Storage.Files.Shares.Models.SharePropertiesInternal : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Quota>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProvisionedIops>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProvisionedIngressMBps>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProvisionedEgressMBps>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProvisionedBandwidthMiBps>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <NextAllowedQuotaDowngradeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RemainingRetentionDays>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <AccessTierChangeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessTierTransitionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareLeaseStatus> <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareLeaseState> <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareLeaseDuration> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnabledProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareRootSquash> <RootSquash>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableSnapshotVirtualDirectoryAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PaidBurstingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PaidBurstingMaxIops>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PaidBurstingMaxBandwidthMibps>k__BackingField;
    public DateTimeOffset LastModified { get; }
    public string Etag { get; }
    public int Quota { get; }
    public Nullable`1<int> ProvisionedIops { get; }
    public Nullable`1<int> ProvisionedIngressMBps { get; }
    public Nullable`1<int> ProvisionedEgressMBps { get; }
    public Nullable`1<int> ProvisionedBandwidthMiBps { get; }
    public Nullable`1<DateTimeOffset> NextAllowedQuotaDowngradeTime { get; }
    public Nullable`1<DateTimeOffset> DeletedTime { get; }
    public Nullable`1<int> RemainingRetentionDays { get; }
    public string AccessTier { get; }
    public Nullable`1<DateTimeOffset> AccessTierChangeTime { get; }
    public string AccessTierTransitionState { get; }
    public Nullable`1<ShareLeaseStatus> LeaseStatus { get; }
    public Nullable`1<ShareLeaseState> LeaseState { get; }
    public Nullable`1<ShareLeaseDuration> LeaseDuration { get; }
    public string EnabledProtocols { get; }
    public Nullable`1<ShareRootSquash> RootSquash { get; }
    public Nullable`1<bool> EnableSnapshotVirtualDirectoryAccess { get; }
    public Nullable`1<bool> PaidBurstingEnabled { get; }
    public Nullable`1<long> PaidBurstingMaxIops { get; }
    public Nullable`1<long> PaidBurstingMaxBandwidthMibps { get; }
    internal SharePropertiesInternal(DateTimeOffset lastModified, string etag, int quota);
    internal SharePropertiesInternal(DateTimeOffset lastModified, string etag, int quota, Nullable`1<int> provisionedIops, Nullable`1<int> provisionedIngressMBps, Nullable`1<int> provisionedEgressMBps, Nullable`1<int> provisionedBandwidthMiBps, Nullable`1<DateTimeOffset> nextAllowedQuotaDowngradeTime, Nullable`1<DateTimeOffset> deletedTime, Nullable`1<int> remainingRetentionDays, string accessTier, Nullable`1<DateTimeOffset> accessTierChangeTime, string accessTierTransitionState, Nullable`1<ShareLeaseStatus> leaseStatus, Nullable`1<ShareLeaseState> leaseState, Nullable`1<ShareLeaseDuration> leaseDuration, string enabledProtocols, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> paidBurstingEnabled, Nullable`1<long> paidBurstingMaxIops, Nullable`1<long> paidBurstingMaxBandwidthMibps);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
public string get_Etag();
    [CompilerGeneratedAttribute]
public int get_Quota();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProvisionedIops();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProvisionedIngressMBps();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProvisionedEgressMBps();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProvisionedBandwidthMiBps();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_NextAllowedQuotaDowngradeTime();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedTime();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RemainingRetentionDays();
    [CompilerGeneratedAttribute]
public string get_AccessTier();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_AccessTierChangeTime();
    [CompilerGeneratedAttribute]
public string get_AccessTierTransitionState();
    [CompilerGeneratedAttribute]
public Nullable`1<ShareLeaseStatus> get_LeaseStatus();
    [CompilerGeneratedAttribute]
public Nullable`1<ShareLeaseState> get_LeaseState();
    [CompilerGeneratedAttribute]
public Nullable`1<ShareLeaseDuration> get_LeaseDuration();
    [CompilerGeneratedAttribute]
public string get_EnabledProtocols();
    [CompilerGeneratedAttribute]
public Nullable`1<ShareRootSquash> get_RootSquash();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableSnapshotVirtualDirectoryAccess();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PaidBurstingEnabled();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_PaidBurstingMaxIops();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_PaidBurstingMaxBandwidthMibps();
    internal static SharePropertiesInternal DeserializeSharePropertiesInternal(XElement element);
}
[FlagsAttribute]
public enum Azure.Storage.Files.Shares.Models.ShareProtocols : Enum {
    public int value__;
    public static ShareProtocols Smb;
    public static ShareProtocols Nfs;
}
public class Azure.Storage.Files.Shares.Models.ShareProtocolSettings : object {
    [CompilerGeneratedAttribute]
private ShareSmbSettings <Smb>k__BackingField;
    public ShareSmbSettings Smb { get; public set; }
    internal ShareProtocolSettings(ShareSmbSettings smb);
    internal ShareProtocolSettings(bool skipInitialization);
    [CompilerGeneratedAttribute]
public ShareSmbSettings get_Smb();
    [CompilerGeneratedAttribute]
public void set_Smb(ShareSmbSettings value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static ShareProtocolSettings DeserializeShareProtocolSettings(XElement element);
}
[CodeGenModelAttribute("RetentionPolicy")]
public class Azure.Storage.Files.Shares.Models.ShareRetentionPolicy : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Days>k__BackingField;
    public bool Enabled { get; public set; }
    public Nullable`1<int> Days { get; public set; }
    internal ShareRetentionPolicy(bool enabled, Nullable`1<int> days);
    internal ShareRetentionPolicy(bool enabled);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Days();
    [CompilerGeneratedAttribute]
public void set_Days(Nullable`1<int> value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static ShareRetentionPolicy DeserializeShareRetentionPolicy(XElement element);
}
public enum Azure.Storage.Files.Shares.Models.ShareRootSquash : Enum {
    public int value__;
    public static ShareRootSquash NoRootSquash;
    public static ShareRootSquash RootSquash;
    public static ShareRootSquash AllSquash;
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.Models.ShareRootSquashExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ShareRootSquash value);
    [ExtensionAttribute]
public static ShareRootSquash ToShareRootSquash(string value);
}
[CodeGenModelAttribute("StorageServiceProperties")]
public class Azure.Storage.Files.Shares.Models.ShareServiceProperties : object {
    [CompilerGeneratedAttribute]
private ShareMetrics <HourMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareMetrics <MinuteMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareProtocolSettings <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ShareCorsRule> <Cors>k__BackingField;
    public ShareMetrics HourMetrics { get; public set; }
    public ShareMetrics MinuteMetrics { get; public set; }
    public ShareProtocolSettings Protocol { get; public set; }
    public IList`1<ShareCorsRule> Cors { get; public set; }
    internal ShareServiceProperties(ShareMetrics hourMetrics, ShareMetrics minuteMetrics, IList`1<ShareCorsRule> cors, ShareProtocolSettings protocol);
    internal ShareServiceProperties(bool skipInitialization);
    [CompilerGeneratedAttribute]
public ShareMetrics get_HourMetrics();
    [CompilerGeneratedAttribute]
public void set_HourMetrics(ShareMetrics value);
    [CompilerGeneratedAttribute]
public ShareMetrics get_MinuteMetrics();
    [CompilerGeneratedAttribute]
public void set_MinuteMetrics(ShareMetrics value);
    [CompilerGeneratedAttribute]
public ShareProtocolSettings get_Protocol();
    [CompilerGeneratedAttribute]
public void set_Protocol(ShareProtocolSettings value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static ShareServiceProperties DeserializeShareServiceProperties(XElement element);
    [CompilerGeneratedAttribute]
public IList`1<ShareCorsRule> get_Cors();
    [CompilerGeneratedAttribute]
public void set_Cors(IList`1<ShareCorsRule> value);
}
public class Azure.Storage.Files.Shares.Models.ShareSetPropertiesOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <QuotaInGB>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareAccessTier> <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareRootSquash> <RootSquash>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableSnapshotVirtualDirectoryAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnablePaidBursting>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PaidBurstingMaxIops>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PaidBurstingMaxBandwidthMibps>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareFileRequestConditions <Conditions>k__BackingField;
    public Nullable`1<int> QuotaInGB { get; public set; }
    public Nullable`1<ShareAccessTier> AccessTier { get; public set; }
    public Nullable`1<ShareRootSquash> RootSquash { get; public set; }
    public Nullable`1<bool> EnableSnapshotVirtualDirectoryAccess { get; public set; }
    public Nullable`1<bool> EnablePaidBursting { get; public set; }
    public Nullable`1<long> PaidBurstingMaxIops { get; public set; }
    public Nullable`1<long> PaidBurstingMaxBandwidthMibps { get; public set; }
    public ShareFileRequestConditions Conditions { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_QuotaInGB();
    [CompilerGeneratedAttribute]
public void set_QuotaInGB(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareAccessTier> get_AccessTier();
    [CompilerGeneratedAttribute]
public void set_AccessTier(Nullable`1<ShareAccessTier> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareRootSquash> get_RootSquash();
    [CompilerGeneratedAttribute]
public void set_RootSquash(Nullable`1<ShareRootSquash> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableSnapshotVirtualDirectoryAccess();
    [CompilerGeneratedAttribute]
public void set_EnableSnapshotVirtualDirectoryAccess(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnablePaidBursting();
    [CompilerGeneratedAttribute]
public void set_EnablePaidBursting(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_PaidBurstingMaxIops();
    [CompilerGeneratedAttribute]
public void set_PaidBurstingMaxIops(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_PaidBurstingMaxBandwidthMibps();
    [CompilerGeneratedAttribute]
public void set_PaidBurstingMaxBandwidthMibps(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public ShareFileRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(ShareFileRequestConditions value);
}
[CodeGenModelAttribute("SignedIdentifier")]
public class Azure.Storage.Files.Shares.Models.ShareSignedIdentifier : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareAccessPolicy <AccessPolicy>k__BackingField;
    public string Id { get; public set; }
    public ShareAccessPolicy AccessPolicy { get; public set; }
    internal ShareSignedIdentifier(string id, ShareAccessPolicy accessPolicy);
    internal ShareSignedIdentifier(string id);
    internal ShareSignedIdentifier(bool skipInitialization);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public ShareAccessPolicy get_AccessPolicy();
    [CompilerGeneratedAttribute]
public void set_AccessPolicy(ShareAccessPolicy value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static ShareSignedIdentifier DeserializeShareSignedIdentifier(XElement element);
}
public class Azure.Storage.Files.Shares.Models.ShareSmbSettings : object {
    [CompilerGeneratedAttribute]
private SmbMultichannel <Multichannel>k__BackingField;
    public SmbMultichannel Multichannel { get; public set; }
    internal ShareSmbSettings(SmbMultichannel multichannel);
    internal ShareSmbSettings(bool skipInitialization);
    [CompilerGeneratedAttribute]
public SmbMultichannel get_Multichannel();
    [CompilerGeneratedAttribute]
public void set_Multichannel(SmbMultichannel value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static ShareSmbSettings DeserializeShareSmbSettings(XElement element);
}
public static class Azure.Storage.Files.Shares.Models.SharesModelFactory : object {
    public static FileSmbProperties FileSmbProperties(Nullable`1<DateTimeOffset> fileChangedOn, string fileId, string parentId);
    public static ShareDirectoryInfo StorageDirectoryInfo(ETag eTag, DateTimeOffset lastModified, string filePermissionKey, string fileAttributes, DateTimeOffset fileCreationTime, DateTimeOffset fileLastWriteTime, DateTimeOffset fileChangeTime, string fileId, string fileParentId);
}
public class Azure.Storage.Files.Shares.Models.ShareSnapshotInfo : object {
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    public string Snapshot { get; internal set; }
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
internal void set_Snapshot(string value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
}
public enum Azure.Storage.Files.Shares.Models.ShareSnapshotsDeleteOption : Enum {
    public int value__;
    public static ShareSnapshotsDeleteOption Include;
    public static ShareSnapshotsDeleteOption IncludeWithLeased;
}
[FlagsAttribute]
public enum Azure.Storage.Files.Shares.Models.ShareStates : Enum {
    public int value__;
    public static ShareStates None;
    public static ShareStates Snapshots;
    public static ShareStates Deleted;
    public static ShareStates All;
}
[CodeGenModelAttribute("ShareStats")]
public class Azure.Storage.Files.Shares.Models.ShareStatistics : object {
    [CompilerGeneratedAttribute]
private long <ShareUsageInBytes>k__BackingField;
    [EditorBrowsableAttribute("1")]
public int ShareUsageBytes { get; internal set; }
    public long ShareUsageInBytes { get; internal set; }
    internal ShareStatistics(int shareUsageBytes);
    public int get_ShareUsageBytes();
    internal void set_ShareUsageBytes(int value);
    [CompilerGeneratedAttribute]
public long get_ShareUsageInBytes();
    [CompilerGeneratedAttribute]
internal void set_ShareUsageInBytes(long value);
    internal static ShareStatistics DeserializeShareStatistics(XElement element);
}
[IsReadOnlyAttribute]
public class Azure.Storage.Files.Shares.Models.ShareTokenIntent : ValueType {
    private string _value;
    private static string BackupValue;
    [CompilerGeneratedAttribute]
private static ShareTokenIntent <Backup>k__BackingField;
    public static ShareTokenIntent Backup { get; }
    public ShareTokenIntent(string value);
    private static ShareTokenIntent();
    [CompilerGeneratedAttribute]
public static ShareTokenIntent get_Backup();
    public static bool op_Equality(ShareTokenIntent left, ShareTokenIntent right);
    public static bool op_Inequality(ShareTokenIntent left, ShareTokenIntent right);
    public static ShareTokenIntent op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ShareTokenIntent other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
public enum Azure.Storage.Files.Shares.Models.ShareTraits : Enum {
    public int value__;
    public static ShareTraits None;
    public static ShareTraits Metadata;
    public static ShareTraits All;
}
public class Azure.Storage.Files.Shares.Models.SmbMultichannel : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    public Nullable`1<bool> Enabled { get; public set; }
    internal SmbMultichannel(Nullable`1<bool> enabled);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(Nullable`1<bool> value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static SmbMultichannel DeserializeSmbMultichannel(XElement element);
}
internal class Azure.Storage.Files.Shares.Models.SourceModifiedAccessConditions : object {
    [CompilerGeneratedAttribute]
private Byte[] <SourceIfMatchCrc64>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SourceIfNoneMatchCrc64>k__BackingField;
    public Byte[] SourceIfMatchCrc64 { get; public set; }
    public Byte[] SourceIfNoneMatchCrc64 { get; public set; }
    internal SourceModifiedAccessConditions(Byte[] sourceIfMatchCrc64, Byte[] sourceIfNoneMatchCrc64);
    [CompilerGeneratedAttribute]
public Byte[] get_SourceIfMatchCrc64();
    [CompilerGeneratedAttribute]
public void set_SourceIfMatchCrc64(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_SourceIfNoneMatchCrc64();
    [CompilerGeneratedAttribute]
public void set_SourceIfNoneMatchCrc64(Byte[] value);
}
public class Azure.Storage.Files.Shares.Models.StorageClosedHandlesSegment : object {
    [CompilerGeneratedAttribute]
private string <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfHandlesClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfHandlesFailedToClose>k__BackingField;
    public string Marker { get; internal set; }
    public int NumberOfHandlesClosed { get; internal set; }
    public int NumberOfHandlesFailedToClose { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Marker();
    [CompilerGeneratedAttribute]
internal void set_Marker(string value);
    [CompilerGeneratedAttribute]
public int get_NumberOfHandlesClosed();
    [CompilerGeneratedAttribute]
internal void set_NumberOfHandlesClosed(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfHandlesFailedToClose();
    [CompilerGeneratedAttribute]
internal void set_NumberOfHandlesFailedToClose(int value);
}
internal class Azure.Storage.Files.Shares.Models.StorageError : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationErrorDetail>k__BackingField;
    public string Message { get; }
    public string AuthenticationErrorDetail { get; }
    internal StorageError(string message, string authenticationErrorDetail);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_AuthenticationErrorDetail();
    internal static StorageError DeserializeStorageError(XElement element);
    internal static StorageError DeserializeStorageError(JsonElement element);
    internal static StorageError FromResponse(Response response);
}
internal class Azure.Storage.Files.Shares.Models.StorageHandlesSegment : object {
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ShareFileHandle> <Handles>k__BackingField;
    public string NextMarker { get; internal set; }
    public IEnumerable`1<ShareFileHandle> Handles { get; internal set; }
    internal StorageHandlesSegment(bool skipInitialization);
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    [CompilerGeneratedAttribute]
internal void set_NextMarker(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ShareFileHandle> get_Handles();
    [CompilerGeneratedAttribute]
internal void set_Handles(IEnumerable`1<ShareFileHandle> value);
}
internal class Azure.Storage.Files.Shares.Models.StringEncoded : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Encoded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public Nullable`1<bool> Encoded { get; }
    public string Content { get; }
    internal StringEncoded(Nullable`1<bool> encoded, string content);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Encoded();
    [CompilerGeneratedAttribute]
public string get_Content();
    internal static StringEncoded DeserializeStringEncoded(XElement element);
}
internal class Azure.Storage.Files.Shares.ServiceGetPropertiesHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceGetPropertiesHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ServiceListSharesSegmentHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceListSharesSegmentHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ServiceRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    private Nullable`1<ShareTokenIntent> _fileRequestIntent;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public ServiceRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version, Nullable`1<ShareTokenIntent> fileRequestIntent);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateSetPropertiesRequest(ShareServiceProperties shareServiceProperties, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ServiceRestClient/<SetPropertiesAsync>d__9")]
public Task`1<ResponseWithHeaders`1<ServiceSetPropertiesHeaders>> SetPropertiesAsync(ShareServiceProperties shareServiceProperties, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ServiceSetPropertiesHeaders> SetProperties(ShareServiceProperties shareServiceProperties, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ServiceRestClient/<GetPropertiesAsync>d__12")]
public Task`1<ResponseWithHeaders`2<ShareServiceProperties, ServiceGetPropertiesHeaders>> GetPropertiesAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ShareServiceProperties, ServiceGetPropertiesHeaders> GetProperties(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateListSharesSegmentRequest(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListSharesIncludeType> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ServiceRestClient/<ListSharesSegmentAsync>d__15")]
public Task`1<ResponseWithHeaders`2<ListSharesResponse, ServiceListSharesSegmentHeaders>> ListSharesSegmentAsync(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListSharesIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListSharesResponse, ServiceListSharesSegmentHeaders> ListSharesSegment(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListSharesIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateListSharesSegmentNextPageRequest(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListSharesIncludeType> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ServiceRestClient/<ListSharesSegmentNextPageAsync>d__18")]
public Task`1<ResponseWithHeaders`2<ListSharesResponse, ServiceListSharesSegmentHeaders>> ListSharesSegmentNextPageAsync(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListSharesIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListSharesResponse, ServiceListSharesSegmentHeaders> ListSharesSegmentNextPage(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListSharesIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.Shares.ServiceSetPropertiesHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceSetPropertiesHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareAcquireLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public ShareAcquireLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareBreakLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<int> LeaseTime { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public ShareBreakLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<int> get_LeaseTime();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareChangeLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public ShareChangeLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
public class Azure.Storage.Files.Shares.ShareClient : object {
    private Uri _uri;
    private ShareClientConfiguration _clientConfiguration;
    private ShareRestClient _shareRestClient;
    private string _accountName;
    private string _name;
    private ShareServiceClient _parentShareServiceClient;
    public Uri Uri { get; }
    internal ShareClientConfiguration ClientConfiguration { get; }
    internal ShareRestClient ShareRestClient { get; }
    public string AccountName { get; }
    public string Name { get; }
    public bool CanGenerateSasUri { get; }
    public ShareClient(string connectionString, string shareName);
    public ShareClient(string connectionString, string shareName, ShareClientOptions options);
    public ShareClient(Uri shareUri, ShareClientOptions options);
    public ShareClient(Uri shareUri, StorageSharedKeyCredential credential, ShareClientOptions options);
    public ShareClient(Uri shareUri, AzureSasCredential credential, ShareClientOptions options);
    public ShareClient(Uri shareUri, TokenCredential credential, ShareClientOptions options);
    internal ShareClient(Uri shareUri, HttpPipelinePolicy authentication, ShareClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    internal ShareClient(Uri shareUri, ShareClientConfiguration clientConfiguration);
    public virtual Uri get_Uri();
    internal virtual ShareClientConfiguration get_ClientConfiguration();
    internal virtual ShareRestClient get_ShareRestClient();
    public virtual string get_AccountName();
    public virtual string get_Name();
    public virtual bool get_CanGenerateSasUri();
    private ShareRestClient BuildShareRestClient(Uri uri);
    public virtual ShareClient WithSnapshot(string snapshot);
    public virtual ShareDirectoryClient GetDirectoryClient(string directoryName);
    public virtual ShareDirectoryClient GetRootDirectoryClient();
    private void SetNameFieldsIfNull();
    public virtual Response`1<ShareInfo> Create(ShareCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateAsync>d__32")]
public virtual Task`1<Response`1<ShareInfo>> CreateAsync(ShareCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareInfo> Create(IDictionary`2<string, string> metadata, Nullable`1<int> quotaInGB, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateAsync>d__34")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareInfo>> CreateAsync(IDictionary`2<string, string> metadata, Nullable`1<int> quotaInGB, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateInternal>d__35")]
internal Task`1<Response`1<ShareInfo>> CreateInternal(IDictionary`2<string, string> metadata, Nullable`1<int> quotaInGB, Nullable`1<ShareAccessTier> accessTier, Nullable`1<ShareProtocols> enabledProtocols, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> enablePaidBursting, Nullable`1<long> paidBurstingMaxIops, Nullable`1<long> paidBurstingMaxBandwidthMibps, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareInfo> CreateIfNotExists(ShareCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateIfNotExistsAsync>d__37")]
public virtual Task`1<Response`1<ShareInfo>> CreateIfNotExistsAsync(ShareCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareInfo> CreateIfNotExists(IDictionary`2<string, string> metadata, Nullable`1<int> quotaInGB, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateIfNotExistsAsync>d__39")]
public virtual Task`1<Response`1<ShareInfo>> CreateIfNotExistsAsync(IDictionary`2<string, string> metadata, Nullable`1<int> quotaInGB, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateIfNotExistsInternal>d__40")]
private Task`1<Response`1<ShareInfo>> CreateIfNotExistsInternal(IDictionary`2<string, string> metadata, Nullable`1<int> quotaInGB, Nullable`1<ShareAccessTier> accessTier, Nullable`1<ShareProtocols> enabledProtocols, Nullable`1<ShareRootSquash> squashRoot, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> enablePaidBursting, Nullable`1<long> paidBurstingMaxIops, Nullable`1<long> paidBurstingMaxBandwidthMibps, bool async, CancellationToken cancellationToken);
    public virtual Response`1<bool> Exists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<ExistsAsync>d__42")]
public virtual Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<ExistsInternal>d__43")]
private Task`1<Response`1<bool>> ExistsInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<bool> DeleteIfExists(ShareDeleteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<DeleteIfExistsAsync>d__45")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(ShareDeleteOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<bool> DeleteIfExists(bool includeSnapshots, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<DeleteIfExistsAsync>d__47")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(bool includeSnapshots, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<DeleteIfExistsInternal>d__48")]
private Task`1<Response`1<bool>> DeleteIfExistsInternal(bool includeSnapshots, Nullable`1<ShareSnapshotsDeleteOption> shareSnapshotsDeleteOption, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareSnapshotInfo> CreateSnapshot(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateSnapshotAsync>d__50")]
public virtual Task`1<Response`1<ShareSnapshotInfo>> CreateSnapshotAsync(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateSnapshotInternal>d__51")]
private Task`1<Response`1<ShareSnapshotInfo>> CreateSnapshotInternal(IDictionary`2<string, string> metadata, bool async, CancellationToken cancellationToken);
    public virtual Response Delete(ShareDeleteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<DeleteAsync>d__53")]
public virtual Task`1<Response> DeleteAsync(ShareDeleteOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response Delete(bool includeSnapshots, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<DeleteAsync>d__55")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> DeleteAsync(bool includeSnapshots, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<DeleteInternal>d__56")]
internal Task`1<Response> DeleteInternal(Nullable`1<bool> includeSnapshots, Nullable`1<ShareSnapshotsDeleteOption> shareSnapshotsDeleteOption, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareProperties> GetProperties(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetPropertiesAsync>d__58")]
public virtual Task`1<Response`1<ShareProperties>> GetPropertiesAsync(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareProperties> GetProperties(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetPropertiesAsync>d__60")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareProperties>> GetPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetPropertiesInternal>d__61")]
private Task`1<Response`1<ShareProperties>> GetPropertiesInternal(ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareInfo> SetProperties(ShareSetPropertiesOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetPropertiesAsync>d__63")]
public virtual Task`1<Response`1<ShareInfo>> SetPropertiesAsync(ShareSetPropertiesOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetPropertiesInternal>d__64")]
internal virtual Task`1<Response`1<ShareInfo>> SetPropertiesInternal(Nullable`1<int> quotaInGB, Nullable`1<ShareAccessTier> accessTier, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> enablePaidBursting, Nullable`1<long> paidBurstingMaxIops, Nullable`1<long> paidBurstingMaxBandwidthMibps, ShareFileRequestConditions conditions, string operationName, bool async, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareInfo> SetQuota(int quotaInGB, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetQuotaAsync>d__66")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareInfo>> SetQuotaAsync(int quotaInGB, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareInfo> SetQuota(int quotaInGB, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetQuotaAsync>d__68")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareInfo>> SetQuotaAsync(int quotaInGB, CancellationToken cancellationToken);
    public virtual Response`1<ShareInfo> SetMetadata(IDictionary`2<string, string> metadata, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetMetadataAsync>d__70")]
public virtual Task`1<Response`1<ShareInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareInfo> SetMetadata(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetMetadataAsync>d__72")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetMetadataInternal>d__73")]
private Task`1<Response`1<ShareInfo>> SetMetadataInternal(IDictionary`2<string, string> metadata, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<IEnumerable`1<ShareSignedIdentifier>> GetAccessPolicy(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetAccessPolicyAsync>d__75")]
public virtual Task`1<Response`1<IEnumerable`1<ShareSignedIdentifier>>> GetAccessPolicyAsync(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<IEnumerable`1<ShareSignedIdentifier>> GetAccessPolicy(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetAccessPolicyAsync>d__77")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<IEnumerable`1<ShareSignedIdentifier>>> GetAccessPolicyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetAccessPolicyInternal>d__78")]
private Task`1<Response`1<IEnumerable`1<ShareSignedIdentifier>>> GetAccessPolicyInternal(ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Response`1<ShareInfo> SetAccessPolicy(IEnumerable`1<ShareSignedIdentifier> permissions, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetAccessPolicyAsync>d__80")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Task`1<Response`1<ShareInfo>> SetAccessPolicyAsync(IEnumerable`1<ShareSignedIdentifier> permissions, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Response`1<ShareInfo> SetAccessPolicy(IEnumerable`1<ShareSignedIdentifier> permissions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetAccessPolicyAsync>d__82")]
[EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Task`1<Response`1<ShareInfo>> SetAccessPolicyAsync(IEnumerable`1<ShareSignedIdentifier> permissions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<SetAccessPolicyInternal>d__83")]
private Task`1<Response`1<ShareInfo>> SetAccessPolicyInternal(IEnumerable`1<ShareSignedIdentifier> permissions, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareStatistics> GetStatistics(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetStatisticsAsync>d__85")]
public virtual Task`1<Response`1<ShareStatistics>> GetStatisticsAsync(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareStatistics> GetStatistics(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetStatisticsAsync>d__87")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareStatistics>> GetStatisticsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetStatisticsInternal>d__88")]
private Task`1<Response`1<ShareStatistics>> GetStatisticsInternal(ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFilePermission> GetPermission(string filePermissionKey, Nullable`1<FilePermissionFormat> filePermissionFormat, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetPermissionAsync>d__90")]
public virtual Task`1<Response`1<ShareFilePermission>> GetPermissionAsync(string filePermissionKey, Nullable`1<FilePermissionFormat> filePermissionFormat, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<string> GetPermission(string filePermissionKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetPermissionAsync>d__92")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<string>> GetPermissionAsync(string filePermissionKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<GetPermissionInternal>d__93")]
private Task`1<Response`1<ShareFilePermission>> GetPermissionInternal(string filePermissionKey, Nullable`1<FilePermissionFormat> filePermissionFormat, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Response`1<PermissionInfo> CreatePermission(ShareFilePermission permission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreatePermissionAsync>d__95")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PermissionInfo>> CreatePermissionAsync(ShareFilePermission permission, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
[EditorBrowsableAttribute("1")]
public virtual Response`1<PermissionInfo> CreatePermission(string permission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreatePermissionAsync>d__97")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PermissionInfo>> CreatePermissionAsync(string permission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreatePermissionInternal>d__98")]
internal Task`1<Response`1<PermissionInfo>> CreatePermissionInternal(string permission, Nullable`1<FilePermissionFormat> permissionFormat, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareDirectoryClient> CreateDirectory(string directoryName, ShareDirectoryCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareDirectoryClient> CreateDirectory(string directoryName, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateDirectoryAsync>d__101")]
public virtual Task`1<Response`1<ShareDirectoryClient>> CreateDirectoryAsync(string directoryName, ShareDirectoryCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<CreateDirectoryAsync>d__102")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareDirectoryClient>> CreateDirectoryAsync(string directoryName, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    public virtual Response DeleteDirectory(string directoryName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareClient/<DeleteDirectoryAsync>d__104")]
public virtual Task`1<Response> DeleteDirectoryAsync(string directoryName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareSasPermissions permissions, DateTimeOffset expiresOn);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareSasPermissions permissions, DateTimeOffset expiresOn, String& stringToSign);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareSasBuilder builder);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareSasBuilder builder, String& stringToSign);
    protected internal virtual ShareServiceClient GetParentServiceClientCore();
}
internal class Azure.Storage.Files.Shares.ShareClientConfiguration : StorageClientConfiguration {
    [CompilerGeneratedAttribute]
private ShareClientOptions <ClientOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private ShareAudience <Audience>k__BackingField;
    public ShareClientOptions ClientOptions { get; internal set; }
    public TransferValidationOptions TransferValidation { get; internal set; }
    public ShareAudience Audience { get; internal set; }
    public ShareClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics, ShareClientOptions clientOptions);
    public ShareClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics, ShareClientOptions clientOptions);
    public ShareClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics, ShareClientOptions clientOptions);
    public ShareClientConfiguration(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics, ShareClientOptions clientOptions);
    internal ShareClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics, ShareClientOptions clientOptions);
    [CompilerGeneratedAttribute]
public ShareClientOptions get_ClientOptions();
    [CompilerGeneratedAttribute]
internal void set_ClientOptions(ShareClientOptions value);
    [CompilerGeneratedAttribute]
public TransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
internal void set_TransferValidation(TransferValidationOptions value);
    [CompilerGeneratedAttribute]
public ShareAudience get_Audience();
    [CompilerGeneratedAttribute]
internal void set_Audience(ShareAudience value);
}
public class Azure.Storage.Files.Shares.ShareClientOptions : ClientOptions {
    internal static ServiceVersion LatestVersion;
    [CompilerGeneratedAttribute]
private ServiceVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowTrailingDot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowSourceTrailingDot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareTokenIntent> <ShareTokenIntent>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShareAudience> <Audience>k__BackingField;
    public ServiceVersion Version { get; }
    public TransferValidationOptions TransferValidation { get; }
    public Nullable`1<bool> AllowTrailingDot { get; public set; }
    public Nullable`1<bool> AllowSourceTrailingDot { get; public set; }
    public Nullable`1<ShareTokenIntent> ShareTokenIntent { get; public set; }
    public Nullable`1<ShareAudience> Audience { get; public set; }
    public ShareClientOptions(ServiceVersion version);
    [CompilerGeneratedAttribute]
public ServiceVersion get_Version();
    [CompilerGeneratedAttribute]
public TransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowTrailingDot();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingDot(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowSourceTrailingDot();
    [CompilerGeneratedAttribute]
public void set_AllowSourceTrailingDot(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShareTokenIntent> get_ShareTokenIntent();
    [CompilerGeneratedAttribute]
public void set_ShareTokenIntent(Nullable`1<ShareTokenIntent> value);
    private void AddHeadersAndQueryParameters();
    [CompilerGeneratedAttribute]
public Nullable`1<ShareAudience> get_Audience();
    [CompilerGeneratedAttribute]
public void set_Audience(Nullable`1<ShareAudience> value);
}
internal class Azure.Storage.Files.Shares.ShareCreateHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ShareCreateHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareCreatePermissionHeaders : object {
    private Response _response;
    public string Version { get; }
    public string FilePermissionKey { get; }
    public ShareCreatePermissionHeaders(Response response);
    public string get_Version();
    public string get_FilePermissionKey();
}
internal class Azure.Storage.Files.Shares.ShareCreateSnapshotHeaders : object {
    private Response _response;
    public string Snapshot { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ShareCreateSnapshotHeaders(Response response);
    public string get_Snapshot();
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareDeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public ShareDeleteHeaders(Response response);
    public string get_Version();
}
public class Azure.Storage.Files.Shares.ShareDirectoryClient : object {
    private Uri _uri;
    private ShareClientConfiguration _clientConfiguration;
    private DirectoryRestClient _directoryRestClient;
    private string _accountName;
    private string _shareName;
    private string _name;
    private string _path;
    private ShareClient _parentShareClient;
    private ShareDirectoryClient _parentShareDirectoryClient;
    public Uri Uri { get; }
    internal ShareClientConfiguration ClientConfiguration { get; }
    internal DirectoryRestClient DirectoryRestClient { get; }
    public string AccountName { get; }
    public string ShareName { get; }
    public string Name { get; }
    public string Path { get; }
    public bool CanGenerateSasUri { get; }
    public ShareDirectoryClient(string connectionString, string shareName, string directoryPath);
    public ShareDirectoryClient(string connectionString, string shareName, string directoryPath, ShareClientOptions options);
    public ShareDirectoryClient(Uri directoryUri, ShareClientOptions options);
    public ShareDirectoryClient(Uri directoryUri, StorageSharedKeyCredential credential, ShareClientOptions options);
    public ShareDirectoryClient(Uri directoryUri, AzureSasCredential credential, ShareClientOptions options);
    public ShareDirectoryClient(Uri directoryUri, TokenCredential credential, ShareClientOptions options);
    internal ShareDirectoryClient(Uri directoryUri, ClientDiagnostics diagnostics, ShareClientOptions options);
    internal ShareDirectoryClient(Uri directoryUri, HttpPipelinePolicy authentication, ShareClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    internal ShareDirectoryClient(Uri directoryUri, ShareClientConfiguration clientConfiguration);
    public virtual Uri get_Uri();
    internal virtual ShareClientConfiguration get_ClientConfiguration();
    internal virtual DirectoryRestClient get_DirectoryRestClient();
    public virtual string get_AccountName();
    public virtual string get_ShareName();
    public virtual string get_Name();
    public virtual string get_Path();
    public virtual bool get_CanGenerateSasUri();
    private DirectoryRestClient BuildDirectoryRestClient(Uri uri);
    public virtual ShareDirectoryClient WithSnapshot(string snapshot);
    public virtual ShareFileClient GetFileClient(string fileName);
    public virtual ShareDirectoryClient GetSubdirectoryClient(string subdirectoryName);
    private void SetNameFieldsIfNull();
    public virtual Response`1<ShareDirectoryInfo> Create(ShareDirectoryCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareDirectoryInfo> Create(IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<CreateAsync>d__40")]
public virtual Task`1<Response`1<ShareDirectoryInfo>> CreateAsync(ShareDirectoryCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<CreateAsync>d__41")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareDirectoryInfo>> CreateAsync(IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<CreateInternal>d__42")]
internal Task`1<Response`1<ShareDirectoryInfo>> CreateInternal(IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareDirectoryInfo> CreateIfNotExists(ShareDirectoryCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareDirectoryInfo> CreateIfNotExists(IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<CreateIfNotExistsAsync>d__45")]
public virtual Task`1<Response`1<ShareDirectoryInfo>> CreateIfNotExistsAsync(ShareDirectoryCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<CreateIfNotExistsAsync>d__46")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareDirectoryInfo>> CreateIfNotExistsAsync(IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<CreateIfNotExistsInternal>d__47")]
internal Task`1<Response`1<ShareDirectoryInfo>> CreateIfNotExistsInternal(IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<bool> Exists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<ExistsAsync>d__49")]
public virtual Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<ExistsInternal>d__50")]
private Task`1<Response`1<bool>> ExistsInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<bool> DeleteIfExists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<DeleteIfExistsAsync>d__52")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<DeleteIfExistsInternal>d__53")]
internal Task`1<Response`1<bool>> DeleteIfExistsInternal(bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response Delete(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<DeleteAsync>d__55")]
public virtual Task`1<Response> DeleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<DeleteInternal>d__56")]
internal Task`1<Response> DeleteInternal(bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareDirectoryProperties> GetProperties(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<GetPropertiesAsync>d__58")]
public virtual Task`1<Response`1<ShareDirectoryProperties>> GetPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<GetPropertiesInternal>d__59")]
private Task`1<Response`1<ShareDirectoryProperties>> GetPropertiesInternal(bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareDirectoryInfo> SetHttpHeaders(ShareDirectorySetHttpHeadersOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<SetHttpHeadersAsync>d__61")]
public virtual Task`1<Response`1<ShareDirectoryInfo>> SetHttpHeadersAsync(ShareDirectorySetHttpHeadersOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareDirectoryInfo> SetHttpHeaders(FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<SetHttpHeadersAsync>d__63")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareDirectoryInfo>> SetHttpHeadersAsync(FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<SetHttpHeadersInternal>d__64")]
private Task`1<Response`1<ShareDirectoryInfo>> SetHttpHeadersInternal(FileSmbProperties smbProperties, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareDirectoryInfo> SetMetadata(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<SetMetadataAsync>d__66")]
public virtual Task`1<Response`1<ShareDirectoryInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<SetMetadataInternal>d__67")]
private Task`1<Response`1<ShareDirectoryInfo>> SetMetadataInternal(IDictionary`2<string, string> metadata, bool async, CancellationToken cancellationToken);
    public virtual Pageable`1<ShareFileItem> GetFilesAndDirectories(ShareDirectoryGetFilesAndDirectoriesOptions options, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<ShareFileItem> GetFilesAndDirectoriesAsync(ShareDirectoryGetFilesAndDirectoriesOptions options, CancellationToken cancellationToken);
    public virtual Pageable`1<ShareFileItem> GetFilesAndDirectories(string prefix, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<ShareFileItem> GetFilesAndDirectoriesAsync(string prefix, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<GetFilesAndDirectoriesInternal>d__72")]
internal Task`1<Response`1<ListFilesAndDirectoriesSegmentResponse>> GetFilesAndDirectoriesInternal(string marker, string prefix, Nullable`1<int> pageSizeHint, Nullable`1<ShareFileTraits> traits, Nullable`1<bool> includeExtendedInfo, bool async, CancellationToken cancellationToken);
    public virtual Pageable`1<ShareFileHandle> GetHandles(Nullable`1<bool> recursive, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<ShareFileHandle> GetHandlesAsync(Nullable`1<bool> recursive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<GetHandlesInternal>d__75")]
internal Task`1<Response`1<StorageHandlesSegment>> GetHandlesInternal(string marker, Nullable`1<int> maxResults, Nullable`1<bool> recursive, bool async, CancellationToken cancellationToken);
    public virtual Response`1<CloseHandlesResult> ForceCloseHandle(string handleId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<ForceCloseHandleAsync>d__77")]
public virtual Task`1<Response`1<CloseHandlesResult>> ForceCloseHandleAsync(string handleId, CancellationToken cancellationToken);
    public virtual CloseHandlesResult ForceCloseAllHandles(Nullable`1<bool> recursive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<ForceCloseAllHandlesAsync>d__79")]
public virtual Task`1<CloseHandlesResult> ForceCloseAllHandlesAsync(Nullable`1<bool> recursive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<ForceCloseAllHandlesInternal>d__80")]
private Task`1<CloseHandlesResult> ForceCloseAllHandlesInternal(Nullable`1<bool> recursive, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<ForceCloseHandlesInternal>d__81")]
private Task`1<Response`1<StorageClosedHandlesSegment>> ForceCloseHandlesInternal(string handleId, string marker, Nullable`1<bool> recursive, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareDirectoryClient> Rename(string destinationPath, ShareFileRenameOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<RenameAsync>d__83")]
public virtual Task`1<Response`1<ShareDirectoryClient>> RenameAsync(string destinationPath, ShareFileRenameOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<RenameInternal>d__84")]
private Task`1<Response`1<ShareDirectoryClient>> RenameInternal(string destinationPath, ShareFileRenameOptions options, bool async, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<ShareDirectoryClient> CreateSubdirectory(string subdirectoryName, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<CreateSubdirectoryAsync>d__86")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<ShareDirectoryClient>> CreateSubdirectoryAsync(string subdirectoryName, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response DeleteSubdirectory(string subdirectoryName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<DeleteSubdirectoryAsync>d__88")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response> DeleteSubdirectoryAsync(string subdirectoryName, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<ShareFileClient> CreateFile(string fileName, long maxSize, ShareFileHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileClient> CreateFile(string fileName, long maxSize, ShareFileHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<CreateFileAsync>d__91")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<ShareFileClient>> CreateFileAsync(string fileName, long maxSize, ShareFileHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<CreateFileAsync>d__92")]
[ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileClient>> CreateFileAsync(string fileName, long maxSize, ShareFileHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response DeleteFile(string fileName, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Response DeleteFile(string fileName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<DeleteFileAsync>d__95")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response> DeleteFileAsync(string fileName, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareDirectoryClient/<DeleteFileAsync>d__96")]
[ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> DeleteFileAsync(string fileName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareFileSasPermissions permissions, DateTimeOffset expiresOn);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareFileSasPermissions permissions, DateTimeOffset expiresOn, String& stringToSign);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareSasBuilder builder);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareSasBuilder builder, String& stringToSign);
    protected internal virtual ShareClient GetParentShareClientCore();
    protected internal virtual ShareDirectoryClient GetParentDirectoryClientCore();
}
internal static class Azure.Storage.Files.Shares.ShareErrors : object {
    public static JsonException InvalidPermissionJson(string json);
    public static InvalidOperationException FileOrShareMissing(string leaseClient, string fileClient, string shareClient);
    public static void AssertAlgorithmSupport(Nullable`1<StorageChecksumAlgorithm> algorithm);
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.ShareExtensions : object {
    [ExtensionAttribute]
internal static CloseHandlesResult ToCloseHandlesResult(Response`1<StorageClosedHandlesSegment> storageClosedHandlesSegment);
    internal static IEnumerable`1<ListFilesIncludeType> AsIncludeItems(Nullable`1<ShareFileTraits> traits);
    internal static IEnumerable`1<ListSharesIncludeType> AsIncludeItems(ShareTraits traits, ShareStates states);
    [ExtensionAttribute]
internal static string ToPermissionsString(ShareAccountSasPermissions permissions);
    [ExtensionAttribute]
internal static string ToPermissionsString(ShareFileSasPermissions permissions);
    [ExtensionAttribute]
internal static string ToPermissionsString(ShareSasPermissions permissions);
    internal static void AssertValidFilePermissionAndKey(string filePermission, string filePermissionKey);
    [ExtensionAttribute]
internal static string ToFileDateTimeString(Nullable`1<DateTimeOffset> dateTimeOffset);
    [ExtensionAttribute]
private static string ToFileDateTimeString(DateTimeOffset dateTimeOffset);
    [ExtensionAttribute]
internal static string ToShareEnableProtocolsString(Nullable`1<ShareProtocols> shareEnabledProtocols);
    [ExtensionAttribute]
internal static Nullable`1<DeleteSnapshotsOptionType> ToShareSnapshotsDeleteOptionInternal(Nullable`1<ShareSnapshotsDeleteOption> option);
    internal static Nullable`1<ShareProtocols> ToShareEnabledProtocols(string rawProtocols);
    [ExtensionAttribute]
internal static ShareDirectoryInfo ToShareDirectoryInfo(ResponseWithHeaders`1<DirectoryCreateHeaders> response);
    [ExtensionAttribute]
internal static ShareDirectoryProperties ToShareDirectoryProperties(ResponseWithHeaders`1<DirectoryGetPropertiesHeaders> response);
    [ExtensionAttribute]
internal static ShareDirectoryInfo ToShareDirectoryInfo(ResponseWithHeaders`1<DirectorySetPropertiesHeaders> response);
    [ExtensionAttribute]
internal static ShareDirectoryInfo ToShareDirectoryInfo(ResponseWithHeaders`1<DirectorySetMetadataHeaders> response);
    [ExtensionAttribute]
internal static StorageHandlesSegment ToStorageHandlesSegment(ListHandlesResponse listHandlesResponse);
    [ExtensionAttribute]
internal static List`1<ShareFileHandle> ToShareFileHandles(IReadOnlyList`1<HandleItem> handleItems);
    [ExtensionAttribute]
internal static ShareFileHandle ToShareFileHandle(HandleItem handleItem);
    [ExtensionAttribute]
internal static Nullable`1<ShareFileHandleAccessRights> ToShareFileHandleAccessRight(IReadOnlyList`1<AccessRight> accessRightList);
    [ExtensionAttribute]
internal static StorageClosedHandlesSegment ToStorageClosedHandlesSegment(ResponseWithHeaders`1<DirectoryForceCloseHandlesHeaders> response);
    [ExtensionAttribute]
internal static ShareFileInfo ToShareFileInfo(ResponseWithHeaders`1<FileCreateHeaders> response);
    [ExtensionAttribute]
internal static ShareFileCopyInfo ToShareFileCopyInfo(ResponseWithHeaders`1<FileStartCopyHeaders> response);
    [ExtensionAttribute]
internal static ShareFileProperties ToShareFileProperties(ResponseWithHeaders`1<FileGetPropertiesHeaders> response);
    [ExtensionAttribute]
internal static ShareFileInfo ToShareFileInfo(ResponseWithHeaders`1<FileSetHttpHeadersHeaders> response);
    [ExtensionAttribute]
internal static ShareFileInfo ToShareFileInfo(ResponseWithHeaders`1<FileSetMetadataHeaders> response);
    [ExtensionAttribute]
internal static ShareFileUploadInfo ToShareFileUploadInfo(ResponseWithHeaders`1<FileUploadRangeHeaders> response);
    [ExtensionAttribute]
internal static ShareFileUploadInfo ToShareFileUploadInfo(ResponseWithHeaders`1<FileUploadRangeFromURLHeaders> response);
    [ExtensionAttribute]
internal static ShareFileRangeInfo ToShareFileRangeInfo(ResponseWithHeaders`2<ShareFileRangeList, FileGetRangeListHeaders> response);
    [ExtensionAttribute]
internal static HttpRange ToHttpRange(FileRange fileRange);
    [ExtensionAttribute]
internal static HttpRange ToHttpRange(ClearRange clearRange);
    [ExtensionAttribute]
internal static StorageClosedHandlesSegment ToStorageClosedHandlesSegment(ResponseWithHeaders`1<FileForceCloseHandlesHeaders> response);
    [ExtensionAttribute]
internal static ShareFileLease ToShareFileLease(ResponseWithHeaders`1<FileAcquireLeaseHeaders> response);
    [ExtensionAttribute]
internal static ShareFileLease ToShareFileLease(ResponseWithHeaders`1<ShareAcquireLeaseHeaders> response);
    [ExtensionAttribute]
internal static FileLeaseReleaseInfo ToFileLeaseReleaseInfo(ResponseWithHeaders`1<FileReleaseLeaseHeaders> response);
    [ExtensionAttribute]
internal static FileLeaseReleaseInfo ToFileLeaseReleaseInfo(ResponseWithHeaders`1<ShareReleaseLeaseHeaders> response);
    [ExtensionAttribute]
internal static ShareFileLease ToShareFileLease(ResponseWithHeaders`1<FileChangeLeaseHeaders> response);
    [ExtensionAttribute]
internal static ShareFileLease ToShareFileLease(ResponseWithHeaders`1<ShareRenewLeaseHeaders> response);
    [ExtensionAttribute]
internal static ShareFileLease ToShareFileLease(ResponseWithHeaders`1<ShareChangeLeaseHeaders> response);
    [ExtensionAttribute]
internal static ShareFileLease ToShareFileLease(ResponseWithHeaders`1<FileBreakLeaseHeaders> response);
    [ExtensionAttribute]
internal static ShareFileLease ToShareFileLease(ResponseWithHeaders`1<ShareBreakLeaseHeaders> response);
    [ExtensionAttribute]
internal static ShareFileLease ToShareFileLease(ResponseWithHeaders`1<FileReleaseLeaseHeaders> response);
    [ExtensionAttribute]
internal static ShareInfo ToShareInfo(ResponseWithHeaders`1<ShareCreateHeaders> response);
    [ExtensionAttribute]
internal static ShareSnapshotInfo ToShareSnapshotInfo(ResponseWithHeaders`1<ShareCreateSnapshotHeaders> response);
    [ExtensionAttribute]
internal static ShareProperties ToShareProperties(ResponseWithHeaders`1<ShareGetPropertiesHeaders> response);
    [ExtensionAttribute]
internal static ShareInfo ToShareInfo(ResponseWithHeaders`1<ShareSetPropertiesHeaders> response);
    [ExtensionAttribute]
internal static ShareInfo ToShareInfo(ResponseWithHeaders`1<ShareSetMetadataHeaders> response);
    [ExtensionAttribute]
internal static ShareInfo ToShareInfo(ResponseWithHeaders`1<ShareSetAccessPolicyHeaders> response);
    [ExtensionAttribute]
internal static PermissionInfo ToPermissionInfo(ResponseWithHeaders`1<ShareCreatePermissionHeaders> response);
    [ExtensionAttribute]
internal static IEnumerable`1<ShareItem> ToShareItems(IReadOnlyList`1<ShareItemInternal> shareItemInternals);
    [ExtensionAttribute]
internal static ShareItem ToShareItem(ShareItemInternal shareItemInternal);
    internal static ShareProperties ToShareProperties(SharePropertiesInternal sharePropertiesInternal, IReadOnlyDictionary`2<string, string> rawMetadata);
    [ExtensionAttribute]
internal static ShareFileDownloadInfo ToShareFileDownloadInfo(ResponseWithHeaders`2<Stream, FileDownloadHeaders> response);
    [ExtensionAttribute]
internal static FileHttpHeaders ToFileHttpHeaders(ShareFileHttpHeaders shareFileHttpHeaders);
    [ExtensionAttribute]
internal static ShareFileItem ToShareFileItem(DirectoryItem directoryItem);
    [ExtensionAttribute]
internal static ShareFileItem ToShareFileItem(FileItem fileItem);
    [ExtensionAttribute]
internal static ShareFileItemProperties ToShareFileItemProperties(FileProperty fileProperty);
    [ExtensionAttribute]
internal static DateTimeOffset ExtractLastModified(ResponseHeaders responseHeaders);
    [ExtensionAttribute]
internal static Response`1<ShareFilePermission> ToShareFilePermission(ResponseWithHeaders`2<SharePermission, ShareGetPermissionHeaders> response);
}
public class Azure.Storage.Files.Shares.ShareFileClient : object {
    private Uri _uri;
    private ShareClientConfiguration _clientConfiguration;
    private FileRestClient _fileRestClient;
    private string _accountName;
    private string _shareName;
    private string _name;
    private string _path;
    private ShareClient _parentShareClient;
    private ShareDirectoryClient _parentShareDirectoryClient;
    public Uri Uri { get; }
    internal ShareClientConfiguration ClientConfiguration { get; }
    internal FileRestClient FileRestClient { get; }
    public string AccountName { get; }
    public string ShareName { get; }
    public string Name { get; }
    public string Path { get; }
    public bool CanGenerateSasUri { get; }
    public ShareFileClient(string connectionString, string shareName, string filePath);
    public ShareFileClient(string connectionString, string shareName, string filePath, ShareClientOptions options);
    public ShareFileClient(Uri fileUri, ShareClientOptions options);
    public ShareFileClient(Uri fileUri, StorageSharedKeyCredential credential, ShareClientOptions options);
    public ShareFileClient(Uri fileUri, AzureSasCredential credential, ShareClientOptions options);
    public ShareFileClient(Uri fileUri, TokenCredential credential, ShareClientOptions options);
    internal ShareFileClient(Uri fileUri, ClientDiagnostics diagnostics, ShareClientOptions options);
    internal ShareFileClient(Uri fileUri, HttpPipelinePolicy authentication, ShareClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    internal ShareFileClient(Uri fileUri, ShareClientConfiguration clientConfiguration);
    public virtual Uri get_Uri();
    internal virtual ShareClientConfiguration get_ClientConfiguration();
    internal virtual FileRestClient get_FileRestClient();
    public virtual string get_AccountName();
    public virtual string get_ShareName();
    public virtual string get_Name();
    public virtual string get_Path();
    public virtual bool get_CanGenerateSasUri();
    private FileRestClient BuildFileRestClient(Uri uri);
    public virtual ShareFileClient WithSnapshot(string shareSnapshot);
    private void SetNameFieldsIfNull();
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetCopyAuthorizationHeaderAsync>d__36")]
protected static Task`1<HttpAuthorization> GetCopyAuthorizationHeaderAsync(ShareFileClient client, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileInfo> Create(long maxSize, ShareFileCreateOptions options, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<CreateAsync>d__38")]
public virtual Task`1<Response`1<ShareFileInfo>> CreateAsync(long maxSize, ShareFileCreateOptions options, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileInfo> Create(long maxSize, ShareFileHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileInfo> Create(long maxSize, ShareFileHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<CreateAsync>d__41")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileInfo>> CreateAsync(long maxSize, ShareFileHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<CreateAsync>d__42")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileInfo>> CreateAsync(long maxSize, ShareFileHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<CreateInternal>d__43")]
private Task`1<Response`1<ShareFileInfo>> CreateInternal(long maxSize, ShareFileHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<bool> Exists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<ExistsAsync>d__45")]
public virtual Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<ExistsInternal>d__46")]
private Task`1<Response`1<bool>> ExistsInternal(bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<bool> DeleteIfExists(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<DeleteIfExistsAsync>d__48")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<DeleteIfExistsInternal>d__49")]
private Task`1<Response`1<bool>> DeleteIfExistsInternal(ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileCopyInfo> StartCopy(Uri sourceUri, ShareFileCopyOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileCopyInfo> StartCopy(Uri sourceUri, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, Nullable`1<PermissionCopyMode> filePermissionCopyMode, Nullable`1<bool> ignoreReadOnly, Nullable`1<bool> setArchiveAttribute, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileCopyInfo> StartCopy(Uri sourceUri, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<StartCopyAsync>d__53")]
public virtual Task`1<Response`1<ShareFileCopyInfo>> StartCopyAsync(Uri sourceUri, ShareFileCopyOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<StartCopyAsync>d__54")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileCopyInfo>> StartCopyAsync(Uri sourceUri, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, Nullable`1<PermissionCopyMode> filePermissionCopyMode, Nullable`1<bool> ignoreReadOnly, Nullable`1<bool> setArchiveAttribute, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<StartCopyAsync>d__55")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileCopyInfo>> StartCopyAsync(Uri sourceUri, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<StartCopyInternal>d__56")]
private Task`1<Response`1<ShareFileCopyInfo>> StartCopyInternal(Uri sourceUri, IDictionary`2<string, string> metadata, FileSmbProperties smbProperties, string filePermission, Nullable`1<PermissionCopyMode> filePermissionCopyMode, Nullable`1<bool> ignoreReadOnly, Nullable`1<bool> setArchiveAttribute, ShareFileRequestConditions conditions, Nullable`1<CopyableFileSmbProperties> copyableFileSmbProperties, bool async, CancellationToken cancellationToken);
    public virtual Response AbortCopy(string copyId, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response AbortCopy(string copyId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<AbortCopyAsync>d__59")]
public virtual Task`1<Response> AbortCopyAsync(string copyId, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<AbortCopyAsync>d__60")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> AbortCopyAsync(string copyId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<AbortCopyInternal>d__61")]
private Task`1<Response> AbortCopyInternal(string copyId, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileDownloadInfo> Download(ShareFileDownloadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<DownloadAsync>d__63")]
public virtual Task`1<Response`1<ShareFileDownloadInfo>> DownloadAsync(ShareFileDownloadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileDownloadInfo> Download(HttpRange range, bool rangeGetContentHash, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileDownloadInfo> Download(HttpRange range, bool rangeGetContentHash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<DownloadAsync>d__66")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileDownloadInfo>> DownloadAsync(HttpRange range, bool rangeGetContentHash, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<DownloadAsync>d__67")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileDownloadInfo>> DownloadAsync(HttpRange range, bool rangeGetContentHash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<DownloadInternal>d__68")]
private Task`1<Response`1<ShareFileDownloadInfo>> DownloadInternal(HttpRange range, DownloadTransferValidationOptions transferValidationOverride, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<StartDownloadAsync>d__69")]
private Task`1<ValueTuple`2<Response`1<ShareFileDownloadInfo>, Stream>> StartDownloadAsync(HttpRange range, DownloadTransferValidationOptions transferValidationOverride, ShareFileRequestConditions conditions, long startOffset, bool async, CancellationToken cancellationToken);
    public virtual Stream OpenRead(ShareFileOpenReadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<OpenReadAsync>d__71")]
public virtual Task`1<Stream> OpenReadAsync(ShareFileOpenReadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Stream OpenRead(long position, Nullable`1<int> bufferSize, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Stream OpenRead(bool allowfileModifications, long position, Nullable`1<int> bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<OpenReadAsync>d__74")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Stream> OpenReadAsync(long position, Nullable`1<int> bufferSize, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<OpenReadAsync>d__75")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Stream> OpenReadAsync(bool allowfileModifications, long position, Nullable`1<int> bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<OpenReadInteral>d__76")]
internal Task`1<Stream> OpenReadInteral(long position, Nullable`1<int> bufferSize, ShareFileRequestConditions conditions, bool allowModifications, DownloadTransferValidationOptions transferValidationOverride, bool async, CancellationToken cancellationToken);
    public virtual Response Delete(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response Delete(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<DeleteAsync>d__79")]
public virtual Task`1<Response> DeleteAsync(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<DeleteAsync>d__80")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> DeleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<DeleteInternal>d__81")]
private Task`1<Response> DeleteInternal(ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareFileProperties> GetProperties(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileProperties> GetProperties(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetPropertiesAsync>d__84")]
public virtual Task`1<Response`1<ShareFileProperties>> GetPropertiesAsync(ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetPropertiesAsync>d__85")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileProperties>> GetPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetPropertiesInternal>d__86")]
private Task`1<Response`1<ShareFileProperties>> GetPropertiesInternal(ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareFileInfo> SetHttpHeaders(ShareFileSetHttpHeadersOptions options, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<SetHttpHeadersAsync>d__88")]
public virtual Task`1<Response`1<ShareFileInfo>> SetHttpHeadersAsync(ShareFileSetHttpHeadersOptions options, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileInfo> SetHttpHeaders(Nullable`1<long> newSize, ShareFileHttpHeaders httpHeaders, FileSmbProperties smbProperties, string filePermission, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileInfo> SetHttpHeaders(Nullable`1<long> newSize, ShareFileHttpHeaders httpHeaders, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<SetHttpHeadersAsync>d__91")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileInfo>> SetHttpHeadersAsync(Nullable`1<long> newSize, ShareFileHttpHeaders httpHeaders, FileSmbProperties smbProperties, string filePermission, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<SetHttpHeadersAsync>d__92")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileInfo>> SetHttpHeadersAsync(Nullable`1<long> newSize, ShareFileHttpHeaders httpHeaders, FileSmbProperties smbProperties, string filePermission, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<SetHttpHeadersInternal>d__93")]
private Task`1<Response`1<ShareFileInfo>> SetHttpHeadersInternal(Nullable`1<long> newSize, ShareFileHttpHeaders httpHeaders, FileSmbProperties smbProperties, string filePermission, Nullable`1<FilePermissionFormat> filePermissionFormat, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileInfo> SetMetadata(IDictionary`2<string, string> metadata, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileInfo> SetMetadata(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<SetMetadataAsync>d__96")]
public virtual Task`1<Response`1<ShareFileInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<SetMetadataAsync>d__97")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<SetMetadataInternal>d__98")]
private Task`1<Response`1<ShareFileInfo>> SetMetadataInternal(IDictionary`2<string, string> metadata, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileUploadInfo> ClearRange(HttpRange range, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<ClearRangeAsync>d__100")]
public virtual Task`1<Response`1<ShareFileUploadInfo>> ClearRangeAsync(HttpRange range, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<ClearRangeInternal>d__101")]
private Task`1<Response`1<ShareFileUploadInfo>> ClearRangeInternal(HttpRange range, ShareFileRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileUploadInfo> UploadRange(HttpRange range, Stream content, ShareFileUploadRangeOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadRangeAsync>d__103")]
public virtual Task`1<Response`1<ShareFileUploadInfo>> UploadRangeAsync(HttpRange range, Stream content, ShareFileUploadRangeOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileUploadInfo> UploadRange(HttpRange range, Stream content, Byte[] transactionalContentHash, IProgress`1<long> progressHandler, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadRangeAsync>d__105")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileUploadInfo>> UploadRangeAsync(HttpRange range, Stream content, Byte[] transactionalContentHash, IProgress`1<long> progressHandler, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileUploadInfo> UploadRange(ShareFileRangeWriteType writeType, HttpRange range, Stream content, Byte[] transactionalContentHash, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadRangeAsync>d__107")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileUploadInfo>> UploadRangeAsync(ShareFileRangeWriteType writeType, HttpRange range, Stream content, Byte[] transactionalContentHash, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadRangeInternal>d__108")]
internal Task`1<Response`1<ShareFileUploadInfo>> UploadRangeInternal(HttpRange range, Stream content, UploadTransferValidationOptions transferValidationOverride, IProgress`1<long> progressHandler, ShareFileRequestConditions conditions, Nullable`1<FileLastWrittenMode> fileLastWrittenMode, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileUploadInfo> UploadRangeFromUri(Uri sourceUri, HttpRange range, HttpRange sourceRange, ShareFileUploadRangeFromUriOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadRangeFromUriAsync>d__110")]
public virtual Task`1<Response`1<ShareFileUploadInfo>> UploadRangeFromUriAsync(Uri sourceUri, HttpRange range, HttpRange sourceRange, ShareFileUploadRangeFromUriOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileUploadInfo> UploadRangeFromUri(Uri sourceUri, HttpRange range, HttpRange sourceRange, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileUploadInfo> UploadRangeFromUri(Uri sourceUri, HttpRange range, HttpRange sourceRange, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadRangeFromUriAsync>d__113")]
[EditorBrowsableAttribute("1")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<ShareFileUploadInfo>> UploadRangeFromUriAsync(Uri sourceUri, HttpRange range, HttpRange sourceRange, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadRangeFromUriAsync>d__114")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileUploadInfo>> UploadRangeFromUriAsync(Uri sourceUri, HttpRange range, HttpRange sourceRange, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadRangeFromUriInternal>d__115")]
private Task`1<Response`1<ShareFileUploadInfo>> UploadRangeFromUriInternal(Uri sourceUri, HttpRange range, HttpRange sourceRange, ShareFileRequestConditions conditions, HttpAuthorization sourceAuthentication, Nullable`1<FileLastWrittenMode> fileLastWrittenMode, bool async, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<ShareFileUploadInfo> Upload(Stream stream, ShareFileUploadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadAsync>d__117")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<ShareFileUploadInfo>> UploadAsync(Stream stream, ShareFileUploadOptions options, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileUploadInfo> Upload(Stream content, IProgress`1<long> progressHandler, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileUploadInfo> Upload(Stream content, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadAsync>d__120")]
[ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileUploadInfo>> UploadAsync(Stream content, IProgress`1<long> progressHandler, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadAsync>d__121")]
[ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileUploadInfo>> UploadAsync(Stream content, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<UploadInternal>d__122")]
internal Task`1<Response`1<ShareFileUploadInfo>> UploadInternal(Stream content, IProgress`1<long> progressHandler, ShareFileRequestConditions conditions, UploadTransferValidationOptions transferValidationOverride, StorageTransferOptions transferOptions, bool async, CancellationToken cancellationToken);
    internal PartitionedUploader`2<ShareFileUploadData, ShareFileUploadInfo> GetPartitionedUploader(StorageTransferOptions transferOptions, UploadTransferValidationOptions transferValidation, ArrayPool`1<byte> arrayPool, string operationName);
    internal static Behaviors<ShareFileUploadData, ShareFileUploadInfo> GetPartitionedUploaderBehaviors(ShareFileClient client);
    public virtual Response`1<ShareFileRangeInfo> GetRangeList(ShareFileGetRangeListOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetRangeListAsync>d__127")]
public virtual Task`1<Response`1<ShareFileRangeInfo>> GetRangeListAsync(ShareFileGetRangeListOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileRangeInfo> GetRangeList(HttpRange range, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileRangeInfo> GetRangeList(HttpRange range, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetRangeListAsync>d__130")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileRangeInfo>> GetRangeListAsync(HttpRange range, ShareFileRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetRangeListAsync>d__131")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileRangeInfo>> GetRangeListAsync(HttpRange range, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetRangeListInternal>d__132")]
private Task`1<Response`1<ShareFileRangeInfo>> GetRangeListInternal(Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, Nullable`1<bool> supportRename, ShareFileRequestConditions conditions, string operationName, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileRangeInfo> GetRangeListDiff(ShareFileGetRangeListDiffOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetRangeListDiffAsync>d__134")]
public virtual Task`1<Response`1<ShareFileRangeInfo>> GetRangeListDiffAsync(ShareFileGetRangeListDiffOptions options, CancellationToken cancellationToken);
    public virtual Pageable`1<ShareFileHandle> GetHandles(CancellationToken cancellationToken);
    public virtual AsyncPageable`1<ShareFileHandle> GetHandlesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<GetHandlesInternal>d__137")]
internal Task`1<Response`1<StorageHandlesSegment>> GetHandlesInternal(string marker, Nullable`1<int> maxResults, bool async, CancellationToken cancellationToken);
    public virtual Response`1<CloseHandlesResult> ForceCloseHandle(string handleId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<ForceCloseHandleAsync>d__139")]
public virtual Task`1<Response`1<CloseHandlesResult>> ForceCloseHandleAsync(string handleId, CancellationToken cancellationToken);
    public virtual CloseHandlesResult ForceCloseAllHandles(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<ForceCloseAllHandlesAsync>d__141")]
public virtual Task`1<CloseHandlesResult> ForceCloseAllHandlesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<ForceCloseAllHandlesInternal>d__142")]
private Task`1<CloseHandlesResult> ForceCloseAllHandlesInternal(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<ForceCloseHandlesInternal>d__143")]
private Task`1<Response`1<StorageClosedHandlesSegment>> ForceCloseHandlesInternal(string handleId, string marker, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<ShareFileClient> Rename(string destinationPath, ShareFileRenameOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<RenameAsync>d__145")]
public virtual Task`1<Response`1<ShareFileClient>> RenameAsync(string destinationPath, ShareFileRenameOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<RenameInternal>d__146")]
private Task`1<Response`1<ShareFileClient>> RenameInternal(string destinationPath, ShareFileRenameOptions options, bool async, CancellationToken cancellationToken);
    public virtual Stream OpenWrite(bool overwrite, long position, ShareFileOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<OpenWriteAsync>d__148")]
public virtual Task`1<Stream> OpenWriteAsync(bool overwrite, long position, ShareFileOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileClient/<OpenWriteInternal>d__149")]
private Task`1<Stream> OpenWriteInternal(bool overwrite, long position, ShareFileOpenWriteOptions options, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareFileSasPermissions permissions, DateTimeOffset expiresOn);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareFileSasPermissions permissions, DateTimeOffset expiresOn, String& stringToSign);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareSasBuilder builder);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Uri GenerateSasUri(ShareSasBuilder builder, String& stringToSign);
    protected internal virtual ShareClient GetParentShareClientCore();
    protected internal virtual ShareDirectoryClient GetParentShareDirectoryClientCore();
}
internal class Azure.Storage.Files.Shares.ShareFileWriteStream : StorageWriteStream {
    private ShareFileClient _fileClient;
    private ShareFileRequestConditions _conditions;
    private long _writeIndex;
    public ShareFileWriteStream(ShareFileClient fileClient, long bufferSize, long position, ShareFileRequestConditions conditions, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidation);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareFileWriteStream/<AppendInternal>d__4")]
protected virtual Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    protected virtual void ValidateBufferSize(long bufferSize);
}
internal class Azure.Storage.Files.Shares.ShareGetAccessPolicyHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ShareGetAccessPolicyHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareGetPermissionHeaders : object {
    private Response _response;
    public string Version { get; }
    public ShareGetPermissionHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareGetPropertiesHeaders : object {
    private Response _response;
    public IDictionary`2<string, string> Metadata { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public Nullable`1<int> Quota { get; }
    public Nullable`1<int> ProvisionedIops { get; }
    public Nullable`1<int> ProvisionedIngressMBps { get; }
    public Nullable`1<int> ProvisionedEgressMBps { get; }
    public Nullable`1<DateTimeOffset> NextAllowedQuotaDowngradeTime { get; }
    public Nullable`1<int> ProvisionedBandwidthMibps { get; }
    public Nullable`1<ShareLeaseDuration> LeaseDuration { get; }
    public Nullable`1<ShareLeaseState> LeaseState { get; }
    public Nullable`1<ShareLeaseStatus> LeaseStatus { get; }
    public string AccessTier { get; }
    public Nullable`1<DateTimeOffset> AccessTierChangeTime { get; }
    public string AccessTierTransitionState { get; }
    public string EnabledProtocols { get; }
    public Nullable`1<ShareRootSquash> RootSquash { get; }
    public Nullable`1<bool> EnableSnapshotVirtualDirectoryAccess { get; }
    public Nullable`1<bool> PaidBurstingEnabled { get; }
    public Nullable`1<long> PaidBurstingMaxIops { get; }
    public Nullable`1<long> PaidBurstingMaxBandwidthMibps { get; }
    public ShareGetPropertiesHeaders(Response response);
    public IDictionary`2<string, string> get_Metadata();
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public Nullable`1<int> get_Quota();
    public Nullable`1<int> get_ProvisionedIops();
    public Nullable`1<int> get_ProvisionedIngressMBps();
    public Nullable`1<int> get_ProvisionedEgressMBps();
    public Nullable`1<DateTimeOffset> get_NextAllowedQuotaDowngradeTime();
    public Nullable`1<int> get_ProvisionedBandwidthMibps();
    public Nullable`1<ShareLeaseDuration> get_LeaseDuration();
    public Nullable`1<ShareLeaseState> get_LeaseState();
    public Nullable`1<ShareLeaseStatus> get_LeaseStatus();
    public string get_AccessTier();
    public Nullable`1<DateTimeOffset> get_AccessTierChangeTime();
    public string get_AccessTierTransitionState();
    public string get_EnabledProtocols();
    public Nullable`1<ShareRootSquash> get_RootSquash();
    public Nullable`1<bool> get_EnableSnapshotVirtualDirectoryAccess();
    public Nullable`1<bool> get_PaidBurstingEnabled();
    public Nullable`1<long> get_PaidBurstingMaxIops();
    public Nullable`1<long> get_PaidBurstingMaxBandwidthMibps();
}
internal class Azure.Storage.Files.Shares.ShareGetStatisticsHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ShareGetStatisticsHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
[ExtensionAttribute]
internal static class Azure.Storage.Files.Shares.ShareModelExtensions : object {
    [ExtensionAttribute]
public static string ToAttributesString(NtfsFileAttributes attributes);
    private static void AppendAttribute(string attributeName, StringBuilder stringBuilder);
    public static Nullable`1<NtfsFileAttributes> ToFileAttributes(string attributesString);
}
internal class Azure.Storage.Files.Shares.ShareReleaseLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ShareReleaseLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareRenewLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public ShareRenewLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    private Nullable`1<ShareTokenIntent> _fileRequestIntent;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public ShareRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version, Nullable`1<ShareTokenIntent> fileRequestIntent);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateCreateRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<int> quota, Nullable`1<ShareAccessTier> accessTier, string enabledProtocols, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> paidBurstingEnabled, Nullable`1<long> paidBurstingMaxBandwidthMibps, Nullable`1<long> paidBurstingMaxIops);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<CreateAsync>d__9")]
public Task`1<ResponseWithHeaders`1<ShareCreateHeaders>> CreateAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<int> quota, Nullable`1<ShareAccessTier> accessTier, string enabledProtocols, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> paidBurstingEnabled, Nullable`1<long> paidBurstingMaxBandwidthMibps, Nullable`1<long> paidBurstingMaxIops, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareCreateHeaders> Create(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<int> quota, Nullable`1<ShareAccessTier> accessTier, string enabledProtocols, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> paidBurstingEnabled, Nullable`1<long> paidBurstingMaxBandwidthMibps, Nullable`1<long> paidBurstingMaxIops, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(string sharesnapshot, Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<GetPropertiesAsync>d__12")]
public Task`1<ResponseWithHeaders`1<ShareGetPropertiesHeaders>> GetPropertiesAsync(string sharesnapshot, Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareGetPropertiesHeaders> GetProperties(string sharesnapshot, Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateDeleteRequest(string sharesnapshot, Nullable`1<int> timeout, Nullable`1<DeleteSnapshotsOptionType> deleteSnapshots, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<DeleteAsync>d__15")]
public Task`1<ResponseWithHeaders`1<ShareDeleteHeaders>> DeleteAsync(string sharesnapshot, Nullable`1<int> timeout, Nullable`1<DeleteSnapshotsOptionType> deleteSnapshots, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareDeleteHeaders> Delete(string sharesnapshot, Nullable`1<int> timeout, Nullable`1<DeleteSnapshotsOptionType> deleteSnapshots, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<int> duration, string proposedLeaseId, string sharesnapshot);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<AcquireLeaseAsync>d__18")]
public Task`1<ResponseWithHeaders`1<ShareAcquireLeaseHeaders>> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<int> duration, string proposedLeaseId, string sharesnapshot, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareAcquireLeaseHeaders> AcquireLease(Nullable`1<int> timeout, Nullable`1<int> duration, string proposedLeaseId, string sharesnapshot, CancellationToken cancellationToken);
    internal HttpMessage CreateReleaseLeaseRequest(string leaseId, Nullable`1<int> timeout, string sharesnapshot);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<ReleaseLeaseAsync>d__21")]
public Task`1<ResponseWithHeaders`1<ShareReleaseLeaseHeaders>> ReleaseLeaseAsync(string leaseId, Nullable`1<int> timeout, string sharesnapshot, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareReleaseLeaseHeaders> ReleaseLease(string leaseId, Nullable`1<int> timeout, string sharesnapshot, CancellationToken cancellationToken);
    internal HttpMessage CreateChangeLeaseRequest(string leaseId, Nullable`1<int> timeout, string proposedLeaseId, string sharesnapshot);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<ChangeLeaseAsync>d__24")]
public Task`1<ResponseWithHeaders`1<ShareChangeLeaseHeaders>> ChangeLeaseAsync(string leaseId, Nullable`1<int> timeout, string proposedLeaseId, string sharesnapshot, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareChangeLeaseHeaders> ChangeLease(string leaseId, Nullable`1<int> timeout, string proposedLeaseId, string sharesnapshot, CancellationToken cancellationToken);
    internal HttpMessage CreateRenewLeaseRequest(string leaseId, Nullable`1<int> timeout, string sharesnapshot);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<RenewLeaseAsync>d__27")]
public Task`1<ResponseWithHeaders`1<ShareRenewLeaseHeaders>> RenewLeaseAsync(string leaseId, Nullable`1<int> timeout, string sharesnapshot, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareRenewLeaseHeaders> RenewLease(string leaseId, Nullable`1<int> timeout, string sharesnapshot, CancellationToken cancellationToken);
    internal HttpMessage CreateBreakLeaseRequest(Nullable`1<int> timeout, Nullable`1<int> breakPeriod, string sharesnapshot, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<BreakLeaseAsync>d__30")]
public Task`1<ResponseWithHeaders`1<ShareBreakLeaseHeaders>> BreakLeaseAsync(Nullable`1<int> timeout, Nullable`1<int> breakPeriod, string sharesnapshot, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareBreakLeaseHeaders> BreakLease(Nullable`1<int> timeout, Nullable`1<int> breakPeriod, string sharesnapshot, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateCreateSnapshotRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<CreateSnapshotAsync>d__33")]
public Task`1<ResponseWithHeaders`1<ShareCreateSnapshotHeaders>> CreateSnapshotAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareCreateSnapshotHeaders> CreateSnapshot(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    internal HttpMessage CreateCreatePermissionRequest(SharePermission sharePermission, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<CreatePermissionAsync>d__36")]
public Task`1<ResponseWithHeaders`1<ShareCreatePermissionHeaders>> CreatePermissionAsync(SharePermission sharePermission, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareCreatePermissionHeaders> CreatePermission(SharePermission sharePermission, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPermissionRequest(string filePermissionKey, Nullable`1<FilePermissionFormat> filePermissionFormat, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<GetPermissionAsync>d__39")]
public Task`1<ResponseWithHeaders`2<SharePermission, ShareGetPermissionHeaders>> GetPermissionAsync(string filePermissionKey, Nullable`1<FilePermissionFormat> filePermissionFormat, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<SharePermission, ShareGetPermissionHeaders> GetPermission(string filePermissionKey, Nullable`1<FilePermissionFormat> filePermissionFormat, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateSetPropertiesRequest(Nullable`1<int> timeout, Nullable`1<int> quota, Nullable`1<ShareAccessTier> accessTier, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> paidBurstingEnabled, Nullable`1<long> paidBurstingMaxBandwidthMibps, Nullable`1<long> paidBurstingMaxIops, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<SetPropertiesAsync>d__42")]
public Task`1<ResponseWithHeaders`1<ShareSetPropertiesHeaders>> SetPropertiesAsync(Nullable`1<int> timeout, Nullable`1<int> quota, Nullable`1<ShareAccessTier> accessTier, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> paidBurstingEnabled, Nullable`1<long> paidBurstingMaxBandwidthMibps, Nullable`1<long> paidBurstingMaxIops, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareSetPropertiesHeaders> SetProperties(Nullable`1<int> timeout, Nullable`1<int> quota, Nullable`1<ShareAccessTier> accessTier, Nullable`1<ShareRootSquash> rootSquash, Nullable`1<bool> enableSnapshotVirtualDirectoryAccess, Nullable`1<bool> paidBurstingEnabled, Nullable`1<long> paidBurstingMaxBandwidthMibps, Nullable`1<long> paidBurstingMaxIops, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateSetMetadataRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<SetMetadataAsync>d__45")]
public Task`1<ResponseWithHeaders`1<ShareSetMetadataHeaders>> SetMetadataAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareSetMetadataHeaders> SetMetadata(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateGetAccessPolicyRequest(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<GetAccessPolicyAsync>d__48")]
public Task`1<ResponseWithHeaders`2<IReadOnlyList`1<ShareSignedIdentifier>, ShareGetAccessPolicyHeaders>> GetAccessPolicyAsync(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<IReadOnlyList`1<ShareSignedIdentifier>, ShareGetAccessPolicyHeaders> GetAccessPolicy(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateSetAccessPolicyRequest(Nullable`1<int> timeout, IEnumerable`1<ShareSignedIdentifier> shareAcl, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<SetAccessPolicyAsync>d__51")]
public Task`1<ResponseWithHeaders`1<ShareSetAccessPolicyHeaders>> SetAccessPolicyAsync(Nullable`1<int> timeout, IEnumerable`1<ShareSignedIdentifier> shareAcl, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareSetAccessPolicyHeaders> SetAccessPolicy(Nullable`1<int> timeout, IEnumerable`1<ShareSignedIdentifier> shareAcl, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateGetStatisticsRequest(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<GetStatisticsAsync>d__54")]
public Task`1<ResponseWithHeaders`2<ShareStatistics, ShareGetStatisticsHeaders>> GetStatisticsAsync(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ShareStatistics, ShareGetStatisticsHeaders> GetStatistics(Nullable`1<int> timeout, ShareFileRequestConditions shareFileRequestConditions, CancellationToken cancellationToken);
    internal HttpMessage CreateRestoreRequest(Nullable`1<int> timeout, string deletedShareName, string deletedShareVersion);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareRestClient/<RestoreAsync>d__57")]
public Task`1<ResponseWithHeaders`1<ShareRestoreHeaders>> RestoreAsync(Nullable`1<int> timeout, string deletedShareName, string deletedShareVersion, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ShareRestoreHeaders> Restore(Nullable`1<int> timeout, string deletedShareName, string deletedShareVersion, CancellationToken cancellationToken);
}
internal class Azure.Storage.Files.Shares.ShareRestoreHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ShareRestoreHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
public class Azure.Storage.Files.Shares.ShareServiceClient : object {
    private Uri _uri;
    private ShareClientConfiguration _clientConfiguration;
    private ServiceRestClient _serviceRestClient;
    private string _accountName;
    public Uri Uri { get; }
    internal ShareClientConfiguration ClientConfiguration { get; }
    internal ServiceRestClient ServiceRestClient { get; }
    public string AccountName { get; }
    public bool CanGenerateAccountSasUri { get; }
    public ShareServiceClient(string connectionString);
    public ShareServiceClient(string connectionString, ShareClientOptions options);
    public ShareServiceClient(Uri serviceUri, ShareClientOptions options);
    public ShareServiceClient(Uri serviceUri, StorageSharedKeyCredential credential, ShareClientOptions options);
    public ShareServiceClient(Uri serviceUri, AzureSasCredential credential, ShareClientOptions options);
    internal ShareServiceClient(Uri directoryUri, ShareClientConfiguration clientConfiguration);
    public ShareServiceClient(Uri serviceUri, TokenCredential credential, ShareClientOptions options);
    internal ShareServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, ShareClientOptions options, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    public virtual Uri get_Uri();
    internal virtual ShareClientConfiguration get_ClientConfiguration();
    internal virtual ServiceRestClient get_ServiceRestClient();
    public virtual string get_AccountName();
    public virtual bool get_CanGenerateAccountSasUri();
    private ServiceRestClient BuildServiceRestClient();
    public virtual ShareClient GetShareClient(string shareName);
    public virtual Pageable`1<ShareItem> GetShares(ShareTraits traits, ShareStates states, string prefix, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<ShareItem> GetSharesAsync(ShareTraits traits, ShareStates states, string prefix, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<GetSharesInternal>d__27")]
internal Task`1<Response`1<ListSharesResponse>> GetSharesInternal(string marker, ShareTraits traits, ShareStates states, string prefix, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareServiceProperties> GetProperties(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<GetPropertiesAsync>d__29")]
public virtual Task`1<Response`1<ShareServiceProperties>> GetPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<GetPropertiesInternal>d__30")]
private Task`1<Response`1<ShareServiceProperties>> GetPropertiesInternal(bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Response SetProperties(ShareServiceProperties properties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<SetPropertiesAsync>d__32")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public virtual Task`1<Response> SetPropertiesAsync(ShareServiceProperties properties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<SetPropertiesInternal>d__33")]
private Task`1<Response> SetPropertiesInternal(ShareServiceProperties properties, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareClient> CreateShare(string shareName, ShareCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<CreateShareAsync>d__35")]
public virtual Task`1<Response`1<ShareClient>> CreateShareAsync(string shareName, ShareCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareClient> CreateShare(string shareName, IDictionary`2<string, string> metadata, Nullable`1<int> quotaInGB, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<CreateShareAsync>d__37")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareClient>> CreateShareAsync(string shareName, IDictionary`2<string, string> metadata, Nullable`1<int> quotaInGB, CancellationToken cancellationToken);
    public virtual Response DeleteShare(string shareName, ShareDeleteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<DeleteShareAsync>d__39")]
public virtual Task`1<Response> DeleteShareAsync(string shareName, ShareDeleteOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response DeleteShare(string shareName, bool includeSnapshots, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<DeleteShareAsync>d__41")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> DeleteShareAsync(string shareName, bool includeSnapshots, CancellationToken cancellationToken);
    public virtual Response`1<ShareClient> UndeleteShare(string deletedShareName, string deletedShareVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<UndeleteShareAsync>d__43")]
public virtual Task`1<Response`1<ShareClient>> UndeleteShareAsync(string deletedShareName, string deletedShareVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.ShareServiceClient/<UndeleteShareInternal>d__44")]
private Task`1<Response`1<ShareClient>> UndeleteShareInternal(string deletedShareName, string deletedShareVersion, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public Uri GenerateAccountSasUri(AccountSasPermissions permissions, DateTimeOffset expiresOn, AccountSasResourceTypes resourceTypes);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public Uri GenerateAccountSasUri(AccountSasPermissions permissions, DateTimeOffset expiresOn, AccountSasResourceTypes resourceTypes, String& stringToSign);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public Uri GenerateAccountSasUri(AccountSasBuilder builder);
    [EditorBrowsableAttribute("1")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public Uri GenerateAccountSasUri(AccountSasBuilder builder, String& stringToSign);
}
internal class Azure.Storage.Files.Shares.ShareSetAccessPolicyHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ShareSetAccessPolicyHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareSetMetadataHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ShareSetMetadataHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Files.Shares.ShareSetPropertiesHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ShareSetPropertiesHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
public class Azure.Storage.Files.Shares.ShareUriBuilder : object {
    private Uri _uri;
    private bool _isPathStyleUri;
    private string _scheme;
    private string _host;
    private int _port;
    private string _accountName;
    private string _shareName;
    private string _directoryOrFilePath;
    private string _snapshot;
    private SasQueryParameters _sas;
    private string _query;
    public string Scheme { get; public set; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public string AccountName { get; public set; }
    public string ShareName { get; public set; }
    public string DirectoryOrFilePath { get; public set; }
    public string Snapshot { get; public set; }
    public SasQueryParameters Sas { get; public set; }
    internal string LastDirectoryOrFileName { get; }
    public string Query { get; public set; }
    public ShareUriBuilder(Uri uri);
    public string get_Scheme();
    public void set_Scheme(string value);
    public string get_Host();
    public void set_Host(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_AccountName();
    public void set_AccountName(string value);
    public string get_ShareName();
    public void set_ShareName(string value);
    public string get_DirectoryOrFilePath();
    public void set_DirectoryOrFilePath(string value);
    public string get_Snapshot();
    public void set_Snapshot(string value);
    public SasQueryParameters get_Sas();
    public void set_Sas(SasQueryParameters value);
    internal string get_LastDirectoryOrFileName();
    public string get_Query();
    public void set_Query(string value);
    public Uri ToUri();
    public virtual string ToString();
    private void ResetUri();
    private RequestUriBuilder BuildUri();
}
public class Azure.Storage.Files.Shares.Specialized.ShareLeaseClient : object {
    private ShareFileClient _file;
    private ShareClient _share;
    private string _leaseId;
    public static TimeSpan InfiniteLeaseDuration;
    protected ShareFileClient FileClient { get; }
    protected ShareClient ShareClient { get; }
    public Uri Uri { get; }
    public string LeaseId { get; private set; }
    internal ShareClientConfiguration ClientConfiguration { get; }
    public ShareLeaseClient(ShareFileClient client, string leaseId);
    public ShareLeaseClient(ShareClient client, string leaseId);
    private static ShareLeaseClient();
    protected virtual ShareFileClient get_FileClient();
    protected virtual ShareClient get_ShareClient();
    public Uri get_Uri();
    public virtual string get_LeaseId();
    private void set_LeaseId(string value);
    internal virtual ShareClientConfiguration get_ClientConfiguration();
    private static string CreateUniqueLeaseId();
    private void EnsureClient();
    public virtual Response`1<ShareFileLease> Acquire(Nullable`1<TimeSpan> duration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<AcquireAsync>d__21")]
public virtual Task`1<Response`1<ShareFileLease>> AcquireAsync(Nullable`1<TimeSpan> duration, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<ShareFileLease> Acquire(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<AcquireAsync>d__23")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ShareFileLease>> AcquireAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<AcquireInternal>d__24")]
private Task`1<Response`1<ShareFileLease>> AcquireInternal(Nullable`1<TimeSpan> duration, bool async, CancellationToken cancellationToken);
    public virtual Response`1<FileLeaseReleaseInfo> Release(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<ReleaseAsync>d__26")]
public virtual Task`1<Response`1<FileLeaseReleaseInfo>> ReleaseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<ReleaseInternal>d__27")]
internal virtual Task`1<Response`1<FileLeaseReleaseInfo>> ReleaseInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileLease> Change(string proposedId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<ChangeAsync>d__29")]
public virtual Task`1<Response`1<ShareFileLease>> ChangeAsync(string proposedId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<ChangeInternal>d__30")]
private Task`1<Response`1<ShareFileLease>> ChangeInternal(string proposedId, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileLease> Break(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<BreakAsync>d__32")]
public virtual Task`1<Response`1<ShareFileLease>> BreakAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<BreakInternal>d__33")]
private Task`1<Response`1<ShareFileLease>> BreakInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<ShareFileLease> Renew(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<RenewAsync>d__35")]
public virtual Task`1<Response`1<ShareFileLease>> RenewAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Files.Shares.Specialized.ShareLeaseClient/<RenewInternal>d__36")]
private Task`1<Response`1<ShareFileLease>> RenewInternal(bool async, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Azure.Storage.Files.Shares.Specialized.SpecializedFileExtensions : object {
    [ExtensionAttribute]
public static ShareLeaseClient GetShareLeaseClient(ShareFileClient client, string leaseId);
    [ExtensionAttribute]
public static ShareLeaseClient GetShareLeaseClient(ShareClient client, string leaseId);
}
[ExtensionAttribute]
public static class Azure.Storage.Files.Shares.Specialized.SpecializedShareExtensions : object {
    [ExtensionAttribute]
public static ShareServiceClient GetParentServiceClient(ShareClient client);
    [ExtensionAttribute]
public static ShareClient GetParentShareClient(ShareDirectoryClient client);
    [ExtensionAttribute]
public static ShareDirectoryClient GetParentDirectoryClient(ShareDirectoryClient client);
    [ExtensionAttribute]
public static ShareClient GetParentShareClient(ShareFileClient client);
    [ExtensionAttribute]
public static ShareDirectoryClient GetParentShareDirectoryClient(ShareFileClient client);
}
internal class Azure.Storage.GeoRedundantReadPolicy : HttpPipelineSynchronousPolicy {
    private string _secondaryStorageHost;
    public GeoRedundantReadPolicy(Uri secondaryStorageUri);
    public virtual void OnSendingRequest(HttpMessage message);
}
internal class Azure.Storage.HashAlgorithmHasher : object {
    private HashAlgorithm _hashAlgorithm;
    public int HashSizeInBytes { get; }
    public HashAlgorithmHasher(HashAlgorithm hashAlgorithm);
    public sealed virtual int get_HashSizeInBytes();
    [AsyncStateMachineAttribute("Azure.Storage.HashAlgorithmHasher/<ComputeHashInternal>d__4")]
public sealed virtual Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);
    public sealed virtual void AppendHash(ReadOnlySpan`1<byte> content);
    public sealed virtual int GetFinalHash(Span`1<byte> hashDestination);
    public sealed virtual void Dispose();
    private static int BitsToBytes(int bits);
}
internal interface Azure.Storage.IHasher {
    public int HashSizeInBytes { get; }
    public abstract virtual int get_HashSizeInBytes();
    public abstract virtual Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);
    public abstract virtual void AppendHash(ReadOnlySpan`1<byte> content);
    public abstract virtual int GetFinalHash(Span`1<byte> hashDestination);
}
[ExtensionAttribute]
internal static class Azure.Storage.IHasherExtensions : object {
    [ExtensionAttribute]
public static Memory`1<byte> GetFinalHash(IHasher hasher);
}
internal class Azure.Storage.LazyLoadingReadOnlyStream`1 : Stream {
    private long _position;
    private long _length;
    private int _bufferSize;
    private Byte[] _buffer;
    private int _bufferPosition;
    private int _bufferLength;
    private bool _allowBlobModifications;
    private bool _bufferInvalidated;
    private DownloadInternalAsync<TProperties> _downloadInternalFunc;
    private GetPropertiesAsync<TProperties> _getPropertiesInternalFunc;
    private DownloadTransferValidationOptions _validationOptions;
    private PredictEncryptedRangeAdjustment<TProperties> _predictEncryptedRangeAdjustment;
    public static PredictEncryptedRangeAdjustment<TProperties> NoRangeAdjustment { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LazyLoadingReadOnlyStream`1(DownloadInternalAsync<TProperties> downloadInternalFunc, GetPropertiesAsync<TProperties> getPropertiesFunc, DownloadTransferValidationOptions transferValidation, bool allowModifications, long initialLenght, long position, Nullable`1<int> bufferSize, PredictEncryptedRangeAdjustment<TProperties> rangePredictionFunc);
    public static PredictEncryptedRangeAdjustment<TProperties> get_NoRangeAdjustment();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.LazyLoadingReadOnlyStream`1/<ReadAsync>d__19")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.LazyLoadingReadOnlyStream`1/<ReadInternal>d__20")]
public Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.LazyLoadingReadOnlyStream`1/<DownloadInternal>d__21")]
private Task`1<int> DownloadInternal(bool async, CancellationToken cancellationToken);
    private static void ValidateReadParameters(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Azure.Storage.LazyLoadingReadOnlyStream`1/<GetBlobLengthInternal>d__24")]
private Task`1<long> GetBlobLengthInternal(bool async, CancellationToken cancellationToken);
    private static long GetBlobLengthFromResponse(Response response);
    private static HttpRange GetResponseRange(Response response);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    internal long CalculateNewPosition(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Azure.Storage.LoggingExtensions : object {
    [ExtensionAttribute]
public static IDisposable BeginLoggingScope(HttpPipeline pipeline, string className, string member);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogMethodEnter(HttpPipeline pipeline, string className, string member, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogMethodExit(HttpPipeline pipeline, string className, string member, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogException(HttpPipeline pipeline, Exception ex, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogTrace(HttpPipeline pipeline, string message);
}
internal class Azure.Storage.NonCryptographicHashAlgorithmHasher : object {
    private static int _streamBufferSize;
    private NonCryptographicHashAlgorithm _nonCryptographicHashAlgorithm;
    public int HashSizeInBytes { get; }
    public NonCryptographicHashAlgorithmHasher(NonCryptographicHashAlgorithm nonCryptographicHashAlgorithm);
    public sealed virtual int get_HashSizeInBytes();
    [AsyncStateMachineAttribute("Azure.Storage.NonCryptographicHashAlgorithmHasher/<ComputeHashInternal>d__5")]
public sealed virtual Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);
    public sealed virtual void AppendHash(ReadOnlySpan`1<byte> content);
    public sealed virtual int GetFinalHash(Span`1<byte> hashDestination);
    public sealed virtual void Dispose();
}
internal class Azure.Storage.NonDisposingStream : Stream {
    private Stream _innerStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public NonDisposingStream(Stream innerStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
}
internal class Azure.Storage.PartitionedUploader`2 : object {
    public static InitializeDestinationInternal<TServiceSpecificData, TCompleteUploadReturn> InitializeNoOp;
    private InitializeDestinationInternal<TServiceSpecificData, TCompleteUploadReturn> _initializeDestinationInternal;
    private SingleUploadStreamingInternal<TServiceSpecificData, TCompleteUploadReturn> _singleUploadStreamingInternal;
    private SingleUploadBinaryDataInternal<TServiceSpecificData, TCompleteUploadReturn> _singleUploadBinaryDataInternal;
    private UploadPartitionStreamingInternal<TServiceSpecificData, TCompleteUploadReturn> _uploadPartitionStreamingInternal;
    private UploadPartitionBinaryDataInternal<TServiceSpecificData, TCompleteUploadReturn> _uploadPartitionBinaryDataInternal;
    private CommitPartitionedUploadInternal<TServiceSpecificData, TCompleteUploadReturn> _commitPartitionedUploadInternal;
    private CreateScope<TServiceSpecificData, TCompleteUploadReturn> _createScope;
    private int _maxWorkerCount;
    private ArrayPool`1<byte> _arrayPool;
    private long _singleUploadThreshold;
    private Nullable`1<long> _blockSize;
    private StorageChecksumAlgorithm _validationAlgorithm;
    private Func`1<Memory`1<byte>> _masterCrcSupplier;
    private string _operationName;
    private bool UseMasterCrc { get; }
    private UploadTransferValidationOptions ValidationOptions { get; }
    public PartitionedUploader`2(Behaviors<TServiceSpecificData, TCompleteUploadReturn> behaviors, StorageTransferOptions transferOptions, UploadTransferValidationOptions transferValidation, ArrayPool`1<byte> arrayPool, string operationName);
    private static PartitionedUploader`2();
    private bool get_UseMasterCrc();
    private UploadTransferValidationOptions get_ValidationOptions();
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInternal>d__32")]
public Task`1<Response`1<TCompleteUploadReturn>> UploadInternal(BinaryData content, TServiceSpecificData args, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInternal>d__33")]
public Task`1<Response`1<TCompleteUploadReturn>> UploadInternal(Stream content, Nullable`1<long> expectedContentLength, TServiceSpecificData args, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<BufferAndOptionalChecksumStreamInternal>d__34")]
private Task`1<ValueTuple`2<Stream, UploadTransferValidationOptions>> BufferAndOptionalChecksumStreamInternal(Stream source, long minCount, long maxCount, UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInSequenceInternal>d__35`1")]
private Task`1<Response`1<TCompleteUploadReturn>> UploadInSequenceInternal(TContent content, Nullable`1<long> contentLength, long partitionSize, TServiceSpecificData args, IProgress`1<long> progressHandler, GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> partitionContentAsync, StageContentPartitionAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> stageContentAsync, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInParallelAsync>d__36`1")]
private Task`1<Response`1<TCompleteUploadReturn>> UploadInParallelAsync(TContent content, Nullable`1<long> contentLength, long blockSize, TServiceSpecificData args, IProgress`1<long> progressHandler, GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> partitionContentAsync, StageContentPartitionAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> stageContentAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<StageStreamPartitionInternal>d__37")]
private Task StageStreamPartitionInternal(Stream partition, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<StageBinaryDataPartitionInternal>d__38")]
private Task StageBinaryDataPartitionInternal(BinaryData content, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetContentPartitionsBinaryDataInternal>d__39")]
private IAsyncEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, BinaryData>> GetContentPartitionsBinaryDataInternal(BinaryData content, Nullable`1<long> contentLength, long blockSize, bool async, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetBinaryDataPartitions>d__40")]
private IEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, BinaryData>> GetBinaryDataPartitions(BinaryData content, int blockSize);
    private static GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, Stream> GetStreamPartitioner(GetNextStreamPartition<TServiceSpecificData, TCompleteUploadReturn> partitionCreator);
    [AsyncIteratorStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetStreamPartitionsAsync>d__42")]
private static IAsyncEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, Stream>> GetStreamPartitionsAsync(Stream stream, Nullable`1<long> streamLength, long blockSize, GetNextStreamPartition<TServiceSpecificData, TCompleteUploadReturn> getNextPartition, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetBufferedPartitionInternal>d__43")]
private Task`1<ValueTuple`2<Stream, ReadOnlyMemory`1<byte>>> GetBufferedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetStreamedPartitionInternal>d__44")]
private Task`1<ValueTuple`2<Stream, ReadOnlyMemory`1<byte>>> GetStreamedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Azure.Storage.PathExtensions : object {
    [ExtensionAttribute]
public static string GetParentPath(string path, char delimiter);
}
internal class Azure.Storage.ProgressIncrementingStream : Stream {
    private Stream _innerStream;
    private AggregatingProgressIncrementer _incrementer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public ProgressIncrementingStream(Stream stream, AggregatingProgressIncrementer incrementer);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Azure.Storage.ProgressIncrementingStream/<FlushAsync>d__12")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ProgressIncrementingStream/<ReadAsync>d__20")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ProgressIncrementingStream/<WriteAsync>d__28")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
[ExtensionAttribute]
internal static class Azure.Storage.Sas.SasExtensions : object {
    private static string NoneName;
    private static string HttpsName;
    private static string HttpsAndHttpName;
    private static string HttpAndHttpsName;
    [ExtensionAttribute]
internal static string ToPermissionsString(AccountSasResourceTypes resourceTypes);
    internal static AccountSasResourceTypes ParseResourceTypes(string s);
    [ExtensionAttribute]
internal static string ToProtocolString(SasProtocol protocol);
    public static SasProtocol ParseProtocol(string s);
    [ExtensionAttribute]
internal static string ToPermissionsString(AccountSasServices services);
    internal static AccountSasServices ParseAccountServices(string s);
    internal static string FormatTimesForSasSigning(DateTimeOffset time);
    internal static void AddToBuilder(StringBuilder sb, string key, string value);
    internal static string ValidateAndSanitizeRawPermissions(string permissions, List`1<char> validPermissionsInOrder);
}
internal class Azure.Storage.Sas.SasQueryParametersInternals : SasQueryParameters {
    [CompilerGeneratedAttribute]
private static string <DefaultSasVersionInternal>k__BackingField;
    internal static string DefaultSasVersionInternal { get; internal set; }
    private static SasQueryParametersInternals();
    [CompilerGeneratedAttribute]
internal static string get_DefaultSasVersionInternal();
    [CompilerGeneratedAttribute]
internal static void set_DefaultSasVersionInternal(string value);
    internal static SasQueryParameters Create(IDictionary`2<string, string> values);
    internal static SasQueryParameters Create(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth, string encryptionScope);
}
[FlagsAttribute]
public enum Azure.Storage.Sas.ShareAccountSasPermissions : Enum {
    public int value__;
    public static ShareAccountSasPermissions Read;
    public static ShareAccountSasPermissions Add;
    public static ShareAccountSasPermissions Create;
    public static ShareAccountSasPermissions Write;
    public static ShareAccountSasPermissions Delete;
    public static ShareAccountSasPermissions List;
    public static ShareAccountSasPermissions All;
}
[FlagsAttribute]
public enum Azure.Storage.Sas.ShareFileSasPermissions : Enum {
    public int value__;
    public static ShareFileSasPermissions Read;
    public static ShareFileSasPermissions Create;
    public static ShareFileSasPermissions Write;
    public static ShareFileSasPermissions Delete;
    public static ShareFileSasPermissions All;
}
public class Azure.Storage.Sas.ShareSasBuilder : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SasProtocol <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private SasIPRange <IPRange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShareName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    private static List`1<char> s_validPermissionsInOrder;
    [EditorBrowsableAttribute("1")]
public string Version { get; public set; }
    public SasProtocol Protocol { get; public set; }
    public DateTimeOffset StartsOn { get; public set; }
    public DateTimeOffset ExpiresOn { get; public set; }
    public string Permissions { get; private set; }
    public SasIPRange IPRange { get; public set; }
    public string Identifier { get; public set; }
    public string ShareName { get; public set; }
    public string FilePath { get; public set; }
    public string Resource { get; public set; }
    public string CacheControl { get; public set; }
    public string ContentDisposition { get; public set; }
    public string ContentEncoding { get; public set; }
    public string ContentLanguage { get; public set; }
    public string ContentType { get; public set; }
    public ShareSasBuilder(ShareFileSasPermissions permissions, DateTimeOffset expiresOn);
    public ShareSasBuilder(ShareSasPermissions permissions, DateTimeOffset expiresOn);
    private static ShareSasBuilder();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public SasProtocol get_Protocol();
    [CompilerGeneratedAttribute]
public void set_Protocol(SasProtocol value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartsOn();
    [CompilerGeneratedAttribute]
public void set_StartsOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
private void set_Permissions(string value);
    [CompilerGeneratedAttribute]
public SasIPRange get_IPRange();
    [CompilerGeneratedAttribute]
public void set_IPRange(SasIPRange value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public string get_ShareName();
    [CompilerGeneratedAttribute]
public void set_ShareName(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
public void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    public void SetPermissions(ShareFileSasPermissions permissions);
    public void SetPermissions(ShareAccountSasPermissions permissions);
    public void SetPermissions(ShareSasPermissions permissions);
    public void SetPermissions(string rawPermissions, bool normalize);
    public void SetPermissions(string rawPermissions);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public SasQueryParameters ToSasQueryParameters(StorageSharedKeyCredential sharedKeyCredential);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/storage-files-shares")]
public SasQueryParameters ToSasQueryParameters(StorageSharedKeyCredential sharedKeyCredential, String& stringToSign);
    private string ToStringToSign(StorageSharedKeyCredential sharedKeyCredential);
    private static string GetCanonicalName(string account, string shareName, string filePath);
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private void EnsureState();
    internal static ShareSasBuilder DeepCopy(ShareSasBuilder originalShareSasBuilder);
}
[FlagsAttribute]
public enum Azure.Storage.Sas.ShareSasPermissions : Enum {
    public int value__;
    public static ShareSasPermissions Read;
    public static ShareSasPermissions Create;
    public static ShareSasPermissions Write;
    public static ShareSasPermissions Delete;
    public static ShareSasPermissions List;
    public static ShareSasPermissions All;
}
internal interface Azure.Storage.Shared.IDownloadedContent {
    public Stream Content { get; }
    public abstract virtual Stream get_Content();
}
internal interface Azure.Storage.Shared.ISupportsTenantIdChallenges {
    public bool EnableTenantDiscovery { get; }
    public abstract virtual bool get_EnableTenantDiscovery();
}
internal class Azure.Storage.Shared.PooledMemoryStream : Stream {
    private static int DefaultMaxArrayPoolRentalSize;
    [CompilerGeneratedAttribute]
private int <MaxArraySize>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayPool`1<byte> <ArrayPool>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BufferPartition> <BufferSet>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public int MaxArraySize { get; }
    public ArrayPool`1<byte> ArrayPool { get; }
    private List`1<BufferPartition> BufferSet { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PooledMemoryStream(ArrayPool`1<byte> arrayPool, int maxArraySize);
    [CompilerGeneratedAttribute]
public int get_MaxArraySize();
    [CompilerGeneratedAttribute]
public ArrayPool`1<byte> get_ArrayPool();
    [CompilerGeneratedAttribute]
private List`1<BufferPartition> get_BufferSet();
    [AsyncStateMachineAttribute("Azure.Storage.Shared.PooledMemoryStream/<BufferStreamPartitionInternal>d__13")]
internal static Task`1<PooledMemoryStream> BufferStreamPartitionInternal(Stream stream, long minCount, long maxCount, ArrayPool`1<byte> arrayPool, Nullable`1<int> maxArrayPoolRentalSize, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.PooledMemoryStream/<ReadLoopInternal>d__14")]
private static Task`1<int> ReadLoopInternal(Stream stream, Byte[] buffer, int offset, int minCount, int maxCount, bool async, CancellationToken cancellationToken);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
public virtual long get_Position();
    [CompilerGeneratedAttribute]
public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private ValueTuple`3<Byte[], int, long> GetBufferFromPosition();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    public void Clear();
    private void AssertPositionInBounds();
    private BufferPartition GetLatestBufferWithAvailableSpaceOrDefault();
    private static long Min(long val1, long val2, long val3);
}
internal class Azure.Storage.Shared.StorageClientConfiguration : object {
    [CompilerGeneratedAttribute]
private HttpPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageSharedKeyCredential <SharedKeyCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCredential <TokenCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureSasCredential <SasCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    public HttpPipeline Pipeline { get; private set; }
    public StorageSharedKeyCredential SharedKeyCredential { get; private set; }
    public TokenCredential TokenCredential { get; private set; }
    public AzureSasCredential SasCredential { get; private set; }
    public ClientDiagnostics ClientDiagnostics { get; private set; }
    public StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics);
    public StorageClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics);
    public StorageClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics);
    internal StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics);
    internal StorageClientConfiguration(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics);
    [CompilerGeneratedAttribute]
public virtual HttpPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
private void set_Pipeline(HttpPipeline value);
    [CompilerGeneratedAttribute]
public virtual StorageSharedKeyCredential get_SharedKeyCredential();
    [CompilerGeneratedAttribute]
private void set_SharedKeyCredential(StorageSharedKeyCredential value);
    [CompilerGeneratedAttribute]
public virtual TokenCredential get_TokenCredential();
    [CompilerGeneratedAttribute]
private void set_TokenCredential(TokenCredential value);
    [CompilerGeneratedAttribute]
public virtual AzureSasCredential get_SasCredential();
    [CompilerGeneratedAttribute]
private void set_SasCredential(AzureSasCredential value);
    [CompilerGeneratedAttribute]
public virtual ClientDiagnostics get_ClientDiagnostics();
    [CompilerGeneratedAttribute]
private void set_ClientDiagnostics(ClientDiagnostics value);
}
[ExtensionAttribute]
internal static class Azure.Storage.Shared.StorageExtensions : object {
    [ExtensionAttribute]
public static string EscapePath(string path, bool trimOuterSlashes);
    [ExtensionAttribute]
public static string UnescapePath(string path, bool trimOuterSlashes);
    public static string GenerateBlockId(long offset);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageExtensions/<GetCopyAuthorizationHeaderAsync>d__3")]
[ExtensionAttribute]
public static Task`1<HttpAuthorization> GetCopyAuthorizationHeaderAsync(TokenCredential tokenCredential, CancellationToken cancellationToken);
    public static IDisposable CreateClientSideEncryptionScope(ClientSideEncryptionVersion version);
}
internal abstract class Azure.Storage.Shared.StorageWriteStream : Stream {
    protected long _position;
    protected long _bufferSize;
    protected IProgress`1<long> _progressHandler;
    protected PooledMemoryStream _buffer;
    private ArrayPool`1<byte> _bufferPool;
    private StorageChecksumAlgorithm _checksumAlgorithm;
    private StorageCrc64HashAlgorithm _masterCrcChecksummer;
    private Memory`1<byte> _composedCrc;
    private Memory`1<byte> _userProvidedChecksum;
    private IHasher _bufferChecksumer;
    private bool _disposed;
    private DisposableBucket _accumulatedDisposables;
    private bool UseMasterCrc { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected StorageWriteStream(long position, long bufferSize, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidation, PooledMemoryStream buffer, ArrayPool`1<byte> bufferPool);
    private bool get_UseMasterCrc();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<WriteAsync>d__30")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<WriteInternal>d__31")]
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<FlushAsync>d__33")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<FlushInternal>d__34")]
private Task FlushInternal(bool async, CancellationToken cancellationToken);
    protected virtual Task CommitInternal(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<AppendAndClearBufferInternal>d__36")]
private Task AppendAndClearBufferInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    protected abstract virtual Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    protected abstract virtual void ValidateBufferSize(long bufferSize);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<WriteToBufferInternal>d__39")]
protected Task WriteToBufferInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    protected static void ValidateWriteParameters(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void ValidateCallerCrcIfAny();
    protected IDisposable FinalizeAndReplaceBufferChecksum(UploadTransferValidationOptions& validationOptions);
}
[ExtensionAttribute]
internal static class Azure.Storage.Shared.StreamExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<long> GetPositionOrDefault(Stream content);
}
internal abstract class Azure.Storage.Shared.WindowStream : Stream {
    [CompilerGeneratedAttribute]
private Stream <InnerStream>k__BackingField;
    private Stream InnerStream { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    private WindowStream(Stream stream);
    [CompilerGeneratedAttribute]
private Stream get_InnerStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public static Stream GetWindow(Stream stream, long maxWindowLength);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.WindowStream/<ReadAsync>d__14")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.WindowStream/<ReadInternal>d__15")]
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    protected abstract virtual int AdjustCount(int count);
    protected abstract virtual void ReportInnerStreamRead(int resultRead);
}
internal class Azure.Storage.SharedAccessSignatureCredentials : object {
    [CompilerGeneratedAttribute]
private string <SasToken>k__BackingField;
    public string SasToken { get; }
    public SharedAccessSignatureCredentials(string sasToken);
    [CompilerGeneratedAttribute]
public string get_SasToken();
}
internal static class Azure.Storage.StorageArgument : object {
    public static StorageTransferOptions PopulateShareFileUploadTransferOptionDefaults(StorageTransferOptions value);
    public static void AssertShareFileUploadTransferOptionBounds(StorageTransferOptions value, string name);
    public static void AssertTransferOptionsDefined(StorageTransferOptions value, string name);
    public static void AssertTransferOptionsDefinedInBounds(StorageTransferOptions value, string name, long upperBoundInitial, long upperBoundMaximum, int upperBoundConcurrency);
}
internal class Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy : BearerTokenAuthenticationPolicy {
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _scopes;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) tenantId;
    private bool _enableTenantDiscovery;
    public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, string scope, bool enableTenantDiscovery);
    public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, IEnumerable`1<string> scopes, bool enableTenantDiscovery);
    protected virtual void AuthorizeRequest(HttpMessage message);
    protected virtual ValueTask AuthorizeRequestAsync(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy/<AuthorizeRequestInternal>d__7")]
private ValueTask AuthorizeRequestInternal(HttpMessage message, bool async);
    protected virtual bool AuthorizeRequestOnChallenge(HttpMessage message);
    protected virtual ValueTask`1<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy/<AuthorizeRequestOnChallengeInternalAsync>d__10")]
private ValueTask`1<bool> AuthorizeRequestOnChallengeInternalAsync(HttpMessage message, bool async);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageClientOptions : object {
    private static string StorageScope;
    [ExtensionAttribute]
public static void Initialize(ClientOptions options);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(StorageSharedKeyCredential credential);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(AzureSasCredential credential, Uri resourceUri);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(TokenCredential credential, string scope, ClientOptions options);
    public static HttpPipelinePolicy GetAuthenticationPolicy(object credentials, string scope, ClientOptions options);
    [ExtensionAttribute]
public static HttpPipeline Build(ClientOptions options, HttpPipelinePolicy authentication, Uri geoRedundantSecondaryStorageUri, Request100ContinueOptions expectContinue);
    [ExtensionAttribute]
public static HttpPipeline Build(ClientOptions options, object credentials, Uri geoRedundantSecondaryStorageUri, Request100ContinueOptions expectContinue);
}
internal abstract class Azure.Storage.StorageCollectionEnumerator`1 : object {
    public abstract virtual ValueTask`1<Page`1<T>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    public Pageable`1<T> ToSyncCollection(CancellationToken cancellationToken);
    public AsyncPageable`1<T> ToAsyncCollection(CancellationToken cancellationToken);
}
internal class Azure.Storage.StorageConnectionString : object {
    private static KeyValuePair`2<string, Func`2<string, bool>> s_useDevelopmentStorageSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_developmentStorageProxyUriSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_defaultEndpointsProtocolSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountNameSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountKeyNameSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountKeySetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_blobEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_queueEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_fileEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_tableEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_blobSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_queueSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_fileSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_tableSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_endpointSuffixSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_sharedAccessSignatureSetting;
    private static StorageConnectionString s_devStoreAccount;
    [CompilerGeneratedAttribute]
private bool <IsDevStoreAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultEndpoints>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <BlobStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <QueueStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <TableStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <FileStorageUri>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Credentials>k__BackingField;
    internal string _accountName;
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> s_validCredentials;
    internal static bool UseV1MD5 { get; }
    public static StorageConnectionString DevelopmentStorageAccount { get; }
    internal bool IsDevStoreAccount { get; internal set; }
    internal string EndpointSuffix { get; internal set; }
    internal IDictionary`2<string, string> Settings { get; internal set; }
    internal bool DefaultEndpoints { get; internal set; }
    public Uri BlobEndpoint { get; }
    public Uri QueueEndpoint { get; }
    public Uri TableEndpoint { get; }
    public Uri FileEndpoint { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> BlobStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> QueueStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> TableStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> FileStorageUri { get; public set; }
    public object Credentials { get; public set; }
    public StorageConnectionString(object storageCredentials, ValueTuple`2<Uri, Uri> blobStorageUri, ValueTuple`2<Uri, Uri> queueStorageUri, ValueTuple`2<Uri, Uri> tableStorageUri, ValueTuple`2<Uri, Uri> fileStorageUri);
    private static StorageConnectionString();
    internal static bool get_UseV1MD5();
    public static StorageConnectionString get_DevelopmentStorageAccount();
    [CompilerGeneratedAttribute]
internal bool get_IsDevStoreAccount();
    [CompilerGeneratedAttribute]
internal void set_IsDevStoreAccount(bool value);
    [CompilerGeneratedAttribute]
internal string get_EndpointSuffix();
    [CompilerGeneratedAttribute]
internal void set_EndpointSuffix(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
internal bool get_DefaultEndpoints();
    [CompilerGeneratedAttribute]
internal void set_DefaultEndpoints(bool value);
    public Uri get_BlobEndpoint();
    public Uri get_QueueEndpoint();
    public Uri get_TableEndpoint();
    public Uri get_FileEndpoint();
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_BlobStorageUri();
    [CompilerGeneratedAttribute]
public void set_BlobStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_QueueStorageUri();
    [CompilerGeneratedAttribute]
public void set_QueueStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_TableStorageUri();
    [CompilerGeneratedAttribute]
public void set_TableStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_FileStorageUri();
    [CompilerGeneratedAttribute]
public void set_FileStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public object get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(object value);
    public static StorageConnectionString Parse(string connectionString);
    public static bool TryParse(string connectionString, StorageConnectionString& account);
    private static StorageConnectionString GetDevelopmentStorageAccount(Uri proxyUri);
    internal static bool ParseCore(string connectionString, StorageConnectionString& accountInformation, Action`1<string> error);
    private static IDictionary`2<string, string> ParseStringIntoSettings(string connectionString, Action`1<string> error);
    private static KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, String[] validValues);
    private static KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, Func`2<string, bool> isValid);
    private static bool IsValidBase64String(string settingValue);
    private static bool IsValidUri(string settingValue);
    private static bool IsValidDomain(string settingValue);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AllRequired(KeyValuePair`2[] requiredSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> Optional(KeyValuePair`2[] optionalSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AtLeastOne(KeyValuePair`2[] atLeastOneSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> None(KeyValuePair`2[] atLeastOneSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesAll(Func`2[] filters);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesOne(Func`2[] filters);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesExactly(Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> filter);
    private static bool MatchesSpecification(IDictionary`2<string, string> settings, Func`2[] constraints);
    private static object GetCredentials(IDictionary`2<string, string> settings);
    private static ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructFileEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructFileEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructTableEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructTableEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructUris(string scheme, string accountName, string hostNamePrefix, string endpointSuffix, string sasToken);
    [CompilerGeneratedAttribute]
internal static string <ParseCore>g__settingOrDefault|70_0(string key, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
internal static bool <ParseCore>g__s_isValidEndpointPair|70_1(string primary, string secondary);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<Uri, Uri> <ParseCore>g__createStorageUri|70_2(string primary, string secondary, string sasToken, Func`2<IDictionary`2<string, string>, ValueTuple`2<Uri, Uri>> factory, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
internal static Uri <ParseCore>g__CreateUri|70_3(string endpoint, string sasToken);
}
internal static class Azure.Storage.StorageCrc64Calculator : object {
    private static ulong poly;
    private static UInt64[] m_u1;
    private static UInt64[] m_u32;
    private static UInt64[] m_uX2N;
    private static ulong m_uComplement;
    private static int m_uBitWidth;
    private static StorageCrc64Calculator();
    public static ulong ComputeSlicedSafe(ReadOnlySpan`1<byte> src, ulong uCrc);
    internal static ulong Concatenate(ulong uInitialCrcAB, ulong uInitialCrcA, ulong uFinalCrcA, ulong uSizeA, ulong uInitialCrcB, ulong uFinalCrcB, ulong uSizeB);
    private static ulong MulX_N(ulong a, ulong uSize);
    private static ulong MulPoly(ulong a, ulong b);
    private static ulong MulPolyUnrolled(ulong a, ulong b);
}
internal static class Azure.Storage.StorageCrc64Composer : object {
    public static Memory`1<byte> Compose(ValueTuple`2[] partitions);
    public static Memory`1<byte> Compose(IEnumerable`1<ValueTuple`2<Byte[], long>> partitions);
    public static ulong Compose(IEnumerable`1<ValueTuple`2<ulong, long>> partitions);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageExceptionExtensions : object {
    [ExtensionAttribute]
public static string GetErrorCode(Response response, string errorCode);
    [ExtensionAttribute]
public static bool IsUnavailable(Response`1<T> response);
    [ExtensionAttribute]
public static Response`1<T> AsNoBodyResponse(Response rawResponse);
}
internal class Azure.Storage.StorageMemoryPool : MemoryPool`1<byte> {
    private ArrayPool`1<byte> _arrayPool;
    [CompilerGeneratedAttribute]
private int <MaxBufferSize>k__BackingField;
    public int MaxBufferSize { get; }
    public StorageMemoryPool(int maxArrayLength, int maxArraysPerBucket);
    [CompilerGeneratedAttribute]
public virtual int get_MaxBufferSize();
    public virtual IMemoryOwner`1<byte> Rent(int minBufferSize);
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageProgressExtensions : object {
    [ExtensionAttribute]
public static Stream WithProgress(Stream stream, IProgress`1<long> progressHandler);
}
internal class Azure.Storage.StorageRequestValidationPipelinePolicy : HttpPipelineSynchronousPolicy {
    public virtual void OnReceivedResponse(HttpMessage message);
}
internal class Azure.Storage.StorageResponseClassifier : ResponseClassifier {
    [CompilerGeneratedAttribute]
private Uri <SecondaryStorageUri>k__BackingField;
    public Uri SecondaryStorageUri { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_SecondaryStorageUri();
    [CompilerGeneratedAttribute]
public void set_SecondaryStorageUri(Uri value);
    public virtual bool IsRetriableResponse(HttpMessage message);
    public virtual bool IsErrorResponse(HttpMessage message);
}
internal class Azure.Storage.StorageServerTimeoutPolicy : HttpPipelineSynchronousPolicy {
    private static string QueryParameterKeyWithEqualSign;
    [CompilerGeneratedAttribute]
private static StorageServerTimeoutPolicy <Shared>k__BackingField;
    public static StorageServerTimeoutPolicy Shared { get; }
    private static StorageServerTimeoutPolicy();
    [CompilerGeneratedAttribute]
public static StorageServerTimeoutPolicy get_Shared();
    public virtual void OnSendingRequest(HttpMessage message);
}
internal class Azure.Storage.StorageSharedKeyCredentialInternals : StorageSharedKeyCredential {
    private StorageSharedKeyCredentialInternals(string accountName, string accountKey);
    internal static string ComputeSasSignature(StorageSharedKeyCredential credential, string message);
}
internal class Azure.Storage.StorageSharedKeyPipelinePolicy : HttpPipelineSynchronousPolicy {
    private static bool IncludeXMsDate;
    private StorageSharedKeyCredential _credentials;
    private static HeaderComparer s_headerComparer;
    public StorageSharedKeyPipelinePolicy(StorageSharedKeyCredential credentials);
    private static StorageSharedKeyPipelinePolicy();
    public virtual void OnSendingRequest(HttpMessage message);
    private string BuildStringToSign(HttpMessage message);
    private static void BuildCanonicalizedHeaders(StringBuilder stringBuilder, HttpMessage message);
    private void BuildCanonicalizedResource(StringBuilder stringBuilder, Uri resource);
}
internal class Azure.Storage.StorageTelemetryPolicy : HttpPipelineSynchronousPolicy {
    private static string CseIdentifierV2;
    private static string CseIdentifierV1;
    [CompilerGeneratedAttribute]
private static StorageTelemetryPolicy <Shared>k__BackingField;
    public static StorageTelemetryPolicy Shared { get; }
    private static StorageTelemetryPolicy();
    [CompilerGeneratedAttribute]
public static StorageTelemetryPolicy get_Shared();
    public virtual void OnSendingRequest(HttpMessage message);
    private static void ApplyAzFeatures(HttpMessage message, AzFeatures azFeatures);
    private static string Serialize(AzFeatures azFeatures);
    private static string TransformUserAgent(string userAgent, string injection);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageVersionExtensions : object {
    public static ServiceVersion LatestVersion;
    internal static ServiceVersion MaxVersion;
    [ExtensionAttribute]
public static string ToVersionString(ServiceVersion version);
}
[ExtensionAttribute]
internal static class Azure.Storage.StreamExtensions : object {
    [ExtensionAttribute]
public static Stream WithNoDispose(Stream stream);
    [ExtensionAttribute]
public static Nullable`1<long> GetLengthOrDefault(Stream content);
    [AsyncStateMachineAttribute("Azure.Storage.StreamExtensions/<ReadInternal>d__2")]
[ExtensionAttribute]
public static Task`1<int> ReadInternal(Stream stream, Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.StreamExtensions/<WriteInternal>d__3")]
[ExtensionAttribute]
public static Task WriteInternal(Stream stream, Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task CopyToInternal(Stream src, Stream dest, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.StreamExtensions/<CopyToInternal>d__5")]
[ExtensionAttribute]
public static Task CopyToInternal(Stream src, Stream dest, int bufferSize, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.StreamPartition : Stream {
    private Action _disposeAction;
    private ReadOnlyMemory`1<byte> _memory;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    private long _position;
    [CompilerGeneratedAttribute]
private long <ParentPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <DisposalTask>k__BackingField;
    private SemaphoreSlim _disposalTaskCompletionSource;
    private bool _disposedValue;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public long ParentPosition { get; }
    public Task DisposalTask { get; }
    public StreamPartition(ReadOnlyMemory`1<byte> buffer, long parentPosition, int count, Action disposeAction, CancellationToken ct);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
public long get_ParentPosition();
    [CompilerGeneratedAttribute]
public Task get_DisposalTask();
    [AsyncStateMachineAttribute("Azure.Storage.StreamPartition/<DisposalTaskCore>d__23")]
private Task DisposalTaskCore(CancellationToken ct);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public int Read(ReadOnlyMemory`1& buffer, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[ExtensionAttribute]
internal static class Azure.Storage.TransferValidationOptionsExtensions : object {
    [ExtensionAttribute]
public static StorageChecksumAlgorithm ResolveAuto(StorageChecksumAlgorithm checksumAlgorithm);
    [ExtensionAttribute]
public static UploadTransferValidationOptions ToValidationOptions(Byte[] md5);
    [ExtensionAttribute]
public static DownloadTransferValidationOptions ToValidationOptions(bool requestTransactionalMD5);
    [ExtensionAttribute]
public static void CopyTo(TransferValidationOptions source, TransferValidationOptions dest);
    [ExtensionAttribute]
public static void CopyTo(UploadTransferValidationOptions source, UploadTransferValidationOptions dest);
    [ExtensionAttribute]
public static void CopyTo(DownloadTransferValidationOptions source, DownloadTransferValidationOptions dest);
}
[ExtensionAttribute]
internal static class Azure.Storage.UriExtensions : object {
    [ExtensionAttribute]
public static Uri AppendToPath(Uri uri, string segment);
    [ExtensionAttribute]
public static IDictionary`2<string, string> GetQueryParameters(Uri uri);
    [ExtensionAttribute]
public static string GetAccountNameFromDomain(Uri uri, string serviceSubDomain);
    public static string GetAccountNameFromDomain(string host, string serviceSubDomain);
    [ExtensionAttribute]
public static string GetPath(Uri uri);
    [ExtensionAttribute]
public static bool IsHostIPEndPointStyle(Uri uri);
    [ExtensionAttribute]
internal static void AppendQueryParameter(StringBuilder sb, string key, string value);
}
internal class Azure.Storage.UriQueryParamsCollection : Dictionary`2<string, string> {
    public UriQueryParamsCollection(string encodedQueryParamString);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.Azure.ShareClientBuilderExtensions : object {
    [ExtensionAttribute]
public static IAzureClientBuilder`2<ShareServiceClient, ShareClientOptions> AddFileServiceClient(TBuilder builder, string connectionString);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static IAzureClientBuilder`2<ShareServiceClient, ShareClientOptions> AddFileServiceClient(TBuilder builder, Uri serviceUri);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<ShareServiceClient, ShareClientOptions> AddFileServiceClientWithCredential(TBuilder builder, Uri serviceUri);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<ShareServiceClient, ShareClientOptions> AddFileServiceClient(TBuilder builder, Uri serviceUri, StorageSharedKeyCredential sharedKeyCredential);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<ShareServiceClient, ShareClientOptions> AddFileServiceClient(TBuilder builder, TConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
