internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
internal static class Azure.Core.Argument : object {
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    [NullableContextAttribute("1")]
public static void AssertNull(T value, string name, string message);
}
internal class Azure.Core.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private static int DefaultInitialBufferSize;
    [CompilerGeneratedAttribute]
private int <WrittenCount>k__BackingField;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; private set; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    [CompilerGeneratedAttribute]
public int get_WrittenCount();
    [CompilerGeneratedAttribute]
private void set_WrittenCount(int value);
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.AsyncLockWithValue`1 : object {
    private object _syncObj;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters;
    private bool _isLocked;
    private bool _hasValue;
    private long _index;
    [NullableAttribute("2")]
private T _value;
    public bool HasValue { get; }
    public AsyncLockWithValue`1(T value);
    public bool get_HasValue();
    [NullableContextAttribute("2")]
public bool TryGetValue(T& value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.AsyncLockWithValue`1/<GetLockOrValueAsync>d__11")]
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken);
    private void SetValue(T value, Int64& lockIndex);
    private void Reset(Int64& lockIndex);
    private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter);
}
[AttributeUsageAttribute("1")]
internal class Azure.Core.AzureResourceProviderNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ResourceProviderNamespace>k__BackingField;
    public string ResourceProviderNamespace { get; }
    public AzureResourceProviderNamespaceAttribute(string resourceProviderNamespace);
    [CompilerGeneratedAttribute]
public string get_ResourceProviderNamespace();
}
internal static class Azure.Core.Base64Url : object {
    public static Byte[] Decode(string encoded);
    public static string Encode(Byte[] bytes);
    internal static string DecodeString(string encoded);
    internal static string EncodeString(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.Diagnostics.AzureEventSource : EventSource {
    private static string SharedDataKey;
    private static HashSet`1<string> NamesInUse;
    private static String[] MainEventSourceTraits;
    private static AzureEventSource();
    protected AzureEventSource(string eventSourceName);
    private static string DeduplicateName(string eventSourceName);
}
internal class Azure.Core.HttpMessageSanitizer : object {
    private static string LogAllValue;
    private bool _logAllHeaders;
    private bool _logFullQueries;
    private String[] _allowedQueryParameters;
    private string _redactedPlaceholder;
    private HashSet`1<string> _allowedHeaders;
    internal static HttpMessageSanitizer Default;
    public HttpMessageSanitizer(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder);
    private static HttpMessageSanitizer();
    public string SanitizeHeader(string name, string value);
    public string SanitizeUrl(string url);
}
internal class Azure.Core.HttpPipelineMessageHandler : HttpMessageHandler {
    private HttpPipeline _pipeline;
    public HttpPipelineMessageHandler(HttpPipeline pipeline);
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineMessageHandler/<SendAsync>d__2")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineMessageHandler/<ToPipelineRequestAsync>d__3")]
private Task`1<Request> ToPipelineRequestAsync(HttpRequestMessage request);
    private static HttpResponseMessage ToHttpResponseMessage(Response response);
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineMessageHandler/<ToPipelineRequestContentAsync>d__5")]
private static Task`1<RequestContent> ToPipelineRequestContentAsync(HttpContent content);
}
internal static class Azure.Core.LightweightPkcs8Decoder : object {
    private static Byte[] s_derIntegerZero;
    private static Byte[] s_rsaAlgorithmId;
    private static LightweightPkcs8Decoder();
    internal static Byte[] ReadBitString(Byte[] data, Int32& offset);
    internal static string ReadObjectIdentifier(Byte[] data, Int32& offset);
    internal static Byte[] ReadOctetString(Byte[] data, Int32& offset);
    private static int ReadLength(Byte[] data, Int32& offset);
    private static Byte[] ReadUnsignedInteger(Byte[] data, Int32& offset, int targetSize);
    private static int ReadPayloadTagLength(Byte[] data, Int32& offset, byte tagValue);
    private static void ConsumeFullPayloadTag(Byte[] data, Int32& offset, byte tagValue);
    private static void ConsumeMatch(Byte[] data, Int32& offset, Byte[] toMatch);
    public static RSA DecodeRSAPkcs8(Byte[] pkcs8Bytes);
    public static string DecodePrivateKeyOid(Byte[] pkcs8Bytes);
}
internal static class Azure.Core.PemReader : object {
    private static string Prolog;
    private static string Epilog;
    private static string LabelEnd;
    private static string RSAAlgorithmId;
    private static string ECDsaAlgorithmId;
    private static bool s_rsaInitializedImportPkcs8PrivateKeyMethod;
    private static MethodInfo s_rsaImportPkcs8PrivateKeyMethod;
    private static MethodInfo s_rsaCopyWithPrivateKeyMethod;
    public static X509Certificate2 LoadCertificate(ReadOnlySpan`1<char> data, Byte[] cer, KeyType keyType, bool allowCertificateOnly, X509KeyStorageFlags keyStorageFlags);
    private static X509Certificate2 CreateRsaCertificate(Byte[] cer, Byte[] key, X509KeyStorageFlags keyStorageFlags);
    public static bool TryRead(ReadOnlySpan`1<char> data, PemField& field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.ActivityExtensions : object {
    private static bool SupportsActivitySourceSwitch;
    [NullableAttribute("2")]
private static Type ActivitySourceType;
    [NullableAttribute("2")]
private static Type ActivityKindType;
    [NullableAttribute("2")]
private static Type ActivityTagsCollectionType;
    [NullableAttribute("2")]
private static Type ActivityLinkType;
    [NullableAttribute("2")]
private static Type ActivityContextType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`2<Activity, int> SetIdFormatMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<Activity, string> GetTraceStateStringMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<Activity, int> GetIdFormatMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`3<Activity, string, object> ActivityAddTagMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`7<object, string, int, ICollection`1<KeyValuePair`2<string, object>>, IList, DateTimeOffset, Activity> ActivitySourceStartActivityMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<object, bool> ActivitySourceHasListenersMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`4<string, string, ICollection`1<KeyValuePair`2<string, object>>, object> CreateActivityLinkMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`1<ICollection`1<KeyValuePair`2<string, object>>> CreateTagsCollectionMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`3<Activity, string, object> GetCustomPropertyMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`3<Activity, string, object> SetCustomPropertyMethod;
    private static ParameterExpression ActivityParameter;
    private static ActivityExtensions();
    [ExtensionAttribute]
public static object GetCustomProperty(Activity activity, string propertyName);
    [ExtensionAttribute]
public static void SetCustomProperty(Activity activity, string propertyName, object propertyValue);
    [ExtensionAttribute]
public static void SetW3CFormat(Activity activity);
    [ExtensionAttribute]
public static bool IsW3CFormat(Activity activity);
    [ExtensionAttribute]
public static string GetTraceState(Activity activity);
    [ExtensionAttribute]
public static void AddObjectTag(Activity activity, string name, object value);
    public static bool SupportsActivitySource();
    public static ICollection`1<KeyValuePair`2<string, object>> CreateTagsCollection();
    [NullableContextAttribute("2")]
public static object CreateActivityLink(string traceparent, string tracestate, ICollection`1<KeyValuePair`2<string, object>> tags);
    [NullableContextAttribute("2")]
public static bool ActivitySourceHasListeners(object activitySource);
    [NullableContextAttribute("2")]
public static Activity ActivitySourceStartActivity(object activitySource, string activityName, int kind, DateTimeOffset startTime, ICollection`1<KeyValuePair`2<string, object>> tags, IList links);
    public static object CreateActivitySource(string name);
    [NullableContextAttribute("2")]
public static IList CreateLinkCollection();
    [ExtensionAttribute]
public static bool TryDispose(Activity activity);
    public static void ResetFeatureSwitch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
    private static string DefaultMessage;
    private HttpMessageSanitizer _sanitizer;
    public ClientDiagnostics(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities);
    public ClientDiagnostics(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities);
    internal static HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics);
    [NullableContextAttribute("2")]
protected virtual ResponseError ExtractFailureContent(string content, ResponseHeaders responseHeaders, IDictionary`2& additionalInfo);
    [NullableContextAttribute("2")]
internal static ResponseError ExtractAzureErrorContent(string content);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Azure.Core.Pipeline.ClientDiagnostics/<CreateRequestFailedExceptionAsync>d__7")]
public ValueTask`1<RequestFailedException> CreateRequestFailedExceptionAsync(Response response, ResponseError error, IDictionary`2<string, string> additionalInfo, Exception innerException);
    public RequestFailedException CreateRequestFailedException(Response response, ResponseError error, IDictionary`2<string, string> additionalInfo, Exception innerException);
    [NullableContextAttribute("2")]
private RequestFailedException CreateRequestFailedExceptionWithContent(Response response, ResponseError error, string content, IDictionary`2<string, string> additionalInfo, Exception innerException);
    [AsyncStateMachineAttribute("Azure.Core.Pipeline.ClientDiagnostics/<CreateRequestFailedMessageAsync>d__10")]
public ValueTask`1<string> CreateRequestFailedMessageAsync(Response response, ResponseError error, IDictionary`2<string, string> additionalInfo, bool async);
    internal static string CreateRequestFailedMessageWithContent(Response response, ResponseError error, string content, IDictionary`2<string, string> additionalInfo, HttpMessageSanitizer sanitizer);
    [AsyncStateMachineAttribute("Azure.Core.Pipeline.ClientDiagnostics/<ReadContentAsync>d__12")]
internal static ValueTask`1<string> ReadContentAsync(Response response, bool async);
    internal static string GetResourceProviderNamespace(Assembly assembly);
}
internal static class Azure.Core.Pipeline.ContentTypeUtilities : object {
    public static bool TryGetTextEncoding(string contentType, Encoding& encoding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Pipeline.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    private static object AzureSdkScopeValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, object> ActivitySources;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    internal DiagnosticScope(string ns, string scopeName, DiagnosticListener source, ActivityKind kind, bool suppressNestedClientActivities);
    internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, object activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    private static object GetActivitySource(string ns, string name);
    public void AddAttribute(string name, string value);
    public void AddAttribute(string name, T value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, string> attributes);
    public void Start();
    public void SetStartTime(DateTime dateTime);
    public sealed virtual void Dispose();
    public void Failed(Exception e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities);
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    public DiagnosticScope CreateScope(string name, ActivityKind kind);
}
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.TaskExtensions : object {
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T EnsureCompleted(Task`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(Task task);
    [ExtensionAttribute]
public static T EnsureCompleted(ValueTask`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(ValueTask task);
    [ExtensionAttribute]
public static Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async);
    [ConditionalAttribute("DEBUG")]
private static void VerifyTaskCompleted(bool isCompleted);
}
internal static class Azure.Identitiy.TokenHelper : object {
    public static ValueTuple`4<string, string, string, string> ParseAccountInfoFromToken(string token);
}
[ExtensionAttribute]
internal static class Azure.Identity.AbstractAcquireTokenParameterBuilderExtensions : object {
    [AsyncStateMachineAttribute("Azure.Identity.AbstractAcquireTokenParameterBuilderExtensions/<ExecuteAsync>d__0`1")]
[ExtensionAttribute]
public static ValueTask`1<AuthenticationResult> ExecuteAsync(AbstractAcquireTokenParameterBuilder`1<T> builder, bool async, CancellationToken cancellationToken);
}
internal class Azure.Identity.AppServiceManagedIdentitySource : ManagedIdentitySource {
    private static string MsiEndpointInvalidUriError;
    private Uri _endpoint;
    private string _secret;
    private string _clientId;
    private string _resourceId;
    protected string AppServiceMsiApiVersion { get; }
    protected string SecretHeaderName { get; }
    protected string ClientIdHeaderName { get; }
    protected AppServiceManagedIdentitySource(CredentialPipeline pipeline, Uri endpoint, string secret, ManagedIdentityClientOptions options);
    protected virtual string get_AppServiceMsiApiVersion();
    protected virtual string get_SecretHeaderName();
    protected virtual string get_ClientIdHeaderName();
    protected static bool TryValidateEnvVars(string msiEndpoint, string secret, Uri& endpointUri);
    protected virtual Request CreateRequest(String[] scopes);
}
internal class Azure.Identity.AppServiceV2017ManagedIdentitySource : AppServiceManagedIdentitySource {
    protected string AppServiceMsiApiVersion { get; }
    protected string SecretHeaderName { get; }
    protected string ClientIdHeaderName { get; }
    private AppServiceV2017ManagedIdentitySource(CredentialPipeline pipeline, Uri endpoint, string secret, ManagedIdentityClientOptions options);
    protected virtual string get_AppServiceMsiApiVersion();
    protected virtual string get_SecretHeaderName();
    protected virtual string get_ClientIdHeaderName();
    public static ManagedIdentitySource TryCreate(ManagedIdentityClientOptions options);
}
internal class Azure.Identity.AppServiceV2019ManagedIdentitySource : AppServiceManagedIdentitySource {
    protected string AppServiceMsiApiVersion { get; }
    protected string SecretHeaderName { get; }
    protected string ClientIdHeaderName { get; }
    private AppServiceV2019ManagedIdentitySource(CredentialPipeline pipeline, Uri endpoint, string secret, ManagedIdentityClientOptions options);
    protected virtual string get_AppServiceMsiApiVersion();
    protected virtual string get_SecretHeaderName();
    protected virtual string get_ClientIdHeaderName();
    public static ManagedIdentitySource TryCreate(ManagedIdentityClientOptions options);
}
internal class Azure.Identity.AuthenticationAccount : object {
    private AuthenticationRecord _profile;
    private string Microsoft.Identity.Client.IAccount.Username { get; }
    private string Microsoft.Identity.Client.IAccount.Environment { get; }
    private AccountId Microsoft.Identity.Client.IAccount.HomeAccountId { get; }
    internal AuthenticationAccount(AuthenticationRecord profile);
    private sealed virtual override string Microsoft.Identity.Client.IAccount.get_Username();
    private sealed virtual override string Microsoft.Identity.Client.IAccount.get_Environment();
    private sealed virtual override AccountId Microsoft.Identity.Client.IAccount.get_HomeAccountId();
    public static AuthenticationAccount op_Explicit(AuthenticationRecord profile);
    public static AuthenticationRecord op_Explicit(AuthenticationAccount account);
}
public class Azure.Identity.AuthenticationFailedException : Exception {
    public AuthenticationFailedException(string message);
    public AuthenticationFailedException(string message, Exception innerException);
    protected AuthenticationFailedException(SerializationInfo info, StreamingContext context);
}
public class Azure.Identity.AuthenticationRecord : object {
    internal static string CurrentVersion;
    private static string UsernamePropertyName;
    private static string AuthorityPropertyName;
    private static string HomeAccountIdPropertyName;
    private static string TenantIdPropertyName;
    private static string ClientIdPropertyName;
    private static string VersionPropertyName;
    private static JsonEncodedText s_usernamePropertyNameBytes;
    private static JsonEncodedText s_authorityPropertyNameBytes;
    private static JsonEncodedText s_homeAccountIdPropertyNameBytes;
    private static JsonEncodedText s_tenantIdPropertyNameBytes;
    private static JsonEncodedText s_clientIdPropertyNameBytes;
    private static JsonEncodedText s_versionPropertyNameBytes;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private AccountId <AccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Username { get; private set; }
    public string Authority { get; private set; }
    public string HomeAccountId { get; }
    public string TenantId { get; private set; }
    public string ClientId { get; private set; }
    internal AccountId AccountId { get; private set; }
    internal string Version { get; private set; }
    internal AuthenticationRecord(AuthenticationResult authResult, string clientId);
    internal AuthenticationRecord(string username, string authority, string homeAccountId, string tenantId, string clientId);
    private static AuthenticationRecord();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
private void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Authority();
    [CompilerGeneratedAttribute]
private void set_Authority(string value);
    public string get_HomeAccountId();
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
private void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
private void set_ClientId(string value);
    [CompilerGeneratedAttribute]
internal AccountId get_AccountId();
    [CompilerGeneratedAttribute]
private void set_AccountId(AccountId value);
    [CompilerGeneratedAttribute]
internal string get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(string value);
    public void Serialize(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AuthenticationRecord/<SerializeAsync>d__43")]
public Task SerializeAsync(Stream stream, CancellationToken cancellationToken);
    public static AuthenticationRecord Deserialize(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AuthenticationRecord/<DeserializeAsync>d__45")]
public static Task`1<AuthenticationRecord> DeserializeAsync(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AuthenticationRecord/<SerializeAsync>d__46")]
private Task SerializeAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AuthenticationRecord/<DeserializeAsync>d__47")]
private static Task`1<AuthenticationRecord> DeserializeAsync(Stream stream, bool async, CancellationToken cancellationToken);
    private static AccountId BuildAccountIdFromString(string homeAccountId);
}
public class Azure.Identity.AuthenticationRequiredException : CredentialUnavailableException {
    [CompilerGeneratedAttribute]
private TokenRequestContext <TokenRequestContext>k__BackingField;
    public TokenRequestContext TokenRequestContext { get; }
    public AuthenticationRequiredException(string message, TokenRequestContext context);
    public AuthenticationRequiredException(string message, TokenRequestContext context, Exception innerException);
    protected AuthenticationRequiredException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public TokenRequestContext get_TokenRequestContext();
}
public class Azure.Identity.AuthorizationCodeCredential : TokenCredential {
    private string _authCode;
    private string _clientId;
    private CredentialPipeline _pipeline;
    private AuthenticationRecord _record;
    private MsalConfidentialClient _client;
    private string _redirectUri;
    private string _tenantId;
    private String[] _additionallyAllowedTenantIds;
    public AuthorizationCodeCredential(string tenantId, string clientId, string clientSecret, string authorizationCode);
    public AuthorizationCodeCredential(string tenantId, string clientId, string clientSecret, string authorizationCode, AuthorizationCodeCredentialOptions options);
    [EditorBrowsableAttribute("1")]
public AuthorizationCodeCredential(string tenantId, string clientId, string clientSecret, string authorizationCode, TokenCredentialOptions options);
    internal AuthorizationCodeCredential(string tenantId, string clientId, string clientSecret, string authorizationCode, TokenCredentialOptions options, MsalConfidentialClient client, CredentialPipeline pipeline);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AuthorizationCodeCredential/<GetTokenAsync>d__14")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AuthorizationCodeCredential/<GetTokenImplAsync>d__15")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
}
public class Azure.Identity.AuthorizationCodeCredentialOptions : TokenCredentialOptions {
    [CompilerGeneratedAttribute]
private Uri <RedirectUri>k__BackingField;
    public Uri RedirectUri { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    [CompilerGeneratedAttribute]
public Uri get_RedirectUri();
    [CompilerGeneratedAttribute]
public void set_RedirectUri(Uri value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
internal class Azure.Identity.AzureApplicationCredential : TokenCredential {
    private ChainedTokenCredential _credential;
    public AzureApplicationCredential(AzureApplicationCredentialOptions options);
    internal AzureApplicationCredential(AzureApplicationCredentialOptions options, EnvironmentCredential environmentCredential, ManagedIdentityCredential managedIdentityCredential);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AzureApplicationCredential/<GetTokenAsync>d__5")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AzureApplicationCredential/<GetTokenImplAsync>d__6")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
}
internal class Azure.Identity.AzureApplicationCredentialOptions : TokenCredentialOptions {
    [CompilerGeneratedAttribute]
private string <ManagedIdentityClientId>k__BackingField;
    public string ManagedIdentityClientId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ManagedIdentityClientId();
    [CompilerGeneratedAttribute]
public void set_ManagedIdentityClientId(string value);
    private static string GetNonEmptyStringOrNull(string str);
}
internal class Azure.Identity.AzureArcManagedIdentitySource : ManagedIdentitySource {
    private static string IdentityEndpointInvalidUriError;
    private static string NoChallengeErrorMessage;
    private static string InvalidChallangeErrorMessage;
    private static string UserAssignedNotSupportedErrorMessage;
    private static string ArcApiVersion;
    private string _clientId;
    private Uri _endpoint;
    private AzureArcManagedIdentitySource(Uri endpoint, ManagedIdentityClientOptions options);
    public static ManagedIdentitySource TryCreate(ManagedIdentityClientOptions options);
    protected virtual Request CreateRequest(String[] scopes);
    [AsyncStateMachineAttribute("Azure.Identity.AzureArcManagedIdentitySource/<HandleResponseAsync>d__10")]
protected virtual ValueTask`1<AccessToken> HandleResponseAsync(bool async, TokenRequestContext context, Response response, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<AccessToken> <>n__0(bool async, TokenRequestContext context, Response response, CancellationToken cancellationToken);
}
public static class Azure.Identity.AzureAuthorityHosts : object {
    private static string AzurePublicCloudHostUrl;
    private static string AzureChinaHostUrl;
    private static string AzureGermanyHostUrl;
    private static string AzureGovernmentHostUrl;
    [CompilerGeneratedAttribute]
private static Uri <AzurePublicCloud>k__BackingField;
    [CompilerGeneratedAttribute]
private static Uri <AzureChina>k__BackingField;
    [CompilerGeneratedAttribute]
private static Uri <AzureGermany>k__BackingField;
    [CompilerGeneratedAttribute]
private static Uri <AzureGovernment>k__BackingField;
    public static Uri AzurePublicCloud { get; }
    public static Uri AzureChina { get; }
    public static Uri AzureGermany { get; }
    public static Uri AzureGovernment { get; }
    private static AzureAuthorityHosts();
    [CompilerGeneratedAttribute]
public static Uri get_AzurePublicCloud();
    [CompilerGeneratedAttribute]
public static Uri get_AzureChina();
    [CompilerGeneratedAttribute]
public static Uri get_AzureGermany();
    [CompilerGeneratedAttribute]
public static Uri get_AzureGovernment();
    internal static Uri GetDefault();
    internal static string GetDefaultScope(Uri authorityHost);
    internal static Uri GetDeviceCodeRedirectUri(Uri authorityHost);
}
public class Azure.Identity.AzureCliCredential : TokenCredential {
    internal static string AzureCLINotInstalled;
    internal static string AzNotLogIn;
    internal static string WinAzureCLIError;
    internal static string AzureCliTimeoutError;
    internal static string AzureCliFailedError;
    internal static string Troubleshoot;
    internal static string InteractiveLoginRequired;
    internal static string CLIInternalError;
    private static int CliProcessTimeoutMs;
    private static string DefaultPathWindows;
    private static string DefaultWorkingDirWindows;
    private static string DefaultPathNonWindows;
    private static string DefaultWorkingDirNonWindows;
    private static string RefreshTokeExpired;
    private static string DefaultPath;
    private static string DefaultWorkingDir;
    private static Regex AzNotFoundPattern;
    private string _path;
    private CredentialPipeline _pipeline;
    private IProcessService _processService;
    private bool _logPII;
    private bool _logAccountDetails;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AdditionallyAllowedTenantIds>k__BackingField;
    internal string TenantId { get; }
    internal String[] AdditionallyAllowedTenantIds { get; }
    public AzureCliCredential(AzureCliCredentialOptions options);
    internal AzureCliCredential(CredentialPipeline pipeline, IProcessService processService, AzureCliCredentialOptions options);
    private static AzureCliCredential();
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal String[] get_AdditionallyAllowedTenantIds();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AzureCliCredential/<GetTokenAsync>d__32")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AzureCliCredential/<GetTokenImplAsync>d__33")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AzureCliCredential/<RequestCliAccessTokenAsync>d__34")]
private ValueTask`1<AccessToken> RequestCliAccessTokenAsync(bool async, TokenRequestContext context, CancellationToken cancellationToken);
    private ProcessStartInfo GetAzureCliProcessStartInfo(string fileName, string argument);
    private static void GetFileNameAndArguments(string resource, string tenantId, String& fileName, String& argument);
    private static AccessToken DeserializeOutput(string output);
}
public class Azure.Identity.AzureCliCredentialOptions : TokenCredentialOptions {
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    public string TenantId { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
[EventSourceAttribute]
internal class Azure.Identity.AzureIdentityEventSource : AzureEventSource {
    private static string EventSourceName;
    private static int GetTokenEvent;
    private static int GetTokenSucceededEvent;
    private static int GetTokenFailedEvent;
    private static int ProbeImdsEndpointEvent;
    private static int ImdsEndpointFoundEvent;
    private static int ImdsEndpointUnavailableEvent;
    private static int MsalLogVerboseEvent;
    private static int MsalLogInfoEvent;
    private static int MsalLogWarningEvent;
    private static int MsalLogErrorEvent;
    private static int InteractiveAuthenticationThreadPoolExecutionEvent;
    private static int InteractiveAuthenticationInlineExecutionEvent;
    private static int DefaultAzureCredentialCredentialSelectedEvent;
    private static int ProcessRunnerErrorEvent;
    private static int ProcessRunnerInfoEvent;
    private static int UsernamePasswordCredentialAcquireTokenSilentFailedEvent;
    private static int TenantIdDiscoveredAndNotUsedEvent;
    private static int TenantIdDiscoveredAndUsedEvent;
    internal static int AuthenticatedAccountDetailsEvent;
    internal static int UnableToParseAccountDetailsFromTokenEvent;
    private static int UserAssignedManagedIdentityNotSupportedEvent;
    private static int ServiceFabricManagedIdentityRuntimeConfigurationNotSupportedEvent;
    internal static string TenantIdDiscoveredAndNotUsedEventMessage;
    internal static string TenantIdDiscoveredAndUsedEventMessage;
    internal static string AuthenticatedAccountDetailsMessage;
    internal static string Unavailable;
    internal static string UnableToParseAccountDetailsFromTokenMessage;
    internal static string UserAssignedManagedIdentityNotSupportedMessage;
    internal static string ServiceFabricManagedIdentityRuntimeConfigurationNotSupportedMessage;
    [CompilerGeneratedAttribute]
private static AzureIdentityEventSource <Singleton>k__BackingField;
    public static AzureIdentityEventSource Singleton { get; }
    private static AzureIdentityEventSource();
    [CompilerGeneratedAttribute]
public static AzureIdentityEventSource get_Singleton();
    [NonEventAttribute]
public void GetToken(string method, TokenRequestContext context);
    [EventAttribute("1")]
public void GetToken(string method, string scopes, string parentRequestId);
    [NonEventAttribute]
public void GetTokenSucceeded(string method, TokenRequestContext context, DateTimeOffset expiresOn);
    [EventAttribute("2")]
public void GetTokenSucceeded(string method, string scopes, string parentRequestId, string expiresOn);
    [NonEventAttribute]
public void GetTokenFailed(string method, TokenRequestContext context, Exception ex);
    [EventAttribute("3")]
public void GetTokenFailed(string method, string scopes, string parentRequestId, string exception);
    [NonEventAttribute]
public void ProbeImdsEndpoint(Uri uri);
    [EventAttribute("4")]
public void ProbeImdsEndpoint(string uri);
    [NonEventAttribute]
public void ImdsEndpointFound(Uri uri);
    [EventAttribute("5")]
public void ImdsEndpointFound(string uri);
    [NonEventAttribute]
public void ImdsEndpointUnavailable(Uri uri, string error);
    [NonEventAttribute]
public void ImdsEndpointUnavailable(Uri uri, Exception e);
    [EventAttribute("6")]
public void ImdsEndpointUnavailable(string uri, string error);
    [NonEventAttribute]
private static string FormatException(Exception ex);
    [NonEventAttribute]
public void LogMsal(LogLevel level, string message);
    [EventAttribute("10")]
public void LogMsalError(string message);
    [EventAttribute("9")]
public void LogMsalWarning(string message);
    [EventAttribute("8")]
public void LogMsalInformational(string message);
    [EventAttribute("7")]
public void LogMsalVerbose(string message);
    [NonEventAttribute]
private static string FormatStringArray(String[] array);
    [EventAttribute("11")]
public void InteractiveAuthenticationExecutingOnThreadPool();
    [EventAttribute("12")]
public void InteractiveAuthenticationExecutingInline();
    [EventAttribute("13")]
public void DefaultAzureCredentialCredentialSelected(string credentialType);
    [NonEventAttribute]
public void ProcessRunnerError(string message);
    [EventAttribute("14")]
public void LogProcessRunnerError(string message);
    [NonEventAttribute]
public void ProcessRunnerInformational(string message);
    [EventAttribute("15")]
public void LogProcessRunnerInformational(string message);
    [NonEventAttribute]
public void UsernamePasswordCredentialAcquireTokenSilentFailed(Exception e);
    [EventAttribute("16")]
public void UsernamePasswordCredentialAcquireTokenSilentFailed(string error);
    [EventAttribute("17")]
public void TenantIdDiscoveredAndNotUsed(string explicitTenantId, string contextTenantId);
    [EventAttribute("18")]
public void TenantIdDiscoveredAndUsed(string explicitTenantId, string contextTenantId);
    [EventAttribute("19")]
public void AuthenticatedAccountDetails(string clientId, string tenantId, string upn, string objectId);
    [EventAttribute("20")]
internal void UnableToParseAccountDetailsFromToken();
    [EventAttribute("21")]
public void UserAssignedManagedIdentityNotSupported(string environment);
    [EventAttribute("22")]
public void ServiceFabricManagedIdentityRuntimeConfigurationNotSupported();
}
public class Azure.Identity.AzurePowerShellCredential : TokenCredential {
    private CredentialPipeline _pipeline;
    private IProcessService _processService;
    private static int PowerShellProcessTimeoutMs;
    [CompilerGeneratedAttribute]
private bool <UseLegacyPowerShell>k__BackingField;
    private static string Troubleshooting;
    private static string AzurePowerShellFailedError;
    private static string AzurePowerShellTimeoutError;
    private static string RunConnectAzAccountToLogin;
    private static string NoAccountsWereFoundInTheCache;
    private static string CannotRetrieveAccessToken;
    private static string AzurePowerShellNoAzAccountModule;
    private static string DefaultWorkingDirWindows;
    private static string DefaultWorkingDirNonWindows;
    private static string DefaultWorkingDir;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AdditionallyAllowedTenantIds>k__BackingField;
    private bool _logPII;
    private bool _logAccountDetails;
    internal static string AzurePowerShellNotLogInError;
    internal static string AzurePowerShellModuleNotInstalledError;
    internal static string PowerShellNotInstalledError;
    internal bool UseLegacyPowerShell { get; internal set; }
    internal string TenantId { get; }
    internal String[] AdditionallyAllowedTenantIds { get; }
    public AzurePowerShellCredential(AzurePowerShellCredentialOptions options);
    internal AzurePowerShellCredential(AzurePowerShellCredentialOptions options, CredentialPipeline pipeline, IProcessService processService);
    private static AzurePowerShellCredential();
    [CompilerGeneratedAttribute]
internal bool get_UseLegacyPowerShell();
    [CompilerGeneratedAttribute]
internal void set_UseLegacyPowerShell(bool value);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal String[] get_AdditionallyAllowedTenantIds();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AzurePowerShellCredential/<GetTokenAsync>d__32")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AzurePowerShellCredential/<GetTokenImplAsync>d__33")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.AzurePowerShellCredential/<RequestAzurePowerShellAccessTokenAsync>d__34")]
private ValueTask`1<AccessToken> RequestAzurePowerShellAccessTokenAsync(bool async, TokenRequestContext context, CancellationToken cancellationToken);
    private static void CheckForErrors(string output);
    private static void ValidateResult(string output);
    private static ProcessStartInfo GetAzurePowerShellProcessStartInfo(string fileName, string argument);
    private void GetFileNameAndArguments(string resource, string tenantId, String& fileName, String& argument);
    private static AccessToken DeserializeOutput(string output);
    private static string Base64Encode(string text);
}
public class Azure.Identity.AzurePowerShellCredentialOptions : TokenCredentialOptions {
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    public string TenantId { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
public class Azure.Identity.ChainedTokenCredential : TokenCredential {
    private static string AggregateAllUnavailableErrorMessage;
    private static string AuthenticationFailedErrorMessage;
    private TokenCredential[] _sources;
    public ChainedTokenCredential(TokenCredential[] sources);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.ChainedTokenCredential/<GetTokenAsync>d__6")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.ChainedTokenCredential/<GetTokenImplAsync>d__7")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
}
public class Azure.Identity.ClientAssertionCredential : TokenCredential {
    private String[] _additionallyAllowedTenantIds;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private MsalConfidentialClient <Client>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultiTenantAuthentication>k__BackingField;
    internal string TenantId { get; }
    internal string ClientId { get; }
    internal MsalConfidentialClient Client { get; }
    internal CredentialPipeline Pipeline { get; }
    internal bool AllowMultiTenantAuthentication { get; }
    public ClientAssertionCredential(string tenantId, string clientId, Func`2<CancellationToken, Task`1<string>> assertionCallback, ClientAssertionCredentialOptions options);
    public ClientAssertionCredential(string tenantId, string clientId, Func`1<string> assertionCallback, ClientAssertionCredentialOptions options);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal string get_ClientId();
    [CompilerGeneratedAttribute]
internal MsalConfidentialClient get_Client();
    [CompilerGeneratedAttribute]
internal CredentialPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
internal bool get_AllowMultiTenantAuthentication();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.ClientAssertionCredential/<GetTokenAsync>d__20")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
}
public class Azure.Identity.ClientAssertionCredentialOptions : TokenCredentialOptions {
    [CompilerGeneratedAttribute]
private CredentialPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private MsalConfidentialClient <MsalClient>k__BackingField;
    internal CredentialPipeline Pipeline { get; internal set; }
    internal MsalConfidentialClient MsalClient { get; internal set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    [CompilerGeneratedAttribute]
internal CredentialPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
internal void set_Pipeline(CredentialPipeline value);
    [CompilerGeneratedAttribute]
internal MsalConfidentialClient get_MsalClient();
    [CompilerGeneratedAttribute]
internal void set_MsalClient(MsalConfidentialClient value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
public class Azure.Identity.ClientCertificateCredential : TokenCredential {
    internal static string Troubleshooting;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private IX509Certificate2Provider <ClientCertificateProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private MsalConfidentialClient <Client>k__BackingField;
    private CredentialPipeline _pipeline;
    private String[] _additionallyAllowedTenantIds;
    internal string TenantId { get; }
    internal string ClientId { get; }
    internal IX509Certificate2Provider ClientCertificateProvider { get; }
    internal MsalConfidentialClient Client { get; }
    public ClientCertificateCredential(string tenantId, string clientId, string clientCertificatePath);
    public ClientCertificateCredential(string tenantId, string clientId, string clientCertificatePath, TokenCredentialOptions options);
    public ClientCertificateCredential(string tenantId, string clientId, string clientCertificatePath, ClientCertificateCredentialOptions options);
    public ClientCertificateCredential(string tenantId, string clientId, X509Certificate2 clientCertificate);
    public ClientCertificateCredential(string tenantId, string clientId, X509Certificate2 clientCertificate, TokenCredentialOptions options);
    public ClientCertificateCredential(string tenantId, string clientId, X509Certificate2 clientCertificate, ClientCertificateCredentialOptions options);
    internal ClientCertificateCredential(string tenantId, string clientId, string certificatePath, TokenCredentialOptions options, CredentialPipeline pipeline, MsalConfidentialClient client);
    internal ClientCertificateCredential(string tenantId, string clientId, X509Certificate2 certificate, TokenCredentialOptions options, CredentialPipeline pipeline, MsalConfidentialClient client);
    internal ClientCertificateCredential(string tenantId, string clientId, IX509Certificate2Provider certificateProvider, TokenCredentialOptions options, CredentialPipeline pipeline, MsalConfidentialClient client);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal string get_ClientId();
    [CompilerGeneratedAttribute]
internal IX509Certificate2Provider get_ClientCertificateProvider();
    [CompilerGeneratedAttribute]
internal MsalConfidentialClient get_Client();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.ClientCertificateCredential/<GetTokenAsync>d__26")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
}
public class Azure.Identity.ClientCertificateCredentialOptions : TokenCredentialOptions {
    [CompilerGeneratedAttribute]
private TokenCachePersistenceOptions <TokenCachePersistenceOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendCertificateChain>k__BackingField;
    public TokenCachePersistenceOptions TokenCachePersistenceOptions { get; public set; }
    public bool SendCertificateChain { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    [CompilerGeneratedAttribute]
public sealed virtual TokenCachePersistenceOptions get_TokenCachePersistenceOptions();
    [CompilerGeneratedAttribute]
public void set_TokenCachePersistenceOptions(TokenCachePersistenceOptions value);
    [CompilerGeneratedAttribute]
public bool get_SendCertificateChain();
    [CompilerGeneratedAttribute]
public void set_SendCertificateChain(bool value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
public class Azure.Identity.ClientSecretCredential : TokenCredential {
    private CredentialPipeline _pipeline;
    private String[] _additionallyAllowedTenantIds;
    [CompilerGeneratedAttribute]
private MsalConfidentialClient <Client>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientSecret>k__BackingField;
    internal MsalConfidentialClient Client { get; }
    internal string TenantId { get; }
    internal string ClientId { get; }
    internal string ClientSecret { get; }
    public ClientSecretCredential(string tenantId, string clientId, string clientSecret);
    public ClientSecretCredential(string tenantId, string clientId, string clientSecret, ClientSecretCredentialOptions options);
    public ClientSecretCredential(string tenantId, string clientId, string clientSecret, TokenCredentialOptions options);
    internal ClientSecretCredential(string tenantId, string clientId, string clientSecret, TokenCredentialOptions options, CredentialPipeline pipeline, MsalConfidentialClient client);
    [CompilerGeneratedAttribute]
internal MsalConfidentialClient get_Client();
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal string get_ClientId();
    [CompilerGeneratedAttribute]
internal string get_ClientSecret();
    [AsyncStateMachineAttribute("Azure.Identity.ClientSecretCredential/<GetTokenAsync>d__19")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
}
public class Azure.Identity.ClientSecretCredentialOptions : TokenCredentialOptions {
    [CompilerGeneratedAttribute]
private TokenCachePersistenceOptions <TokenCachePersistenceOptions>k__BackingField;
    public TokenCachePersistenceOptions TokenCachePersistenceOptions { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    [CompilerGeneratedAttribute]
public sealed virtual TokenCachePersistenceOptions get_TokenCachePersistenceOptions();
    [CompilerGeneratedAttribute]
public void set_TokenCachePersistenceOptions(TokenCachePersistenceOptions value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
internal class Azure.Identity.CloudShellManagedIdentitySource : ManagedIdentitySource {
    private Uri _endpoint;
    private static string MsiEndpointInvalidUriError;
    private CloudShellManagedIdentitySource(Uri endpoint, ManagedIdentityClientOptions options);
    public static ManagedIdentitySource TryCreate(ManagedIdentityClientOptions options);
    protected virtual Request CreateRequest(String[] scopes);
}
internal class Azure.Identity.Constants : object {
    public static string OrganizationsTenantId;
    public static string AdfsTenantId;
    public static string DeveloperSignOnClientId;
    public static int SharedTokenCacheAccessRetryCount;
    public static TimeSpan SharedTokenCacheAccessRetryDelay;
    public static string DefaultRedirectUrl;
    public static string DefaultMsalTokenCacheDirectory;
    public static string DefaultMsalTokenCacheKeychainService;
    public static string DefaultMsalTokenCacheKeychainAccount;
    public static string DefaultMsalTokenCacheKeyringLabel;
    public static string DefaultMsalTokenCacheKeyringSchema;
    public static string DefaultMsalTokenCacheKeyringCollection;
    public static KeyValuePair`2<string, string> DefaultMsaltokenCacheKeyringAttribute1;
    public static KeyValuePair`2<string, string> DefaultMsaltokenCacheKeyringAttribute2;
    public static string DefaultMsalTokenCacheName;
    public static string ManagedIdentityClientId;
    public static string ManagedIdentityResourceId;
    public static string SharedTokenCacheFilePath { get; }
    private static Constants();
    public static string get_SharedTokenCacheFilePath();
}
[IsReadOnlyAttribute]
internal class Azure.Identity.CredentialDiagnosticScope : ValueType {
    private string _name;
    private DiagnosticScope _scope;
    private TokenRequestContext _context;
    private IScopeHandler _scopeHandler;
    public CredentialDiagnosticScope(ClientDiagnostics diagnostics, string name, TokenRequestContext context, IScopeHandler scopeHandler);
    public void Start();
    public AccessToken Succeeded(AccessToken token);
    public Exception FailWrapAndThrow(Exception ex, string additionalMessage);
    private void RegisterFailed(Exception ex);
    private bool TryWrapException(Exception& exception, string additionalMessageText);
    public sealed virtual void Dispose();
}
internal class Azure.Identity.CredentialPipeline : object {
    private static Lazy`1<CredentialPipeline> s_singleton;
    private static IScopeHandler _defaultScopeHandler;
    [CompilerGeneratedAttribute]
private Uri <AuthorityHost>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpPipeline <HttpPipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <Diagnostics>k__BackingField;
    public Uri AuthorityHost { get; }
    public HttpPipeline HttpPipeline { get; }
    public ClientDiagnostics Diagnostics { get; }
    private CredentialPipeline(TokenCredentialOptions options);
    public CredentialPipeline(Uri authorityHost, HttpPipeline httpPipeline, ClientDiagnostics diagnostics);
    private static CredentialPipeline();
    public static CredentialPipeline GetInstance(TokenCredentialOptions options);
    [CompilerGeneratedAttribute]
public Uri get_AuthorityHost();
    [CompilerGeneratedAttribute]
public HttpPipeline get_HttpPipeline();
    [CompilerGeneratedAttribute]
public ClientDiagnostics get_Diagnostics();
    public IConfidentialClientApplication CreateMsalConfidentialClient(string tenantId, string clientId, string clientSecret);
    public CredentialDiagnosticScope StartGetTokenScope(string fullyQualifiedMethod, TokenRequestContext context);
    public CredentialDiagnosticScope StartGetTokenScopeGroup(string fullyQualifiedMethod, TokenRequestContext context);
}
public class Azure.Identity.CredentialUnavailableException : AuthenticationFailedException {
    public CredentialUnavailableException(string message);
    public CredentialUnavailableException(string message, Exception innerException);
    protected CredentialUnavailableException(SerializationInfo info, StreamingContext context);
    internal static CredentialUnavailableException CreateAggregateException(string message, IList`1<CredentialUnavailableException> exceptions);
}
public class Azure.Identity.DefaultAzureCredential : TokenCredential {
    private static string Troubleshooting;
    private static string DefaultExceptionMessage;
    private static string UnhandledExceptionMessage;
    private CredentialPipeline _pipeline;
    private AsyncLockWithValue`1<TokenCredential> _credentialLock;
    private TokenCredential[] _sources;
    public DefaultAzureCredential(bool includeInteractiveCredentials);
    public DefaultAzureCredential(DefaultAzureCredentialOptions options);
    internal DefaultAzureCredential(DefaultAzureCredentialFactory factory);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DefaultAzureCredential/<GetTokenAsync>d__11")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DefaultAzureCredential/<GetTokenImplAsync>d__12")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DefaultAzureCredential/<GetTokenFromCredentialAsync>d__13")]
private static ValueTask`1<AccessToken> GetTokenFromCredentialAsync(TokenCredential credential, TokenRequestContext requestContext, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DefaultAzureCredential/<GetTokenFromSourcesAsync>d__14")]
private static ValueTask`1<ValueTuple`2<AccessToken, TokenCredential>> GetTokenFromSourcesAsync(TokenCredential[] sources, TokenRequestContext requestContext, bool async, CancellationToken cancellationToken);
    private static DefaultAzureCredentialOptions ValidateAuthorityHostOption(DefaultAzureCredentialOptions options);
}
internal class Azure.Identity.DefaultAzureCredentialFactory : object {
    private static TokenCredential[] s_defaultCredentialChain;
    private bool _useDefaultCredentialChain;
    [CompilerGeneratedAttribute]
private DefaultAzureCredentialOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialPipeline <Pipeline>k__BackingField;
    public DefaultAzureCredentialOptions Options { get; }
    public CredentialPipeline Pipeline { get; }
    public DefaultAzureCredentialFactory(DefaultAzureCredentialOptions options);
    protected DefaultAzureCredentialFactory(DefaultAzureCredentialOptions options, CredentialPipeline pipeline);
    private static DefaultAzureCredentialFactory();
    [CompilerGeneratedAttribute]
public DefaultAzureCredentialOptions get_Options();
    [CompilerGeneratedAttribute]
public CredentialPipeline get_Pipeline();
    public TokenCredential[] CreateCredentialChain();
    public virtual TokenCredential CreateEnvironmentCredential();
    public virtual TokenCredential CreateManagedIdentityCredential();
    public virtual TokenCredential CreateSharedTokenCacheCredential();
    public virtual TokenCredential CreateInteractiveBrowserCredential();
    public virtual TokenCredential CreateAzureCliCredential();
    public virtual TokenCredential CreateVisualStudioCredential();
    public virtual TokenCredential CreateVisualStudioCodeCredential();
    public virtual TokenCredential CreateAzurePowerShellCredential();
}
public class Azure.Identity.DefaultAzureCredentialOptions : TokenCredentialOptions {
    private UpdateTracker`1<string> _tenantId;
    private UpdateTracker`1<string> _interactiveBrowserTenantId;
    private UpdateTracker`1<string> _sharedTokenCacheTenantId;
    private UpdateTracker`1<string> _visualStudioTenantId;
    private UpdateTracker`1<string> _visualStudioCodeTenantId;
    [CompilerGeneratedAttribute]
private IList`1<string> <AdditionallyAllowedTenants>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedTokenCacheUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InteractiveBrowserCredentialClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManagedIdentityClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceIdentifier <ManagedIdentityResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeEnvironmentCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeManagedIdentityCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeSharedTokenCacheCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeInteractiveBrowserCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeAzureCliCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeVisualStudioCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeVisualStudioCodeCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeAzurePowerShellCredential>k__BackingField;
    public string TenantId { get; public set; }
    [EditorBrowsableAttribute("1")]
public string InteractiveBrowserTenantId { get; public set; }
    [EditorBrowsableAttribute("1")]
public string SharedTokenCacheTenantId { get; public set; }
    [EditorBrowsableAttribute("1")]
public string VisualStudioTenantId { get; public set; }
    [EditorBrowsableAttribute("1")]
public string VisualStudioCodeTenantId { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; private set; }
    public string SharedTokenCacheUsername { get; public set; }
    public string InteractiveBrowserCredentialClientId { get; public set; }
    public string ManagedIdentityClientId { get; public set; }
    public ResourceIdentifier ManagedIdentityResourceId { get; public set; }
    public bool ExcludeEnvironmentCredential { get; public set; }
    public bool ExcludeManagedIdentityCredential { get; public set; }
    public bool ExcludeSharedTokenCacheCredential { get; public set; }
    public bool ExcludeInteractiveBrowserCredential { get; public set; }
    public bool ExcludeAzureCliCredential { get; public set; }
    public bool ExcludeVisualStudioCredential { get; public set; }
    public bool ExcludeVisualStudioCodeCredential { get; public set; }
    public bool ExcludeAzurePowerShellCredential { get; public set; }
    public string get_TenantId();
    public void set_TenantId(string value);
    public string get_InteractiveBrowserTenantId();
    public void set_InteractiveBrowserTenantId(string value);
    public string get_SharedTokenCacheTenantId();
    public void set_SharedTokenCacheTenantId(string value);
    public string get_VisualStudioTenantId();
    public void set_VisualStudioTenantId(string value);
    public string get_VisualStudioCodeTenantId();
    public void set_VisualStudioCodeTenantId(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_AdditionallyAllowedTenants();
    [CompilerGeneratedAttribute]
private void set_AdditionallyAllowedTenants(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_SharedTokenCacheUsername();
    [CompilerGeneratedAttribute]
public void set_SharedTokenCacheUsername(string value);
    [CompilerGeneratedAttribute]
public string get_InteractiveBrowserCredentialClientId();
    [CompilerGeneratedAttribute]
public void set_InteractiveBrowserCredentialClientId(string value);
    [CompilerGeneratedAttribute]
public string get_ManagedIdentityClientId();
    [CompilerGeneratedAttribute]
public void set_ManagedIdentityClientId(string value);
    [CompilerGeneratedAttribute]
public ResourceIdentifier get_ManagedIdentityResourceId();
    [CompilerGeneratedAttribute]
public void set_ManagedIdentityResourceId(ResourceIdentifier value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeEnvironmentCredential();
    [CompilerGeneratedAttribute]
public void set_ExcludeEnvironmentCredential(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeManagedIdentityCredential();
    [CompilerGeneratedAttribute]
public void set_ExcludeManagedIdentityCredential(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeSharedTokenCacheCredential();
    [CompilerGeneratedAttribute]
public void set_ExcludeSharedTokenCacheCredential(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeInteractiveBrowserCredential();
    [CompilerGeneratedAttribute]
public void set_ExcludeInteractiveBrowserCredential(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeAzureCliCredential();
    [CompilerGeneratedAttribute]
public void set_ExcludeAzureCliCredential(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeVisualStudioCredential();
    [CompilerGeneratedAttribute]
public void set_ExcludeVisualStudioCredential(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeVisualStudioCodeCredential();
    [CompilerGeneratedAttribute]
public void set_ExcludeVisualStudioCodeCredential(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeAzurePowerShellCredential();
    [CompilerGeneratedAttribute]
public void set_ExcludeAzurePowerShellCredential(bool value);
    internal DefaultAzureCredentialOptions ShallowClone();
    private static string GetNonEmptyStringOrNull(string str);
}
public class Azure.Identity.DeviceCodeCredential : TokenCredential {
    private string _tenantId;
    private String[] _additionallyAllowedTenantIds;
    [CompilerGeneratedAttribute]
private MsalPublicClient <Client>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableAutomaticAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationRecord <Record>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<DeviceCodeInfo, CancellationToken, Task> <DeviceCodeCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialPipeline <Pipeline>k__BackingField;
    private static string AuthenticationRequiredMessage;
    private static string NoDefaultScopeMessage;
    internal MsalPublicClient Client { get; internal set; }
    internal string ClientId { get; }
    internal bool DisableAutomaticAuthentication { get; }
    internal AuthenticationRecord Record { get; private set; }
    internal Func`3<DeviceCodeInfo, CancellationToken, Task> DeviceCodeCallback { get; }
    internal CredentialPipeline Pipeline { get; }
    public DeviceCodeCredential(DeviceCodeCredentialOptions options);
    [EditorBrowsableAttribute("1")]
public DeviceCodeCredential(Func`3<DeviceCodeInfo, CancellationToken, Task> deviceCodeCallback, string clientId, TokenCredentialOptions options);
    [EditorBrowsableAttribute("1")]
public DeviceCodeCredential(Func`3<DeviceCodeInfo, CancellationToken, Task> deviceCodeCallback, string tenantId, string clientId, TokenCredentialOptions options);
    internal DeviceCodeCredential(Func`3<DeviceCodeInfo, CancellationToken, Task> deviceCodeCallback, string tenantId, string clientId, TokenCredentialOptions options, CredentialPipeline pipeline);
    internal DeviceCodeCredential(Func`3<DeviceCodeInfo, CancellationToken, Task> deviceCodeCallback, string tenantId, string clientId, TokenCredentialOptions options, CredentialPipeline pipeline, MsalPublicClient client);
    [CompilerGeneratedAttribute]
internal MsalPublicClient get_Client();
    [CompilerGeneratedAttribute]
internal void set_Client(MsalPublicClient value);
    [CompilerGeneratedAttribute]
internal string get_ClientId();
    [CompilerGeneratedAttribute]
internal bool get_DisableAutomaticAuthentication();
    [CompilerGeneratedAttribute]
internal AuthenticationRecord get_Record();
    [CompilerGeneratedAttribute]
private void set_Record(AuthenticationRecord value);
    [CompilerGeneratedAttribute]
internal Func`3<DeviceCodeInfo, CancellationToken, Task> get_DeviceCodeCallback();
    [CompilerGeneratedAttribute]
internal CredentialPipeline get_Pipeline();
    public virtual AuthenticationRecord Authenticate(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DeviceCodeCredential/<AuthenticateAsync>d__31")]
public virtual Task`1<AuthenticationRecord> AuthenticateAsync(CancellationToken cancellationToken);
    public virtual AuthenticationRecord Authenticate(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DeviceCodeCredential/<AuthenticateAsync>d__33")]
public virtual Task`1<AuthenticationRecord> AuthenticateAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DeviceCodeCredential/<GetTokenAsync>d__35")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    internal static Task DefaultDeviceCodeHandler(DeviceCodeInfo deviceCodeInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DeviceCodeCredential/<AuthenticateImplAsync>d__37")]
private Task`1<AuthenticationRecord> AuthenticateImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DeviceCodeCredential/<GetTokenImplAsync>d__38")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.DeviceCodeCredential/<GetTokenViaDeviceCodeAsync>d__39")]
private Task`1<AccessToken> GetTokenViaDeviceCodeAsync(TokenRequestContext context, bool async, CancellationToken cancellationToken);
    private Task DeviceCodeCallbackImpl(DeviceCodeResult deviceCode, CancellationToken cancellationToken);
}
public class Azure.Identity.DeviceCodeCredentialOptions : TokenCredentialOptions {
    private string _tenantId;
    [CompilerGeneratedAttribute]
private bool <DisableAutomaticAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCachePersistenceOptions <TokenCachePersistenceOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationRecord <AuthenticationRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<DeviceCodeInfo, CancellationToken, Task> <DeviceCodeCallback>k__BackingField;
    public bool DisableAutomaticAuthentication { get; public set; }
    public string TenantId { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    public string ClientId { get; public set; }
    public TokenCachePersistenceOptions TokenCachePersistenceOptions { get; public set; }
    public AuthenticationRecord AuthenticationRecord { get; public set; }
    public Func`3<DeviceCodeInfo, CancellationToken, Task> DeviceCodeCallback { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DisableAutomaticAuthentication();
    [CompilerGeneratedAttribute]
public void set_DisableAutomaticAuthentication(bool value);
    public string get_TenantId();
    public void set_TenantId(string value);
    public IList`1<string> get_AdditionallyAllowedTenants();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual TokenCachePersistenceOptions get_TokenCachePersistenceOptions();
    [CompilerGeneratedAttribute]
public void set_TokenCachePersistenceOptions(TokenCachePersistenceOptions value);
    [CompilerGeneratedAttribute]
public AuthenticationRecord get_AuthenticationRecord();
    [CompilerGeneratedAttribute]
public void set_AuthenticationRecord(AuthenticationRecord value);
    [CompilerGeneratedAttribute]
public Func`3<DeviceCodeInfo, CancellationToken, Task> get_DeviceCodeCallback();
    [CompilerGeneratedAttribute]
public void set_DeviceCodeCallback(Func`3<DeviceCodeInfo, CancellationToken, Task> value);
}
public class Azure.Identity.DeviceCodeInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <UserCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VerificationUri>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Scopes>k__BackingField;
    public string UserCode { get; private set; }
    public string DeviceCode { get; private set; }
    public Uri VerificationUri { get; private set; }
    public DateTimeOffset ExpiresOn { get; private set; }
    public string Message { get; private set; }
    public string ClientId { get; private set; }
    public IReadOnlyCollection`1<string> Scopes { get; private set; }
    internal DeviceCodeInfo(DeviceCodeResult deviceCode);
    internal DeviceCodeInfo(string userCode, string deviceCode, Uri verificationUri, DateTimeOffset expiresOn, string message, string clientId, IReadOnlyCollection`1<string> scopes);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_UserCode();
    [CompilerGeneratedAttribute]
private void set_UserCode(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_DeviceCode();
    [CompilerGeneratedAttribute]
private void set_DeviceCode(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Uri get_VerificationUri();
    [CompilerGeneratedAttribute]
private void set_VerificationUri(Uri value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
private void set_ExpiresOn(DateTimeOffset value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
private void set_ClientId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
private void set_Scopes(IReadOnlyCollection`1<string> value);
}
public class Azure.Identity.EnvironmentCredential : TokenCredential {
    private static string UnavailableErrorMessage;
    private CredentialPipeline _pipeline;
    private TokenCredentialOptions _options;
    [CompilerGeneratedAttribute]
private TokenCredential <Credential>k__BackingField;
    internal TokenCredential Credential { get; }
    public EnvironmentCredential(TokenCredentialOptions options);
    internal EnvironmentCredential(CredentialPipeline pipeline, TokenCredentialOptions options);
    internal EnvironmentCredential(CredentialPipeline pipeline, TokenCredential credential);
    [CompilerGeneratedAttribute]
internal TokenCredential get_Credential();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.EnvironmentCredential/<GetTokenAsync>d__11")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.EnvironmentCredential/<GetTokenImplAsync>d__12")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
}
internal class Azure.Identity.EnvironmentVariables : object {
    public static string Username { get; }
    public static string Password { get; }
    public static string TenantId { get; }
    public static List`1<string> AdditionallyAllowedTenants { get; }
    public static string ClientId { get; }
    public static string ClientSecret { get; }
    public static string ClientCertificatePath { get; }
    public static string ClientSendCertificateChain { get; }
    public static string IdentityEndpoint { get; }
    public static string IdentityHeader { get; }
    public static string MsiEndpoint { get; }
    public static string MsiSecret { get; }
    public static string ImdsEndpoint { get; }
    public static string IdentityServerThumbprint { get; }
    public static string PodIdentityEndpoint { get; }
    public static string Path { get; }
    public static string ProgramFilesX86 { get; }
    public static string ProgramFiles { get; }
    public static string AuthorityHost { get; }
    public static string AzureRegionalAuthorityName { get; }
    public static string AzureFederatedTokenFile { get; }
    public static string get_Username();
    public static string get_Password();
    public static string get_TenantId();
    public static List`1<string> get_AdditionallyAllowedTenants();
    public static string get_ClientId();
    public static string get_ClientSecret();
    public static string get_ClientCertificatePath();
    public static string get_ClientSendCertificateChain();
    public static string get_IdentityEndpoint();
    public static string get_IdentityHeader();
    public static string get_MsiEndpoint();
    public static string get_MsiSecret();
    public static string get_ImdsEndpoint();
    public static string get_IdentityServerThumbprint();
    public static string get_PodIdentityEndpoint();
    public static string get_Path();
    public static string get_ProgramFilesX86();
    public static string get_ProgramFiles();
    public static string get_AuthorityHost();
    public static string get_AzureRegionalAuthorityName();
    public static string get_AzureFederatedTokenFile();
}
internal class Azure.Identity.FileSystemService : object {
    [CompilerGeneratedAttribute]
private static IFileSystemService <Default>k__BackingField;
    public static IFileSystemService Default { get; }
    private static FileSystemService();
    [CompilerGeneratedAttribute]
public static IFileSystemService get_Default();
    public sealed virtual bool FileExists(string path);
    public sealed virtual string ReadAllText(string path);
}
internal class Azure.Identity.HttpPipelineClientFactory : object {
    private HttpPipeline _pipeline;
    public HttpPipelineClientFactory(HttpPipeline pipeline);
    public sealed virtual HttpClient GetHttpClient();
}
internal class Azure.Identity.IdentityCompatSwitches : object {
    internal static string DisableInteractiveThreadpoolExecutionSwitchName;
    internal static string DisableInteractiveThreadpoolExecutionEnvVar;
    internal static string DisableCP1ExecutionSwitchName;
    internal static string DisableCP1ExecutionEnvVar;
    internal static string DisableMultiTenantAuthSwitchName;
    internal static string DisableMultiTenantAuthEnvVar;
    public static bool DisableInteractiveBrowserThreadpoolExecution { get; }
    public static bool DisableCP1 { get; }
    public static bool DisableTenantDiscovery { get; }
    public static bool get_DisableInteractiveBrowserThreadpoolExecution();
    public static bool get_DisableCP1();
    public static bool get_DisableTenantDiscovery();
}
public static class Azure.Identity.IdentityModelFactory : object {
    public static AuthenticationRecord AuthenticationRecord(string username, string authority, string homeAccountId, string tenantId, string clientId);
    public static DeviceCodeInfo DeviceCodeInfo(string userCode, string deviceCode, Uri verificationUri, DateTimeOffset expiresOn, string message, string clientId, IReadOnlyCollection`1<string> scopes);
}
internal interface Azure.Identity.IFileSystemService {
    public abstract virtual bool FileExists(string path);
    public abstract virtual string ReadAllText(string path);
}
internal class Azure.Identity.ImdsManagedIdentitySource : ManagedIdentitySource {
    private static Uri s_imdsEndpoint;
    internal static string imddsTokenPath;
    private static string ImdsApiVersion;
    internal static string IdentityUnavailableError;
    internal static string NoResponseError;
    internal static string TimeoutError;
    internal static string GatewayError;
    internal static string AggregateError;
    private string _clientId;
    private string _resourceId;
    private Uri _imdsEndpoint;
    private Nullable`1<TimeSpan> _imdsNetworkTimeout;
    internal ImdsManagedIdentitySource(ManagedIdentityClientOptions options);
    private static ImdsManagedIdentitySource();
    protected virtual Request CreateRequest(String[] scopes);
    protected virtual HttpMessage CreateHttpMessage(Request request);
    [AsyncStateMachineAttribute("Azure.Identity.ImdsManagedIdentitySource/<AuthenticateAsync>d__15")]
public virtual ValueTask`1<AccessToken> AuthenticateAsync(bool async, TokenRequestContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.ImdsManagedIdentitySource/<HandleResponseAsync>d__16")]
protected virtual ValueTask`1<AccessToken> HandleResponseAsync(bool async, TokenRequestContext context, Response response, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<AccessToken> <>n__0(bool async, TokenRequestContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<AccessToken> <>n__1(bool async, TokenRequestContext context, Response response, CancellationToken cancellationToken);
}
internal interface Azure.Identity.IMsalPublicClientInitializerOptions {
    public Action`1<PublicClientApplicationBuilder> BeforeBuildClient { get; }
    public abstract virtual Action`1<PublicClientApplicationBuilder> get_BeforeBuildClient();
}
internal class Azure.Identity.InMemoryTokenCacheOptions : UnsafeTokenCacheOptions {
    protected internal virtual Task`1<ReadOnlyMemory`1<byte>> RefreshCacheAsync();
    protected internal virtual Task TokenCacheUpdatedAsync(TokenCacheUpdatedArgs tokenCacheUpdatedArgs);
}
public class Azure.Identity.InteractiveBrowserCredential : TokenCredential {
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AdditionallyAllowedTenantIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginHint>k__BackingField;
    [CompilerGeneratedAttribute]
private MsalPublicClient <Client>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableAutomaticAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationRecord <Record>k__BackingField;
    private static string AuthenticationRequiredMessage;
    private static string NoDefaultScopeMessage;
    internal string TenantId { get; }
    internal String[] AdditionallyAllowedTenantIds { get; }
    internal string ClientId { get; }
    internal string LoginHint { get; }
    internal MsalPublicClient Client { get; }
    internal CredentialPipeline Pipeline { get; }
    internal bool DisableAutomaticAuthentication { get; }
    internal AuthenticationRecord Record { get; private set; }
    public InteractiveBrowserCredential(InteractiveBrowserCredentialOptions options);
    [EditorBrowsableAttribute("1")]
public InteractiveBrowserCredential(string clientId);
    [EditorBrowsableAttribute("1")]
public InteractiveBrowserCredential(string tenantId, string clientId, TokenCredentialOptions options);
    internal InteractiveBrowserCredential(string tenantId, string clientId, TokenCredentialOptions options, CredentialPipeline pipeline);
    internal InteractiveBrowserCredential(string tenantId, string clientId, TokenCredentialOptions options, CredentialPipeline pipeline, MsalPublicClient client);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal String[] get_AdditionallyAllowedTenantIds();
    [CompilerGeneratedAttribute]
internal string get_ClientId();
    [CompilerGeneratedAttribute]
internal string get_LoginHint();
    [CompilerGeneratedAttribute]
internal MsalPublicClient get_Client();
    [CompilerGeneratedAttribute]
internal CredentialPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
internal bool get_DisableAutomaticAuthentication();
    [CompilerGeneratedAttribute]
internal AuthenticationRecord get_Record();
    [CompilerGeneratedAttribute]
private void set_Record(AuthenticationRecord value);
    public virtual AuthenticationRecord Authenticate(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.InteractiveBrowserCredential/<AuthenticateAsync>d__34")]
public virtual Task`1<AuthenticationRecord> AuthenticateAsync(CancellationToken cancellationToken);
    public virtual AuthenticationRecord Authenticate(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.InteractiveBrowserCredential/<AuthenticateAsync>d__36")]
public virtual Task`1<AuthenticationRecord> AuthenticateAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.InteractiveBrowserCredential/<GetTokenAsync>d__38")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.InteractiveBrowserCredential/<AuthenticateImplAsync>d__39")]
private Task`1<AuthenticationRecord> AuthenticateImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.InteractiveBrowserCredential/<GetTokenImplAsync>d__40")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.InteractiveBrowserCredential/<GetTokenViaBrowserLoginAsync>d__41")]
private Task`1<AccessToken> GetTokenViaBrowserLoginAsync(TokenRequestContext context, bool async, CancellationToken cancellationToken);
}
public class Azure.Identity.InteractiveBrowserCredentialOptions : TokenCredentialOptions {
    private string _tenantId;
    [CompilerGeneratedAttribute]
private bool <DisableAutomaticAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCachePersistenceOptions <TokenCachePersistenceOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationRecord <AuthenticationRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginHint>k__BackingField;
    public bool DisableAutomaticAuthentication { get; public set; }
    public string TenantId { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    public string ClientId { get; public set; }
    public TokenCachePersistenceOptions TokenCachePersistenceOptions { get; public set; }
    public Uri RedirectUri { get; public set; }
    public AuthenticationRecord AuthenticationRecord { get; public set; }
    public string LoginHint { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DisableAutomaticAuthentication();
    [CompilerGeneratedAttribute]
public void set_DisableAutomaticAuthentication(bool value);
    public string get_TenantId();
    public void set_TenantId(string value);
    public IList`1<string> get_AdditionallyAllowedTenants();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual TokenCachePersistenceOptions get_TokenCachePersistenceOptions();
    [CompilerGeneratedAttribute]
public void set_TokenCachePersistenceOptions(TokenCachePersistenceOptions value);
    [CompilerGeneratedAttribute]
public Uri get_RedirectUri();
    [CompilerGeneratedAttribute]
public void set_RedirectUri(Uri value);
    [CompilerGeneratedAttribute]
public AuthenticationRecord get_AuthenticationRecord();
    [CompilerGeneratedAttribute]
public void set_AuthenticationRecord(AuthenticationRecord value);
    [CompilerGeneratedAttribute]
public string get_LoginHint();
    [CompilerGeneratedAttribute]
public void set_LoginHint(string value);
}
internal interface Azure.Identity.IProcess {
    public bool HasExited { get; }
    public int ExitCode { get; }
    public ProcessStartInfo StartInfo { get; public set; }
    public abstract virtual bool get_HasExited();
    public abstract virtual int get_ExitCode();
    public abstract virtual ProcessStartInfo get_StartInfo();
    public abstract virtual void set_StartInfo(ProcessStartInfo value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Exited(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Exited(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OutputDataReceived(DataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OutputDataReceived(DataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ErrorDataReceived(DataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ErrorDataReceived(DataReceivedEventHandler value);
    public abstract virtual bool Start();
    public abstract virtual void Kill();
    public abstract virtual void BeginOutputReadLine();
    public abstract virtual void BeginErrorReadLine();
}
internal interface Azure.Identity.IProcessService {
    public abstract virtual IProcess Create(ProcessStartInfo startInfo);
}
internal interface Azure.Identity.IScopeHandler {
    public abstract virtual DiagnosticScope CreateScope(ClientDiagnostics diagnostics, string name);
    public abstract virtual void Start(string name, DiagnosticScope& modreq(System.Runtime.InteropServices.InAttribute) scope);
    public abstract virtual void Dispose(string name, DiagnosticScope& modreq(System.Runtime.InteropServices.InAttribute) scope);
    public abstract virtual void Fail(string name, DiagnosticScope& modreq(System.Runtime.InteropServices.InAttribute) scope, Exception exception);
}
internal interface Azure.Identity.ITokenCacheOptions {
    public TokenCachePersistenceOptions TokenCachePersistenceOptions { get; }
    public abstract virtual TokenCachePersistenceOptions get_TokenCachePersistenceOptions();
}
internal interface Azure.Identity.IVisualStudioCodeAdapter {
    public abstract virtual string GetUserSettingsPath();
    public abstract virtual string GetCredentials(string serviceName, string accountName);
}
internal interface Azure.Identity.IX509Certificate2Provider {
    public abstract virtual ValueTask`1<X509Certificate2> GetCertificateAsync(bool async, CancellationToken cancellationToken);
}
internal static class Azure.Identity.LinuxNativeMethods : object {
    public static string SECRET_COLLECTION_SESSION;
    public static IntPtr secret_schema_new(string name, SecretSchemaFlags flags, string attribute1, SecretSchemaAttributeType attribute1Type, string attribute2, SecretSchemaAttributeType attribute2Type);
    public static string secret_password_lookup_sync(IntPtr schemaPtr, IntPtr cancellable, string attribute1Type, string attribute1Value, string attribute2Type, string attribute2Value);
    public static void secret_password_store_sync(IntPtr schemaPtr, string collection, string label, string password, IntPtr cancellable, string attribute1Type, string attribute1Value, string attribute2Type, string attribute2Value);
    public static void secret_password_clear_sync(IntPtr schemaPtr, IntPtr cancellable, string attribute1Type, string attribute1Value, string attribute2Type, string attribute2Value);
    public static void secret_password_free(IntPtr passwordPtr);
    public static void secret_schema_unref(IntPtr schemaPtr);
    private static void HandleError(IntPtr errorPtr, string errorMessage);
}
internal class Azure.Identity.LinuxVisualStudioCodeAdapter : object {
    private static string s_userSettingsJsonPath;
    private static LinuxVisualStudioCodeAdapter();
    public sealed virtual string GetUserSettingsPath();
    public sealed virtual string GetCredentials(string serviceName, string accountName);
    private static string LookupPassword(IntPtr& schemaPtr, string serviceName, string accountName);
    private static IntPtr GetLibsecretSchema();
}
internal static class Azure.Identity.MacosNativeMethods : object {
    public static int SecStatusCodeSuccess;
    public static int SecStatusCodeNoSuchKeychain;
    public static int SecStatusCodeInvalidKeychain;
    public static int SecStatusCodeAuthFailed;
    public static int SecStatusCodeDuplicateItem;
    public static int SecStatusCodeItemNotFound;
    public static int SecStatusCodeInteractionNotAllowed;
    public static int SecStatusCodeInteractionRequired;
    public static int SecStatusCodeNoSuchAttr;
    public static void SecKeychainFindGenericPassword(IntPtr keychainOrArray, string serviceName, string accountName, Int32& passwordLength, IntPtr& credentialsPtr, IntPtr& itemRef);
    public static void SecKeychainAddGenericPassword(IntPtr keychainOrArray, string serviceName, string accountName, string password, IntPtr& itemRef);
    public static void SecKeychainItemDelete(IntPtr itemRef);
    public static void SecKeychainItemFreeContent(IntPtr attrList, IntPtr data);
    public static void CFRelease(IntPtr cfRef);
    private static void ThrowIfError(int status);
    private static string GetErrorMessageString(int status);
}
internal class Azure.Identity.MacosVisualStudioCodeAdapter : object {
    private static string s_userSettingsJsonPath;
    private static MacosVisualStudioCodeAdapter();
    public sealed virtual string GetUserSettingsPath();
    public sealed virtual string GetCredentials(string serviceName, string accountName);
}
internal class Azure.Identity.ManagedIdentityClient : object {
    internal static string MsiUnavailableError;
    private Lazy`1<ManagedIdentitySource> _identitySource;
    [CompilerGeneratedAttribute]
private CredentialPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceIdentifier <ResourceIdentifier>k__BackingField;
    internal CredentialPipeline Pipeline { get; }
    protected internal string ClientId { get; }
    internal ResourceIdentifier ResourceIdentifier { get; }
    public ManagedIdentityClient(CredentialPipeline pipeline, string clientId);
    public ManagedIdentityClient(CredentialPipeline pipeline, ResourceIdentifier resourceId);
    public ManagedIdentityClient(ManagedIdentityClientOptions options);
    [CompilerGeneratedAttribute]
internal CredentialPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
protected internal string get_ClientId();
    [CompilerGeneratedAttribute]
internal ResourceIdentifier get_ResourceIdentifier();
    [AsyncStateMachineAttribute("Azure.Identity.ManagedIdentityClient/<AuthenticateAsync>d__15")]
public virtual ValueTask`1<AccessToken> AuthenticateAsync(bool async, TokenRequestContext context, CancellationToken cancellationToken);
    private static ManagedIdentitySource SelectManagedIdentitySource(ManagedIdentityClientOptions options);
}
internal class Azure.Identity.ManagedIdentityClientOptions : object {
    [CompilerGeneratedAttribute]
private TokenCredentialOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceIdentifier <ResourceIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveTransport>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <InitialImdsConnectionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialPipeline <Pipeline>k__BackingField;
    public TokenCredentialOptions Options { get; public set; }
    public string ClientId { get; public set; }
    public ResourceIdentifier ResourceIdentifier { get; public set; }
    public bool PreserveTransport { get; public set; }
    public Nullable`1<TimeSpan> InitialImdsConnectionTimeout { get; public set; }
    public CredentialPipeline Pipeline { get; public set; }
    [CompilerGeneratedAttribute]
public TokenCredentialOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(TokenCredentialOptions value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public ResourceIdentifier get_ResourceIdentifier();
    [CompilerGeneratedAttribute]
public void set_ResourceIdentifier(ResourceIdentifier value);
    [CompilerGeneratedAttribute]
public bool get_PreserveTransport();
    [CompilerGeneratedAttribute]
public void set_PreserveTransport(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_InitialImdsConnectionTimeout();
    [CompilerGeneratedAttribute]
public void set_InitialImdsConnectionTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public CredentialPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
public void set_Pipeline(CredentialPipeline value);
}
public class Azure.Identity.ManagedIdentityCredential : TokenCredential {
    internal static string MsiUnavailableError;
    private CredentialPipeline _pipeline;
    [CompilerGeneratedAttribute]
private ManagedIdentityClient <Client>k__BackingField;
    private string _clientId;
    private bool _logAccountDetails;
    private static string Troubleshooting;
    internal ManagedIdentityClient Client { get; }
    public ManagedIdentityCredential(string clientId, TokenCredentialOptions options);
    public ManagedIdentityCredential(ResourceIdentifier resourceId, TokenCredentialOptions options);
    internal ManagedIdentityCredential(string clientId, CredentialPipeline pipeline, bool preserveTransport);
    internal ManagedIdentityCredential(ResourceIdentifier resourceId, CredentialPipeline pipeline, bool preserveTransport);
    internal ManagedIdentityCredential(ManagedIdentityClient client);
    [CompilerGeneratedAttribute]
internal ManagedIdentityClient get_Client();
    [AsyncStateMachineAttribute("Azure.Identity.ManagedIdentityCredential/<GetTokenAsync>d__14")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.ManagedIdentityCredential/<GetTokenImplAsync>d__16")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
}
internal abstract class Azure.Identity.ManagedIdentitySource : object {
    internal static string AuthenticationResponseInvalidFormatError;
    internal static string UnexpectedResponse;
    private ManagedIdentityResponseClassifier _responseClassifier;
    [CompilerGeneratedAttribute]
private CredentialPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    protected internal CredentialPipeline Pipeline { get; }
    protected internal string ClientId { get; }
    protected ManagedIdentitySource(CredentialPipeline pipeline);
    [CompilerGeneratedAttribute]
protected internal CredentialPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
protected internal string get_ClientId();
    [AsyncStateMachineAttribute("Azure.Identity.ManagedIdentitySource/<AuthenticateAsync>d__10")]
public virtual ValueTask`1<AccessToken> AuthenticateAsync(bool async, TokenRequestContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.ManagedIdentitySource/<HandleResponseAsync>d__11")]
protected virtual ValueTask`1<AccessToken> HandleResponseAsync(bool async, TokenRequestContext context, Response response, CancellationToken cancellationToken);
    protected abstract virtual Request CreateRequest(String[] scopes);
    protected virtual HttpMessage CreateHttpMessage(Request request);
    [AsyncStateMachineAttribute("Azure.Identity.ManagedIdentitySource/<GetMessageFromResponse>d__14")]
protected static Task`1<string> GetMessageFromResponse(Response response, bool async, CancellationToken cancellationToken);
    protected static string GetMessageFromResponse(JsonElement& root);
    private static AccessToken GetTokenFromResponse(JsonElement& root);
    private static Nullable`1<DateTimeOffset> TryParseExpiresOn(JsonElement jsonExpiresOn);
}
internal class Azure.Identity.MsalCacheHelperWrapper : object {
    private MsalCacheHelper _helper;
    [AsyncStateMachineAttribute("Azure.Identity.MsalCacheHelperWrapper/<InitializeAsync>d__2")]
public virtual Task InitializeAsync(StorageCreationProperties storageCreationProperties, TraceSource logger);
    public virtual void VerifyPersistence();
    public virtual void RegisterCache(ITokenCache tokenCache);
    public virtual void UnregisterCache(ITokenCache tokenCache);
    public virtual Byte[] LoadUnencryptedTokenCache();
    public virtual void SaveUnencryptedTokenCache(Byte[] tokenCache);
}
internal class Azure.Identity.MsalCacheReader : object {
    private string _cachePath;
    private string _cacheLockPath;
    private int _cacheRetryCount;
    private TimeSpan _cacheRetryDelay;
    private DateTimeOffset _lastReadTime;
    public MsalCacheReader(ITokenCache cache, string cachePath, int cacheRetryCount, TimeSpan cacheRetryDelay);
    [AsyncStateMachineAttribute("Azure.Identity.MsalCacheReader/<OnBeforeAccessAsync>d__6")]
private Task OnBeforeAccessAsync(TokenCacheNotificationArgs args);
    [AsyncStateMachineAttribute("Azure.Identity.MsalCacheReader/<ReadCacheFromProtectedStorageAsync>d__7")]
private Task`1<Byte[]> ReadCacheFromProtectedStorageAsync();
}
internal abstract class Azure.Identity.MsalClientBase`1 : object {
    private AsyncLockWithValue`1<TClient> _clientAsyncLock;
    private bool _logAccountDetails;
    [CompilerGeneratedAttribute]
private bool <IsPiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCache <TokenCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialPipeline <Pipeline>k__BackingField;
    protected internal bool IsPiiLoggingEnabled { get; }
    internal string TenantId { get; }
    internal string ClientId { get; }
    internal TokenCache TokenCache { get; }
    protected internal CredentialPipeline Pipeline { get; }
    protected MsalClientBase`1(CredentialPipeline pipeline, string tenantId, string clientId, TokenCredentialOptions options);
    [CompilerGeneratedAttribute]
protected internal bool get_IsPiiLoggingEnabled();
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal string get_ClientId();
    [CompilerGeneratedAttribute]
internal TokenCache get_TokenCache();
    [CompilerGeneratedAttribute]
protected internal CredentialPipeline get_Pipeline();
    protected abstract virtual ValueTask`1<TClient> CreateClientAsync(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalClientBase`1/<GetClientAsync>d__20")]
protected ValueTask`1<TClient> GetClientAsync(bool async, CancellationToken cancellationToken);
    protected void LogMsal(LogLevel level, string message, bool isPii);
    protected void LogAccountDetails(AuthenticationResult result);
}
internal class Azure.Identity.MsalConfidentialClient : MsalClientBase`1<IConfidentialClientApplication> {
    internal string _clientSecret;
    internal bool _includeX5CClaimHeader;
    internal IX509Certificate2Provider _certificateProvider;
    private Func`1<string> _assertionCallback;
    private Func`2<CancellationToken, Task`1<string>> _asyncAssertionCallback;
    [CompilerGeneratedAttribute]
private string <RedirectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionalAuthority>k__BackingField;
    internal string RedirectUrl { get; }
    internal string RegionalAuthority { get; }
    public MsalConfidentialClient(CredentialPipeline pipeline, string tenantId, string clientId, string clientSecret, string redirectUrl, TokenCredentialOptions options);
    public MsalConfidentialClient(CredentialPipeline pipeline, string tenantId, string clientId, IX509Certificate2Provider certificateProvider, bool includeX5CClaimHeader, TokenCredentialOptions options);
    public MsalConfidentialClient(CredentialPipeline pipeline, string tenantId, string clientId, Func`1<string> assertionCallback, TokenCredentialOptions options);
    public MsalConfidentialClient(CredentialPipeline pipeline, string tenantId, string clientId, Func`2<CancellationToken, Task`1<string>> assertionCallback, TokenCredentialOptions options);
    [CompilerGeneratedAttribute]
internal string get_RedirectUrl();
    [CompilerGeneratedAttribute]
internal string get_RegionalAuthority();
    [AsyncStateMachineAttribute("Azure.Identity.MsalConfidentialClient/<CreateClientAsync>d__16")]
protected virtual ValueTask`1<IConfidentialClientApplication> CreateClientAsync(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalConfidentialClient/<AcquireTokenForClientAsync>d__17")]
public virtual ValueTask`1<AuthenticationResult> AcquireTokenForClientAsync(String[] scopes, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalConfidentialClient/<AcquireTokenForClientCoreAsync>d__18")]
public virtual ValueTask`1<AuthenticationResult> AcquireTokenForClientCoreAsync(String[] scopes, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalConfidentialClient/<AcquireTokenSilentAsync>d__19")]
public virtual ValueTask`1<AuthenticationResult> AcquireTokenSilentAsync(String[] scopes, AuthenticationAccount account, string tenantId, string redirectUri, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalConfidentialClient/<AcquireTokenSilentCoreAsync>d__20")]
public virtual ValueTask`1<AuthenticationResult> AcquireTokenSilentCoreAsync(String[] scopes, AuthenticationAccount account, string tenantId, string redirectUri, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalConfidentialClient/<AcquireTokenByAuthorizationCodeAsync>d__21")]
public virtual ValueTask`1<AuthenticationResult> AcquireTokenByAuthorizationCodeAsync(String[] scopes, string code, string tenantId, string redirectUri, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalConfidentialClient/<AcquireTokenByAuthorizationCodeCoreAsync>d__22")]
public virtual ValueTask`1<AuthenticationResult> AcquireTokenByAuthorizationCodeCoreAsync(String[] scopes, string code, string tenantId, string redirectUri, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalConfidentialClient/<AcquireTokenOnBehalfOfAsync>d__23")]
public virtual ValueTask`1<AuthenticationResult> AcquireTokenOnBehalfOfAsync(String[] scopes, string tenantId, UserAssertion userAssertionValue, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalConfidentialClient/<AcquireTokenOnBehalfOfCoreAsync>d__24")]
public virtual ValueTask`1<AuthenticationResult> AcquireTokenOnBehalfOfCoreAsync(String[] scopes, string tenantId, UserAssertion userAssertionValue, bool async, CancellationToken cancellationToken);
}
internal class Azure.Identity.MsalPublicClient : MsalClientBase`1<IPublicClientApplication> {
    private Action`1<PublicClientApplicationBuilder> _beforeBuildClient;
    [CompilerGeneratedAttribute]
private string <RedirectUrl>k__BackingField;
    internal string RedirectUrl { get; }
    public MsalPublicClient(CredentialPipeline pipeline, string tenantId, string clientId, string redirectUrl, TokenCredentialOptions options);
    [CompilerGeneratedAttribute]
internal string get_RedirectUrl();
    protected virtual ValueTask`1<IPublicClientApplication> CreateClientAsync(bool async, CancellationToken cancellationToken);
    protected virtual ValueTask`1<IPublicClientApplication> CreateClientCoreAsync(String[] clientCapabilities, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<GetAccountsAsync>d__8")]
public ValueTask`1<List`1<IAccount>> GetAccountsAsync(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<GetAccountsCoreAsync>d__9")]
protected virtual ValueTask`1<List`1<IAccount>> GetAccountsCoreAsync(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenSilentAsync>d__10")]
public ValueTask`1<AuthenticationResult> AcquireTokenSilentAsync(String[] scopes, string claims, IAccount account, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenSilentCoreAsync>d__11")]
protected virtual ValueTask`1<AuthenticationResult> AcquireTokenSilentCoreAsync(String[] scopes, string claims, IAccount account, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenSilentAsync>d__12")]
public ValueTask`1<AuthenticationResult> AcquireTokenSilentAsync(String[] scopes, string claims, AuthenticationRecord record, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenSilentCoreAsync>d__13")]
protected virtual ValueTask`1<AuthenticationResult> AcquireTokenSilentCoreAsync(String[] scopes, string claims, AuthenticationRecord record, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenInteractiveAsync>d__14")]
public ValueTask`1<AuthenticationResult> AcquireTokenInteractiveAsync(String[] scopes, string claims, Prompt prompt, string loginHint, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenInteractiveCoreAsync>d__15")]
protected virtual ValueTask`1<AuthenticationResult> AcquireTokenInteractiveCoreAsync(String[] scopes, string claims, Prompt prompt, string loginHint, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenByUsernamePasswordAsync>d__16")]
public ValueTask`1<AuthenticationResult> AcquireTokenByUsernamePasswordAsync(String[] scopes, string claims, string username, SecureString password, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenByUsernamePasswordCoreAsync>d__17")]
protected virtual ValueTask`1<AuthenticationResult> AcquireTokenByUsernamePasswordCoreAsync(String[] scopes, string claims, string username, SecureString password, string tenantId, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenWithDeviceCodeAsync>d__18")]
public ValueTask`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(String[] scopes, string claims, Func`2<DeviceCodeResult, Task> deviceCodeCallback, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenWithDeviceCodeCoreAsync>d__19")]
protected virtual ValueTask`1<AuthenticationResult> AcquireTokenWithDeviceCodeCoreAsync(String[] scopes, string claims, Func`2<DeviceCodeResult, Task> deviceCodeCallback, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenByRefreshTokenAsync>d__20")]
public ValueTask`1<AuthenticationResult> AcquireTokenByRefreshTokenAsync(String[] scopes, string claims, string refreshToken, AzureCloudInstance azureCloudInstance, string tenant, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<AcquireTokenByRefreshTokenCoreAsync>d__21")]
protected virtual ValueTask`1<AuthenticationResult> AcquireTokenByRefreshTokenCoreAsync(String[] scopes, string claims, string refreshToken, AzureCloudInstance azureCloudInstance, string tenant, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.MsalPublicClient/<GetAccountsAsync>d__22")]
private static ValueTask`1<List`1<IAccount>> GetAccountsAsync(IPublicClientApplication client, bool async);
}
public class Azure.Identity.OnBehalfOfCredential : TokenCredential {
    internal MsalConfidentialClient _client;
    private string _tenantId;
    private CredentialPipeline _pipeline;
    private string _clientId;
    private string _clientSecret;
    private UserAssertion _userAssertion;
    private String[] _additionallyAllowedTenantIds;
    public OnBehalfOfCredential(string tenantId, string clientId, X509Certificate2 clientCertificate, string userAssertion);
    public OnBehalfOfCredential(string tenantId, string clientId, X509Certificate2 clientCertificate, string userAssertion, OnBehalfOfCredentialOptions options);
    public OnBehalfOfCredential(string tenantId, string clientId, string clientSecret, string userAssertion);
    public OnBehalfOfCredential(string tenantId, string clientId, string clientSecret, string userAssertion, OnBehalfOfCredentialOptions options);
    internal OnBehalfOfCredential(string tenantId, string clientId, X509Certificate2 certificate, string userAssertion, OnBehalfOfCredentialOptions options, CredentialPipeline pipeline, MsalConfidentialClient client);
    internal OnBehalfOfCredential(string tenantId, string clientId, IX509Certificate2Provider certificateProvider, string userAssertion, OnBehalfOfCredentialOptions options, CredentialPipeline pipeline, MsalConfidentialClient client);
    internal OnBehalfOfCredential(string tenantId, string clientId, string clientSecret, string userAssertion, OnBehalfOfCredentialOptions options, CredentialPipeline pipeline, MsalConfidentialClient client);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.OnBehalfOfCredential/<GetTokenInternalAsync>d__17")]
internal ValueTask`1<AccessToken> GetTokenInternalAsync(TokenRequestContext requestContext, bool async, CancellationToken cancellationToken);
}
public class Azure.Identity.OnBehalfOfCredentialOptions : TokenCredentialOptions {
    [CompilerGeneratedAttribute]
private TokenCachePersistenceOptions <TokenCachePersistenceOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendCertificateChain>k__BackingField;
    public TokenCachePersistenceOptions TokenCachePersistenceOptions { get; public set; }
    public bool SendCertificateChain { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    [CompilerGeneratedAttribute]
public sealed virtual TokenCachePersistenceOptions get_TokenCachePersistenceOptions();
    [CompilerGeneratedAttribute]
public void set_TokenCachePersistenceOptions(TokenCachePersistenceOptions value);
    [CompilerGeneratedAttribute]
public bool get_SendCertificateChain();
    [CompilerGeneratedAttribute]
public void set_SendCertificateChain(bool value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
internal class Azure.Identity.ProcessRunner : object {
    private IProcess _process;
    private TimeSpan _timeout;
    private TaskCompletionSource`1<string> _tcs;
    private TaskCompletionSource`1<ICollection`1<string>> _outputTcs;
    private TaskCompletionSource`1<ICollection`1<string>> _errorTcs;
    private ICollection`1<string> _outputData;
    private ICollection`1<string> _errorData;
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _timeoutCts;
    private CancellationTokenRegistration _ctRegistration;
    private bool _logPII;
    public ProcessRunner(IProcess process, TimeSpan timeout, bool logPII, CancellationToken cancellationToken);
    public Task`1<string> RunAsync();
    public string Run();
    private void StartProcess();
    [AsyncStateMachineAttribute("Azure.Identity.ProcessRunner/<HandleExitAsync>d__15")]
private ValueTask HandleExitAsync();
    private void HandleCancel();
    private static void OnDataReceived(DataReceivedEventArgs args, ICollection`1<string> data, TaskCompletionSource`1<ICollection`1<string>> tcs);
    private void TrySetResult(string result);
    private bool TrySetCanceled();
    private void TrySetException(Exception exception);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <StartProcess>b__14_0(object sender, DataReceivedEventArgs args);
    [CompilerGeneratedAttribute]
private void <StartProcess>b__14_1(object sender, DataReceivedEventArgs args);
    [CompilerGeneratedAttribute]
private void <StartProcess>b__14_2(object o, EventArgs e);
}
internal class Azure.Identity.ProcessService : object {
    [CompilerGeneratedAttribute]
private static IProcessService <Default>k__BackingField;
    public static IProcessService Default { get; }
    private static ProcessService();
    [CompilerGeneratedAttribute]
public static IProcessService get_Default();
    public sealed virtual IProcess Create(ProcessStartInfo startInfo);
}
internal class Azure.Identity.ScopeGroupHandler : object {
    private static AsyncLocal`1<IScopeHandler> _currentAsyncLocal;
    private string _groupName;
    private Dictionary`2<string, ChildScopeInfo> _childScopes;
    public static IScopeHandler Current { get; }
    public ScopeGroupHandler(string groupName);
    private static ScopeGroupHandler();
    public static IScopeHandler get_Current();
    public sealed virtual DiagnosticScope CreateScope(ClientDiagnostics diagnostics, string name);
    public void Start(string name, DiagnosticScope& scope);
    public void Dispose(string name, DiagnosticScope& scope);
    public void Fail(string name, DiagnosticScope& scope, Exception exception);
    private static void SucceedChildScope(ChildScopeInfo scopeInfo);
    private static void FailChildScope(ChildScopeInfo scopeInfo);
    private bool IsGroup(string name);
    private sealed virtual override void Azure.Identity.IScopeHandler.Start(string name, DiagnosticScope& modreq(System.Runtime.InteropServices.InAttribute) scope);
    private sealed virtual override void Azure.Identity.IScopeHandler.Dispose(string name, DiagnosticScope& modreq(System.Runtime.InteropServices.InAttribute) scope);
    private sealed virtual override void Azure.Identity.IScopeHandler.Fail(string name, DiagnosticScope& modreq(System.Runtime.InteropServices.InAttribute) scope, Exception exception);
}
internal static class Azure.Identity.ScopeUtilities : object {
    private static string DefaultSuffix;
    private static string ScopePattern;
    private static string InvalidScopeMessage;
    private static Regex scopeRegex;
    private static ScopeUtilities();
    public static string ScopesToResource(String[] scopes);
    public static String[] ResourceToScopes(string resource);
    public static void ValidateScope(string scope);
}
internal class Azure.Identity.SentinelFileLock : object {
    private FileStream _lockFileStream;
    private static int DefaultFileBufferSize;
    private SentinelFileLock(FileStream lockFileStream);
    [AsyncStateMachineAttribute("Azure.Identity.SentinelFileLock/<AcquireAsync>d__3")]
public static Task`1<SentinelFileLock> AcquireAsync(string lockfilePath, int lockFileRetryCount, TimeSpan lockFileRetryDelay);
    public sealed virtual void Dispose();
}
internal class Azure.Identity.ServiceFabricManagedIdentitySource : ManagedIdentitySource {
    private static string ServiceFabricMsiApiVersion;
    private static string IdentityEndpointInvalidUriError;
    private Uri _endpoint;
    private string _identityHeaderValue;
    private string _clientId;
    private string _resourceId;
    private ServiceFabricManagedIdentitySource(CredentialPipeline pipeline, Uri endpoint, string identityHeaderValue, ManagedIdentityClientOptions options);
    public static ManagedIdentitySource TryCreate(ManagedIdentityClientOptions options);
    internal static HttpClientTransport GetServiceFabricMITransport();
    protected virtual Request CreateRequest(String[] scopes);
    private static bool ValidateMsiServerCertificate(HttpRequestMessage message, X509Certificate2 cert, X509Chain certChain, SslPolicyErrors policyErrors);
}
public class Azure.Identity.SharedTokenCacheCredential : TokenCredential {
    internal static string NoAccountsInCacheMessage;
    internal static string MultipleAccountsInCacheMessage;
    internal static string NoMatchingAccountsInCacheMessage;
    internal static string MultipleMatchingAccountsInCacheMessage;
    private static SharedTokenCacheCredentialOptions s_DefaultCacheOptions;
    private CredentialPipeline _pipeline;
    private bool _skipTenantValidation;
    private AuthenticationRecord _record;
    private AsyncLockWithValue`1<IAccount> _accountAsyncLock;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private MsalPublicClient <Client>k__BackingField;
    internal string TenantId { get; }
    internal string Username { get; }
    internal MsalPublicClient Client { get; }
    public SharedTokenCacheCredential(SharedTokenCacheCredentialOptions options);
    [EditorBrowsableAttribute("1")]
public SharedTokenCacheCredential(string username, TokenCredentialOptions options);
    internal SharedTokenCacheCredential(string tenantId, string username, TokenCredentialOptions options, CredentialPipeline pipeline);
    internal SharedTokenCacheCredential(string tenantId, string username, TokenCredentialOptions options, CredentialPipeline pipeline, MsalPublicClient client);
    private static SharedTokenCacheCredential();
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal string get_Username();
    [CompilerGeneratedAttribute]
internal MsalPublicClient get_Client();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.SharedTokenCacheCredential/<GetTokenAsync>d__24")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.SharedTokenCacheCredential/<GetTokenImplAsync>d__25")]
private ValueTask`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.SharedTokenCacheCredential/<GetAccountAsync>d__26")]
private ValueTask`1<IAccount> GetAccountAsync(string tenantId, bool async, CancellationToken cancellationToken);
    private string GetCredentialUnavailableMessage(List`1<IAccount> filteredAccounts);
}
public class Azure.Identity.SharedTokenCacheCredentialOptions : TokenCredentialOptions {
    private string _tenantId;
    internal static TokenCachePersistenceOptions s_defaulTokenCachetPersistenceOptions;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableGuestTenantAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationRecord <AuthenticationRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCachePersistenceOptions <TokenCachePersistenceOptions>k__BackingField;
    public string ClientId { get; public set; }
    public string Username { get; public set; }
    public string TenantId { get; public set; }
    public bool EnableGuestTenantAuthentication { get; public set; }
    public AuthenticationRecord AuthenticationRecord { get; public set; }
    public TokenCachePersistenceOptions TokenCachePersistenceOptions { get; }
    public SharedTokenCacheCredentialOptions(TokenCachePersistenceOptions tokenCacheOptions);
    private static SharedTokenCacheCredentialOptions();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    public string get_TenantId();
    public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public bool get_EnableGuestTenantAuthentication();
    [CompilerGeneratedAttribute]
public void set_EnableGuestTenantAuthentication(bool value);
    [CompilerGeneratedAttribute]
public AuthenticationRecord get_AuthenticationRecord();
    [CompilerGeneratedAttribute]
public void set_AuthenticationRecord(AuthenticationRecord value);
    [CompilerGeneratedAttribute]
public sealed virtual TokenCachePersistenceOptions get_TokenCachePersistenceOptions();
}
[ExtensionAttribute]
internal static class Azure.Identity.StringExtensions : object {
    [ExtensionAttribute]
public static SecureString ToSecureString(string plainString);
}
internal static class Azure.Identity.TenantIdResolver : object {
    public static String[] AllTenants;
    private static TenantIdResolver();
    public static string Resolve(string explicitTenantId, TokenRequestContext context, String[] additionallyAllowedTenantIds);
    public static String[] ResolveAddionallyAllowedTenantIds(IList`1<string> additionallyAllowedTenants);
}
internal class Azure.Identity.TokenCache : object {
    private SemaphoreSlim _lock;
    private DateTimeOffset _lastUpdated;
    private ConditionalWeakTable`2<object, CacheTimestamp> _cacheAccessMap;
    internal Func`1<IPublicClientApplication> _publicClientApplicationFactory;
    private bool _allowUnencryptedStorage;
    private string _name;
    private bool _persistToDisk;
    private static AsyncLockWithValue`1<MsalCacheHelperWrapper> cacheHelperLock;
    private MsalCacheHelperWrapper _cacheHelperWrapper;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    internal Func`2<TokenCacheUpdatedArgs, Task> TokenCacheUpdatedAsync;
    internal Func`3<TokenCacheRefreshArgs, CancellationToken, Task`1<TokenCacheData>> RefreshCacheFromOptionsAsync;
    internal Byte[] Data { get; private set; }
    public TokenCache(TokenCachePersistenceOptions options);
    internal TokenCache(TokenCachePersistenceOptions options, MsalCacheHelperWrapper cacheHelperWrapper, Func`1<IPublicClientApplication> publicApplicationFactory);
    private static TokenCache();
    [CompilerGeneratedAttribute]
internal Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
    [AsyncStateMachineAttribute("Azure.Identity.TokenCache/<RegisterCache>d__18")]
internal virtual Task RegisterCache(bool async, ITokenCache tokenCache, CancellationToken cancellationToken);
    internal static void ResetWrapperCache();
    [AsyncStateMachineAttribute("Azure.Identity.TokenCache/<OnBeforeCacheAccessAsync>d__20")]
private Task OnBeforeCacheAccessAsync(TokenCacheNotificationArgs args);
    [AsyncStateMachineAttribute("Azure.Identity.TokenCache/<OnAfterCacheAccessAsync>d__21")]
private Task OnAfterCacheAccessAsync(TokenCacheNotificationArgs args);
    [AsyncStateMachineAttribute("Azure.Identity.TokenCache/<UpdateCacheDataAsync>d__22")]
private Task UpdateCacheDataAsync(ITokenCacheSerializer tokenCache);
    [AsyncStateMachineAttribute("Azure.Identity.TokenCache/<MergeCacheData>d__23")]
private Task`1<Byte[]> MergeCacheData(Byte[] cacheA, Byte[] cacheB);
    [AsyncStateMachineAttribute("Azure.Identity.TokenCache/<GetCacheHelperAsync>d__24")]
private Task`1<MsalCacheHelperWrapper> GetCacheHelperAsync(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.TokenCache/<GetProtectedCacheHelperAsync>d__25")]
private Task`1<MsalCacheHelperWrapper> GetProtectedCacheHelperAsync(bool async, string name);
    [AsyncStateMachineAttribute("Azure.Identity.TokenCache/<GetFallbackCacheHelperAsync>d__26")]
private Task`1<MsalCacheHelperWrapper> GetFallbackCacheHelperAsync(bool async, string name);
    [AsyncStateMachineAttribute("Azure.Identity.TokenCache/<InitializeCacheHelper>d__27")]
private Task`1<MsalCacheHelperWrapper> InitializeCacheHelper(bool async, StorageCreationProperties storageProperties);
}
public class Azure.Identity.TokenCacheData : ValueType {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <CacheBytes>k__BackingField;
    public ReadOnlyMemory`1<byte> CacheBytes { get; }
    public TokenCacheData(ReadOnlyMemory`1<byte> cacheBytes);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_CacheBytes();
}
public class Azure.Identity.TokenCachePersistenceOptions : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnsafeAllowUnencryptedStorage>k__BackingField;
    public string Name { get; public set; }
    public bool UnsafeAllowUnencryptedStorage { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_UnsafeAllowUnencryptedStorage();
    [CompilerGeneratedAttribute]
public void set_UnsafeAllowUnencryptedStorage(bool value);
}
public class Azure.Identity.TokenCacheRefreshArgs : object {
    [CompilerGeneratedAttribute]
private string <SuggestedCacheKey>k__BackingField;
    public string SuggestedCacheKey { get; }
    internal TokenCacheRefreshArgs(TokenCacheNotificationArgs args);
    [CompilerGeneratedAttribute]
public string get_SuggestedCacheKey();
}
public class Azure.Identity.TokenCacheUpdatedArgs : object {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <UnsafeCacheData>k__BackingField;
    public ReadOnlyMemory`1<byte> UnsafeCacheData { get; }
    internal TokenCacheUpdatedArgs(ReadOnlyMemory`1<byte> cacheData);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_UnsafeCacheData();
}
public class Azure.Identity.TokenCredentialDiagnosticsOptions : DiagnosticsOptions {
    [CompilerGeneratedAttribute]
private bool <IsAccountIdentifierLoggingEnabled>k__BackingField;
    public bool IsAccountIdentifierLoggingEnabled { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsAccountIdentifierLoggingEnabled();
    [CompilerGeneratedAttribute]
public void set_IsAccountIdentifierLoggingEnabled(bool value);
}
public class Azure.Identity.TokenCredentialOptions : ClientOptions {
    private Uri _authorityHost;
    [CompilerGeneratedAttribute]
private bool <IsLoggingPIIEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AdditionallyAllowedTenantsCore>k__BackingField;
    public Uri AuthorityHost { get; public set; }
    internal bool IsLoggingPIIEnabled { get; internal set; }
    internal List`1<string> AdditionallyAllowedTenantsCore { get; internal set; }
    public TokenCredentialDiagnosticsOptions Diagnostics { get; }
    public Uri get_AuthorityHost();
    public void set_AuthorityHost(Uri value);
    [CompilerGeneratedAttribute]
internal bool get_IsLoggingPIIEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsLoggingPIIEnabled(bool value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_AdditionallyAllowedTenantsCore();
    [CompilerGeneratedAttribute]
internal void set_AdditionallyAllowedTenantsCore(List`1<string> value);
    public TokenCredentialDiagnosticsOptions get_Diagnostics();
}
internal class Azure.Identity.TokenExchangeManagedIdentitySource : ManagedIdentitySource {
    private TokenFileCache _tokenFileCache;
    private ClientAssertionCredential _clientAssertionCredential;
    private TokenExchangeManagedIdentitySource(CredentialPipeline pipeline, string tenantId, string clientId, string tokenFilePath);
    public static ManagedIdentitySource TryCreate(ManagedIdentityClientOptions options);
    [AsyncStateMachineAttribute("Azure.Identity.TokenExchangeManagedIdentitySource/<AuthenticateAsync>d__4")]
public virtual ValueTask`1<AccessToken> AuthenticateAsync(bool async, TokenRequestContext context, CancellationToken cancellationToken);
    protected virtual Request CreateRequest(String[] scopes);
}
public abstract class Azure.Identity.UnsafeTokenCacheOptions : TokenCachePersistenceOptions {
    protected internal abstract virtual Task TokenCacheUpdatedAsync(TokenCacheUpdatedArgs tokenCacheUpdatedArgs);
    protected internal abstract virtual Task`1<ReadOnlyMemory`1<byte>> RefreshCacheAsync();
    [AsyncStateMachineAttribute("Azure.Identity.UnsafeTokenCacheOptions/<RefreshCacheAsync>d__2")]
protected internal virtual Task`1<TokenCacheData> RefreshCacheAsync(TokenCacheRefreshArgs args, CancellationToken cancellationToken);
}
public class Azure.Identity.UsernamePasswordCredential : TokenCredential {
    private static string NoDefaultScopeMessage;
    private static string Troubleshooting;
    private string _clientId;
    private CredentialPipeline _pipeline;
    private string _username;
    private SecureString _password;
    private AuthenticationRecord _record;
    private string _tenantId;
    private String[] _additionallyAllowedTenantIds;
    [CompilerGeneratedAttribute]
private MsalPublicClient <Client>k__BackingField;
    internal MsalPublicClient Client { get; }
    public UsernamePasswordCredential(string username, string password, string tenantId, string clientId);
    public UsernamePasswordCredential(string username, string password, string tenantId, string clientId, TokenCredentialOptions options);
    public UsernamePasswordCredential(string username, string password, string tenantId, string clientId, UsernamePasswordCredentialOptions options);
    internal UsernamePasswordCredential(string username, string password, string tenantId, string clientId, TokenCredentialOptions options, CredentialPipeline pipeline, MsalPublicClient client);
    [CompilerGeneratedAttribute]
internal MsalPublicClient get_Client();
    public virtual AuthenticationRecord Authenticate(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.UsernamePasswordCredential/<AuthenticateAsync>d__18")]
public virtual Task`1<AuthenticationRecord> AuthenticateAsync(CancellationToken cancellationToken);
    public virtual AuthenticationRecord Authenticate(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.UsernamePasswordCredential/<AuthenticateAsync>d__20")]
public virtual Task`1<AuthenticationRecord> AuthenticateAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.UsernamePasswordCredential/<GetTokenAsync>d__22")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.UsernamePasswordCredential/<AuthenticateImplAsync>d__23")]
private Task`1<AuthenticationResult> AuthenticateImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.UsernamePasswordCredential/<GetTokenImplAsync>d__24")]
private Task`1<AccessToken> GetTokenImplAsync(bool async, TokenRequestContext requestContext, CancellationToken cancellationToken);
}
public class Azure.Identity.UsernamePasswordCredentialOptions : TokenCredentialOptions {
    [CompilerGeneratedAttribute]
private TokenCachePersistenceOptions <TokenCachePersistenceOptions>k__BackingField;
    public TokenCachePersistenceOptions TokenCachePersistenceOptions { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    [CompilerGeneratedAttribute]
public sealed virtual TokenCachePersistenceOptions get_TokenCachePersistenceOptions();
    [CompilerGeneratedAttribute]
public void set_TokenCachePersistenceOptions(TokenCachePersistenceOptions value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
internal static class Azure.Identity.Validations : object {
    private static string InvalidTenantIdErrorMessage;
    private static string NullTenantIdErrorMessage;
    private static string NonTlsAuthorityHostErrorMessage;
    internal static string NoWindowsPowerShellLegacyErrorMessage;
    public static string ValidateTenantId(string tenantId, string argumentName, bool allowNull);
    public static Uri ValidateAuthorityHost(Uri authorityHost);
    public static bool CanUseLegacyPowerShell(bool useLegacyPowerShell);
    private static bool IsValidTenantCharacter(char c);
}
public class Azure.Identity.VisualStudioCodeCredential : TokenCredential {
    private static string CredentialsSection;
    private static string ClientId;
    private IVisualStudioCodeAdapter _vscAdapter;
    private IFileSystemService _fileSystem;
    private CredentialPipeline _pipeline;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    internal String[] AdditionallyAllowedTenantIds;
    private static string _commonTenant;
    private static string Troubleshooting;
    [CompilerGeneratedAttribute]
private MsalPublicClient <Client>k__BackingField;
    internal string TenantId { get; }
    internal MsalPublicClient Client { get; }
    public VisualStudioCodeCredential(VisualStudioCodeCredentialOptions options);
    internal VisualStudioCodeCredential(VisualStudioCodeCredentialOptions options, CredentialPipeline pipeline, MsalPublicClient client, IFileSystemService fileSystem, IVisualStudioCodeAdapter vscAdapter);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal MsalPublicClient get_Client();
    [AsyncStateMachineAttribute("Azure.Identity.VisualStudioCodeCredential/<GetTokenAsync>d__17")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.VisualStudioCodeCredential/<GetTokenImplAsync>d__19")]
private ValueTask`1<AccessToken> GetTokenImplAsync(TokenRequestContext requestContext, bool async, CancellationToken cancellationToken);
    private string GetStoredCredentials(string environmentName);
    private static bool IsRefreshTokenString(string str);
    private void GetUserSettings(String& tenant, String& environmentName);
    private static IVisualStudioCodeAdapter GetVscAdapter();
    private static AzureCloudInstance GetAzureCloudInstance(string name);
}
public class Azure.Identity.VisualStudioCodeCredentialOptions : TokenCredentialOptions {
    private string _tenantId;
    public string TenantId { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    public string get_TenantId();
    public void set_TenantId(string value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
public class Azure.Identity.VisualStudioCredential : TokenCredential {
    private static string TokenProviderFilePath;
    private static string ResourceArgumentName;
    private static string TenantArgumentName;
    private CredentialPipeline _pipeline;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AdditionallyAllowedTenantIds>k__BackingField;
    private IFileSystemService _fileSystem;
    private IProcessService _processService;
    private bool _logPII;
    private bool _logAccountDetails;
    internal string TenantId { get; }
    internal String[] AdditionallyAllowedTenantIds { get; }
    public VisualStudioCredential(VisualStudioCredentialOptions options);
    internal VisualStudioCredential(string tenantId, CredentialPipeline pipeline, IFileSystemService fileSystem, IProcessService processService, VisualStudioCredentialOptions options);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal String[] get_AdditionallyAllowedTenantIds();
    [AsyncStateMachineAttribute("Azure.Identity.VisualStudioCredential/<GetTokenAsync>d__17")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.VisualStudioCredential/<GetTokenImplAsync>d__19")]
private ValueTask`1<AccessToken> GetTokenImplAsync(TokenRequestContext requestContext, bool async, CancellationToken cancellationToken);
    private static string GetTokenProviderPath();
    [AsyncStateMachineAttribute("Azure.Identity.VisualStudioCredential/<RunProcessesAsync>d__21")]
private Task`1<AccessToken> RunProcessesAsync(List`1<ProcessStartInfo> processStartInfos, bool async, CancellationToken cancellationToken);
    private List`1<ProcessStartInfo> GetProcessStartInfos(VisualStudioTokenProvider[] visualStudioTokenProviders, string resource, TokenRequestContext requestContext, CancellationToken cancellationToken);
    private VisualStudioTokenProvider[] GetTokenProviders(string tokenProviderPath);
    private string GetTokenProviderContent(string tokenProviderPath);
    private static String[] GetStringArrayPropertyValue(JsonElement element, string name);
}
public class Azure.Identity.VisualStudioCredentialOptions : TokenCredentialOptions {
    private string _tenantId;
    public string TenantId { get; public set; }
    public IList`1<string> AdditionallyAllowedTenants { get; }
    public string get_TenantId();
    public void set_TenantId(string value);
    public IList`1<string> get_AdditionallyAllowedTenants();
}
internal static class Azure.Identity.WindowsNativeMethods : object {
    public static int ERROR_NOT_FOUND;
    public static UInt32 FORMAT_MESSAGE_ALLOCATE_BUFFER;
    public static UInt32 FORMAT_MESSAGE_IGNORE_INSERTS;
    public static UInt32 FORMAT_MESSAGE_FROM_SYSTEM;
    public static IntPtr CredRead(string target, CRED_TYPE type);
    public static void CredWrite(IntPtr userCredential);
    public static void CredDelete(string target, CRED_TYPE type);
    public static void CredFree(IntPtr userCredential);
    private static void ThrowIfFailed(bool isSucceeded, string methodName);
    private static string MessageFromErrorCode(int errorCode);
}
internal class Azure.Identity.WindowsVisualStudioCodeAdapter : object {
    private static string s_userSettingsJsonPath;
    private static WindowsVisualStudioCodeAdapter();
    public sealed virtual string GetUserSettingsPath();
    public sealed virtual string GetCredentials(string serviceName, string accountName);
}
internal class Azure.Identity.X509Certificate2FromFileProvider : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePath>k__BackingField;
    private X509Certificate2 Certificate { get; private set; }
    internal string CertificatePath { get; }
    public X509Certificate2FromFileProvider(string clientCertificatePath);
    [CompilerGeneratedAttribute]
private X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
internal string get_CertificatePath();
    public sealed virtual ValueTask`1<X509Certificate2> GetCertificateAsync(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.X509Certificate2FromFileProvider/<LoadCertificateFromPfxFileAsync>d__9")]
private ValueTask`1<X509Certificate2> LoadCertificateFromPfxFileAsync(bool async, string clientCertificatePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Identity.X509Certificate2FromFileProvider/<LoadCertificateFromPemFileAsync>d__10")]
private ValueTask`1<X509Certificate2> LoadCertificateFromPemFileAsync(bool async, string clientCertificatePath, CancellationToken cancellationToken);
}
internal class Azure.Identity.X509Certificate2FromObjectProvider : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    private X509Certificate2 Certificate { get; }
    public X509Certificate2FromObjectProvider(X509Certificate2 clientCertificate);
    [CompilerGeneratedAttribute]
private X509Certificate2 get_Certificate();
    public sealed virtual ValueTask`1<X509Certificate2> GetCertificateAsync(bool async, CancellationToken cancellationToken);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
