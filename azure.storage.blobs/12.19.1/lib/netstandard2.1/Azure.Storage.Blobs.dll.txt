[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Autorest.CSharp.Core.GeneratorPageableHelpers : object {
    private static Byte[] DefaultItemPropertyName;
    private static Byte[] DefaultNextLinkPropertyName;
    private static GeneratorPageableHelpers();
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Autorest.CSharp.Core.GeneratorPageableHelpers/<CreateAsyncPageable>d__10`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
}
internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
internal static class Azure.Core.Argument : object {
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static void AssertEnumDefined(Type enumType, object value, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    [NullableContextAttribute("1")]
public static void AssertNull(T value, string name, string message);
}
internal class Azure.Core.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private static int DefaultInitialBufferSize;
    [CompilerGeneratedAttribute]
private int <WrittenCount>k__BackingField;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; private set; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    [CompilerGeneratedAttribute]
public int get_WrittenCount();
    [CompilerGeneratedAttribute]
private void set_WrittenCount(int value);
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.AsyncLockWithValue`1 : object {
    private object _syncObj;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters;
    private bool _isLocked;
    private bool _hasValue;
    private long _index;
    [NullableAttribute("2")]
private T _value;
    public bool HasValue { get; }
    public AsyncLockWithValue`1(T value);
    public bool get_HasValue();
    [NullableContextAttribute("2")]
public bool TryGetValue(T& value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.AsyncLockWithValue`1/<GetLockOrValueAsync>d__11")]
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken);
    private void SetValue(T value, Int64& lockIndex);
    private void Reset(Int64& lockIndex);
    private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter);
}
internal static class Azure.Core.AuthorizationChallengeParser : object {
    [NullableContextAttribute("1")]
public static string GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter);
    internal static bool TryGetNextChallenge(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& challengeKey);
    internal static bool TryGetNextParameter(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& paramKey, ReadOnlySpan`1& paramValue, char separator);
}
[AttributeUsageAttribute("1")]
internal class Azure.Core.AzureResourceProviderNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ResourceProviderNamespace>k__BackingField;
    public string ResourceProviderNamespace { get; }
    public AzureResourceProviderNamespaceAttribute(string resourceProviderNamespace);
    [CompilerGeneratedAttribute]
public string get_ResourceProviderNamespace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.AzureSasCredentialSynchronousPolicy : HttpPipelineSynchronousPolicy {
    private AzureSasCredential _credential;
    public AzureSasCredentialSynchronousPolicy(AzureSasCredential credential);
    public virtual void OnSendingRequest(HttpMessage message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Azure.Core.CallerShouldAuditAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.CancellationHelper : object {
    private static string s_cancellationMessage;
    private static CancellationHelper();
    internal static bool ShouldWrapInOperationCanceledException(Exception exception, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
internal static Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken, string message);
    [NullableContextAttribute("2")]
private static void ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken);
    internal static void ThrowIfCancellationRequested(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Azure.Core.ChangeTrackingDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<TKey, TValue> _innerDictionary;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public ChangeTrackingDictionary`2(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optionalDictionary);
    public ChangeTrackingDictionary`2(Optional`1<IDictionary`2<TKey, TValue>> optionalDictionary);
    private ChangeTrackingDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    private ChangeTrackingDictionary`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    public bool get_IsUndefined();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private IDictionary`2<TKey, TValue> EnsureDictionary();
    [IteratorStateMachineAttribute("Azure.Core.ChangeTrackingDictionary`2/<<GetEnumerator>g__GetEmptyEnumerator|8_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__GetEmptyEnumerator|8_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Azure.Core.ChangeTrackingList`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<T> _innerList;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ChangeTrackingList`1(Optional`1<IList`1<T>> optionalList);
    public ChangeTrackingList`1(Optional`1<IReadOnlyList`1<T>> optionalList);
    private ChangeTrackingList`1(IEnumerable`1<T> innerList);
    private ChangeTrackingList`1(IList`1<T> innerList);
    public bool get_IsUndefined();
    public void Reset();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private IList`1<T> EnsureList();
    [IteratorStateMachineAttribute("Azure.Core.ChangeTrackingList`1/<<GetEnumerator>g__EnumerateEmpty|9_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<T> <GetEnumerator>g__EnumerateEmpty|9_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Azure.Core.CodeGenClientAttribute : CodeGenTypeAttribute {
    [CompilerGeneratedAttribute]
private Type <ParentClient>k__BackingField;
    public Type ParentClient { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenClientAttribute(string originalName);
    [CompilerGeneratedAttribute]
public Type get_ParentClient();
    [CompilerGeneratedAttribute]
public void set_ParentClient(Type value);
}
[AttributeUsageAttribute("384")]
internal class Azure.Core.CodeGenMemberAttribute : CodeGenTypeAttribute {
    [NullableContextAttribute("1")]
public CodeGenMemberAttribute(string originalName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
internal class Azure.Core.CodeGenMemberSerializationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <SerializationPath>k__BackingField;
    public String[] SerializationPath { get; }
    public CodeGenMemberSerializationAttribute(String[] serializationPath);
    [CompilerGeneratedAttribute]
public String[] get_SerializationPath();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
internal class Azure.Core.CodeGenMemberSerializationHooksAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <SerializationValueHook>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeserializationValueHook>k__BackingField;
    public string SerializationValueHook { get; public set; }
    public string DeserializationValueHook { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SerializationValueHook();
    [CompilerGeneratedAttribute]
public void set_SerializationValueHook(string value);
    [CompilerGeneratedAttribute]
public string get_DeserializationValueHook();
    [CompilerGeneratedAttribute]
public void set_DeserializationValueHook(string value);
}
[AttributeUsageAttribute("28")]
internal class Azure.Core.CodeGenModelAttribute : CodeGenTypeAttribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Usage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Formats>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Usage { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Formats { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenModelAttribute(string originalName);
    [CompilerGeneratedAttribute]
public String[] get_Usage();
    [CompilerGeneratedAttribute]
public void set_Usage(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Formats();
    [CompilerGeneratedAttribute]
public void set_Formats(String[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Azure.Core.CodeGenOverrideServiceVersionsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Versions>k__BackingField;
    public String[] Versions { get; }
    public CodeGenOverrideServiceVersionsAttribute(String[] versions);
    [CompilerGeneratedAttribute]
public String[] get_Versions();
}
[AttributeUsageAttribute("28")]
internal class Azure.Core.CodeGenSuppressAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <Parameters>k__BackingField;
    public string Member { get; }
    public Type[] Parameters { get; }
    public CodeGenSuppressAttribute(string member, Type[] parameters);
    [CompilerGeneratedAttribute]
public string get_Member();
    [CompilerGeneratedAttribute]
public Type[] get_Parameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Azure.Core.CodeGenSuppressTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Typename>k__BackingField;
    public string Typename { get; }
    public CodeGenSuppressTypeAttribute(string typename);
    [CompilerGeneratedAttribute]
public string get_Typename();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Azure.Core.CodeGenTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <OriginalName>k__BackingField;
    public string OriginalName { get; }
    public CodeGenTypeAttribute(string originalName);
    [CompilerGeneratedAttribute]
public string get_OriginalName();
}
internal class Azure.Core.FixedDelayWithNoJitterStrategy : DelayStrategy {
    private static TimeSpan DefaultDelay;
    private TimeSpan _delay;
    public FixedDelayWithNoJitterStrategy(Nullable`1<TimeSpan> suggestedDelay);
    private static FixedDelayWithNoJitterStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.FormUrlEncodedContent : RequestContent {
    private List`1<KeyValuePair`2<string, string>> _values;
    private Encoding Latin1;
    private Byte[] _bytes;
    public void Add(string parameter, string value);
    private void BuildIfNeeded();
    [AsyncStateMachineAttribute("Azure.Core.FormUrlEncodedContent/<WriteToAsync>d__5")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
    private Byte[] GetContentByteArray(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static string Encode(string data);
}
[AttributeUsageAttribute("64")]
internal class Azure.Core.ForwardsClientCallsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <SkipChecks>k__BackingField;
    public bool SkipChecks { get; }
    public ForwardsClientCallsAttribute(bool skipChecks);
    [CompilerGeneratedAttribute]
public bool get_SkipChecks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.HashCodeBuilder : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCodeBuilder();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    public static UInt32 RotateLeft(UInt32 value, int offset);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
internal class Azure.Core.HttpMessageSanitizer : object {
    private static string LogAllValue;
    private bool _logAllHeaders;
    private bool _logFullQueries;
    private String[] _allowedQueryParameters;
    private string _redactedPlaceholder;
    private HashSet`1<string> _allowedHeaders;
    internal static HttpMessageSanitizer Default;
    public HttpMessageSanitizer(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder);
    private static HttpMessageSanitizer();
    public string SanitizeHeader(string name, string value);
    public string SanitizeUrl(string url);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.HttpPipelineExtensions : object {
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessMessageAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<Response> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response ProcessMessage(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessHeadAsBoolMessageAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<bool>> ProcessHeadAsBoolMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [ExtensionAttribute]
public static Response`1<bool> ProcessHeadAsBoolMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [NullableContextAttribute("0")]
private static ValueTuple`2<CancellationToken, ErrorOptions> ApplyRequestContext(RequestContext requestContext);
}
internal interface Azure.Core.IOperation {
    public abstract virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Azure.Core.IOperation`1 {
    public abstract virtual ValueTask`1<OperationState`1<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
internal interface Azure.Core.IOperationSource`1 {
    public abstract virtual T CreateResult(Response response, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<T> CreateResultAsync(Response response, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IUtf8JsonSerializable {
    public abstract virtual void Write(Utf8JsonWriter writer);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IXmlSerializable {
    public abstract virtual void Write(XmlWriter writer, string nameHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.JsonElementExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static object GetObject(JsonElement& element);
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64(JsonElement& element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffset(JsonElement& element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpan(JsonElement& element, string format);
    [ExtensionAttribute]
public static char GetChar(JsonElement& element);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ThrowNonNullablePropertyIsNull(JsonProperty property);
    [ExtensionAttribute]
public static string GetRequiredString(JsonElement& element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.NextLinkOperationImplementation : object {
    private static string ApiVersionParam;
    private static String[] FailureStates;
    private static String[] SuccessStates;
    private HeaderSource _headerSource;
    private bool _originalResponseHasLocation;
    private Uri _startRequestUri;
    private OperationFinalStateVia _finalStateVia;
    private RequestMethod _requestMethod;
    private HttpPipeline _pipeline;
    [NullableAttribute("2")]
private string _apiVersion;
    [NullableAttribute("2")]
private string _lastKnownLocation;
    private string _nextRequestUri;
    private NextLinkOperationImplementation(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, HeaderSource headerSource, bool originalResponseHasLocation, string lastKnownLocation, OperationFinalStateVia finalStateVia, string apiVersion);
    private static NextLinkOperationImplementation();
    public static IOperation Create(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    public static IOperation`1<T> Create(IOperationSource`1<T> operationSource, HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<UpdateStateAsync>d__15")]
public sealed virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
    private static OperationState GetOperationStateFromFinalResponse(RequestMethod requestMethod, Response response);
    private void UpdateNextRequestUri(ResponseHeaders headers);
    internal static string AppendOrReplaceApiVersion(string uri, string apiVersion);
    [NullableContextAttribute("0")]
internal static bool TryGetApiVersion(Uri startRequestUri, ReadOnlySpan`1& apiVersion);
    [NullableContextAttribute("2")]
private string GetFinalUri(string resourceLocation);
    [AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<GetResponseAsync>d__21")]
private ValueTask`1<Response> GetResponseAsync(bool async, string uri, CancellationToken cancellationToken);
    private HttpMessage CreateRequest(string uri);
    private static bool IsFinalState(Response response, HeaderSource headerSource, Nullable`1& failureState, String& resourceLocation);
    private static bool ShouldIgnoreHeader(RequestMethod method, Response response);
    private static HeaderSource GetHeaderSource(RequestMethod requestMethod, Uri requestUri, Response response, string apiVersion, String& nextRequestUri);
}
internal enum Azure.Core.OperationFinalStateVia : Enum {
    public int value__;
    public static OperationFinalStateVia AzureAsyncOperation;
    public static OperationFinalStateVia Location;
    public static OperationFinalStateVia OriginalUri;
    public static OperationFinalStateVia OperationLocation;
    public static OperationFinalStateVia LocationOverride;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.OperationHelpers : object {
    public static T GetValue(T& value);
    [NullableContextAttribute("0")]
public static T GetValue(Nullable`1& value);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__2`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__3`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__6")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__7")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal : OperationInternalBase {
    private OperationInternal`1<VoidValue> _internalOperation;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public OperationInternal(IOperation operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    private OperationInternal(OperationState finalState);
    public static OperationInternal Succeeded(Response rawResponse);
    public static OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal/<UpdateStatusAsync>d__9")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal`1 : OperationInternalBase {
    private IOperation`1<T> _operation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLockWithValue`1<OperationState`1<T>> _stateLock;
    private Response _rawResponse;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    public T Value { get; }
    public OperationInternal`1(IOperation`1<T> operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    private OperationInternal`1(OperationState`1<T> finalState);
    public static OperationInternal`1<T> Succeeded(Response rawResponse, T value);
    public static OperationInternal`1<T> Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    public bool get_HasValue();
    public T get_Value();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__15")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__16")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__19")]
private ValueTask`1<Response`1<T>> WaitForCompletionAsync(bool async, Nullable`1<TimeSpan> pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<UpdateStatusAsync>d__20")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    private static Response GetResponseFromState(OperationState`1<T> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.OperationInternalBase : object {
    private ClientDiagnostics _diagnostics;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> _scopeAttributes;
    [NullableAttribute("2")]
private DelayStrategy _fallbackStrategy;
    private AsyncLockWithValue`1<Response> _responseLock;
    private string _waitForCompletionResponseScopeName;
    protected string _updateStatusScopeName;
    protected string _waitForCompletionScopeName;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    protected OperationInternalBase(Response rawResponse);
    protected OperationInternalBase(ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    public abstract virtual Response get_RawResponse();
    public abstract virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<UpdateStatusAsync>d__13")]
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__15")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__16")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__19")]
protected ValueTask`1<Response> WaitForCompletionResponseAsync(bool async, Nullable`1<TimeSpan> pollingInterval, string scopeName, CancellationToken cancellationToken);
    protected abstract virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    protected DiagnosticScope CreateScope(string scopeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationPoller : object {
    private DelayStrategy _delayStrategy;
    [NullableContextAttribute("2")]
public OperationPoller(DelayStrategy strategy);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__6`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__8`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__10")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__11")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<Delay>d__12")]
private static ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState : ValueType {
    [CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    [NullableAttribute("2")]
public RequestFailedException OperationFailedException { get; }
    private OperationState(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException operationFailedException);
    [CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    public static OperationState Success(Response rawResponse);
    public static OperationState Failure(Response rawResponse, RequestFailedException operationFailedException);
    public static OperationState Pending(Response rawResponse);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    [NullableAttribute("1")]
public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    public T Value { get; }
    public RequestFailedException OperationFailedException { get; }
    private OperationState`1(Response rawResponse, bool hasCompleted, bool hasSucceeded, T value, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    [NullableContextAttribute("1")]
public static OperationState`1<T> Success(Response rawResponse, T value);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Failure(Response rawResponse, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Pending(Response rawResponse);
}
internal static class Azure.Core.Optional : object {
    public static bool IsCollectionDefined(IEnumerable`1<T> collection);
    public static bool IsCollectionDefined(IReadOnlyDictionary`2<TKey, TValue> collection);
    public static bool IsCollectionDefined(IDictionary`2<TKey, TValue> collection);
    public static bool IsDefined(Nullable`1<T> value);
    public static bool IsDefined(object value);
    public static bool IsDefined(string value);
    public static bool IsDefined(JsonElement value);
    public static IReadOnlyDictionary`2<TKey, TValue> ToDictionary(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optional);
    public static IDictionary`2<TKey, TValue> ToDictionary(Optional`1<IDictionary`2<TKey, TValue>> optional);
    public static IReadOnlyList`1<T> ToList(Optional`1<IReadOnlyList`1<T>> optional);
    public static IList`1<T> ToList(Optional`1<IList`1<T>> optional);
    public static Nullable`1<T> ToNullable(Optional`1<T> optional);
    public static Nullable`1<T> ToNullable(Optional`1<Nullable`1<T>> optional);
}
[IsReadOnlyAttribute]
internal class Azure.Core.Optional`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public T Value { get; }
    public bool HasValue { get; }
    public Optional`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    public static Optional`1<T> op_Implicit(T value);
    public static T op_Implicit(Optional`1<T> optional);
}
internal static class Azure.Core.Page : object {
    [NullableContextAttribute("1")]
public static Page`1<T> FromValues(IEnumerable`1<T> values, string continuationToken, Response response);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.PageableHelpers : object {
    private static Byte[] DefaultItemPropertyName;
    private static Byte[] DefaultNextLinkPropertyName;
    private static PageableHelpers();
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.PageableHelpers/<CreateAsyncPageable>d__10`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
    private static ValueTuple`2<List`1<T>, string> ParseResponseForBinaryData(Response response, Byte[] itemPropertyName, Byte[] nextLinkPropertyName);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static object <ParseResponseForBinaryData>g__ReadBinaryData|19_0(Utf8JsonReader& r, ReadOnlyMemory`1& content);
}
internal static class Azure.Core.Pipeline.ActivityExtensions : object {
    [CompilerGeneratedAttribute]
private static bool <SupportsActivitySource>k__BackingField;
    public static bool SupportsActivitySource { get; private set; }
    private static ActivityExtensions();
    [CompilerGeneratedAttribute]
public static bool get_SupportsActivitySource();
    [CompilerGeneratedAttribute]
private static void set_SupportsActivitySource(bool value);
    public static void ResetFeatureSwitch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
    public ClientDiagnostics(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities);
    public ClientDiagnostics(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities);
    internal static HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics);
    internal static string GetResourceProviderNamespace(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Pipeline.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    internal static string OpenTelemetrySchemaAttribute;
    internal static string OpenTelemetrySchemaVersion;
    private static object AzureSdkScopeValue;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    [RequiresUnreferencedCodeAttribute("The diagnosticSourceArgs are used in a call to DiagnosticSource.Write, all necessary properties need to be preserved on the type being passed in using DynamicDependency attributes.")]
internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public void AddAttribute(string name, string value);
    public void AddIntegerAttribute(string name, int value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, string> attributes);
    public void Start();
    public void SetDisplayName(string displayName);
    public void SetStartTime(DateTime dateTime);
    public void SetTraceContext(string traceparent, string tracestate);
    public sealed virtual void Dispose();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(Exception exception);
    public void Failed(string errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    private bool _isStable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ActivitySource> ActivitySources;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable);
    private static DiagnosticScopeFactory();
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public DiagnosticScope CreateScope(string name, ActivityKind kind);
    private ActivitySource GetActivitySource(string ns, string name);
}
internal static class Azure.Core.Pipeline.RetriableStream : object {
    public static Stream Create(Func`2<long, Stream> responseFactory, Func`2<long, ValueTask`1<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries);
    [AsyncStateMachineAttribute("Azure.Core.Pipeline.RetriableStream/<CreateAsync>d__1")]
public static Task`1<Stream> CreateAsync(Func`2<long, Stream> responseFactory, Func`2<long, ValueTask`1<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries);
    public static Stream Create(Stream initialResponse, Func`2<long, Stream> streamFactory, Func`2<long, ValueTask`1<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries);
}
internal class Azure.Core.Pipeline.StorageRequestFailedDetailsParser : RequestFailedDetailsParser {
    [NullableContextAttribute("1")]
public virtual bool TryParse(Response response, ResponseError& error, IDictionary`2& data);
}
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.TaskExtensions : object {
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T EnsureCompleted(Task`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(Task task);
    [ExtensionAttribute]
public static T EnsureCompleted(ValueTask`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(ValueTask task);
    [ExtensionAttribute]
public static Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async);
    [ConditionalAttribute("DEBUG")]
private static void VerifyTaskCompleted(bool isCompleted);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ProtocolOperation`1 : Operation`1<T> {
    private Func`2<Response, T> _resultSelector;
    private OperationInternal`1<T> _operation;
    private IOperation _nextLinkOperation;
    public string Id { get; }
    public T Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal ProtocolOperation`1(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, string scopeName, Func`2<Response, T> resultSelector);
    public virtual string get_Id();
    public virtual T get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperation`1/<Azure-Core-IOperation<T>-UpdateStateAsync>d__17")]
private sealed virtual override ValueTask`1<OperationState`1<T>> Azure.Core.IOperation<T>.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ProtocolOperationHelpers : object {
    public static Operation`1<TTo> Convert(Operation`1<TFrom> operation, Func`2<Response, TTo> convertFunc, ClientDiagnostics diagnostics, string scopeName);
    public static ValueTask`1<Operation`1<VoidValue>> ProcessMessageWithoutResponseValueAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<VoidValue> ProcessMessageWithoutResponseValue(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static ValueTask`1<Operation`1<BinaryData>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<BinaryData> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperationHelpers/<ProcessMessageAsync>d__5`1")]
public static ValueTask`1<Operation`1<T>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
    public static Operation`1<T> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
}
internal class Azure.Core.RawRequestUriBuilder : RequestUriBuilder {
    [NullableAttribute("1")]
private static string SchemeSeparator;
    private static char HostSeparator;
    private static char PortSeparator;
    [NullableAttribute("1")]
private static Char[] HostOrPort;
    private static char QueryBeginSeparator;
    private static char QueryContinueSeparator;
    private static char QueryValueSeparator;
    private Nullable`1<RawWritingPosition> _position;
    private static RawRequestUriBuilder();
    private static void GetQueryParts(ReadOnlySpan`1<char> queryUnparsed, ReadOnlySpan`1& name, ReadOnlySpan`1& value);
    [NullableContextAttribute("1")]
public void AppendRaw(string value, bool escape);
    private void AppendRaw(ReadOnlySpan`1<char> value, bool escape);
    [NullableContextAttribute("1")]
public void AppendRawNextLink(string nextLink, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.RequestContentHelper : object {
    public static RequestContent FromEnumerable(IEnumerable`1<T> enumerable);
    public static RequestContent FromEnumerable(IEnumerable`1<BinaryData> enumerable);
    public static RequestContent FromDictionary(IDictionary`2<string, T> dictionary);
    public static RequestContent FromDictionary(IDictionary`2<string, BinaryData> dictionary);
    public static RequestContent FromObject(object value);
    public static RequestContent FromObject(BinaryData value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestHeaderExtensions : object {
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, bool value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, float value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, double value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, int value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, long value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, TimeSpan value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Guid value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Byte[] value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, BinaryData value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string prefix, IDictionary`2<string, string> headersToAdd);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, ETag value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, MatchConditions conditions);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, RequestConditions conditions, string format);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestUriBuilderExtensions : object {
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, float value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, double value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, int value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, IEnumerable`1<string> value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, float value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, double value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, decimal value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, int value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, string format, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.ResponseHeadersExtensions : object {
    private static String[] KnownFormats;
    private static ResponseHeadersExtensions();
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Byte[]& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, T& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string prefix, IDictionary`2& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ResponseWithHeaders : object {
    public static ResponseWithHeaders`2<T, THeaders> FromValue(T value, THeaders headers, Response rawResponse);
    public static ResponseWithHeaders`1<THeaders> FromValue(THeaders headers, Response rawResponse);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.ResponseWithHeaders`1 : object {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public THeaders Headers { get; }
    public ResponseWithHeaders`1(THeaders headers, Response rawResponse);
    public Response GetRawResponse();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`1<THeaders> self);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ResponseWithHeaders`2 : Response`1<T> {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public T Value { get; }
    public THeaders Headers { get; }
    public ResponseWithHeaders`2(T value, THeaders headers, Response rawResponse);
    public virtual Response GetRawResponse();
    [CompilerGeneratedAttribute]
public virtual T get_Value();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`2<T, THeaders> self);
}
internal class Azure.Core.SequentialDelayStrategy : DelayStrategy {
    [NullableAttribute("1")]
private static TimeSpan[] _pollingSequence;
    private static TimeSpan _maxDelay;
    private static SequentialDelayStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.StringRequestContent : RequestContent {
    private Byte[] _bytes;
    public StringRequestContent(string value);
    [AsyncStateMachineAttribute("Azure.Core.StringRequestContent/<WriteToAsync>d__2")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.TypeFormatters : object {
    private static string RoundtripZFormat;
    [CompilerGeneratedAttribute]
private static string <DefaultNumberFormat>k__BackingField;
    public static string DefaultNumberFormat { get; }
    private static TypeFormatters();
    [CompilerGeneratedAttribute]
public static string get_DefaultNumberFormat();
    public static string ToString(bool value);
    public static string ToString(DateTime value, string format);
    public static string ToString(DateTimeOffset value, string format);
    public static string ToString(TimeSpan value, string format);
    public static string ToString(Byte[] value, string format);
    public static string ToBase64UrlString(Byte[] value);
    public static Byte[] FromBase64UrlString(string value);
    private static int GetNumBase64PaddingCharsToAddForDecode(int inputLength);
    public static DateTimeOffset ParseDateTimeOffset(string value, string format);
    public static TimeSpan ParseTimeSpan(string value, string format);
    [NullableContextAttribute("2")]
public static string ConvertToString(object value, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Utf8JsonRequestContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private Utf8JsonWriter <JsonWriter>k__BackingField;
    public Utf8JsonWriter JsonWriter { get; }
    [CompilerGeneratedAttribute]
public Utf8JsonWriter get_JsonWriter();
    [AsyncStateMachineAttribute("Azure.Core.Utf8JsonRequestContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.Utf8JsonWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTime value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, char value);
    [ExtensionAttribute]
public static void WriteNonEmptyArray(Utf8JsonWriter writer, string name, IReadOnlyList`1<string> values);
    [ExtensionAttribute]
public static void WriteBase64StringValue(Utf8JsonWriter writer, Byte[] value, string format);
    [ExtensionAttribute]
public static void WriteNumberValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteObjectValue(Utf8JsonWriter writer, object value);
}
[IsReadOnlyAttribute]
internal class Azure.Core.VoidValue : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XElementExtensions : object {
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64Value(XElement element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffsetValue(XElement element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpanValue(XElement element, string format);
    [ExtensionAttribute]
public static object GetObjectValue(XElement element, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.XmlWriterContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private XmlWriter <XmlWriter>k__BackingField;
    public XmlWriter XmlWriter { get; }
    [CompilerGeneratedAttribute]
public XmlWriter get_XmlWriter();
    [AsyncStateMachineAttribute("Azure.Core.XmlWriterContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XmlWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteObjectValue(XmlWriter writer, object value, string nameHint);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, Byte[] value, string format);
}
internal class Azure.NoBodyResponse`1 : Response`1<T> {
    private Response _response;
    public bool HasValue { get; }
    public T Value { get; }
    public NoBodyResponse`1(Response response);
    public virtual bool get_HasValue();
    public virtual T get_Value();
    public virtual Response GetRawResponse();
    public virtual string ToString();
}
internal class Azure.Storage.AggregatingProgressIncrementer : object {
    private long _currentValue;
    private IProgress`1<long> _innerHandler;
    [CompilerGeneratedAttribute]
private static AggregatingProgressIncrementer <None>k__BackingField;
    public static AggregatingProgressIncrementer None { get; }
    public long Current { get; }
    public AggregatingProgressIncrementer(IProgress`1<long> innerHandler);
    private static AggregatingProgressIncrementer();
    public Stream CreateProgressIncrementingStream(Stream stream);
    public sealed virtual void Report(long bytes);
    public void Reset();
    [CompilerGeneratedAttribute]
public static AggregatingProgressIncrementer get_None();
    public long get_Current();
}
internal class Azure.Storage.Blobs.AppendBlobAppendBlockFromUrlHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public Byte[] XMsContentCrc64 { get; }
    public string Version { get; }
    public string BlobAppendOffset { get; }
    public Nullable`1<int> BlobCommittedBlockCount { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public AppendBlobAppendBlockFromUrlHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public Byte[] get_XMsContentCrc64();
    public string get_Version();
    public string get_BlobAppendOffset();
    public Nullable`1<int> get_BlobCommittedBlockCount();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
    public Nullable`1<bool> get_IsServerEncrypted();
}
internal class Azure.Storage.Blobs.AppendBlobAppendBlockHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public Byte[] XMsContentCrc64 { get; }
    public string Version { get; }
    public string BlobAppendOffset { get; }
    public Nullable`1<int> BlobCommittedBlockCount { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public AppendBlobAppendBlockHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public Byte[] get_XMsContentCrc64();
    public string get_Version();
    public string get_BlobAppendOffset();
    public Nullable`1<int> get_BlobCommittedBlockCount();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.AppendBlobCreateHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public string Version { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public AppendBlobCreateHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public string get_Version();
    public string get_VersionId();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.AppendBlobRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public AppendBlobRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateCreateRequest(long contentLength, Nullable`1<int> timeout, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.AppendBlobRestClient/<CreateAsync>d__8")]
public Task`1<ResponseWithHeaders`1<AppendBlobCreateHeaders>> CreateAsync(long contentLength, Nullable`1<int> timeout, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<AppendBlobCreateHeaders> Create(long contentLength, Nullable`1<int> timeout, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken);
    internal HttpMessage CreateAppendBlockRequest(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.AppendBlobRestClient/<AppendBlockAsync>d__11")]
public Task`1<ResponseWithHeaders`1<AppendBlobAppendBlockHeaders>> AppendBlockAsync(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<AppendBlobAppendBlockHeaders> AppendBlock(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateAppendBlockFromUrlRequest(string sourceUrl, long contentLength, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.AppendBlobRestClient/<AppendBlockFromUrlAsync>d__14")]
public Task`1<ResponseWithHeaders`1<AppendBlobAppendBlockFromUrlHeaders>> AppendBlockFromUrlAsync(string sourceUrl, long contentLength, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<AppendBlobAppendBlockFromUrlHeaders> AppendBlockFromUrl(string sourceUrl, long contentLength, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken);
    internal HttpMessage CreateSealRequest(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, Nullable`1<long> appendPosition);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.AppendBlobRestClient/<SealAsync>d__17")]
public Task`1<ResponseWithHeaders`1<AppendBlobSealHeaders>> SealAsync(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, Nullable`1<long> appendPosition, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<AppendBlobSealHeaders> Seal(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, Nullable`1<long> appendPosition, CancellationToken cancellationToken);
}
internal class Azure.Storage.Blobs.AppendBlobSealHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public Nullable`1<bool> IsSealed { get; }
    public AppendBlobSealHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public Nullable`1<bool> get_IsSealed();
}
internal class Azure.Storage.Blobs.AppendBlobWriteStream : StorageWriteStream {
    private AppendBlobClient _appendBlobClient;
    private AppendBlobRequestConditions _conditions;
    public AppendBlobWriteStream(AppendBlobClient appendBlobClient, long bufferSize, long position, AppendBlobRequestConditions conditions, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidation);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.AppendBlobWriteStream/<AppendInternal>d__3")]
protected virtual Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    protected virtual void ValidateBufferSize(long bufferSize);
}
internal class Azure.Storage.Blobs.BlobAbortCopyFromURLHeaders : object {
    private Response _response;
    public string Version { get; }
    public BlobAbortCopyFromURLHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobAcquireLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public BlobAcquireLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobBreakLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<int> LeaseTime { get; }
    public string Version { get; }
    public BlobBreakLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<int> get_LeaseTime();
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobChangeLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public BlobChangeLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
public class Azure.Storage.Blobs.BlobClient : BlobBaseClient {
    private BlockBlobClient _blockBlobClient;
    private BlockBlobClient BlockBlobClient { get; }
    public BlobClient(string connectionString, string blobContainerName, string blobName);
    public BlobClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options);
    public BlobClient(Uri blobUri, BlobClientOptions options);
    public BlobClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options);
    public BlobClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options);
    public BlobClient(Uri blobUri, TokenCredential credential, BlobClientOptions options);
    internal BlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption);
    public BlobClient WithSnapshot(string snapshot);
    public BlobClient WithVersion(string versionId);
    public BlobClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey);
    public BlobClient WithEncryptionScope(string encryptionScope);
    protected internal virtual BlobClient WithClientSideEncryptionOptionsCore(ClientSideEncryptionOptions clientSideEncryptionOptions);
    public virtual Response`1<BlobContentInfo> Upload(Stream content);
    public virtual Response`1<BlobContentInfo> Upload(BinaryData content);
    public virtual Response`1<BlobContentInfo> Upload(string path);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<UploadAsync>d__16")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<UploadAsync>d__17")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(BinaryData content);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<UploadAsync>d__18")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(string path);
    public virtual Response`1<BlobContentInfo> Upload(Stream content, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> Upload(BinaryData content, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> Upload(string path, CancellationToken cancellationToken);
    public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, CancellationToken cancellationToken);
    public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(BinaryData content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<UploadAsync>d__24")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(string path, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> Upload(Stream content, bool overwrite, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> Upload(BinaryData content, bool overwrite, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> Upload(string path, bool overwrite, CancellationToken cancellationToken);
    public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, bool overwrite, CancellationToken cancellationToken);
    public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(BinaryData content, bool overwrite, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<UploadAsync>d__30")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(string path, bool overwrite, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> Upload(Stream content, BlobUploadOptions options, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> Upload(BinaryData content, BlobUploadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContentInfo> Upload(Stream content, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, IProgress`1<long> progressHandler, Nullable`1<AccessTier> accessTier, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> Upload(string path, BlobUploadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContentInfo> Upload(string path, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, IProgress`1<long> progressHandler, Nullable`1<AccessTier> accessTier, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<UploadAsync>d__36")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, BlobUploadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<UploadAsync>d__37")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(BinaryData content, BlobUploadOptions options, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, IProgress`1<long> progressHandler, Nullable`1<AccessTier> accessTier, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<UploadAsync>d__39")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(string path, BlobUploadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<UploadAsync>d__40")]
[ForwardsClientCallsAttribute]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(string path, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, IProgress`1<long> progressHandler, Nullable`1<AccessTier> accessTier, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<StagedUploadInternal>d__41")]
internal Task`1<Response`1<BlobContentInfo>> StagedUploadInternal(Stream content, BlobUploadOptions options, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<StagedUploadInternal>d__42")]
internal Task`1<Response`1<BlobContentInfo>> StagedUploadInternal(string path, BlobUploadOptions options, bool async, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Stream OpenWrite(bool overwrite, BlobOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<OpenWriteAsync>d__44")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Stream> OpenWriteAsync(bool overwrite, BlobOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClient/<OpenWriteInternal>d__45")]
internal Task`1<Stream> OpenWriteInternal(bool overwrite, BlobOpenWriteOptions options, bool async, CancellationToken cancellationToken);
    private BlockBlobClient get_BlockBlobClient();
    internal PartitionedUploader`2<BlobUploadOptions, BlobContentInfo> GetPartitionedUploader(StorageTransferOptions transferOptions, UploadTransferValidationOptions validationOptions, ArrayPool`1<byte> arrayPool, string operationName);
}
internal class Azure.Storage.Blobs.BlobClientConfiguration : StorageClientConfiguration {
    [CompilerGeneratedAttribute]
private ServiceVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CustomerProvidedKey> <CustomerProvidedKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimBlobNameSlashes>k__BackingField;
    public ServiceVersion Version { get; internal set; }
    public Nullable`1<CustomerProvidedKey> CustomerProvidedKey { get; internal set; }
    public TransferValidationOptions TransferValidation { get; internal set; }
    public string EncryptionScope { get; internal set; }
    public bool TrimBlobNameSlashes { get; internal set; }
    public BlobClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes);
    public BlobClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes);
    public BlobClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes);
    public BlobClientConfiguration(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes);
    internal BlobClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, TokenCredential tokenCredential, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes);
    [CompilerGeneratedAttribute]
public virtual ServiceVersion get_Version();
    [CompilerGeneratedAttribute]
internal virtual void set_Version(ServiceVersion value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<CustomerProvidedKey> get_CustomerProvidedKey();
    [CompilerGeneratedAttribute]
internal virtual void set_CustomerProvidedKey(Nullable`1<CustomerProvidedKey> value);
    [CompilerGeneratedAttribute]
public virtual TransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
internal virtual void set_TransferValidation(TransferValidationOptions value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
    [CompilerGeneratedAttribute]
public bool get_TrimBlobNameSlashes();
    [CompilerGeneratedAttribute]
internal void set_TrimBlobNameSlashes(bool value);
    internal static BlobClientConfiguration DeepCopy(BlobClientConfiguration originalClientConfiguration);
}
public class Azure.Storage.Blobs.BlobClientOptions : ClientOptions {
    internal static ServiceVersion LatestVersion;
    [CompilerGeneratedAttribute]
private ServiceVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CustomerProvidedKey> <CustomerProvidedKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <GeoRedundantSecondaryUri>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimBlobNameSlashes>k__BackingField;
    internal ClientSideEncryptionOptions _clientSideEncryptionOptions;
    [CompilerGeneratedAttribute]
private bool <EnableTenantDiscovery>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BlobAudience> <Audience>k__BackingField;
    public ServiceVersion Version { get; }
    public Nullable`1<CustomerProvidedKey> CustomerProvidedKey { get; public set; }
    public string EncryptionScope { get; public set; }
    public Uri GeoRedundantSecondaryUri { get; public set; }
    public TransferValidationOptions TransferValidation { get; }
    public bool TrimBlobNameSlashes { get; public set; }
    public bool EnableTenantDiscovery { get; public set; }
    public Nullable`1<BlobAudience> Audience { get; public set; }
    public BlobClientOptions(ServiceVersion version);
    [CompilerGeneratedAttribute]
public ServiceVersion get_Version();
    [CompilerGeneratedAttribute]
public Nullable`1<CustomerProvidedKey> get_CustomerProvidedKey();
    [CompilerGeneratedAttribute]
public void set_CustomerProvidedKey(Nullable`1<CustomerProvidedKey> value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public void set_EncryptionScope(string value);
    [CompilerGeneratedAttribute]
public Uri get_GeoRedundantSecondaryUri();
    [CompilerGeneratedAttribute]
public void set_GeoRedundantSecondaryUri(Uri value);
    [CompilerGeneratedAttribute]
public TransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public bool get_TrimBlobNameSlashes();
    [CompilerGeneratedAttribute]
public void set_TrimBlobNameSlashes(bool value);
    private void AddHeadersAndQueryParameters();
    internal HttpPipeline Build(HttpPipelinePolicy authentication);
    internal HttpPipeline Build(object credentials);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableTenantDiscovery();
    [CompilerGeneratedAttribute]
public void set_EnableTenantDiscovery(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<BlobAudience> get_Audience();
    [CompilerGeneratedAttribute]
public void set_Audience(Nullable`1<BlobAudience> value);
}
internal class Azure.Storage.Blobs.BlobClientSideDecryptor : object {
    private ClientSideDecryptor _decryptor;
    public BlobClientSideDecryptor(ClientSideDecryptor decryptor);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClientSideDecryptor/<DecryptInternal>d__2")]
public Task`1<Stream> DecryptInternal(Stream content, IDictionary`2<string, string> metadata, HttpRange originalRange, string receivedContentRange, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClientSideDecryptor/<DecryptWholeBlobWriteInternal>d__3")]
public Task`1<Stream> DecryptWholeBlobWriteInternal(Stream plaintextDestination, IDictionary`2<string, string> metadata, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClientSideDecryptor/<TrimStreamInternal>d__4")]
private static Task`1<Stream> TrimStreamInternal(Stream stream, HttpRange originalRange, Nullable`1<ContentRange> receivedRange, int alreadyTrimmedOffsetAmount, bool async, CancellationToken cancellationToken);
    internal static EncryptionData GetAndValidateEncryptionDataOrDefault(IDictionary`2<string, string> metadata);
    private static bool CanIgnorePadding(Nullable`1<ContentRange> contentRange);
    internal static HttpRange GetEncryptedBlobRange(HttpRange originalRange, string rawEncryptionData);
    internal static HttpRange GetEncryptedBlobRange(HttpRange originalRange, EncryptionData encryptionData);
    private static HttpRange GetEncryptedBlobRangeV2_0(HttpRange originalRange, EncryptionData encryptionData);
    private static HttpRange GetEncryptedBlobRangeV1_0(HttpRange originalRange);
}
internal class Azure.Storage.Blobs.BlobClientSideEncryptor : object {
    private IClientSideEncryptor _encryptor;
    public BlobClientSideEncryptor(IClientSideEncryptor encryptor);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClientSideEncryptor/<ClientSideEncryptInternal>d__2")]
public Task`1<ValueTuple`2<Stream, IDictionary`2<string, string>>> ClientSideEncryptInternal(Stream content, IDictionary`2<string, string> metadata, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobClientSideEncryptor/<ClientSideEncryptionOpenWriteInternal>d__3")]
public Task`1<Stream> ClientSideEncryptionOpenWriteInternal(BlockBlobClient blobClient, bool overwrite, BlockBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken);
    private static IDictionary`2<string, string> TransformMetadata(IDictionary`2<string, string> metadata, EncryptionData encryptionData);
}
public class Azure.Storage.Blobs.BlobContainerClient : object {
    public static string RootBlobContainerName;
    public static string LogsBlobContainerName;
    public static string WebBlobContainerName;
    private Uri _uri;
    private BlobClientConfiguration _clientConfiguration;
    private HttpPipelinePolicy _authenticationPolicy;
    private ClientSideEncryptionOptions _clientSideEncryption;
    private string _accountName;
    private string _name;
    private ContainerRestClient _containerRestClient;
    private BlobServiceClient _parentBlobServiceClient;
    public Uri Uri { get; }
    internal BlobClientConfiguration ClientConfiguration { get; }
    internal HttpPipelinePolicy AuthenticationPolicy { get; }
    internal ClientSideEncryptionOptions ClientSideEncryption { get; }
    public string AccountName { get; }
    public string Name { get; }
    public bool CanGenerateSasUri { get; }
    internal ContainerRestClient ContainerRestClient { get; }
    public BlobContainerClient(string connectionString, string blobContainerName);
    public BlobContainerClient(string connectionString, string blobContainerName, BlobClientOptions options);
    public BlobContainerClient(Uri blobContainerUri, BlobClientOptions options);
    public BlobContainerClient(Uri blobContainerUri, StorageSharedKeyCredential credential, BlobClientOptions options);
    public BlobContainerClient(Uri blobContainerUri, AzureSasCredential credential, BlobClientOptions options);
    public BlobContainerClient(Uri blobContainerUri, TokenCredential credential, BlobClientOptions options);
    internal BlobContainerClient(Uri containerUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption);
    private static BlobContainerClient();
    public virtual Uri get_Uri();
    internal virtual BlobClientConfiguration get_ClientConfiguration();
    internal virtual HttpPipelinePolicy get_AuthenticationPolicy();
    internal virtual ClientSideEncryptionOptions get_ClientSideEncryption();
    public virtual string get_AccountName();
    public virtual string get_Name();
    public virtual bool get_CanGenerateSasUri();
    internal virtual ContainerRestClient get_ContainerRestClient();
    protected static BlobContainerClient CreateClient(Uri containerUri, BlobClientOptions options, HttpPipeline pipeline);
    private ContainerRestClient BuildContainerRestClient(Uri containerUri);
    protected internal virtual BlobBaseClient GetBlobBaseClientCore(string blobName);
    public virtual BlobClient GetBlobClient(string blobName);
    protected internal virtual BlockBlobClient GetBlockBlobClientCore(string blobName);
    protected internal virtual AppendBlobClient GetAppendBlobClientCore(string blobName);
    protected internal virtual PageBlobClient GetPageBlobClientCore(string blobName);
    protected internal virtual BlobLeaseClient GetBlobLeaseClientCore(string leaseId);
    private void SetNameFieldsIfNull();
    public virtual Response`1<BlobContainerInfo> Create(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContainerInfo> Create(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<CreateAsync>d__45")]
public virtual Task`1<Response`1<BlobContainerInfo>> CreateAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<CreateAsync>d__46")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContainerInfo>> CreateAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    public virtual Response`1<BlobContainerInfo> CreateIfNotExists(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContainerInfo> CreateIfNotExists(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<CreateIfNotExistsAsync>d__49")]
public virtual Task`1<Response`1<BlobContainerInfo>> CreateIfNotExistsAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<CreateIfNotExistsAsync>d__50")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContainerInfo>> CreateIfNotExistsAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<CreateIfNotExistsInternal>d__51")]
private Task`1<Response`1<BlobContainerInfo>> CreateIfNotExistsInternal(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<CreateInternal>d__52")]
private Task`1<Response`1<BlobContainerInfo>> CreateInternal(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response Delete(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<DeleteAsync>d__54")]
public virtual Task`1<Response> DeleteAsync(BlobRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<bool> DeleteIfExists(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<DeleteIfExistsAsync>d__56")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<DeleteIfExistsInternal>d__57")]
private Task`1<Response`1<bool>> DeleteIfExistsInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<DeleteInternal>d__58")]
private Task`1<Response> DeleteInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<bool> Exists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<ExistsAsync>d__60")]
public virtual Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<ExistsInternal>d__61")]
private Task`1<Response`1<bool>> ExistsInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobContainerProperties> GetProperties(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<GetPropertiesAsync>d__63")]
public virtual Task`1<Response`1<BlobContainerProperties>> GetPropertiesAsync(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<GetPropertiesInternal>d__64")]
private Task`1<Response`1<BlobContainerProperties>> GetPropertiesInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobContainerInfo> SetMetadata(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<SetMetadataAsync>d__66")]
public virtual Task`1<Response`1<BlobContainerInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<SetMetadataInternal>d__67")]
private Task`1<Response`1<BlobContainerInfo>> SetMetadataInternal(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobContainerAccessPolicy> GetAccessPolicy(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<GetAccessPolicyAsync>d__69")]
public virtual Task`1<Response`1<BlobContainerAccessPolicy>> GetAccessPolicyAsync(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<GetAccessPolicyInternal>d__70")]
private Task`1<Response`1<BlobContainerAccessPolicy>> GetAccessPolicyInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute]
public virtual Response`1<BlobContainerInfo> SetAccessPolicy(PublicAccessType accessType, IEnumerable`1<BlobSignedIdentifier> permissions, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<SetAccessPolicyAsync>d__72")]
[CallerShouldAuditAttribute]
public virtual Task`1<Response`1<BlobContainerInfo>> SetAccessPolicyAsync(PublicAccessType accessType, IEnumerable`1<BlobSignedIdentifier> permissions, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<SetAccessPolicyInternal>d__73")]
private Task`1<Response`1<BlobContainerInfo>> SetAccessPolicyInternal(PublicAccessType accessType, IEnumerable`1<BlobSignedIdentifier> permissions, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Pageable`1<BlobItem> GetBlobs(BlobTraits traits, BlobStates states, string prefix, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<BlobItem> GetBlobsAsync(BlobTraits traits, BlobStates states, string prefix, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<GetBlobsInternal>d__76")]
internal Task`1<Response`1<ListBlobsFlatSegmentResponse>> GetBlobsInternal(string marker, BlobTraits traits, BlobStates states, string prefix, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    public virtual Pageable`1<BlobHierarchyItem> GetBlobsByHierarchy(BlobTraits traits, BlobStates states, string delimiter, string prefix, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<BlobHierarchyItem> GetBlobsByHierarchyAsync(BlobTraits traits, BlobStates states, string delimiter, string prefix, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<GetBlobsByHierarchyInternal>d__79")]
internal Task`1<Response`1<ListBlobsHierarchySegmentResponse>> GetBlobsByHierarchyInternal(string marker, string delimiter, BlobTraits traits, BlobStates states, string prefix, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<BlobContentInfo> UploadBlob(string blobName, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<UploadBlobAsync>d__81")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<BlobContentInfo>> UploadBlobAsync(string blobName, Stream content, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<BlobContentInfo> UploadBlob(string blobName, BinaryData content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<UploadBlobAsync>d__83")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<BlobContentInfo>> UploadBlobAsync(string blobName, BinaryData content, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response DeleteBlob(string blobName, DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<DeleteBlobAsync>d__85")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response> DeleteBlobAsync(string blobName, DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<bool> DeleteBlobIfExists(string blobName, DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<DeleteBlobIfExistsAsync>d__87")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<bool>> DeleteBlobIfExistsAsync(string blobName, DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken);
    internal virtual Response`1<BlobContainerClient> Rename(string destinationContainerName, BlobRequestConditions sourceConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<RenameAsync>d__89")]
internal virtual Task`1<Response`1<BlobContainerClient>> RenameAsync(string destinationContainerName, BlobRequestConditions sourceConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<RenameInternal>d__90")]
internal Task`1<Response`1<BlobContainerClient>> RenameInternal(string destinationContainerName, BlobRequestConditions sourceConditions, bool async, CancellationToken cancellationToken);
    public virtual Pageable`1<TaggedBlobItem> FindBlobsByTags(string tagFilterSqlExpression, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<TaggedBlobItem> FindBlobsByTagsAsync(string tagFilterSqlExpression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobContainerClient/<FindBlobsByTagsInternal>d__93")]
internal Task`1<Response`1<FilterBlobSegment>> FindBlobsByTagsInternal(string marker, string expression, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute]
public virtual Uri GenerateSasUri(BlobContainerSasPermissions permissions, DateTimeOffset expiresOn);
    [CallerShouldAuditAttribute]
public virtual Uri GenerateSasUri(BlobSasBuilder builder);
    protected internal virtual BlobServiceClient GetParentBlobServiceClientCore();
}
internal class Azure.Storage.Blobs.BlobCopyFromURLHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string VersionId { get; }
    public string CopyId { get; }
    public string CopyStatus { get; }
    public Byte[] ContentMD5 { get; }
    public Byte[] XMsContentCrc64 { get; }
    public string EncryptionScope { get; }
    public BlobCopyFromURLHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_VersionId();
    public string get_CopyId();
    public string get_CopyStatus();
    public Byte[] get_ContentMD5();
    public Byte[] get_XMsContentCrc64();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.BlobCreateSnapshotHeaders : object {
    private Response _response;
    public string Snapshot { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public BlobCreateSnapshotHeaders(Response response);
    public string get_Snapshot();
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_VersionId();
    public Nullable`1<bool> get_IsServerEncrypted();
}
internal class Azure.Storage.Blobs.BlobDeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public BlobDeleteHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobDeleteImmutabilityPolicyHeaders : object {
    private Response _response;
    public string Version { get; }
    public BlobDeleteImmutabilityPolicyHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobDownloadHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<DateTimeOffset> CreationTime { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public string ObjectReplicationPolicyId { get; }
    public IDictionary`2<string, string> ObjectReplicationRules { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentType { get; }
    public string ContentRange { get; }
    public Byte[] ContentMD5 { get; }
    public string ContentEncoding { get; }
    public string CacheControl { get; }
    public string ContentDisposition { get; }
    public string ContentLanguage { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public Nullable`1<BlobType> BlobType { get; }
    public Nullable`1<DateTimeOffset> CopyCompletionTime { get; }
    public string CopyStatusDescription { get; }
    public string CopyId { get; }
    public string CopyProgress { get; }
    public string CopySource { get; }
    public Nullable`1<CopyStatus> CopyStatus { get; }
    public Nullable`1<LeaseDurationType> LeaseDuration { get; }
    public Nullable`1<LeaseState> LeaseState { get; }
    public Nullable`1<LeaseStatus> LeaseStatus { get; }
    public string Version { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsCurrentVersion { get; }
    public string AcceptRanges { get; }
    public Nullable`1<int> BlobCommittedBlockCount { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public Byte[] BlobContentMD5 { get; }
    public Nullable`1<long> TagCount { get; }
    public Nullable`1<bool> IsSealed { get; }
    public Nullable`1<DateTimeOffset> LastAccessed { get; }
    public Nullable`1<DateTimeOffset> ImmutabilityPolicyExpiresOn { get; }
    public Nullable`1<BlobImmutabilityPolicyMode> ImmutabilityPolicyMode { get; }
    public Nullable`1<bool> LegalHold { get; }
    public Byte[] ContentCrc64 { get; }
    public string ErrorCode { get; }
    public BlobDownloadHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<DateTimeOffset> get_CreationTime();
    public IDictionary`2<string, string> get_Metadata();
    public string get_ObjectReplicationPolicyId();
    public IDictionary`2<string, string> get_ObjectReplicationRules();
    public Nullable`1<long> get_ContentLength();
    public string get_ContentType();
    public string get_ContentRange();
    public Byte[] get_ContentMD5();
    public string get_ContentEncoding();
    public string get_CacheControl();
    public string get_ContentDisposition();
    public string get_ContentLanguage();
    public Nullable`1<long> get_BlobSequenceNumber();
    public Nullable`1<BlobType> get_BlobType();
    public Nullable`1<DateTimeOffset> get_CopyCompletionTime();
    public string get_CopyStatusDescription();
    public string get_CopyId();
    public string get_CopyProgress();
    public string get_CopySource();
    public Nullable`1<CopyStatus> get_CopyStatus();
    public Nullable`1<LeaseDurationType> get_LeaseDuration();
    public Nullable`1<LeaseState> get_LeaseState();
    public Nullable`1<LeaseStatus> get_LeaseStatus();
    public string get_Version();
    public string get_VersionId();
    public Nullable`1<bool> get_IsCurrentVersion();
    public string get_AcceptRanges();
    public Nullable`1<int> get_BlobCommittedBlockCount();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
    public Byte[] get_BlobContentMD5();
    public Nullable`1<long> get_TagCount();
    public Nullable`1<bool> get_IsSealed();
    public Nullable`1<DateTimeOffset> get_LastAccessed();
    public Nullable`1<DateTimeOffset> get_ImmutabilityPolicyExpiresOn();
    public Nullable`1<BlobImmutabilityPolicyMode> get_ImmutabilityPolicyMode();
    public Nullable`1<bool> get_LegalHold();
    public Byte[] get_ContentCrc64();
    public string get_ErrorCode();
}
internal class Azure.Storage.Blobs.BlobErrors : Errors {
    public static ArgumentOutOfRangeException BlobConditionsMustBeDefault(String[] conditions);
    public static InvalidOperationException BlobOrContainerMissing(string leaseClient, string blobBaseClient, string blobContainerClient);
    public static ArgumentException InvalidDateTimeUtc(string dateTime);
    internal static void VerifyHttpsCustomerProvidedKey(Uri uri, Nullable`1<CustomerProvidedKey> customerProvidedKey);
    internal static void VerifyCpkAndEncryptionScopeNotBothSet(Nullable`1<CustomerProvidedKey> customerProvidedKey, string encryptionScope);
    public static ArgumentException ParsingFullHttpRangeFailed(string range);
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.BlobExtensions : object {
    [ExtensionAttribute]
internal static IDictionary`2<string, string> ToTagDictionary(BlobTags blobTags);
    [ExtensionAttribute]
internal static BlobTags ToBlobTags(IDictionary`2<string, string> tags);
    [ExtensionAttribute]
internal static string ToTagsString(IDictionary`2<string, string> tags);
    [ExtensionAttribute]
internal static TaggedBlobItem ToBlobTagItem(FilterBlobItem filterBlobItem);
    [ExtensionAttribute]
internal static List`1<TaggedBlobItem> ToBlobTagItems(IEnumerable`1<FilterBlobItem> filterBlobItems);
    [ExtensionAttribute]
internal static IList`1<ObjectReplicationPolicy> ParseObjectReplicationIds(IDictionary`2<string, string> OrIds);
    [ExtensionAttribute]
internal static IList`1<ObjectReplicationPolicy> ParseObjectReplicationMetadata(IReadOnlyDictionary`2<string, string> OrMetadata);
    [ExtensionAttribute]
internal static Nullable`1<RehydratePriority> ToRehydratePriority(string rehydratePriority);
    [ExtensionAttribute]
internal static AccountInfo ToAccountInfo(ResponseWithHeaders`1<ServiceGetAccountInfoHeaders> response);
    [ExtensionAttribute]
internal static BlobContainerInfo ToBlobContainerInfo(ResponseWithHeaders`1<ContainerCreateHeaders> response);
    [ExtensionAttribute]
internal static BlobContainerAccessPolicy ToBlobContainerAccessPolicy(ResponseWithHeaders`2<IReadOnlyList`1<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders> response);
    [ExtensionAttribute]
internal static BlobContainerInfo ToBlobContainerInfo(ResponseWithHeaders`1<ContainerSetAccessPolicyHeaders> response);
    [ExtensionAttribute]
internal static BlobContainerInfo ToBlobContainerInfo(ResponseWithHeaders`1<ContainerSetMetadataHeaders> response);
    [ExtensionAttribute]
internal static BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<AppendBlobCreateHeaders> response);
    [ExtensionAttribute]
internal static BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<PageBlobCreateHeaders> response);
    [ExtensionAttribute]
internal static BlobAppendInfo ToBlobAppendInfo(ResponseWithHeaders`1<AppendBlobAppendBlockHeaders> response);
    [ExtensionAttribute]
internal static BlobAppendInfo ToBlobAppendInfo(ResponseWithHeaders`1<AppendBlobAppendBlockFromUrlHeaders> response);
    [ExtensionAttribute]
internal static BlobInfo ToBlobInfo(ResponseWithHeaders`1<AppendBlobSealHeaders> response);
    [ExtensionAttribute]
internal static PageInfo ToPageInfo(ResponseWithHeaders`1<PageBlobUploadPagesHeaders> response);
    [ExtensionAttribute]
internal static PageInfo ToPageInfo(ResponseWithHeaders`1<PageBlobClearPagesHeaders> response);
    [ExtensionAttribute]
internal static PageInfo ToPageInfo(ResponseWithHeaders`1<PageBlobUploadPagesFromURLHeaders> response);
    [ExtensionAttribute]
internal static PageRangesInfo ToPageRangesInfo(ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders> response);
    [ExtensionAttribute]
internal static PageRangesInfo ToPageRangesInfo(ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders> response);
    [ExtensionAttribute]
internal static HttpRange ToHttpRange(PageRange pageRange);
    [ExtensionAttribute]
internal static HttpRange ToHttpRange(ClearRange clearRange);
    [ExtensionAttribute]
internal static PageBlobInfo ToPageBlobInfo(ResponseWithHeaders`1<PageBlobResizeHeaders> response);
    [ExtensionAttribute]
internal static PageBlobInfo ToPageBlobInfo(ResponseWithHeaders`1<PageBlobUpdateSequenceNumberHeaders> response);
    [ExtensionAttribute]
internal static BlockInfo ToBlockInfo(ResponseWithHeaders`1<BlockBlobStageBlockHeaders> response);
    [ExtensionAttribute]
internal static BlockInfo ToBlockInfo(ResponseWithHeaders`1<BlockBlobStageBlockFromURLHeaders> response);
    [ExtensionAttribute]
internal static BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<BlockBlobCommitBlockListHeaders> response);
    [ExtensionAttribute]
internal static BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<BlockBlobPutBlobFromUrlHeaders> response);
    [ExtensionAttribute]
internal static BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<BlockBlobUploadHeaders> response);
    [ExtensionAttribute]
internal static BlockList ToBlockList(ResponseWithHeaders`2<BlockList, BlockBlobGetBlockListHeaders> response);
    [ExtensionAttribute]
internal static BlobSnapshotInfo ToBlobSnapshotInfo(ResponseWithHeaders`1<BlobCreateSnapshotHeaders> response);
    [ExtensionAttribute]
internal static BlobInfo ToBlobInfo(ResponseWithHeaders`1<BlobSetMetadataHeaders> response);
    [ExtensionAttribute]
internal static BlobInfo ToBlobInfo(ResponseWithHeaders`1<BlobSetHttpHeadersHeaders> response);
    [ExtensionAttribute]
internal static BlobProperties ToBlobProperties(ResponseWithHeaders`1<BlobGetPropertiesHeaders> response);
    [ExtensionAttribute]
internal static BlobCopyInfo ToBlobCopyInfo(ResponseWithHeaders`1<BlobCopyFromURLHeaders> response);
    [ExtensionAttribute]
internal static BlobCopyInfo ToBlobCopyInfo(ResponseWithHeaders`1<BlobStartCopyFromURLHeaders> response);
    [ExtensionAttribute]
internal static BlobCopyInfo ToBlobCopyInfo(ResponseWithHeaders`1<PageBlobCopyIncrementalHeaders> response);
    [ExtensionAttribute]
internal static BlobDownloadStreamingResult ToBlobDownloadStreamingResult(ResponseWithHeaders`2<Stream, BlobDownloadHeaders> response);
    internal static BlobDownloadInfo ToBlobDownloadInfo(ResponseWithHeaders`2<Stream, BlobQueryHeaders> response, Stream stream);
    [ExtensionAttribute]
private static void ExtractMultiHeaderDownloadProperties(ResponseHeaders headers, IDictionary`2& metadata, IDictionary`2& objectReplicationRules);
    [ExtensionAttribute]
internal static BlobLease ToBlobLease(ResponseWithHeaders`1<BlobAcquireLeaseHeaders> response);
    [ExtensionAttribute]
internal static BlobLease ToBlobLease(ResponseWithHeaders`1<ContainerAcquireLeaseHeaders> response);
    [ExtensionAttribute]
internal static BlobLease ToBlobLease(ResponseWithHeaders`1<BlobRenewLeaseHeaders> response);
    [ExtensionAttribute]
internal static BlobLease ToBlobLease(ResponseWithHeaders`1<ContainerRenewLeaseHeaders> response);
    [ExtensionAttribute]
internal static BlobLease ToBlobLease(ResponseWithHeaders`1<BlobChangeLeaseHeaders> response);
    [ExtensionAttribute]
internal static BlobLease ToBlobLease(ResponseWithHeaders`1<ContainerChangeLeaseHeaders> response);
    [ExtensionAttribute]
internal static BlobLease ToBlobLease(ResponseWithHeaders`1<BlobBreakLeaseHeaders> response);
    [ExtensionAttribute]
internal static BlobLease ToBlobLease(ResponseWithHeaders`1<ContainerBreakLeaseHeaders> response);
    [ExtensionAttribute]
internal static Nullable`1<int> ExtractLeaseTime(ResponseHeaders responseHeaders);
    [ExtensionAttribute]
internal static ReleasedObjectInfo ToReleasedObjectInfo(ResponseWithHeaders`1<BlobReleaseLeaseHeaders> response);
    [ExtensionAttribute]
internal static ReleasedObjectInfo ToReleasedObjectInfo(ResponseWithHeaders`1<ContainerReleaseLeaseHeaders> response);
    [ExtensionAttribute]
internal static BlobItem[] ToBlobItems(IReadOnlyList`1<BlobItemInternal> blobItemInternals);
    [ExtensionAttribute]
internal static BlobItem ToBlobItem(BlobItemInternal blobItemInternal);
    [ExtensionAttribute]
internal static string ToBlobNameString(BlobName blobName);
    [ExtensionAttribute]
internal static BlobItemProperties ToBlobItemProperties(BlobPropertiesInternal blobPropertiesInternal);
    [ExtensionAttribute]
internal static BlobContainerItem[] ToBlobContainerItems(IReadOnlyList`1<ContainerItemInternal> containerItemInternals);
    [ExtensionAttribute]
internal static BlobContainerItem ToBlobContainerItem(ContainerItemInternal containerItemInternal);
    internal static BlobContainerProperties ToBlobContainerProperties(ContainerPropertiesInternal containerPropertiesInternal, IReadOnlyDictionary`2<string, string> metadata);
    [ExtensionAttribute]
internal static BlobContainerProperties ToBlobContainerProperties(ResponseWithHeaders`1<ContainerGetPropertiesHeaders> response);
    [ExtensionAttribute]
internal static IDictionary`2<string, string> ToMetadata(IDictionary`2<string, string> originalMetadata);
    [ExtensionAttribute]
internal static IDictionary`2<string, string> ToMetadata(IReadOnlyDictionary`2<string, string> originalMetadata);
    [ExtensionAttribute]
internal static BlobImmutabilityPolicy ToBlobImmutabilityPolicy(ResponseWithHeaders`1<BlobSetImmutabilityPolicyHeaders> response);
    [ExtensionAttribute]
internal static BlobLegalHoldResult ToBlobLegalHoldInfo(ResponseWithHeaders`1<BlobSetLegalHoldHeaders> response);
    [ExtensionAttribute]
internal static string ToEncryptionAlgorithmString(EncryptionAlgorithmType type);
    [ExtensionAttribute]
internal static PageRangeItem[] ToPageBlobRanges(ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders> response);
    [ExtensionAttribute]
internal static PageRangeItem[] ToPageBlobRanges(ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders> response);
    internal static PageRangeItem[] ToPageBlobRanges(IReadOnlyList`1<PageRange> pageRanges, IReadOnlyList`1<ClearRange> clearRanges);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(RequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(BlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(BlobLeaseRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(AppendBlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(PageBlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(RequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, List`1& invalidList);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(BlobLeaseRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, List`1& invalidList);
    [ExtensionAttribute]
internal static void ValidateConditionsNotPresent(BlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, List`1& invalidList);
    [ExtensionAttribute]
internal static BlockListType ToBlockListType(BlockListTypes options);
    internal static IEnumerable`1<ListContainersIncludeType> AsIncludeItems(BlobContainerTraits traits, BlobContainerStates states);
    internal static IEnumerable`1<ListBlobsIncludeItem> AsIncludeItems(BlobTraits traits, BlobStates states);
    [ExtensionAttribute]
internal static string ToPermissionsString(BlobAccountSasPermissions permissions);
    [ExtensionAttribute]
internal static string ToPermissionsString(BlobContainerSasPermissions permissions);
    [ExtensionAttribute]
internal static string ToPermissionsString(BlobSasPermissions permissions);
    [ExtensionAttribute]
internal static string ToPermissionsString(BlobVersionSasPermissions permissions);
    [ExtensionAttribute]
internal static string ToPermissionsString(SnapshotSasPermissions permissions);
}
internal class Azure.Storage.Blobs.BlobGetPropertiesHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<DateTimeOffset> CreationTime { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public string ObjectReplicationPolicyId { get; }
    public IDictionary`2<string, string> ObjectReplicationRules { get; }
    public Nullable`1<BlobType> BlobType { get; }
    public Nullable`1<DateTimeOffset> CopyCompletionTime { get; }
    public string CopyStatusDescription { get; }
    public string CopyId { get; }
    public string CopyProgress { get; }
    public string CopySource { get; }
    public Nullable`1<CopyStatus> CopyStatus { get; }
    public Nullable`1<bool> IsIncrementalCopy { get; }
    public string DestinationSnapshot { get; }
    public Nullable`1<LeaseDurationType> LeaseDuration { get; }
    public Nullable`1<LeaseState> LeaseState { get; }
    public Nullable`1<LeaseStatus> LeaseStatus { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentType { get; }
    public Byte[] ContentMD5 { get; }
    public string ContentEncoding { get; }
    public string ContentDisposition { get; }
    public string ContentLanguage { get; }
    public string CacheControl { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public string Version { get; }
    public string AcceptRanges { get; }
    public Nullable`1<int> BlobCommittedBlockCount { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public string AccessTier { get; }
    public Nullable`1<bool> AccessTierInferred { get; }
    public string ArchiveStatus { get; }
    public Nullable`1<DateTimeOffset> AccessTierChangeTime { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsCurrentVersion { get; }
    public Nullable`1<long> TagCount { get; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; }
    public Nullable`1<bool> IsSealed { get; }
    public string RehydratePriority { get; }
    public Nullable`1<DateTimeOffset> LastAccessed { get; }
    public Nullable`1<DateTimeOffset> ImmutabilityPolicyExpiresOn { get; }
    public Nullable`1<BlobImmutabilityPolicyMode> ImmutabilityPolicyMode { get; }
    public Nullable`1<bool> LegalHold { get; }
    public BlobGetPropertiesHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<DateTimeOffset> get_CreationTime();
    public IDictionary`2<string, string> get_Metadata();
    public string get_ObjectReplicationPolicyId();
    public IDictionary`2<string, string> get_ObjectReplicationRules();
    public Nullable`1<BlobType> get_BlobType();
    public Nullable`1<DateTimeOffset> get_CopyCompletionTime();
    public string get_CopyStatusDescription();
    public string get_CopyId();
    public string get_CopyProgress();
    public string get_CopySource();
    public Nullable`1<CopyStatus> get_CopyStatus();
    public Nullable`1<bool> get_IsIncrementalCopy();
    public string get_DestinationSnapshot();
    public Nullable`1<LeaseDurationType> get_LeaseDuration();
    public Nullable`1<LeaseState> get_LeaseState();
    public Nullable`1<LeaseStatus> get_LeaseStatus();
    public Nullable`1<long> get_ContentLength();
    public string get_ContentType();
    public Byte[] get_ContentMD5();
    public string get_ContentEncoding();
    public string get_ContentDisposition();
    public string get_ContentLanguage();
    public string get_CacheControl();
    public Nullable`1<long> get_BlobSequenceNumber();
    public string get_Version();
    public string get_AcceptRanges();
    public Nullable`1<int> get_BlobCommittedBlockCount();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
    public string get_AccessTier();
    public Nullable`1<bool> get_AccessTierInferred();
    public string get_ArchiveStatus();
    public Nullable`1<DateTimeOffset> get_AccessTierChangeTime();
    public string get_VersionId();
    public Nullable`1<bool> get_IsCurrentVersion();
    public Nullable`1<long> get_TagCount();
    public Nullable`1<DateTimeOffset> get_ExpiresOn();
    public Nullable`1<bool> get_IsSealed();
    public string get_RehydratePriority();
    public Nullable`1<DateTimeOffset> get_LastAccessed();
    public Nullable`1<DateTimeOffset> get_ImmutabilityPolicyExpiresOn();
    public Nullable`1<BlobImmutabilityPolicyMode> get_ImmutabilityPolicyMode();
    public Nullable`1<bool> get_LegalHold();
}
internal class Azure.Storage.Blobs.BlobGetTagsHeaders : object {
    private Response _response;
    public string Version { get; }
    public BlobGetTagsHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobQueryHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentType { get; }
    public string ContentRange { get; }
    public Byte[] ContentMD5 { get; }
    public string ContentEncoding { get; }
    public string CacheControl { get; }
    public string ContentDisposition { get; }
    public string ContentLanguage { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public Nullable`1<BlobType> BlobType { get; }
    public Nullable`1<DateTimeOffset> CopyCompletionTime { get; }
    public string CopyStatusDescription { get; }
    public string CopyId { get; }
    public string CopyProgress { get; }
    public string CopySource { get; }
    public Nullable`1<CopyStatus> CopyStatus { get; }
    public Nullable`1<LeaseDurationType> LeaseDuration { get; }
    public Nullable`1<LeaseState> LeaseState { get; }
    public Nullable`1<LeaseStatus> LeaseStatus { get; }
    public string Version { get; }
    public string AcceptRanges { get; }
    public Nullable`1<int> BlobCommittedBlockCount { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public Byte[] BlobContentMD5 { get; }
    public Byte[] ContentCrc64 { get; }
    public BlobQueryHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public IDictionary`2<string, string> get_Metadata();
    public Nullable`1<long> get_ContentLength();
    public string get_ContentType();
    public string get_ContentRange();
    public Byte[] get_ContentMD5();
    public string get_ContentEncoding();
    public string get_CacheControl();
    public string get_ContentDisposition();
    public string get_ContentLanguage();
    public Nullable`1<long> get_BlobSequenceNumber();
    public Nullable`1<BlobType> get_BlobType();
    public Nullable`1<DateTimeOffset> get_CopyCompletionTime();
    public string get_CopyStatusDescription();
    public string get_CopyId();
    public string get_CopyProgress();
    public string get_CopySource();
    public Nullable`1<CopyStatus> get_CopyStatus();
    public Nullable`1<LeaseDurationType> get_LeaseDuration();
    public Nullable`1<LeaseState> get_LeaseState();
    public Nullable`1<LeaseStatus> get_LeaseStatus();
    public string get_Version();
    public string get_AcceptRanges();
    public Nullable`1<int> get_BlobCommittedBlockCount();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
    public Byte[] get_BlobContentMD5();
    public Byte[] get_ContentCrc64();
}
internal class Azure.Storage.Blobs.BlobQuickQueryStream : Stream {
    internal Stream _avroStream;
    internal AvroReader _avroReader;
    internal Byte[] _buffer;
    internal int _bufferOffset;
    internal int _bufferLength;
    internal IProgress`1<long> _progressHandler;
    internal Action`1<BlobQueryError> _errorHandler;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BlobQuickQueryStream(Stream avroStream, IProgress`1<long> progressHandler, Action`1<BlobQueryError> errorHandler);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobQuickQueryStream/<ReadAsync>d__9")]
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobQuickQueryStream/<ReadInternal>d__10")]
private Task`1<int> ReadInternal(bool async, Byte[] buffer, int offset, int count);
    internal static void ValidateReadParameters(Byte[] buffer, int offset, int count);
    internal void ProcessErrorRecord(Dictionary`2<string, object> record);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
internal class Azure.Storage.Blobs.BlobReleaseLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public BlobReleaseLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobRenewLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public BlobRenewLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    private static ResponseClassifier _responseClassifier200;
    private static ResponseClassifier _responseClassifier201;
    internal ClientDiagnostics ClientDiagnostics { get; }
    private static ResponseClassifier ResponseClassifier200 { get; }
    private static ResponseClassifier ResponseClassifier201 { get; }
    public BlobRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateDownloadRequest(string snapshot, string versionId, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<bool> rangeGetContentMD5, Nullable`1<bool> rangeGetContentCRC64, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<DownloadAsync>d__8")]
public Task`1<ResponseWithHeaders`2<Stream, BlobDownloadHeaders>> DownloadAsync(string snapshot, string versionId, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<bool> rangeGetContentMD5, Nullable`1<bool> rangeGetContentCRC64, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<Stream, BlobDownloadHeaders> Download(string snapshot, string versionId, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<bool> rangeGetContentMD5, Nullable`1<bool> rangeGetContentCRC64, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<GetPropertiesAsync>d__11")]
public Task`1<ResponseWithHeaders`1<BlobGetPropertiesHeaders>> GetPropertiesAsync(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobGetPropertiesHeaders> GetProperties(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, string encryptionAlgorithm, string ifTags, RequestConditions requestConditions, RequestContext context);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<GetPropertiesAsync>d__14")]
public virtual Task`1<Response> GetPropertiesAsync(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, string encryptionAlgorithm, string ifTags, RequestConditions requestConditions, RequestContext context);
    public virtual Response GetProperties(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, string encryptionAlgorithm, string ifTags, RequestConditions requestConditions, RequestContext context);
    internal HttpMessage CreateDeleteRequest(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, Nullable`1<DeleteSnapshotsOption> deleteSnapshots, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<BlobDeleteType> blobDeleteType);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<DeleteAsync>d__17")]
public Task`1<ResponseWithHeaders`1<BlobDeleteHeaders>> DeleteAsync(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, Nullable`1<DeleteSnapshotsOption> deleteSnapshots, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<BlobDeleteType> blobDeleteType, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobDeleteHeaders> Delete(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, Nullable`1<DeleteSnapshotsOption> deleteSnapshots, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<BlobDeleteType> blobDeleteType, CancellationToken cancellationToken);
    internal HttpMessage CreateUndeleteRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<UndeleteAsync>d__20")]
public Task`1<ResponseWithHeaders`1<BlobUndeleteHeaders>> UndeleteAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobUndeleteHeaders> Undelete(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateSetExpiryRequest(BlobExpiryOptions expiryOptions, Nullable`1<int> timeout, string expiresOn);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<SetExpiryAsync>d__23")]
public Task`1<ResponseWithHeaders`1<BlobSetExpiryHeaders>> SetExpiryAsync(BlobExpiryOptions expiryOptions, Nullable`1<int> timeout, string expiresOn, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobSetExpiryHeaders> SetExpiry(BlobExpiryOptions expiryOptions, Nullable`1<int> timeout, string expiresOn, CancellationToken cancellationToken);
    internal HttpMessage CreateSetHttpHeadersRequest(Nullable`1<int> timeout, string blobCacheControl, string blobContentType, Byte[] blobContentMD5, string blobContentEncoding, string blobContentLanguage, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobContentDisposition);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<SetHttpHeadersAsync>d__26")]
public Task`1<ResponseWithHeaders`1<BlobSetHttpHeadersHeaders>> SetHttpHeadersAsync(Nullable`1<int> timeout, string blobCacheControl, string blobContentType, Byte[] blobContentMD5, string blobContentEncoding, string blobContentLanguage, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobContentDisposition, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobSetHttpHeadersHeaders> SetHttpHeaders(Nullable`1<int> timeout, string blobCacheControl, string blobContentType, Byte[] blobContentMD5, string blobContentEncoding, string blobContentLanguage, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobContentDisposition, CancellationToken cancellationToken);
    internal HttpMessage CreateSetImmutabilityPolicyRequest(Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifUnmodifiedSince, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<SetImmutabilityPolicyAsync>d__29")]
public Task`1<ResponseWithHeaders`1<BlobSetImmutabilityPolicyHeaders>> SetImmutabilityPolicyAsync(Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifUnmodifiedSince, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobSetImmutabilityPolicyHeaders> SetImmutabilityPolicy(Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifUnmodifiedSince, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, CancellationToken cancellationToken);
    internal HttpMessage CreateDeleteImmutabilityPolicyRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<DeleteImmutabilityPolicyAsync>d__32")]
public Task`1<ResponseWithHeaders`1<BlobDeleteImmutabilityPolicyHeaders>> DeleteImmutabilityPolicyAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobDeleteImmutabilityPolicyHeaders> DeleteImmutabilityPolicy(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateSetLegalHoldRequest(bool legalHold, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<SetLegalHoldAsync>d__35")]
public Task`1<ResponseWithHeaders`1<BlobSetLegalHoldHeaders>> SetLegalHoldAsync(bool legalHold, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobSetLegalHoldHeaders> SetLegalHold(bool legalHold, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateSetMetadataRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<SetMetadataAsync>d__38")]
public Task`1<ResponseWithHeaders`1<BlobSetMetadataHeaders>> SetMetadataAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobSetMetadataHeaders> SetMetadata(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<AcquireLeaseAsync>d__41")]
public Task`1<ResponseWithHeaders`1<BlobAcquireLeaseHeaders>> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobAcquireLeaseHeaders> AcquireLease(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, string ifTags, RequestConditions requestConditions, RequestContext context);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<AcquireLeaseAsync>d__44")]
public virtual Task`1<Response> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, string ifTags, RequestConditions requestConditions, RequestContext context);
    public virtual Response AcquireLease(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, string ifTags, RequestConditions requestConditions, RequestContext context);
    internal HttpMessage CreateReleaseLeaseRequest(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<ReleaseLeaseAsync>d__47")]
public Task`1<ResponseWithHeaders`1<BlobReleaseLeaseHeaders>> ReleaseLeaseAsync(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobReleaseLeaseHeaders> ReleaseLease(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateRenewLeaseRequest(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<RenewLeaseAsync>d__50")]
public Task`1<ResponseWithHeaders`1<BlobRenewLeaseHeaders>> RenewLeaseAsync(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobRenewLeaseHeaders> RenewLease(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateChangeLeaseRequest(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<ChangeLeaseAsync>d__53")]
public Task`1<ResponseWithHeaders`1<BlobChangeLeaseHeaders>> ChangeLeaseAsync(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobChangeLeaseHeaders> ChangeLease(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateBreakLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<BreakLeaseAsync>d__56")]
public Task`1<ResponseWithHeaders`1<BlobBreakLeaseHeaders>> BreakLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobBreakLeaseHeaders> BreakLease(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateCreateSnapshotRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<CreateSnapshotAsync>d__59")]
public Task`1<ResponseWithHeaders`1<BlobCreateSnapshotHeaders>> CreateSnapshotAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobCreateSnapshotHeaders> CreateSnapshot(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, CancellationToken cancellationToken);
    internal HttpMessage CreateStartCopyFromURLRequest(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, string blobTagsString, Nullable`1<bool> sealBlob, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<StartCopyFromURLAsync>d__62")]
public Task`1<ResponseWithHeaders`1<BlobStartCopyFromURLHeaders>> StartCopyFromURLAsync(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, string blobTagsString, Nullable`1<bool> sealBlob, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobStartCopyFromURLHeaders> StartCopyFromURL(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, string blobTagsString, Nullable`1<bool> sealBlob, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken);
    internal HttpMessage CreateCopyFromURLRequest(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, string copySourceAuthorization, string encryptionScope, Nullable`1<BlobCopySourceTagsMode> copySourceTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<CopyFromURLAsync>d__65")]
public Task`1<ResponseWithHeaders`1<BlobCopyFromURLHeaders>> CopyFromURLAsync(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, string copySourceAuthorization, string encryptionScope, Nullable`1<BlobCopySourceTagsMode> copySourceTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobCopyFromURLHeaders> CopyFromURL(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, string copySourceAuthorization, string encryptionScope, Nullable`1<BlobCopySourceTagsMode> copySourceTags, CancellationToken cancellationToken);
    internal HttpMessage CreateAbortCopyFromURLRequest(string copyId, Nullable`1<int> timeout, string leaseId);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<AbortCopyFromURLAsync>d__68")]
public Task`1<ResponseWithHeaders`1<BlobAbortCopyFromURLHeaders>> AbortCopyFromURLAsync(string copyId, Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobAbortCopyFromURLHeaders> AbortCopyFromURL(string copyId, Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken);
    internal HttpMessage CreateSetTierRequest(AccessTier tier, string snapshot, string versionId, Nullable`1<int> timeout, Nullable`1<RehydratePriority> rehydratePriority, string leaseId, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<SetTierAsync>d__71")]
public Task`1<ResponseWithHeaders`1<BlobSetTierHeaders>> SetTierAsync(AccessTier tier, string snapshot, string versionId, Nullable`1<int> timeout, Nullable`1<RehydratePriority> rehydratePriority, string leaseId, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobSetTierHeaders> SetTier(AccessTier tier, string snapshot, string versionId, Nullable`1<int> timeout, Nullable`1<RehydratePriority> rehydratePriority, string leaseId, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateQueryRequest(string snapshot, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, QueryRequest queryRequest);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<QueryAsync>d__74")]
public Task`1<ResponseWithHeaders`2<Stream, BlobQueryHeaders>> QueryAsync(string snapshot, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, QueryRequest queryRequest, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<Stream, BlobQueryHeaders> Query(string snapshot, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, QueryRequest queryRequest, CancellationToken cancellationToken);
    internal HttpMessage CreateGetTagsRequest(Nullable`1<int> timeout, string snapshot, string versionId, string ifTags, string leaseId);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<GetTagsAsync>d__77")]
public Task`1<ResponseWithHeaders`2<BlobTags, BlobGetTagsHeaders>> GetTagsAsync(Nullable`1<int> timeout, string snapshot, string versionId, string ifTags, string leaseId, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<BlobTags, BlobGetTagsHeaders> GetTags(Nullable`1<int> timeout, string snapshot, string versionId, string ifTags, string leaseId, CancellationToken cancellationToken);
    internal HttpMessage CreateSetTagsRequest(Nullable`1<int> timeout, string versionId, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string ifTags, string leaseId, BlobTags tags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobRestClient/<SetTagsAsync>d__80")]
public Task`1<ResponseWithHeaders`1<BlobSetTagsHeaders>> SetTagsAsync(Nullable`1<int> timeout, string versionId, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string ifTags, string leaseId, BlobTags tags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlobSetTagsHeaders> SetTags(Nullable`1<int> timeout, string versionId, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string ifTags, string leaseId, BlobTags tags, CancellationToken cancellationToken);
    private static ResponseClassifier get_ResponseClassifier200();
    private static ResponseClassifier get_ResponseClassifier201();
}
public class Azure.Storage.Blobs.BlobServiceClient : object {
    private Uri _uri;
    private BlobClientConfiguration _clientConfiguration;
    private HttpPipelinePolicy _authenticationPolicy;
    private ClientSideEncryptionOptions _clientSideEncryption;
    private string _accountName;
    private ServiceRestClient _serviceRestClient;
    public Uri Uri { get; }
    internal BlobClientConfiguration ClientConfiguration { get; }
    internal HttpPipelinePolicy AuthenticationPolicy { get; }
    internal ClientSideEncryptionOptions ClientSideEncryption { get; }
    public string AccountName { get; }
    public bool CanGenerateAccountSasUri { get; }
    internal ServiceRestClient ServiceRestClient { get; }
    public BlobServiceClient(string connectionString);
    public BlobServiceClient(string connectionString, BlobClientOptions options);
    public BlobServiceClient(Uri serviceUri, BlobClientOptions options);
    public BlobServiceClient(Uri serviceUri, StorageSharedKeyCredential credential, BlobClientOptions options);
    public BlobServiceClient(Uri serviceUri, AzureSasCredential credential, BlobClientOptions options);
    public BlobServiceClient(Uri serviceUri, TokenCredential credential, BlobClientOptions options);
    internal BlobServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, BlobClientOptions options);
    internal BlobServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, StorageSharedKeyCredential storageSharedKeyCredential, BlobClientOptions options);
    internal BlobServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, TokenCredential tokenCredential, BlobClientOptions options);
    internal BlobServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, AzureSasCredential sasCredential, BlobClientOptions options);
    internal BlobServiceClient(Uri serviceUri, BlobClientConfiguration clientConfiguration, HttpPipelinePolicy authentication, ClientSideEncryptionOptions clientSideEncryption);
    public virtual Uri get_Uri();
    internal virtual BlobClientConfiguration get_ClientConfiguration();
    internal virtual HttpPipelinePolicy get_AuthenticationPolicy();
    internal virtual ClientSideEncryptionOptions get_ClientSideEncryption();
    public string get_AccountName();
    public virtual bool get_CanGenerateAccountSasUri();
    internal virtual ServiceRestClient get_ServiceRestClient();
    protected static BlobServiceClient CreateClient(Uri serviceUri, BlobClientOptions options, HttpPipelinePolicy authentication, HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    [EditorBrowsableAttribute("1")]
protected static BlobServiceClient CreateClient(Uri serviceUri, BlobClientOptions options, HttpPipelinePolicy authentication, HttpPipeline pipeline);
    private ServiceRestClient BuildServiceRestClient(Uri uri);
    public virtual BlobContainerClient GetBlobContainerClient(string blobContainerName);
    protected static HttpPipeline GetHttpPipeline(BlobServiceClient client);
    protected static HttpPipelinePolicy GetAuthenticationPolicy(BlobServiceClient client);
    protected static BlobClientOptions GetClientOptions(BlobServiceClient client);
    public virtual Pageable`1<BlobContainerItem> GetBlobContainers(BlobContainerTraits traits, BlobContainerStates states, string prefix, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Pageable`1<BlobContainerItem> GetBlobContainers(BlobContainerTraits traits, string prefix, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<BlobContainerItem> GetBlobContainersAsync(BlobContainerTraits traits, BlobContainerStates states, string prefix, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual AsyncPageable`1<BlobContainerItem> GetBlobContainersAsync(BlobContainerTraits traits, string prefix, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<GetBlobContainersInternal>d__43")]
internal Task`1<Response`1<ListContainersSegmentResponse>> GetBlobContainersInternal(string continuationToken, BlobContainerTraits traits, BlobContainerStates states, string prefix, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    public virtual Response`1<AccountInfo> GetAccountInfo(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<GetAccountInfoAsync>d__45")]
public virtual Task`1<Response`1<AccountInfo>> GetAccountInfoAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<GetAccountInfoInternal>d__46")]
private Task`1<Response`1<AccountInfo>> GetAccountInfoInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobServiceProperties> GetProperties(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<GetPropertiesAsync>d__48")]
public virtual Task`1<Response`1<BlobServiceProperties>> GetPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<GetPropertiesInternal>d__49")]
private Task`1<Response`1<BlobServiceProperties>> GetPropertiesInternal(bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute]
public virtual Response SetProperties(BlobServiceProperties properties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<SetPropertiesAsync>d__51")]
[CallerShouldAuditAttribute]
public virtual Task`1<Response> SetPropertiesAsync(BlobServiceProperties properties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<SetPropertiesInternal>d__52")]
private Task`1<Response> SetPropertiesInternal(BlobServiceProperties properties, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobServiceStatistics> GetStatistics(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<GetStatisticsAsync>d__54")]
public virtual Task`1<Response`1<BlobServiceStatistics>> GetStatisticsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<GetStatisticsInternal>d__55")]
private Task`1<Response`1<BlobServiceStatistics>> GetStatisticsInternal(bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute]
public virtual Response`1<UserDelegationKey> GetUserDelegationKey(Nullable`1<DateTimeOffset> startsOn, DateTimeOffset expiresOn, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<GetUserDelegationKeyAsync>d__57")]
[CallerShouldAuditAttribute]
public virtual Task`1<Response`1<UserDelegationKey>> GetUserDelegationKeyAsync(Nullable`1<DateTimeOffset> startsOn, DateTimeOffset expiresOn, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<GetUserDelegationKeyInternal>d__58")]
private Task`1<Response`1<UserDelegationKey>> GetUserDelegationKeyInternal(Nullable`1<DateTimeOffset> startsOn, DateTimeOffset expiresOn, bool async, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<BlobContainerClient> CreateBlobContainer(string blobContainerName, PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<CreateBlobContainerAsync>d__60")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<BlobContainerClient>> CreateBlobContainerAsync(string blobContainerName, PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response DeleteBlobContainer(string blobContainerName, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<DeleteBlobContainerAsync>d__62")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response> DeleteBlobContainerAsync(string blobContainerName, BlobRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<BlobContainerClient> UndeleteBlobContainer(string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<UndeleteBlobContainerAsync>d__64")]
public virtual Task`1<Response`1<BlobContainerClient>> UndeleteBlobContainerAsync(string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContainerClient> UndeleteBlobContainer(string deletedContainerName, string deletedContainerVersion, string destinationContainerName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<UndeleteBlobContainerAsync>d__66")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContainerClient>> UndeleteBlobContainerAsync(string deletedContainerName, string deletedContainerVersion, string destinationContainerName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<UndeleteBlobContainerInternal>d__67")]
internal Task`1<Response`1<BlobContainerClient>> UndeleteBlobContainerInternal(string deletedContainerName, string deletedContainerVersion, string destinationContainerName, bool async, CancellationToken cancellationToken);
    internal virtual Response`1<BlobContainerClient> RenameBlobContainer(string sourceContainerName, string destinationContainerName, BlobRequestConditions sourceConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<RenameBlobContainerAsync>d__69")]
internal virtual Task`1<Response`1<BlobContainerClient>> RenameBlobContainerAsync(string sourceContainerName, string destinationContainerName, BlobRequestConditions sourceConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<RenameBlobContainerInternal>d__70")]
internal Task`1<Response`1<BlobContainerClient>> RenameBlobContainerInternal(string sourceContainerName, string destinationContainerName, BlobRequestConditions sourceConditions, bool async, CancellationToken cancellationToken);
    public virtual Pageable`1<TaggedBlobItem> FindBlobsByTags(string tagFilterSqlExpression, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<TaggedBlobItem> FindBlobsByTagsAsync(string tagFilterSqlExpression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlobServiceClient/<FindBlobsByTagsInternal>d__73")]
internal Task`1<Response`1<FilterBlobSegment>> FindBlobsByTagsInternal(string marker, string expression, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute]
public Uri GenerateAccountSasUri(AccountSasPermissions permissions, DateTimeOffset expiresOn, AccountSasResourceTypes resourceTypes);
    [CallerShouldAuditAttribute]
public Uri GenerateAccountSasUri(AccountSasBuilder builder);
}
internal class Azure.Storage.Blobs.BlobSetExpiryHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public BlobSetExpiryHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobSetHttpHeadersHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public string Version { get; }
    public BlobSetHttpHeadersHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<long> get_BlobSequenceNumber();
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobSetImmutabilityPolicyHeaders : object {
    private Response _response;
    public string Version { get; }
    public Nullable`1<DateTimeOffset> ImmutabilityPolicyExpiry { get; }
    public Nullable`1<BlobImmutabilityPolicyMode> ImmutabilityPolicyMode { get; }
    public BlobSetImmutabilityPolicyHeaders(Response response);
    public string get_Version();
    public Nullable`1<DateTimeOffset> get_ImmutabilityPolicyExpiry();
    public Nullable`1<BlobImmutabilityPolicyMode> get_ImmutabilityPolicyMode();
}
internal class Azure.Storage.Blobs.BlobSetLegalHoldHeaders : object {
    private Response _response;
    public string Version { get; }
    public Nullable`1<bool> LegalHold { get; }
    public BlobSetLegalHoldHeaders(Response response);
    public string get_Version();
    public Nullable`1<bool> get_LegalHold();
}
internal class Azure.Storage.Blobs.BlobSetMetadataHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public BlobSetMetadataHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_VersionId();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.BlobSetTagsHeaders : object {
    private Response _response;
    public string Version { get; }
    public BlobSetTagsHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobSetTierHeaders : object {
    private Response _response;
    public string Version { get; }
    public BlobSetTierHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlobStartCopyFromURLHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string VersionId { get; }
    public string CopyId { get; }
    public Nullable`1<CopyStatus> CopyStatus { get; }
    public BlobStartCopyFromURLHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_VersionId();
    public string get_CopyId();
    public Nullable`1<CopyStatus> get_CopyStatus();
}
internal class Azure.Storage.Blobs.BlobUndeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public BlobUndeleteHeaders(Response response);
    public string get_Version();
}
public class Azure.Storage.Blobs.BlobUriBuilder : object {
    private Uri _uri;
    private bool _isPathStyleUri;
    [CompilerGeneratedAttribute]
private bool <TrimBlobNameSlashes>k__BackingField;
    private string _scheme;
    private string _host;
    private int _port;
    private string _accountName;
    private string _containerName;
    private string _blobName;
    private string _snapshot;
    private string _versionId;
    private BlobSasQueryParameters _sas;
    private string _query;
    public bool TrimBlobNameSlashes { get; }
    public string Scheme { get; public set; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public string AccountName { get; public set; }
    public string BlobContainerName { get; public set; }
    public string BlobName { get; public set; }
    public string Snapshot { get; public set; }
    public string VersionId { get; public set; }
    public BlobSasQueryParameters Sas { get; public set; }
    public string Query { get; public set; }
    public BlobUriBuilder(Uri uri);
    public BlobUriBuilder(Uri uri, bool trimBlobNameSlashes);
    [CompilerGeneratedAttribute]
public bool get_TrimBlobNameSlashes();
    public string get_Scheme();
    public void set_Scheme(string value);
    public string get_Host();
    public void set_Host(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_AccountName();
    public void set_AccountName(string value);
    public string get_BlobContainerName();
    public void set_BlobContainerName(string value);
    public string get_BlobName();
    public void set_BlobName(string value);
    public string get_Snapshot();
    public void set_Snapshot(string value);
    public string get_VersionId();
    public void set_VersionId(string value);
    public BlobSasQueryParameters get_Sas();
    public void set_Sas(BlobSasQueryParameters value);
    public string get_Query();
    public void set_Query(string value);
    public Uri ToUri();
    public virtual string ToString();
    private void ResetUri();
    private RequestUriBuilder BuildUri();
}
internal class Azure.Storage.Blobs.BlockBlobCommitBlockListHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public Byte[] XMsContentCrc64 { get; }
    public string Version { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public BlockBlobCommitBlockListHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public Byte[] get_XMsContentCrc64();
    public string get_Version();
    public string get_VersionId();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.BlockBlobGetBlockListHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string ContentType { get; }
    public Nullable`1<long> BlobContentLength { get; }
    public string Version { get; }
    public BlockBlobGetBlockListHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_ContentType();
    public Nullable`1<long> get_BlobContentLength();
    public string get_Version();
}
internal class Azure.Storage.Blobs.BlockBlobPutBlobFromUrlHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public string Version { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public BlockBlobPutBlobFromUrlHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public string get_Version();
    public string get_VersionId();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.BlockBlobRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public BlockBlobRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateUploadRequest(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, Byte[] transactionalContentCrc64);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlockBlobRestClient/<UploadAsync>d__8")]
public Task`1<ResponseWithHeaders`1<BlockBlobUploadHeaders>> UploadAsync(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, Byte[] transactionalContentCrc64, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlockBlobUploadHeaders> Upload(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, Byte[] transactionalContentCrc64, CancellationToken cancellationToken);
    internal HttpMessage CreatePutBlobFromUrlRequest(long contentLength, string copySource, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<bool> copySourceBlobProperties, string copySourceAuthorization, Nullable`1<BlobCopySourceTagsMode> copySourceTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlockBlobRestClient/<PutBlobFromUrlAsync>d__11")]
public Task`1<ResponseWithHeaders`1<BlockBlobPutBlobFromUrlHeaders>> PutBlobFromUrlAsync(long contentLength, string copySource, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<bool> copySourceBlobProperties, string copySourceAuthorization, Nullable`1<BlobCopySourceTagsMode> copySourceTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlockBlobPutBlobFromUrlHeaders> PutBlobFromUrl(long contentLength, string copySource, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<bool> copySourceBlobProperties, string copySourceAuthorization, Nullable`1<BlobCopySourceTagsMode> copySourceTags, CancellationToken cancellationToken);
    internal HttpMessage CreateStageBlockRequest(string blockId, long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlockBlobRestClient/<StageBlockAsync>d__14")]
public Task`1<ResponseWithHeaders`1<BlockBlobStageBlockHeaders>> StageBlockAsync(string blockId, long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlockBlobStageBlockHeaders> StageBlock(string blockId, long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, CancellationToken cancellationToken);
    internal HttpMessage CreateStageBlockFromURLRequest(string blockId, long contentLength, string sourceUrl, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlockBlobRestClient/<StageBlockFromURLAsync>d__17")]
public Task`1<ResponseWithHeaders`1<BlockBlobStageBlockFromURLHeaders>> StageBlockFromURLAsync(string blockId, long contentLength, string sourceUrl, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlockBlobStageBlockFromURLHeaders> StageBlockFromURL(string blockId, long contentLength, string sourceUrl, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken);
    internal HttpMessage CreateCommitBlockListRequest(BlockLookupList blocks, Nullable`1<int> timeout, string blobCacheControl, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlockBlobRestClient/<CommitBlockListAsync>d__20")]
public Task`1<ResponseWithHeaders`1<BlockBlobCommitBlockListHeaders>> CommitBlockListAsync(BlockLookupList blocks, Nullable`1<int> timeout, string blobCacheControl, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<BlockBlobCommitBlockListHeaders> CommitBlockList(BlockLookupList blocks, Nullable`1<int> timeout, string blobCacheControl, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken);
    internal HttpMessage CreateGetBlockListRequest(BlockListType listType, string snapshot, Nullable`1<int> timeout, string leaseId, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlockBlobRestClient/<GetBlockListAsync>d__23")]
public Task`1<ResponseWithHeaders`2<BlockList, BlockBlobGetBlockListHeaders>> GetBlockListAsync(BlockListType listType, string snapshot, Nullable`1<int> timeout, string leaseId, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<BlockList, BlockBlobGetBlockListHeaders> GetBlockList(BlockListType listType, string snapshot, Nullable`1<int> timeout, string leaseId, string ifTags, CancellationToken cancellationToken);
}
internal class Azure.Storage.Blobs.BlockBlobStageBlockFromURLHeaders : object {
    private Response _response;
    public Byte[] ContentMD5 { get; }
    public Byte[] XMsContentCrc64 { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public BlockBlobStageBlockFromURLHeaders(Response response);
    public Byte[] get_ContentMD5();
    public Byte[] get_XMsContentCrc64();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.BlockBlobStageBlockHeaders : object {
    private Response _response;
    public Byte[] ContentMD5 { get; }
    public string Version { get; }
    public Byte[] XMsContentCrc64 { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public BlockBlobStageBlockHeaders(Response response);
    public Byte[] get_ContentMD5();
    public string get_Version();
    public Byte[] get_XMsContentCrc64();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.BlockBlobUploadHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public string Version { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public BlockBlobUploadHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public string get_Version();
    public string get_VersionId();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.BlockBlobWriteStream : StorageWriteStream {
    private BlockBlobClient _blockBlobClient;
    private BlobRequestConditions _conditions;
    private List`1<string> _blockIds;
    private BlobHttpHeaders _blobHttpHeaders;
    private IDictionary`2<string, string> _metadata;
    private IDictionary`2<string, string> _tags;
    public BlockBlobWriteStream(BlockBlobClient blockBlobClient, long bufferSize, long position, BlobRequestConditions conditions, IProgress`1<long> progressHandler, BlobHttpHeaders blobHttpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, UploadTransferValidationOptions transferValidation);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlockBlobWriteStream/<AppendInternal>d__7")]
protected virtual Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.BlockBlobWriteStream/<CommitInternal>d__8")]
protected virtual Task CommitInternal(bool async, CancellationToken cancellationToken);
    protected virtual void ValidateBufferSize(long bufferSize);
}
internal class Azure.Storage.Blobs.ContainerAcquireLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public ContainerAcquireLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerBreakLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<int> LeaseTime { get; }
    public string Version { get; }
    public ContainerBreakLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<int> get_LeaseTime();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerChangeLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public ContainerChangeLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerCreateHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ContainerCreateHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerDeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public ContainerDeleteHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerFilterBlobsHeaders : object {
    private Response _response;
    public string Version { get; }
    public ContainerFilterBlobsHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerGetAccessPolicyHeaders : object {
    private Response _response;
    public Nullable`1<PublicAccessType> BlobPublicAccess { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ContainerGetAccessPolicyHeaders(Response response);
    public Nullable`1<PublicAccessType> get_BlobPublicAccess();
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerGetPropertiesHeaders : object {
    private Response _response;
    public IDictionary`2<string, string> Metadata { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<LeaseDurationType> LeaseDuration { get; }
    public Nullable`1<LeaseState> LeaseState { get; }
    public Nullable`1<LeaseStatus> LeaseStatus { get; }
    public string Version { get; }
    public Nullable`1<PublicAccessType> BlobPublicAccess { get; }
    public Nullable`1<bool> HasImmutabilityPolicy { get; }
    public Nullable`1<bool> HasLegalHold { get; }
    public string DefaultEncryptionScope { get; }
    public Nullable`1<bool> DenyEncryptionScopeOverride { get; }
    public Nullable`1<bool> IsImmutableStorageWithVersioningEnabled { get; }
    public ContainerGetPropertiesHeaders(Response response);
    public IDictionary`2<string, string> get_Metadata();
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<LeaseDurationType> get_LeaseDuration();
    public Nullable`1<LeaseState> get_LeaseState();
    public Nullable`1<LeaseStatus> get_LeaseStatus();
    public string get_Version();
    public Nullable`1<PublicAccessType> get_BlobPublicAccess();
    public Nullable`1<bool> get_HasImmutabilityPolicy();
    public Nullable`1<bool> get_HasLegalHold();
    public string get_DefaultEncryptionScope();
    public Nullable`1<bool> get_DenyEncryptionScopeOverride();
    public Nullable`1<bool> get_IsImmutableStorageWithVersioningEnabled();
}
internal class Azure.Storage.Blobs.ContainerListBlobFlatSegmentHeaders : object {
    private Response _response;
    public string ContentType { get; }
    public string Version { get; }
    public ContainerListBlobFlatSegmentHeaders(Response response);
    public string get_ContentType();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerListBlobHierarchySegmentHeaders : object {
    private Response _response;
    public string ContentType { get; }
    public string Version { get; }
    public ContainerListBlobHierarchySegmentHeaders(Response response);
    public string get_ContentType();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerReleaseLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ContainerReleaseLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerRenameHeaders : object {
    private Response _response;
    public string Version { get; }
    public ContainerRenameHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerRenewLeaseHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string LeaseId { get; }
    public string Version { get; }
    public ContainerRenewLeaseHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_LeaseId();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    private static ResponseClassifier _responseClassifier201;
    internal ClientDiagnostics ClientDiagnostics { get; }
    private static ResponseClassifier ResponseClassifier201 { get; }
    public ContainerRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateCreateRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<PublicAccessType> access, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<CreateAsync>d__8")]
public Task`1<ResponseWithHeaders`1<ContainerCreateHeaders>> CreateAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<PublicAccessType> access, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerCreateHeaders> Create(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<PublicAccessType> access, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(Nullable`1<int> timeout, string leaseId);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<GetPropertiesAsync>d__11")]
public Task`1<ResponseWithHeaders`1<ContainerGetPropertiesHeaders>> GetPropertiesAsync(Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerGetPropertiesHeaders> GetProperties(Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken);
    internal HttpMessage CreateDeleteRequest(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<DeleteAsync>d__14")]
public Task`1<ResponseWithHeaders`1<ContainerDeleteHeaders>> DeleteAsync(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerDeleteHeaders> Delete(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateSetMetadataRequest(Nullable`1<int> timeout, string leaseId, IDictionary`2<string, string> metadata, Nullable`1<DateTimeOffset> ifModifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<SetMetadataAsync>d__17")]
public Task`1<ResponseWithHeaders`1<ContainerSetMetadataHeaders>> SetMetadataAsync(Nullable`1<int> timeout, string leaseId, IDictionary`2<string, string> metadata, Nullable`1<DateTimeOffset> ifModifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerSetMetadataHeaders> SetMetadata(Nullable`1<int> timeout, string leaseId, IDictionary`2<string, string> metadata, Nullable`1<DateTimeOffset> ifModifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateGetAccessPolicyRequest(Nullable`1<int> timeout, string leaseId);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<GetAccessPolicyAsync>d__20")]
public Task`1<ResponseWithHeaders`2<IReadOnlyList`1<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders>> GetAccessPolicyAsync(Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<IReadOnlyList`1<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders> GetAccessPolicy(Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken);
    internal HttpMessage CreateSetAccessPolicyRequest(Nullable`1<int> timeout, string leaseId, Nullable`1<PublicAccessType> access, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, IEnumerable`1<BlobSignedIdentifier> containerAcl);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<SetAccessPolicyAsync>d__23")]
public Task`1<ResponseWithHeaders`1<ContainerSetAccessPolicyHeaders>> SetAccessPolicyAsync(Nullable`1<int> timeout, string leaseId, Nullable`1<PublicAccessType> access, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, IEnumerable`1<BlobSignedIdentifier> containerAcl, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerSetAccessPolicyHeaders> SetAccessPolicy(Nullable`1<int> timeout, string leaseId, Nullable`1<PublicAccessType> access, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, IEnumerable`1<BlobSignedIdentifier> containerAcl, CancellationToken cancellationToken);
    internal HttpMessage CreateRestoreRequest(Nullable`1<int> timeout, string deletedContainerName, string deletedContainerVersion);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<RestoreAsync>d__26")]
public Task`1<ResponseWithHeaders`1<ContainerRestoreHeaders>> RestoreAsync(Nullable`1<int> timeout, string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerRestoreHeaders> Restore(Nullable`1<int> timeout, string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken);
    internal HttpMessage CreateRenameRequest(string sourceContainerName, Nullable`1<int> timeout, string sourceLeaseId);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<RenameAsync>d__29")]
public Task`1<ResponseWithHeaders`1<ContainerRenameHeaders>> RenameAsync(string sourceContainerName, Nullable`1<int> timeout, string sourceLeaseId, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerRenameHeaders> Rename(string sourceContainerName, Nullable`1<int> timeout, string sourceLeaseId, CancellationToken cancellationToken);
    internal HttpMessage CreateSubmitBatchRequest(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<SubmitBatchAsync>d__32")]
public Task`1<ResponseWithHeaders`2<Stream, ContainerSubmitBatchHeaders>> SubmitBatchAsync(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<Stream, ContainerSubmitBatchHeaders> SubmitBatch(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateFilterBlobsRequest(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<FilterBlobsAsync>d__35")]
public Task`1<ResponseWithHeaders`2<FilterBlobSegment, ContainerFilterBlobsHeaders>> FilterBlobsAsync(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<FilterBlobSegment, ContainerFilterBlobsHeaders> FilterBlobs(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include, CancellationToken cancellationToken);
    internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<AcquireLeaseAsync>d__38")]
public Task`1<ResponseWithHeaders`1<ContainerAcquireLeaseHeaders>> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerAcquireLeaseHeaders> AcquireLease(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, RequestConditions requestConditions, RequestContext context);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<AcquireLeaseAsync>d__41")]
public virtual Task`1<Response> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, RequestConditions requestConditions, RequestContext context);
    public virtual Response AcquireLease(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, RequestConditions requestConditions, RequestContext context);
    internal HttpMessage CreateReleaseLeaseRequest(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<ReleaseLeaseAsync>d__44")]
public Task`1<ResponseWithHeaders`1<ContainerReleaseLeaseHeaders>> ReleaseLeaseAsync(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerReleaseLeaseHeaders> ReleaseLease(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateRenewLeaseRequest(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<RenewLeaseAsync>d__47")]
public Task`1<ResponseWithHeaders`1<ContainerRenewLeaseHeaders>> RenewLeaseAsync(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerRenewLeaseHeaders> RenewLease(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateBreakLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<BreakLeaseAsync>d__50")]
public Task`1<ResponseWithHeaders`1<ContainerBreakLeaseHeaders>> BreakLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerBreakLeaseHeaders> BreakLease(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateChangeLeaseRequest(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<ChangeLeaseAsync>d__53")]
public Task`1<ResponseWithHeaders`1<ContainerChangeLeaseHeaders>> ChangeLeaseAsync(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ContainerChangeLeaseHeaders> ChangeLease(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken);
    internal HttpMessage CreateListBlobFlatSegmentRequest(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<ListBlobFlatSegmentAsync>d__56")]
public Task`1<ResponseWithHeaders`2<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders>> ListBlobFlatSegmentAsync(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders> ListBlobFlatSegment(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateListBlobHierarchySegmentRequest(string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<ListBlobHierarchySegmentAsync>d__59")]
public Task`1<ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders>> ListBlobHierarchySegmentAsync(string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders> ListBlobHierarchySegment(string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateListBlobFlatSegmentNextPageRequest(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<ListBlobFlatSegmentNextPageAsync>d__62")]
public Task`1<ResponseWithHeaders`2<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders>> ListBlobFlatSegmentNextPageAsync(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders> ListBlobFlatSegmentNextPage(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateListBlobHierarchySegmentNextPageRequest(string nextLink, string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ContainerRestClient/<ListBlobHierarchySegmentNextPageAsync>d__65")]
public Task`1<ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders>> ListBlobHierarchySegmentNextPageAsync(string nextLink, string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders> ListBlobHierarchySegmentNextPage(string nextLink, string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    private static ResponseClassifier get_ResponseClassifier201();
}
internal class Azure.Storage.Blobs.ContainerRestoreHeaders : object {
    private Response _response;
    public string Version { get; }
    public ContainerRestoreHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerSetAccessPolicyHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ContainerSetAccessPolicyHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerSetMetadataHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public ContainerSetMetadataHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
}
internal class Azure.Storage.Blobs.ContainerSubmitBatchHeaders : object {
    private Response _response;
    public string ContentType { get; }
    public string Version { get; }
    public ContainerSubmitBatchHeaders(Response response);
    public string get_ContentType();
    public string get_Version();
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.EncryptionRangeExtensions : object {
    [ExtensionAttribute]
public static int GetTotalRegionLength(EncryptedRegionInfo info);
}
[IsReadOnlyAttribute]
public class Azure.Storage.Blobs.Models.AccessTier : ValueType {
    private string _value;
    private static string P4Value;
    private static string P6Value;
    private static string P10Value;
    private static string P15Value;
    private static string P20Value;
    private static string P30Value;
    private static string P40Value;
    private static string P50Value;
    private static string P60Value;
    private static string P70Value;
    private static string P80Value;
    private static string HotValue;
    private static string CoolValue;
    private static string ArchiveValue;
    private static string PremiumValue;
    private static string ColdValue;
    [CompilerGeneratedAttribute]
private static AccessTier <P4>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P6>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P10>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P15>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P20>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P30>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P40>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P50>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P60>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P70>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <P80>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <Hot>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <Cool>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <Archive>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <Premium>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccessTier <Cold>k__BackingField;
    public static AccessTier P4 { get; }
    public static AccessTier P6 { get; }
    public static AccessTier P10 { get; }
    public static AccessTier P15 { get; }
    public static AccessTier P20 { get; }
    public static AccessTier P30 { get; }
    public static AccessTier P40 { get; }
    public static AccessTier P50 { get; }
    public static AccessTier P60 { get; }
    public static AccessTier P70 { get; }
    public static AccessTier P80 { get; }
    public static AccessTier Hot { get; }
    public static AccessTier Cool { get; }
    public static AccessTier Archive { get; }
    public static AccessTier Premium { get; }
    public static AccessTier Cold { get; }
    public AccessTier(string value);
    private static AccessTier();
    [CompilerGeneratedAttribute]
public static AccessTier get_P4();
    [CompilerGeneratedAttribute]
public static AccessTier get_P6();
    [CompilerGeneratedAttribute]
public static AccessTier get_P10();
    [CompilerGeneratedAttribute]
public static AccessTier get_P15();
    [CompilerGeneratedAttribute]
public static AccessTier get_P20();
    [CompilerGeneratedAttribute]
public static AccessTier get_P30();
    [CompilerGeneratedAttribute]
public static AccessTier get_P40();
    [CompilerGeneratedAttribute]
public static AccessTier get_P50();
    [CompilerGeneratedAttribute]
public static AccessTier get_P60();
    [CompilerGeneratedAttribute]
public static AccessTier get_P70();
    [CompilerGeneratedAttribute]
public static AccessTier get_P80();
    [CompilerGeneratedAttribute]
public static AccessTier get_Hot();
    [CompilerGeneratedAttribute]
public static AccessTier get_Cool();
    [CompilerGeneratedAttribute]
public static AccessTier get_Archive();
    [CompilerGeneratedAttribute]
public static AccessTier get_Premium();
    [CompilerGeneratedAttribute]
public static AccessTier get_Cold();
    public static bool op_Equality(AccessTier left, AccessTier right);
    public static bool op_Inequality(AccessTier left, AccessTier right);
    public static AccessTier op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AccessTier other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
public class Azure.Storage.Blobs.Models.AccountInfo : object {
    [CompilerGeneratedAttribute]
private SkuName <SkuName>k__BackingField;
    [CompilerGeneratedAttribute]
private AccountKind <AccountKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHierarchicalNamespaceEnabled>k__BackingField;
    public SkuName SkuName { get; internal set; }
    public AccountKind AccountKind { get; internal set; }
    public bool IsHierarchicalNamespaceEnabled { get; internal set; }
    [CompilerGeneratedAttribute]
public SkuName get_SkuName();
    [CompilerGeneratedAttribute]
internal void set_SkuName(SkuName value);
    [CompilerGeneratedAttribute]
public AccountKind get_AccountKind();
    [CompilerGeneratedAttribute]
internal void set_AccountKind(AccountKind value);
    [CompilerGeneratedAttribute]
public bool get_IsHierarchicalNamespaceEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsHierarchicalNamespaceEnabled(bool value);
}
public enum Azure.Storage.Blobs.Models.AccountKind : Enum {
    public int value__;
    public static AccountKind Storage;
    public static AccountKind BlobStorage;
    public static AccountKind StorageV2;
    public static AccountKind FileStorage;
    public static AccountKind BlockBlobStorage;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.AccountKindExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(AccountKind value);
    [ExtensionAttribute]
public static AccountKind ToAccountKind(string value);
}
public class Azure.Storage.Blobs.Models.AppendBlobAppendBlockFromUriOptions : object {
    [CompilerGeneratedAttribute]
private HttpRange <SourceRange>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SourceContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private AppendBlobRequestConditions <DestinationConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private AppendBlobRequestConditions <SourceConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpAuthorization <SourceAuthentication>k__BackingField;
    public HttpRange SourceRange { get; public set; }
    public Byte[] SourceContentHash { get; public set; }
    public AppendBlobRequestConditions DestinationConditions { get; public set; }
    public AppendBlobRequestConditions SourceConditions { get; public set; }
    public HttpAuthorization SourceAuthentication { get; public set; }
    [CompilerGeneratedAttribute]
public HttpRange get_SourceRange();
    [CompilerGeneratedAttribute]
public void set_SourceRange(HttpRange value);
    [CompilerGeneratedAttribute]
public Byte[] get_SourceContentHash();
    [CompilerGeneratedAttribute]
public void set_SourceContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public AppendBlobRequestConditions get_DestinationConditions();
    [CompilerGeneratedAttribute]
public void set_DestinationConditions(AppendBlobRequestConditions value);
    [CompilerGeneratedAttribute]
public AppendBlobRequestConditions get_SourceConditions();
    [CompilerGeneratedAttribute]
public void set_SourceConditions(AppendBlobRequestConditions value);
    [CompilerGeneratedAttribute]
public HttpAuthorization get_SourceAuthentication();
    [CompilerGeneratedAttribute]
public void set_SourceAuthentication(HttpAuthorization value);
}
public class Azure.Storage.Blobs.Models.AppendBlobAppendBlockOptions : object {
    [CompilerGeneratedAttribute]
private AppendBlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public AppendBlobRequestConditions Conditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public AppendBlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(AppendBlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
}
public class Azure.Storage.Blobs.Models.AppendBlobCreateOptions : object {
    [CompilerGeneratedAttribute]
private BlobHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasLegalHold>k__BackingField;
    [CompilerGeneratedAttribute]
private AppendBlobRequestConditions <Conditions>k__BackingField;
    public BlobHttpHeaders HttpHeaders { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public IDictionary`2<string, string> Tags { get; public set; }
    public BlobImmutabilityPolicy ImmutabilityPolicy { get; public set; }
    public Nullable`1<bool> HasLegalHold { get; public set; }
    public AppendBlobRequestConditions Conditions { get; public set; }
    [CompilerGeneratedAttribute]
public BlobHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(BlobHttpHeaders value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public BlobImmutabilityPolicy get_ImmutabilityPolicy();
    [CompilerGeneratedAttribute]
public void set_ImmutabilityPolicy(BlobImmutabilityPolicy value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HasLegalHold();
    [CompilerGeneratedAttribute]
public void set_HasLegalHold(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public AppendBlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(AppendBlobRequestConditions value);
}
public class Azure.Storage.Blobs.Models.AppendBlobOpenWriteOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private AppendBlobRequestConditions <OpenConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public Nullable`1<long> BufferSize { get; public set; }
    public AppendBlobRequestConditions OpenConditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public AppendBlobRequestConditions get_OpenConditions();
    [CompilerGeneratedAttribute]
public void set_OpenConditions(AppendBlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
}
public class Azure.Storage.Blobs.Models.AppendBlobRequestConditions : BlobRequestConditions {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IfAppendPositionEqual>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IfMaxSizeLessThanOrEqual>k__BackingField;
    public Nullable`1<long> IfAppendPositionEqual { get; public set; }
    public Nullable`1<long> IfMaxSizeLessThanOrEqual { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IfAppendPositionEqual();
    [CompilerGeneratedAttribute]
public void set_IfAppendPositionEqual(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IfMaxSizeLessThanOrEqual();
    [CompilerGeneratedAttribute]
public void set_IfMaxSizeLessThanOrEqual(Nullable`1<long> value);
    internal virtual void AddConditions(StringBuilder conditions);
}
public enum Azure.Storage.Blobs.Models.ArchiveStatus : Enum {
    public int value__;
    public static ArchiveStatus RehydratePendingToHot;
    public static ArchiveStatus RehydratePendingToCool;
    public static ArchiveStatus RehydratePendingToCold;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.ArchiveStatusExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ArchiveStatus value);
    [ExtensionAttribute]
public static ArchiveStatus ToArchiveStatus(string value);
}
internal class Azure.Storage.Blobs.Models.ArrowConfiguration : object {
}
[CodeGenModelAttribute("ArrowField")]
internal class Azure.Storage.Blobs.Models.ArrowFieldInternal : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Scale>k__BackingField;
    public string Type { get; }
    public string Name { get; public set; }
    public Nullable`1<int> Precision { get; public set; }
    public Nullable`1<int> Scale { get; public set; }
    public ArrowFieldInternal(string type);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(Nullable`1<int> value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
}
[CodeGenModelAttribute("ArrowConfiguration")]
internal class Azure.Storage.Blobs.Models.ArrowTextConfigurationInternal : object {
    [CompilerGeneratedAttribute]
private IList`1<ArrowFieldInternal> <Schema>k__BackingField;
    public IList`1<ArrowFieldInternal> Schema { get; }
    public ArrowTextConfigurationInternal(IEnumerable`1<ArrowFieldInternal> schema);
    [CompilerGeneratedAttribute]
public IList`1<ArrowFieldInternal> get_Schema();
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
}
[CodeGenModelAttribute("AccessPolicy")]
public class Azure.Storage.Blobs.Models.BlobAccessPolicy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <PolicyStartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <PolicyExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CodeGenMemberAttribute("Start")]
public Nullable`1<DateTimeOffset> PolicyStartsOn { get; public set; }
    [CodeGenMemberAttribute("Expiry")]
public Nullable`1<DateTimeOffset> PolicyExpiresOn { get; public set; }
    [CodeGenMemberAttribute("Permission")]
public string Permissions { get; public set; }
    [EditorBrowsableAttribute("1")]
public DateTimeOffset StartsOn { get; public set; }
    [EditorBrowsableAttribute("1")]
public DateTimeOffset ExpiresOn { get; public set; }
    internal BlobAccessPolicy(Nullable`1<DateTimeOffset> policyStartsOn, Nullable`1<DateTimeOffset> policyExpiresOn, string permissions);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobAccessPolicy DeserializeBlobAccessPolicy(XElement element);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_PolicyStartsOn();
    [CompilerGeneratedAttribute]
public void set_PolicyStartsOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_PolicyExpiresOn();
    [CompilerGeneratedAttribute]
public void set_PolicyExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(string value);
    public DateTimeOffset get_StartsOn();
    public void set_StartsOn(DateTimeOffset value);
    public DateTimeOffset get_ExpiresOn();
    public void set_ExpiresOn(DateTimeOffset value);
}
[CodeGenModelAttribute("Logging")]
public class Azure.Storage.Blobs.Models.BlobAnalyticsLogging : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Delete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Read>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Write>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRetentionPolicy <RetentionPolicy>k__BackingField;
    public string Version { get; public set; }
    public bool Delete { get; public set; }
    public bool Read { get; public set; }
    public bool Write { get; public set; }
    public BlobRetentionPolicy RetentionPolicy { get; public set; }
    internal BlobAnalyticsLogging(string version, bool delete, bool read, bool write, BlobRetentionPolicy retentionPolicy);
    internal BlobAnalyticsLogging(bool skipInitialization);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Delete();
    [CompilerGeneratedAttribute]
public void set_Delete(bool value);
    [CompilerGeneratedAttribute]
public bool get_Read();
    [CompilerGeneratedAttribute]
public void set_Read(bool value);
    [CompilerGeneratedAttribute]
public bool get_Write();
    [CompilerGeneratedAttribute]
public void set_Write(bool value);
    [CompilerGeneratedAttribute]
public BlobRetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(BlobRetentionPolicy value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobAnalyticsLogging DeserializeBlobAnalyticsLogging(XElement element);
}
public class Azure.Storage.Blobs.Models.BlobAppendInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentCrc64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlobAppendOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlobCommittedBlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public Byte[] ContentCrc64 { get; internal set; }
    public string BlobAppendOffset { get; internal set; }
    public int BlobCommittedBlockCount { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    public string EncryptionKeySha256 { get; internal set; }
    public string EncryptionScope { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentCrc64();
    [CompilerGeneratedAttribute]
internal void set_ContentCrc64(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_BlobAppendOffset();
    [CompilerGeneratedAttribute]
internal void set_BlobAppendOffset(string value);
    [CompilerGeneratedAttribute]
public int get_BlobCommittedBlockCount();
    [CompilerGeneratedAttribute]
internal void set_BlobCommittedBlockCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKeySha256();
    [CompilerGeneratedAttribute]
internal void set_EncryptionKeySha256(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
}
[IsReadOnlyAttribute]
public class Azure.Storage.Blobs.Models.BlobAudience : ValueType {
    private string _value;
    private static string _defaultAudience;
    [CompilerGeneratedAttribute]
private static BlobAudience <DefaultAudience>k__BackingField;
    public static BlobAudience DefaultAudience { get; }
    public BlobAudience(string value);
    private static BlobAudience();
    [CompilerGeneratedAttribute]
public static BlobAudience get_DefaultAudience();
    public static BlobAudience CreateBlobServiceAccountAudience(string storageAccountName);
    public static bool op_Equality(BlobAudience left, BlobAudience right);
    public static bool op_Inequality(BlobAudience left, BlobAudience right);
    public static BlobAudience op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BlobAudience other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    internal string CreateDefaultScope();
}
internal class Azure.Storage.Blobs.Models.BlobBaseClientExistsClassifier : ResponseClassificationHandler {
    public static bool IsResourceNotFoundResponse(Response response);
    public static bool IsUsesCustomerSpecifiedEncryptionResponse(Response response);
    public virtual bool TryClassify(HttpMessage message, Boolean& isError);
}
[IsReadOnlyAttribute]
[CodeGenModelAttribute("Block")]
public class Azure.Storage.Blobs.Models.BlobBlock : ValueType {
    [CompilerGeneratedAttribute]
private long <SizeLong>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CodeGenMemberAttribute("Size")]
public long SizeLong { get; }
    [EditorBrowsableAttribute("1")]
public int Size { get; }
    [CodeGenMemberAttribute("Name")]
public string Name { get; }
    internal BlobBlock(string name, long sizeLong);
    internal static BlobBlock DeserializeBlobBlock(XElement element);
    [CompilerGeneratedAttribute]
public long get_SizeLong();
    public int get_Size();
    [CompilerGeneratedAttribute]
public string get_Name();
    [EditorBrowsableAttribute("1")]
public sealed virtual bool Equals(BlobBlock other);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
public class Azure.Storage.Blobs.Models.BlobContainerAccessPolicy : object {
    [CompilerGeneratedAttribute]
private PublicAccessType <BlobPublicAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<BlobSignedIdentifier> <SignedIdentifiers>k__BackingField;
    public PublicAccessType BlobPublicAccess { get; internal set; }
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public IEnumerable`1<BlobSignedIdentifier> SignedIdentifiers { get; internal set; }
    [CompilerGeneratedAttribute]
public PublicAccessType get_BlobPublicAccess();
    [CompilerGeneratedAttribute]
internal void set_BlobPublicAccess(PublicAccessType value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<BlobSignedIdentifier> get_SignedIdentifiers();
    [CompilerGeneratedAttribute]
internal void set_SignedIdentifiers(IEnumerable`1<BlobSignedIdentifier> value);
}
public class Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions : object {
    [CompilerGeneratedAttribute]
private string <DefaultEncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventEncryptionScopeOverride>k__BackingField;
    public string DefaultEncryptionScope { get; public set; }
    public bool PreventEncryptionScopeOverride { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultEncryptionScope();
    [CompilerGeneratedAttribute]
public void set_DefaultEncryptionScope(string value);
    [CompilerGeneratedAttribute]
public bool get_PreventEncryptionScopeOverride();
    [CompilerGeneratedAttribute]
public void set_PreventEncryptionScopeOverride(bool value);
}
public class Azure.Storage.Blobs.Models.BlobContainerInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
}
public class Azure.Storage.Blobs.Models.BlobContainerItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobContainerProperties <Properties>k__BackingField;
    public string Name { get; internal set; }
    public Nullable`1<bool> IsDeleted { get; internal set; }
    public string VersionId { get; internal set; }
    public BlobContainerProperties Properties { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsDeleted();
    [CompilerGeneratedAttribute]
internal void set_IsDeleted(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
internal void set_VersionId(string value);
    [CompilerGeneratedAttribute]
public BlobContainerProperties get_Properties();
    [CompilerGeneratedAttribute]
internal void set_Properties(BlobContainerProperties value);
}
public class Azure.Storage.Blobs.Models.BlobContainerProperties : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseStatus> <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseState> <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseDurationType> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PublicAccessType> <PublicAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasLegalHold>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultEncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PreventEncryptionScopeOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RemainingRetentionDays>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasImmutableStorageWithVersioning>k__BackingField;
    public DateTimeOffset LastModified { get; internal set; }
    public Nullable`1<LeaseStatus> LeaseStatus { get; internal set; }
    public Nullable`1<LeaseState> LeaseState { get; internal set; }
    public Nullable`1<LeaseDurationType> LeaseDuration { get; internal set; }
    public Nullable`1<PublicAccessType> PublicAccess { get; internal set; }
    public Nullable`1<bool> HasImmutabilityPolicy { get; internal set; }
    public Nullable`1<bool> HasLegalHold { get; internal set; }
    public string DefaultEncryptionScope { get; internal set; }
    public Nullable`1<bool> PreventEncryptionScopeOverride { get; internal set; }
    public Nullable`1<DateTimeOffset> DeletedOn { get; internal set; }
    public Nullable`1<int> RemainingRetentionDays { get; internal set; }
    public ETag ETag { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public bool HasImmutableStorageWithVersioning { get; internal set; }
    internal BlobContainerProperties(bool skipInitialization);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseStatus> get_LeaseStatus();
    [CompilerGeneratedAttribute]
internal void set_LeaseStatus(Nullable`1<LeaseStatus> value);
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseState> get_LeaseState();
    [CompilerGeneratedAttribute]
internal void set_LeaseState(Nullable`1<LeaseState> value);
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseDurationType> get_LeaseDuration();
    [CompilerGeneratedAttribute]
internal void set_LeaseDuration(Nullable`1<LeaseDurationType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<PublicAccessType> get_PublicAccess();
    [CompilerGeneratedAttribute]
internal void set_PublicAccess(Nullable`1<PublicAccessType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HasImmutabilityPolicy();
    [CompilerGeneratedAttribute]
internal void set_HasImmutabilityPolicy(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HasLegalHold();
    [CompilerGeneratedAttribute]
internal void set_HasLegalHold(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_DefaultEncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_DefaultEncryptionScope(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PreventEncryptionScopeOverride();
    [CompilerGeneratedAttribute]
internal void set_PreventEncryptionScopeOverride(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedOn();
    [CompilerGeneratedAttribute]
internal void set_DeletedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RemainingRetentionDays();
    [CompilerGeneratedAttribute]
internal void set_RemainingRetentionDays(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_HasImmutableStorageWithVersioning();
    [CompilerGeneratedAttribute]
internal void set_HasImmutableStorageWithVersioning(bool value);
}
[FlagsAttribute]
public enum Azure.Storage.Blobs.Models.BlobContainerStates : Enum {
    public int value__;
    public static BlobContainerStates None;
    public static BlobContainerStates Deleted;
    public static BlobContainerStates System;
}
[FlagsAttribute]
public enum Azure.Storage.Blobs.Models.BlobContainerTraits : Enum {
    public int value__;
    public static BlobContainerTraits None;
    public static BlobContainerTraits Metadata;
}
public class Azure.Storage.Blobs.Models.BlobContentInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlobSequenceNumber>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public string VersionId { get; internal set; }
    public string EncryptionKeySha256 { get; internal set; }
    public string EncryptionScope { get; internal set; }
    public long BlobSequenceNumber { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
internal void set_VersionId(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKeySha256();
    [CompilerGeneratedAttribute]
internal void set_EncryptionKeySha256(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
    [CompilerGeneratedAttribute]
public long get_BlobSequenceNumber();
    [CompilerGeneratedAttribute]
internal void set_BlobSequenceNumber(long value);
}
public class Azure.Storage.Blobs.Models.BlobCopyFromUriOptions : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AccessTier> <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <SourceConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <DestinationConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RehydratePriority> <RehydratePriority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ShouldSealDestination>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobImmutabilityPolicy <DestinationImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <LegalHold>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpAuthorization <SourceAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BlobCopySourceTagsMode> <CopySourceTagsMode>k__BackingField;
    public IDictionary`2<string, string> Metadata { get; public set; }
    public IDictionary`2<string, string> Tags { get; public set; }
    public Nullable`1<AccessTier> AccessTier { get; public set; }
    public BlobRequestConditions SourceConditions { get; public set; }
    public BlobRequestConditions DestinationConditions { get; public set; }
    public Nullable`1<RehydratePriority> RehydratePriority { get; public set; }
    public Nullable`1<bool> ShouldSealDestination { get; public set; }
    public BlobImmutabilityPolicy DestinationImmutabilityPolicy { get; public set; }
    public Nullable`1<bool> LegalHold { get; public set; }
    public HttpAuthorization SourceAuthentication { get; public set; }
    public Nullable`1<BlobCopySourceTagsMode> CopySourceTagsMode { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<AccessTier> get_AccessTier();
    [CompilerGeneratedAttribute]
public void set_AccessTier(Nullable`1<AccessTier> value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_SourceConditions();
    [CompilerGeneratedAttribute]
public void set_SourceConditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_DestinationConditions();
    [CompilerGeneratedAttribute]
public void set_DestinationConditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public Nullable`1<RehydratePriority> get_RehydratePriority();
    [CompilerGeneratedAttribute]
public void set_RehydratePriority(Nullable`1<RehydratePriority> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ShouldSealDestination();
    [CompilerGeneratedAttribute]
public void set_ShouldSealDestination(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public BlobImmutabilityPolicy get_DestinationImmutabilityPolicy();
    [CompilerGeneratedAttribute]
public void set_DestinationImmutabilityPolicy(BlobImmutabilityPolicy value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_LegalHold();
    [CompilerGeneratedAttribute]
public void set_LegalHold(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public HttpAuthorization get_SourceAuthentication();
    [CompilerGeneratedAttribute]
public void set_SourceAuthentication(HttpAuthorization value);
    [CompilerGeneratedAttribute]
public Nullable`1<BlobCopySourceTagsMode> get_CopySourceTagsMode();
    [CompilerGeneratedAttribute]
public void set_CopySourceTagsMode(Nullable`1<BlobCopySourceTagsMode> value);
}
public class Azure.Storage.Blobs.Models.BlobCopyInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyStatus <CopyStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public string VersionId { get; internal set; }
    public string CopyId { get; internal set; }
    public CopyStatus CopyStatus { get; internal set; }
    public string EncryptionScope { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
internal void set_VersionId(string value);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
internal void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public CopyStatus get_CopyStatus();
    [CompilerGeneratedAttribute]
internal void set_CopyStatus(CopyStatus value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
}
[CodeGenModelAttribute("BlobCopySourceTags")]
public enum Azure.Storage.Blobs.Models.BlobCopySourceTagsMode : Enum {
    public int value__;
    public static BlobCopySourceTagsMode Replace;
    public static BlobCopySourceTagsMode Copy;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.BlobCopySourceTagsModeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(BlobCopySourceTagsMode value);
    [ExtensionAttribute]
public static BlobCopySourceTagsMode ToBlobCopySourceTagsMode(string value);
}
[CodeGenModelAttribute("CorsRule")]
public class Azure.Storage.Blobs.Models.BlobCorsRule : object {
    [CompilerGeneratedAttribute]
private string <AllowedOrigins>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowedHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExposedHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAgeInSeconds>k__BackingField;
    public string AllowedOrigins { get; public set; }
    public string AllowedMethods { get; public set; }
    public string AllowedHeaders { get; public set; }
    public string ExposedHeaders { get; public set; }
    public int MaxAgeInSeconds { get; public set; }
    internal BlobCorsRule(string allowedOrigins, string allowedMethods, string allowedHeaders, string exposedHeaders, int maxAgeInSeconds);
    [CompilerGeneratedAttribute]
public string get_AllowedOrigins();
    [CompilerGeneratedAttribute]
public void set_AllowedOrigins(string value);
    [CompilerGeneratedAttribute]
public string get_AllowedMethods();
    [CompilerGeneratedAttribute]
public void set_AllowedMethods(string value);
    [CompilerGeneratedAttribute]
public string get_AllowedHeaders();
    [CompilerGeneratedAttribute]
public void set_AllowedHeaders(string value);
    [CompilerGeneratedAttribute]
public string get_ExposedHeaders();
    [CompilerGeneratedAttribute]
public void set_ExposedHeaders(string value);
    [CompilerGeneratedAttribute]
public int get_MaxAgeInSeconds();
    [CompilerGeneratedAttribute]
public void set_MaxAgeInSeconds(int value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobCorsRule DeserializeBlobCorsRule(XElement element);
}
internal enum Azure.Storage.Blobs.Models.BlobDeleteType : Enum {
    public int value__;
    public static BlobDeleteType None;
    public static BlobDeleteType Permanent;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.BlobDeleteTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(BlobDeleteType value);
    [ExtensionAttribute]
public static BlobDeleteType ToBlobDeleteType(string value);
}
public class Azure.Storage.Blobs.Models.BlobDownloadDetails : object {
    [CompilerGeneratedAttribute]
private BlobType <BlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentRange>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlobSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CopyCompletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyStatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyStatus <CopyStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private LeaseDurationType <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private LeaseState <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private LeaseStatus <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AcceptRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlobCommittedBlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <BlobContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TagCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSealed>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ObjectReplicationPolicy> <ObjectReplicationSourceProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObjectReplicationDestinationPolicyId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastAccessed>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLegalHold>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreatedOn>k__BackingField;
    public BlobType BlobType { get; internal set; }
    public long ContentLength { get; internal set; }
    public string ContentType { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public string ContentRange { get; internal set; }
    public ETag ETag { get; internal set; }
    public string ContentEncoding { get; internal set; }
    public string CacheControl { get; internal set; }
    public string ContentDisposition { get; internal set; }
    public string ContentLanguage { get; internal set; }
    public long BlobSequenceNumber { get; internal set; }
    public DateTimeOffset CopyCompletedOn { get; internal set; }
    public string CopyStatusDescription { get; internal set; }
    public string CopyId { get; internal set; }
    public string CopyProgress { get; internal set; }
    public Uri CopySource { get; internal set; }
    public CopyStatus CopyStatus { get; internal set; }
    public LeaseDurationType LeaseDuration { get; internal set; }
    public LeaseState LeaseState { get; internal set; }
    public LeaseStatus LeaseStatus { get; internal set; }
    public string AcceptRanges { get; internal set; }
    public int BlobCommittedBlockCount { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    public string EncryptionKeySha256 { get; internal set; }
    public string EncryptionScope { get; internal set; }
    public Byte[] BlobContentHash { get; internal set; }
    public long TagCount { get; internal set; }
    public string VersionId { get; internal set; }
    public bool IsSealed { get; internal set; }
    public IList`1<ObjectReplicationPolicy> ObjectReplicationSourceProperties { get; internal set; }
    public string ObjectReplicationDestinationPolicyId { get; internal set; }
    public DateTimeOffset LastAccessed { get; internal set; }
    public BlobImmutabilityPolicy ImmutabilityPolicy { get; internal set; }
    public bool HasLegalHold { get; internal set; }
    public DateTimeOffset CreatedOn { get; internal set; }
    [CompilerGeneratedAttribute]
public BlobType get_BlobType();
    [CompilerGeneratedAttribute]
internal void set_BlobType(BlobType value);
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
internal void set_ContentLength(long value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ContentRange();
    [CompilerGeneratedAttribute]
internal void set_ContentRange(string value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
internal void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
internal void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
internal void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
internal void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public long get_BlobSequenceNumber();
    [CompilerGeneratedAttribute]
internal void set_BlobSequenceNumber(long value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CopyCompletedOn();
    [CompilerGeneratedAttribute]
internal void set_CopyCompletedOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_CopyStatusDescription();
    [CompilerGeneratedAttribute]
internal void set_CopyStatusDescription(string value);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
internal void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public string get_CopyProgress();
    [CompilerGeneratedAttribute]
internal void set_CopyProgress(string value);
    [CompilerGeneratedAttribute]
public Uri get_CopySource();
    [CompilerGeneratedAttribute]
internal void set_CopySource(Uri value);
    [CompilerGeneratedAttribute]
public CopyStatus get_CopyStatus();
    [CompilerGeneratedAttribute]
internal void set_CopyStatus(CopyStatus value);
    [CompilerGeneratedAttribute]
public LeaseDurationType get_LeaseDuration();
    [CompilerGeneratedAttribute]
internal void set_LeaseDuration(LeaseDurationType value);
    [CompilerGeneratedAttribute]
public LeaseState get_LeaseState();
    [CompilerGeneratedAttribute]
internal void set_LeaseState(LeaseState value);
    [CompilerGeneratedAttribute]
public LeaseStatus get_LeaseStatus();
    [CompilerGeneratedAttribute]
internal void set_LeaseStatus(LeaseStatus value);
    [CompilerGeneratedAttribute]
public string get_AcceptRanges();
    [CompilerGeneratedAttribute]
internal void set_AcceptRanges(string value);
    [CompilerGeneratedAttribute]
public int get_BlobCommittedBlockCount();
    [CompilerGeneratedAttribute]
internal void set_BlobCommittedBlockCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKeySha256();
    [CompilerGeneratedAttribute]
internal void set_EncryptionKeySha256(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_BlobContentHash();
    [CompilerGeneratedAttribute]
internal void set_BlobContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public long get_TagCount();
    [CompilerGeneratedAttribute]
internal void set_TagCount(long value);
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
internal void set_VersionId(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSealed();
    [CompilerGeneratedAttribute]
internal void set_IsSealed(bool value);
    [CompilerGeneratedAttribute]
public IList`1<ObjectReplicationPolicy> get_ObjectReplicationSourceProperties();
    [CompilerGeneratedAttribute]
internal void set_ObjectReplicationSourceProperties(IList`1<ObjectReplicationPolicy> value);
    [CompilerGeneratedAttribute]
public string get_ObjectReplicationDestinationPolicyId();
    [CompilerGeneratedAttribute]
internal void set_ObjectReplicationDestinationPolicyId(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastAccessed();
    [CompilerGeneratedAttribute]
internal void set_LastAccessed(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public BlobImmutabilityPolicy get_ImmutabilityPolicy();
    [CompilerGeneratedAttribute]
internal void set_ImmutabilityPolicy(BlobImmutabilityPolicy value);
    [CompilerGeneratedAttribute]
public bool get_HasLegalHold();
    [CompilerGeneratedAttribute]
internal void set_HasLegalHold(bool value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(DateTimeOffset value);
}
public class Azure.Storage.Blobs.Models.BlobDownloadInfo : object {
    [CompilerGeneratedAttribute]
private BlobType <BlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobDownloadDetails <Details>k__BackingField;
    [EditorBrowsableAttribute("1")]
public BlobType BlobType { get; internal set; }
    [EditorBrowsableAttribute("1")]
public long ContentLength { get; internal set; }
    public Stream Content { get; internal set; }
    [EditorBrowsableAttribute("1")]
public string ContentType { get; internal set; }
    [EditorBrowsableAttribute("1")]
public Byte[] ContentHash { get; internal set; }
    public BlobDownloadDetails Details { get; internal set; }
    [CompilerGeneratedAttribute]
public BlobType get_BlobType();
    [CompilerGeneratedAttribute]
internal void set_BlobType(BlobType value);
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
internal void set_ContentLength(long value);
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_Content();
    [CompilerGeneratedAttribute]
internal void set_Content(Stream value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public BlobDownloadDetails get_Details();
    [CompilerGeneratedAttribute]
internal void set_Details(BlobDownloadDetails value);
    public sealed virtual void Dispose();
}
public class Azure.Storage.Blobs.Models.BlobDownloadOptions : object {
    [CompilerGeneratedAttribute]
private HttpRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private DownloadTransferValidationOptions <TransferValidation>k__BackingField;
    public HttpRange Range { get; public set; }
    public BlobRequestConditions Conditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public DownloadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public HttpRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(HttpRange value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public DownloadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(DownloadTransferValidationOptions value);
}
public class Azure.Storage.Blobs.Models.BlobDownloadResult : object {
    [CompilerGeneratedAttribute]
private BlobDownloadDetails <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryData <Content>k__BackingField;
    public BlobDownloadDetails Details { get; internal set; }
    public BinaryData Content { get; internal set; }
    [CompilerGeneratedAttribute]
public BlobDownloadDetails get_Details();
    [CompilerGeneratedAttribute]
internal void set_Details(BlobDownloadDetails value);
    [CompilerGeneratedAttribute]
public BinaryData get_Content();
    [CompilerGeneratedAttribute]
internal void set_Content(BinaryData value);
}
public class Azure.Storage.Blobs.Models.BlobDownloadStreamingResult : object {
    [CompilerGeneratedAttribute]
private BlobDownloadDetails <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Content>k__BackingField;
    public BlobDownloadDetails Details { get; internal set; }
    public Stream Content { get; internal set; }
    [CompilerGeneratedAttribute]
public BlobDownloadDetails get_Details();
    [CompilerGeneratedAttribute]
internal void set_Details(BlobDownloadDetails value);
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_Content();
    [CompilerGeneratedAttribute]
internal void set_Content(Stream value);
    public sealed virtual void Dispose();
}
public class Azure.Storage.Blobs.Models.BlobDownloadToOptions : object {
    [CompilerGeneratedAttribute]
private BlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageTransferOptions <TransferOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private DownloadTransferValidationOptions <TransferValidation>k__BackingField;
    public BlobRequestConditions Conditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public StorageTransferOptions TransferOptions { get; public set; }
    public DownloadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public StorageTransferOptions get_TransferOptions();
    [CompilerGeneratedAttribute]
public void set_TransferOptions(StorageTransferOptions value);
    [CompilerGeneratedAttribute]
public DownloadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(DownloadTransferValidationOptions value);
}
[IsReadOnlyAttribute]
[CodeGenModelAttribute("ErrorCode")]
public class Azure.Storage.Blobs.Models.BlobErrorCode : ValueType {
    private string _value;
    private static string AccountAlreadyExistsValue;
    private static string AccountBeingCreatedValue;
    private static string AccountIsDisabledValue;
    private static string AuthenticationFailedValue;
    private static string AuthorizationFailureValue;
    private static string ConditionHeadersNotSupportedValue;
    private static string ConditionNotMetValue;
    private static string EmptyMetadataKeyValue;
    private static string InsufficientAccountPermissionsValue;
    private static string InternalErrorValue;
    private static string InvalidAuthenticationInfoValue;
    private static string InvalidHeaderValueValue;
    private static string InvalidHttpVerbValue;
    private static string InvalidInputValue;
    private static string InvalidMd5Value;
    private static string InvalidMetadataValue;
    private static string InvalidQueryParameterValueValue;
    private static string InvalidRangeValue;
    private static string InvalidResourceNameValue;
    private static string InvalidUriValue;
    private static string InvalidXmlDocumentValue;
    private static string InvalidXmlNodeValueValue;
    private static string Md5MismatchValue;
    private static string MetadataTooLargeValue;
    private static string MissingContentLengthHeaderValue;
    private static string MissingRequiredQueryParameterValue;
    private static string MissingRequiredHeaderValue;
    private static string MissingRequiredXmlNodeValue;
    private static string MultipleConditionHeadersNotSupportedValue;
    private static string OperationTimedOutValue;
    private static string OutOfRangeInputValue;
    private static string OutOfRangeQueryParameterValueValue;
    private static string RequestBodyTooLargeValue;
    private static string ResourceTypeMismatchValue;
    private static string RequestUrlFailedToParseValue;
    private static string ResourceAlreadyExistsValue;
    private static string ResourceNotFoundValue;
    private static string ServerBusyValue;
    private static string UnsupportedHeaderValue;
    private static string UnsupportedXmlNodeValue;
    private static string UnsupportedQueryParameterValue;
    private static string UnsupportedHttpVerbValue;
    private static string AppendPositionConditionNotMetValue;
    private static string BlobAlreadyExistsValue;
    private static string BlobImmutableDueToPolicyValue;
    private static string BlobNotFoundValue;
    private static string BlobOverwrittenValue;
    private static string BlobTierInadequateForContentLengthValue;
    private static string BlobUsesCustomerSpecifiedEncryptionValue;
    private static string BlockCountExceedsLimitValue;
    private static string BlockListTooLongValue;
    private static string CannotChangeToLowerTierValue;
    private static string CannotVerifyCopySourceValue;
    private static string ContainerAlreadyExistsValue;
    private static string ContainerBeingDeletedValue;
    private static string ContainerDisabledValue;
    private static string ContainerNotFoundValue;
    private static string ContentLengthLargerThanTierLimitValue;
    private static string CopyAcrossAccountsNotSupportedValue;
    private static string CopyIdMismatchValue;
    private static string FeatureVersionMismatchValue;
    private static string IncrementalCopyBlobMismatchValue;
    private static string IncrementalCopyOfEarlierVersionSnapshotNotAllowedValue;
    private static string IncrementalCopySourceMustBeSnapshotValue;
    private static string InfiniteLeaseDurationRequiredValue;
    private static string InvalidBlobOrBlockValue;
    private static string InvalidBlobTierValue;
    private static string InvalidBlobTypeValue;
    private static string InvalidBlockIdValue;
    private static string InvalidBlockListValue;
    private static string InvalidOperationValue;
    private static string InvalidPageRangeValue;
    private static string InvalidSourceBlobTypeValue;
    private static string InvalidSourceBlobUrlValue;
    private static string InvalidVersionForPageBlobOperationValue;
    private static string LeaseAlreadyPresentValue;
    private static string LeaseAlreadyBrokenValue;
    private static string LeaseIdMismatchWithBlobOperationValue;
    private static string LeaseIdMismatchWithContainerOperationValue;
    private static string LeaseIdMismatchWithLeaseOperationValue;
    private static string LeaseIdMissingValue;
    private static string LeaseIsBreakingAndCannotBeAcquiredValue;
    private static string LeaseIsBreakingAndCannotBeChangedValue;
    private static string LeaseIsBrokenAndCannotBeRenewedValue;
    private static string LeaseLostValue;
    private static string LeaseNotPresentWithBlobOperationValue;
    private static string LeaseNotPresentWithContainerOperationValue;
    private static string LeaseNotPresentWithLeaseOperationValue;
    private static string MaxBlobSizeConditionNotMetValue;
    private static string NoAuthenticationInformationValue;
    private static string NoPendingCopyOperationValue;
    private static string OperationNotAllowedOnIncrementalCopyBlobValue;
    private static string PendingCopyOperationValue;
    private static string PreviousSnapshotCannotBeNewerValue;
    private static string PreviousSnapshotNotFoundValue;
    private static string PreviousSnapshotOperationNotSupportedValue;
    private static string SequenceNumberConditionNotMetValue;
    private static string SequenceNumberIncrementTooLargeValue;
    private static string SnapshotCountExceededValue;
    private static string SnapshotOperationRateExceededValue;
    private static string SnapshotsPresentValue;
    private static string SourceConditionNotMetValue;
    private static string SystemInUseValue;
    private static string TargetConditionNotMetValue;
    private static string UnauthorizedBlobOverwriteValue;
    private static string BlobBeingRehydratedValue;
    private static string BlobArchivedValue;
    private static string BlobNotArchivedValue;
    private static string AuthorizationSourceIPMismatchValue;
    private static string AuthorizationProtocolMismatchValue;
    private static string AuthorizationPermissionMismatchValue;
    private static string AuthorizationServiceMismatchValue;
    private static string AuthorizationResourceTypeMismatchValue;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AccountAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AccountBeingCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AccountIsDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AuthenticationFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AuthorizationFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ConditionHeadersNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ConditionNotMet>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <EmptyMetadataKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InsufficientAccountPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InternalError>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidAuthenticationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidHeaderValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidHttpVerb>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidInput>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidMd5>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidQueryParameterValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidRange>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidUri>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidXmlDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidXmlNodeValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <Md5Mismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <MetadataTooLarge>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <MissingContentLengthHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <MissingRequiredQueryParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <MissingRequiredHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <MissingRequiredXmlNode>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <MultipleConditionHeadersNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <OperationTimedOut>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <OutOfRangeInput>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <OutOfRangeQueryParameterValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <RequestBodyTooLarge>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ResourceTypeMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <RequestUrlFailedToParse>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ResourceAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ResourceNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ServerBusy>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <UnsupportedHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <UnsupportedXmlNode>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <UnsupportedQueryParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <UnsupportedHttpVerb>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AppendPositionConditionNotMet>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlobAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlobImmutableDueToPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlobNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlobOverwritten>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlobTierInadequateForContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlobUsesCustomerSpecifiedEncryption>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlockCountExceedsLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlockListTooLong>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <CannotChangeToLowerTier>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <CannotVerifyCopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ContainerAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ContainerBeingDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ContainerDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ContainerNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <ContentLengthLargerThanTierLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <CopyAcrossAccountsNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <CopyIdMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <FeatureVersionMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <IncrementalCopyBlobMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <IncrementalCopyOfEarlierVersionSnapshotNotAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <IncrementalCopySourceMustBeSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InfiniteLeaseDurationRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidBlobOrBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidBlobTier>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidBlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidBlockId>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidBlockList>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidPageRange>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidSourceBlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidSourceBlobUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <InvalidVersionForPageBlobOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseAlreadyPresent>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseAlreadyBroken>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseIdMismatchWithBlobOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseIdMismatchWithContainerOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseIdMismatchWithLeaseOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseIdMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseIsBreakingAndCannotBeAcquired>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseIsBreakingAndCannotBeChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseIsBrokenAndCannotBeRenewed>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseLost>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseNotPresentWithBlobOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseNotPresentWithContainerOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <LeaseNotPresentWithLeaseOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <MaxBlobSizeConditionNotMet>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <NoAuthenticationInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <NoPendingCopyOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <OperationNotAllowedOnIncrementalCopyBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <PendingCopyOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <PreviousSnapshotCannotBeNewer>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <PreviousSnapshotNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <PreviousSnapshotOperationNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <SequenceNumberConditionNotMet>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <SequenceNumberIncrementTooLarge>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <SnapshotCountExceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <SnapshotOperationRateExceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <SnapshotsPresent>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <SourceConditionNotMet>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <SystemInUse>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <TargetConditionNotMet>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <UnauthorizedBlobOverwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlobBeingRehydrated>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlobArchived>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <BlobNotArchived>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AuthorizationSourceIPMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AuthorizationProtocolMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AuthorizationPermissionMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AuthorizationServiceMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <AuthorizationResourceTypeMismatch>k__BackingField;
    private static string SnaphotOperationRateExceededValue;
    private static string IncrementalCopyOfEralierVersionSnapshotNotAllowedValue;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <SnaphotOperationRateExceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobErrorCode <IncrementalCopyOfEralierVersionSnapshotNotAllowed>k__BackingField;
    public static BlobErrorCode AccountAlreadyExists { get; }
    public static BlobErrorCode AccountBeingCreated { get; }
    public static BlobErrorCode AccountIsDisabled { get; }
    public static BlobErrorCode AuthenticationFailed { get; }
    public static BlobErrorCode AuthorizationFailure { get; }
    public static BlobErrorCode ConditionHeadersNotSupported { get; }
    public static BlobErrorCode ConditionNotMet { get; }
    public static BlobErrorCode EmptyMetadataKey { get; }
    public static BlobErrorCode InsufficientAccountPermissions { get; }
    public static BlobErrorCode InternalError { get; }
    public static BlobErrorCode InvalidAuthenticationInfo { get; }
    public static BlobErrorCode InvalidHeaderValue { get; }
    public static BlobErrorCode InvalidHttpVerb { get; }
    public static BlobErrorCode InvalidInput { get; }
    public static BlobErrorCode InvalidMd5 { get; }
    public static BlobErrorCode InvalidMetadata { get; }
    public static BlobErrorCode InvalidQueryParameterValue { get; }
    public static BlobErrorCode InvalidRange { get; }
    public static BlobErrorCode InvalidResourceName { get; }
    public static BlobErrorCode InvalidUri { get; }
    public static BlobErrorCode InvalidXmlDocument { get; }
    public static BlobErrorCode InvalidXmlNodeValue { get; }
    public static BlobErrorCode Md5Mismatch { get; }
    public static BlobErrorCode MetadataTooLarge { get; }
    public static BlobErrorCode MissingContentLengthHeader { get; }
    public static BlobErrorCode MissingRequiredQueryParameter { get; }
    public static BlobErrorCode MissingRequiredHeader { get; }
    public static BlobErrorCode MissingRequiredXmlNode { get; }
    public static BlobErrorCode MultipleConditionHeadersNotSupported { get; }
    public static BlobErrorCode OperationTimedOut { get; }
    public static BlobErrorCode OutOfRangeInput { get; }
    public static BlobErrorCode OutOfRangeQueryParameterValue { get; }
    public static BlobErrorCode RequestBodyTooLarge { get; }
    public static BlobErrorCode ResourceTypeMismatch { get; }
    public static BlobErrorCode RequestUrlFailedToParse { get; }
    public static BlobErrorCode ResourceAlreadyExists { get; }
    public static BlobErrorCode ResourceNotFound { get; }
    public static BlobErrorCode ServerBusy { get; }
    public static BlobErrorCode UnsupportedHeader { get; }
    public static BlobErrorCode UnsupportedXmlNode { get; }
    public static BlobErrorCode UnsupportedQueryParameter { get; }
    public static BlobErrorCode UnsupportedHttpVerb { get; }
    public static BlobErrorCode AppendPositionConditionNotMet { get; }
    public static BlobErrorCode BlobAlreadyExists { get; }
    public static BlobErrorCode BlobImmutableDueToPolicy { get; }
    public static BlobErrorCode BlobNotFound { get; }
    public static BlobErrorCode BlobOverwritten { get; }
    public static BlobErrorCode BlobTierInadequateForContentLength { get; }
    public static BlobErrorCode BlobUsesCustomerSpecifiedEncryption { get; }
    public static BlobErrorCode BlockCountExceedsLimit { get; }
    public static BlobErrorCode BlockListTooLong { get; }
    public static BlobErrorCode CannotChangeToLowerTier { get; }
    public static BlobErrorCode CannotVerifyCopySource { get; }
    public static BlobErrorCode ContainerAlreadyExists { get; }
    public static BlobErrorCode ContainerBeingDeleted { get; }
    public static BlobErrorCode ContainerDisabled { get; }
    public static BlobErrorCode ContainerNotFound { get; }
    public static BlobErrorCode ContentLengthLargerThanTierLimit { get; }
    public static BlobErrorCode CopyAcrossAccountsNotSupported { get; }
    public static BlobErrorCode CopyIdMismatch { get; }
    public static BlobErrorCode FeatureVersionMismatch { get; }
    public static BlobErrorCode IncrementalCopyBlobMismatch { get; }
    public static BlobErrorCode IncrementalCopyOfEarlierVersionSnapshotNotAllowed { get; }
    public static BlobErrorCode IncrementalCopySourceMustBeSnapshot { get; }
    public static BlobErrorCode InfiniteLeaseDurationRequired { get; }
    public static BlobErrorCode InvalidBlobOrBlock { get; }
    public static BlobErrorCode InvalidBlobTier { get; }
    public static BlobErrorCode InvalidBlobType { get; }
    public static BlobErrorCode InvalidBlockId { get; }
    public static BlobErrorCode InvalidBlockList { get; }
    public static BlobErrorCode InvalidOperation { get; }
    public static BlobErrorCode InvalidPageRange { get; }
    public static BlobErrorCode InvalidSourceBlobType { get; }
    public static BlobErrorCode InvalidSourceBlobUrl { get; }
    public static BlobErrorCode InvalidVersionForPageBlobOperation { get; }
    public static BlobErrorCode LeaseAlreadyPresent { get; }
    public static BlobErrorCode LeaseAlreadyBroken { get; }
    public static BlobErrorCode LeaseIdMismatchWithBlobOperation { get; }
    public static BlobErrorCode LeaseIdMismatchWithContainerOperation { get; }
    public static BlobErrorCode LeaseIdMismatchWithLeaseOperation { get; }
    public static BlobErrorCode LeaseIdMissing { get; }
    public static BlobErrorCode LeaseIsBreakingAndCannotBeAcquired { get; }
    public static BlobErrorCode LeaseIsBreakingAndCannotBeChanged { get; }
    public static BlobErrorCode LeaseIsBrokenAndCannotBeRenewed { get; }
    public static BlobErrorCode LeaseLost { get; }
    public static BlobErrorCode LeaseNotPresentWithBlobOperation { get; }
    public static BlobErrorCode LeaseNotPresentWithContainerOperation { get; }
    public static BlobErrorCode LeaseNotPresentWithLeaseOperation { get; }
    public static BlobErrorCode MaxBlobSizeConditionNotMet { get; }
    public static BlobErrorCode NoAuthenticationInformation { get; }
    public static BlobErrorCode NoPendingCopyOperation { get; }
    public static BlobErrorCode OperationNotAllowedOnIncrementalCopyBlob { get; }
    public static BlobErrorCode PendingCopyOperation { get; }
    public static BlobErrorCode PreviousSnapshotCannotBeNewer { get; }
    public static BlobErrorCode PreviousSnapshotNotFound { get; }
    public static BlobErrorCode PreviousSnapshotOperationNotSupported { get; }
    public static BlobErrorCode SequenceNumberConditionNotMet { get; }
    public static BlobErrorCode SequenceNumberIncrementTooLarge { get; }
    public static BlobErrorCode SnapshotCountExceeded { get; }
    public static BlobErrorCode SnapshotOperationRateExceeded { get; }
    public static BlobErrorCode SnapshotsPresent { get; }
    public static BlobErrorCode SourceConditionNotMet { get; }
    public static BlobErrorCode SystemInUse { get; }
    public static BlobErrorCode TargetConditionNotMet { get; }
    public static BlobErrorCode UnauthorizedBlobOverwrite { get; }
    public static BlobErrorCode BlobBeingRehydrated { get; }
    public static BlobErrorCode BlobArchived { get; }
    public static BlobErrorCode BlobNotArchived { get; }
    public static BlobErrorCode AuthorizationSourceIPMismatch { get; }
    public static BlobErrorCode AuthorizationProtocolMismatch { get; }
    public static BlobErrorCode AuthorizationPermissionMismatch { get; }
    public static BlobErrorCode AuthorizationServiceMismatch { get; }
    public static BlobErrorCode AuthorizationResourceTypeMismatch { get; }
    [EditorBrowsableAttribute("1")]
public static BlobErrorCode SnaphotOperationRateExceeded { get; }
    [EditorBrowsableAttribute("1")]
public static BlobErrorCode IncrementalCopyOfEralierVersionSnapshotNotAllowed { get; }
    public BlobErrorCode(string value);
    private static BlobErrorCode();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AccountAlreadyExists();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AccountBeingCreated();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AccountIsDisabled();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AuthenticationFailed();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AuthorizationFailure();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ConditionHeadersNotSupported();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ConditionNotMet();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_EmptyMetadataKey();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InsufficientAccountPermissions();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InternalError();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidAuthenticationInfo();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidHeaderValue();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidHttpVerb();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidInput();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidMd5();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidMetadata();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidQueryParameterValue();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidRange();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidResourceName();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidUri();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidXmlDocument();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidXmlNodeValue();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_Md5Mismatch();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_MetadataTooLarge();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_MissingContentLengthHeader();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_MissingRequiredQueryParameter();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_MissingRequiredHeader();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_MissingRequiredXmlNode();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_MultipleConditionHeadersNotSupported();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_OperationTimedOut();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_OutOfRangeInput();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_OutOfRangeQueryParameterValue();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_RequestBodyTooLarge();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ResourceTypeMismatch();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_RequestUrlFailedToParse();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ResourceAlreadyExists();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ResourceNotFound();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ServerBusy();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_UnsupportedHeader();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_UnsupportedXmlNode();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_UnsupportedQueryParameter();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_UnsupportedHttpVerb();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AppendPositionConditionNotMet();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlobAlreadyExists();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlobImmutableDueToPolicy();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlobNotFound();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlobOverwritten();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlobTierInadequateForContentLength();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlobUsesCustomerSpecifiedEncryption();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlockCountExceedsLimit();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlockListTooLong();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_CannotChangeToLowerTier();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_CannotVerifyCopySource();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ContainerAlreadyExists();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ContainerBeingDeleted();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ContainerDisabled();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ContainerNotFound();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_ContentLengthLargerThanTierLimit();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_CopyAcrossAccountsNotSupported();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_CopyIdMismatch();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_FeatureVersionMismatch();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_IncrementalCopyBlobMismatch();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_IncrementalCopyOfEarlierVersionSnapshotNotAllowed();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_IncrementalCopySourceMustBeSnapshot();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InfiniteLeaseDurationRequired();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidBlobOrBlock();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidBlobTier();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidBlobType();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidBlockId();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidBlockList();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidPageRange();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidSourceBlobType();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidSourceBlobUrl();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_InvalidVersionForPageBlobOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseAlreadyPresent();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseAlreadyBroken();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseIdMismatchWithBlobOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseIdMismatchWithContainerOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseIdMismatchWithLeaseOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseIdMissing();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseIsBreakingAndCannotBeAcquired();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseIsBreakingAndCannotBeChanged();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseIsBrokenAndCannotBeRenewed();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseLost();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseNotPresentWithBlobOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseNotPresentWithContainerOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_LeaseNotPresentWithLeaseOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_MaxBlobSizeConditionNotMet();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_NoAuthenticationInformation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_NoPendingCopyOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_OperationNotAllowedOnIncrementalCopyBlob();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_PendingCopyOperation();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_PreviousSnapshotCannotBeNewer();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_PreviousSnapshotNotFound();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_PreviousSnapshotOperationNotSupported();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_SequenceNumberConditionNotMet();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_SequenceNumberIncrementTooLarge();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_SnapshotCountExceeded();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_SnapshotOperationRateExceeded();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_SnapshotsPresent();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_SourceConditionNotMet();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_SystemInUse();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_TargetConditionNotMet();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_UnauthorizedBlobOverwrite();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlobBeingRehydrated();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlobArchived();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_BlobNotArchived();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AuthorizationSourceIPMismatch();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AuthorizationProtocolMismatch();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AuthorizationPermissionMismatch();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AuthorizationServiceMismatch();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_AuthorizationResourceTypeMismatch();
    public static bool op_Equality(BlobErrorCode left, BlobErrorCode right);
    public static bool op_Inequality(BlobErrorCode left, BlobErrorCode right);
    public static BlobErrorCode op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BlobErrorCode other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_SnaphotOperationRateExceeded();
    [CompilerGeneratedAttribute]
public static BlobErrorCode get_IncrementalCopyOfEralierVersionSnapshotNotAllowed();
}
[IsReadOnlyAttribute]
internal class Azure.Storage.Blobs.Models.BlobExpiryOptions : ValueType {
    private string _value;
    private static string NeverExpireValue;
    private static string RelativeToCreationValue;
    private static string RelativeToNowValue;
    private static string AbsoluteValue;
    [CompilerGeneratedAttribute]
private static BlobExpiryOptions <NeverExpire>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobExpiryOptions <RelativeToCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobExpiryOptions <RelativeToNow>k__BackingField;
    [CompilerGeneratedAttribute]
private static BlobExpiryOptions <Absolute>k__BackingField;
    public static BlobExpiryOptions NeverExpire { get; }
    public static BlobExpiryOptions RelativeToCreation { get; }
    public static BlobExpiryOptions RelativeToNow { get; }
    public static BlobExpiryOptions Absolute { get; }
    public BlobExpiryOptions(string value);
    private static BlobExpiryOptions();
    [CompilerGeneratedAttribute]
public static BlobExpiryOptions get_NeverExpire();
    [CompilerGeneratedAttribute]
public static BlobExpiryOptions get_RelativeToCreation();
    [CompilerGeneratedAttribute]
public static BlobExpiryOptions get_RelativeToNow();
    [CompilerGeneratedAttribute]
public static BlobExpiryOptions get_Absolute();
    public static bool op_Equality(BlobExpiryOptions left, BlobExpiryOptions right);
    public static bool op_Inequality(BlobExpiryOptions left, BlobExpiryOptions right);
    public static BlobExpiryOptions op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BlobExpiryOptions other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Azure.Storage.Blobs.Models.BlobFlatListSegment : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<BlobItemInternal> <BlobItems>k__BackingField;
    public IReadOnlyList`1<BlobItemInternal> BlobItems { get; }
    internal BlobFlatListSegment(IEnumerable`1<BlobItemInternal> blobItems);
    internal BlobFlatListSegment(IReadOnlyList`1<BlobItemInternal> blobItems);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<BlobItemInternal> get_BlobItems();
    internal static BlobFlatListSegment DeserializeBlobFlatListSegment(XElement element);
}
[CodeGenModelAttribute("GeoReplication")]
public class Azure.Storage.Blobs.Models.BlobGeoReplication : object {
    [CompilerGeneratedAttribute]
private BlobGeoReplicationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastSyncedOn>k__BackingField;
    public BlobGeoReplicationStatus Status { get; }
    [CodeGenMemberAttribute("LastSyncTime")]
public Nullable`1<DateTimeOffset> LastSyncedOn { get; internal set; }
    internal BlobGeoReplication(BlobGeoReplicationStatus status, Nullable`1<DateTimeOffset> lastSyncedOn);
    [CompilerGeneratedAttribute]
public BlobGeoReplicationStatus get_Status();
    internal static BlobGeoReplication DeserializeBlobGeoReplication(XElement element);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastSyncedOn();
    [CompilerGeneratedAttribute]
internal void set_LastSyncedOn(Nullable`1<DateTimeOffset> value);
}
public enum Azure.Storage.Blobs.Models.BlobGeoReplicationStatus : Enum {
    public int value__;
    public static BlobGeoReplicationStatus Live;
    public static BlobGeoReplicationStatus Bootstrap;
    public static BlobGeoReplicationStatus Unavailable;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.BlobGeoReplicationStatusExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(BlobGeoReplicationStatus value);
    [ExtensionAttribute]
public static BlobGeoReplicationStatus ToBlobGeoReplicationStatus(string value);
}
public class Azure.Storage.Blobs.Models.BlobHierarchyItem : object {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobItem <Blob>k__BackingField;
    public string Prefix { get; internal set; }
    public BlobItem Blob { get; internal set; }
    public bool IsPrefix { get; }
    public bool IsBlob { get; }
    internal BlobHierarchyItem(string prefix, BlobItem blob);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
internal void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public BlobItem get_Blob();
    [CompilerGeneratedAttribute]
internal void set_Blob(BlobItem value);
    public bool get_IsPrefix();
    public bool get_IsBlob();
}
internal class Azure.Storage.Blobs.Models.BlobHierarchyListSegment : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<BlobPrefix> <BlobPrefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<BlobItemInternal> <BlobItems>k__BackingField;
    public IReadOnlyList`1<BlobPrefix> BlobPrefixes { get; }
    public IReadOnlyList`1<BlobItemInternal> BlobItems { get; }
    internal BlobHierarchyListSegment(IEnumerable`1<BlobItemInternal> blobItems);
    internal BlobHierarchyListSegment(IReadOnlyList`1<BlobPrefix> blobPrefixes, IReadOnlyList`1<BlobItemInternal> blobItems);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<BlobPrefix> get_BlobPrefixes();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<BlobItemInternal> get_BlobItems();
    internal static BlobHierarchyListSegment DeserializeBlobHierarchyListSegment(XElement element);
}
public class Azure.Storage.Blobs.Models.BlobHttpHeaders : object {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    public string ContentType { get; public set; }
    public Byte[] ContentHash { get; public set; }
    public string ContentEncoding { get; public set; }
    public string ContentLanguage { get; public set; }
    public string ContentDisposition { get; public set; }
    public string CacheControl { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
public void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public void set_CacheControl(string value);
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
public class Azure.Storage.Blobs.Models.BlobImmutabilityPolicy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BlobImmutabilityPolicyMode> <PolicyMode>k__BackingField;
    public Nullable`1<DateTimeOffset> ExpiresOn { get; public set; }
    public Nullable`1<BlobImmutabilityPolicyMode> PolicyMode { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<BlobImmutabilityPolicyMode> get_PolicyMode();
    [CompilerGeneratedAttribute]
public void set_PolicyMode(Nullable`1<BlobImmutabilityPolicyMode> value);
}
public enum Azure.Storage.Blobs.Models.BlobImmutabilityPolicyMode : Enum {
    public int value__;
    public static BlobImmutabilityPolicyMode Mutable;
    public static BlobImmutabilityPolicyMode Unlocked;
    public static BlobImmutabilityPolicyMode Locked;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.BlobImmutabilityPolicyModeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(BlobImmutabilityPolicyMode value);
    [ExtensionAttribute]
public static BlobImmutabilityPolicyMode ToBlobImmutabilityPolicyMode(string value);
}
public class Azure.Storage.Blobs.Models.BlobInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlobSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public long BlobSequenceNumber { get; internal set; }
    public string VersionId { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public long get_BlobSequenceNumber();
    [CompilerGeneratedAttribute]
internal void set_BlobSequenceNumber(long value);
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
internal void set_VersionId(string value);
}
public class Azure.Storage.Blobs.Models.BlobItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsLatestVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobItemProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ObjectReplicationPolicy> <ObjectReplicationSourceProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasVersionsOnly>k__BackingField;
    public string Name { get; internal set; }
    public bool Deleted { get; internal set; }
    public string Snapshot { get; internal set; }
    public string VersionId { get; internal set; }
    public Nullable`1<bool> IsLatestVersion { get; internal set; }
    public BlobItemProperties Properties { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public IDictionary`2<string, string> Tags { get; internal set; }
    public IList`1<ObjectReplicationPolicy> ObjectReplicationSourceProperties { get; internal set; }
    public Nullable`1<bool> HasVersionsOnly { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Deleted();
    [CompilerGeneratedAttribute]
internal void set_Deleted(bool value);
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
internal void set_Snapshot(string value);
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
internal void set_VersionId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsLatestVersion();
    [CompilerGeneratedAttribute]
internal void set_IsLatestVersion(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public BlobItemProperties get_Properties();
    [CompilerGeneratedAttribute]
internal void set_Properties(BlobItemProperties value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IList`1<ObjectReplicationPolicy> get_ObjectReplicationSourceProperties();
    [CompilerGeneratedAttribute]
internal void set_ObjectReplicationSourceProperties(IList`1<ObjectReplicationPolicy> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HasVersionsOnly();
    [CompilerGeneratedAttribute]
internal void set_HasVersionsOnly(Nullable`1<bool> value);
}
internal class Azure.Storage.Blobs.Models.BlobItemInternal : object {
    [CompilerGeneratedAttribute]
private BlobName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsCurrentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobPropertiesInternal <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobTags <BlobTags>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasVersionsOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <OrMetadata>k__BackingField;
    public BlobName Name { get; }
    public bool Deleted { get; }
    public string Snapshot { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsCurrentVersion { get; }
    public BlobPropertiesInternal Properties { get; }
    public IReadOnlyDictionary`2<string, string> Metadata { get; }
    public BlobTags BlobTags { get; }
    public Nullable`1<bool> HasVersionsOnly { get; }
    public IReadOnlyDictionary`2<string, string> OrMetadata { get; }
    internal BlobItemInternal(BlobName name, bool deleted, string snapshot, BlobPropertiesInternal properties);
    internal BlobItemInternal(BlobName name, bool deleted, string snapshot, string versionId, Nullable`1<bool> isCurrentVersion, BlobPropertiesInternal properties, IReadOnlyDictionary`2<string, string> metadata, BlobTags blobTags, Nullable`1<bool> hasVersionsOnly, IReadOnlyDictionary`2<string, string> orMetadata);
    [CompilerGeneratedAttribute]
public BlobName get_Name();
    [CompilerGeneratedAttribute]
public bool get_Deleted();
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsCurrentVersion();
    [CompilerGeneratedAttribute]
public BlobPropertiesInternal get_Properties();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public BlobTags get_BlobTags();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HasVersionsOnly();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_OrMetadata();
    internal static BlobItemInternal DeserializeBlobItemInternal(XElement element);
}
public class Azure.Storage.Blobs.Models.BlobItemProperties : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BlobSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BlobType> <BlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseStatus> <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseState> <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseDurationType> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CopyStatus> <CopyStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyStatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncrementalCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RemainingRetentionDays>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AccessTier> <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AccessTierInferred>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchiveStatus> <ArchiveStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomerProvidedKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <TagCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsSealed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RehydratePriority> <RehydratePriority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastAccessedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ETag> <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CopyCompletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <AccessTierChangedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLegalHold>k__BackingField;
    public Nullable`1<DateTimeOffset> LastModified { get; internal set; }
    public Nullable`1<long> ContentLength { get; internal set; }
    public string ContentType { get; internal set; }
    public string ContentEncoding { get; internal set; }
    public string ContentLanguage { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public string ContentDisposition { get; internal set; }
    public string CacheControl { get; internal set; }
    public Nullable`1<long> BlobSequenceNumber { get; internal set; }
    public Nullable`1<BlobType> BlobType { get; internal set; }
    public Nullable`1<LeaseStatus> LeaseStatus { get; internal set; }
    public Nullable`1<LeaseState> LeaseState { get; internal set; }
    public Nullable`1<LeaseDurationType> LeaseDuration { get; internal set; }
    public string CopyId { get; internal set; }
    public Nullable`1<CopyStatus> CopyStatus { get; internal set; }
    public Uri CopySource { get; internal set; }
    public string CopyProgress { get; internal set; }
    public string CopyStatusDescription { get; internal set; }
    public Nullable`1<bool> ServerEncrypted { get; internal set; }
    public Nullable`1<bool> IncrementalCopy { get; internal set; }
    public string DestinationSnapshot { get; internal set; }
    public Nullable`1<int> RemainingRetentionDays { get; internal set; }
    public Nullable`1<AccessTier> AccessTier { get; internal set; }
    public bool AccessTierInferred { get; internal set; }
    public Nullable`1<ArchiveStatus> ArchiveStatus { get; internal set; }
    public string CustomerProvidedKeySha256 { get; internal set; }
    public string EncryptionScope { get; internal set; }
    public Nullable`1<long> TagCount { get; internal set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; internal set; }
    public Nullable`1<bool> IsSealed { get; internal set; }
    public Nullable`1<RehydratePriority> RehydratePriority { get; internal set; }
    public Nullable`1<DateTimeOffset> LastAccessedOn { get; internal set; }
    public Nullable`1<ETag> ETag { get; internal set; }
    public Nullable`1<DateTimeOffset> CreatedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> CopyCompletedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> DeletedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> AccessTierChangedOn { get; internal set; }
    public BlobImmutabilityPolicy ImmutabilityPolicy { get; internal set; }
    public bool HasLegalHold { get; internal set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ContentLength();
    [CompilerGeneratedAttribute]
internal void set_ContentLength(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
internal void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
internal void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
internal void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
internal void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BlobSequenceNumber();
    [CompilerGeneratedAttribute]
internal void set_BlobSequenceNumber(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<BlobType> get_BlobType();
    [CompilerGeneratedAttribute]
internal void set_BlobType(Nullable`1<BlobType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseStatus> get_LeaseStatus();
    [CompilerGeneratedAttribute]
internal void set_LeaseStatus(Nullable`1<LeaseStatus> value);
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseState> get_LeaseState();
    [CompilerGeneratedAttribute]
internal void set_LeaseState(Nullable`1<LeaseState> value);
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseDurationType> get_LeaseDuration();
    [CompilerGeneratedAttribute]
internal void set_LeaseDuration(Nullable`1<LeaseDurationType> value);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
internal void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<CopyStatus> get_CopyStatus();
    [CompilerGeneratedAttribute]
internal void set_CopyStatus(Nullable`1<CopyStatus> value);
    [CompilerGeneratedAttribute]
public Uri get_CopySource();
    [CompilerGeneratedAttribute]
internal void set_CopySource(Uri value);
    [CompilerGeneratedAttribute]
public string get_CopyProgress();
    [CompilerGeneratedAttribute]
internal void set_CopyProgress(string value);
    [CompilerGeneratedAttribute]
public string get_CopyStatusDescription();
    [CompilerGeneratedAttribute]
internal void set_CopyStatusDescription(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_ServerEncrypted(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncrementalCopy();
    [CompilerGeneratedAttribute]
internal void set_IncrementalCopy(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_DestinationSnapshot();
    [CompilerGeneratedAttribute]
internal void set_DestinationSnapshot(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RemainingRetentionDays();
    [CompilerGeneratedAttribute]
internal void set_RemainingRetentionDays(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<AccessTier> get_AccessTier();
    [CompilerGeneratedAttribute]
internal void set_AccessTier(Nullable`1<AccessTier> value);
    [CompilerGeneratedAttribute]
public bool get_AccessTierInferred();
    [CompilerGeneratedAttribute]
internal void set_AccessTierInferred(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchiveStatus> get_ArchiveStatus();
    [CompilerGeneratedAttribute]
internal void set_ArchiveStatus(Nullable`1<ArchiveStatus> value);
    [CompilerGeneratedAttribute]
public string get_CustomerProvidedKeySha256();
    [CompilerGeneratedAttribute]
internal void set_CustomerProvidedKeySha256(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_TagCount();
    [CompilerGeneratedAttribute]
internal void set_TagCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSealed();
    [CompilerGeneratedAttribute]
internal void set_IsSealed(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<RehydratePriority> get_RehydratePriority();
    [CompilerGeneratedAttribute]
internal void set_RehydratePriority(Nullable`1<RehydratePriority> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastAccessedOn();
    [CompilerGeneratedAttribute]
internal void set_LastAccessedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ETag> get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(Nullable`1<ETag> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CopyCompletedOn();
    [CompilerGeneratedAttribute]
internal void set_CopyCompletedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedOn();
    [CompilerGeneratedAttribute]
internal void set_DeletedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_AccessTierChangedOn();
    [CompilerGeneratedAttribute]
internal void set_AccessTierChangedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public BlobImmutabilityPolicy get_ImmutabilityPolicy();
    [CompilerGeneratedAttribute]
internal void set_ImmutabilityPolicy(BlobImmutabilityPolicy value);
    [CompilerGeneratedAttribute]
public bool get_HasLegalHold();
    [CompilerGeneratedAttribute]
internal void set_HasLegalHold(bool value);
}
public class Azure.Storage.Blobs.Models.BlobLease : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LeaseTime>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public string LeaseId { get; internal set; }
    public Nullable`1<int> LeaseTime { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_LeaseId();
    [CompilerGeneratedAttribute]
internal void set_LeaseId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LeaseTime();
    [CompilerGeneratedAttribute]
internal void set_LeaseTime(Nullable`1<int> value);
}
public class Azure.Storage.Blobs.Models.BlobLeaseRequestConditions : RequestConditions {
    [CompilerGeneratedAttribute]
private string <TagConditions>k__BackingField;
    public string TagConditions { get; public set; }
    internal BlobLeaseRequestConditions(BlobLeaseRequestConditions deepCopySource);
    [CompilerGeneratedAttribute]
public string get_TagConditions();
    [CompilerGeneratedAttribute]
public void set_TagConditions(string value);
    internal static BlobLeaseRequestConditions CloneOrDefault(BlobLeaseRequestConditions deepCopySource);
}
public class Azure.Storage.Blobs.Models.BlobLegalHoldResult : object {
    [CompilerGeneratedAttribute]
private bool <HasLegalHold>k__BackingField;
    public bool HasLegalHold { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_HasLegalHold();
    [CompilerGeneratedAttribute]
internal void set_HasLegalHold(bool value);
}
[CodeGenModelAttribute("Metrics")]
public class Azure.Storage.Blobs.Models.BlobMetrics : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRetentionPolicy <RetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeApis>k__BackingField;
    public string Version { get; public set; }
    public bool Enabled { get; public set; }
    public BlobRetentionPolicy RetentionPolicy { get; public set; }
    [CodeGenMemberAttribute("IncludeAPIs")]
public Nullable`1<bool> IncludeApis { get; public set; }
    internal BlobMetrics(string version, bool enabled, Nullable`1<bool> includeApis, BlobRetentionPolicy retentionPolicy);
    internal BlobMetrics(bool skipInitialization);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public BlobRetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(BlobRetentionPolicy value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobMetrics DeserializeBlobMetrics(XElement element);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeApis();
    [CompilerGeneratedAttribute]
public void set_IncludeApis(Nullable`1<bool> value);
}
internal class Azure.Storage.Blobs.Models.BlobName : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Encoded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public Nullable`1<bool> Encoded { get; }
    public string Content { get; }
    internal BlobName(Nullable`1<bool> encoded, string content);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Encoded();
    [CompilerGeneratedAttribute]
public string get_Content();
    internal static BlobName DeserializeBlobName(XElement element);
}
public class Azure.Storage.Blobs.Models.BlobOpenReadOptions : object {
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private DownloadTransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowModifications>k__BackingField;
    public long Position { get; public set; }
    public Nullable`1<int> BufferSize { get; public set; }
    public BlobRequestConditions Conditions { get; public set; }
    public DownloadTransferValidationOptions TransferValidation { get; public set; }
    internal bool AllowModifications { get; }
    public BlobOpenReadOptions(bool allowModifications);
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public DownloadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(DownloadTransferValidationOptions value);
    [CompilerGeneratedAttribute]
internal bool get_AllowModifications();
}
public class Azure.Storage.Blobs.Models.BlobOpenWriteOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <OpenConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public Nullable`1<long> BufferSize { get; public set; }
    public BlobRequestConditions OpenConditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public BlobHttpHeaders HttpHeaders { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public IDictionary`2<string, string> Tags { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_OpenConditions();
    [CompilerGeneratedAttribute]
public void set_OpenConditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public BlobHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(BlobHttpHeaders value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.BlobOpenWriteOptionsExtensions : object {
    [ExtensionAttribute]
public static BlockBlobOpenWriteOptions ToBlockBlobOpenWriteOptions(BlobOpenWriteOptions options);
}
internal class Azure.Storage.Blobs.Models.BlobPrefix : object {
    [CompilerGeneratedAttribute]
private BlobName <Name>k__BackingField;
    public BlobName Name { get; }
    internal BlobPrefix(BlobName name);
    [CompilerGeneratedAttribute]
public BlobName get_Name();
    internal static BlobPrefix DeserializeBlobPrefix(XElement element);
}
public class Azure.Storage.Blobs.Models.BlobProperties : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObjectReplicationDestinationPolicyId>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ObjectReplicationPolicy> <ObjectReplicationSourceProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobType <BlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CopyCompletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyStatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CopyStatus> <BlobCopyStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIncrementalCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private LeaseDurationType <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private LeaseState <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private LeaseStatus <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlobSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AcceptRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlobCommittedBlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AccessTierInferred>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArchiveStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <AccessTierChangedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLatestVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TagCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSealed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RehydratePriority>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastAccessed>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLegalHold>k__BackingField;
    public DateTimeOffset LastModified { get; }
    public DateTimeOffset CreatedOn { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public string ObjectReplicationDestinationPolicyId { get; }
    public IList`1<ObjectReplicationPolicy> ObjectReplicationSourceProperties { get; }
    public BlobType BlobType { get; }
    public DateTimeOffset CopyCompletedOn { get; }
    public string CopyStatusDescription { get; }
    public string CopyId { get; }
    public string CopyProgress { get; }
    public Uri CopySource { get; }
    [EditorBrowsableAttribute("1")]
public CopyStatus CopyStatus { get; }
    public Nullable`1<CopyStatus> BlobCopyStatus { get; }
    public bool IsIncrementalCopy { get; }
    public string DestinationSnapshot { get; }
    public LeaseDurationType LeaseDuration { get; }
    public LeaseState LeaseState { get; }
    public LeaseStatus LeaseStatus { get; }
    public long ContentLength { get; }
    public string ContentType { get; }
    public ETag ETag { get; }
    public Byte[] ContentHash { get; }
    public string ContentEncoding { get; }
    public string ContentDisposition { get; }
    public string ContentLanguage { get; }
    public string CacheControl { get; }
    public long BlobSequenceNumber { get; }
    public string AcceptRanges { get; }
    public int BlobCommittedBlockCount { get; }
    public bool IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public string AccessTier { get; }
    public bool AccessTierInferred { get; }
    public string ArchiveStatus { get; }
    public DateTimeOffset AccessTierChangedOn { get; }
    public string VersionId { get; }
    public bool IsLatestVersion { get; }
    public long TagCount { get; }
    public DateTimeOffset ExpiresOn { get; }
    public bool IsSealed { get; }
    public string RehydratePriority { get; }
    public DateTimeOffset LastAccessed { get; }
    public BlobImmutabilityPolicy ImmutabilityPolicy { get; internal set; }
    public bool HasLegalHold { get; internal set; }
    internal BlobProperties(DateTimeOffset lastModified, DateTimeOffset createdOn, IDictionary`2<string, string> metadata, string objectReplicationDestinationPolicyId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, BlobType blobType, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, Nullable`1<CopyStatus> blobCopyStatus, bool isIncrementalCopy, string destinationSnapshot, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, string accessTier, bool accessTierInferred, string archiveStatus, DateTimeOffset accessTierChangedOn, string versionId, bool isLatestVersion, long tagCount, DateTimeOffset expiresOn, bool isSealed, string rehydratePriority, DateTimeOffset lastAccessed, BlobImmutabilityPolicy immutabilityPolicy, bool hasLegalHold);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreatedOn();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public string get_ObjectReplicationDestinationPolicyId();
    [CompilerGeneratedAttribute]
public IList`1<ObjectReplicationPolicy> get_ObjectReplicationSourceProperties();
    [CompilerGeneratedAttribute]
public BlobType get_BlobType();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CopyCompletedOn();
    [CompilerGeneratedAttribute]
public string get_CopyStatusDescription();
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
public string get_CopyProgress();
    [CompilerGeneratedAttribute]
public Uri get_CopySource();
    public CopyStatus get_CopyStatus();
    [CompilerGeneratedAttribute]
public Nullable`1<CopyStatus> get_BlobCopyStatus();
    [CompilerGeneratedAttribute]
public bool get_IsIncrementalCopy();
    [CompilerGeneratedAttribute]
public string get_DestinationSnapshot();
    [CompilerGeneratedAttribute]
public LeaseDurationType get_LeaseDuration();
    [CompilerGeneratedAttribute]
public LeaseState get_LeaseState();
    [CompilerGeneratedAttribute]
public LeaseStatus get_LeaseStatus();
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public long get_BlobSequenceNumber();
    [CompilerGeneratedAttribute]
public string get_AcceptRanges();
    [CompilerGeneratedAttribute]
public int get_BlobCommittedBlockCount();
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
public string get_EncryptionKeySha256();
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public string get_AccessTier();
    [CompilerGeneratedAttribute]
public bool get_AccessTierInferred();
    [CompilerGeneratedAttribute]
public string get_ArchiveStatus();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_AccessTierChangedOn();
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
public bool get_IsLatestVersion();
    [CompilerGeneratedAttribute]
public long get_TagCount();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public bool get_IsSealed();
    [CompilerGeneratedAttribute]
public string get_RehydratePriority();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastAccessed();
    [CompilerGeneratedAttribute]
public BlobImmutabilityPolicy get_ImmutabilityPolicy();
    [CompilerGeneratedAttribute]
internal void set_ImmutabilityPolicy(BlobImmutabilityPolicy value);
    [CompilerGeneratedAttribute]
public bool get_HasLegalHold();
    [CompilerGeneratedAttribute]
internal void set_HasLegalHold(bool value);
}
internal class Azure.Storage.Blobs.Models.BlobPropertiesInternal : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentMD5>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BlobSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BlobType> <BlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseStatus> <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseState> <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseDurationType> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CopyStatus> <CopyStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopySource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CopyCompletionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyStatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ServerEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncrementalCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RemainingRetentionDays>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AccessTier> <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AccessTierInferred>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchiveStatus> <ArchiveStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomerProvidedKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <AccessTierChangeTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TagCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsSealed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RehydratePriority> <RehydratePriority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastAccessedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ImmutabilityPolicyExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BlobImmutabilityPolicyMode> <ImmutabilityPolicyMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <LegalHold>k__BackingField;
    public Nullable`1<DateTimeOffset> CreationTime { get; }
    public DateTimeOffset LastModified { get; }
    public string Etag { get; }
    public Nullable`1<long> ContentLength { get; }
    public string ContentType { get; }
    public string ContentEncoding { get; }
    public string ContentLanguage { get; }
    public Byte[] ContentMD5 { get; }
    public string ContentDisposition { get; }
    public string CacheControl { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public Nullable`1<BlobType> BlobType { get; }
    public Nullable`1<LeaseStatus> LeaseStatus { get; }
    public Nullable`1<LeaseState> LeaseState { get; }
    public Nullable`1<LeaseDurationType> LeaseDuration { get; }
    public string CopyId { get; }
    public Nullable`1<CopyStatus> CopyStatus { get; }
    public string CopySource { get; }
    public string CopyProgress { get; }
    public Nullable`1<DateTimeOffset> CopyCompletionTime { get; }
    public string CopyStatusDescription { get; }
    public Nullable`1<bool> ServerEncrypted { get; }
    public Nullable`1<bool> IncrementalCopy { get; }
    public string DestinationSnapshot { get; }
    public Nullable`1<DateTimeOffset> DeletedTime { get; }
    public Nullable`1<int> RemainingRetentionDays { get; }
    public Nullable`1<AccessTier> AccessTier { get; }
    public Nullable`1<bool> AccessTierInferred { get; }
    public Nullable`1<ArchiveStatus> ArchiveStatus { get; }
    public string CustomerProvidedKeySha256 { get; }
    public string EncryptionScope { get; }
    public Nullable`1<DateTimeOffset> AccessTierChangeTime { get; }
    public Nullable`1<int> TagCount { get; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; }
    public Nullable`1<bool> IsSealed { get; }
    public Nullable`1<RehydratePriority> RehydratePriority { get; }
    public Nullable`1<DateTimeOffset> LastAccessedOn { get; }
    public Nullable`1<DateTimeOffset> ImmutabilityPolicyExpiresOn { get; }
    public Nullable`1<BlobImmutabilityPolicyMode> ImmutabilityPolicyMode { get; }
    public Nullable`1<bool> LegalHold { get; }
    internal BlobPropertiesInternal(DateTimeOffset lastModified, string etag);
    internal BlobPropertiesInternal(Nullable`1<DateTimeOffset> creationTime, DateTimeOffset lastModified, string etag, Nullable`1<long> contentLength, string contentType, string contentEncoding, string contentLanguage, Byte[] contentMD5, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, string copySource, string copyProgress, Nullable`1<DateTimeOffset> copyCompletionTime, string copyStatusDescription, Nullable`1<bool> serverEncrypted, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<DateTimeOffset> deletedTime, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<bool> accessTierInferred, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, string encryptionScope, Nullable`1<DateTimeOffset> accessTierChangeTime, Nullable`1<int> tagCount, Nullable`1<DateTimeOffset> expiresOn, Nullable`1<bool> isSealed, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> lastAccessedOn, Nullable`1<DateTimeOffset> immutabilityPolicyExpiresOn, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreationTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
public string get_Etag();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ContentLength();
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
public Byte[] get_ContentMD5();
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BlobSequenceNumber();
    [CompilerGeneratedAttribute]
public Nullable`1<BlobType> get_BlobType();
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseStatus> get_LeaseStatus();
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseState> get_LeaseState();
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseDurationType> get_LeaseDuration();
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
public Nullable`1<CopyStatus> get_CopyStatus();
    [CompilerGeneratedAttribute]
public string get_CopySource();
    [CompilerGeneratedAttribute]
public string get_CopyProgress();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CopyCompletionTime();
    [CompilerGeneratedAttribute]
public string get_CopyStatusDescription();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ServerEncrypted();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncrementalCopy();
    [CompilerGeneratedAttribute]
public string get_DestinationSnapshot();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedTime();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RemainingRetentionDays();
    [CompilerGeneratedAttribute]
public Nullable`1<AccessTier> get_AccessTier();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AccessTierInferred();
    [CompilerGeneratedAttribute]
public Nullable`1<ArchiveStatus> get_ArchiveStatus();
    [CompilerGeneratedAttribute]
public string get_CustomerProvidedKeySha256();
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_AccessTierChangeTime();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TagCount();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSealed();
    [CompilerGeneratedAttribute]
public Nullable`1<RehydratePriority> get_RehydratePriority();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastAccessedOn();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ImmutabilityPolicyExpiresOn();
    [CompilerGeneratedAttribute]
public Nullable`1<BlobImmutabilityPolicyMode> get_ImmutabilityPolicyMode();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_LegalHold();
    internal static BlobPropertiesInternal DeserializeBlobPropertiesInternal(XElement element);
}
public class Azure.Storage.Blobs.Models.BlobQueryArrowField : object {
    [CompilerGeneratedAttribute]
private BlobQueryArrowFieldType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    public BlobQueryArrowFieldType Type { get; public set; }
    public string Name { get; public set; }
    public int Precision { get; public set; }
    public int Scale { get; public set; }
    [CompilerGeneratedAttribute]
public BlobQueryArrowFieldType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(BlobQueryArrowFieldType value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(int value);
    [CompilerGeneratedAttribute]
public int get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(int value);
}
public enum Azure.Storage.Blobs.Models.BlobQueryArrowFieldType : Enum {
    public int value__;
    public static BlobQueryArrowFieldType Int64;
    public static BlobQueryArrowFieldType Bool;
    public static BlobQueryArrowFieldType Timestamp;
    public static BlobQueryArrowFieldType String;
    public static BlobQueryArrowFieldType Double;
    public static BlobQueryArrowFieldType Decimal;
}
public class Azure.Storage.Blobs.Models.BlobQueryArrowOptions : BlobQueryTextOptions {
    [CompilerGeneratedAttribute]
private IList`1<BlobQueryArrowField> <Schema>k__BackingField;
    public IList`1<BlobQueryArrowField> Schema { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<BlobQueryArrowField> get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(IList`1<BlobQueryArrowField> value);
}
public class Azure.Storage.Blobs.Models.BlobQueryCsvTextOptions : BlobQueryTextOptions {
    [CompilerGeneratedAttribute]
private string <RecordSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColumnSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <QuotationCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <EscapeCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasHeaders>k__BackingField;
    public string RecordSeparator { get; public set; }
    public string ColumnSeparator { get; public set; }
    public Nullable`1<char> QuotationCharacter { get; public set; }
    public Nullable`1<char> EscapeCharacter { get; public set; }
    public bool HasHeaders { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RecordSeparator();
    [CompilerGeneratedAttribute]
public void set_RecordSeparator(string value);
    [CompilerGeneratedAttribute]
public string get_ColumnSeparator();
    [CompilerGeneratedAttribute]
public void set_ColumnSeparator(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_QuotationCharacter();
    [CompilerGeneratedAttribute]
public void set_QuotationCharacter(Nullable`1<char> value);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_EscapeCharacter();
    [CompilerGeneratedAttribute]
public void set_EscapeCharacter(Nullable`1<char> value);
    [CompilerGeneratedAttribute]
public bool get_HasHeaders();
    [CompilerGeneratedAttribute]
public void set_HasHeaders(bool value);
}
public class Azure.Storage.Blobs.Models.BlobQueryError : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFatal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public string Name { get; internal set; }
    public string Description { get; internal set; }
    public bool IsFatal { get; internal set; }
    public long Position { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
internal void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFatal();
    [CompilerGeneratedAttribute]
internal void set_IsFatal(bool value);
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(long value);
}
public class Azure.Storage.Blobs.Models.BlobQueryJsonTextOptions : BlobQueryTextOptions {
    [CompilerGeneratedAttribute]
private string <RecordSeparator>k__BackingField;
    public string RecordSeparator { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RecordSeparator();
    [CompilerGeneratedAttribute]
public void set_RecordSeparator(string value);
}
public class Azure.Storage.Blobs.Models.BlobQueryOptions : object {
    [CompilerGeneratedAttribute]
private BlobQueryTextOptions <InputTextConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobQueryTextOptions <OutputTextConfiguration>k__BackingField;
    private object _objectLock;
    internal Action`1<BlobQueryError> _errorHandler;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    public BlobQueryTextOptions InputTextConfiguration { get; public set; }
    public BlobQueryTextOptions OutputTextConfiguration { get; public set; }
    public BlobRequestConditions Conditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    [CompilerGeneratedAttribute]
public BlobQueryTextOptions get_InputTextConfiguration();
    [CompilerGeneratedAttribute]
public void set_InputTextConfiguration(BlobQueryTextOptions value);
    [CompilerGeneratedAttribute]
public BlobQueryTextOptions get_OutputTextConfiguration();
    [CompilerGeneratedAttribute]
public void set_OutputTextConfiguration(BlobQueryTextOptions value);
    public void add_ErrorHandler(Action`1<BlobQueryError> value);
    public void remove_ErrorHandler(Action`1<BlobQueryError> value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
}
public class Azure.Storage.Blobs.Models.BlobQueryParquetTextOptions : BlobQueryTextOptions {
}
public abstract class Azure.Storage.Blobs.Models.BlobQueryTextOptions : object {
}
[FlagsAttribute]
internal enum Azure.Storage.Blobs.Models.BlobRequestConditionProperty : Enum {
    public int value__;
    public static BlobRequestConditionProperty None;
    public static BlobRequestConditionProperty LeaseId;
    public static BlobRequestConditionProperty TagConditions;
    public static BlobRequestConditionProperty IfModifiedSince;
    public static BlobRequestConditionProperty IfUnmodifiedSince;
    public static BlobRequestConditionProperty IfMatch;
    public static BlobRequestConditionProperty IfNoneMatch;
    public static BlobRequestConditionProperty IfAppendPositionEqual;
    public static BlobRequestConditionProperty IfMaxSizeLessThanOrEqual;
    public static BlobRequestConditionProperty IfSequenceNumberLessThan;
    public static BlobRequestConditionProperty IfSequenceNumberLessThanOrEqual;
    public static BlobRequestConditionProperty IfSequenceNumberEqual;
}
public class Azure.Storage.Blobs.Models.BlobRequestConditions : BlobLeaseRequestConditions {
    [CompilerGeneratedAttribute]
private string <LeaseId>k__BackingField;
    public string LeaseId { get; public set; }
    private BlobRequestConditions(BlobRequestConditions deepCopySource);
    [CompilerGeneratedAttribute]
public string get_LeaseId();
    [CompilerGeneratedAttribute]
public void set_LeaseId(string value);
    internal static BlobRequestConditions CloneOrDefault(BlobRequestConditions deepCopySource);
    public virtual string ToString();
    internal BlobRequestConditions WithIfMatch(ETag etag);
    internal virtual void AddConditions(StringBuilder conditions);
}
[CodeGenModelAttribute("RetentionPolicy")]
public class Azure.Storage.Blobs.Models.BlobRetentionPolicy : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Days>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowPermanentDelete>k__BackingField;
    public bool Enabled { get; public set; }
    public Nullable`1<int> Days { get; public set; }
    internal Nullable`1<bool> AllowPermanentDelete { get; internal set; }
    internal BlobRetentionPolicy(bool enabled, Nullable`1<int> days, Nullable`1<bool> allowPermanentDelete);
    internal BlobRetentionPolicy(bool enabled);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Days();
    [CompilerGeneratedAttribute]
public void set_Days(Nullable`1<int> value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobRetentionPolicy DeserializeBlobRetentionPolicy(XElement element);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_AllowPermanentDelete();
    [CompilerGeneratedAttribute]
internal void set_AllowPermanentDelete(Nullable`1<bool> value);
}
[CodeGenModelAttribute("StorageServiceProperties")]
public class Azure.Storage.Blobs.Models.BlobServiceProperties : object {
    [CompilerGeneratedAttribute]
private BlobAnalyticsLogging <Logging>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobMetrics <HourMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobMetrics <MinuteMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultServiceVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRetentionPolicy <DeleteRetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobStaticWebsite <StaticWebsite>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<BlobCorsRule> <Cors>k__BackingField;
    public BlobAnalyticsLogging Logging { get; public set; }
    public BlobMetrics HourMetrics { get; public set; }
    public BlobMetrics MinuteMetrics { get; public set; }
    public string DefaultServiceVersion { get; public set; }
    public BlobRetentionPolicy DeleteRetentionPolicy { get; public set; }
    public BlobStaticWebsite StaticWebsite { get; public set; }
    public IList`1<BlobCorsRule> Cors { get; public set; }
    internal BlobServiceProperties(BlobAnalyticsLogging logging, BlobMetrics hourMetrics, BlobMetrics minuteMetrics, IList`1<BlobCorsRule> cors, string defaultServiceVersion, BlobRetentionPolicy deleteRetentionPolicy, BlobStaticWebsite staticWebsite);
    internal BlobServiceProperties(bool skipInitialization);
    [CompilerGeneratedAttribute]
public BlobAnalyticsLogging get_Logging();
    [CompilerGeneratedAttribute]
public void set_Logging(BlobAnalyticsLogging value);
    [CompilerGeneratedAttribute]
public BlobMetrics get_HourMetrics();
    [CompilerGeneratedAttribute]
public void set_HourMetrics(BlobMetrics value);
    [CompilerGeneratedAttribute]
public BlobMetrics get_MinuteMetrics();
    [CompilerGeneratedAttribute]
public void set_MinuteMetrics(BlobMetrics value);
    [CompilerGeneratedAttribute]
public string get_DefaultServiceVersion();
    [CompilerGeneratedAttribute]
public void set_DefaultServiceVersion(string value);
    [CompilerGeneratedAttribute]
public BlobRetentionPolicy get_DeleteRetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_DeleteRetentionPolicy(BlobRetentionPolicy value);
    [CompilerGeneratedAttribute]
public BlobStaticWebsite get_StaticWebsite();
    [CompilerGeneratedAttribute]
public void set_StaticWebsite(BlobStaticWebsite value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobServiceProperties DeserializeBlobServiceProperties(XElement element);
    [CompilerGeneratedAttribute]
public IList`1<BlobCorsRule> get_Cors();
    [CompilerGeneratedAttribute]
public void set_Cors(IList`1<BlobCorsRule> value);
}
[CodeGenModelAttribute("StorageServiceStats")]
public class Azure.Storage.Blobs.Models.BlobServiceStatistics : object {
    [CompilerGeneratedAttribute]
private BlobGeoReplication <GeoReplication>k__BackingField;
    public BlobGeoReplication GeoReplication { get; }
    internal BlobServiceStatistics(BlobGeoReplication geoReplication);
    [CompilerGeneratedAttribute]
public BlobGeoReplication get_GeoReplication();
    internal static BlobServiceStatistics DeserializeBlobServiceStatistics(XElement element);
}
[CodeGenModelAttribute("SignedIdentifier")]
public class Azure.Storage.Blobs.Models.BlobSignedIdentifier : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobAccessPolicy <AccessPolicy>k__BackingField;
    public string Id { get; public set; }
    public BlobAccessPolicy AccessPolicy { get; public set; }
    internal BlobSignedIdentifier(string id, BlobAccessPolicy accessPolicy);
    internal BlobSignedIdentifier(bool skipInitialization);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public BlobAccessPolicy get_AccessPolicy();
    [CompilerGeneratedAttribute]
public void set_AccessPolicy(BlobAccessPolicy value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobSignedIdentifier DeserializeBlobSignedIdentifier(XElement element);
}
[CodeGenTypeAttribute("StorageBlobsModelFactory")]
public static class Azure.Storage.Blobs.Models.BlobsModelFactory : object {
    public static UserDelegationKey UserDelegationKey(string signedObjectId, string signedTenantId, DateTimeOffset signedStartsOn, DateTimeOffset signedExpiresOn, string signedService, string signedVersion, string value);
    public static BlobContentInfo BlobContentInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, string versionId, string encryptionKeySha256, string encryptionScope, long blobSequenceNumber);
    [EditorBrowsableAttribute("1")]
public static BlobContentInfo BlobContentInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, string encryptionKeySha256, string encryptionScope, long blobSequenceNumber);
    [EditorBrowsableAttribute("1")]
public static BlobContentInfo BlobContentInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, string encryptionKeySha256, long blobSequenceNumber);
    public static BlobAppendInfo BlobAppendInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, Byte[] contentCrc64, string blobAppendOffset, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope);
    [EditorBrowsableAttribute("1")]
public static BlobAppendInfo BlobAppendInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, Byte[] contentCrc64, string blobAppendOffset, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256);
    public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, Nullable`1<CopyStatus> blobCopyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary`2<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, Byte[] contentHash, DateTimeOffset lastAccessed, BlobImmutabilityPolicy immutabilityPolicy, bool hasLegalHold);
    [EditorBrowsableAttribute("1")]
public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, CopyStatus copyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary`2<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, Byte[] contentHash, DateTimeOffset lastAccessed, BlobImmutabilityPolicy immutabilityPolicy, bool hasLegalHold);
    [EditorBrowsableAttribute("1")]
public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, CopyStatus copyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary`2<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, Byte[] contentHash, DateTimeOffset lastAccessed);
    [EditorBrowsableAttribute("1")]
public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, CopyStatus copyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary`2<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, Byte[] contentHash);
    [EditorBrowsableAttribute("1")]
public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseState leaseState, LeaseStatus leaseStatus, long contentLength, LeaseDurationType leaseDuration, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string destinationSnapshot, string cacheControl, bool isIncrementalCopy, long blobSequenceNumber, CopyStatus copyStatus, string acceptRanges, Uri copySource, int blobCommittedBlockCount, string copyProgress, bool isServerEncrypted, string copyId, string encryptionKeySha256, string copyStatusDescription, string encryptionScope, DateTimeOffset copyCompletedOn, string accessTier, BlobType blobType, bool accessTierInferred, IDictionary`2<string, string> metadata, string archiveStatus, DateTimeOffset createdOn, DateTimeOffset accessTierChangedOn, string contentType);
    [EditorBrowsableAttribute("1")]
public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, long contentLength, string destinationSnapshot, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, bool isIncrementalCopy, string cacheControl, CopyStatus copyStatus, long blobSequenceNumber, Uri copySource, string acceptRanges, string copyProgress, int blobCommittedBlockCount, string copyId, bool isServerEncrypted, string copyStatusDescription, string encryptionKeySha256, DateTimeOffset copyCompletedOn, string accessTier, BlobType blobType, bool accessTierInferred, IDictionary`2<string, string> metadata, string archiveStatus, DateTimeOffset createdOn, DateTimeOffset accessTierChangedOn, string contentType);
    public static BlobItemProperties BlobItemProperties(bool accessTierInferred, Nullable`1<bool> serverEncrypted, string contentType, string contentEncoding, string contentLanguage, Byte[] contentHash, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, Uri copySource, string copyProgress, string copyStatusDescription, Nullable`1<long> contentLength, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, string encryptionScope, Nullable`1<long> tagCount, Nullable`1<DateTimeOffset> expiresOn, Nullable`1<bool> isSealed, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> lastAccessedOn, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> copyCompletedOn, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> accessTierChangedOn);
    [EditorBrowsableAttribute("1")]
public static BlobItemProperties BlobItemProperties(bool accessTierInferred, Nullable`1<bool> serverEncrypted, string contentType, string contentEncoding, string contentLanguage, Byte[] contentHash, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, Uri copySource, string copyProgress, string copyStatusDescription, Nullable`1<long> contentLength, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, string encryptionScope, Nullable`1<long> tagCount, Nullable`1<DateTimeOffset> expiresOn, Nullable`1<bool> isSealed, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> copyCompletedOn, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> accessTierChangedOn);
    [EditorBrowsableAttribute("1")]
public static BlobItemProperties BlobItemProperties(bool accessTierInferred, string copyProgress, string contentType, string contentEncoding, string contentLanguage, Byte[] contentHash, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, Uri copySource, Nullable`1<long> contentLength, string copyStatusDescription, Nullable`1<bool> serverEncrypted, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, string encryptionScope, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> copyCompletedOn, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> accessTierChangedOn);
    [EditorBrowsableAttribute("1")]
public static BlobItemProperties BlobItemProperties(bool accessTierInferred, Uri copySource, string contentType, string contentEncoding, string contentLanguage, Byte[] contentHash, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, Nullable`1<long> contentLength, string copyProgress, string copyStatusDescription, Nullable`1<bool> serverEncrypted, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> copyCompletedOn, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> accessTierChangedOn);
    public static BlockInfo BlockInfo(Byte[] contentHash, Byte[] contentCrc64, string encryptionKeySha256, string encryptionScope);
    [EditorBrowsableAttribute("1")]
public static BlockInfo BlockInfo(Byte[] contentHash, Byte[] contentCrc64, string encryptionKeySha256);
    public static PageInfo PageInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, Byte[] contentCrc64, long blobSequenceNumber, string encryptionKeySha256, string encryptionScope);
    [EditorBrowsableAttribute("1")]
public static PageInfo PageInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, Byte[] contentCrc64, long blobSequenceNumber, string encryptionKeySha256);
    public static BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<LeaseStatus> leaseStatus, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<int> remainingRetentionDays, IDictionary`2<string, string> metadata, Nullable`1<bool> hasLegalHold);
    [EditorBrowsableAttribute("1")]
public static BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<bool> hasLegalHold, IDictionary`2<string, string> metadata);
    [EditorBrowsableAttribute("1")]
public static BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<LeaseStatus> leaseStatus, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, IDictionary`2<string, string> metadata, Nullable`1<bool> hasLegalHold);
    [EditorBrowsableAttribute("1")]
public static BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<bool> hasLegalHold, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, IDictionary`2<string, string> metadata, Nullable`1<bool> hasImmutabilityPolicy);
    public static BlobCopyInfo BlobCopyInfo(ETag eTag, DateTimeOffset lastModified, string versionId, string copyId, CopyStatus copyStatus);
    [EditorBrowsableAttribute("1")]
public static BlobCopyInfo BlobCopyInfo(ETag eTag, DateTimeOffset lastModified, string copyId, CopyStatus copyStatus);
    public static BlobItem BlobItem(string name, bool deleted, BlobItemProperties properties, string snapshot, string versionId, Nullable`1<bool> isLatestVersion, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, List`1<ObjectReplicationPolicy> objectReplicationSourcePolicies, Nullable`1<bool> hasVersionsOnly);
    [EditorBrowsableAttribute("1")]
public static BlobItem BlobItem(string name, bool deleted, BlobItemProperties properties, string snapshot, string versionId, Nullable`1<bool> isLatestVersion, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, List`1<ObjectReplicationPolicy> objectReplicationSourcePolicies);
    [EditorBrowsableAttribute("1")]
public static BlobItem BlobItem(string name, bool deleted, BlobItemProperties properties, string snapshot, IDictionary`2<string, string> metadata);
    public static BlobSnapshotInfo BlobSnapshotInfo(string snapshot, ETag eTag, DateTimeOffset lastModified, string versionId, bool isServerEncrypted);
    [EditorBrowsableAttribute("1")]
public static BlobSnapshotInfo BlobSnapshotInfo(string snapshot, ETag eTag, DateTimeOffset lastModified, bool isServerEncrypted);
    public static BlobInfo blobInfo(ETag eTag, DateTimeOffset lastModifed, long blobSequenceNumber, string versionId);
    public static BlobContainerItem BlobContainerItem(string name, BlobContainerProperties properties, Nullable`1<bool> isDeleted, string versionId);
    public static BlobContainerInfo BlobContainerInfo(ETag eTag, DateTimeOffset lastModified);
    [EditorBrowsableAttribute("1")]
public static BlobContainerItem BlobContainerItem(string name, BlobContainerProperties properties);
    public static BlobQueryError BlobQueryError(string name, string description, bool isFatal, long position);
    public static GetBlobTagResult GetBlobTagResult(IDictionary`2<string, string> tags);
    public static TaggedBlobItem TaggedBlobItem(string blobName, string blobContainerName, IDictionary`2<string, string> tags);
    [EditorBrowsableAttribute("1")]
public static TaggedBlobItem TaggedBlobItem(string blobName, string blobContainerName);
    public static ObjectReplicationPolicy ObjectReplicationPolicy(string policyId, IList`1<ObjectReplicationRule> rules);
    public static ObjectReplicationRule ObjectReplicationRule(string ruleId, ObjectReplicationStatus replicationStatus);
    public static BlobDownloadDetails BlobDownloadDetails(BlobType blobType, long contentLength, string contentType, Byte[] contentHash, DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, long blobSequenceNumber, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, Byte[] blobContentHash, long tagCount, string versionId, bool isSealed, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, string objectReplicationDestinationPolicy, bool hasLegalHold, DateTimeOffset createdOn);
    [EditorBrowsableAttribute("1")]
public static BlobDownloadDetails BlobDownloadDetails(DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, long blobSequenceNumber, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, Byte[] blobContentHash, long tagCount, string versionId, bool isSealed, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, string objectReplicationDestinationPolicy);
    [EditorBrowsableAttribute("1")]
public static BlobDownloadDetails BlobDownloadDetails(BlobType blobType, long contentLength, string contentType, Byte[] contentHash, DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, long blobSequenceNumber, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, Byte[] blobContentHash, long tagCount, string versionId, bool isSealed, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, string objectReplicationDestinationPolicy);
    public static AccountInfo AccountInfo(SkuName skuName, AccountKind accountKind, bool isHierarchicalNamespaceEnabled);
    [EditorBrowsableAttribute("1")]
public static AccountInfo AccountInfo(SkuName skuName, AccountKind accountKind);
    public static BlobContainerAccessPolicy BlobContainerAccessPolicy(PublicAccessType blobPublicAccess, ETag eTag, DateTimeOffset lastModified, IEnumerable`1<BlobSignedIdentifier> signedIdentifiers);
    public static PageBlobInfo PageBlobInfo(ETag eTag, DateTimeOffset lastModified, long blobSequenceNumber);
    [EditorBrowsableAttribute("1")]
public static BlobBlock BlobBlock(string name, int size);
    public static BlobBlock BlobBlock(string name, long size);
    public static BlobGeoReplication BlobGeoReplication(BlobGeoReplicationStatus status, Nullable`1<DateTimeOffset> lastSyncedOn);
    public static BlobInfo BlobInfo(ETag eTag, DateTimeOffset lastModified);
    public static BlobLease BlobLease(ETag eTag, DateTimeOffset lastModified, string leaseId);
    public static BlobServiceStatistics BlobServiceStatistics(BlobGeoReplication geoReplication);
    public static BlockList BlockList(IEnumerable`1<BlobBlock> committedBlocks, IEnumerable`1<BlobBlock> uncommittedBlocks);
    public static UserDelegationKey UserDelegationKey(string signedObjectId, string signedTenantId, string signedService, string signedVersion, string value, DateTimeOffset signedExpiresOn, DateTimeOffset signedStartsOn);
    public static BlobHierarchyItem BlobHierarchyItem(string prefix, BlobItem blob);
    public static BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, Byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, Byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, string encryptionScope, long contentLength, Byte[] blobContentHash, string versionId, IDictionary`2<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime, long tagCount, DateTimeOffset lastAccessed);
    [EditorBrowsableAttribute("1")]
public static BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, Byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, Byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, string encryptionScope, long contentLength, Byte[] blobContentHash, string versionId, IDictionary`2<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime, long tagCount);
    [EditorBrowsableAttribute("1")]
public static BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, Byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, Byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, string encryptionScope, long contentLength, Byte[] blobContentHash, IDictionary`2<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime);
    [EditorBrowsableAttribute("1")]
public static BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, Byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, Byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, long contentLength, Byte[] blobContentHash, IDictionary`2<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime);
    public static BlobDownloadResult BlobDownloadResult(BinaryData content, BlobDownloadDetails details);
    public static BlobDownloadStreamingResult BlobDownloadStreamingResult(Stream content, BlobDownloadDetails details);
    public static PageRangesInfo PageRangesInfo(DateTimeOffset lastModified, ETag eTag, long blobContentLength, IEnumerable`1<HttpRange> pageRanges, IEnumerable`1<HttpRange> clearRanges);
}
public class Azure.Storage.Blobs.Models.BlobSnapshotInfo : object {
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerEncrypted>k__BackingField;
    public string Snapshot { get; internal set; }
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public string VersionId { get; internal set; }
    public bool IsServerEncrypted { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
internal void set_Snapshot(string value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
internal void set_VersionId(string value);
    [CompilerGeneratedAttribute]
public bool get_IsServerEncrypted();
    [CompilerGeneratedAttribute]
internal void set_IsServerEncrypted(bool value);
}
[FlagsAttribute]
public enum Azure.Storage.Blobs.Models.BlobStates : Enum {
    public int value__;
    public static BlobStates None;
    public static BlobStates Snapshots;
    public static BlobStates Uncommitted;
    public static BlobStates Deleted;
    public static BlobStates Version;
    public static BlobStates DeletedWithVersions;
    public static BlobStates All;
}
[CodeGenModelAttribute("StaticWebsite")]
public class Azure.Storage.Blobs.Models.BlobStaticWebsite : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDocument404Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultIndexDocumentPath>k__BackingField;
    public bool Enabled { get; public set; }
    public string IndexDocument { get; public set; }
    public string ErrorDocument404Path { get; public set; }
    public string DefaultIndexDocumentPath { get; public set; }
    internal BlobStaticWebsite(bool enabled, string indexDocument, string errorDocument404Path, string defaultIndexDocumentPath);
    internal BlobStaticWebsite(bool enabled);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public string get_IndexDocument();
    [CompilerGeneratedAttribute]
public void set_IndexDocument(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDocument404Path();
    [CompilerGeneratedAttribute]
public void set_ErrorDocument404Path(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultIndexDocumentPath();
    [CompilerGeneratedAttribute]
public void set_DefaultIndexDocumentPath(string value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobStaticWebsite DeserializeBlobStaticWebsite(XElement element);
}
public class Azure.Storage.Blobs.Models.BlobSyncUploadFromUriOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CopySourceBlobProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <DestinationConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <SourceConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AccessTier> <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpAuthorization <SourceAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BlobCopySourceTagsMode> <CopySourceTagsMode>k__BackingField;
    public Nullable`1<bool> CopySourceBlobProperties { get; public set; }
    public BlobHttpHeaders HttpHeaders { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public IDictionary`2<string, string> Tags { get; public set; }
    public BlobRequestConditions DestinationConditions { get; public set; }
    public BlobRequestConditions SourceConditions { get; public set; }
    public Nullable`1<AccessTier> AccessTier { get; public set; }
    public Byte[] ContentHash { get; public set; }
    public HttpAuthorization SourceAuthentication { get; public set; }
    public Nullable`1<BlobCopySourceTagsMode> CopySourceTagsMode { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CopySourceBlobProperties();
    [CompilerGeneratedAttribute]
public void set_CopySourceBlobProperties(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public BlobHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(BlobHttpHeaders value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_DestinationConditions();
    [CompilerGeneratedAttribute]
public void set_DestinationConditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_SourceConditions();
    [CompilerGeneratedAttribute]
public void set_SourceConditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public Nullable`1<AccessTier> get_AccessTier();
    [CompilerGeneratedAttribute]
public void set_AccessTier(Nullable`1<AccessTier> value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public HttpAuthorization get_SourceAuthentication();
    [CompilerGeneratedAttribute]
public void set_SourceAuthentication(HttpAuthorization value);
    [CompilerGeneratedAttribute]
public Nullable`1<BlobCopySourceTagsMode> get_CopySourceTagsMode();
    [CompilerGeneratedAttribute]
public void set_CopySourceTagsMode(Nullable`1<BlobCopySourceTagsMode> value);
}
internal class Azure.Storage.Blobs.Models.BlobTag : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; public set; }
    public string Value { get; public set; }
    public BlobTag(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobTag DeserializeBlobTag(XElement element);
}
internal class Azure.Storage.Blobs.Models.BlobTags : object {
    [CompilerGeneratedAttribute]
private IList`1<BlobTag> <BlobTagSet>k__BackingField;
    public IList`1<BlobTag> BlobTagSet { get; }
    public BlobTags(IEnumerable`1<BlobTag> blobTagSet);
    internal BlobTags(IList`1<BlobTag> blobTagSet);
    [CompilerGeneratedAttribute]
public IList`1<BlobTag> get_BlobTagSet();
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static BlobTags DeserializeBlobTags(XElement element);
}
[FlagsAttribute]
public enum Azure.Storage.Blobs.Models.BlobTraits : Enum {
    public int value__;
    public static BlobTraits None;
    public static BlobTraits CopyStatus;
    public static BlobTraits Metadata;
    public static BlobTraits Tags;
    public static BlobTraits ImmutabilityPolicy;
    public static BlobTraits LegalHold;
    public static BlobTraits All;
}
public enum Azure.Storage.Blobs.Models.BlobType : Enum {
    public int value__;
    [CodeGenMemberAttribute("BlockBlob")]
public static BlobType Block;
    [CodeGenMemberAttribute("PageBlob")]
public static BlobType Page;
    [CodeGenMemberAttribute("AppendBlob")]
public static BlobType Append;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.BlobTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(BlobType value);
    [ExtensionAttribute]
public static BlobType ToBlobType(string value);
}
public class Azure.Storage.Blobs.Models.BlobUploadOptions : object {
    [CompilerGeneratedAttribute]
private BlobHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AccessTier> <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageTransferOptions <TransferOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <LegalHold>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public BlobHttpHeaders HttpHeaders { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public IDictionary`2<string, string> Tags { get; public set; }
    public BlobRequestConditions Conditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public Nullable`1<AccessTier> AccessTier { get; public set; }
    public StorageTransferOptions TransferOptions { get; public set; }
    public BlobImmutabilityPolicy ImmutabilityPolicy { get; public set; }
    public Nullable`1<bool> LegalHold { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public BlobHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(BlobHttpHeaders value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<AccessTier> get_AccessTier();
    [CompilerGeneratedAttribute]
public void set_AccessTier(Nullable`1<AccessTier> value);
    [CompilerGeneratedAttribute]
public StorageTransferOptions get_TransferOptions();
    [CompilerGeneratedAttribute]
public void set_TransferOptions(StorageTransferOptions value);
    [CompilerGeneratedAttribute]
public BlobImmutabilityPolicy get_ImmutabilityPolicy();
    [CompilerGeneratedAttribute]
public void set_ImmutabilityPolicy(BlobImmutabilityPolicy value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_LegalHold();
    [CompilerGeneratedAttribute]
public void set_LegalHold(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
}
public class Azure.Storage.Blobs.Models.BlockBlobOpenWriteOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <OpenConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    public Nullable`1<long> BufferSize { get; public set; }
    public BlobRequestConditions OpenConditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public BlobHttpHeaders HttpHeaders { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public IDictionary`2<string, string> Tags { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    internal string OperationName { get; internal set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_OpenConditions();
    [CompilerGeneratedAttribute]
public void set_OpenConditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public BlobHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(BlobHttpHeaders value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
    [CompilerGeneratedAttribute]
internal string get_OperationName();
    [CompilerGeneratedAttribute]
internal void set_OperationName(string value);
}
public class Azure.Storage.Blobs.Models.BlockBlobStageBlockOptions : object {
    [CompilerGeneratedAttribute]
private BlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public BlobRequestConditions Conditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
}
public class Azure.Storage.Blobs.Models.BlockInfo : object {
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentCrc64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    public Byte[] ContentHash { get; internal set; }
    public Byte[] ContentCrc64 { get; internal set; }
    public string EncryptionKeySha256 { get; internal set; }
    public string EncryptionScope { get; internal set; }
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentCrc64();
    [CompilerGeneratedAttribute]
internal void set_ContentCrc64(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKeySha256();
    [CompilerGeneratedAttribute]
internal void set_EncryptionKeySha256(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
}
public class Azure.Storage.Blobs.Models.BlockList : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlobContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<BlobBlock> <CommittedBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<BlobBlock> <UncommittedBlocks>k__BackingField;
    public DateTimeOffset LastModified { get; internal set; }
    public ETag ETag { get; internal set; }
    public string ContentType { get; internal set; }
    public long BlobContentLength { get; internal set; }
    public IEnumerable`1<BlobBlock> CommittedBlocks { get; internal set; }
    public IEnumerable`1<BlobBlock> UncommittedBlocks { get; internal set; }
    internal BlockList(IEnumerable`1<BlobBlock> committedBlocks, IEnumerable`1<BlobBlock> uncommittedBlocks);
    internal static BlockList DeserializeBlockList(XElement element);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public long get_BlobContentLength();
    [CompilerGeneratedAttribute]
internal void set_BlobContentLength(long value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<BlobBlock> get_CommittedBlocks();
    [CompilerGeneratedAttribute]
internal void set_CommittedBlocks(IEnumerable`1<BlobBlock> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<BlobBlock> get_UncommittedBlocks();
    [CompilerGeneratedAttribute]
internal void set_UncommittedBlocks(IEnumerable`1<BlobBlock> value);
}
internal enum Azure.Storage.Blobs.Models.BlockListType : Enum {
    public int value__;
    public static BlockListType Committed;
    public static BlockListType Uncommitted;
    public static BlockListType All;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.BlockListTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(BlockListType value);
    [ExtensionAttribute]
public static BlockListType ToBlockListType(string value);
}
[FlagsAttribute]
public enum Azure.Storage.Blobs.Models.BlockListTypes : Enum {
    public int value__;
    public static BlockListTypes All;
    public static BlockListTypes Committed;
    public static BlockListTypes Uncommitted;
}
internal class Azure.Storage.Blobs.Models.BlockLookupList : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <Committed>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Uncommitted>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Latest>k__BackingField;
    public IList`1<string> Committed { get; public set; }
    public IList`1<string> Uncommitted { get; public set; }
    public IList`1<string> Latest { get; public set; }
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Committed();
    [CompilerGeneratedAttribute]
public void set_Committed(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Uncommitted();
    [CompilerGeneratedAttribute]
public void set_Uncommitted(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Latest();
    [CompilerGeneratedAttribute]
public void set_Latest(IList`1<string> value);
}
internal class Azure.Storage.Blobs.Models.ClearRange : object {
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private long <End>k__BackingField;
    public long Start { get; }
    public long End { get; }
    internal ClearRange(long start, long end);
    [CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
public long get_End();
    internal static ClearRange DeserializeClearRange(XElement element);
}
public class Azure.Storage.Blobs.Models.CommitBlockListOptions : object {
    [CompilerGeneratedAttribute]
private BlobHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AccessTier> <AccessTier>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <LegalHold>k__BackingField;
    public BlobHttpHeaders HttpHeaders { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public IDictionary`2<string, string> Tags { get; public set; }
    public BlobRequestConditions Conditions { get; public set; }
    public Nullable`1<AccessTier> AccessTier { get; public set; }
    public BlobImmutabilityPolicy ImmutabilityPolicy { get; public set; }
    public Nullable`1<bool> LegalHold { get; public set; }
    [CompilerGeneratedAttribute]
public BlobHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(BlobHttpHeaders value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public Nullable`1<AccessTier> get_AccessTier();
    [CompilerGeneratedAttribute]
public void set_AccessTier(Nullable`1<AccessTier> value);
    [CompilerGeneratedAttribute]
public BlobImmutabilityPolicy get_ImmutabilityPolicy();
    [CompilerGeneratedAttribute]
public void set_ImmutabilityPolicy(BlobImmutabilityPolicy value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_LegalHold();
    [CompilerGeneratedAttribute]
public void set_LegalHold(Nullable`1<bool> value);
}
[CodeGenModelAttribute("ContainerItem")]
internal class Azure.Storage.Blobs.Models.ContainerItemInternal : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Deleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainerPropertiesInternal <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Metadata>k__BackingField;
    public string Name { get; }
    public Nullable`1<bool> Deleted { get; }
    public string Version { get; }
    public ContainerPropertiesInternal Properties { get; }
    public IReadOnlyDictionary`2<string, string> Metadata { get; }
    internal ContainerItemInternal(string name, ContainerPropertiesInternal properties);
    internal ContainerItemInternal(string name, Nullable`1<bool> deleted, string version, ContainerPropertiesInternal properties, IReadOnlyDictionary`2<string, string> metadata);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Deleted();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public ContainerPropertiesInternal get_Properties();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Metadata();
    internal static ContainerItemInternal DeserializeContainerItemInternal(XElement element);
}
[CodeGenModelAttribute("ContainerProperties")]
internal class Azure.Storage.Blobs.Models.ContainerPropertiesInternal : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseStatus> <LeaseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseState> <LeaseState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LeaseDurationType> <LeaseDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PublicAccessType> <PublicAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasLegalHold>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultEncryptionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PreventEncryptionScopeOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RemainingRetentionDays>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsImmutableStorageWithVersioningEnabled>k__BackingField;
    public DateTimeOffset LastModified { get; }
    public string Etag { get; }
    public Nullable`1<LeaseStatus> LeaseStatus { get; }
    public Nullable`1<LeaseState> LeaseState { get; }
    public Nullable`1<LeaseDurationType> LeaseDuration { get; }
    public Nullable`1<PublicAccessType> PublicAccess { get; }
    public Nullable`1<bool> HasImmutabilityPolicy { get; }
    public Nullable`1<bool> HasLegalHold { get; }
    public string DefaultEncryptionScope { get; }
    public Nullable`1<bool> PreventEncryptionScopeOverride { get; }
    public Nullable`1<DateTimeOffset> DeletedTime { get; }
    public Nullable`1<int> RemainingRetentionDays { get; }
    public Nullable`1<bool> IsImmutableStorageWithVersioningEnabled { get; }
    internal ContainerPropertiesInternal(DateTimeOffset lastModified, string etag);
    internal ContainerPropertiesInternal(DateTimeOffset lastModified, string etag, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<bool> hasLegalHold, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, Nullable`1<DateTimeOffset> deletedTime, Nullable`1<int> remainingRetentionDays, Nullable`1<bool> isImmutableStorageWithVersioningEnabled);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
public string get_Etag();
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseStatus> get_LeaseStatus();
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseState> get_LeaseState();
    [CompilerGeneratedAttribute]
public Nullable`1<LeaseDurationType> get_LeaseDuration();
    [CompilerGeneratedAttribute]
public Nullable`1<PublicAccessType> get_PublicAccess();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HasImmutabilityPolicy();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HasLegalHold();
    [CompilerGeneratedAttribute]
public string get_DefaultEncryptionScope();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PreventEncryptionScopeOverride();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedTime();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RemainingRetentionDays();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsImmutableStorageWithVersioningEnabled();
    internal static ContainerPropertiesInternal DeserializeContainerPropertiesInternal(XElement element);
}
internal class Azure.Storage.Blobs.Models.ContentRange : ValueType {
    private static string WildcardMarker;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <End>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeUnit <Unit>k__BackingField;
    public Nullable`1<long> Start { get; }
    public Nullable`1<long> End { get; }
    public Nullable`1<long> Size { get; }
    public RangeUnit Unit { get; }
    public ContentRange(RangeUnit unit, Nullable`1<long> start, Nullable`1<long> end, Nullable`1<long> size);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<long> get_Start();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<long> get_End();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<long> get_Size();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public RangeUnit get_Unit();
    public static ContentRange Parse(string headerValue);
}
public class Azure.Storage.Blobs.Models.CopyFromUriOperation : Operation`1<long> {
    private BlobBaseClient _client;
    private CancellationToken _cancellationToken;
    private bool _hasCompleted;
    private Nullable`1<long> _value;
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    public string Id { get; }
    public long Value { get; }
    public CopyFromUriOperation(string id, BlobBaseClient client);
    internal CopyFromUriOperation(BlobBaseClient client, string copyId, Response initialResponse, CancellationToken cancellationToken);
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    [CompilerGeneratedAttribute]
public virtual string get_Id();
    public virtual long get_Value();
    public virtual Response GetRawResponse();
    public virtual ValueTask`1<Response`1<long>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<long>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Models.CopyFromUriOperation/<UpdateStatusAsync>d__21")]
public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Models.CopyFromUriOperation/<UpdateStatusAsync>d__22")]
private Task`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
}
[CodeGenModelAttribute("CopyStatusType")]
public enum Azure.Storage.Blobs.Models.CopyStatus : Enum {
    public int value__;
    public static CopyStatus Pending;
    public static CopyStatus Success;
    public static CopyStatus Aborted;
    public static CopyStatus Failed;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.CopyStatusExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(CopyStatus value);
    [ExtensionAttribute]
public static CopyStatus ToCopyStatus(string value);
}
[IsReadOnlyAttribute]
public class Azure.Storage.Blobs.Models.CustomerProvidedKey : ValueType {
    [CompilerGeneratedAttribute]
private string <EncryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeyHash>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAlgorithmType <EncryptionAlgorithm>k__BackingField;
    public string EncryptionKey { get; }
    public string EncryptionKeyHash { get; }
    public EncryptionAlgorithmType EncryptionAlgorithm { get; }
    public CustomerProvidedKey(string key);
    public CustomerProvidedKey(Byte[] key);
    [CompilerGeneratedAttribute]
public string get_EncryptionKey();
    [CompilerGeneratedAttribute]
public string get_EncryptionKeyHash();
    [CompilerGeneratedAttribute]
public EncryptionAlgorithmType get_EncryptionAlgorithm();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CustomerProvidedKey left, CustomerProvidedKey right);
    public static bool op_Inequality(CustomerProvidedKey left, CustomerProvidedKey right);
    public sealed virtual bool Equals(CustomerProvidedKey other);
    public virtual string ToString();
}
[CodeGenModelAttribute("DeleteSnapshotsOptionType")]
public enum Azure.Storage.Blobs.Models.DeleteSnapshotsOption : Enum {
    public int value__;
    public static DeleteSnapshotsOption None;
    [CodeGenMemberAttribute("Include")]
public static DeleteSnapshotsOption IncludeSnapshots;
    [CodeGenMemberAttribute("Only")]
public static DeleteSnapshotsOption OnlySnapshots;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.DeleteSnapshotsOptionExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(DeleteSnapshotsOption value);
    [ExtensionAttribute]
public static DeleteSnapshotsOption ToDeleteSnapshotsOption(string value);
}
[CodeGenModelAttribute("DelimitedTextConfiguration")]
internal class Azure.Storage.Blobs.Models.DelimitedTextConfigurationInternal : object {
    [CompilerGeneratedAttribute]
private string <ColumnSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldQuote>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RecordSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EscapeChar>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HeadersPresent>k__BackingField;
    public string ColumnSeparator { get; public set; }
    public string FieldQuote { get; public set; }
    public string RecordSeparator { get; public set; }
    public string EscapeChar { get; public set; }
    public Nullable`1<bool> HeadersPresent { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ColumnSeparator();
    [CompilerGeneratedAttribute]
public void set_ColumnSeparator(string value);
    [CompilerGeneratedAttribute]
public string get_FieldQuote();
    [CompilerGeneratedAttribute]
public void set_FieldQuote(string value);
    [CompilerGeneratedAttribute]
public string get_RecordSeparator();
    [CompilerGeneratedAttribute]
public void set_RecordSeparator(string value);
    [CompilerGeneratedAttribute]
public string get_EscapeChar();
    [CompilerGeneratedAttribute]
public void set_EscapeChar(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HeadersPresent();
    [CompilerGeneratedAttribute]
public void set_HeadersPresent(Nullable`1<bool> value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
}
public enum Azure.Storage.Blobs.Models.EncryptionAlgorithmType : Enum {
    public int value__;
    public static EncryptionAlgorithmType Aes256;
}
[CodeGenModelAttribute("EncryptionAlgorithmType")]
internal enum Azure.Storage.Blobs.Models.EncryptionAlgorithmTypeInternal : Enum {
    public int value__;
    public static EncryptionAlgorithmTypeInternal None;
    public static EncryptionAlgorithmTypeInternal AES256;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.EncryptionAlgorithmTypeInternalExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(EncryptionAlgorithmTypeInternal value);
    [ExtensionAttribute]
public static EncryptionAlgorithmTypeInternal ToEncryptionAlgorithmTypeInternal(string value);
}
internal class Azure.Storage.Blobs.Models.FilterBlobItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsCurrentVersion>k__BackingField;
    public string Name { get; }
    public string ContainerName { get; }
    public BlobTags Tags { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsCurrentVersion { get; }
    internal FilterBlobItem(string name, string containerName);
    internal FilterBlobItem(string name, string containerName, BlobTags tags, string versionId, Nullable`1<bool> isCurrentVersion);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ContainerName();
    [CompilerGeneratedAttribute]
public BlobTags get_Tags();
    [CompilerGeneratedAttribute]
public string get_VersionId();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsCurrentVersion();
    internal static FilterBlobItem DeserializeFilterBlobItem(XElement element);
}
internal class Azure.Storage.Blobs.Models.FilterBlobsAsyncCollection : StorageCollectionEnumerator`1<TaggedBlobItem> {
    private BlobServiceClient _serviceClient;
    private BlobContainerClient _containerClient;
    private string _expression;
    public FilterBlobsAsyncCollection(BlobServiceClient serviceClient, string expression);
    public FilterBlobsAsyncCollection(BlobContainerClient containerClient, string expression);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Models.FilterBlobsAsyncCollection/<GetNextPageAsync>d__5")]
public virtual ValueTask`1<Page`1<TaggedBlobItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Blobs.Models.FilterBlobSegment : object {
    [CompilerGeneratedAttribute]
private string <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Where>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FilterBlobItem> <Blobs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    public string ServiceEndpoint { get; }
    public string Where { get; }
    public IReadOnlyList`1<FilterBlobItem> Blobs { get; }
    public string NextMarker { get; }
    internal FilterBlobSegment(string serviceEndpoint, string where, IEnumerable`1<FilterBlobItem> blobs);
    internal FilterBlobSegment(string serviceEndpoint, string where, IReadOnlyList`1<FilterBlobItem> blobs, string nextMarker);
    [CompilerGeneratedAttribute]
public string get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
public string get_Where();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FilterBlobItem> get_Blobs();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    internal static FilterBlobSegment DeserializeFilterBlobSegment(XElement element);
}
internal enum Azure.Storage.Blobs.Models.FilterBlobsIncludeItem : Enum {
    public int value__;
    public static FilterBlobsIncludeItem None;
    public static FilterBlobsIncludeItem Versions;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.FilterBlobsIncludeItemExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(FilterBlobsIncludeItem value);
    [ExtensionAttribute]
public static FilterBlobsIncludeItem ToFilterBlobsIncludeItem(string value);
}
internal class Azure.Storage.Blobs.Models.GetBlobContainersAsyncCollection : StorageCollectionEnumerator`1<BlobContainerItem> {
    private BlobServiceClient _client;
    private BlobContainerTraits _traits;
    private BlobContainerStates _states;
    private string _prefix;
    public GetBlobContainersAsyncCollection(BlobServiceClient client, BlobContainerTraits traits, BlobContainerStates states, string prefix);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Models.GetBlobContainersAsyncCollection/<GetNextPageAsync>d__5")]
public virtual ValueTask`1<Page`1<BlobContainerItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Blobs.Models.GetBlobsAsyncCollection : StorageCollectionEnumerator`1<BlobItem> {
    private BlobContainerClient _client;
    private BlobTraits _traits;
    private BlobStates _states;
    private string _prefix;
    public GetBlobsAsyncCollection(BlobContainerClient client, BlobTraits traits, BlobStates states, string prefix);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Models.GetBlobsAsyncCollection/<GetNextPageAsync>d__5")]
public virtual ValueTask`1<Page`1<BlobItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Blobs.Models.GetBlobsByHierarchyAsyncCollection : StorageCollectionEnumerator`1<BlobHierarchyItem> {
    private BlobContainerClient _client;
    private BlobTraits _traits;
    private BlobStates _states;
    private string _delimiter;
    private string _prefix;
    public GetBlobsByHierarchyAsyncCollection(BlobContainerClient client, string delimiter, BlobTraits traits, BlobStates states, string prefix);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Models.GetBlobsByHierarchyAsyncCollection/<GetNextPageAsync>d__6")]
public virtual ValueTask`1<Page`1<BlobHierarchyItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
public class Azure.Storage.Blobs.Models.GetBlobTagResult : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    public IDictionary`2<string, string> Tags { get; internal set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(IDictionary`2<string, string> value);
}
internal class Azure.Storage.Blobs.Models.GetPageRangesAsyncCollection : StorageCollectionEnumerator`1<PageRangeItem> {
    private bool _diff;
    private PageBlobClient _client;
    private Nullable`1<HttpRange> _range;
    private string _snapshot;
    private string _previousSnapshot;
    private Uri _previousSnapshotUri;
    private PageBlobRequestConditions _requestConditions;
    private string _operationName;
    public GetPageRangesAsyncCollection(bool diff, PageBlobClient client, Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, Uri previousSnapshotUri, PageBlobRequestConditions requestConditions, string operationName);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Models.GetPageRangesAsyncCollection/<GetNextPageAsync>d__9")]
public virtual ValueTask`1<Page`1<PageRangeItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
public class Azure.Storage.Blobs.Models.GetPageRangesDiffOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<HttpRange> <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreviousSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private PageBlobRequestConditions <Conditions>k__BackingField;
    public Nullable`1<HttpRange> Range { get; public set; }
    public string Snapshot { get; public set; }
    public string PreviousSnapshot { get; public set; }
    public PageBlobRequestConditions Conditions { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<HttpRange> get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(Nullable`1<HttpRange> value);
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
public void set_Snapshot(string value);
    [CompilerGeneratedAttribute]
public string get_PreviousSnapshot();
    [CompilerGeneratedAttribute]
public void set_PreviousSnapshot(string value);
    [CompilerGeneratedAttribute]
public PageBlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(PageBlobRequestConditions value);
}
public class Azure.Storage.Blobs.Models.GetPageRangesOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<HttpRange> <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private PageBlobRequestConditions <Conditions>k__BackingField;
    public Nullable`1<HttpRange> Range { get; public set; }
    public string Snapshot { get; public set; }
    public PageBlobRequestConditions Conditions { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<HttpRange> get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(Nullable`1<HttpRange> value);
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
public void set_Snapshot(string value);
    [CompilerGeneratedAttribute]
public PageBlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(PageBlobRequestConditions value);
}
[CodeGenModelAttribute("JsonTextConfiguration")]
internal class Azure.Storage.Blobs.Models.JsonTextConfigurationInternal : object {
    [CompilerGeneratedAttribute]
private string <RecordSeparator>k__BackingField;
    public string RecordSeparator { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RecordSeparator();
    [CompilerGeneratedAttribute]
public void set_RecordSeparator(string value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
}
internal class Azure.Storage.Blobs.Models.KeyInfo : object {
    [CompilerGeneratedAttribute]
private string <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Expiry>k__BackingField;
    public string Start { get; public set; }
    public string Expiry { get; }
    public KeyInfo(string expiry);
    [CompilerGeneratedAttribute]
public string get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(string value);
    [CompilerGeneratedAttribute]
public string get_Expiry();
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
}
public enum Azure.Storage.Blobs.Models.LeaseDurationType : Enum {
    public int value__;
    public static LeaseDurationType Infinite;
    public static LeaseDurationType Fixed;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.LeaseDurationTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(LeaseDurationType value);
    [ExtensionAttribute]
public static LeaseDurationType ToLeaseDurationType(string value);
}
[CodeGenModelAttribute("LeaseStateType")]
public enum Azure.Storage.Blobs.Models.LeaseState : Enum {
    public int value__;
    public static LeaseState Available;
    public static LeaseState Leased;
    public static LeaseState Expired;
    public static LeaseState Breaking;
    public static LeaseState Broken;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.LeaseStateExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(LeaseState value);
    [ExtensionAttribute]
public static LeaseState ToLeaseState(string value);
}
[CodeGenModelAttribute("LeaseStatusType")]
public enum Azure.Storage.Blobs.Models.LeaseStatus : Enum {
    public int value__;
    public static LeaseStatus Locked;
    public static LeaseStatus Unlocked;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.LeaseStatusExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(LeaseStatus value);
    [ExtensionAttribute]
public static LeaseStatus ToLeaseStatus(string value);
}
internal class Azure.Storage.Blobs.Models.ListBlobsFlatSegmentResponse : object {
    [CompilerGeneratedAttribute]
private string <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobFlatListSegment <Segment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    public string ServiceEndpoint { get; }
    public string ContainerName { get; }
    public string Prefix { get; }
    public string Marker { get; }
    public Nullable`1<int> MaxResults { get; }
    public BlobFlatListSegment Segment { get; }
    public string NextMarker { get; }
    internal ListBlobsFlatSegmentResponse(string serviceEndpoint, string containerName, BlobFlatListSegment segment);
    internal ListBlobsFlatSegmentResponse(string serviceEndpoint, string containerName, string prefix, string marker, Nullable`1<int> maxResults, BlobFlatListSegment segment, string nextMarker);
    [CompilerGeneratedAttribute]
public string get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
public string get_ContainerName();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Marker();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxResults();
    [CompilerGeneratedAttribute]
public BlobFlatListSegment get_Segment();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    internal static ListBlobsFlatSegmentResponse DeserializeListBlobsFlatSegmentResponse(XElement element);
}
internal class Azure.Storage.Blobs.Models.ListBlobsHierarchySegmentResponse : object {
    [CompilerGeneratedAttribute]
private string <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobHierarchyListSegment <Segment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    public string ServiceEndpoint { get; }
    public string ContainerName { get; }
    public string Prefix { get; }
    public string Marker { get; }
    public Nullable`1<int> MaxResults { get; }
    public string Delimiter { get; }
    public BlobHierarchyListSegment Segment { get; }
    public string NextMarker { get; }
    internal ListBlobsHierarchySegmentResponse(string serviceEndpoint, string containerName, BlobHierarchyListSegment segment);
    internal ListBlobsHierarchySegmentResponse(string serviceEndpoint, string containerName, string prefix, string marker, Nullable`1<int> maxResults, string delimiter, BlobHierarchyListSegment segment, string nextMarker);
    [CompilerGeneratedAttribute]
public string get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
public string get_ContainerName();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Marker();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxResults();
    [CompilerGeneratedAttribute]
public string get_Delimiter();
    [CompilerGeneratedAttribute]
public BlobHierarchyListSegment get_Segment();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    internal static ListBlobsHierarchySegmentResponse DeserializeListBlobsHierarchySegmentResponse(XElement element);
}
internal enum Azure.Storage.Blobs.Models.ListBlobsIncludeItem : Enum {
    public int value__;
    public static ListBlobsIncludeItem Copy;
    public static ListBlobsIncludeItem Deleted;
    public static ListBlobsIncludeItem Metadata;
    public static ListBlobsIncludeItem Snapshots;
    public static ListBlobsIncludeItem Uncommittedblobs;
    public static ListBlobsIncludeItem Versions;
    public static ListBlobsIncludeItem Tags;
    public static ListBlobsIncludeItem Immutabilitypolicy;
    public static ListBlobsIncludeItem Legalhold;
    public static ListBlobsIncludeItem DeletedWithVersions;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.ListBlobsIncludeItemExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ListBlobsIncludeItem value);
    [ExtensionAttribute]
public static ListBlobsIncludeItem ToListBlobsIncludeItem(string value);
}
internal enum Azure.Storage.Blobs.Models.ListContainersIncludeType : Enum {
    public int value__;
    public static ListContainersIncludeType Metadata;
    public static ListContainersIncludeType Deleted;
    public static ListContainersIncludeType System;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.ListContainersIncludeTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(ListContainersIncludeType value);
    [ExtensionAttribute]
public static ListContainersIncludeType ToListContainersIncludeType(string value);
}
internal class Azure.Storage.Blobs.Models.ListContainersSegmentResponse : object {
    [CompilerGeneratedAttribute]
private string <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ContainerItemInternal> <ContainerItems>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    public string ServiceEndpoint { get; }
    public string Prefix { get; }
    public string Marker { get; }
    public Nullable`1<int> MaxResults { get; }
    public IReadOnlyList`1<ContainerItemInternal> ContainerItems { get; }
    public string NextMarker { get; }
    internal ListContainersSegmentResponse(string serviceEndpoint, IEnumerable`1<ContainerItemInternal> containerItems);
    internal ListContainersSegmentResponse(string serviceEndpoint, string prefix, string marker, Nullable`1<int> maxResults, IReadOnlyList`1<ContainerItemInternal> containerItems, string nextMarker);
    [CompilerGeneratedAttribute]
public string get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Marker();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxResults();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ContainerItemInternal> get_ContainerItems();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    internal static ListContainersSegmentResponse DeserializeListContainersSegmentResponse(XElement element);
}
public class Azure.Storage.Blobs.Models.ObjectReplicationPolicy : object {
    [CompilerGeneratedAttribute]
private string <PolicyId>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ObjectReplicationRule> <Rules>k__BackingField;
    public string PolicyId { get; internal set; }
    public IList`1<ObjectReplicationRule> Rules { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_PolicyId();
    [CompilerGeneratedAttribute]
internal void set_PolicyId(string value);
    [CompilerGeneratedAttribute]
public IList`1<ObjectReplicationRule> get_Rules();
    [CompilerGeneratedAttribute]
internal void set_Rules(IList`1<ObjectReplicationRule> value);
}
public class Azure.Storage.Blobs.Models.ObjectReplicationRule : object {
    [CompilerGeneratedAttribute]
private string <RuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectReplicationStatus <ReplicationStatus>k__BackingField;
    public string RuleId { get; internal set; }
    public ObjectReplicationStatus ReplicationStatus { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_RuleId();
    [CompilerGeneratedAttribute]
internal void set_RuleId(string value);
    [CompilerGeneratedAttribute]
public ObjectReplicationStatus get_ReplicationStatus();
    [CompilerGeneratedAttribute]
internal void set_ReplicationStatus(ObjectReplicationStatus value);
}
[FlagsAttribute]
public enum Azure.Storage.Blobs.Models.ObjectReplicationStatus : Enum {
    public int value__;
    public static ObjectReplicationStatus Complete;
    public static ObjectReplicationStatus Failed;
}
public class Azure.Storage.Blobs.Models.PageBlobCreateOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobHttpHeaders <HttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private PageBlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <LegalHold>k__BackingField;
    public Nullable`1<long> SequenceNumber { get; public set; }
    public BlobHttpHeaders HttpHeaders { get; public set; }
    public PageBlobRequestConditions Conditions { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public IDictionary`2<string, string> Tags { get; public set; }
    public BlobImmutabilityPolicy ImmutabilityPolicy { get; public set; }
    public Nullable`1<bool> LegalHold { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_SequenceNumber();
    [CompilerGeneratedAttribute]
public void set_SequenceNumber(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public BlobHttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
public void set_HttpHeaders(BlobHttpHeaders value);
    [CompilerGeneratedAttribute]
public PageBlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(PageBlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public BlobImmutabilityPolicy get_ImmutabilityPolicy();
    [CompilerGeneratedAttribute]
public void set_ImmutabilityPolicy(BlobImmutabilityPolicy value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_LegalHold();
    [CompilerGeneratedAttribute]
public void set_LegalHold(Nullable`1<bool> value);
}
public class Azure.Storage.Blobs.Models.PageBlobInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlobSequenceNumber>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public long BlobSequenceNumber { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public long get_BlobSequenceNumber();
    [CompilerGeneratedAttribute]
internal void set_BlobSequenceNumber(long value);
}
public class Azure.Storage.Blobs.Models.PageBlobOpenWriteOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private PageBlobRequestConditions <OpenConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public Nullable`1<long> BufferSize { get; public set; }
    public PageBlobRequestConditions OpenConditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public Nullable`1<long> Size { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public PageBlobRequestConditions get_OpenConditions();
    [CompilerGeneratedAttribute]
public void set_OpenConditions(PageBlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
}
public class Azure.Storage.Blobs.Models.PageBlobRequestConditions : BlobRequestConditions {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IfSequenceNumberLessThan>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IfSequenceNumberLessThanOrEqual>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IfSequenceNumberEqual>k__BackingField;
    public Nullable`1<long> IfSequenceNumberLessThan { get; public set; }
    public Nullable`1<long> IfSequenceNumberLessThanOrEqual { get; public set; }
    public Nullable`1<long> IfSequenceNumberEqual { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IfSequenceNumberLessThan();
    [CompilerGeneratedAttribute]
public void set_IfSequenceNumberLessThan(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IfSequenceNumberLessThanOrEqual();
    [CompilerGeneratedAttribute]
public void set_IfSequenceNumberLessThanOrEqual(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IfSequenceNumberEqual();
    [CompilerGeneratedAttribute]
public void set_IfSequenceNumberEqual(Nullable`1<long> value);
    internal virtual void AddConditions(StringBuilder conditions);
}
public class Azure.Storage.Blobs.Models.PageBlobUploadPagesFromUriOptions : object {
    [CompilerGeneratedAttribute]
private Byte[] <SourceContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private PageBlobRequestConditions <DestinationConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private PageBlobRequestConditions <SourceConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpAuthorization <SourceAuthentication>k__BackingField;
    public Byte[] SourceContentHash { get; public set; }
    public PageBlobRequestConditions DestinationConditions { get; public set; }
    public PageBlobRequestConditions SourceConditions { get; public set; }
    public HttpAuthorization SourceAuthentication { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_SourceContentHash();
    [CompilerGeneratedAttribute]
public void set_SourceContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public PageBlobRequestConditions get_DestinationConditions();
    [CompilerGeneratedAttribute]
public void set_DestinationConditions(PageBlobRequestConditions value);
    [CompilerGeneratedAttribute]
public PageBlobRequestConditions get_SourceConditions();
    [CompilerGeneratedAttribute]
public void set_SourceConditions(PageBlobRequestConditions value);
    [CompilerGeneratedAttribute]
public HttpAuthorization get_SourceAuthentication();
    [CompilerGeneratedAttribute]
public void set_SourceAuthentication(HttpAuthorization value);
}
public class Azure.Storage.Blobs.Models.PageBlobUploadPagesOptions : object {
    [CompilerGeneratedAttribute]
private PageBlobRequestConditions <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<long> <ProgressHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadTransferValidationOptions <TransferValidation>k__BackingField;
    public PageBlobRequestConditions Conditions { get; public set; }
    public IProgress`1<long> ProgressHandler { get; public set; }
    public UploadTransferValidationOptions TransferValidation { get; public set; }
    [CompilerGeneratedAttribute]
public PageBlobRequestConditions get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(PageBlobRequestConditions value);
    [CompilerGeneratedAttribute]
public IProgress`1<long> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<long> value);
    [CompilerGeneratedAttribute]
public UploadTransferValidationOptions get_TransferValidation();
    [CompilerGeneratedAttribute]
public void set_TransferValidation(UploadTransferValidationOptions value);
}
public class Azure.Storage.Blobs.Models.PageInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentCrc64>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlobSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKeySha256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    public ETag ETag { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public Byte[] ContentHash { get; internal set; }
    public Byte[] ContentCrc64 { get; internal set; }
    public long BlobSequenceNumber { get; internal set; }
    public string EncryptionKeySha256 { get; internal set; }
    public string EncryptionScope { get; internal set; }
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentHash();
    [CompilerGeneratedAttribute]
internal void set_ContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentCrc64();
    [CompilerGeneratedAttribute]
internal void set_ContentCrc64(Byte[] value);
    [CompilerGeneratedAttribute]
public long get_BlobSequenceNumber();
    [CompilerGeneratedAttribute]
internal void set_BlobSequenceNumber(long value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKeySha256();
    [CompilerGeneratedAttribute]
internal void set_EncryptionKeySha256(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
internal void set_EncryptionScope(string value);
}
internal class Azure.Storage.Blobs.Models.PageList : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PageRange> <PageRange>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ClearRange> <ClearRange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    public IReadOnlyList`1<PageRange> PageRange { get; }
    public IReadOnlyList`1<ClearRange> ClearRange { get; }
    public string NextMarker { get; }
    internal PageList(IReadOnlyList`1<PageRange> pageRange, IReadOnlyList`1<ClearRange> clearRange, string nextMarker);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PageRange> get_PageRange();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ClearRange> get_ClearRange();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    internal static PageList DeserializePageList(XElement element);
}
[IsReadOnlyAttribute]
internal class Azure.Storage.Blobs.Models.PageRange : ValueType {
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private long <End>k__BackingField;
    public long Start { get; }
    public long End { get; }
    internal PageRange(long start, long end);
    [CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
public long get_End();
    internal static PageRange DeserializePageRange(XElement element);
    [EditorBrowsableAttribute("1")]
public sealed virtual bool Equals(PageRange other);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
public class Azure.Storage.Blobs.Models.PageRangeItem : object {
    [CompilerGeneratedAttribute]
private HttpRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClear>k__BackingField;
    public HttpRange Range { get; internal set; }
    public bool IsClear { get; internal set; }
    [CompilerGeneratedAttribute]
public HttpRange get_Range();
    [CompilerGeneratedAttribute]
internal void set_Range(HttpRange value);
    [CompilerGeneratedAttribute]
public bool get_IsClear();
    [CompilerGeneratedAttribute]
internal void set_IsClear(bool value);
}
public class Azure.Storage.Blobs.Models.PageRangesInfo : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlobContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<HttpRange> <PageRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<HttpRange> <ClearRanges>k__BackingField;
    public DateTimeOffset LastModified { get; internal set; }
    public ETag ETag { get; internal set; }
    public long BlobContentLength { get; internal set; }
    public IEnumerable`1<HttpRange> PageRanges { get; internal set; }
    public IEnumerable`1<HttpRange> ClearRanges { get; internal set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(ETag value);
    [CompilerGeneratedAttribute]
public long get_BlobContentLength();
    [CompilerGeneratedAttribute]
internal void set_BlobContentLength(long value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<HttpRange> get_PageRanges();
    [CompilerGeneratedAttribute]
internal void set_PageRanges(IEnumerable`1<HttpRange> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<HttpRange> get_ClearRanges();
    [CompilerGeneratedAttribute]
internal void set_ClearRanges(IEnumerable`1<HttpRange> value);
}
public enum Azure.Storage.Blobs.Models.PathRenameMode : Enum {
    public int value__;
    public static PathRenameMode Legacy;
    public static PathRenameMode Posix;
}
[IsReadOnlyAttribute]
internal class Azure.Storage.Blobs.Models.PremiumPageBlobAccessTier : ValueType {
    private string _value;
    private static string P4Value;
    private static string P6Value;
    private static string P10Value;
    private static string P15Value;
    private static string P20Value;
    private static string P30Value;
    private static string P40Value;
    private static string P50Value;
    private static string P60Value;
    private static string P70Value;
    private static string P80Value;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P4>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P6>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P10>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P15>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P20>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P30>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P40>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P50>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P60>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P70>k__BackingField;
    [CompilerGeneratedAttribute]
private static PremiumPageBlobAccessTier <P80>k__BackingField;
    public static PremiumPageBlobAccessTier P4 { get; }
    public static PremiumPageBlobAccessTier P6 { get; }
    public static PremiumPageBlobAccessTier P10 { get; }
    public static PremiumPageBlobAccessTier P15 { get; }
    public static PremiumPageBlobAccessTier P20 { get; }
    public static PremiumPageBlobAccessTier P30 { get; }
    public static PremiumPageBlobAccessTier P40 { get; }
    public static PremiumPageBlobAccessTier P50 { get; }
    public static PremiumPageBlobAccessTier P60 { get; }
    public static PremiumPageBlobAccessTier P70 { get; }
    public static PremiumPageBlobAccessTier P80 { get; }
    public PremiumPageBlobAccessTier(string value);
    private static PremiumPageBlobAccessTier();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P4();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P6();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P10();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P15();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P20();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P30();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P40();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P50();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P60();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P70();
    [CompilerGeneratedAttribute]
public static PremiumPageBlobAccessTier get_P80();
    public static bool op_Equality(PremiumPageBlobAccessTier left, PremiumPageBlobAccessTier right);
    public static bool op_Inequality(PremiumPageBlobAccessTier left, PremiumPageBlobAccessTier right);
    public static PremiumPageBlobAccessTier op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PremiumPageBlobAccessTier other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
public enum Azure.Storage.Blobs.Models.PublicAccessType : Enum {
    public int value__;
    public static PublicAccessType None;
    [CodeGenMemberAttribute("Container")]
public static PublicAccessType BlobContainer;
    public static PublicAccessType Blob;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.PublicAccessTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(PublicAccessType value);
    [ExtensionAttribute]
public static PublicAccessType ToPublicAccessType(string value);
}
internal class Azure.Storage.Blobs.Models.QueryFormat : object {
    [CompilerGeneratedAttribute]
private QueryFormatType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private DelimitedTextConfigurationInternal <DelimitedTextConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTextConfigurationInternal <JsonTextConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrowTextConfigurationInternal <ArrowConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ParquetTextConfiguration>k__BackingField;
    public QueryFormatType Type { get; }
    public DelimitedTextConfigurationInternal DelimitedTextConfiguration { get; public set; }
    public JsonTextConfigurationInternal JsonTextConfiguration { get; public set; }
    public ArrowTextConfigurationInternal ArrowConfiguration { get; public set; }
    public object ParquetTextConfiguration { get; public set; }
    public QueryFormat(QueryFormatType type);
    [CompilerGeneratedAttribute]
public QueryFormatType get_Type();
    [CompilerGeneratedAttribute]
public DelimitedTextConfigurationInternal get_DelimitedTextConfiguration();
    [CompilerGeneratedAttribute]
public void set_DelimitedTextConfiguration(DelimitedTextConfigurationInternal value);
    [CompilerGeneratedAttribute]
public JsonTextConfigurationInternal get_JsonTextConfiguration();
    [CompilerGeneratedAttribute]
public void set_JsonTextConfiguration(JsonTextConfigurationInternal value);
    [CompilerGeneratedAttribute]
public ArrowTextConfigurationInternal get_ArrowConfiguration();
    [CompilerGeneratedAttribute]
public void set_ArrowConfiguration(ArrowTextConfigurationInternal value);
    [CompilerGeneratedAttribute]
public object get_ParquetTextConfiguration();
    [CompilerGeneratedAttribute]
public void set_ParquetTextConfiguration(object value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
}
internal enum Azure.Storage.Blobs.Models.QueryFormatType : Enum {
    public int value__;
    public static QueryFormatType Delimited;
    public static QueryFormatType Json;
    public static QueryFormatType Arrow;
    public static QueryFormatType Parquet;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.QueryFormatTypeExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(QueryFormatType value);
    [ExtensionAttribute]
public static QueryFormatType ToQueryFormatType(string value);
}
internal class Azure.Storage.Blobs.Models.QueryRequest : object {
    [CompilerGeneratedAttribute]
private QuerySerialization <InputSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private QuerySerialization <OutputSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    public QuerySerialization InputSerialization { get; public set; }
    public QuerySerialization OutputSerialization { get; public set; }
    public string QueryType { get; public set; }
    public string Expression { get; public set; }
    public QueryRequest(string expression);
    [CompilerGeneratedAttribute]
public QuerySerialization get_InputSerialization();
    [CompilerGeneratedAttribute]
public void set_InputSerialization(QuerySerialization value);
    [CompilerGeneratedAttribute]
public QuerySerialization get_OutputSerialization();
    [CompilerGeneratedAttribute]
public void set_OutputSerialization(QuerySerialization value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    [CompilerGeneratedAttribute]
public string get_QueryType();
    [CompilerGeneratedAttribute]
public void set_QueryType(string value);
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(string value);
}
internal class Azure.Storage.Blobs.Models.QuerySerialization : object {
    [CompilerGeneratedAttribute]
private QueryFormat <Format>k__BackingField;
    public QueryFormat Format { get; }
    public QuerySerialization(QueryFormat format);
    [CompilerGeneratedAttribute]
public QueryFormat get_Format();
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
}
public enum Azure.Storage.Blobs.Models.RehydratePriority : Enum {
    public int value__;
    public static RehydratePriority High;
    public static RehydratePriority Standard;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.RehydratePriorityExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(RehydratePriority value);
    [ExtensionAttribute]
public static RehydratePriority ToRehydratePriority(string value);
}
public class Azure.Storage.Blobs.Models.ReleasedObjectInfo : object {
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    public ETag ETag { get; }
    public DateTimeOffset LastModified { get; }
    public ReleasedObjectInfo(ETag eTag, DateTimeOffset lastModified);
    internal ReleasedObjectInfo(BlobInfo info);
    internal ReleasedObjectInfo(BlobContainerInfo info);
    [CompilerGeneratedAttribute]
public ETag get_ETag();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
[CodeGenModelAttribute("SequenceNumberActionType")]
public enum Azure.Storage.Blobs.Models.SequenceNumberAction : Enum {
    public int value__;
    public static SequenceNumberAction Max;
    public static SequenceNumberAction Update;
    public static SequenceNumberAction Increment;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.SequenceNumberActionExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(SequenceNumberAction value);
    [ExtensionAttribute]
public static SequenceNumberAction ToSequenceNumberAction(string value);
}
public enum Azure.Storage.Blobs.Models.SkuName : Enum {
    public int value__;
    [CodeGenMemberAttribute("StandardLRS")]
public static SkuName StandardLrs;
    [CodeGenMemberAttribute("StandardGRS")]
public static SkuName StandardGrs;
    public static SkuName StandardRagrs;
    [CodeGenMemberAttribute("StandardZRS")]
public static SkuName StandardZrs;
    [CodeGenMemberAttribute("PremiumLRS")]
public static SkuName PremiumLrs;
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.Models.SkuNameExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(SkuName value);
    [ExtensionAttribute]
public static SkuName ToSkuName(string value);
}
public class Azure.Storage.Blobs.Models.StageBlockFromUriOptions : object {
    [CompilerGeneratedAttribute]
private HttpRange <SourceRange>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SourceContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestConditions <SourceConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobRequestConditions <DestinationConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpAuthorization <SourceAuthentication>k__BackingField;
    public HttpRange SourceRange { get; public set; }
    public Byte[] SourceContentHash { get; public set; }
    public RequestConditions SourceConditions { get; public set; }
    public BlobRequestConditions DestinationConditions { get; public set; }
    public HttpAuthorization SourceAuthentication { get; public set; }
    [CompilerGeneratedAttribute]
public HttpRange get_SourceRange();
    [CompilerGeneratedAttribute]
public void set_SourceRange(HttpRange value);
    [CompilerGeneratedAttribute]
public Byte[] get_SourceContentHash();
    [CompilerGeneratedAttribute]
public void set_SourceContentHash(Byte[] value);
    [CompilerGeneratedAttribute]
public RequestConditions get_SourceConditions();
    [CompilerGeneratedAttribute]
public void set_SourceConditions(RequestConditions value);
    [CompilerGeneratedAttribute]
public BlobRequestConditions get_DestinationConditions();
    [CompilerGeneratedAttribute]
public void set_DestinationConditions(BlobRequestConditions value);
    [CompilerGeneratedAttribute]
public HttpAuthorization get_SourceAuthentication();
    [CompilerGeneratedAttribute]
public void set_SourceAuthentication(HttpAuthorization value);
}
internal class Azure.Storage.Blobs.Models.StorageError : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    internal StorageError(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    internal static StorageError DeserializeStorageError(XElement element);
}
public class Azure.Storage.Blobs.Models.TaggedBlobItem : object {
    [CompilerGeneratedAttribute]
private string <BlobName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlobContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    public string BlobName { get; internal set; }
    public string BlobContainerName { get; internal set; }
    public IDictionary`2<string, string> Tags { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_BlobName();
    [CompilerGeneratedAttribute]
internal void set_BlobName(string value);
    [CompilerGeneratedAttribute]
public string get_BlobContainerName();
    [CompilerGeneratedAttribute]
internal void set_BlobContainerName(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(IDictionary`2<string, string> value);
}
public class Azure.Storage.Blobs.Models.UserDelegationKey : object {
    [CompilerGeneratedAttribute]
private string <SignedObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignedTenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignedExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignedStartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignedService>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CodeGenMemberAttribute("SignedOid")]
public string SignedObjectId { get; internal set; }
    [CodeGenMemberAttribute("SignedTid")]
public string SignedTenantId { get; internal set; }
    [CodeGenMemberAttribute("SignedExpiry")]
public DateTimeOffset SignedExpiresOn { get; internal set; }
    [CodeGenMemberAttribute("SignedStart")]
public DateTimeOffset SignedStartsOn { get; internal set; }
    public string SignedService { get; internal set; }
    public string SignedVersion { get; internal set; }
    public string Value { get; internal set; }
    internal UserDelegationKey(string signedObjectId, string signedTenantId, DateTimeOffset signedStartsOn, DateTimeOffset signedExpiresOn, string signedService, string signedVersion, string value);
    internal static UserDelegationKey DeserializeUserDelegationKey(XElement element);
    [CompilerGeneratedAttribute]
public string get_SignedObjectId();
    [CompilerGeneratedAttribute]
internal void set_SignedObjectId(string value);
    [CompilerGeneratedAttribute]
public string get_SignedTenantId();
    [CompilerGeneratedAttribute]
internal void set_SignedTenantId(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignedExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_SignedExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignedStartsOn();
    [CompilerGeneratedAttribute]
internal void set_SignedStartsOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_SignedService();
    [CompilerGeneratedAttribute]
internal void set_SignedService(string value);
    [CompilerGeneratedAttribute]
public string get_SignedVersion();
    [CompilerGeneratedAttribute]
internal void set_SignedVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(string value);
}
internal class Azure.Storage.Blobs.PageBlobClearPagesHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public Byte[] XMsContentCrc64 { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public string Version { get; }
    public PageBlobClearPagesHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public Byte[] get_XMsContentCrc64();
    public Nullable`1<long> get_BlobSequenceNumber();
    public string get_Version();
}
internal class Azure.Storage.Blobs.PageBlobCopyIncrementalHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public string Version { get; }
    public string CopyId { get; }
    public Nullable`1<CopyStatus> CopyStatus { get; }
    public PageBlobCopyIncrementalHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public string get_Version();
    public string get_CopyId();
    public Nullable`1<CopyStatus> get_CopyStatus();
}
internal class Azure.Storage.Blobs.PageBlobCreateHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public string Version { get; }
    public string VersionId { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public PageBlobCreateHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public string get_Version();
    public string get_VersionId();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.PageBlobGetPageRangesDiffHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<long> BlobContentLength { get; }
    public string Version { get; }
    public PageBlobGetPageRangesDiffHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<long> get_BlobContentLength();
    public string get_Version();
}
internal class Azure.Storage.Blobs.PageBlobGetPageRangesHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<long> BlobContentLength { get; }
    public string Version { get; }
    public PageBlobGetPageRangesHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<long> get_BlobContentLength();
    public string get_Version();
}
internal class Azure.Storage.Blobs.PageBlobResizeHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public string Version { get; }
    public PageBlobResizeHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<long> get_BlobSequenceNumber();
    public string get_Version();
}
internal class Azure.Storage.Blobs.PageBlobRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public PageBlobRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateCreateRequest(long contentLength, long blobContentLength, Nullable`1<int> timeout, Nullable`1<PremiumPageBlobAccessTier> tier, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<CreateAsync>d__8")]
public Task`1<ResponseWithHeaders`1<PageBlobCreateHeaders>> CreateAsync(long contentLength, long blobContentLength, Nullable`1<int> timeout, Nullable`1<PremiumPageBlobAccessTier> tier, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PageBlobCreateHeaders> Create(long contentLength, long blobContentLength, Nullable`1<int> timeout, Nullable`1<PremiumPageBlobAccessTier> tier, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken);
    internal HttpMessage CreateUploadPagesRequest(long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<UploadPagesAsync>d__11")]
public Task`1<ResponseWithHeaders`1<PageBlobUploadPagesHeaders>> UploadPagesAsync(long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PageBlobUploadPagesHeaders> UploadPages(long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateClearPagesRequest(long contentLength, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<ClearPagesAsync>d__14")]
public Task`1<ResponseWithHeaders`1<PageBlobClearPagesHeaders>> ClearPagesAsync(long contentLength, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PageBlobClearPagesHeaders> ClearPages(long contentLength, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateUploadPagesFromURLRequest(string sourceUrl, string sourceRange, long contentLength, string range, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<UploadPagesFromURLAsync>d__17")]
public Task`1<ResponseWithHeaders`1<PageBlobUploadPagesFromURLHeaders>> UploadPagesFromURLAsync(string sourceUrl, string sourceRange, long contentLength, string range, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PageBlobUploadPagesFromURLHeaders> UploadPagesFromURL(string sourceUrl, string sourceRange, long contentLength, string range, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPageRangesRequest(string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<GetPageRangesAsync>d__20")]
public Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders>> GetPageRangesAsync(string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders> GetPageRanges(string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPageRangesDiffRequest(string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<GetPageRangesDiffAsync>d__23")]
public Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders>> GetPageRangesDiffAsync(string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders> GetPageRangesDiff(string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken);
    internal HttpMessage CreateResizeRequest(long blobContentLength, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<ResizeAsync>d__26")]
public Task`1<ResponseWithHeaders`1<PageBlobResizeHeaders>> ResizeAsync(long blobContentLength, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PageBlobResizeHeaders> Resize(long blobContentLength, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateUpdateSequenceNumberRequest(SequenceNumberAction sequenceNumberAction, Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<UpdateSequenceNumberAsync>d__29")]
public Task`1<ResponseWithHeaders`1<PageBlobUpdateSequenceNumberHeaders>> UpdateSequenceNumberAsync(SequenceNumberAction sequenceNumberAction, Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PageBlobUpdateSequenceNumberHeaders> UpdateSequenceNumber(SequenceNumberAction sequenceNumberAction, Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, CancellationToken cancellationToken);
    internal HttpMessage CreateCopyIncrementalRequest(string copySource, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<CopyIncrementalAsync>d__32")]
public Task`1<ResponseWithHeaders`1<PageBlobCopyIncrementalHeaders>> CopyIncrementalAsync(string copySource, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<PageBlobCopyIncrementalHeaders> CopyIncremental(string copySource, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPageRangesNextPageRequest(string nextLink, string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<GetPageRangesNextPageAsync>d__35")]
public Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders>> GetPageRangesNextPageAsync(string nextLink, string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders> GetPageRangesNextPage(string nextLink, string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPageRangesDiffNextPageRequest(string nextLink, string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobRestClient/<GetPageRangesDiffNextPageAsync>d__38")]
public Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders>> GetPageRangesDiffNextPageAsync(string nextLink, string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders> GetPageRangesDiffNextPage(string nextLink, string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken);
}
internal class Azure.Storage.Blobs.PageBlobUpdateSequenceNumberHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public string Version { get; }
    public PageBlobUpdateSequenceNumberHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Nullable`1<long> get_BlobSequenceNumber();
    public string get_Version();
}
internal class Azure.Storage.Blobs.PageBlobUploadPagesFromURLHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public Byte[] XMsContentCrc64 { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public PageBlobUploadPagesFromURLHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public Byte[] get_XMsContentCrc64();
    public Nullable`1<long> get_BlobSequenceNumber();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.PageBlobUploadPagesHeaders : object {
    private Response _response;
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public Byte[] ContentMD5 { get; }
    public Byte[] XMsContentCrc64 { get; }
    public Nullable`1<long> BlobSequenceNumber { get; }
    public string Version { get; }
    public Nullable`1<bool> IsServerEncrypted { get; }
    public string EncryptionKeySha256 { get; }
    public string EncryptionScope { get; }
    public PageBlobUploadPagesHeaders(Response response);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public Byte[] get_ContentMD5();
    public Byte[] get_XMsContentCrc64();
    public Nullable`1<long> get_BlobSequenceNumber();
    public string get_Version();
    public Nullable`1<bool> get_IsServerEncrypted();
    public string get_EncryptionKeySha256();
    public string get_EncryptionScope();
}
internal class Azure.Storage.Blobs.PageBlobWriteStream : StorageWriteStream {
    private PageBlobClient _pageBlobClient;
    private PageBlobRequestConditions _conditions;
    private long _writeIndex;
    public PageBlobWriteStream(PageBlobClient pageBlobClient, long bufferSize, long position, PageBlobRequestConditions conditions, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidation);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PageBlobWriteStream/<AppendInternal>d__4")]
protected virtual Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    protected virtual void ValidateBufferSize(long bufferSize);
    private static void ValidatePosition(long position);
}
internal class Azure.Storage.Blobs.PartitionedDownloader : object {
    private static string _operationName;
    private static string _innerOperationName;
    private BlobBaseClient _client;
    private int _maxWorkerCount;
    private long _initialRangeSize;
    private long _rangeSize;
    private StorageChecksumAlgorithm _validationAlgorithm;
    private int _checksumSize;
    private StorageCrc64HashAlgorithm _masterCrcCalculator;
    private IProgress`1<long> _progress;
    private ArrayPool`1<byte> _arrayPool;
    private bool UseMasterCrc { get; }
    private DownloadTransferValidationOptions ValidationOptions { get; }
    public PartitionedDownloader(BlobBaseClient client, StorageTransferOptions transferOptions, DownloadTransferValidationOptions transferValidation, IProgress`1<long> progress, ArrayPool`1<byte> arrayPool);
    private bool get_UseMasterCrc();
    private DownloadTransferValidationOptions get_ValidationOptions();
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PartitionedDownloader/<DownloadToInternal>d__16")]
public Task`1<Response> DownloadToInternal(Stream destination, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PartitionedDownloader/<HandleOneShotDownload>d__17")]
private Task HandleOneShotDownload(Response`1<BlobDownloadStreamingResult> response, Stream destination, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PartitionedDownloader/<FinalizeDownloadInternal>d__18")]
private Task FinalizeDownloadInternal(Stream destination, Memory`1<byte> composedCrc, bool async, CancellationToken cancellationToken);
    private static long ParseRangeTotalLength(string range);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PartitionedDownloader/<CopyToInternal>d__20")]
private Task CopyToInternal(Response`1<BlobDownloadStreamingResult> response, Stream destination, Memory`1<byte> checksumBuffer, bool async, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Azure.Storage.Blobs.PartitionedDownloader/<GetRanges>d__21")]
private IEnumerable`1<HttpRange> GetRanges(long initialLength, long totalLength);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.PartitionedDownloader/<FlushFinalIfNecessaryInternal>d__22")]
private Task FlushFinalIfNecessaryInternal(Stream destination, bool async, CancellationToken cancellationToken);
    private void ValidateFinalCrc(ReadOnlySpan`1<byte> composedCrc);
}
[ExtensionAttribute]
internal static class Azure.Storage.Blobs.QuickQueryExtensions : object {
    [ExtensionAttribute]
internal static QuerySerialization ToQuickQuerySerialization(BlobQueryTextOptions textConfiguration, bool isInput);
    [ExtensionAttribute]
internal static ArrowFieldInternal ToArrowFieldInternal(BlobQueryArrowField blobQueryArrowField);
    [ExtensionAttribute]
internal static string ToArrowFiledInternalType(BlobQueryArrowFieldType blobQueryArrowFieldType);
}
internal class Azure.Storage.Blobs.ServiceFilterBlobsHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceFilterBlobsHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ServiceGetAccountInfoHeaders : object {
    private Response _response;
    public string Version { get; }
    public Nullable`1<SkuName> SkuName { get; }
    public Nullable`1<AccountKind> AccountKind { get; }
    public Nullable`1<bool> IsHierarchicalNamespaceEnabled { get; }
    public ServiceGetAccountInfoHeaders(Response response);
    public string get_Version();
    public Nullable`1<SkuName> get_SkuName();
    public Nullable`1<AccountKind> get_AccountKind();
    public Nullable`1<bool> get_IsHierarchicalNamespaceEnabled();
}
internal class Azure.Storage.Blobs.ServiceGetPropertiesHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceGetPropertiesHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ServiceGetStatisticsHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceGetStatisticsHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ServiceGetUserDelegationKeyHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceGetUserDelegationKeyHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ServiceListContainersSegmentHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceListContainersSegmentHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ServiceRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public ServiceRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateSetPropertiesRequest(BlobServiceProperties storageServiceProperties, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ServiceRestClient/<SetPropertiesAsync>d__8")]
public Task`1<ResponseWithHeaders`1<ServiceSetPropertiesHeaders>> SetPropertiesAsync(BlobServiceProperties storageServiceProperties, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ServiceSetPropertiesHeaders> SetProperties(BlobServiceProperties storageServiceProperties, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ServiceRestClient/<GetPropertiesAsync>d__11")]
public Task`1<ResponseWithHeaders`2<BlobServiceProperties, ServiceGetPropertiesHeaders>> GetPropertiesAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<BlobServiceProperties, ServiceGetPropertiesHeaders> GetProperties(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateGetStatisticsRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ServiceRestClient/<GetStatisticsAsync>d__14")]
public Task`1<ResponseWithHeaders`2<BlobServiceStatistics, ServiceGetStatisticsHeaders>> GetStatisticsAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<BlobServiceStatistics, ServiceGetStatisticsHeaders> GetStatistics(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateListContainersSegmentRequest(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ServiceRestClient/<ListContainersSegmentAsync>d__17")]
public Task`1<ResponseWithHeaders`2<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders>> ListContainersSegmentAsync(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders> ListContainersSegment(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateGetUserDelegationKeyRequest(KeyInfo keyInfo, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ServiceRestClient/<GetUserDelegationKeyAsync>d__20")]
public Task`1<ResponseWithHeaders`2<UserDelegationKey, ServiceGetUserDelegationKeyHeaders>> GetUserDelegationKeyAsync(KeyInfo keyInfo, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<UserDelegationKey, ServiceGetUserDelegationKeyHeaders> GetUserDelegationKey(KeyInfo keyInfo, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateGetAccountInfoRequest();
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ServiceRestClient/<GetAccountInfoAsync>d__23")]
public Task`1<ResponseWithHeaders`1<ServiceGetAccountInfoHeaders>> GetAccountInfoAsync(CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ServiceGetAccountInfoHeaders> GetAccountInfo(CancellationToken cancellationToken);
    internal HttpMessage CreateSubmitBatchRequest(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ServiceRestClient/<SubmitBatchAsync>d__26")]
public Task`1<ResponseWithHeaders`2<Stream, ServiceSubmitBatchHeaders>> SubmitBatchAsync(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<Stream, ServiceSubmitBatchHeaders> SubmitBatch(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateFilterBlobsRequest(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ServiceRestClient/<FilterBlobsAsync>d__29")]
public Task`1<ResponseWithHeaders`2<FilterBlobSegment, ServiceFilterBlobsHeaders>> FilterBlobsAsync(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<FilterBlobSegment, ServiceFilterBlobsHeaders> FilterBlobs(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include, CancellationToken cancellationToken);
    internal HttpMessage CreateListContainersSegmentNextPageRequest(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.ServiceRestClient/<ListContainersSegmentNextPageAsync>d__32")]
public Task`1<ResponseWithHeaders`2<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders>> ListContainersSegmentNextPageAsync(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders> ListContainersSegmentNextPage(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
}
internal class Azure.Storage.Blobs.ServiceSetPropertiesHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceSetPropertiesHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Blobs.ServiceSubmitBatchHeaders : object {
    private Response _response;
    public string ContentType { get; }
    public string Version { get; }
    public ServiceSubmitBatchHeaders(Response response);
    public string get_ContentType();
    public string get_Version();
}
public class Azure.Storage.Blobs.Specialized.AppendBlobClient : BlobBaseClient {
    private AppendBlobRestClient _appendBlobRestClient;
    public int AppendBlobMaxAppendBlockBytes { get; }
    public int AppendBlobMaxBlocks { get; }
    internal AppendBlobRestClient AppendBlobRestClient { get; }
    public AppendBlobClient(string connectionString, string blobContainerName, string blobName);
    public AppendBlobClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options);
    public AppendBlobClient(Uri blobUri, BlobClientOptions options);
    public AppendBlobClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options);
    public AppendBlobClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options);
    public AppendBlobClient(Uri blobUri, TokenCredential credential, BlobClientOptions options);
    internal AppendBlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration);
    public virtual int get_AppendBlobMaxAppendBlockBytes();
    public virtual int get_AppendBlobMaxBlocks();
    internal virtual AppendBlobRestClient get_AppendBlobRestClient();
    private static void AssertNoClientSideEncryption(BlobClientOptions options);
    private AppendBlobRestClient BuildAppendBlobRestClient(Uri blobUri);
    public AppendBlobClient WithSnapshot(string snapshot);
    public AppendBlobClient WithVersion(string versionId);
    public AppendBlobClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey);
    public AppendBlobClient WithEncryptionScope(string encryptionScope);
    public virtual Response`1<BlobContentInfo> Create(AppendBlobCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<CreateAsync>d__22")]
public virtual Task`1<Response`1<BlobContentInfo>> CreateAsync(AppendBlobCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContentInfo> Create(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, AppendBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<CreateAsync>d__24")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContentInfo>> CreateAsync(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, AppendBlobRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> CreateIfNotExists(AppendBlobCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<CreateIfNotExistsAsync>d__26")]
public virtual Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsAsync(AppendBlobCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContentInfo> CreateIfNotExists(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<CreateIfNotExistsAsync>d__28")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsAsync(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<CreateIfNotExistsInternal>d__29")]
private Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsInternal(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<CreateInternal>d__30")]
private Task`1<Response`1<BlobContentInfo>> CreateInternal(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, AppendBlobRequestConditions conditions, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken, string operationName);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobAppendInfo> AppendBlock(Stream content, Byte[] transactionalContentHash, AppendBlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<AppendBlockAsync>d__32")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobAppendInfo>> AppendBlockAsync(Stream content, Byte[] transactionalContentHash, AppendBlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    public virtual Response`1<BlobAppendInfo> AppendBlock(Stream content, AppendBlobAppendBlockOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<AppendBlockAsync>d__34")]
public virtual Task`1<Response`1<BlobAppendInfo>> AppendBlockAsync(Stream content, AppendBlobAppendBlockOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<AppendBlockInternal>d__35")]
internal Task`1<Response`1<BlobAppendInfo>> AppendBlockInternal(Stream content, UploadTransferValidationOptions transferValidationOverride, AppendBlobRequestConditions conditions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobAppendInfo> AppendBlockFromUri(Uri sourceUri, AppendBlobAppendBlockFromUriOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<AppendBlockFromUriAsync>d__37")]
public virtual Task`1<Response`1<BlobAppendInfo>> AppendBlockFromUriAsync(Uri sourceUri, AppendBlobAppendBlockFromUriOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobAppendInfo> AppendBlockFromUri(Uri sourceUri, HttpRange sourceRange, Byte[] sourceContentHash, AppendBlobRequestConditions conditions, AppendBlobRequestConditions sourceConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<AppendBlockFromUriAsync>d__39")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobAppendInfo>> AppendBlockFromUriAsync(Uri sourceUri, HttpRange sourceRange, Byte[] sourceContentHash, AppendBlobRequestConditions conditions, AppendBlobRequestConditions sourceConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<AppendBlockFromUriInternal>d__40")]
private Task`1<Response`1<BlobAppendInfo>> AppendBlockFromUriInternal(Uri sourceUri, HttpRange sourceRange, Byte[] sourceContentHash, AppendBlobRequestConditions conditions, AppendBlobRequestConditions sourceConditions, HttpAuthorization sourceAuthentication, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobInfo> Seal(AppendBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<SealAsync>d__42")]
public virtual Task`1<Response`1<BlobInfo>> SealAsync(AppendBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<SealInternal>d__43")]
private Task`1<Response`1<BlobInfo>> SealInternal(AppendBlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Stream OpenWrite(bool overwrite, AppendBlobOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<OpenWriteAsync>d__45")]
public virtual Task`1<Stream> OpenWriteAsync(bool overwrite, AppendBlobOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.AppendBlobClient/<OpenWriteInternal>d__46")]
private Task`1<Stream> OpenWriteInternal(bool overwrite, AppendBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken);
}
public class Azure.Storage.Blobs.Specialized.BlobBaseClient : object {
    private protected Uri _uri;
    internal BlobClientConfiguration _clientConfiguration;
    private ClientSideEncryptionOptions _clientSideEncryption;
    private string _snapshot;
    private string _blobVersionId;
    private string _accountName;
    private string _containerName;
    private string _name;
    private BlobRestClient _blobRestClient;
    private BlobContainerClient _parentBlobContainerClient;
    public Uri Uri { get; }
    internal BlobClientConfiguration ClientConfiguration { get; }
    internal ClientSideEncryptionOptions ClientSideEncryption { get; }
    internal bool UsingClientSideEncryption { get; }
    public string AccountName { get; }
    public string BlobContainerName { get; }
    public string Name { get; }
    public bool CanGenerateSasUri { get; }
    internal BlobRestClient BlobRestClient { get; }
    public BlobBaseClient(string connectionString, string blobContainerName, string blobName);
    public BlobBaseClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options);
    public BlobBaseClient(Uri blobUri, BlobClientOptions options);
    public BlobBaseClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options);
    public BlobBaseClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options);
    public BlobBaseClient(Uri blobUri, TokenCredential credential, BlobClientOptions options);
    internal BlobBaseClient(Uri blobUri, HttpPipelinePolicy authentication, BlobClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    internal BlobBaseClient(Uri blobUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption);
    public virtual Uri get_Uri();
    internal virtual BlobClientConfiguration get_ClientConfiguration();
    internal virtual ClientSideEncryptionOptions get_ClientSideEncryption();
    internal virtual bool get_UsingClientSideEncryption();
    public virtual string get_AccountName();
    public virtual string get_BlobContainerName();
    public virtual string get_Name();
    public virtual bool get_CanGenerateSasUri();
    internal virtual BlobRestClient get_BlobRestClient();
    private BlobRestClient BuildBlobRestClient(Uri blobUri);
    public virtual BlobBaseClient WithSnapshot(string snapshot);
    protected virtual BlobBaseClient WithSnapshotCore(string snapshot);
    public virtual BlobBaseClient WithVersion(string versionId);
    private protected virtual BlobBaseClient WithVersionCore(string versionId);
    public virtual BlobBaseClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey);
    private protected virtual BlobBaseClient WithCustomerProvidedKeyCore(Nullable`1<CustomerProvidedKey> customerProvidedKey);
    public virtual BlobBaseClient WithEncryptionScope(string encryptionScope);
    private protected virtual BlobBaseClient WithEncryptionScopeCore(string encryptionScope);
    protected internal virtual BlobLeaseClient GetBlobLeaseClientCore(string leaseId);
    private void SetNameFieldsIfNull();
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<GetCopyAuthorizationHeaderAsync>d__47")]
protected static Task`1<HttpAuthorization> GetCopyAuthorizationHeaderAsync(BlobBaseClient client, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobDownloadInfo> Download();
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadAsync>d__49")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobDownloadInfo>> DownloadAsync();
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobDownloadInfo> Download(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadAsync>d__51")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobDownloadInfo>> DownloadAsync(CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobDownloadInfo> Download(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadAsync>d__53")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobDownloadInfo>> DownloadAsync(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadInternal>d__54")]
private Task`1<Response`1<BlobDownloadInfo>> DownloadInternal(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, bool async, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobDownloadStreamingResult> DownloadStreaming(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadStreamingAsync>d__56")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingAsync(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobDownloadStreamingResult> DownloadStreaming(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadStreamingAsync>d__58")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingAsync(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    public virtual Response`1<BlobDownloadStreamingResult> DownloadStreaming(BlobDownloadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadStreamingAsync>d__60")]
public virtual Task`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingAsync(BlobDownloadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadStreamingDirect>d__61")]
private ValueTask`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingDirect(HttpRange range, BlobRequestConditions conditions, DownloadTransferValidationOptions transferValidationOverride, IProgress`1<long> progressHandler, string operationName, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadStreamingInternal>d__62")]
internal virtual ValueTask`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingInternal(HttpRange range, BlobRequestConditions conditions, DownloadTransferValidationOptions transferValidationOverride, IProgress`1<long> progressHandler, string operationName, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<StartDownloadAsync>d__63")]
private ValueTask`1<Response`1<BlobDownloadStreamingResult>> StartDownloadAsync(HttpRange range, BlobRequestConditions conditions, DownloadTransferValidationOptions validationOptions, long startOffset, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobDownloadResult> DownloadContent();
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadContentAsync>d__65")]
public virtual Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync();
    public virtual Response`1<BlobDownloadResult> DownloadContent(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadContentAsync>d__67")]
public virtual Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync(CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobDownloadResult> DownloadContent(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadContentAsync>d__69")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobDownloadResult> DownloadContent(BlobRequestConditions conditions, IProgress`1<long> progressHandler, HttpRange range, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadContentAsync>d__71")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync(BlobRequestConditions conditions, IProgress`1<long> progressHandler, HttpRange range, CancellationToken cancellationToken);
    public virtual Response`1<BlobDownloadResult> DownloadContent(BlobDownloadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadContentAsync>d__73")]
public virtual Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync(BlobDownloadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadContentInternal>d__74")]
private Task`1<Response`1<BlobDownloadResult>> DownloadContentInternal(BlobRequestConditions conditions, IProgress`1<long> progressHandler, HttpRange range, DownloadTransferValidationOptions transferValidationOverride, bool async, CancellationToken cancellationToken);
    public virtual Response DownloadTo(Stream destination);
    public virtual Response DownloadTo(string path);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadToAsync>d__77")]
public virtual Task`1<Response> DownloadToAsync(Stream destination);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadToAsync>d__78")]
public virtual Task`1<Response> DownloadToAsync(string path);
    public virtual Response DownloadTo(Stream destination, CancellationToken cancellationToken);
    public virtual Response DownloadTo(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadToAsync>d__81")]
public virtual Task`1<Response> DownloadToAsync(Stream destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadToAsync>d__82")]
public virtual Task`1<Response> DownloadToAsync(string path, CancellationToken cancellationToken);
    public virtual Response DownloadTo(Stream destination, BlobDownloadToOptions options, CancellationToken cancellationToken);
    public virtual Response DownloadTo(string path, BlobDownloadToOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadToAsync>d__85")]
public virtual Task`1<Response> DownloadToAsync(Stream destination, BlobDownloadToOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadToAsync>d__86")]
public virtual Task`1<Response> DownloadToAsync(string path, BlobDownloadToOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response DownloadTo(Stream destination, BlobRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response DownloadTo(string path, BlobRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadToAsync>d__89")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> DownloadToAsync(Stream destination, BlobRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DownloadToAsync>d__90")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response> DownloadToAsync(string path, BlobRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<StagedDownloadAsync>d__91")]
internal Task`1<Response> StagedDownloadAsync(Stream destination, BlobRequestConditions conditions, IProgress`1<long> progressHandler, StorageTransferOptions transferOptions, DownloadTransferValidationOptions transferValidationOverride, bool async, CancellationToken cancellationToken);
    public virtual Stream OpenRead(BlobOpenReadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<OpenReadAsync>d__93")]
public virtual Task`1<Stream> OpenReadAsync(BlobOpenReadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Stream OpenRead(long position, Nullable`1<int> bufferSize, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Stream OpenRead(bool allowBlobModifications, long position, Nullable`1<int> bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<OpenReadAsync>d__96")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Stream> OpenReadAsync(long position, Nullable`1<int> bufferSize, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<OpenReadAsync>d__97")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Stream> OpenReadAsync(bool allowBlobModifications, long position, Nullable`1<int> bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<OpenReadInternal>d__98")]
internal Task`1<Stream> OpenReadInternal(long position, Nullable`1<int> bufferSize, BlobRequestConditions conditions, bool allowModifications, DownloadTransferValidationOptions transferValidationOverride, bool async, CancellationToken cancellationToken);
    public virtual CopyFromUriOperation StartCopyFromUri(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual CopyFromUriOperation StartCopyFromUri(Uri source, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, Nullable`1<RehydratePriority> rehydratePriority, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<StartCopyFromUriAsync>d__101")]
public virtual Task`1<CopyFromUriOperation> StartCopyFromUriAsync(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<StartCopyFromUriAsync>d__102")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<CopyFromUriOperation> StartCopyFromUriAsync(Uri source, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, Nullable`1<RehydratePriority> rehydratePriority, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<StartCopyFromUriInternal>d__103")]
private Task`1<Response`1<BlobCopyInfo>> StartCopyFromUriInternal(Uri source, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, Nullable`1<AccessTier> accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<bool> sealBlob, BlobImmutabilityPolicy destinationImmutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken);
    public virtual Response AbortCopyFromUri(string copyId, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<AbortCopyFromUriAsync>d__105")]
public virtual Task`1<Response> AbortCopyFromUriAsync(string copyId, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<AbortCopyFromUriInternal>d__106")]
private Task`1<Response> AbortCopyFromUriInternal(string copyId, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobCopyInfo> SyncCopyFromUri(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SyncCopyFromUriAsync>d__108")]
public virtual Task`1<Response`1<BlobCopyInfo>> SyncCopyFromUriAsync(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SyncCopyFromUriInternal>d__109")]
private Task`1<Response`1<BlobCopyInfo>> SyncCopyFromUriInternal(Uri source, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, Nullable`1<AccessTier> accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, BlobImmutabilityPolicy destinationImmutabilityPolicy, Nullable`1<bool> legalHold, HttpAuthorization sourceAuthentication, Nullable`1<BlobCopySourceTagsMode> copySourceTags, bool async, CancellationToken cancellationToken);
    public virtual Response Delete(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DeleteAsync>d__111")]
public virtual Task`1<Response> DeleteAsync(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<bool> DeleteIfExists(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DeleteIfExistsAsync>d__113")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DeleteIfExistsInternal>d__114")]
internal Task`1<Response`1<bool>> DeleteIfExistsInternal(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DeleteInternal>d__115")]
private Task`1<Response> DeleteInternal(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<bool> Exists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<ExistsAsync>d__117")]
public virtual Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<ExistsInternal>d__118")]
private Task`1<Response`1<bool>> ExistsInternal(bool async, CancellationToken cancellationToken);
    public virtual Response Undelete(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<UndeleteAsync>d__120")]
public virtual Task`1<Response> UndeleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<UndeleteInternal>d__121")]
private Task`1<Response> UndeleteInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobProperties> GetProperties(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<GetPropertiesAsync>d__123")]
public virtual Task`1<Response`1<BlobProperties>> GetPropertiesAsync(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<GetPropertiesInternal>d__124")]
internal Task`1<Response`1<BlobProperties>> GetPropertiesInternal(BlobRequestConditions conditions, bool async, RequestContext context, string operationName);
    public virtual Response`1<BlobInfo> SetHttpHeaders(BlobHttpHeaders httpHeaders, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetHttpHeadersAsync>d__126")]
public virtual Task`1<Response`1<BlobInfo>> SetHttpHeadersAsync(BlobHttpHeaders httpHeaders, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetHttpHeadersInternal>d__127")]
private Task`1<Response`1<BlobInfo>> SetHttpHeadersInternal(BlobHttpHeaders httpHeaders, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobInfo> SetMetadata(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetMetadataAsync>d__129")]
public virtual Task`1<Response`1<BlobInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetMetadataInternal>d__130")]
internal Task`1<Response`1<BlobInfo>> SetMetadataInternal(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobSnapshotInfo> CreateSnapshot(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<CreateSnapshotAsync>d__132")]
public virtual Task`1<Response`1<BlobSnapshotInfo>> CreateSnapshotAsync(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<CreateSnapshotInternal>d__133")]
private Task`1<Response`1<BlobSnapshotInfo>> CreateSnapshotInternal(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response SetAccessTier(AccessTier accessTier, BlobRequestConditions conditions, Nullable`1<RehydratePriority> rehydratePriority, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetAccessTierAsync>d__135")]
public virtual Task`1<Response> SetAccessTierAsync(AccessTier accessTier, BlobRequestConditions conditions, Nullable`1<RehydratePriority> rehydratePriority, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetAccessTierInternal>d__136")]
private Task`1<Response> SetAccessTierInternal(AccessTier accessTier, BlobRequestConditions conditions, Nullable`1<RehydratePriority> rehydratePriority, bool async, CancellationToken cancellationToken);
    public virtual Response`1<GetBlobTagResult> GetTags(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<GetTagsAsync>d__138")]
public virtual Task`1<Response`1<GetBlobTagResult>> GetTagsAsync(BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<GetTagsInternal>d__139")]
private Task`1<Response`1<GetBlobTagResult>> GetTagsInternal(bool async, BlobRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response SetTags(IDictionary`2<string, string> tags, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetTagsAsync>d__141")]
public virtual Task`1<Response> SetTagsAsync(IDictionary`2<string, string> tags, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetTagsInternal>d__142")]
private Task`1<Response> SetTagsInternal(IDictionary`2<string, string> tags, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobImmutabilityPolicy> SetImmutabilityPolicy(BlobImmutabilityPolicy immutabilityPolicy, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetImmutabilityPolicyAsync>d__144")]
public virtual Task`1<Response`1<BlobImmutabilityPolicy>> SetImmutabilityPolicyAsync(BlobImmutabilityPolicy immutabilityPolicy, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetImmutabilityPolicyInternal>d__145")]
private Task`1<Response`1<BlobImmutabilityPolicy>> SetImmutabilityPolicyInternal(BlobImmutabilityPolicy immutabilityPolicy, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response DeleteImmutabilityPolicy(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DeleteImmutabilityPolicyAsync>d__147")]
public virtual Task`1<Response> DeleteImmutabilityPolicyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<DeleteImmutabilityPolicyInternal>d__148")]
private Task`1<Response> DeleteImmutabilityPolicyInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobLegalHoldResult> SetLegalHold(bool hasLegalHold, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetLegalHoldAsync>d__150")]
public virtual Task`1<Response`1<BlobLegalHoldResult>> SetLegalHoldAsync(bool hasLegalHold, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<SetLegalHoldInternal>d__151")]
private Task`1<Response`1<BlobLegalHoldResult>> SetLegalHoldInternal(bool hasLegalHold, bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute]
public virtual Uri GenerateSasUri(BlobSasPermissions permissions, DateTimeOffset expiresOn);
    [CallerShouldAuditAttribute]
public virtual Uri GenerateSasUri(BlobSasBuilder builder);
    protected internal virtual BlobContainerClient GetParentBlobContainerClientCore();
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobBaseClient/<<OpenReadInternal>b__98_2>d")]
[CompilerGeneratedAttribute]
private Task`1<Response`1<BlobProperties>> <OpenReadInternal>b__98_2(bool async, CancellationToken cancellationToken);
}
public class Azure.Storage.Blobs.Specialized.BlobLeaseClient : object {
    private BlobBaseClient _blob;
    private BlobContainerClient _container;
    private string _leaseId;
    public static TimeSpan InfiniteLeaseDuration;
    protected BlobBaseClient BlobClient { get; }
    protected BlobContainerClient BlobContainerClient { get; }
    public Uri Uri { get; }
    public string LeaseId { get; private set; }
    private HttpPipeline Pipeline { get; }
    internal ServiceVersion Version { get; }
    internal ClientDiagnostics ClientDiagnostics { get; }
    public BlobLeaseClient(BlobBaseClient client, string leaseId);
    public BlobLeaseClient(BlobContainerClient client, string leaseId);
    private static BlobLeaseClient();
    protected virtual BlobBaseClient get_BlobClient();
    protected virtual BlobContainerClient get_BlobContainerClient();
    public Uri get_Uri();
    public virtual string get_LeaseId();
    private void set_LeaseId(string value);
    private HttpPipeline get_Pipeline();
    internal virtual ServiceVersion get_Version();
    internal virtual ClientDiagnostics get_ClientDiagnostics();
    private static string CreateUniqueLeaseId();
    private void EnsureClient();
    public virtual Response`1<BlobLease> Acquire(TimeSpan duration, RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<AcquireAsync>d__25")]
public virtual Task`1<Response`1<BlobLease>> AcquireAsync(TimeSpan duration, RequestConditions conditions, CancellationToken cancellationToken);
    private Response`1<BlobLease> ParseAcquireResponse(Response response);
    public virtual Response Acquire(TimeSpan duration, RequestConditions conditions, RequestContext context);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<AcquireAsync>d__28")]
public virtual Task`1<Response> AcquireAsync(TimeSpan duration, RequestConditions conditions, RequestContext context);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<AcquireInternal>d__29")]
private Task`1<Response> AcquireInternal(TimeSpan duration, RequestConditions conditions, bool async, RequestContext context);
    public virtual Response`1<BlobLease> Renew(RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<RenewAsync>d__31")]
public virtual Task`1<Response`1<BlobLease>> RenewAsync(RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<RenewInternal>d__32")]
private Task`1<Response`1<BlobLease>> RenewInternal(RequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<ReleasedObjectInfo> Release(RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<ReleaseAsync>d__34")]
public virtual Task`1<Response`1<ReleasedObjectInfo>> ReleaseAsync(RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<ReleaseInternal>d__35")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<ReleasedObjectInfo>> ReleaseInternal(RequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobLease> Change(string proposedId, RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<ChangeAsync>d__37")]
public virtual Task`1<Response`1<BlobLease>> ChangeAsync(string proposedId, RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<ChangeInternal>d__38")]
private Task`1<Response`1<BlobLease>> ChangeInternal(string proposedId, RequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobLease> Break(Nullable`1<TimeSpan> breakPeriod, RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<BreakAsync>d__40")]
public virtual Task`1<Response`1<BlobLease>> BreakAsync(Nullable`1<TimeSpan> breakPeriod, RequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlobLeaseClient/<BreakInternal>d__41")]
private Task`1<Response`1<BlobLease>> BreakInternal(Nullable`1<TimeSpan> breakPeriod, RequestConditions conditions, bool async, CancellationToken cancellationToken);
}
public class Azure.Storage.Blobs.Specialized.BlockBlobClient : BlobBaseClient {
    private BlockBlobRestClient _blockBlobRestClient;
    [EditorBrowsableAttribute("1")]
public int BlockBlobMaxUploadBlobBytes { get; }
    public long BlockBlobMaxUploadBlobLongBytes { get; }
    [EditorBrowsableAttribute("1")]
public int BlockBlobMaxStageBlockBytes { get; }
    public long BlockBlobMaxStageBlockLongBytes { get; }
    public int BlockBlobMaxBlocks { get; }
    internal BlockBlobRestClient BlockBlobRestClient { get; }
    public BlockBlobClient(string connectionString, string containerName, string blobName);
    public BlockBlobClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options);
    public BlockBlobClient(Uri blobUri, BlobClientOptions options);
    public BlockBlobClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options);
    public BlockBlobClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options);
    public BlockBlobClient(Uri blobUri, TokenCredential credential, BlobClientOptions options);
    internal BlockBlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration);
    internal BlockBlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption);
    public virtual int get_BlockBlobMaxUploadBlobBytes();
    public virtual long get_BlockBlobMaxUploadBlobLongBytes();
    public virtual int get_BlockBlobMaxStageBlockBytes();
    public virtual long get_BlockBlobMaxStageBlockLongBytes();
    public virtual int get_BlockBlobMaxBlocks();
    internal virtual BlockBlobRestClient get_BlockBlobRestClient();
    protected static BlockBlobClient CreateClient(Uri blobUri, BlobClientOptions options, HttpPipeline pipeline);
    private static void AssertNoClientSideEncryption(BlobClientOptions options);
    private BlockBlobRestClient BuildBlockBlobRestClient(Uri blobUri);
    public BlockBlobClient WithSnapshot(string snapshot);
    public BlockBlobClient WithVersion(string versionId);
    protected sealed virtual BlobBaseClient WithSnapshotCore(string snapshot);
    public BlockBlobClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey);
    public BlockBlobClient WithEncryptionScope(string encryptionScope);
    public virtual Response`1<BlobContentInfo> Upload(Stream content, BlobUploadOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<UploadAsync>d__31")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, BlobUploadOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContentInfo> Upload(Stream content, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<UploadAsync>d__33")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<UploadInternal>d__34")]
internal virtual Task`1<Response`1<BlobContentInfo>> UploadInternal(Stream content, BlobHttpHeaders blobHttpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidationOverride, string operationName, bool async, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlockInfo> StageBlock(string base64BlockId, Stream content, Byte[] transactionalContentHash, BlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<StageBlockAsync>d__36")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlockInfo>> StageBlockAsync(string base64BlockId, Stream content, Byte[] transactionalContentHash, BlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    public virtual Response`1<BlockInfo> StageBlock(string base64BlockId, Stream content, BlockBlobStageBlockOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<StageBlockAsync>d__38")]
public virtual Task`1<Response`1<BlockInfo>> StageBlockAsync(string base64BlockId, Stream content, BlockBlobStageBlockOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<StageBlockInternal>d__39")]
internal virtual Task`1<Response`1<BlockInfo>> StageBlockInternal(string base64BlockId, Stream content, UploadTransferValidationOptions transferValidationOverride, BlobRequestConditions conditions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlockInfo> StageBlockFromUri(Uri sourceUri, string base64BlockId, StageBlockFromUriOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<StageBlockFromUriAsync>d__41")]
public virtual Task`1<Response`1<BlockInfo>> StageBlockFromUriAsync(Uri sourceUri, string base64BlockId, StageBlockFromUriOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlockInfo> StageBlockFromUri(Uri sourceUri, string base64BlockId, HttpRange sourceRange, Byte[] sourceContentHash, RequestConditions sourceConditions, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<StageBlockFromUriAsync>d__43")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlockInfo>> StageBlockFromUriAsync(Uri sourceUri, string base64BlockId, HttpRange sourceRange, Byte[] sourceContentHash, RequestConditions sourceConditions, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<StageBlockFromUriInternal>d__44")]
private Task`1<Response`1<BlockInfo>> StageBlockFromUriInternal(Uri sourceUri, string base64BlockId, HttpRange sourceRange, Byte[] sourceContentHash, RequestConditions sourceConditions, BlobRequestConditions conditions, HttpAuthorization sourceAuthentication, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> CommitBlockList(IEnumerable`1<string> base64BlockIds, CommitBlockListOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContentInfo> CommitBlockList(IEnumerable`1<string> base64BlockIds, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<CommitBlockListAsync>d__47")]
public virtual Task`1<Response`1<BlobContentInfo>> CommitBlockListAsync(IEnumerable`1<string> base64BlockIds, CommitBlockListOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<CommitBlockListAsync>d__48")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContentInfo>> CommitBlockListAsync(IEnumerable`1<string> base64BlockIds, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<CommitBlockListInternal>d__49")]
internal virtual Task`1<Response`1<BlobContentInfo>> CommitBlockListInternal(IEnumerable`1<string> base64BlockIds, BlobHttpHeaders blobHttpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlockList> GetBlockList(BlockListTypes blockListTypes, string snapshot, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<GetBlockListAsync>d__51")]
public virtual Task`1<Response`1<BlockList>> GetBlockListAsync(BlockListTypes blockListTypes, string snapshot, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<GetBlockListInternal>d__52")]
private Task`1<Response`1<BlockList>> GetBlockListInternal(BlockListTypes blockListTypes, string snapshot, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobDownloadInfo> Query(string querySqlExpression, BlobQueryOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<QueryAsync>d__54")]
public virtual Task`1<Response`1<BlobDownloadInfo>> QueryAsync(string querySqlExpression, BlobQueryOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<QueryInternal>d__55")]
private Task`1<Response`1<BlobDownloadInfo>> QueryInternal(string querySqlExpression, BlobQueryOptions options, bool async, CancellationToken cancellationToken);
    public virtual Stream OpenWrite(bool overwrite, BlockBlobOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<OpenWriteAsync>d__57")]
public virtual Task`1<Stream> OpenWriteAsync(bool overwrite, BlockBlobOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<OpenWriteInternal>d__58")]
internal Task`1<Stream> OpenWriteInternal(bool overwrite, BlockBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> SyncUploadFromUri(Uri copySource, bool overwrite, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<SyncUploadFromUriAsync>d__60")]
public virtual Task`1<Response`1<BlobContentInfo>> SyncUploadFromUriAsync(Uri copySource, bool overwrite, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> SyncUploadFromUri(Uri copySource, BlobSyncUploadFromUriOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<SyncUploadFromUriAsync>d__62")]
public virtual Task`1<Response`1<BlobContentInfo>> SyncUploadFromUriAsync(Uri copySource, BlobSyncUploadFromUriOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.BlockBlobClient/<SyncUploadFromUriInternal>d__63")]
internal virtual Task`1<Response`1<BlobContentInfo>> SyncUploadFromUriInternal(Uri copySource, BlobSyncUploadFromUriOptions options, bool async, CancellationToken cancellationToken);
    internal PartitionedUploader`2<BlobUploadOptions, BlobContentInfo> GetPartitionedUploader(StorageTransferOptions transferOptions, UploadTransferValidationOptions validationOptions, ArrayPool`1<byte> arrayPool, string operationName);
    internal static Behaviors<BlobUploadOptions, BlobContentInfo> GetPartitionedUploaderBehaviors(BlockBlobClient client);
}
public class Azure.Storage.Blobs.Specialized.PageBlobClient : BlobBaseClient {
    private PageBlobRestClient _pageBlobRestClient;
    public int PageBlobPageBytes { get; }
    public int PageBlobMaxUploadPagesBytes { get; }
    internal PageBlobRestClient PageBlobRestClient { get; }
    public PageBlobClient(string connectionString, string blobContainerName, string blobName);
    public PageBlobClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options);
    public PageBlobClient(Uri blobUri, BlobClientOptions options);
    public PageBlobClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options);
    public PageBlobClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options);
    public PageBlobClient(Uri blobUri, TokenCredential credential, BlobClientOptions options);
    internal PageBlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration);
    public virtual int get_PageBlobPageBytes();
    public virtual int get_PageBlobMaxUploadPagesBytes();
    internal virtual PageBlobRestClient get_PageBlobRestClient();
    private static void AssertNoClientSideEncryption(BlobClientOptions options);
    private PageBlobRestClient BuildPageBlobRestClient(Uri blobUri);
    public PageBlobClient WithSnapshot(string snapshot);
    protected sealed virtual BlobBaseClient WithSnapshotCore(string snapshot);
    public PageBlobClient WithVersion(string versionId);
    public PageBlobClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey);
    public PageBlobClient WithEncryptionScope(string encryptionScope);
    public virtual Response`1<BlobContentInfo> Create(long size, PageBlobCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<CreateAsync>d__23")]
public virtual Task`1<Response`1<BlobContentInfo>> CreateAsync(long size, PageBlobCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContentInfo> Create(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<CreateAsync>d__25")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContentInfo>> CreateAsync(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<BlobContentInfo> CreateIfNotExists(long size, PageBlobCreateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<CreateIfNotExistsAsync>d__27")]
public virtual Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsAsync(long size, PageBlobCreateOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<BlobContentInfo> CreateIfNotExists(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<CreateIfNotExistsAsync>d__29")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsAsync(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<CreateIfNotExistsInternal>d__30")]
private Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsInternal(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<CreateInternal>d__31")]
private Task`1<Response`1<BlobContentInfo>> CreateInternal(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, PageBlobRequestConditions conditions, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken, string operationName);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PageInfo> UploadPages(Stream content, long offset, Byte[] transactionalContentHash, PageBlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<UploadPagesAsync>d__33")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PageInfo>> UploadPagesAsync(Stream content, long offset, Byte[] transactionalContentHash, PageBlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken);
    public virtual Response`1<PageInfo> UploadPages(Stream content, long offset, PageBlobUploadPagesOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<UploadPagesAsync>d__35")]
public virtual Task`1<Response`1<PageInfo>> UploadPagesAsync(Stream content, long offset, PageBlobUploadPagesOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<UploadPagesInternal>d__36")]
internal Task`1<Response`1<PageInfo>> UploadPagesInternal(Stream content, long offset, UploadTransferValidationOptions transferValidationOverride, PageBlobRequestConditions conditions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    public virtual Response`1<PageInfo> ClearPages(HttpRange range, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<ClearPagesAsync>d__38")]
public virtual Task`1<Response`1<PageInfo>> ClearPagesAsync(HttpRange range, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<ClearPagesInternal>d__39")]
private Task`1<Response`1<PageInfo>> ClearPagesInternal(HttpRange range, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Pageable`1<PageRangeItem> GetAllPageRanges(GetPageRangesOptions options, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<PageRangeItem> GetAllPageRangesAsync(GetPageRangesOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<GetAllPageRangesInteral>d__42")]
internal Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders>> GetAllPageRangesInteral(string marker, Nullable`1<int> pageSizeHint, Nullable`1<HttpRange> range, string snapshot, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PageRangesInfo> GetPageRanges(Nullable`1<HttpRange> range, string snapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<GetPageRangesAsync>d__44")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PageRangesInfo>> GetPageRangesAsync(Nullable`1<HttpRange> range, string snapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<GetPageRangesInternal>d__45")]
private Task`1<Response`1<PageRangesInfo>> GetPageRangesInternal(Nullable`1<HttpRange> range, string snapshot, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Pageable`1<PageRangeItem> GetAllPageRangesDiff(GetPageRangesDiffOptions options, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<PageRangeItem> GetAllPageRangesDiffAsync(GetPageRangesDiffOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<GetAllPageRangesDiffInternal>d__48")]
internal Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders>> GetAllPageRangesDiffInternal(string marker, Nullable`1<int> pageSizeHint, Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, bool async, string operationName, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PageRangesInfo> GetPageRangesDiff(Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<GetPageRangesDiffAsync>d__50")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PageRangesInfo>> GetPageRangesDiffAsync(Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<GetPageRangesDiffInternal>d__51")]
private Task`1<Response`1<PageRangesInfo>> GetPageRangesDiffInternal(Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, bool async, string operationName, CancellationToken cancellationToken);
    public virtual Response`1<PageRangesInfo> GetManagedDiskPageRangesDiff(Nullable`1<HttpRange> range, string snapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<GetManagedDiskPageRangesDiffAsync>d__53")]
public virtual Task`1<Response`1<PageRangesInfo>> GetManagedDiskPageRangesDiffAsync(Nullable`1<HttpRange> range, string snapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    public virtual Response`1<PageBlobInfo> Resize(long size, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<ResizeAsync>d__55")]
public virtual Task`1<Response`1<PageBlobInfo>> ResizeAsync(long size, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<ResizeInternal>d__56")]
private Task`1<Response`1<PageBlobInfo>> ResizeInternal(long size, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<PageBlobInfo> UpdateSequenceNumber(SequenceNumberAction action, Nullable`1<long> sequenceNumber, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<UpdateSequenceNumberAsync>d__58")]
public virtual Task`1<Response`1<PageBlobInfo>> UpdateSequenceNumberAsync(SequenceNumberAction action, Nullable`1<long> sequenceNumber, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<UpdateSequenceNumberInternal>d__59")]
private Task`1<Response`1<PageBlobInfo>> UpdateSequenceNumberInternal(SequenceNumberAction action, Nullable`1<long> sequenceNumber, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual CopyFromUriOperation StartCopyIncremental(Uri sourceUri, string snapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<StartCopyIncrementalAsync>d__61")]
public virtual Task`1<CopyFromUriOperation> StartCopyIncrementalAsync(Uri sourceUri, string snapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<StartCopyIncrementalInternal>d__62")]
private Task`1<Response`1<BlobCopyInfo>> StartCopyIncrementalInternal(Uri sourceUri, string snapshot, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    public virtual Response`1<PageInfo> UploadPagesFromUri(Uri sourceUri, HttpRange sourceRange, HttpRange range, PageBlobUploadPagesFromUriOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<UploadPagesFromUriAsync>d__64")]
public virtual Task`1<Response`1<PageInfo>> UploadPagesFromUriAsync(Uri sourceUri, HttpRange sourceRange, HttpRange range, PageBlobUploadPagesFromUriOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual Response`1<PageInfo> UploadPagesFromUri(Uri sourceUri, HttpRange sourceRange, HttpRange range, Byte[] sourceContentHash, PageBlobRequestConditions conditions, PageBlobRequestConditions sourceConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<UploadPagesFromUriAsync>d__66")]
[EditorBrowsableAttribute("1")]
public virtual Task`1<Response`1<PageInfo>> UploadPagesFromUriAsync(Uri sourceUri, HttpRange sourceRange, HttpRange range, Byte[] sourceContentHash, PageBlobRequestConditions conditions, PageBlobRequestConditions sourceConditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<UploadPagesFromUriInternal>d__67")]
private Task`1<Response`1<PageInfo>> UploadPagesFromUriInternal(Uri sourceUri, HttpRange sourceRange, HttpRange range, Byte[] sourceContentHash, PageBlobRequestConditions conditions, PageBlobRequestConditions sourceConditions, HttpAuthorization sourceAuthentication, bool async, CancellationToken cancellationToken);
    public virtual Stream OpenWrite(bool overwrite, long position, PageBlobOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<OpenWriteAsync>d__69")]
public virtual Task`1<Stream> OpenWriteAsync(bool overwrite, long position, PageBlobOpenWriteOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.PageBlobClient/<OpenWriteInternal>d__70")]
private Task`1<Stream> OpenWriteInternal(bool overwrite, long position, PageBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken);
}
public class Azure.Storage.Blobs.Specialized.SpecializedBlobClientOptions : BlobClientOptions {
    public ClientSideEncryptionOptions ClientSideEncryption { get; public set; }
    public SpecializedBlobClientOptions(ServiceVersion version);
    public ClientSideEncryptionOptions get_ClientSideEncryption();
    public void set_ClientSideEncryption(ClientSideEncryptionOptions value);
}
[ExtensionAttribute]
public static class Azure.Storage.Blobs.Specialized.SpecializedBlobExtensions : object {
    [ExtensionAttribute]
public static AppendBlobClient GetAppendBlobClient(BlobContainerClient client, string blobName);
    [ExtensionAttribute]
public static BlobContainerClient GetParentBlobContainerClient(BlobBaseClient client);
    [ExtensionAttribute]
public static BlobBaseClient GetBlobBaseClient(BlobContainerClient client, string blobName);
    [ExtensionAttribute]
public static BlobClient WithClientSideEncryptionOptions(BlobClient client, ClientSideEncryptionOptions clientSideEncryptionOptions);
    [ExtensionAttribute]
public static BlobServiceClient GetParentBlobServiceClient(BlobContainerClient client);
    [ExtensionAttribute]
public static BlobLeaseClient GetBlobLeaseClient(BlobBaseClient client, string leaseId);
    [ExtensionAttribute]
public static BlobLeaseClient GetBlobLeaseClient(BlobContainerClient client, string leaseId);
    [ExtensionAttribute]
public static BlockBlobClient GetBlockBlobClient(BlobContainerClient client, string blobName);
    [ExtensionAttribute]
public static PageBlobClient GetPageBlobClient(BlobContainerClient client, string blobName);
    [ExtensionAttribute]
public static void UpdateClientSideKeyEncryptionKey(BlobClient client, ClientSideEncryptionOptions encryptionOptionsOverride, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.SpecializedBlobExtensions/<UpdateClientSideKeyEncryptionKeyAsync>d__10")]
[ExtensionAttribute]
public static Task UpdateClientSideKeyEncryptionKeyAsync(BlobClient client, ClientSideEncryptionOptions encryptionOptionsOverride, BlobRequestConditions conditions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.SpecializedBlobExtensions/<UpdateClientsideKeyEncryptionKeyInternal>d__11")]
private static Task UpdateClientsideKeyEncryptionKeyInternal(BlobClient client, ClientSideEncryptionOptions encryptionOptionsOverride, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.SpecializedBlobExtensions/<UnwrapKeyInternal>d__12")]
private static Task`1<Byte[]> UnwrapKeyInternal(EncryptionData encryptionData, IKeyEncryptionKeyResolver keyResolver, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Blobs.Specialized.SpecializedBlobExtensions/<WrapKeyInternal>d__13")]
private static Task`1<Byte[]> WrapKeyInternal(ReadOnlyMemory`1<byte> contentEncryptionKey, string keyWrapAlgorithm, IKeyEncryptionKey key, bool async, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Azure.Storage.BufferExtensions : object {
    [ExtensionAttribute]
public static IDisposable RentDisposable(ArrayPool`1<T> pool, int minimumLength, T[]& array);
    [ExtensionAttribute]
public static IDisposable RentAsMemoryDisposable(ArrayPool`1<T> pool, int minimumLength, Memory`1& memory);
    [ExtensionAttribute]
public static IDisposable RentAsSpanDisposable(ArrayPool`1<T> pool, int minimumLength, Span`1& span);
    [ExtensionAttribute]
public static T[] Clear(T[] array);
}
internal class Azure.Storage.ChecksumCalculatingStream : Stream {
    private Stream _stream;
    private AppendChecksumCalculation _appendChecksumCalculation;
    private long _initialPosition;
    private long _nextToBeChecksummedPosition;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private ChecksumCalculatingStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation, bool isReadMode);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public static Stream GetReadStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation);
    public static Stream GetWriteStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<ReadAsync>d__30")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<ReadSeekableInternal>d__31")]
private Task`1<int> ReadSeekableInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<ReadUnseekableInternal>d__32")]
private Task`1<int> ReadUnseekableInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<WriteAsync>d__34")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<WriteInternal>d__35")]
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Azure.Storage.ChecksumCalculatingStream/<FlushAsync>d__38")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Close();
    public virtual void SetLength(long value);
    private void AssertCanRead();
    private void AssertCanWrite();
}
internal static class Azure.Storage.CompatSwitches : object {
    private static Nullable`1<bool> _disableRequestConditionsValidation;
    public static bool DisableRequestConditionsValidation { get; }
    public static bool get_DisableRequestConditionsValidation();
}
internal static class Azure.Storage.Constants : object {
    public static int KB;
    public static int MB;
    public static int GB;
    public static long TB;
    public static int Base16;
    public static int MaxReliabilityRetries;
    public static int MaxIdleTimeMs;
    public static string DefaultSasVersion;
    public static int MaxHashRequestDownloadRange;
    public static int DefaultBufferSize;
    public static int LargeBufferSize;
    public static int LargeUploadThreshold;
    public static int DefaultStreamingDownloadSize;
    public static int DefaultStreamCopyBufferSize;
    public static int DefaultDownloadCopyBufferSize;
    public static int StorageCrc64SizeInBytes;
    public static int MD5SizeInBytes;
    public static bool DefaultTrimBlobNameSlashes;
    public static string CloseAllHandles;
    public static string Wildcard;
    public static string BlockNameFormat;
    public static string SasTimeFormatSeconds;
    public static string SasTimeFormatSubSeconds;
    public static string SasTimeFormatMinutes;
    public static string SasTimeFormatDays;
    public static string SnapshotParameterName;
    public static string VersionIdParameterName;
    public static string ShareSnapshotParameterName;
    public static string Https;
    public static string Http;
    public static string PercentSign;
    public static string EncodedPercentSign;
    public static string QueryDelimiter;
    public static string PathBackSlashDelimiter;
    public static string FalseName;
    public static string TrueName;
    public static string ErrorCode;
    public static string ErrorMessage;
    public static string CommaString;
    public static char CommaChar;
    public static string ContentTypeApplicationXml;
    public static string ContentTypeApplicationJson;
    public static string ErrorPropertyKey;
    public static string DetailPropertyKey;
    public static string MessagePropertyKey;
    public static string CodePropertyKey;
    public static string Iso8601Format;
    public static string DisableRequestConditionsValidationSwitchName;
    public static string DisableRequestConditionsValidationEnvVar;
    public static string DefaultScope;
}
[ExtensionAttribute]
internal static class Azure.Storage.ContentHasher : object {
    internal static int GetHashSizeInBytes(StorageChecksumAlgorithm algorithm);
    [ExtensionAttribute]
internal static UploadTransferValidationOptions ToUploadTransferValidationOptions(GetHashResult hashResult);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<AssertResponseHashMatchInternal>d__3")]
public static Task AssertResponseHashMatchInternal(Stream content, StorageChecksumAlgorithm algorithm, Response response, bool async, CancellationToken cancellationToken);
    public static void AssertResponseHashMatch(Byte[] content, int offset, int count, StorageChecksumAlgorithm algorithm, Response response);
    private static void AssertResponseHashMatch(GetHashResult computedHash, StorageChecksumAlgorithm algorithm, Response response);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<GetHashOrDefaultInternal>d__6")]
public static Task`1<GetHashResult> GetHashOrDefaultInternal(Stream content, UploadTransferValidationOptions options, bool async, CancellationToken cancellationToken);
    public static GetHashResult GetHashOrDefault(BinaryData content, UploadTransferValidationOptions options);
    private static bool GetHashOrDefaultTryFromOptions(UploadTransferValidationOptions options, GetHashResult& result);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<GetHashInternal>d__9")]
public static Task`1<GetHashResult> GetHashInternal(Stream content, StorageChecksumAlgorithm algorithmIdentifier, bool async, CancellationToken cancellationToken);
    public static GetHashResult GetHash(BinaryData content, StorageChecksumAlgorithm algorithmIdentifier);
    public static ValueTuple`4<Stream, GetFinalStreamHash, int, IDisposable> SetupChecksumCalculatingReadStream(Stream stream, StorageChecksumAlgorithm algorithmIdentifier);
    private static IHasher GetHasher(StorageChecksumAlgorithm algorithmIdentifier);
    [AsyncStateMachineAttribute("Azure.Storage.ContentHasher/<ComputeHashInternal>d__14")]
private static Task`1<Byte[]> ComputeHashInternal(Stream content, IHasher hasher, bool async, CancellationToken cancellationToken);
    public static IHasher GetHasherFromAlgorithmId(StorageChecksumAlgorithm algorithm);
    public static ValueTuple`2<ReadOnlyMemory`1<byte>, StorageChecksumAlgorithm> GetResponseChecksumOrDefault(Response response);
    [CompilerGeneratedAttribute]
internal static Byte[] <GetHash>g__computeCrc|10_0(StorageCrc64HashAlgorithm nonCryptographicHashAlgorithm, <>c__DisplayClass10_0& );
}
internal class Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream : Stream {
    private Stream _innerStream;
    private CryptoStreamMode _mode;
    private IAuthenticatedCryptographicTransform _transform;
    private bool _flushedFinal;
    private Byte[] _buffer;
    private int _bufferPos;
    private int _bufferPopulatedLength;
    private int _bufferLength;
    private int _tempRefillBufferSize;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public AuthenticatedRegionCryptoStream(Stream innerStream, IAuthenticatedCryptographicTransform transform, int regionDataSize, CryptoStreamMode streamMode);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<ReadAsync>d__22")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<ReadInternal>d__23")]
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<WriteAsync>d__25")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<WriteInternal>d__26")]
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<FlushAsync>d__28")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<FlushIfReadyInternal>d__29")]
private Task FlushIfReadyInternal(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<FlushFinalInternal>d__30")]
public Task FlushFinalInternal(bool async, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
internal class Azure.Storage.Cryptography.ClientSideDecryptor : object {
    private static AsyncLocal`1<ContentEncryptionKeyCache> s_contentEncryptionKeyCache;
    private IKeyEncryptionKey _potentialCachedIKeyEncryptionKey;
    private IKeyEncryptionKeyResolver _keyResolver;
    public ClientSideDecryptor(ClientSideEncryptionOptions options);
    private static ClientSideDecryptor();
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptReadInternal>d__4")]
public Task`1<Stream> DecryptReadInternal(Stream ciphertext, EncryptionData encryptionData, bool ivInStream, bool noPadding, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptWholeContentWriteInternal>d__5")]
public Task`1<Stream> DecryptWholeContentWriteInternal(Stream plaintextDestination, EncryptionData encryptionData, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptInternalV2_0>d__6")]
private Task`1<Stream> DecryptInternalV2_0(Stream ciphertext, EncryptionData encryptionData, CryptoStreamMode mode, bool async, CancellationToken cancellationToken);
    private static Stream WrapStreamV2_0(Stream contentStream, CryptoStreamMode mode, Byte[] contentEncryptionKey, int authRegionPlaintextSize);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptReadInternalV1_0>d__8")]
private Task`1<Stream> DecryptReadInternalV1_0(Stream ciphertext, EncryptionData encryptionData, bool ivInStream, bool noPadding, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptWholeContentWriteInternalV1_0>d__9")]
private Task`1<Stream> DecryptWholeContentWriteInternalV1_0(Stream plaintextDestination, EncryptionData encryptionData, bool async, CancellationToken cancellationToken);
    private static Stream WrapStreamV1_0(Stream contentStream, Byte[] contentEncryptionKey, EncryptionData encryptionData, Byte[] iv, bool noPadding, CryptoStreamMode mode);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<GetContentEncryptionKeyAsync>d__11")]
internal Task`1<Memory`1<byte>> GetContentEncryptionKeyAsync(EncryptionData encryptionData, bool async, CancellationToken cancellationToken);
    internal static void BeginContentEncryptionKeyCaching(ContentEncryptionKeyCache cache);
}
[ExtensionAttribute]
internal static class Azure.Storage.Cryptography.ClientSideEncryptionOptionsExtensions : object {
    [ExtensionAttribute]
public static ClientSideEncryptionOptions Clone(ClientSideEncryptionOptions options);
    internal static void CopyOptions(ClientSideEncryptionOptions source, ClientSideEncryptionOptions destination);
    [ExtensionAttribute]
public static IClientSideEncryptor GetClientSideEncryptor(ClientSideEncryptionOptions options);
}
internal class Azure.Storage.Cryptography.ClientSideEncryptorV1_0 : object {
    private IKeyEncryptionKey _keyEncryptionKey;
    private string _keyWrapAlgorithm;
    public ClientSideEncryptorV1_0(ClientSideEncryptionOptions options);
    private void ValidateMembers();
    public sealed virtual long ExpectedOutputContentLength(long plaintextLength);
    public static long CalculateExpectedOutputContentLength(long plaintextLength);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV1_0/<EncryptInternal>d__6")]
public sealed virtual Task`1<ValueTuple`2<Stream, EncryptionData>> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV1_0/<BufferedEncryptInternal>d__7")]
public sealed virtual Task`1<ValueTuple`2<Byte[], EncryptionData>> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV1_0/<EncryptedOpenWriteInternal>d__8")]
public sealed virtual Task`1<Stream> EncryptedOpenWriteInternal(Func`4<EncryptionData, bool, CancellationToken, Task`1<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV1_0/<CreateEncryptionDataInternal>d__9")]
private Task`1<EncryptionData> CreateEncryptionDataInternal(Aes aes, bool async, CancellationToken cancellationToken);
    private static Byte[] CreateKey(int numBits);
}
internal class Azure.Storage.Cryptography.ClientSideEncryptorV2_0 : object {
    private IKeyEncryptionKey _keyEncryptionKey;
    private string _keyWrapAlgorithm;
    public ClientSideEncryptorV2_0(ClientSideEncryptionOptions options);
    public sealed virtual long ExpectedOutputContentLength(long plaintextLength);
    public static long CalculateExpectedOutputContentLength(long plaintextLength);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV2_0/<EncryptInternal>d__5")]
public sealed virtual Task`1<ValueTuple`2<Stream, EncryptionData>> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV2_0/<BufferedEncryptInternal>d__6")]
public sealed virtual Task`1<ValueTuple`2<Byte[], EncryptionData>> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV2_0/<EncryptedOpenWriteInternal>d__7")]
public sealed virtual Task`1<Stream> EncryptedOpenWriteInternal(Func`4<EncryptionData, bool, CancellationToken, Task`1<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV2_0/<CreateEncryptionDataInternal>d__8")]
private Task`1<EncryptionData> CreateEncryptionDataInternal(Byte[] key, bool async, CancellationToken cancellationToken);
    private static Byte[] CreateKey(int numBits);
}
internal class Azure.Storage.Cryptography.GcmAuthenticatedCryptographicTransform : object {
    private AesGcm _gcm;
    private long _nonceCounter;
    [CompilerGeneratedAttribute]
private TransformMode <TransformMode>k__BackingField;
    public TransformMode TransformMode { get; }
    public int NonceLength { get; }
    public int TagLength { get; }
    public GcmAuthenticatedCryptographicTransform(Byte[] key, TransformMode mode);
    [CompilerGeneratedAttribute]
public sealed virtual TransformMode get_TransformMode();
    public sealed virtual int get_NonceLength();
    public sealed virtual int get_TagLength();
    public sealed virtual int TransformAuthenticationBlock(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual void Dispose();
    private ReadOnlySpan`1<byte> GetNewNonce();
}
internal interface Azure.Storage.Cryptography.IAuthenticatedCryptographicTransform {
    public TransformMode TransformMode { get; }
    public int NonceLength { get; }
    public int TagLength { get; }
    public abstract virtual TransformMode get_TransformMode();
    public abstract virtual int get_NonceLength();
    public abstract virtual int get_TagLength();
    public abstract virtual int TransformAuthenticationBlock(ReadOnlySpan`1<byte> input, Span`1<byte> output);
}
internal interface Azure.Storage.Cryptography.IClientSideEncryptor {
    public abstract virtual long ExpectedOutputContentLength(long plaintextLength);
    public abstract virtual Task`1<ValueTuple`2<Stream, EncryptionData>> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    public abstract virtual Task`1<ValueTuple`2<Byte[], EncryptionData>> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> EncryptedOpenWriteInternal(Func`4<EncryptionData, bool, CancellationToken, Task`1<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Azure.Storage.Cryptography.Models.ClientSideEncryptionAlgorithm : ValueType {
    internal static string AesCbc256Value;
    internal static string AesGcm256Value;
    private string _value;
    [CompilerGeneratedAttribute]
private static ClientSideEncryptionAlgorithm <AesCbc256>k__BackingField;
    [CompilerGeneratedAttribute]
private static ClientSideEncryptionAlgorithm <AesGcm256>k__BackingField;
    public static ClientSideEncryptionAlgorithm AesCbc256 { get; }
    public static ClientSideEncryptionAlgorithm AesGcm256 { get; }
    public ClientSideEncryptionAlgorithm(string value);
    private static ClientSideEncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public static ClientSideEncryptionAlgorithm get_AesCbc256();
    [CompilerGeneratedAttribute]
public static ClientSideEncryptionAlgorithm get_AesGcm256();
    public static bool op_Equality(ClientSideEncryptionAlgorithm left, ClientSideEncryptionAlgorithm right);
    public static bool op_Inequality(ClientSideEncryptionAlgorithm left, ClientSideEncryptionAlgorithm right);
    public static ClientSideEncryptionAlgorithm op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(ClientSideEncryptionAlgorithm other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Azure.Storage.Cryptography.Models.ClientSideEncryptionVersionExtensions : object {
    [ExtensionAttribute]
public static string Serialize(ClientSideEncryptionVersion version);
    [ExtensionAttribute]
public static ClientSideEncryptionVersion ToClientSideEncryptionVersion(string versionString);
}
internal class Azure.Storage.Cryptography.Models.EncryptedRegionInfo : object {
    [CompilerGeneratedAttribute]
private int <DataLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NonceLength>k__BackingField;
    public int DataLength { get; public set; }
    public int NonceLength { get; public set; }
    [CompilerGeneratedAttribute]
public int get_DataLength();
    [CompilerGeneratedAttribute]
public void set_DataLength(int value);
    [CompilerGeneratedAttribute]
public int get_NonceLength();
    [CompilerGeneratedAttribute]
public void set_NonceLength(int value);
}
internal class Azure.Storage.Cryptography.Models.EncryptionAgent : object {
    [CompilerGeneratedAttribute]
private ClientSideEncryptionVersion <EncryptionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientSideEncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
    public ClientSideEncryptionVersion EncryptionVersion { get; public set; }
    public ClientSideEncryptionAlgorithm EncryptionAlgorithm { get; public set; }
    [CompilerGeneratedAttribute]
public ClientSideEncryptionVersion get_EncryptionVersion();
    [CompilerGeneratedAttribute]
public void set_EncryptionVersion(ClientSideEncryptionVersion value);
    [CompilerGeneratedAttribute]
public ClientSideEncryptionAlgorithm get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(ClientSideEncryptionAlgorithm value);
}
internal class Azure.Storage.Cryptography.Models.EncryptionData : object {
    [CompilerGeneratedAttribute]
private string <EncryptionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyEnvelope <WrappedContentKey>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAgent <EncryptionAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentEncryptionIV>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptedRegionInfo <EncryptedRegionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <KeyWrappingMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AgentString>k__BackingField;
    public string EncryptionMode { get; public set; }
    public KeyEnvelope WrappedContentKey { get; public set; }
    public EncryptionAgent EncryptionAgent { get; public set; }
    public Byte[] ContentEncryptionIV { get; public set; }
    public EncryptedRegionInfo EncryptedRegionInfo { get; public set; }
    public IDictionary`2<string, string> KeyWrappingMetadata { get; public set; }
    private static string AgentString { get; }
    private static EncryptionData();
    [CompilerGeneratedAttribute]
public string get_EncryptionMode();
    [CompilerGeneratedAttribute]
public void set_EncryptionMode(string value);
    [CompilerGeneratedAttribute]
public KeyEnvelope get_WrappedContentKey();
    [CompilerGeneratedAttribute]
public void set_WrappedContentKey(KeyEnvelope value);
    [CompilerGeneratedAttribute]
public EncryptionAgent get_EncryptionAgent();
    [CompilerGeneratedAttribute]
public void set_EncryptionAgent(EncryptionAgent value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentEncryptionIV();
    [CompilerGeneratedAttribute]
public void set_ContentEncryptionIV(Byte[] value);
    [CompilerGeneratedAttribute]
public EncryptedRegionInfo get_EncryptedRegionInfo();
    [CompilerGeneratedAttribute]
public void set_EncryptedRegionInfo(EncryptedRegionInfo value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_KeyWrappingMetadata();
    [CompilerGeneratedAttribute]
public void set_KeyWrappingMetadata(IDictionary`2<string, string> value);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.Models.EncryptionData/<CreateInternalV1_0>d__24")]
internal static ValueTask`1<EncryptionData> CreateInternalV1_0(Byte[] contentEncryptionIv, string keyWrapAlgorithm, Byte[] contentEncryptionKey, IKeyEncryptionKey keyEncryptionKey, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.Models.EncryptionData/<CreateInternalV2_0>d__25")]
internal static Task`1<EncryptionData> CreateInternalV2_0(string keyWrapAlgorithm, Byte[] contentEncryptionKey, IKeyEncryptionKey keyEncryptionKey, bool async, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private static string get_AgentString();
    private static string GenerateAgentString();
}
internal static class Azure.Storage.Cryptography.Models.EncryptionDataSerializer : object {
    private static string EncryptionAgent_EncryptionVersionName;
    public static string Serialize(EncryptionData data);
    private static ReadOnlyMemory`1<byte> SerializeEncryptionData(EncryptionData data);
    public static void WriteEncryptionData(Utf8JsonWriter json, EncryptionData data);
    private static void WriteEncryptedRegionInfo(Utf8JsonWriter json, EncryptedRegionInfo encryptedRegionInfo);
    private static void WriteWrappedKey(Utf8JsonWriter json, KeyEnvelope key);
    private static void WriteEncryptionAgent(Utf8JsonWriter json, EncryptionAgent encryptionAgent);
    private static void WriteDictionary(Utf8JsonWriter json, IDictionary`2<string, string> dictionary);
    public static EncryptionData Deserialize(string serializedData);
    public static EncryptionData DeserializeEncryptionData(Utf8JsonReader& reader);
    public static EncryptionData ReadEncryptionData(JsonElement root);
    private static void ReadPropertyValue(EncryptionData data, JsonProperty property);
    private static void ReadPropertyValue(KeyEnvelope key, JsonProperty property);
    private static void ReadPropertyValue(EncryptionAgent agent, JsonProperty property);
    private static void ReadPropertyValue(EncryptedRegionInfo info, JsonProperty property);
}
internal class Azure.Storage.Cryptography.Models.KeyEnvelope : object {
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EncryptedKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    public string KeyId { get; public set; }
    public Byte[] EncryptedKey { get; public set; }
    public string Algorithm { get; public set; }
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
public void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_EncryptedKey();
    [CompilerGeneratedAttribute]
public void set_EncryptedKey(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
}
internal enum Azure.Storage.Cryptography.Models.TransformMode : Enum {
    public int value__;
    public static TransformMode Encrypt;
    public static TransformMode Decrypt;
}
internal class Azure.Storage.DisposableBucket : object {
    [CompilerGeneratedAttribute]
private List`1<IDisposable> <Disposables>k__BackingField;
    private List`1<IDisposable> Disposables { get; }
    [CompilerGeneratedAttribute]
private List`1<IDisposable> get_Disposables();
    public void Add(IDisposable disposable);
    public sealed virtual void Dispose();
}
internal class Azure.Storage.Errors : object {
    public static ArgumentException AccountMismatch(string accountNameCredential, string accountNameValue);
    public static InvalidOperationException AccountSasMissingData();
    public static ArgumentNullException ArgumentNull(string paramName);
    public static ArgumentException InvalidArgument(string paramName);
    public static ArgumentException InvalidResourceType(char s);
    public static InvalidOperationException TaskIncomplete();
    public static FormatException InvalidFormat(string err);
    public static ArgumentException ParsingConnectionStringFailed();
    public static ArgumentOutOfRangeException InvalidSasProtocol(string protocol, string sasProtocol);
    public static ArgumentException InvalidService(char s);
    public static ArgumentException InsufficientStorageTransferOptions(long streamLength, long statedMaxBlockSize, long necessaryMinBlockSize);
    public static InvalidDataException HashMismatch(string hashHeaderName);
    public static InvalidDataException ChecksumMismatch(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static InvalidDataException HashMismatchOnStreamedDownload(string mismatchedRange);
    public static ArgumentException PrecalculatedHashNotSupportedOnSplit();
    public static ArgumentException CannotDeferTransactionalHashVerification();
    public static ArgumentException CannotInitializeWriteStreamWithData();
    internal static void VerifyStreamPosition(Stream stream, string streamName);
    public static void ThrowIfParamNull(object obj, string paramName);
    internal static void CheckCryptKeySize(int keySizeInBytes);
    public static CryptographicException CryptographyAuthTagMismatch();
    public static ArgumentException CryptographyPlaintextCiphertextLengthMismatch();
    public static ArgumentException CryptographyInvalidNonceLength();
    public static ArgumentException CryptographyInvalidTagLength();
    public static ArgumentException CannotBothBeNotNull(string param0, string param1);
    public static ArgumentOutOfRangeException MustBeGreaterThanOrEqualTo(string paramName, long value);
    public static ArgumentOutOfRangeException MustBeLessThanOrEqualTo(string paramName, long value);
    public static ArgumentOutOfRangeException MustBeBetweenInclusive(string paramName, long lower, long upper, long actual);
    public static ArgumentOutOfRangeException MustBeGreaterThanValueOrEqualToOtherValue(string paramName, long value0, long value1);
    public static ArgumentException StreamMustBeReadable(string paramName);
    public static InvalidOperationException StreamMustBeAtPosition0();
    public static InvalidOperationException TokenCredentialsRequireHttps();
    public static ArgumentException SasCredentialRequiresUriWithoutSas(Uri uri);
    public static InvalidOperationException SasMissingData(string paramName);
    public static InvalidOperationException SasDataNotAllowed(string paramName, string paramNameNotAllowed);
    public static InvalidOperationException SasDataInConjunction(string paramName, string paramName2);
    public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName, string clientParam);
    public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName);
    public static InvalidOperationException SasServiceNotMatching(string builderParam, string builderName, string expectedService);
    public static InvalidOperationException SasClientMissingData(string paramName);
    public static InvalidOperationException SasBuilderEmptyParam(string builderName, string paramName, string sasType);
    public static InvalidOperationException SasIncorrectResourceType(string builderName, string builderParam, string value, string clientName);
    public static ArgumentException InvalidPermission(char s);
    public static ArgumentException ParsingHttpRangeFailed();
    public static AccessViolationException UnableAccessArray();
    public static NotImplementedException NotImplemented();
    public static AuthenticationException InvalidCredentials(string fullName);
    public static ArgumentException SeekOutsideBufferRange(long index, long inclusiveRangeStart, long exclusiveRangeEnd);
    public static ArgumentException VersionNotSupported(string paramName);
    public static RequestFailedException ClientRequestIdMismatch(Response response, string echo, string original);
    public static ArgumentException TransactionalHashingNotSupportedWithClientSideEncryption();
    public static void VerifyHttpsTokenAuth(Uri uri);
}
internal class Azure.Storage.GeoRedundantReadPolicy : HttpPipelineSynchronousPolicy {
    private string _secondaryStorageHost;
    public GeoRedundantReadPolicy(Uri secondaryStorageUri);
    public virtual void OnSendingRequest(HttpMessage message);
}
internal class Azure.Storage.HashAlgorithmHasher : object {
    private HashAlgorithm _hashAlgorithm;
    public int HashSizeInBytes { get; }
    public HashAlgorithmHasher(HashAlgorithm hashAlgorithm);
    public sealed virtual int get_HashSizeInBytes();
    [AsyncStateMachineAttribute("Azure.Storage.HashAlgorithmHasher/<ComputeHashInternal>d__4")]
public sealed virtual Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);
    public sealed virtual void AppendHash(ReadOnlySpan`1<byte> content);
    public sealed virtual int GetFinalHash(Span`1<byte> hashDestination);
    public sealed virtual void Dispose();
    private static int BitsToBytes(int bits);
}
internal interface Azure.Storage.IHasher {
    public int HashSizeInBytes { get; }
    public abstract virtual int get_HashSizeInBytes();
    public abstract virtual Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);
    public abstract virtual void AppendHash(ReadOnlySpan`1<byte> content);
    public abstract virtual int GetFinalHash(Span`1<byte> hashDestination);
}
[ExtensionAttribute]
internal static class Azure.Storage.IHasherExtensions : object {
    [ExtensionAttribute]
public static Memory`1<byte> GetFinalHash(IHasher hasher);
}
internal class Azure.Storage.Internal.Avro.AvroConstants : object {
    public static int SyncMarkerSize;
    public static Byte[] InitBytes;
    public static string CodecKey;
    public static string SchemaKey;
    public static string Null;
    public static string Boolean;
    public static string Int;
    public static string Long;
    public static string Float;
    public static string Double;
    public static string Bytes;
    public static string String;
    public static string Record;
    public static string Enum;
    public static string Map;
    public static string Array;
    public static string Union;
    public static string Fixed;
    public static string Aliases;
    public static string Name;
    public static string Fields;
    public static string Type;
    public static string Symbols;
    public static string Values;
    private static AvroConstants();
}
internal class Azure.Storage.Internal.Avro.AvroEnumType : AvroType {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Symbols>k__BackingField;
    public IReadOnlyList`1<string> Symbols { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Symbols();
    [CompilerGeneratedAttribute]
public void set_Symbols(IReadOnlyList`1<string> value);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroEnumType/<ReadAsync>d__4")]
public virtual Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Internal.Avro.AvroMapType : AvroType {
    [CompilerGeneratedAttribute]
private AvroType <ItemType>k__BackingField;
    public AvroType ItemType { get; public set; }
    [CompilerGeneratedAttribute]
public AvroType get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(AvroType value);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroMapType/<ReadAsync>d__4")]
public virtual Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroMapType/<<ReadAsync>b__4_0>d")]
[CompilerGeneratedAttribute]
private Task`1<object> <ReadAsync>b__4_0(Stream s, bool a, CancellationToken c);
}
[ExtensionAttribute]
internal static class Azure.Storage.Internal.Avro.AvroParser : object {
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadFixedBytesAsync>d__0")]
public static Task`1<Byte[]> ReadFixedBytesAsync(Stream stream, int length, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadByteAsync>d__1")]
private static Task`1<byte> ReadByteAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadZigZagLongAsync>d__2")]
private static Task`1<long> ReadZigZagLongAsync(Stream stream, bool async, CancellationToken cancellationToken);
    public static Task`1<object> ReadNullAsync();
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadBoolAsync>d__4")]
public static Task`1<bool> ReadBoolAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadLongAsync>d__5")]
public static Task`1<long> ReadLongAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadIntAsync>d__6")]
public static Task`1<int> ReadIntAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadFloatAsync>d__7")]
public static Task`1<float> ReadFloatAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadDoubleAsync>d__8")]
public static Task`1<double> ReadDoubleAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadBytesAsync>d__9")]
public static Task`1<Byte[]> ReadBytesAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadStringAsync>d__10")]
public static Task`1<string> ReadStringAsync(Stream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadMapPairAsync>d__11`1")]
private static Task`1<KeyValuePair`2<string, T>> ReadMapPairAsync(Stream stream, Func`4<Stream, bool, CancellationToken, Task`1<T>> parseItemAsync, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadMapAsync>d__12`1")]
public static Task`1<Dictionary`2<string, T>> ReadMapAsync(Stream stream, Func`4<Stream, bool, CancellationToken, Task`1<T>> parseItemAsync, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroParser/<ReadArrayAsync>d__13`1")]
private static Task`1<IEnumerable`1<T>> ReadArrayAsync(Stream stream, Func`4<Stream, bool, CancellationToken, Task`1<T>> parseItemAsync, bool async, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static List`1<T> Map(JsonElement array, Func`2<JsonElement, T> selector);
    [ExtensionAttribute]
internal static Dictionary`2<string, T> ToDictionary(IEnumerable`1<KeyValuePair`2<string, T>> values);
}
internal enum Azure.Storage.Internal.Avro.AvroPrimitive : Enum {
    public int value__;
    public static AvroPrimitive Null;
    public static AvroPrimitive Boolean;
    public static AvroPrimitive Int;
    public static AvroPrimitive Long;
    public static AvroPrimitive Float;
    public static AvroPrimitive Double;
    public static AvroPrimitive Bytes;
    public static AvroPrimitive String;
}
internal class Azure.Storage.Internal.Avro.AvroPrimitiveType : AvroType {
    [CompilerGeneratedAttribute]
private AvroPrimitive <Primitive>k__BackingField;
    public AvroPrimitive Primitive { get; public set; }
    [CompilerGeneratedAttribute]
public AvroPrimitive get_Primitive();
    [CompilerGeneratedAttribute]
public void set_Primitive(AvroPrimitive value);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroPrimitiveType/<ReadAsync>d__4")]
public virtual Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Internal.Avro.AvroReader : object {
    private Stream _dataStream;
    private Stream _headerStream;
    private Byte[] _syncMarker;
    private Dictionary`2<string, string> _metadata;
    private AvroType _itemType;
    private long _itemsRemainingInBlock;
    [CompilerGeneratedAttribute]
private long <BlockOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ObjectIndex>k__BackingField;
    private bool _initalized;
    private bool _disposed;
    private long _initialBlockOffset;
    public long BlockOffset { get; private set; }
    public long ObjectIndex { get; private set; }
    public AvroReader(Stream dataStream);
    public AvroReader(Stream dataStream, Stream headerStream, long currentBlockOffset, long indexWithinCurrentBlock);
    [CompilerGeneratedAttribute]
public virtual long get_BlockOffset();
    [CompilerGeneratedAttribute]
private void set_BlockOffset(long value);
    [CompilerGeneratedAttribute]
public virtual long get_ObjectIndex();
    [CompilerGeneratedAttribute]
private void set_ObjectIndex(long value);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroReader/<Initalize>d__20")]
public virtual Task Initalize(bool async, CancellationToken cancellationToken);
    public virtual bool HasNext();
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroReader/<Next>d__22")]
public virtual Task`1<object> Next(bool async, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Azure.Storage.Internal.Avro.AvroRecordType : AvroType {
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, AvroType> <Fields>k__BackingField;
    public string Schema { get; public set; }
    public IReadOnlyDictionary`2<string, AvroType> Fields { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, AvroType> get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(IReadOnlyDictionary`2<string, AvroType> value);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroRecordType/<ReadAsync>d__8")]
public virtual Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken);
}
internal abstract class Azure.Storage.Internal.Avro.AvroType : object {
    public abstract virtual Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken);
    public static AvroType FromSchema(JsonElement schema);
    private static AvroType FromStringSchema(JsonElement schema);
    private static AvroType FromArraySchema(JsonElement schema);
    private static AvroType FromObjectSchema(JsonElement schema);
}
internal class Azure.Storage.Internal.Avro.AvroUnionType : AvroType {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AvroType> <Types>k__BackingField;
    public IReadOnlyList`1<AvroType> Types { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AvroType> get_Types();
    [CompilerGeneratedAttribute]
public void set_Types(IReadOnlyList`1<AvroType> value);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.AvroUnionType/<ReadAsync>d__4")]
public virtual Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Internal.Avro.StreamWithPosition : Stream {
    private Stream _stream;
    private long _position;
    private bool _disposed;
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public StreamWithPosition(Stream stream, long position);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.StreamWithPosition/<ReadAsync>d__9")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Internal.Avro.StreamWithPosition/<ReadInternal>d__10")]
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
internal class Azure.Storage.LazyLoadingReadOnlyStream`1 : Stream {
    private long _position;
    private long _length;
    private int _bufferSize;
    private Byte[] _buffer;
    private int _bufferPosition;
    private int _bufferLength;
    private bool _allowBlobModifications;
    private bool _bufferInvalidated;
    private DownloadInternalAsync<TProperties> _downloadInternalFunc;
    private GetPropertiesAsync<TProperties> _getPropertiesInternalFunc;
    private DownloadTransferValidationOptions _validationOptions;
    private PredictEncryptedRangeAdjustment<TProperties> _predictEncryptedRangeAdjustment;
    public static PredictEncryptedRangeAdjustment<TProperties> NoRangeAdjustment { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LazyLoadingReadOnlyStream`1(DownloadInternalAsync<TProperties> downloadInternalFunc, GetPropertiesAsync<TProperties> getPropertiesFunc, DownloadTransferValidationOptions transferValidation, bool allowModifications, long initialLenght, long position, Nullable`1<int> bufferSize, PredictEncryptedRangeAdjustment<TProperties> rangePredictionFunc);
    public static PredictEncryptedRangeAdjustment<TProperties> get_NoRangeAdjustment();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.LazyLoadingReadOnlyStream`1/<ReadAsync>d__19")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.LazyLoadingReadOnlyStream`1/<ReadInternal>d__20")]
public Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.LazyLoadingReadOnlyStream`1/<DownloadInternal>d__21")]
private Task`1<int> DownloadInternal(bool async, CancellationToken cancellationToken);
    private static void ValidateReadParameters(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Azure.Storage.LazyLoadingReadOnlyStream`1/<GetBlobLengthInternal>d__24")]
private Task`1<long> GetBlobLengthInternal(bool async, CancellationToken cancellationToken);
    private static long GetBlobLengthFromResponse(Response response);
    private static HttpRange GetResponseRange(Response response);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    internal long CalculateNewPosition(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Azure.Storage.LoggingExtensions : object {
    [ExtensionAttribute]
public static IDisposable BeginLoggingScope(HttpPipeline pipeline, string className, string member);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogMethodEnter(HttpPipeline pipeline, string className, string member, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogMethodExit(HttpPipeline pipeline, string className, string member, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogException(HttpPipeline pipeline, Exception ex, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogTrace(HttpPipeline pipeline, string message);
}
internal class Azure.Storage.NonCryptographicHashAlgorithmHasher : object {
    private static int _streamBufferSize;
    private NonCryptographicHashAlgorithm _nonCryptographicHashAlgorithm;
    public int HashSizeInBytes { get; }
    public NonCryptographicHashAlgorithmHasher(NonCryptographicHashAlgorithm nonCryptographicHashAlgorithm);
    public sealed virtual int get_HashSizeInBytes();
    [AsyncStateMachineAttribute("Azure.Storage.NonCryptographicHashAlgorithmHasher/<ComputeHashInternal>d__5")]
public sealed virtual Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);
    public sealed virtual void AppendHash(ReadOnlySpan`1<byte> content);
    public sealed virtual int GetFinalHash(Span`1<byte> hashDestination);
    public sealed virtual void Dispose();
}
internal class Azure.Storage.NonDisposingStream : Stream {
    private Stream _innerStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public NonDisposingStream(Stream innerStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
}
internal class Azure.Storage.PartitionedUploader`2 : object {
    public static InitializeDestinationInternal<TServiceSpecificData, TCompleteUploadReturn> InitializeNoOp;
    private InitializeDestinationInternal<TServiceSpecificData, TCompleteUploadReturn> _initializeDestinationInternal;
    private SingleUploadStreamingInternal<TServiceSpecificData, TCompleteUploadReturn> _singleUploadStreamingInternal;
    private SingleUploadBinaryDataInternal<TServiceSpecificData, TCompleteUploadReturn> _singleUploadBinaryDataInternal;
    private UploadPartitionStreamingInternal<TServiceSpecificData, TCompleteUploadReturn> _uploadPartitionStreamingInternal;
    private UploadPartitionBinaryDataInternal<TServiceSpecificData, TCompleteUploadReturn> _uploadPartitionBinaryDataInternal;
    private CommitPartitionedUploadInternal<TServiceSpecificData, TCompleteUploadReturn> _commitPartitionedUploadInternal;
    private CreateScope<TServiceSpecificData, TCompleteUploadReturn> _createScope;
    private int _maxWorkerCount;
    private ArrayPool`1<byte> _arrayPool;
    private long _singleUploadThreshold;
    private Nullable`1<long> _blockSize;
    private StorageChecksumAlgorithm _validationAlgorithm;
    private Func`1<Memory`1<byte>> _masterCrcSupplier;
    private string _operationName;
    private bool UseMasterCrc { get; }
    private UploadTransferValidationOptions ValidationOptions { get; }
    public PartitionedUploader`2(Behaviors<TServiceSpecificData, TCompleteUploadReturn> behaviors, StorageTransferOptions transferOptions, UploadTransferValidationOptions transferValidation, ArrayPool`1<byte> arrayPool, string operationName);
    private static PartitionedUploader`2();
    private bool get_UseMasterCrc();
    private UploadTransferValidationOptions get_ValidationOptions();
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInternal>d__32")]
public Task`1<Response`1<TCompleteUploadReturn>> UploadInternal(BinaryData content, TServiceSpecificData args, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInternal>d__33")]
public Task`1<Response`1<TCompleteUploadReturn>> UploadInternal(Stream content, Nullable`1<long> expectedContentLength, TServiceSpecificData args, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<BufferAndOptionalChecksumStreamInternal>d__34")]
private Task`1<ValueTuple`2<Stream, UploadTransferValidationOptions>> BufferAndOptionalChecksumStreamInternal(Stream source, long minCount, long maxCount, UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInSequenceInternal>d__35`1")]
private Task`1<Response`1<TCompleteUploadReturn>> UploadInSequenceInternal(TContent content, Nullable`1<long> contentLength, long partitionSize, TServiceSpecificData args, IProgress`1<long> progressHandler, GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> partitionContentAsync, StageContentPartitionAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> stageContentAsync, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<UploadInParallelAsync>d__36`1")]
private Task`1<Response`1<TCompleteUploadReturn>> UploadInParallelAsync(TContent content, Nullable`1<long> contentLength, long blockSize, TServiceSpecificData args, IProgress`1<long> progressHandler, GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> partitionContentAsync, StageContentPartitionAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> stageContentAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<StageStreamPartitionInternal>d__37")]
private Task StageStreamPartitionInternal(Stream partition, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<StageBinaryDataPartitionInternal>d__38")]
private Task StageBinaryDataPartitionInternal(BinaryData content, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetContentPartitionsBinaryDataInternal>d__39")]
private IAsyncEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, BinaryData>> GetContentPartitionsBinaryDataInternal(BinaryData content, Nullable`1<long> contentLength, long blockSize, bool async, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetBinaryDataPartitions>d__40")]
private IEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, BinaryData>> GetBinaryDataPartitions(BinaryData content, int blockSize);
    private static GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, Stream> GetStreamPartitioner(GetNextStreamPartition<TServiceSpecificData, TCompleteUploadReturn> partitionCreator);
    [AsyncIteratorStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetStreamPartitionsAsync>d__42")]
private static IAsyncEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, Stream>> GetStreamPartitionsAsync(Stream stream, Nullable`1<long> streamLength, long blockSize, GetNextStreamPartition<TServiceSpecificData, TCompleteUploadReturn> getNextPartition, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetBufferedPartitionInternal>d__43")]
private Task`1<ValueTuple`2<Stream, ReadOnlyMemory`1<byte>>> GetBufferedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.PartitionedUploader`2/<GetStreamedPartitionInternal>d__44")]
private Task`1<ValueTuple`2<Stream, ReadOnlyMemory`1<byte>>> GetStreamedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.ProgressIncrementingStream : Stream {
    private Stream _innerStream;
    private AggregatingProgressIncrementer _incrementer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public ProgressIncrementingStream(Stream stream, AggregatingProgressIncrementer incrementer);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Azure.Storage.ProgressIncrementingStream/<FlushAsync>d__12")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ProgressIncrementingStream/<ReadAsync>d__20")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.ProgressIncrementingStream/<WriteAsync>d__28")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
[FlagsAttribute]
public enum Azure.Storage.Sas.BlobAccountSasPermissions : Enum {
    public int value__;
    public static BlobAccountSasPermissions Read;
    public static BlobAccountSasPermissions Add;
    public static BlobAccountSasPermissions Create;
    public static BlobAccountSasPermissions Write;
    public static BlobAccountSasPermissions Delete;
    public static BlobAccountSasPermissions List;
    public static BlobAccountSasPermissions All;
}
[FlagsAttribute]
public enum Azure.Storage.Sas.BlobContainerSasPermissions : Enum {
    public int value__;
    public static BlobContainerSasPermissions Read;
    public static BlobContainerSasPermissions Add;
    public static BlobContainerSasPermissions Create;
    public static BlobContainerSasPermissions Write;
    public static BlobContainerSasPermissions Delete;
    public static BlobContainerSasPermissions List;
    public static BlobContainerSasPermissions Tag;
    public static BlobContainerSasPermissions DeleteBlobVersion;
    public static BlobContainerSasPermissions Move;
    public static BlobContainerSasPermissions Execute;
    public static BlobContainerSasPermissions SetImmutabilityPolicy;
    public static BlobContainerSasPermissions Filter;
    public static BlobContainerSasPermissions All;
}
public class Azure.Storage.Sas.BlobSasBuilder : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SasProtocol <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private SasIPRange <IPRange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlobContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlobName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlobVersionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreauthorizedAgentObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [EditorBrowsableAttribute("1")]
public string Version { get; public set; }
    public SasProtocol Protocol { get; public set; }
    public DateTimeOffset StartsOn { get; public set; }
    public DateTimeOffset ExpiresOn { get; public set; }
    public string Permissions { get; private set; }
    public SasIPRange IPRange { get; public set; }
    public string Identifier { get; public set; }
    public string BlobContainerName { get; public set; }
    public string BlobName { get; public set; }
    public string Snapshot { get; public set; }
    public string BlobVersionId { get; public set; }
    public string Resource { get; public set; }
    public string CacheControl { get; public set; }
    public string ContentDisposition { get; public set; }
    public string ContentEncoding { get; public set; }
    public string ContentLanguage { get; public set; }
    public string ContentType { get; public set; }
    public string PreauthorizedAgentObjectId { get; public set; }
    public string CorrelationId { get; public set; }
    public string EncryptionScope { get; public set; }
    public BlobSasBuilder(BlobSasPermissions permissions, DateTimeOffset expiresOn);
    public BlobSasBuilder(BlobContainerSasPermissions permissions, DateTimeOffset expiresOn);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public SasProtocol get_Protocol();
    [CompilerGeneratedAttribute]
public void set_Protocol(SasProtocol value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartsOn();
    [CompilerGeneratedAttribute]
public void set_StartsOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
private void set_Permissions(string value);
    [CompilerGeneratedAttribute]
public SasIPRange get_IPRange();
    [CompilerGeneratedAttribute]
public void set_IPRange(SasIPRange value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public string get_BlobContainerName();
    [CompilerGeneratedAttribute]
public void set_BlobContainerName(string value);
    [CompilerGeneratedAttribute]
public string get_BlobName();
    [CompilerGeneratedAttribute]
public void set_BlobName(string value);
    [CompilerGeneratedAttribute]
public string get_Snapshot();
    [CompilerGeneratedAttribute]
public void set_Snapshot(string value);
    [CompilerGeneratedAttribute]
public string get_BlobVersionId();
    [CompilerGeneratedAttribute]
public void set_BlobVersionId(string value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
public void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_PreauthorizedAgentObjectId();
    [CompilerGeneratedAttribute]
public void set_PreauthorizedAgentObjectId(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public void set_EncryptionScope(string value);
    public void SetPermissions(BlobSasPermissions permissions);
    public void SetPermissions(BlobAccountSasPermissions permissions);
    public void SetPermissions(BlobContainerSasPermissions permissions);
    public void SetPermissions(SnapshotSasPermissions permissions);
    public void SetPermissions(BlobVersionSasPermissions permissions);
    public void SetPermissions(string rawPermissions, bool normalize);
    public void SetPermissions(string rawPermissions);
    [CallerShouldAuditAttribute]
public BlobSasQueryParameters ToSasQueryParameters(StorageSharedKeyCredential sharedKeyCredential);
    [CallerShouldAuditAttribute]
public BlobSasQueryParameters ToSasQueryParameters(UserDelegationKey userDelegationKey, string accountName);
    private static string GetCanonicalName(string account, string containerName, string blobName);
    private static string ComputeHMACSHA256(string userDelegationKeyValue, string message);
    private void EnsureState();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    internal static BlobSasBuilder DeepCopy(BlobSasBuilder originalBlobSasBuilder);
}
[FlagsAttribute]
public enum Azure.Storage.Sas.BlobSasPermissions : Enum {
    public int value__;
    public static BlobSasPermissions Read;
    public static BlobSasPermissions Add;
    public static BlobSasPermissions Create;
    public static BlobSasPermissions Write;
    public static BlobSasPermissions Delete;
    public static BlobSasPermissions Tag;
    public static BlobSasPermissions DeleteBlobVersion;
    public static BlobSasPermissions List;
    public static BlobSasPermissions Move;
    public static BlobSasPermissions Execute;
    public static BlobSasPermissions SetImmutabilityPolicy;
    public static BlobSasPermissions PermanentDelete;
    public static BlobSasPermissions All;
}
public class Azure.Storage.Sas.BlobSasQueryParameters : SasQueryParameters {
    [CompilerGeneratedAttribute]
private UserDelegationKeyProperties <KeyProperties>k__BackingField;
    internal UserDelegationKeyProperties KeyProperties { get; internal set; }
    public string KeyObjectId { get; }
    public string KeyTenantId { get; }
    public DateTimeOffset KeyStartsOn { get; }
    public DateTimeOffset KeyExpiresOn { get; }
    public string KeyService { get; }
    public string KeyVersion { get; }
    public static BlobSasQueryParameters Empty { get; }
    internal BlobSasQueryParameters(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string keyOid, string keyTid, DateTimeOffset keyStart, DateTimeOffset keyExpiry, string keyService, string keyVersion, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, string encryptionScope);
    internal BlobSasQueryParameters(IDictionary`2<string, string> values);
    [CompilerGeneratedAttribute]
internal UserDelegationKeyProperties get_KeyProperties();
    [CompilerGeneratedAttribute]
internal void set_KeyProperties(UserDelegationKeyProperties value);
    public string get_KeyObjectId();
    public string get_KeyTenantId();
    public DateTimeOffset get_KeyStartsOn();
    public DateTimeOffset get_KeyExpiresOn();
    public string get_KeyService();
    public string get_KeyVersion();
    public static BlobSasQueryParameters get_Empty();
    public virtual string ToString();
}
[FlagsAttribute]
public enum Azure.Storage.Sas.BlobVersionSasPermissions : Enum {
    public int value__;
    public static BlobVersionSasPermissions Delete;
    public static BlobVersionSasPermissions SetImmutabilityPolicy;
    public static BlobVersionSasPermissions PermanentDelete;
    public static BlobVersionSasPermissions All;
}
[ExtensionAttribute]
internal static class Azure.Storage.Sas.SasExtensions : object {
    private static string NoneName;
    private static string HttpsName;
    private static string HttpsAndHttpName;
    [ExtensionAttribute]
internal static string ToPermissionsString(AccountSasResourceTypes resourceTypes);
    internal static AccountSasResourceTypes ParseResourceTypes(string s);
    [ExtensionAttribute]
internal static string ToProtocolString(SasProtocol protocol);
    public static SasProtocol ParseProtocol(string s);
    [ExtensionAttribute]
internal static string ToPermissionsString(AccountSasServices services);
    internal static AccountSasServices ParseAccountServices(string s);
    internal static string FormatTimesForSasSigning(DateTimeOffset time);
    internal static void AddToBuilder(StringBuilder sb, string key, string value);
    internal static string ValidateAndSanitizeRawPermissions(string permissions, List`1<char> validPermissionsInOrder);
}
[ExtensionAttribute]
internal static class Azure.Storage.Sas.SasQueryParametersExtensions : object {
    [ExtensionAttribute]
internal static void ParseKeyProperties(BlobSasQueryParameters parameters, IDictionary`2<string, string> values);
}
internal class Azure.Storage.Sas.SasQueryParametersInternals : SasQueryParameters {
    [CompilerGeneratedAttribute]
private static string <DefaultSasVersionInternal>k__BackingField;
    internal static string DefaultSasVersionInternal { get; internal set; }
    private static SasQueryParametersInternals();
    [CompilerGeneratedAttribute]
internal static string get_DefaultSasVersionInternal();
    [CompilerGeneratedAttribute]
internal static void set_DefaultSasVersionInternal(string value);
    internal static SasQueryParameters Create(IDictionary`2<string, string> values);
    internal static SasQueryParameters Create(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth, string encryptionScope);
}
[FlagsAttribute]
public enum Azure.Storage.Sas.SnapshotSasPermissions : Enum {
    public int value__;
    public static SnapshotSasPermissions Read;
    public static SnapshotSasPermissions Write;
    public static SnapshotSasPermissions Delete;
    public static SnapshotSasPermissions SetImmutabilityPolicy;
    public static SnapshotSasPermissions PermanentDelete;
    public static SnapshotSasPermissions All;
}
internal class Azure.Storage.Sas.UserDelegationKeyProperties : object {
    [CompilerGeneratedAttribute]
private string <ObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    internal string ObjectId { get; internal set; }
    internal string TenantId { get; internal set; }
    internal DateTimeOffset StartsOn { get; internal set; }
    internal DateTimeOffset ExpiresOn { get; internal set; }
    internal string Service { get; internal set; }
    internal string Version { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_ObjectId();
    [CompilerGeneratedAttribute]
internal void set_ObjectId(string value);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_StartsOn();
    [CompilerGeneratedAttribute]
internal void set_StartsOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
internal string get_Service();
    [CompilerGeneratedAttribute]
internal void set_Service(string value);
    [CompilerGeneratedAttribute]
internal string get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(string value);
    public void AppendProperties(StringBuilder stringBuilder);
}
internal interface Azure.Storage.Shared.IDownloadedContent {
    public Stream Content { get; }
    public abstract virtual Stream get_Content();
}
internal interface Azure.Storage.Shared.ISupportsTenantIdChallenges {
    public bool EnableTenantDiscovery { get; }
    public abstract virtual bool get_EnableTenantDiscovery();
}
internal class Azure.Storage.Shared.PooledMemoryStream : Stream {
    private static int DefaultMaxArrayPoolRentalSize;
    [CompilerGeneratedAttribute]
private int <MaxArraySize>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayPool`1<byte> <ArrayPool>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BufferPartition> <BufferSet>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public int MaxArraySize { get; }
    public ArrayPool`1<byte> ArrayPool { get; }
    private List`1<BufferPartition> BufferSet { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PooledMemoryStream(ArrayPool`1<byte> arrayPool, int maxArraySize);
    [CompilerGeneratedAttribute]
public int get_MaxArraySize();
    [CompilerGeneratedAttribute]
public ArrayPool`1<byte> get_ArrayPool();
    [CompilerGeneratedAttribute]
private List`1<BufferPartition> get_BufferSet();
    [AsyncStateMachineAttribute("Azure.Storage.Shared.PooledMemoryStream/<BufferStreamPartitionInternal>d__13")]
internal static Task`1<PooledMemoryStream> BufferStreamPartitionInternal(Stream stream, long minCount, long maxCount, ArrayPool`1<byte> arrayPool, Nullable`1<int> maxArrayPoolRentalSize, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.PooledMemoryStream/<ReadLoopInternal>d__14")]
private static Task`1<int> ReadLoopInternal(Stream stream, Byte[] buffer, int offset, int minCount, int maxCount, bool async, CancellationToken cancellationToken);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
public virtual long get_Position();
    [CompilerGeneratedAttribute]
public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private ValueTuple`3<Byte[], int, long> GetBufferFromPosition();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    public void Clear();
    private void AssertPositionInBounds();
    private BufferPartition GetLatestBufferWithAvailableSpaceOrDefault();
    private static long Min(long val1, long val2, long val3);
}
internal class Azure.Storage.Shared.StorageClientConfiguration : object {
    [CompilerGeneratedAttribute]
private HttpPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageSharedKeyCredential <SharedKeyCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCredential <TokenCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureSasCredential <SasCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    public HttpPipeline Pipeline { get; private set; }
    public StorageSharedKeyCredential SharedKeyCredential { get; private set; }
    public TokenCredential TokenCredential { get; private set; }
    public AzureSasCredential SasCredential { get; private set; }
    public ClientDiagnostics ClientDiagnostics { get; private set; }
    public StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics);
    public StorageClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics);
    public StorageClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics);
    internal StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics);
    internal StorageClientConfiguration(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics);
    [CompilerGeneratedAttribute]
public virtual HttpPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
private void set_Pipeline(HttpPipeline value);
    [CompilerGeneratedAttribute]
public virtual StorageSharedKeyCredential get_SharedKeyCredential();
    [CompilerGeneratedAttribute]
private void set_SharedKeyCredential(StorageSharedKeyCredential value);
    [CompilerGeneratedAttribute]
public virtual TokenCredential get_TokenCredential();
    [CompilerGeneratedAttribute]
private void set_TokenCredential(TokenCredential value);
    [CompilerGeneratedAttribute]
public virtual AzureSasCredential get_SasCredential();
    [CompilerGeneratedAttribute]
private void set_SasCredential(AzureSasCredential value);
    [CompilerGeneratedAttribute]
public virtual ClientDiagnostics get_ClientDiagnostics();
    [CompilerGeneratedAttribute]
private void set_ClientDiagnostics(ClientDiagnostics value);
}
[ExtensionAttribute]
internal static class Azure.Storage.Shared.StorageExtensions : object {
    [ExtensionAttribute]
public static string EscapePath(string path, bool trimOuterSlashes);
    [ExtensionAttribute]
public static string UnescapePath(string path, bool trimOuterSlashes);
    public static string GenerateBlockId(long offset);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageExtensions/<GetCopyAuthorizationHeaderAsync>d__3")]
[ExtensionAttribute]
public static Task`1<HttpAuthorization> GetCopyAuthorizationHeaderAsync(TokenCredential tokenCredential, CancellationToken cancellationToken);
    public static IDisposable CreateClientSideEncryptionScope(ClientSideEncryptionVersion version);
}
internal abstract class Azure.Storage.Shared.StorageWriteStream : Stream {
    protected long _position;
    protected long _bufferSize;
    protected IProgress`1<long> _progressHandler;
    protected PooledMemoryStream _buffer;
    private ArrayPool`1<byte> _bufferPool;
    private StorageChecksumAlgorithm _checksumAlgorithm;
    private StorageCrc64HashAlgorithm _masterCrcChecksummer;
    private Memory`1<byte> _composedCrc;
    private Memory`1<byte> _userProvidedChecksum;
    private IHasher _bufferChecksumer;
    private bool _disposed;
    private DisposableBucket _accumulatedDisposables;
    private bool UseMasterCrc { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected StorageWriteStream(long position, long bufferSize, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidation, PooledMemoryStream buffer, ArrayPool`1<byte> bufferPool);
    private bool get_UseMasterCrc();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<WriteAsync>d__30")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<WriteInternal>d__31")]
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<FlushAsync>d__33")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<FlushInternal>d__34")]
private Task FlushInternal(bool async, CancellationToken cancellationToken);
    protected virtual Task CommitInternal(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<AppendAndClearBufferInternal>d__36")]
private Task AppendAndClearBufferInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    protected abstract virtual Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);
    protected abstract virtual void ValidateBufferSize(long bufferSize);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.StorageWriteStream/<WriteToBufferInternal>d__39")]
protected Task WriteToBufferInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    protected static void ValidateWriteParameters(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void ValidateCallerCrcIfAny();
    protected IDisposable FinalizeAndReplaceBufferChecksum(UploadTransferValidationOptions& validationOptions);
}
[ExtensionAttribute]
internal static class Azure.Storage.Shared.StreamExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<long> GetPositionOrDefault(Stream content);
}
internal abstract class Azure.Storage.Shared.WindowStream : Stream {
    [CompilerGeneratedAttribute]
private Stream <InnerStream>k__BackingField;
    private Stream InnerStream { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    private WindowStream(Stream stream);
    [CompilerGeneratedAttribute]
private Stream get_InnerStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public static Stream GetWindow(Stream stream, long maxWindowLength);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.WindowStream/<ReadAsync>d__14")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Shared.WindowStream/<ReadInternal>d__15")]
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    protected abstract virtual int AdjustCount(int count);
    protected abstract virtual void ReportInnerStreamRead(int resultRead);
}
internal class Azure.Storage.SharedAccessSignatureCredentials : object {
    [CompilerGeneratedAttribute]
private string <SasToken>k__BackingField;
    public string SasToken { get; }
    public SharedAccessSignatureCredentials(string sasToken);
    [CompilerGeneratedAttribute]
public string get_SasToken();
}
internal class Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy : BearerTokenAuthenticationPolicy {
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _scopes;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) tenantId;
    private bool _enableTenantDiscovery;
    public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, string scope, bool enableTenantDiscovery);
    public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, IEnumerable`1<string> scopes, bool enableTenantDiscovery);
    protected virtual void AuthorizeRequest(HttpMessage message);
    protected virtual ValueTask AuthorizeRequestAsync(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy/<AuthorizeRequestInternal>d__7")]
private ValueTask AuthorizeRequestInternal(HttpMessage message, bool async);
    protected virtual bool AuthorizeRequestOnChallenge(HttpMessage message);
    protected virtual ValueTask`1<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy/<AuthorizeRequestOnChallengeInternalAsync>d__10")]
private ValueTask`1<bool> AuthorizeRequestOnChallengeInternalAsync(HttpMessage message, bool async);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageClientOptions : object {
    private static string StorageScope;
    [ExtensionAttribute]
public static void Initialize(ClientOptions options);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(StorageSharedKeyCredential credential);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(AzureSasCredential credential, Uri resourceUri);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(TokenCredential credential, string scope, ClientOptions options);
    public static HttpPipelinePolicy GetAuthenticationPolicy(object credentials, string scope, ClientOptions options);
    [ExtensionAttribute]
public static HttpPipeline Build(ClientOptions options, HttpPipelinePolicy authentication, Uri geoRedundantSecondaryStorageUri);
    [ExtensionAttribute]
public static HttpPipeline Build(ClientOptions options, object credentials, Uri geoRedundantSecondaryStorageUri);
}
internal abstract class Azure.Storage.StorageCollectionEnumerator`1 : object {
    public abstract virtual ValueTask`1<Page`1<T>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    public Pageable`1<T> ToSyncCollection(CancellationToken cancellationToken);
    public AsyncPageable`1<T> ToAsyncCollection(CancellationToken cancellationToken);
}
internal class Azure.Storage.StorageConnectionString : object {
    private static KeyValuePair`2<string, Func`2<string, bool>> s_useDevelopmentStorageSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_developmentStorageProxyUriSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_defaultEndpointsProtocolSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountNameSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountKeyNameSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountKeySetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_blobEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_queueEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_fileEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_tableEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_blobSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_queueSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_fileSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_tableSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_endpointSuffixSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_sharedAccessSignatureSetting;
    private static StorageConnectionString s_devStoreAccount;
    [CompilerGeneratedAttribute]
private bool <IsDevStoreAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultEndpoints>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <BlobStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <QueueStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <TableStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <FileStorageUri>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Credentials>k__BackingField;
    internal string _accountName;
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> s_validCredentials;
    internal static bool UseV1MD5 { get; }
    public static StorageConnectionString DevelopmentStorageAccount { get; }
    internal bool IsDevStoreAccount { get; internal set; }
    internal string EndpointSuffix { get; internal set; }
    internal IDictionary`2<string, string> Settings { get; internal set; }
    internal bool DefaultEndpoints { get; internal set; }
    public Uri BlobEndpoint { get; }
    public Uri QueueEndpoint { get; }
    public Uri TableEndpoint { get; }
    public Uri FileEndpoint { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> BlobStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> QueueStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> TableStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> FileStorageUri { get; public set; }
    public object Credentials { get; public set; }
    public StorageConnectionString(object storageCredentials, ValueTuple`2<Uri, Uri> blobStorageUri, ValueTuple`2<Uri, Uri> queueStorageUri, ValueTuple`2<Uri, Uri> tableStorageUri, ValueTuple`2<Uri, Uri> fileStorageUri);
    private static StorageConnectionString();
    internal static bool get_UseV1MD5();
    public static StorageConnectionString get_DevelopmentStorageAccount();
    [CompilerGeneratedAttribute]
internal bool get_IsDevStoreAccount();
    [CompilerGeneratedAttribute]
internal void set_IsDevStoreAccount(bool value);
    [CompilerGeneratedAttribute]
internal string get_EndpointSuffix();
    [CompilerGeneratedAttribute]
internal void set_EndpointSuffix(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
internal bool get_DefaultEndpoints();
    [CompilerGeneratedAttribute]
internal void set_DefaultEndpoints(bool value);
    public Uri get_BlobEndpoint();
    public Uri get_QueueEndpoint();
    public Uri get_TableEndpoint();
    public Uri get_FileEndpoint();
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_BlobStorageUri();
    [CompilerGeneratedAttribute]
public void set_BlobStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_QueueStorageUri();
    [CompilerGeneratedAttribute]
public void set_QueueStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_TableStorageUri();
    [CompilerGeneratedAttribute]
public void set_TableStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_FileStorageUri();
    [CompilerGeneratedAttribute]
public void set_FileStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public object get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(object value);
    public static StorageConnectionString Parse(string connectionString);
    public static bool TryParse(string connectionString, StorageConnectionString& account);
    private static StorageConnectionString GetDevelopmentStorageAccount(Uri proxyUri);
    internal static bool ParseCore(string connectionString, StorageConnectionString& accountInformation, Action`1<string> error);
    private static IDictionary`2<string, string> ParseStringIntoSettings(string connectionString, Action`1<string> error);
    private static KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, String[] validValues);
    private static KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, Func`2<string, bool> isValid);
    private static bool IsValidBase64String(string settingValue);
    private static bool IsValidUri(string settingValue);
    private static bool IsValidDomain(string settingValue);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AllRequired(KeyValuePair`2[] requiredSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> Optional(KeyValuePair`2[] optionalSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AtLeastOne(KeyValuePair`2[] atLeastOneSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> None(KeyValuePair`2[] atLeastOneSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesAll(Func`2[] filters);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesOne(Func`2[] filters);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesExactly(Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> filter);
    private static bool MatchesSpecification(IDictionary`2<string, string> settings, Func`2[] constraints);
    private static object GetCredentials(IDictionary`2<string, string> settings);
    private static ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructFileEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructFileEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructTableEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructTableEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructUris(string scheme, string accountName, string hostNamePrefix, string endpointSuffix, string sasToken);
    [CompilerGeneratedAttribute]
internal static string <ParseCore>g__settingOrDefault|70_0(string key, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
internal static bool <ParseCore>g__s_isValidEndpointPair|70_1(string primary, string secondary);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<Uri, Uri> <ParseCore>g__createStorageUri|70_2(string primary, string secondary, string sasToken, Func`2<IDictionary`2<string, string>, ValueTuple`2<Uri, Uri>> factory, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
internal static Uri <ParseCore>g__CreateUri|70_3(string endpoint, string sasToken);
}
internal static class Azure.Storage.StorageCrc64Calculator : object {
    private static ulong poly;
    private static UInt64[] m_u1;
    private static UInt64[] m_u32;
    private static UInt64[] m_uX2N;
    private static ulong m_uComplement;
    private static int m_uBitWidth;
    private static StorageCrc64Calculator();
    public static ulong ComputeSlicedSafe(ReadOnlySpan`1<byte> src, ulong uCrc);
    internal static ulong Concatenate(ulong uInitialCrcAB, ulong uInitialCrcA, ulong uFinalCrcA, ulong uSizeA, ulong uInitialCrcB, ulong uFinalCrcB, ulong uSizeB);
    private static ulong MulX_N(ulong a, ulong uSize);
    private static ulong MulPoly(ulong a, ulong b);
    private static ulong MulPolyUnrolled(ulong a, ulong b);
}
internal static class Azure.Storage.StorageCrc64Composer : object {
    public static Memory`1<byte> Compose(ValueTuple`2[] partitions);
    public static Memory`1<byte> Compose(IEnumerable`1<ValueTuple`2<Byte[], long>> partitions);
    public static ulong Compose(IEnumerable`1<ValueTuple`2<ulong, long>> partitions);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageExceptionExtensions : object {
    [ExtensionAttribute]
public static string GetErrorCode(Response response, string errorCode);
    [ExtensionAttribute]
public static bool IsUnavailable(Response`1<T> response);
    [ExtensionAttribute]
public static Response`1<T> AsNoBodyResponse(Response rawResponse);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageProgressExtensions : object {
    [ExtensionAttribute]
public static Stream WithProgress(Stream stream, IProgress`1<long> progressHandler);
}
internal class Azure.Storage.StorageRequestValidationPipelinePolicy : HttpPipelineSynchronousPolicy {
    public virtual void OnReceivedResponse(HttpMessage message);
}
internal class Azure.Storage.StorageResponseClassifier : ResponseClassifier {
    [CompilerGeneratedAttribute]
private Uri <SecondaryStorageUri>k__BackingField;
    public Uri SecondaryStorageUri { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_SecondaryStorageUri();
    [CompilerGeneratedAttribute]
public void set_SecondaryStorageUri(Uri value);
    public virtual bool IsRetriableResponse(HttpMessage message);
    public virtual bool IsErrorResponse(HttpMessage message);
}
internal class Azure.Storage.StorageServerTimeoutPolicy : HttpPipelineSynchronousPolicy {
    private static string QueryParameterKeyWithEqualSign;
    [CompilerGeneratedAttribute]
private static StorageServerTimeoutPolicy <Shared>k__BackingField;
    public static StorageServerTimeoutPolicy Shared { get; }
    private static StorageServerTimeoutPolicy();
    [CompilerGeneratedAttribute]
public static StorageServerTimeoutPolicy get_Shared();
    public virtual void OnSendingRequest(HttpMessage message);
}
internal class Azure.Storage.StorageSharedKeyCredentialInternals : StorageSharedKeyCredential {
    private StorageSharedKeyCredentialInternals(string accountName, string accountKey);
    internal static string ComputeSasSignature(StorageSharedKeyCredential credential, string message);
}
internal class Azure.Storage.StorageSharedKeyPipelinePolicy : HttpPipelineSynchronousPolicy {
    private static bool IncludeXMsDate;
    private StorageSharedKeyCredential _credentials;
    public StorageSharedKeyPipelinePolicy(StorageSharedKeyCredential credentials);
    public virtual void OnSendingRequest(HttpMessage message);
    private string BuildStringToSign(HttpMessage message);
    private static void BuildCanonicalizedHeaders(StringBuilder stringBuilder, HttpMessage message);
    private void BuildCanonicalizedResource(StringBuilder stringBuilder, Uri resource);
}
internal class Azure.Storage.StorageTelemetryPolicy : HttpPipelineSynchronousPolicy {
    private static string CseIdentifierV2;
    private static string CseIdentifierV1;
    [CompilerGeneratedAttribute]
private static StorageTelemetryPolicy <Shared>k__BackingField;
    public static StorageTelemetryPolicy Shared { get; }
    private static StorageTelemetryPolicy();
    [CompilerGeneratedAttribute]
public static StorageTelemetryPolicy get_Shared();
    public virtual void OnSendingRequest(HttpMessage message);
    private static void ApplyAzFeatures(HttpMessage message, AzFeatures azFeatures);
    private static string Serialize(AzFeatures azFeatures);
    private static string TransformUserAgent(string userAgent, string injection);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageVersionExtensions : object {
    public static ServiceVersion LatestVersion;
    internal static ServiceVersion MaxVersion;
    [ExtensionAttribute]
public static string ToVersionString(ServiceVersion version);
}
[ExtensionAttribute]
internal static class Azure.Storage.StreamExtensions : object {
    [ExtensionAttribute]
public static Stream WithNoDispose(Stream stream);
    [ExtensionAttribute]
public static Nullable`1<long> GetLengthOrDefault(Stream content);
    [AsyncStateMachineAttribute("Azure.Storage.StreamExtensions/<ReadInternal>d__2")]
[ExtensionAttribute]
public static Task`1<int> ReadInternal(Stream stream, Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.StreamExtensions/<WriteInternal>d__3")]
[ExtensionAttribute]
public static Task WriteInternal(Stream stream, Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task CopyToInternal(Stream src, Stream dest, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.StreamExtensions/<CopyToInternal>d__5")]
[ExtensionAttribute]
public static Task CopyToInternal(Stream src, Stream dest, int bufferSize, bool async, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Azure.Storage.TransferValidationOptionsExtensions : object {
    [ExtensionAttribute]
public static StorageChecksumAlgorithm ResolveAuto(StorageChecksumAlgorithm checksumAlgorithm);
    [ExtensionAttribute]
public static UploadTransferValidationOptions ToValidationOptions(Byte[] md5);
    [ExtensionAttribute]
public static DownloadTransferValidationOptions ToValidationOptions(bool requestTransactionalMD5);
    [ExtensionAttribute]
public static void CopyTo(TransferValidationOptions source, TransferValidationOptions dest);
    [ExtensionAttribute]
public static void CopyTo(UploadTransferValidationOptions source, UploadTransferValidationOptions dest);
    [ExtensionAttribute]
public static void CopyTo(DownloadTransferValidationOptions source, DownloadTransferValidationOptions dest);
}
[ExtensionAttribute]
internal static class Azure.Storage.UriExtensions : object {
    [ExtensionAttribute]
public static Uri AppendToPath(Uri uri, string segment);
    [ExtensionAttribute]
public static IDictionary`2<string, string> GetQueryParameters(Uri uri);
    [ExtensionAttribute]
public static string GetAccountNameFromDomain(Uri uri, string serviceSubDomain);
    public static string GetAccountNameFromDomain(string host, string serviceSubDomain);
    [ExtensionAttribute]
public static string GetPath(Uri uri);
    [ExtensionAttribute]
public static bool IsHostIPEndPointStyle(Uri uri);
    [ExtensionAttribute]
internal static void AppendQueryParameter(StringBuilder sb, string key, string value);
}
internal class Azure.Storage.UriQueryParamsCollection : Dictionary`2<string, string> {
    public UriQueryParamsCollection(string encodedQueryParamString);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.Azure.BlobClientBuilderExtensions : object {
    [ExtensionAttribute]
public static IAzureClientBuilder`2<BlobServiceClient, BlobClientOptions> AddBlobServiceClient(TBuilder builder, string connectionString);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<BlobServiceClient, BlobClientOptions> AddBlobServiceClient(TBuilder builder, Uri serviceUri);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<BlobServiceClient, BlobClientOptions> AddBlobServiceClient(TBuilder builder, Uri serviceUri, StorageSharedKeyCredential sharedKeyCredential);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<BlobServiceClient, BlobClientOptions> AddBlobServiceClient(TBuilder builder, TConfiguration configuration);
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
