[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Autorest.CSharp.Core.GeneratorPageableHelpers : object {
    private static Byte[] DefaultItemPropertyName;
    private static Byte[] DefaultNextLinkPropertyName;
    private static GeneratorPageableHelpers();
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Autorest.CSharp.Core.GeneratorPageableHelpers/<CreateAsyncPageable>d__10`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
}
internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
internal static class Azure.Core.Argument : object {
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static void AssertEnumDefined(Type enumType, object value, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    [NullableContextAttribute("1")]
public static void AssertNull(T value, string name, string message);
}
internal class Azure.Core.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private static int DefaultInitialBufferSize;
    [CompilerGeneratedAttribute]
private int <WrittenCount>k__BackingField;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; private set; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    [CompilerGeneratedAttribute]
public int get_WrittenCount();
    [CompilerGeneratedAttribute]
private void set_WrittenCount(int value);
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.AsyncLockWithValue`1 : object {
    private object _syncObj;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters;
    private bool _isLocked;
    private bool _hasValue;
    private long _index;
    [NullableAttribute("2")]
private T _value;
    public bool HasValue { get; }
    public AsyncLockWithValue`1(T value);
    public bool get_HasValue();
    [NullableContextAttribute("2")]
public bool TryGetValue(T& value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.AsyncLockWithValue`1/<GetLockOrValueAsync>d__11")]
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken);
    private void SetValue(T value, Int64& lockIndex);
    private void Reset(Int64& lockIndex);
    private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter);
}
internal static class Azure.Core.AuthorizationChallengeParser : object {
    [NullableContextAttribute("1")]
public static string GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter);
    internal static bool TryGetNextChallenge(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& challengeKey);
    internal static bool TryGetNextParameter(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& paramKey, ReadOnlySpan`1& paramValue, char separator);
}
[AttributeUsageAttribute("1")]
internal class Azure.Core.AzureResourceProviderNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ResourceProviderNamespace>k__BackingField;
    public string ResourceProviderNamespace { get; }
    public AzureResourceProviderNamespaceAttribute(string resourceProviderNamespace);
    [CompilerGeneratedAttribute]
public string get_ResourceProviderNamespace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.AzureSasCredentialSynchronousPolicy : HttpPipelineSynchronousPolicy {
    private AzureSasCredential _credential;
    public AzureSasCredentialSynchronousPolicy(AzureSasCredential credential);
    public virtual void OnSendingRequest(HttpMessage message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Azure.Core.CallerShouldAuditAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Azure.Core.ChangeTrackingDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<TKey, TValue> _innerDictionary;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public ChangeTrackingDictionary`2(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optionalDictionary);
    public ChangeTrackingDictionary`2(Optional`1<IDictionary`2<TKey, TValue>> optionalDictionary);
    private ChangeTrackingDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    private ChangeTrackingDictionary`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    public bool get_IsUndefined();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private IDictionary`2<TKey, TValue> EnsureDictionary();
    [IteratorStateMachineAttribute("Azure.Core.ChangeTrackingDictionary`2/<<GetEnumerator>g__GetEmptyEnumerator|8_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__GetEmptyEnumerator|8_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Azure.Core.ChangeTrackingList`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<T> _innerList;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ChangeTrackingList`1(Optional`1<IList`1<T>> optionalList);
    public ChangeTrackingList`1(Optional`1<IReadOnlyList`1<T>> optionalList);
    private ChangeTrackingList`1(IEnumerable`1<T> innerList);
    private ChangeTrackingList`1(IList`1<T> innerList);
    public bool get_IsUndefined();
    public void Reset();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private IList`1<T> EnsureList();
    [IteratorStateMachineAttribute("Azure.Core.ChangeTrackingList`1/<<GetEnumerator>g__EnumerateEmpty|9_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<T> <GetEnumerator>g__EnumerateEmpty|9_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Azure.Core.CodeGenClientAttribute : CodeGenTypeAttribute {
    [CompilerGeneratedAttribute]
private Type <ParentClient>k__BackingField;
    public Type ParentClient { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenClientAttribute(string originalName);
    [CompilerGeneratedAttribute]
public Type get_ParentClient();
    [CompilerGeneratedAttribute]
public void set_ParentClient(Type value);
}
[AttributeUsageAttribute("384")]
internal class Azure.Core.CodeGenMemberAttribute : CodeGenTypeAttribute {
    [NullableContextAttribute("1")]
public CodeGenMemberAttribute(string originalName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
internal class Azure.Core.CodeGenMemberSerializationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <SerializationPath>k__BackingField;
    public String[] SerializationPath { get; }
    public CodeGenMemberSerializationAttribute(String[] serializationPath);
    [CompilerGeneratedAttribute]
public String[] get_SerializationPath();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
internal class Azure.Core.CodeGenMemberSerializationHooksAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <SerializationValueHook>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeserializationValueHook>k__BackingField;
    public string SerializationValueHook { get; public set; }
    public string DeserializationValueHook { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SerializationValueHook();
    [CompilerGeneratedAttribute]
public void set_SerializationValueHook(string value);
    [CompilerGeneratedAttribute]
public string get_DeserializationValueHook();
    [CompilerGeneratedAttribute]
public void set_DeserializationValueHook(string value);
}
[AttributeUsageAttribute("28")]
internal class Azure.Core.CodeGenModelAttribute : CodeGenTypeAttribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Usage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Formats>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Usage { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Formats { get; public set; }
    [NullableContextAttribute("1")]
public CodeGenModelAttribute(string originalName);
    [CompilerGeneratedAttribute]
public String[] get_Usage();
    [CompilerGeneratedAttribute]
public void set_Usage(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Formats();
    [CompilerGeneratedAttribute]
public void set_Formats(String[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Azure.Core.CodeGenOverrideServiceVersionsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Versions>k__BackingField;
    public String[] Versions { get; }
    public CodeGenOverrideServiceVersionsAttribute(String[] versions);
    [CompilerGeneratedAttribute]
public String[] get_Versions();
}
[AttributeUsageAttribute("28")]
internal class Azure.Core.CodeGenSuppressAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <Parameters>k__BackingField;
    public string Member { get; }
    public Type[] Parameters { get; }
    public CodeGenSuppressAttribute(string member, Type[] parameters);
    [CompilerGeneratedAttribute]
public string get_Member();
    [CompilerGeneratedAttribute]
public Type[] get_Parameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Azure.Core.CodeGenSuppressTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Typename>k__BackingField;
    public string Typename { get; }
    public CodeGenSuppressTypeAttribute(string typename);
    [CompilerGeneratedAttribute]
public string get_Typename();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Azure.Core.CodeGenTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <OriginalName>k__BackingField;
    public string OriginalName { get; }
    public CodeGenTypeAttribute(string originalName);
    [CompilerGeneratedAttribute]
public string get_OriginalName();
}
internal class Azure.Core.FixedDelayWithNoJitterStrategy : DelayStrategy {
    private static TimeSpan DefaultDelay;
    private TimeSpan _delay;
    public FixedDelayWithNoJitterStrategy(Nullable`1<TimeSpan> suggestedDelay);
    private static FixedDelayWithNoJitterStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.FormUrlEncodedContent : RequestContent {
    private List`1<KeyValuePair`2<string, string>> _values;
    private Encoding Latin1;
    private Byte[] _bytes;
    public void Add(string parameter, string value);
    private void BuildIfNeeded();
    [AsyncStateMachineAttribute("Azure.Core.FormUrlEncodedContent/<WriteToAsync>d__5")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
    private Byte[] GetContentByteArray(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static string Encode(string data);
}
[AttributeUsageAttribute("64")]
internal class Azure.Core.ForwardsClientCallsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <SkipChecks>k__BackingField;
    public bool SkipChecks { get; }
    public ForwardsClientCallsAttribute(bool skipChecks);
    [CompilerGeneratedAttribute]
public bool get_SkipChecks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.HashCodeBuilder : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCodeBuilder();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    public static UInt32 RotateLeft(UInt32 value, int offset);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
internal class Azure.Core.HttpMessageSanitizer : object {
    private static string LogAllValue;
    private bool _logAllHeaders;
    private bool _logFullQueries;
    private String[] _allowedQueryParameters;
    private string _redactedPlaceholder;
    private HashSet`1<string> _allowedHeaders;
    internal static HttpMessageSanitizer Default;
    public HttpMessageSanitizer(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder);
    private static HttpMessageSanitizer();
    public string SanitizeHeader(string name, string value);
    public string SanitizeUrl(string url);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.HttpPipelineExtensions : object {
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessMessageAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<Response> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response ProcessMessage(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessHeadAsBoolMessageAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<bool>> ProcessHeadAsBoolMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [ExtensionAttribute]
public static Response`1<bool> ProcessHeadAsBoolMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [NullableContextAttribute("0")]
private static ValueTuple`2<CancellationToken, ErrorOptions> ApplyRequestContext(RequestContext requestContext);
}
internal interface Azure.Core.IOperation {
    public abstract virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Azure.Core.IOperation`1 {
    public abstract virtual ValueTask`1<OperationState`1<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
internal interface Azure.Core.IOperationSource`1 {
    public abstract virtual T CreateResult(Response response, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<T> CreateResultAsync(Response response, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IUtf8JsonSerializable {
    public abstract virtual void Write(Utf8JsonWriter writer);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IXmlSerializable {
    public abstract virtual void Write(XmlWriter writer, string nameHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.JsonElementExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static object GetObject(JsonElement& element);
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64(JsonElement& element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffset(JsonElement& element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpan(JsonElement& element, string format);
    [ExtensionAttribute]
public static char GetChar(JsonElement& element);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ThrowNonNullablePropertyIsNull(JsonProperty property);
    [ExtensionAttribute]
public static string GetRequiredString(JsonElement& element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.NextLinkOperationImplementation : object {
    private static string ApiVersionParam;
    private static String[] FailureStates;
    private static String[] SuccessStates;
    private HeaderSource _headerSource;
    private bool _originalResponseHasLocation;
    private Uri _startRequestUri;
    private OperationFinalStateVia _finalStateVia;
    private RequestMethod _requestMethod;
    private HttpPipeline _pipeline;
    [NullableAttribute("2")]
private string _apiVersion;
    [NullableAttribute("2")]
private string _lastKnownLocation;
    private string _nextRequestUri;
    private NextLinkOperationImplementation(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, HeaderSource headerSource, bool originalResponseHasLocation, string lastKnownLocation, OperationFinalStateVia finalStateVia, string apiVersion);
    private static NextLinkOperationImplementation();
    public static IOperation Create(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    public static IOperation`1<T> Create(IOperationSource`1<T> operationSource, HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<UpdateStateAsync>d__15")]
public sealed virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
    private static OperationState GetOperationStateFromFinalResponse(RequestMethod requestMethod, Response response);
    private void UpdateNextRequestUri(ResponseHeaders headers);
    internal static string AppendOrReplaceApiVersion(string uri, string apiVersion);
    [NullableContextAttribute("0")]
internal static bool TryGetApiVersion(Uri startRequestUri, ReadOnlySpan`1& apiVersion);
    [NullableContextAttribute("2")]
private string GetFinalUri(string resourceLocation);
    [AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<GetResponseAsync>d__21")]
private ValueTask`1<Response> GetResponseAsync(bool async, string uri, CancellationToken cancellationToken);
    private HttpMessage CreateRequest(string uri);
    private static bool IsFinalState(Response response, HeaderSource headerSource, Nullable`1& failureState, String& resourceLocation);
    private static bool ShouldIgnoreHeader(RequestMethod method, Response response);
    private static HeaderSource GetHeaderSource(RequestMethod requestMethod, Uri requestUri, Response response, string apiVersion, String& nextRequestUri);
}
internal enum Azure.Core.OperationFinalStateVia : Enum {
    public int value__;
    public static OperationFinalStateVia AzureAsyncOperation;
    public static OperationFinalStateVia Location;
    public static OperationFinalStateVia OriginalUri;
    public static OperationFinalStateVia OperationLocation;
    public static OperationFinalStateVia LocationOverride;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.OperationHelpers : object {
    public static T GetValue(T& value);
    [NullableContextAttribute("0")]
public static T GetValue(Nullable`1& value);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__2`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__3`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__6")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__7")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal : OperationInternalBase {
    private OperationInternal`1<VoidValue> _internalOperation;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public OperationInternal(IOperation operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    private OperationInternal(OperationState finalState);
    public static OperationInternal Succeeded(Response rawResponse);
    public static OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal/<UpdateStatusAsync>d__9")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal`1 : OperationInternalBase {
    private IOperation`1<T> _operation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLockWithValue`1<OperationState`1<T>> _stateLock;
    private Response _rawResponse;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    public T Value { get; }
    public OperationInternal`1(IOperation`1<T> operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    private OperationInternal`1(OperationState`1<T> finalState);
    public static OperationInternal`1<T> Succeeded(Response rawResponse, T value);
    public static OperationInternal`1<T> Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    public bool get_HasValue();
    public T get_Value();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__15")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__16")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__19")]
private ValueTask`1<Response`1<T>> WaitForCompletionAsync(bool async, Nullable`1<TimeSpan> pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<UpdateStatusAsync>d__20")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    private static Response GetResponseFromState(OperationState`1<T> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.OperationInternalBase : object {
    private ClientDiagnostics _diagnostics;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> _scopeAttributes;
    [NullableAttribute("2")]
private DelayStrategy _fallbackStrategy;
    private AsyncLockWithValue`1<Response> _responseLock;
    private string _waitForCompletionResponseScopeName;
    protected string _updateStatusScopeName;
    protected string _waitForCompletionScopeName;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    protected OperationInternalBase(Response rawResponse);
    protected OperationInternalBase(ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    public abstract virtual Response get_RawResponse();
    public abstract virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<UpdateStatusAsync>d__13")]
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__15")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__16")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__19")]
protected ValueTask`1<Response> WaitForCompletionResponseAsync(bool async, Nullable`1<TimeSpan> pollingInterval, string scopeName, CancellationToken cancellationToken);
    protected abstract virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    protected DiagnosticScope CreateScope(string scopeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationPoller : object {
    private DelayStrategy _delayStrategy;
    [NullableContextAttribute("2")]
public OperationPoller(DelayStrategy strategy);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__6`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__8`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__10")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__11")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<Delay>d__12")]
private static ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState : ValueType {
    [CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    [NullableAttribute("2")]
public RequestFailedException OperationFailedException { get; }
    private OperationState(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException operationFailedException);
    [CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    public static OperationState Success(Response rawResponse);
    public static OperationState Failure(Response rawResponse, RequestFailedException operationFailedException);
    public static OperationState Pending(Response rawResponse);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    [NullableAttribute("1")]
public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    public T Value { get; }
    public RequestFailedException OperationFailedException { get; }
    private OperationState`1(Response rawResponse, bool hasCompleted, bool hasSucceeded, T value, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    [NullableContextAttribute("1")]
public static OperationState`1<T> Success(Response rawResponse, T value);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Failure(Response rawResponse, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Pending(Response rawResponse);
}
internal static class Azure.Core.Optional : object {
    public static bool IsCollectionDefined(IEnumerable`1<T> collection);
    public static bool IsCollectionDefined(IReadOnlyDictionary`2<TKey, TValue> collection);
    public static bool IsCollectionDefined(IDictionary`2<TKey, TValue> collection);
    public static bool IsDefined(Nullable`1<T> value);
    public static bool IsDefined(object value);
    public static bool IsDefined(string value);
    public static bool IsDefined(JsonElement value);
    public static IReadOnlyDictionary`2<TKey, TValue> ToDictionary(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optional);
    public static IDictionary`2<TKey, TValue> ToDictionary(Optional`1<IDictionary`2<TKey, TValue>> optional);
    public static IReadOnlyList`1<T> ToList(Optional`1<IReadOnlyList`1<T>> optional);
    public static IList`1<T> ToList(Optional`1<IList`1<T>> optional);
    public static Nullable`1<T> ToNullable(Optional`1<T> optional);
    public static Nullable`1<T> ToNullable(Optional`1<Nullable`1<T>> optional);
}
[IsReadOnlyAttribute]
internal class Azure.Core.Optional`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public T Value { get; }
    public bool HasValue { get; }
    public Optional`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    public static Optional`1<T> op_Implicit(T value);
    public static T op_Implicit(Optional`1<T> optional);
}
internal static class Azure.Core.Page : object {
    [NullableContextAttribute("1")]
public static Page`1<T> FromValues(IEnumerable`1<T> values, string continuationToken, Response response);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.PageableHelpers : object {
    private static Byte[] DefaultItemPropertyName;
    private static Byte[] DefaultNextLinkPropertyName;
    private static PageableHelpers();
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.PageableHelpers/<CreateAsyncPageable>d__10`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
    private static ValueTuple`2<List`1<T>, string> ParseResponseForBinaryData(Response response, Byte[] itemPropertyName, Byte[] nextLinkPropertyName);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static object <ParseResponseForBinaryData>g__ReadBinaryData|19_0(Utf8JsonReader& r, ReadOnlyMemory`1& content);
}
internal static class Azure.Core.Pipeline.ActivityExtensions : object {
    [CompilerGeneratedAttribute]
private static bool <SupportsActivitySource>k__BackingField;
    public static bool SupportsActivitySource { get; private set; }
    private static ActivityExtensions();
    [CompilerGeneratedAttribute]
public static bool get_SupportsActivitySource();
    [CompilerGeneratedAttribute]
private static void set_SupportsActivitySource(bool value);
    public static void ResetFeatureSwitch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
    public ClientDiagnostics(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities);
    public ClientDiagnostics(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities);
    internal static HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics);
    internal static string GetResourceProviderNamespace(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Pipeline.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    internal static string OpenTelemetrySchemaAttribute;
    internal static string OpenTelemetrySchemaVersion;
    private static object AzureSdkScopeValue;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    [RequiresUnreferencedCodeAttribute("The diagnosticSourceArgs are used in a call to DiagnosticSource.Write, all necessary properties need to be preserved on the type being passed in using DynamicDependency attributes.")]
internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public void AddAttribute(string name, string value);
    public void AddIntegerAttribute(string name, int value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, string> attributes);
    public void Start();
    public void SetDisplayName(string displayName);
    public void SetStartTime(DateTime dateTime);
    public void SetTraceContext(string traceparent, string tracestate);
    public sealed virtual void Dispose();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(Exception exception);
    public void Failed(string errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    private bool _isStable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ActivitySource> ActivitySources;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable);
    private static DiagnosticScopeFactory();
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public DiagnosticScope CreateScope(string name, ActivityKind kind);
    private ActivitySource GetActivitySource(string ns, string name);
}
internal class Azure.Core.Pipeline.StorageRequestFailedDetailsParser : RequestFailedDetailsParser {
    [NullableContextAttribute("1")]
public virtual bool TryParse(Response response, ResponseError& error, IDictionary`2& data);
}
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.TaskExtensions : object {
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T EnsureCompleted(Task`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(Task task);
    [ExtensionAttribute]
public static T EnsureCompleted(ValueTask`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(ValueTask task);
    [ExtensionAttribute]
public static Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async);
    [ConditionalAttribute("DEBUG")]
private static void VerifyTaskCompleted(bool isCompleted);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ProtocolOperation`1 : Operation`1<T> {
    private Func`2<Response, T> _resultSelector;
    private OperationInternal`1<T> _operation;
    private IOperation _nextLinkOperation;
    public string Id { get; }
    public T Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal ProtocolOperation`1(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, string scopeName, Func`2<Response, T> resultSelector);
    public virtual string get_Id();
    public virtual T get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperation`1/<Azure-Core-IOperation<T>-UpdateStateAsync>d__17")]
private sealed virtual override ValueTask`1<OperationState`1<T>> Azure.Core.IOperation<T>.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ProtocolOperationHelpers : object {
    public static Operation`1<TTo> Convert(Operation`1<TFrom> operation, Func`2<Response, TTo> convertFunc, ClientDiagnostics diagnostics, string scopeName);
    public static ValueTask`1<Operation`1<VoidValue>> ProcessMessageWithoutResponseValueAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<VoidValue> ProcessMessageWithoutResponseValue(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static ValueTask`1<Operation`1<BinaryData>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<BinaryData> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperationHelpers/<ProcessMessageAsync>d__5`1")]
public static ValueTask`1<Operation`1<T>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
    public static Operation`1<T> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
}
internal class Azure.Core.RawRequestUriBuilder : RequestUriBuilder {
    [NullableAttribute("1")]
private static string SchemeSeparator;
    private static char HostSeparator;
    private static char PortSeparator;
    [NullableAttribute("1")]
private static Char[] HostOrPort;
    private static char QueryBeginSeparator;
    private static char QueryContinueSeparator;
    private static char QueryValueSeparator;
    private Nullable`1<RawWritingPosition> _position;
    private static RawRequestUriBuilder();
    private static void GetQueryParts(ReadOnlySpan`1<char> queryUnparsed, ReadOnlySpan`1& name, ReadOnlySpan`1& value);
    [NullableContextAttribute("1")]
public void AppendRaw(string value, bool escape);
    private void AppendRaw(ReadOnlySpan`1<char> value, bool escape);
    [NullableContextAttribute("1")]
public void AppendRawNextLink(string nextLink, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.RequestContentHelper : object {
    public static RequestContent FromEnumerable(IEnumerable`1<T> enumerable);
    public static RequestContent FromEnumerable(IEnumerable`1<BinaryData> enumerable);
    public static RequestContent FromDictionary(IDictionary`2<string, T> dictionary);
    public static RequestContent FromDictionary(IDictionary`2<string, BinaryData> dictionary);
    public static RequestContent FromObject(object value);
    public static RequestContent FromObject(BinaryData value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestHeaderExtensions : object {
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, bool value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, float value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, double value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, int value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, long value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, TimeSpan value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Guid value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Byte[] value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, BinaryData value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string prefix, IDictionary`2<string, string> headersToAdd);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, ETag value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, MatchConditions conditions);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, RequestConditions conditions, string format);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestUriBuilderExtensions : object {
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, float value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, double value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, int value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, IEnumerable`1<string> value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, float value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, double value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, decimal value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, int value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, string format, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.ResponseHeadersExtensions : object {
    private static String[] KnownFormats;
    private static ResponseHeadersExtensions();
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Byte[]& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, T& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string prefix, IDictionary`2& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ResponseWithHeaders : object {
    public static ResponseWithHeaders`2<T, THeaders> FromValue(T value, THeaders headers, Response rawResponse);
    public static ResponseWithHeaders`1<THeaders> FromValue(THeaders headers, Response rawResponse);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.ResponseWithHeaders`1 : object {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public THeaders Headers { get; }
    public ResponseWithHeaders`1(THeaders headers, Response rawResponse);
    public Response GetRawResponse();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`1<THeaders> self);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ResponseWithHeaders`2 : Response`1<T> {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public T Value { get; }
    public THeaders Headers { get; }
    public ResponseWithHeaders`2(T value, THeaders headers, Response rawResponse);
    public virtual Response GetRawResponse();
    [CompilerGeneratedAttribute]
public virtual T get_Value();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`2<T, THeaders> self);
}
internal class Azure.Core.SequentialDelayStrategy : DelayStrategy {
    [NullableAttribute("1")]
private static TimeSpan[] _pollingSequence;
    private static TimeSpan _maxDelay;
    private static SequentialDelayStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.StringRequestContent : RequestContent {
    private Byte[] _bytes;
    public StringRequestContent(string value);
    [AsyncStateMachineAttribute("Azure.Core.StringRequestContent/<WriteToAsync>d__2")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[ExtensionAttribute]
internal static class Azure.Core.SyncAsyncEventHandlerExtensions : object {
    [AsyncStateMachineAttribute("Azure.Core.SyncAsyncEventHandlerExtensions/<RaiseAsync>d__0`1")]
[ExtensionAttribute]
public static Task RaiseAsync(SyncAsyncEventHandler`1<T> eventHandler, T e, string declaringTypeName, string eventName, ClientDiagnostics clientDiagnostics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.TypeFormatters : object {
    private static string RoundtripZFormat;
    [CompilerGeneratedAttribute]
private static string <DefaultNumberFormat>k__BackingField;
    public static string DefaultNumberFormat { get; }
    private static TypeFormatters();
    [CompilerGeneratedAttribute]
public static string get_DefaultNumberFormat();
    public static string ToString(bool value);
    public static string ToString(DateTime value, string format);
    public static string ToString(DateTimeOffset value, string format);
    public static string ToString(TimeSpan value, string format);
    public static string ToString(Byte[] value, string format);
    public static string ToBase64UrlString(Byte[] value);
    public static Byte[] FromBase64UrlString(string value);
    private static int GetNumBase64PaddingCharsToAddForDecode(int inputLength);
    public static DateTimeOffset ParseDateTimeOffset(string value, string format);
    public static TimeSpan ParseTimeSpan(string value, string format);
    [NullableContextAttribute("2")]
public static string ConvertToString(object value, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Utf8JsonRequestContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private Utf8JsonWriter <JsonWriter>k__BackingField;
    public Utf8JsonWriter JsonWriter { get; }
    [CompilerGeneratedAttribute]
public Utf8JsonWriter get_JsonWriter();
    [AsyncStateMachineAttribute("Azure.Core.Utf8JsonRequestContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.Utf8JsonWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTime value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, char value);
    [ExtensionAttribute]
public static void WriteNonEmptyArray(Utf8JsonWriter writer, string name, IReadOnlyList`1<string> values);
    [ExtensionAttribute]
public static void WriteBase64StringValue(Utf8JsonWriter writer, Byte[] value, string format);
    [ExtensionAttribute]
public static void WriteNumberValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteObjectValue(Utf8JsonWriter writer, object value);
}
[IsReadOnlyAttribute]
internal class Azure.Core.VoidValue : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XElementExtensions : object {
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64Value(XElement element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffsetValue(XElement element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpanValue(XElement element, string format);
    [ExtensionAttribute]
public static object GetObjectValue(XElement element, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.XmlWriterContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private XmlWriter <XmlWriter>k__BackingField;
    public XmlWriter XmlWriter { get; }
    [CompilerGeneratedAttribute]
public XmlWriter get_XmlWriter();
    [AsyncStateMachineAttribute("Azure.Core.XmlWriterContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XmlWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteObjectValue(XmlWriter writer, object value, string nameHint);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, Byte[] value, string format);
}
internal class Azure.NoBodyResponse`1 : Response`1<T> {
    private Response _response;
    public bool HasValue { get; }
    public T Value { get; }
    public NoBodyResponse`1(Response response);
    public virtual bool get_HasValue();
    public virtual T get_Value();
    public virtual Response GetRawResponse();
    public virtual string ToString();
}
internal static class Azure.Storage.CompatSwitches : object {
    private static Nullable`1<bool> _disableRequestConditionsValidation;
    public static bool DisableRequestConditionsValidation { get; }
    public static bool get_DisableRequestConditionsValidation();
}
internal static class Azure.Storage.Constants : object {
    public static int KB;
    public static int MB;
    public static int GB;
    public static long TB;
    public static int Base16;
    public static int MaxReliabilityRetries;
    public static int MaxIdleTimeMs;
    public static string DefaultSasVersion;
    public static int MaxHashRequestDownloadRange;
    public static int DefaultBufferSize;
    public static int LargeBufferSize;
    public static int LargeUploadThreshold;
    public static int DefaultStreamingDownloadSize;
    public static int DefaultStreamCopyBufferSize;
    public static int DefaultDownloadCopyBufferSize;
    public static int StorageCrc64SizeInBytes;
    public static int MD5SizeInBytes;
    public static bool DefaultTrimBlobNameSlashes;
    public static string CloseAllHandles;
    public static string Wildcard;
    public static string BlockNameFormat;
    public static string SasTimeFormatSeconds;
    public static string SasTimeFormatSubSeconds;
    public static string SasTimeFormatMinutes;
    public static string SasTimeFormatDays;
    public static string SnapshotParameterName;
    public static string VersionIdParameterName;
    public static string ShareSnapshotParameterName;
    public static string Https;
    public static string Http;
    public static string PercentSign;
    public static string EncodedPercentSign;
    public static string QueryDelimiter;
    public static string PathBackSlashDelimiter;
    public static string FalseName;
    public static string TrueName;
    public static string ErrorCode;
    public static string ErrorMessage;
    public static string CommaString;
    public static char CommaChar;
    public static string ContentTypeApplicationXml;
    public static string ContentTypeApplicationJson;
    public static string ErrorPropertyKey;
    public static string DetailPropertyKey;
    public static string MessagePropertyKey;
    public static string CodePropertyKey;
    public static string Iso8601Format;
    public static string DisableRequestConditionsValidationSwitchName;
    public static string DisableRequestConditionsValidationEnvVar;
    public static string DefaultScope;
}
internal class Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream : Stream {
    private Stream _innerStream;
    private CryptoStreamMode _mode;
    private IAuthenticatedCryptographicTransform _transform;
    private bool _flushedFinal;
    private Byte[] _buffer;
    private int _bufferPos;
    private int _bufferPopulatedLength;
    private int _bufferLength;
    private int _tempRefillBufferSize;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public AuthenticatedRegionCryptoStream(Stream innerStream, IAuthenticatedCryptographicTransform transform, int regionDataSize, CryptoStreamMode streamMode);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<ReadAsync>d__22")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<ReadInternal>d__23")]
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<WriteAsync>d__25")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<WriteInternal>d__26")]
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<FlushAsync>d__28")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<FlushIfReadyInternal>d__29")]
private Task FlushIfReadyInternal(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream/<FlushFinalInternal>d__30")]
public Task FlushFinalInternal(bool async, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
internal class Azure.Storage.Cryptography.ClientSideDecryptor : object {
    private static AsyncLocal`1<ContentEncryptionKeyCache> s_contentEncryptionKeyCache;
    private IKeyEncryptionKey _potentialCachedIKeyEncryptionKey;
    private IKeyEncryptionKeyResolver _keyResolver;
    public ClientSideDecryptor(ClientSideEncryptionOptions options);
    private static ClientSideDecryptor();
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptReadInternal>d__4")]
public Task`1<Stream> DecryptReadInternal(Stream ciphertext, EncryptionData encryptionData, bool ivInStream, bool noPadding, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptWholeContentWriteInternal>d__5")]
public Task`1<Stream> DecryptWholeContentWriteInternal(Stream plaintextDestination, EncryptionData encryptionData, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptInternalV2_0>d__6")]
private Task`1<Stream> DecryptInternalV2_0(Stream ciphertext, EncryptionData encryptionData, CryptoStreamMode mode, bool async, CancellationToken cancellationToken);
    private static Stream WrapStreamV2_0(Stream contentStream, CryptoStreamMode mode, Byte[] contentEncryptionKey, int authRegionPlaintextSize);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptReadInternalV1_0>d__8")]
private Task`1<Stream> DecryptReadInternalV1_0(Stream ciphertext, EncryptionData encryptionData, bool ivInStream, bool noPadding, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<DecryptWholeContentWriteInternalV1_0>d__9")]
private Task`1<Stream> DecryptWholeContentWriteInternalV1_0(Stream plaintextDestination, EncryptionData encryptionData, bool async, CancellationToken cancellationToken);
    private static Stream WrapStreamV1_0(Stream contentStream, Byte[] contentEncryptionKey, EncryptionData encryptionData, Byte[] iv, bool noPadding, CryptoStreamMode mode);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideDecryptor/<GetContentEncryptionKeyAsync>d__11")]
internal Task`1<Memory`1<byte>> GetContentEncryptionKeyAsync(EncryptionData encryptionData, bool async, CancellationToken cancellationToken);
    internal static void BeginContentEncryptionKeyCaching(ContentEncryptionKeyCache cache);
}
[ExtensionAttribute]
internal static class Azure.Storage.Cryptography.ClientSideEncryptionOptionsExtensions : object {
    [ExtensionAttribute]
public static ClientSideEncryptionOptions Clone(ClientSideEncryptionOptions options);
    internal static void CopyOptions(ClientSideEncryptionOptions source, ClientSideEncryptionOptions destination);
    [ExtensionAttribute]
public static IClientSideEncryptor GetClientSideEncryptor(ClientSideEncryptionOptions options);
}
internal class Azure.Storage.Cryptography.ClientSideEncryptorV1_0 : object {
    private IKeyEncryptionKey _keyEncryptionKey;
    private string _keyWrapAlgorithm;
    public ClientSideEncryptorV1_0(ClientSideEncryptionOptions options);
    private void ValidateMembers();
    public sealed virtual long ExpectedOutputContentLength(long plaintextLength);
    public static long CalculateExpectedOutputContentLength(long plaintextLength);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV1_0/<EncryptInternal>d__6")]
public sealed virtual Task`1<ValueTuple`2<Stream, EncryptionData>> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV1_0/<BufferedEncryptInternal>d__7")]
public sealed virtual Task`1<ValueTuple`2<Byte[], EncryptionData>> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV1_0/<EncryptedOpenWriteInternal>d__8")]
public sealed virtual Task`1<Stream> EncryptedOpenWriteInternal(Func`4<EncryptionData, bool, CancellationToken, Task`1<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV1_0/<CreateEncryptionDataInternal>d__9")]
private Task`1<EncryptionData> CreateEncryptionDataInternal(Aes aes, bool async, CancellationToken cancellationToken);
    private static Byte[] CreateKey(int numBits);
}
internal class Azure.Storage.Cryptography.ClientSideEncryptorV2_0 : object {
    private IKeyEncryptionKey _keyEncryptionKey;
    private string _keyWrapAlgorithm;
    public ClientSideEncryptorV2_0(ClientSideEncryptionOptions options);
    public sealed virtual long ExpectedOutputContentLength(long plaintextLength);
    public static long CalculateExpectedOutputContentLength(long plaintextLength);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV2_0/<EncryptInternal>d__5")]
public sealed virtual Task`1<ValueTuple`2<Stream, EncryptionData>> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV2_0/<BufferedEncryptInternal>d__6")]
public sealed virtual Task`1<ValueTuple`2<Byte[], EncryptionData>> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV2_0/<EncryptedOpenWriteInternal>d__7")]
public sealed virtual Task`1<Stream> EncryptedOpenWriteInternal(Func`4<EncryptionData, bool, CancellationToken, Task`1<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.ClientSideEncryptorV2_0/<CreateEncryptionDataInternal>d__8")]
private Task`1<EncryptionData> CreateEncryptionDataInternal(Byte[] key, bool async, CancellationToken cancellationToken);
    private static Byte[] CreateKey(int numBits);
}
internal class Azure.Storage.Cryptography.GcmAuthenticatedCryptographicTransform : object {
    private AesGcm _gcm;
    private long _nonceCounter;
    [CompilerGeneratedAttribute]
private TransformMode <TransformMode>k__BackingField;
    public TransformMode TransformMode { get; }
    public int NonceLength { get; }
    public int TagLength { get; }
    public GcmAuthenticatedCryptographicTransform(Byte[] key, TransformMode mode);
    [CompilerGeneratedAttribute]
public sealed virtual TransformMode get_TransformMode();
    public sealed virtual int get_NonceLength();
    public sealed virtual int get_TagLength();
    public sealed virtual int TransformAuthenticationBlock(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual void Dispose();
    private ReadOnlySpan`1<byte> GetNewNonce();
}
internal interface Azure.Storage.Cryptography.IAuthenticatedCryptographicTransform {
    public TransformMode TransformMode { get; }
    public int NonceLength { get; }
    public int TagLength { get; }
    public abstract virtual TransformMode get_TransformMode();
    public abstract virtual int get_NonceLength();
    public abstract virtual int get_TagLength();
    public abstract virtual int TransformAuthenticationBlock(ReadOnlySpan`1<byte> input, Span`1<byte> output);
}
internal interface Azure.Storage.Cryptography.IClientSideEncryptor {
    public abstract virtual long ExpectedOutputContentLength(long plaintextLength);
    public abstract virtual Task`1<ValueTuple`2<Stream, EncryptionData>> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    public abstract virtual Task`1<ValueTuple`2<Byte[], EncryptionData>> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> EncryptedOpenWriteInternal(Func`4<EncryptionData, bool, CancellationToken, Task`1<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Azure.Storage.Cryptography.Models.ClientSideEncryptionAlgorithm : ValueType {
    internal static string AesCbc256Value;
    internal static string AesGcm256Value;
    private string _value;
    [CompilerGeneratedAttribute]
private static ClientSideEncryptionAlgorithm <AesCbc256>k__BackingField;
    [CompilerGeneratedAttribute]
private static ClientSideEncryptionAlgorithm <AesGcm256>k__BackingField;
    public static ClientSideEncryptionAlgorithm AesCbc256 { get; }
    public static ClientSideEncryptionAlgorithm AesGcm256 { get; }
    public ClientSideEncryptionAlgorithm(string value);
    private static ClientSideEncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public static ClientSideEncryptionAlgorithm get_AesCbc256();
    [CompilerGeneratedAttribute]
public static ClientSideEncryptionAlgorithm get_AesGcm256();
    public static bool op_Equality(ClientSideEncryptionAlgorithm left, ClientSideEncryptionAlgorithm right);
    public static bool op_Inequality(ClientSideEncryptionAlgorithm left, ClientSideEncryptionAlgorithm right);
    public static ClientSideEncryptionAlgorithm op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(ClientSideEncryptionAlgorithm other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Azure.Storage.Cryptography.Models.ClientSideEncryptionVersionExtensions : object {
    [ExtensionAttribute]
public static string Serialize(ClientSideEncryptionVersion version);
    [ExtensionAttribute]
public static ClientSideEncryptionVersion ToClientSideEncryptionVersion(string versionString);
}
internal class Azure.Storage.Cryptography.Models.EncryptedRegionInfo : object {
    [CompilerGeneratedAttribute]
private int <DataLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NonceLength>k__BackingField;
    public int DataLength { get; public set; }
    public int NonceLength { get; public set; }
    [CompilerGeneratedAttribute]
public int get_DataLength();
    [CompilerGeneratedAttribute]
public void set_DataLength(int value);
    [CompilerGeneratedAttribute]
public int get_NonceLength();
    [CompilerGeneratedAttribute]
public void set_NonceLength(int value);
}
internal class Azure.Storage.Cryptography.Models.EncryptionAgent : object {
    [CompilerGeneratedAttribute]
private ClientSideEncryptionVersion <EncryptionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientSideEncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
    public ClientSideEncryptionVersion EncryptionVersion { get; public set; }
    public ClientSideEncryptionAlgorithm EncryptionAlgorithm { get; public set; }
    [CompilerGeneratedAttribute]
public ClientSideEncryptionVersion get_EncryptionVersion();
    [CompilerGeneratedAttribute]
public void set_EncryptionVersion(ClientSideEncryptionVersion value);
    [CompilerGeneratedAttribute]
public ClientSideEncryptionAlgorithm get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(ClientSideEncryptionAlgorithm value);
}
internal class Azure.Storage.Cryptography.Models.EncryptionData : object {
    [CompilerGeneratedAttribute]
private string <EncryptionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyEnvelope <WrappedContentKey>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAgent <EncryptionAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ContentEncryptionIV>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptedRegionInfo <EncryptedRegionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <KeyWrappingMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AgentString>k__BackingField;
    public string EncryptionMode { get; public set; }
    public KeyEnvelope WrappedContentKey { get; public set; }
    public EncryptionAgent EncryptionAgent { get; public set; }
    public Byte[] ContentEncryptionIV { get; public set; }
    public EncryptedRegionInfo EncryptedRegionInfo { get; public set; }
    public IDictionary`2<string, string> KeyWrappingMetadata { get; public set; }
    private static string AgentString { get; }
    private static EncryptionData();
    [CompilerGeneratedAttribute]
public string get_EncryptionMode();
    [CompilerGeneratedAttribute]
public void set_EncryptionMode(string value);
    [CompilerGeneratedAttribute]
public KeyEnvelope get_WrappedContentKey();
    [CompilerGeneratedAttribute]
public void set_WrappedContentKey(KeyEnvelope value);
    [CompilerGeneratedAttribute]
public EncryptionAgent get_EncryptionAgent();
    [CompilerGeneratedAttribute]
public void set_EncryptionAgent(EncryptionAgent value);
    [CompilerGeneratedAttribute]
public Byte[] get_ContentEncryptionIV();
    [CompilerGeneratedAttribute]
public void set_ContentEncryptionIV(Byte[] value);
    [CompilerGeneratedAttribute]
public EncryptedRegionInfo get_EncryptedRegionInfo();
    [CompilerGeneratedAttribute]
public void set_EncryptedRegionInfo(EncryptedRegionInfo value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_KeyWrappingMetadata();
    [CompilerGeneratedAttribute]
public void set_KeyWrappingMetadata(IDictionary`2<string, string> value);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.Models.EncryptionData/<CreateInternalV1_0>d__24")]
internal static ValueTask`1<EncryptionData> CreateInternalV1_0(Byte[] contentEncryptionIv, string keyWrapAlgorithm, Byte[] contentEncryptionKey, IKeyEncryptionKey keyEncryptionKey, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Cryptography.Models.EncryptionData/<CreateInternalV2_0>d__25")]
internal static Task`1<EncryptionData> CreateInternalV2_0(string keyWrapAlgorithm, Byte[] contentEncryptionKey, IKeyEncryptionKey keyEncryptionKey, bool async, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private static string get_AgentString();
    private static string GenerateAgentString();
}
internal static class Azure.Storage.Cryptography.Models.EncryptionDataSerializer : object {
    private static string EncryptionAgent_EncryptionVersionName;
    public static string Serialize(EncryptionData data);
    private static ReadOnlyMemory`1<byte> SerializeEncryptionData(EncryptionData data);
    public static void WriteEncryptionData(Utf8JsonWriter json, EncryptionData data);
    private static void WriteEncryptedRegionInfo(Utf8JsonWriter json, EncryptedRegionInfo encryptedRegionInfo);
    private static void WriteWrappedKey(Utf8JsonWriter json, KeyEnvelope key);
    private static void WriteEncryptionAgent(Utf8JsonWriter json, EncryptionAgent encryptionAgent);
    private static void WriteDictionary(Utf8JsonWriter json, IDictionary`2<string, string> dictionary);
    public static EncryptionData Deserialize(string serializedData);
    public static EncryptionData DeserializeEncryptionData(Utf8JsonReader& reader);
    public static EncryptionData ReadEncryptionData(JsonElement root);
    private static void ReadPropertyValue(EncryptionData data, JsonProperty property);
    private static void ReadPropertyValue(KeyEnvelope key, JsonProperty property);
    private static void ReadPropertyValue(EncryptionAgent agent, JsonProperty property);
    private static void ReadPropertyValue(EncryptedRegionInfo info, JsonProperty property);
}
internal class Azure.Storage.Cryptography.Models.KeyEnvelope : object {
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EncryptedKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    public string KeyId { get; public set; }
    public Byte[] EncryptedKey { get; public set; }
    public string Algorithm { get; public set; }
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
public void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_EncryptedKey();
    [CompilerGeneratedAttribute]
public void set_EncryptedKey(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
}
internal enum Azure.Storage.Cryptography.Models.TransformMode : Enum {
    public int value__;
    public static TransformMode Encrypt;
    public static TransformMode Decrypt;
}
internal class Azure.Storage.Errors : object {
    public static ArgumentException AccountMismatch(string accountNameCredential, string accountNameValue);
    public static InvalidOperationException AccountSasMissingData();
    public static ArgumentNullException ArgumentNull(string paramName);
    public static ArgumentException InvalidArgument(string paramName);
    public static ArgumentException InvalidResourceType(char s);
    public static InvalidOperationException TaskIncomplete();
    public static FormatException InvalidFormat(string err);
    public static ArgumentException ParsingConnectionStringFailed();
    public static ArgumentOutOfRangeException InvalidSasProtocol(string protocol, string sasProtocol);
    public static ArgumentException InvalidService(char s);
    public static ArgumentException InsufficientStorageTransferOptions(long streamLength, long statedMaxBlockSize, long necessaryMinBlockSize);
    public static InvalidDataException HashMismatch(string hashHeaderName);
    public static InvalidDataException ChecksumMismatch(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static InvalidDataException HashMismatchOnStreamedDownload(string mismatchedRange);
    public static ArgumentException PrecalculatedHashNotSupportedOnSplit();
    public static ArgumentException CannotDeferTransactionalHashVerification();
    public static ArgumentException CannotInitializeWriteStreamWithData();
    internal static void VerifyStreamPosition(Stream stream, string streamName);
    public static void ThrowIfParamNull(object obj, string paramName);
    internal static void CheckCryptKeySize(int keySizeInBytes);
    public static CryptographicException CryptographyAuthTagMismatch();
    public static ArgumentException CryptographyPlaintextCiphertextLengthMismatch();
    public static ArgumentException CryptographyInvalidNonceLength();
    public static ArgumentException CryptographyInvalidTagLength();
    public static ArgumentException CannotBothBeNotNull(string param0, string param1);
    public static ArgumentOutOfRangeException MustBeGreaterThanOrEqualTo(string paramName, long value);
    public static ArgumentOutOfRangeException MustBeLessThanOrEqualTo(string paramName, long value);
    public static ArgumentOutOfRangeException MustBeBetweenInclusive(string paramName, long lower, long upper, long actual);
    public static ArgumentOutOfRangeException MustBeGreaterThanValueOrEqualToOtherValue(string paramName, long value0, long value1);
    public static ArgumentException StreamMustBeReadable(string paramName);
    public static InvalidOperationException StreamMustBeAtPosition0();
    public static InvalidOperationException TokenCredentialsRequireHttps();
    public static ArgumentException SasCredentialRequiresUriWithoutSas(Uri uri);
    public static InvalidOperationException SasMissingData(string paramName);
    public static InvalidOperationException SasDataNotAllowed(string paramName, string paramNameNotAllowed);
    public static InvalidOperationException SasDataInConjunction(string paramName, string paramName2);
    public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName, string clientParam);
    public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName);
    public static InvalidOperationException SasServiceNotMatching(string builderParam, string builderName, string expectedService);
    public static InvalidOperationException SasClientMissingData(string paramName);
    public static InvalidOperationException SasBuilderEmptyParam(string builderName, string paramName, string sasType);
    public static InvalidOperationException SasIncorrectResourceType(string builderName, string builderParam, string value, string clientName);
    public static ArgumentException InvalidPermission(char s);
    public static ArgumentException ParsingHttpRangeFailed();
    public static AccessViolationException UnableAccessArray();
    public static NotImplementedException NotImplemented();
    public static AuthenticationException InvalidCredentials(string fullName);
    public static ArgumentException SeekOutsideBufferRange(long index, long inclusiveRangeStart, long exclusiveRangeEnd);
    public static ArgumentException VersionNotSupported(string paramName);
    public static RequestFailedException ClientRequestIdMismatch(Response response, string echo, string original);
    public static ArgumentException TransactionalHashingNotSupportedWithClientSideEncryption();
    public static void VerifyHttpsTokenAuth(Uri uri);
}
internal class Azure.Storage.GeoRedundantReadPolicy : HttpPipelineSynchronousPolicy {
    private string _secondaryStorageHost;
    public GeoRedundantReadPolicy(Uri secondaryStorageUri);
    public virtual void OnSendingRequest(HttpMessage message);
}
[ExtensionAttribute]
internal static class Azure.Storage.LoggingExtensions : object {
    [ExtensionAttribute]
public static IDisposable BeginLoggingScope(HttpPipeline pipeline, string className, string member);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogMethodEnter(HttpPipeline pipeline, string className, string member, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogMethodExit(HttpPipeline pipeline, string className, string member, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogException(HttpPipeline pipeline, Exception ex, string message);
    [ExtensionAttribute]
[ConditionalAttribute("EnableLoggingHelpers")]
public static void LogTrace(HttpPipeline pipeline, string message);
}
internal class Azure.Storage.Queues.MessageIdDeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public MessageIdDeleteHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.MessageIdRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public MessageIdRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateUpdateRequest(string messageid, string popReceipt, int visibilitytimeout, Nullable`1<int> timeout, QueueMessage queueMessage);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.MessageIdRestClient/<UpdateAsync>d__8")]
public Task`1<ResponseWithHeaders`1<MessageIdUpdateHeaders>> UpdateAsync(string messageid, string popReceipt, int visibilitytimeout, Nullable`1<int> timeout, QueueMessage queueMessage, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<MessageIdUpdateHeaders> Update(string messageid, string popReceipt, int visibilitytimeout, Nullable`1<int> timeout, QueueMessage queueMessage, CancellationToken cancellationToken);
    internal HttpMessage CreateDeleteRequest(string messageid, string popReceipt, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.MessageIdRestClient/<DeleteAsync>d__11")]
public Task`1<ResponseWithHeaders`1<MessageIdDeleteHeaders>> DeleteAsync(string messageid, string popReceipt, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<MessageIdDeleteHeaders> Delete(string messageid, string popReceipt, Nullable`1<int> timeout, CancellationToken cancellationToken);
}
internal class Azure.Storage.Queues.MessageIdUpdateHeaders : object {
    private Response _response;
    public string Version { get; }
    public string PopReceipt { get; }
    public Nullable`1<DateTimeOffset> TimeNextVisible { get; }
    public MessageIdUpdateHeaders(Response response);
    public string get_Version();
    public string get_PopReceipt();
    public Nullable`1<DateTimeOffset> get_TimeNextVisible();
}
internal class Azure.Storage.Queues.MessagesClearHeaders : object {
    private Response _response;
    public string Version { get; }
    public MessagesClearHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.MessagesDequeueHeaders : object {
    private Response _response;
    public string Version { get; }
    public MessagesDequeueHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.MessagesEnqueueHeaders : object {
    private Response _response;
    public string Version { get; }
    public MessagesEnqueueHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.MessagesPeekHeaders : object {
    private Response _response;
    public string Version { get; }
    public MessagesPeekHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.MessagesRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public MessagesRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateDequeueRequest(Nullable`1<int> numberOfMessages, Nullable`1<int> visibilitytimeout, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.MessagesRestClient/<DequeueAsync>d__8")]
public Task`1<ResponseWithHeaders`2<IReadOnlyList`1<DequeuedMessageItem>, MessagesDequeueHeaders>> DequeueAsync(Nullable`1<int> numberOfMessages, Nullable`1<int> visibilitytimeout, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<IReadOnlyList`1<DequeuedMessageItem>, MessagesDequeueHeaders> Dequeue(Nullable`1<int> numberOfMessages, Nullable`1<int> visibilitytimeout, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateClearRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.MessagesRestClient/<ClearAsync>d__11")]
public Task`1<ResponseWithHeaders`1<MessagesClearHeaders>> ClearAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<MessagesClearHeaders> Clear(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateEnqueueRequest(QueueMessage queueMessage, Nullable`1<int> visibilitytimeout, Nullable`1<int> messageTimeToLive, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.MessagesRestClient/<EnqueueAsync>d__14")]
public Task`1<ResponseWithHeaders`2<IReadOnlyList`1<SendReceipt>, MessagesEnqueueHeaders>> EnqueueAsync(QueueMessage queueMessage, Nullable`1<int> visibilitytimeout, Nullable`1<int> messageTimeToLive, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<IReadOnlyList`1<SendReceipt>, MessagesEnqueueHeaders> Enqueue(QueueMessage queueMessage, Nullable`1<int> visibilitytimeout, Nullable`1<int> messageTimeToLive, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreatePeekRequest(Nullable`1<int> numberOfMessages, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.MessagesRestClient/<PeekAsync>d__17")]
public Task`1<ResponseWithHeaders`2<IReadOnlyList`1<PeekedMessageItem>, MessagesPeekHeaders>> PeekAsync(Nullable`1<int> numberOfMessages, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<IReadOnlyList`1<PeekedMessageItem>, MessagesPeekHeaders> Peek(Nullable`1<int> numberOfMessages, Nullable`1<int> timeout, CancellationToken cancellationToken);
}
internal class Azure.Storage.Queues.Models.DequeuedMessageItem : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <InsertionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopReceipt>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <TimeNextVisible>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DequeueCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageText>k__BackingField;
    public string MessageId { get; }
    public DateTimeOffset InsertionTime { get; }
    public DateTimeOffset ExpirationTime { get; }
    public string PopReceipt { get; }
    public DateTimeOffset TimeNextVisible { get; }
    public long DequeueCount { get; }
    public string MessageText { get; }
    internal DequeuedMessageItem(string messageId, DateTimeOffset insertionTime, DateTimeOffset expirationTime, string popReceipt, DateTimeOffset timeNextVisible, long dequeueCount, string messageText);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_InsertionTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpirationTime();
    [CompilerGeneratedAttribute]
public string get_PopReceipt();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_TimeNextVisible();
    [CompilerGeneratedAttribute]
public long get_DequeueCount();
    [CompilerGeneratedAttribute]
public string get_MessageText();
    internal static DequeuedMessageItem DeserializeDequeuedMessageItem(XElement element);
}
internal class Azure.Storage.Queues.Models.GetQueuesAsyncCollection : StorageCollectionEnumerator`1<QueueItem> {
    private QueueServiceClient _client;
    private QueueTraits _traits;
    private string _prefix;
    public GetQueuesAsyncCollection(QueueServiceClient client, QueueTraits traits, string prefix);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.Models.GetQueuesAsyncCollection/<GetNextPageAsync>d__4")]
public virtual ValueTask`1<Page`1<QueueItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Queues.Models.ListQueuesSegmentResponse : object {
    [CompilerGeneratedAttribute]
private string <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<QueueItem> <QueueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextMarker>k__BackingField;
    public string ServiceEndpoint { get; }
    public string Prefix { get; }
    public string Marker { get; }
    public int MaxResults { get; }
    public IReadOnlyList`1<QueueItem> QueueItems { get; }
    public string NextMarker { get; }
    internal ListQueuesSegmentResponse(string serviceEndpoint, string prefix, int maxResults, string nextMarker);
    internal ListQueuesSegmentResponse(string serviceEndpoint, string prefix, string marker, int maxResults, IReadOnlyList`1<QueueItem> queueItems, string nextMarker);
    [CompilerGeneratedAttribute]
public string get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Marker();
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<QueueItem> get_QueueItems();
    [CompilerGeneratedAttribute]
public string get_NextMarker();
    internal static ListQueuesSegmentResponse DeserializeListQueuesSegmentResponse(XElement element);
}
public class Azure.Storage.Queues.Models.PeekedMessage : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryData <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <InsertedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DequeueCount>k__BackingField;
    public string MessageId { get; internal set; }
    [EditorBrowsableAttribute("1")]
public string MessageText { get; internal set; }
    public BinaryData Body { get; internal set; }
    public Nullable`1<DateTimeOffset> InsertedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; internal set; }
    public long DequeueCount { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
internal void set_MessageId(string value);
    public string get_MessageText();
    internal void set_MessageText(string value);
    [CompilerGeneratedAttribute]
public BinaryData get_Body();
    [CompilerGeneratedAttribute]
internal void set_Body(BinaryData value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_InsertedOn();
    [CompilerGeneratedAttribute]
internal void set_InsertedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public long get_DequeueCount();
    [CompilerGeneratedAttribute]
internal void set_DequeueCount(long value);
    internal static PeekedMessage ToPeekedMessage(PeekedMessageItem peekedMessageItem, QueueMessageEncoding messageEncoding);
}
internal class Azure.Storage.Queues.Models.PeekedMessageItem : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <InsertionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DequeueCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageText>k__BackingField;
    public string MessageId { get; }
    public DateTimeOffset InsertionTime { get; }
    public DateTimeOffset ExpirationTime { get; }
    public long DequeueCount { get; }
    public string MessageText { get; }
    internal PeekedMessageItem(string messageId, DateTimeOffset insertionTime, DateTimeOffset expirationTime, long dequeueCount, string messageText);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_InsertionTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpirationTime();
    [CompilerGeneratedAttribute]
public long get_DequeueCount();
    [CompilerGeneratedAttribute]
public string get_MessageText();
    internal static PeekedMessageItem DeserializePeekedMessageItem(XElement element);
}
[CodeGenModelAttribute("AccessPolicy")]
public class Azure.Storage.Queues.Models.QueueAccessPolicy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <StartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CodeGenMemberAttribute("Start")]
public Nullable`1<DateTimeOffset> StartsOn { get; public set; }
    [CodeGenMemberAttribute("Expiry")]
public Nullable`1<DateTimeOffset> ExpiresOn { get; public set; }
    [CodeGenMemberAttribute("Permission")]
public string Permissions { get; public set; }
    internal QueueAccessPolicy(Nullable`1<DateTimeOffset> startsOn, Nullable`1<DateTimeOffset> expiresOn, string permissions);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static QueueAccessPolicy DeserializeQueueAccessPolicy(XElement element);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_StartsOn();
    [CompilerGeneratedAttribute]
public void set_StartsOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(string value);
}
[CodeGenModelAttribute("Logging")]
public class Azure.Storage.Queues.Models.QueueAnalyticsLogging : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Delete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Read>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Write>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueRetentionPolicy <RetentionPolicy>k__BackingField;
    public string Version { get; public set; }
    public bool Delete { get; public set; }
    public bool Read { get; public set; }
    public bool Write { get; public set; }
    public QueueRetentionPolicy RetentionPolicy { get; public set; }
    internal QueueAnalyticsLogging(string version, bool delete, bool read, bool write, QueueRetentionPolicy retentionPolicy);
    internal QueueAnalyticsLogging(bool skipInitialization);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Delete();
    [CompilerGeneratedAttribute]
public void set_Delete(bool value);
    [CompilerGeneratedAttribute]
public bool get_Read();
    [CompilerGeneratedAttribute]
public void set_Read(bool value);
    [CompilerGeneratedAttribute]
public bool get_Write();
    [CompilerGeneratedAttribute]
public void set_Write(bool value);
    [CompilerGeneratedAttribute]
public QueueRetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(QueueRetentionPolicy value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static QueueAnalyticsLogging DeserializeQueueAnalyticsLogging(XElement element);
}
[IsReadOnlyAttribute]
public class Azure.Storage.Queues.Models.QueueAudience : ValueType {
    private string _value;
    private static string _defaultAudience;
    [CompilerGeneratedAttribute]
private static QueueAudience <PublicAudience>k__BackingField;
    public static QueueAudience PublicAudience { get; }
    public QueueAudience(string value);
    private static QueueAudience();
    [CompilerGeneratedAttribute]
public static QueueAudience get_PublicAudience();
    public static QueueAudience CreateQueueServiceAccountAudience(string storageAccountName);
    public static bool op_Equality(QueueAudience left, QueueAudience right);
    public static bool op_Inequality(QueueAudience left, QueueAudience right);
    public static QueueAudience op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(QueueAudience other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    internal string CreateDefaultScope();
}
[CodeGenModelAttribute("CorsRule")]
public class Azure.Storage.Queues.Models.QueueCorsRule : object {
    [CompilerGeneratedAttribute]
private string <AllowedOrigins>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllowedHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExposedHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAgeInSeconds>k__BackingField;
    public string AllowedOrigins { get; public set; }
    public string AllowedMethods { get; public set; }
    public string AllowedHeaders { get; public set; }
    public string ExposedHeaders { get; public set; }
    public int MaxAgeInSeconds { get; public set; }
    internal QueueCorsRule(string allowedOrigins, string allowedMethods, string allowedHeaders, string exposedHeaders, int maxAgeInSeconds);
    [CompilerGeneratedAttribute]
public string get_AllowedOrigins();
    [CompilerGeneratedAttribute]
public void set_AllowedOrigins(string value);
    [CompilerGeneratedAttribute]
public string get_AllowedMethods();
    [CompilerGeneratedAttribute]
public void set_AllowedMethods(string value);
    [CompilerGeneratedAttribute]
public string get_AllowedHeaders();
    [CompilerGeneratedAttribute]
public void set_AllowedHeaders(string value);
    [CompilerGeneratedAttribute]
public string get_ExposedHeaders();
    [CompilerGeneratedAttribute]
public void set_ExposedHeaders(string value);
    [CompilerGeneratedAttribute]
public int get_MaxAgeInSeconds();
    [CompilerGeneratedAttribute]
public void set_MaxAgeInSeconds(int value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static QueueCorsRule DeserializeQueueCorsRule(XElement element);
}
[IsReadOnlyAttribute]
[CodeGenModelAttribute("StorageErrorCode")]
public class Azure.Storage.Queues.Models.QueueErrorCode : ValueType {
    private string _value;
    private static string AccountAlreadyExistsValue;
    private static string AccountBeingCreatedValue;
    private static string AccountIsDisabledValue;
    private static string AuthenticationFailedValue;
    private static string AuthorizationFailureValue;
    private static string ConditionHeadersNotSupportedValue;
    private static string ConditionNotMetValue;
    private static string EmptyMetadataKeyValue;
    private static string InsufficientAccountPermissionsValue;
    private static string InternalErrorValue;
    private static string InvalidAuthenticationInfoValue;
    private static string InvalidHeaderValueValue;
    private static string InvalidHttpVerbValue;
    private static string InvalidInputValue;
    private static string InvalidMd5Value;
    private static string InvalidMetadataValue;
    private static string InvalidQueryParameterValueValue;
    private static string InvalidRangeValue;
    private static string InvalidResourceNameValue;
    private static string InvalidUriValue;
    private static string InvalidXmlDocumentValue;
    private static string InvalidXmlNodeValueValue;
    private static string Md5MismatchValue;
    private static string MetadataTooLargeValue;
    private static string MissingContentLengthHeaderValue;
    private static string MissingRequiredQueryParameterValue;
    private static string MissingRequiredHeaderValue;
    private static string MissingRequiredXmlNodeValue;
    private static string MultipleConditionHeadersNotSupportedValue;
    private static string OperationTimedOutValue;
    private static string OutOfRangeInputValue;
    private static string OutOfRangeQueryParameterValueValue;
    private static string RequestBodyTooLargeValue;
    private static string ResourceTypeMismatchValue;
    private static string RequestUrlFailedToParseValue;
    private static string ResourceAlreadyExistsValue;
    private static string ResourceNotFoundValue;
    private static string ServerBusyValue;
    private static string UnsupportedHeaderValue;
    private static string UnsupportedXmlNodeValue;
    private static string UnsupportedQueryParameterValue;
    private static string UnsupportedHttpVerbValue;
    private static string InvalidMarkerValue;
    private static string MessageNotFoundValue;
    private static string MessageTooLargeValue;
    private static string PopReceiptMismatchValue;
    private static string QueueAlreadyExistsValue;
    private static string QueueBeingDeletedValue;
    private static string QueueDisabledValue;
    private static string QueueNotEmptyValue;
    private static string QueueNotFoundValue;
    private static string AuthorizationSourceIPMismatchValue;
    private static string AuthorizationProtocolMismatchValue;
    private static string AuthorizationPermissionMismatchValue;
    private static string AuthorizationServiceMismatchValue;
    private static string AuthorizationResourceTypeMismatchValue;
    private static string FeatureVersionMismatchValue;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AccountAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AccountBeingCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AccountIsDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AuthenticationFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AuthorizationFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <ConditionHeadersNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <ConditionNotMet>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <EmptyMetadataKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InsufficientAccountPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InternalError>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidAuthenticationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidHeaderValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidHttpVerb>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidInput>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidMd5>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidQueryParameterValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidRange>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidUri>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidXmlDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidXmlNodeValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <Md5Mismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <MetadataTooLarge>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <MissingContentLengthHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <MissingRequiredQueryParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <MissingRequiredHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <MissingRequiredXmlNode>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <MultipleConditionHeadersNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <OperationTimedOut>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <OutOfRangeInput>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <OutOfRangeQueryParameterValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <RequestBodyTooLarge>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <ResourceTypeMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <RequestUrlFailedToParse>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <ResourceAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <ResourceNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <ServerBusy>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <UnsupportedHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <UnsupportedXmlNode>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <UnsupportedQueryParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <UnsupportedHttpVerb>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <InvalidMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <MessageNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <MessageTooLarge>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <PopReceiptMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <QueueAlreadyExists>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <QueueBeingDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <QueueDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <QueueNotEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <QueueNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AuthorizationSourceIPMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AuthorizationProtocolMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AuthorizationPermissionMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AuthorizationServiceMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <AuthorizationResourceTypeMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static QueueErrorCode <FeatureVersionMismatch>k__BackingField;
    public static QueueErrorCode AccountAlreadyExists { get; }
    public static QueueErrorCode AccountBeingCreated { get; }
    public static QueueErrorCode AccountIsDisabled { get; }
    public static QueueErrorCode AuthenticationFailed { get; }
    public static QueueErrorCode AuthorizationFailure { get; }
    public static QueueErrorCode ConditionHeadersNotSupported { get; }
    public static QueueErrorCode ConditionNotMet { get; }
    public static QueueErrorCode EmptyMetadataKey { get; }
    public static QueueErrorCode InsufficientAccountPermissions { get; }
    public static QueueErrorCode InternalError { get; }
    public static QueueErrorCode InvalidAuthenticationInfo { get; }
    public static QueueErrorCode InvalidHeaderValue { get; }
    public static QueueErrorCode InvalidHttpVerb { get; }
    public static QueueErrorCode InvalidInput { get; }
    public static QueueErrorCode InvalidMd5 { get; }
    public static QueueErrorCode InvalidMetadata { get; }
    public static QueueErrorCode InvalidQueryParameterValue { get; }
    public static QueueErrorCode InvalidRange { get; }
    public static QueueErrorCode InvalidResourceName { get; }
    public static QueueErrorCode InvalidUri { get; }
    public static QueueErrorCode InvalidXmlDocument { get; }
    public static QueueErrorCode InvalidXmlNodeValue { get; }
    public static QueueErrorCode Md5Mismatch { get; }
    public static QueueErrorCode MetadataTooLarge { get; }
    public static QueueErrorCode MissingContentLengthHeader { get; }
    public static QueueErrorCode MissingRequiredQueryParameter { get; }
    public static QueueErrorCode MissingRequiredHeader { get; }
    public static QueueErrorCode MissingRequiredXmlNode { get; }
    public static QueueErrorCode MultipleConditionHeadersNotSupported { get; }
    public static QueueErrorCode OperationTimedOut { get; }
    public static QueueErrorCode OutOfRangeInput { get; }
    public static QueueErrorCode OutOfRangeQueryParameterValue { get; }
    public static QueueErrorCode RequestBodyTooLarge { get; }
    public static QueueErrorCode ResourceTypeMismatch { get; }
    public static QueueErrorCode RequestUrlFailedToParse { get; }
    public static QueueErrorCode ResourceAlreadyExists { get; }
    public static QueueErrorCode ResourceNotFound { get; }
    public static QueueErrorCode ServerBusy { get; }
    public static QueueErrorCode UnsupportedHeader { get; }
    public static QueueErrorCode UnsupportedXmlNode { get; }
    public static QueueErrorCode UnsupportedQueryParameter { get; }
    public static QueueErrorCode UnsupportedHttpVerb { get; }
    public static QueueErrorCode InvalidMarker { get; }
    public static QueueErrorCode MessageNotFound { get; }
    public static QueueErrorCode MessageTooLarge { get; }
    public static QueueErrorCode PopReceiptMismatch { get; }
    public static QueueErrorCode QueueAlreadyExists { get; }
    public static QueueErrorCode QueueBeingDeleted { get; }
    public static QueueErrorCode QueueDisabled { get; }
    public static QueueErrorCode QueueNotEmpty { get; }
    public static QueueErrorCode QueueNotFound { get; }
    public static QueueErrorCode AuthorizationSourceIPMismatch { get; }
    public static QueueErrorCode AuthorizationProtocolMismatch { get; }
    public static QueueErrorCode AuthorizationPermissionMismatch { get; }
    public static QueueErrorCode AuthorizationServiceMismatch { get; }
    public static QueueErrorCode AuthorizationResourceTypeMismatch { get; }
    public static QueueErrorCode FeatureVersionMismatch { get; }
    public QueueErrorCode(string value);
    private static QueueErrorCode();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AccountAlreadyExists();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AccountBeingCreated();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AccountIsDisabled();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AuthenticationFailed();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AuthorizationFailure();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_ConditionHeadersNotSupported();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_ConditionNotMet();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_EmptyMetadataKey();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InsufficientAccountPermissions();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InternalError();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidAuthenticationInfo();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidHeaderValue();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidHttpVerb();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidInput();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidMd5();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidMetadata();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidQueryParameterValue();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidRange();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidResourceName();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidUri();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidXmlDocument();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidXmlNodeValue();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_Md5Mismatch();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_MetadataTooLarge();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_MissingContentLengthHeader();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_MissingRequiredQueryParameter();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_MissingRequiredHeader();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_MissingRequiredXmlNode();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_MultipleConditionHeadersNotSupported();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_OperationTimedOut();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_OutOfRangeInput();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_OutOfRangeQueryParameterValue();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_RequestBodyTooLarge();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_ResourceTypeMismatch();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_RequestUrlFailedToParse();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_ResourceAlreadyExists();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_ResourceNotFound();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_ServerBusy();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_UnsupportedHeader();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_UnsupportedXmlNode();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_UnsupportedQueryParameter();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_UnsupportedHttpVerb();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_InvalidMarker();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_MessageNotFound();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_MessageTooLarge();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_PopReceiptMismatch();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_QueueAlreadyExists();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_QueueBeingDeleted();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_QueueDisabled();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_QueueNotEmpty();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_QueueNotFound();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AuthorizationSourceIPMismatch();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AuthorizationProtocolMismatch();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AuthorizationPermissionMismatch();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AuthorizationServiceMismatch();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_AuthorizationResourceTypeMismatch();
    [CompilerGeneratedAttribute]
public static QueueErrorCode get_FeatureVersionMismatch();
    public static bool op_Equality(QueueErrorCode left, QueueErrorCode right);
    public static bool op_Inequality(QueueErrorCode left, QueueErrorCode right);
    public static QueueErrorCode op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(QueueErrorCode other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Azure.Storage.Queues.Models.QueueExtensions : object {
    [ExtensionAttribute]
internal static IEnumerable`1<string> AsIncludeTypes(QueueTraits traits);
}
[CodeGenModelAttribute("GeoReplication")]
public class Azure.Storage.Queues.Models.QueueGeoReplication : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastSyncedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueGeoReplicationStatus <Status>k__BackingField;
    [CodeGenMemberAttribute("LastSyncTime")]
public Nullable`1<DateTimeOffset> LastSyncedOn { get; internal set; }
    [CodeGenMemberAttribute("Status")]
public QueueGeoReplicationStatus Status { get; internal set; }
    internal QueueGeoReplication(QueueGeoReplicationStatus status, Nullable`1<DateTimeOffset> lastSyncedOn);
    internal static QueueGeoReplication DeserializeQueueGeoReplication(XElement element);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastSyncedOn();
    [CompilerGeneratedAttribute]
internal void set_LastSyncedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public QueueGeoReplicationStatus get_Status();
    [CompilerGeneratedAttribute]
internal void set_Status(QueueGeoReplicationStatus value);
}
public enum Azure.Storage.Queues.Models.QueueGeoReplicationStatus : Enum {
    public int value__;
    public static QueueGeoReplicationStatus Live;
    public static QueueGeoReplicationStatus Bootstrap;
    public static QueueGeoReplicationStatus Unavailable;
}
[ExtensionAttribute]
internal static class Azure.Storage.Queues.Models.QueueGeoReplicationStatusExtensions : object {
    [ExtensionAttribute]
public static string ToSerialString(QueueGeoReplicationStatus value);
    [ExtensionAttribute]
public static QueueGeoReplicationStatus ToQueueGeoReplicationStatus(string value);
}
public class Azure.Storage.Queues.Models.QueueItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    public string Name { get; internal set; }
    public IDictionary`2<string, string> Metadata { get; internal set; }
    internal QueueItem(string name);
    internal QueueItem(string name, IDictionary`2<string, string> metadata);
    internal static QueueItem DeserializeQueueItem(XElement element);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
}
public class Azure.Storage.Queues.Models.QueueMessage : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopReceipt>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryData <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <NextVisibleOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <InsertedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DequeueCount>k__BackingField;
    public string MessageId { get; internal set; }
    public string PopReceipt { get; internal set; }
    [EditorBrowsableAttribute("1")]
public string MessageText { get; internal set; }
    public BinaryData Body { get; internal set; }
    public Nullable`1<DateTimeOffset> NextVisibleOn { get; internal set; }
    public Nullable`1<DateTimeOffset> InsertedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; internal set; }
    public long DequeueCount { get; internal set; }
    internal QueueMessage(string messageText);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
internal void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_PopReceipt();
    [CompilerGeneratedAttribute]
internal void set_PopReceipt(string value);
    public string get_MessageText();
    internal void set_MessageText(string value);
    [CompilerGeneratedAttribute]
public BinaryData get_Body();
    [CompilerGeneratedAttribute]
internal void set_Body(BinaryData value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_NextVisibleOn();
    [CompilerGeneratedAttribute]
internal void set_NextVisibleOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_InsertedOn();
    [CompilerGeneratedAttribute]
internal void set_InsertedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public long get_DequeueCount();
    [CompilerGeneratedAttribute]
internal void set_DequeueCount(long value);
    public QueueMessage Update(UpdateReceipt updated);
    internal static QueueMessage ToQueueMessage(DequeuedMessageItem dequeuedMessageItem, QueueMessageEncoding messageEncoding);
}
[CodeGenModelAttribute("Metrics")]
public class Azure.Storage.Queues.Models.QueueMetrics : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueRetentionPolicy <RetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeApis>k__BackingField;
    public string Version { get; public set; }
    public bool Enabled { get; public set; }
    public QueueRetentionPolicy RetentionPolicy { get; public set; }
    [CodeGenMemberAttribute("IncludeAPIs")]
public Nullable`1<bool> IncludeApis { get; public set; }
    internal QueueMetrics(string version, bool enabled, Nullable`1<bool> includeApis, QueueRetentionPolicy retentionPolicy);
    internal QueueMetrics(bool skipInitialization);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public QueueRetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(QueueRetentionPolicy value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static QueueMetrics DeserializeQueueMetrics(XElement element);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeApis();
    [CompilerGeneratedAttribute]
public void set_IncludeApis(Nullable`1<bool> value);
}
public class Azure.Storage.Queues.Models.QueueProperties : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ApproximateMessagesCount>k__BackingField;
    public IDictionary`2<string, string> Metadata { get; internal set; }
    public int ApproximateMessagesCount { get; internal set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public int get_ApproximateMessagesCount();
    [CompilerGeneratedAttribute]
internal void set_ApproximateMessagesCount(int value);
}
[CodeGenModelAttribute("RetentionPolicy")]
public class Azure.Storage.Queues.Models.QueueRetentionPolicy : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Days>k__BackingField;
    public bool Enabled { get; public set; }
    public Nullable`1<int> Days { get; public set; }
    internal QueueRetentionPolicy(bool enabled, Nullable`1<int> days);
    internal QueueRetentionPolicy(bool enabled);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Days();
    [CompilerGeneratedAttribute]
public void set_Days(Nullable`1<int> value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static QueueRetentionPolicy DeserializeQueueRetentionPolicy(XElement element);
}
[CodeGenModelAttribute("StorageServiceProperties")]
public class Azure.Storage.Queues.Models.QueueServiceProperties : object {
    [CompilerGeneratedAttribute]
private QueueAnalyticsLogging <Logging>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueMetrics <HourMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueMetrics <MinuteMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<QueueCorsRule> <Cors>k__BackingField;
    public QueueAnalyticsLogging Logging { get; public set; }
    public QueueMetrics HourMetrics { get; public set; }
    public QueueMetrics MinuteMetrics { get; public set; }
    [CodeGenMemberAttribute("Cors")]
public IList`1<QueueCorsRule> Cors { get; public set; }
    internal QueueServiceProperties(QueueAnalyticsLogging logging, QueueMetrics hourMetrics, QueueMetrics minuteMetrics, IList`1<QueueCorsRule> cors);
    internal QueueServiceProperties(bool skipInitialization);
    [CompilerGeneratedAttribute]
public QueueAnalyticsLogging get_Logging();
    [CompilerGeneratedAttribute]
public void set_Logging(QueueAnalyticsLogging value);
    [CompilerGeneratedAttribute]
public QueueMetrics get_HourMetrics();
    [CompilerGeneratedAttribute]
public void set_HourMetrics(QueueMetrics value);
    [CompilerGeneratedAttribute]
public QueueMetrics get_MinuteMetrics();
    [CompilerGeneratedAttribute]
public void set_MinuteMetrics(QueueMetrics value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static QueueServiceProperties DeserializeQueueServiceProperties(XElement element);
    [CompilerGeneratedAttribute]
public IList`1<QueueCorsRule> get_Cors();
    [CompilerGeneratedAttribute]
public void set_Cors(IList`1<QueueCorsRule> value);
}
[CodeGenModelAttribute("StorageServiceStats")]
public class Azure.Storage.Queues.Models.QueueServiceStatistics : object {
    [CompilerGeneratedAttribute]
private QueueGeoReplication <GeoReplication>k__BackingField;
    [CodeGenMemberAttribute("GeoReplication")]
public QueueGeoReplication GeoReplication { get; internal set; }
    internal QueueServiceStatistics(QueueGeoReplication geoReplication);
    internal static QueueServiceStatistics DeserializeQueueServiceStatistics(XElement element);
    [CompilerGeneratedAttribute]
public QueueGeoReplication get_GeoReplication();
    [CompilerGeneratedAttribute]
internal void set_GeoReplication(QueueGeoReplication value);
}
[CodeGenModelAttribute("SignedIdentifier")]
public class Azure.Storage.Queues.Models.QueueSignedIdentifier : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueAccessPolicy <AccessPolicy>k__BackingField;
    public string Id { get; public set; }
    public QueueAccessPolicy AccessPolicy { get; public set; }
    internal QueueSignedIdentifier(string id, QueueAccessPolicy accessPolicy);
    internal QueueSignedIdentifier(bool skipInitialization);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public QueueAccessPolicy get_AccessPolicy();
    [CompilerGeneratedAttribute]
public void set_AccessPolicy(QueueAccessPolicy value);
    private sealed virtual override void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint);
    internal static QueueSignedIdentifier DeserializeQueueSignedIdentifier(XElement element);
}
[CodeGenTypeAttribute("StorageQueuesModelFactory")]
public static class Azure.Storage.Queues.Models.QueuesModelFactory : object {
    [EditorBrowsableAttribute("1")]
public static QueueMessage QueueMessage(string messageId, string popReceipt, string messageText, long dequeueCount, Nullable`1<DateTimeOffset> nextVisibleOn, Nullable`1<DateTimeOffset> insertedOn, Nullable`1<DateTimeOffset> expiresOn);
    public static QueueMessage QueueMessage(string messageId, string popReceipt, BinaryData body, long dequeueCount, Nullable`1<DateTimeOffset> nextVisibleOn, Nullable`1<DateTimeOffset> insertedOn, Nullable`1<DateTimeOffset> expiresOn);
    [EditorBrowsableAttribute("1")]
public static PeekedMessage PeekedMessage(string messageId, string messageText, long dequeueCount, Nullable`1<DateTimeOffset> insertedOn, Nullable`1<DateTimeOffset> expiresOn);
    public static PeekedMessage PeekedMessage(string messageId, BinaryData message, long dequeueCount, Nullable`1<DateTimeOffset> insertedOn, Nullable`1<DateTimeOffset> expiresOn);
    public static QueueItem QueueItem(string name, IDictionary`2<string, string> metadata);
    public static QueueProperties QueueProperties(IDictionary`2<string, string> metadata, int approximateMessagesCount);
    public static QueueServiceStatistics QueueServiceStatistics(QueueGeoReplication geoReplication);
    public static UpdateReceipt UpdateReceipt(string popReceipt, DateTimeOffset nextVisibleOn);
    public static SendReceipt SendReceipt(string messageId, DateTimeOffset insertionTime, DateTimeOffset expirationTime, string popReceipt, DateTimeOffset timeNextVisible);
    public static QueueGeoReplication QueueGeoReplication(QueueGeoReplicationStatus status, Nullable`1<DateTimeOffset> lastSyncedOn);
}
[FlagsAttribute]
public enum Azure.Storage.Queues.Models.QueueTraits : Enum {
    public int value__;
    public static QueueTraits None;
    public static QueueTraits Metadata;
}
[CodeGenModelAttribute("EnqueuedMessage")]
public class Azure.Storage.Queues.Models.SendReceipt : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <InsertionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopReceipt>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <TimeNextVisible>k__BackingField;
    [CodeGenMemberAttribute("MessageId")]
public string MessageId { get; internal set; }
    [CodeGenMemberAttribute("InsertionTime")]
public DateTimeOffset InsertionTime { get; internal set; }
    [CodeGenMemberAttribute("ExpirationTime")]
public DateTimeOffset ExpirationTime { get; internal set; }
    [CodeGenMemberAttribute("PopReceipt")]
public string PopReceipt { get; internal set; }
    [CodeGenMemberAttribute("TimeNextVisible")]
public DateTimeOffset TimeNextVisible { get; internal set; }
    internal SendReceipt(string messageId, DateTimeOffset insertionTime, DateTimeOffset expirationTime, string popReceipt, DateTimeOffset timeNextVisible);
    internal static SendReceipt DeserializeSendReceipt(XElement element);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
internal void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_InsertionTime();
    [CompilerGeneratedAttribute]
internal void set_InsertionTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpirationTime();
    [CompilerGeneratedAttribute]
internal void set_ExpirationTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_PopReceipt();
    [CompilerGeneratedAttribute]
internal void set_PopReceipt(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_TimeNextVisible();
    [CompilerGeneratedAttribute]
internal void set_TimeNextVisible(DateTimeOffset value);
}
internal class Azure.Storage.Queues.Models.StorageError : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    internal StorageError(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    internal static StorageError DeserializeStorageError(XElement element);
}
public class Azure.Storage.Queues.Models.UpdateReceipt : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <NextVisibleOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopReceipt>k__BackingField;
    public DateTimeOffset NextVisibleOn { get; internal set; }
    public string PopReceipt { get; internal set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_NextVisibleOn();
    [CompilerGeneratedAttribute]
internal void set_NextVisibleOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_PopReceipt();
    [CompilerGeneratedAttribute]
internal void set_PopReceipt(string value);
}
public class Azure.Storage.Queues.QueueClient : object {
    private Uri _uri;
    private Uri _messagesUri;
    private QueueClientConfiguration _clientConfiguration;
    private QueueRestClient _queueRestClient;
    private MessagesRestClient _messagesRestClient;
    private MessageIdRestClient _messageIdRestClient;
    private string _accountName;
    private string _name;
    private QueueServiceClient _parentQueueServiceClient;
    public Uri Uri { get; }
    protected Uri MessagesUri { get; }
    internal QueueClientConfiguration ClientConfiguration { get; }
    internal QueueRestClient QueueRestClient { get; }
    internal MessagesRestClient MessagesRestClient { get; }
    internal MessageIdRestClient MessageIdRestClient { get; }
    internal bool UsingClientSideEncryption { get; }
    public int MaxPeekableMessages { get; }
    public int MessageMaxBytes { get; }
    public string AccountName { get; }
    public string Name { get; }
    public bool CanGenerateSasUri { get; }
    public QueueClient(string connectionString, string queueName);
    public QueueClient(string connectionString, string queueName, QueueClientOptions options);
    public QueueClient(Uri queueUri, QueueClientOptions options);
    public QueueClient(Uri queueUri, StorageSharedKeyCredential credential, QueueClientOptions options);
    public QueueClient(Uri queueUri, AzureSasCredential credential, QueueClientOptions options);
    public QueueClient(Uri queueUri, TokenCredential credential, QueueClientOptions options);
    internal QueueClient(Uri queueUri, HttpPipelinePolicy authentication, QueueClientOptions options, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    internal QueueClient(Uri queueUri, QueueClientConfiguration clientConfiguration);
    public virtual Uri get_Uri();
    protected virtual Uri get_MessagesUri();
    internal virtual QueueClientConfiguration get_ClientConfiguration();
    internal virtual QueueRestClient get_QueueRestClient();
    internal virtual MessagesRestClient get_MessagesRestClient();
    internal virtual MessageIdRestClient get_MessageIdRestClient();
    internal bool get_UsingClientSideEncryption();
    public virtual int get_MaxPeekableMessages();
    public virtual int get_MessageMaxBytes();
    public virtual string get_AccountName();
    public virtual string get_Name();
    public virtual bool get_CanGenerateSasUri();
    private ValueTuple`3<QueueRestClient, MessagesRestClient, MessageIdRestClient> BuildRestClients();
    private void SetNameFieldsIfNull();
    protected internal virtual QueueClient WithClientSideEncryptionOptionsCore(ClientSideEncryptionOptions clientSideEncryptionOptions);
    public virtual Response Create(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<CreateAsync>d__45")]
public virtual Task`1<Response> CreateAsync(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<CreateInternal>d__46")]
private Task`1<Response> CreateInternal(IDictionary`2<string, string> metadata, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response CreateIfNotExists(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<CreateIfNotExistsAsync>d__48")]
public virtual Task`1<Response> CreateIfNotExistsAsync(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<CreateIfNotExistsInternal>d__49")]
private Task`1<Response> CreateIfNotExistsInternal(IDictionary`2<string, string> metadata, bool async, CancellationToken cancellationToken);
    public virtual Response`1<bool> Exists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ExistsAsync>d__51")]
public virtual Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ExistsInternal>d__52")]
private Task`1<Response`1<bool>> ExistsInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<bool> DeleteIfExists(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<DeleteIfExistsAsync>d__54")]
public virtual Task`1<Response`1<bool>> DeleteIfExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<DeleteIfExistsInternal>d__55")]
private Task`1<Response`1<bool>> DeleteIfExistsInternal(bool async, CancellationToken cancellationToken);
    public virtual Response Delete(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<DeleteAsync>d__57")]
public virtual Task`1<Response> DeleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<DeleteInternal>d__58")]
private Task`1<Response> DeleteInternal(bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<QueueProperties> GetProperties(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<GetPropertiesAsync>d__60")]
public virtual Task`1<Response`1<QueueProperties>> GetPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<GetPropertiesInternal>d__61")]
private Task`1<Response`1<QueueProperties>> GetPropertiesInternal(bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response SetMetadata(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<SetMetadataAsync>d__63")]
public virtual Task`1<Response> SetMetadataAsync(IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<SetMetadataInternal>d__64")]
private Task`1<Response> SetMetadataInternal(IDictionary`2<string, string> metadata, bool async, CancellationToken cancellationToken);
    public virtual Response`1<IEnumerable`1<QueueSignedIdentifier>> GetAccessPolicy(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<GetAccessPolicyAsync>d__66")]
public virtual Task`1<Response`1<IEnumerable`1<QueueSignedIdentifier>>> GetAccessPolicyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<GetAccessPolicyInternal>d__67")]
private Task`1<Response`1<IEnumerable`1<QueueSignedIdentifier>>> GetAccessPolicyInternal(bool async, CancellationToken cancellationToken);
    public virtual Response SetAccessPolicy(IEnumerable`1<QueueSignedIdentifier> permissions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<SetAccessPolicyAsync>d__69")]
public virtual Task`1<Response> SetAccessPolicyAsync(IEnumerable`1<QueueSignedIdentifier> permissions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<SetAccessPolicyInternal>d__70")]
private Task`1<Response> SetAccessPolicyInternal(IEnumerable`1<QueueSignedIdentifier> permissions, bool async, CancellationToken cancellationToken);
    public virtual Response ClearMessages(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ClearMessagesAsync>d__72")]
public virtual Task`1<Response> ClearMessagesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ClearMessagesInternal>d__73")]
private Task`1<Response> ClearMessagesInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<SendReceipt> SendMessage(string messageText);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<SendMessageAsync>d__75")]
public virtual Task`1<Response`1<SendReceipt>> SendMessageAsync(string messageText);
    public virtual Response`1<SendReceipt> SendMessage(string messageText, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<SendMessageAsync>d__77")]
public virtual Task`1<Response`1<SendReceipt>> SendMessageAsync(string messageText, CancellationToken cancellationToken);
    public virtual Response`1<SendReceipt> SendMessage(string messageText, Nullable`1<TimeSpan> visibilityTimeout, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
    public virtual Response`1<SendReceipt> SendMessage(BinaryData message, Nullable`1<TimeSpan> visibilityTimeout, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<SendMessageAsync>d__80")]
public virtual Task`1<Response`1<SendReceipt>> SendMessageAsync(string messageText, Nullable`1<TimeSpan> visibilityTimeout, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<SendMessageAsync>d__81")]
public virtual Task`1<Response`1<SendReceipt>> SendMessageAsync(BinaryData message, Nullable`1<TimeSpan> visibilityTimeout, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<SendMessageInternal>d__82")]
private Task`1<Response`1<SendReceipt>> SendMessageInternal(BinaryData message, Nullable`1<TimeSpan> visibilityTimeout, Nullable`1<TimeSpan> timeToLive, bool async, CancellationToken cancellationToken, string operationName);
    public virtual Response`1<QueueMessage[]> ReceiveMessages();
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ReceiveMessagesAsync>d__84")]
public virtual Task`1<Response`1<QueueMessage[]>> ReceiveMessagesAsync();
    public virtual Response`1<QueueMessage[]> ReceiveMessages(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ReceiveMessagesAsync>d__86")]
public virtual Task`1<Response`1<QueueMessage[]>> ReceiveMessagesAsync(CancellationToken cancellationToken);
    public virtual Response`1<QueueMessage[]> ReceiveMessages(Nullable`1<int> maxMessages, Nullable`1<TimeSpan> visibilityTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ReceiveMessagesAsync>d__88")]
public virtual Task`1<Response`1<QueueMessage[]>> ReceiveMessagesAsync(Nullable`1<int> maxMessages, Nullable`1<TimeSpan> visibilityTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ReceiveMessagesInternal>d__89")]
private Task`1<Response`1<QueueMessage[]>> ReceiveMessagesInternal(Nullable`1<int> maxMessages, Nullable`1<TimeSpan> visibilityTimeout, string operationName, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ToQueueMessagesWithInvalidMessageHandling>d__90")]
private Task`1<QueueMessage[]> ToQueueMessagesWithInvalidMessageHandling(IEnumerable`1<DequeuedMessageItem> dequeuedMessageItems, bool async, CancellationToken cancellationToken);
    public virtual Response`1<QueueMessage> ReceiveMessage(Nullable`1<TimeSpan> visibilityTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ReceiveMessageAsync>d__92")]
public virtual Task`1<Response`1<QueueMessage>> ReceiveMessageAsync(Nullable`1<TimeSpan> visibilityTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ReceiveMessageInternal>d__93")]
private Task`1<Response`1<QueueMessage>> ReceiveMessageInternal(Nullable`1<TimeSpan> visibilityTimeout, bool async, CancellationToken cancellationToken);
    public virtual Response`1<PeekedMessage> PeekMessage(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<PeekMessageAsync>d__95")]
public virtual Task`1<Response`1<PeekedMessage>> PeekMessageAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<PeekMessageInternal>d__96")]
private Task`1<Response`1<PeekedMessage>> PeekMessageInternal(bool async, CancellationToken cancellationToken);
    public virtual Response`1<PeekedMessage[]> PeekMessages(Nullable`1<int> maxMessages, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<PeekMessagesAsync>d__98")]
public virtual Task`1<Response`1<PeekedMessage[]>> PeekMessagesAsync(Nullable`1<int> maxMessages, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<PeekMessagesInternal>d__99")]
private Task`1<Response`1<PeekedMessage[]>> PeekMessagesInternal(Nullable`1<int> maxMessages, bool async, CancellationToken cancellationToken, string operationName);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<ToPeekedMessagesWithInvalidMessageHandling>d__100")]
private Task`1<PeekedMessage[]> ToPeekedMessagesWithInvalidMessageHandling(IEnumerable`1<PeekedMessageItem> peekedMessageItems, bool async, CancellationToken cancellationToken);
    private Uri GetMessageUri(string messageId);
    public virtual Response DeleteMessage(string messageId, string popReceipt, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<DeleteMessageAsync>d__103")]
public virtual Task`1<Response> DeleteMessageAsync(string messageId, string popReceipt, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<DeleteMessageInternal>d__104")]
private Task`1<Response> DeleteMessageInternal(string messageId, string popReceipt, bool async, CancellationToken cancellationToken);
    public virtual Response`1<UpdateReceipt> UpdateMessage(string messageId, string popReceipt, string messageText, TimeSpan visibilityTimeout, CancellationToken cancellationToken);
    public virtual Response`1<UpdateReceipt> UpdateMessage(string messageId, string popReceipt, BinaryData message, TimeSpan visibilityTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<UpdateMessageAsync>d__107")]
public virtual Task`1<Response`1<UpdateReceipt>> UpdateMessageAsync(string messageId, string popReceipt, string messageText, TimeSpan visibilityTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<UpdateMessageAsync>d__108")]
public virtual Task`1<Response`1<UpdateReceipt>> UpdateMessageAsync(string messageId, string popReceipt, BinaryData message, TimeSpan visibilityTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<UpdateMessageInternal>d__109")]
private Task`1<Response`1<UpdateReceipt>> UpdateMessageInternal(BinaryData message, string messageId, string popReceipt, TimeSpan visibilityTimeout, bool async, CancellationToken cancellationToken, string operationName);
    [CallerShouldAuditAttribute]
public virtual Uri GenerateSasUri(QueueSasPermissions permissions, DateTimeOffset expiresOn);
    [CallerShouldAuditAttribute]
public virtual Uri GenerateSasUri(QueueSasBuilder builder);
    private static BinaryData ToBinaryData(string input);
    private void AssertEncodingForEncryption();
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClient/<OnMessageDecodingFailedAsync>d__114")]
protected virtual Task OnMessageDecodingFailedAsync(QueueMessage receivedMessage, PeekedMessage peekedMessage, bool isRunningSynchronously, CancellationToken cancellationToken);
    protected internal virtual QueueServiceClient GetParentQueueServiceClientCore();
}
internal class Azure.Storage.Queues.QueueClientConfiguration : StorageClientConfiguration {
    [CompilerGeneratedAttribute]
private ServiceVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueClientSideEncryptionOptions <ClientSideEncryption>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueMessageEncoding <MessageEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> <QueueMessageDecodingFailedHandlers>k__BackingField;
    public ServiceVersion Version { get; internal set; }
    public QueueClientSideEncryptionOptions ClientSideEncryption { get; internal set; }
    public QueueMessageEncoding MessageEncoding { get; internal set; }
    public SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> QueueMessageDecodingFailedHandlers { get; internal set; }
    public QueueClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, QueueClientSideEncryptionOptions clientSideEncryption, QueueMessageEncoding messageEncoding, SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> queueMessageDecodingFailedHandlers);
    public QueueClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, QueueClientSideEncryptionOptions clientSideEncryption, QueueMessageEncoding messageEncoding, SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> queueMessageDecodingFailedHandlers);
    public QueueClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, QueueClientSideEncryptionOptions clientSideEncryption, QueueMessageEncoding messageEncoding, SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> queueMessageDecodingFailedHandlers);
    public QueueClientConfiguration(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics, ServiceVersion version, QueueClientSideEncryptionOptions clientSideEncryption, QueueMessageEncoding messageEncoding, SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> queueMessageDecodingFailedHandlers);
    internal QueueClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, QueueClientSideEncryptionOptions clientSideEncryption, QueueMessageEncoding messageEncoding, SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> queueMessageDecodingFailedHandlers);
    [CompilerGeneratedAttribute]
public ServiceVersion get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(ServiceVersion value);
    [CompilerGeneratedAttribute]
public QueueClientSideEncryptionOptions get_ClientSideEncryption();
    [CompilerGeneratedAttribute]
internal void set_ClientSideEncryption(QueueClientSideEncryptionOptions value);
    [CompilerGeneratedAttribute]
public QueueMessageEncoding get_MessageEncoding();
    [CompilerGeneratedAttribute]
internal void set_MessageEncoding(QueueMessageEncoding value);
    [CompilerGeneratedAttribute]
public SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> get_QueueMessageDecodingFailedHandlers();
    [CompilerGeneratedAttribute]
internal void set_QueueMessageDecodingFailedHandlers(SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> value);
}
public class Azure.Storage.Queues.QueueClientOptions : ClientOptions {
    internal static ServiceVersion LatestVersion;
    [CompilerGeneratedAttribute]
private ServiceVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <GeoRedundantSecondaryUri>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueMessageEncoding <MessageEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTenantDiscovery>k__BackingField;
    [CompilerGeneratedAttribute]
private SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> MessageDecodingFailed;
    internal ClientSideEncryptionOptions _clientSideEncryptionOptions;
    [CompilerGeneratedAttribute]
private Nullable`1<QueueAudience> <Audience>k__BackingField;
    public ServiceVersion Version { get; }
    public Uri GeoRedundantSecondaryUri { get; public set; }
    public QueueMessageEncoding MessageEncoding { get; public set; }
    public bool EnableTenantDiscovery { get; public set; }
    public Nullable`1<QueueAudience> Audience { get; public set; }
    public QueueClientOptions(ServiceVersion version);
    [CompilerGeneratedAttribute]
public ServiceVersion get_Version();
    [CompilerGeneratedAttribute]
public Uri get_GeoRedundantSecondaryUri();
    [CompilerGeneratedAttribute]
public void set_GeoRedundantSecondaryUri(Uri value);
    [CompilerGeneratedAttribute]
public QueueMessageEncoding get_MessageEncoding();
    [CompilerGeneratedAttribute]
public void set_MessageEncoding(QueueMessageEncoding value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableTenantDiscovery();
    [CompilerGeneratedAttribute]
public void set_EnableTenantDiscovery(bool value);
    [CompilerGeneratedAttribute]
public void add_MessageDecodingFailed(SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MessageDecodingFailed(SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> value);
    internal SyncAsyncEventHandler`1<QueueMessageDecodingFailedEventArgs> GetMessageDecodingFailedHandlers();
    private void AddHeadersAndQueryParameters();
    internal HttpPipeline Build(HttpPipelinePolicy authentication);
    internal HttpPipeline Build(object credentials);
    [CompilerGeneratedAttribute]
public Nullable`1<QueueAudience> get_Audience();
    [CompilerGeneratedAttribute]
public void set_Audience(Nullable`1<QueueAudience> value);
}
internal class Azure.Storage.Queues.QueueClientSideDecryptor : object {
    private ClientSideDecryptor _decryptor;
    [CompilerGeneratedAttribute]
private QueueClientSideEncryptionOptions <Options>k__BackingField;
    public QueueClientSideEncryptionOptions Options { get; }
    public QueueClientSideDecryptor(QueueClientSideEncryptionOptions options);
    [CompilerGeneratedAttribute]
public QueueClientSideEncryptionOptions get_Options();
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClientSideDecryptor/<ClientSideDecryptMessagesInternal>d__5")]
public Task`1<QueueMessage[]> ClientSideDecryptMessagesInternal(QueueMessage[] messages, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClientSideDecryptor/<ClientSideDecryptMessagesInternal>d__6")]
public Task`1<PeekedMessage[]> ClientSideDecryptMessagesInternal(PeekedMessage[] messages, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClientSideDecryptor/<ClientSideDecryptInternal>d__7")]
private Task`1<BinaryData> ClientSideDecryptInternal(BinaryData downloadedMessage, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Queues.QueueClientSideEncryptor : object {
    private IClientSideEncryptor _encryptor;
    public QueueClientSideEncryptor(IClientSideEncryptor encryptor);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueClientSideEncryptor/<ClientSideEncryptInternal>d__2")]
public Task`1<BinaryData> ClientSideEncryptInternal(BinaryData messageToUpload, bool async, CancellationToken cancellationToken);
}
internal class Azure.Storage.Queues.QueueCreateHeaders : object {
    private Response _response;
    public string Version { get; }
    public QueueCreateHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.QueueDeleteHeaders : object {
    private Response _response;
    public string Version { get; }
    public QueueDeleteHeaders(Response response);
    public string get_Version();
}
[ExtensionAttribute]
internal static class Azure.Storage.Queues.QueueExtensions : object {
    [ExtensionAttribute]
internal static string ToPermissionsString(QueueAccountSasPermissions permissions);
    [ExtensionAttribute]
internal static string ToPermissionsString(QueueSasPermissions permissions);
}
internal class Azure.Storage.Queues.QueueGetAccessPolicyHeaders : object {
    private Response _response;
    public string Version { get; }
    public QueueGetAccessPolicyHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.QueueGetPropertiesHeaders : object {
    private Response _response;
    public IDictionary`2<string, string> Metadata { get; }
    public Nullable`1<int> ApproximateMessagesCount { get; }
    public string Version { get; }
    public QueueGetPropertiesHeaders(Response response);
    public IDictionary`2<string, string> get_Metadata();
    public Nullable`1<int> get_ApproximateMessagesCount();
    public string get_Version();
}
internal static class Azure.Storage.Queues.QueueMessageCodec : object {
    public static string EncodeMessageBody(BinaryData binaryData, QueueMessageEncoding messageEncoding);
    public static BinaryData DecodeMessageBody(string messageText, QueueMessageEncoding messageEncoding);
}
public class Azure.Storage.Queues.QueueMessageDecodingFailedEventArgs : SyncAsyncEventArgs {
    [CompilerGeneratedAttribute]
private QueueClient <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueMessage <ReceivedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private PeekedMessage <PeekedMessage>k__BackingField;
    public QueueClient Queue { get; }
    public QueueMessage ReceivedMessage { get; }
    public PeekedMessage PeekedMessage { get; }
    public QueueMessageDecodingFailedEventArgs(QueueClient queueClient, QueueMessage receivedMessage, PeekedMessage peekedMessage, bool isRunningSynchronously, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public QueueClient get_Queue();
    [CompilerGeneratedAttribute]
public QueueMessage get_ReceivedMessage();
    [CompilerGeneratedAttribute]
public PeekedMessage get_PeekedMessage();
}
public enum Azure.Storage.Queues.QueueMessageEncoding : Enum {
    public int value__;
    public static QueueMessageEncoding None;
    public static QueueMessageEncoding Base64;
}
internal class Azure.Storage.Queues.QueueRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public QueueRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateCreateRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueRestClient/<CreateAsync>d__8")]
public Task`1<ResponseWithHeaders`1<QueueCreateHeaders>> CreateAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<QueueCreateHeaders> Create(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    internal HttpMessage CreateDeleteRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueRestClient/<DeleteAsync>d__11")]
public Task`1<ResponseWithHeaders`1<QueueDeleteHeaders>> DeleteAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<QueueDeleteHeaders> Delete(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueRestClient/<GetPropertiesAsync>d__14")]
public Task`1<ResponseWithHeaders`1<QueueGetPropertiesHeaders>> GetPropertiesAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<QueueGetPropertiesHeaders> GetProperties(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateSetMetadataRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueRestClient/<SetMetadataAsync>d__17")]
public Task`1<ResponseWithHeaders`1<QueueSetMetadataHeaders>> SetMetadataAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<QueueSetMetadataHeaders> SetMetadata(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    internal HttpMessage CreateGetAccessPolicyRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueRestClient/<GetAccessPolicyAsync>d__20")]
public Task`1<ResponseWithHeaders`2<IReadOnlyList`1<QueueSignedIdentifier>, QueueGetAccessPolicyHeaders>> GetAccessPolicyAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<IReadOnlyList`1<QueueSignedIdentifier>, QueueGetAccessPolicyHeaders> GetAccessPolicy(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateSetAccessPolicyRequest(Nullable`1<int> timeout, IEnumerable`1<QueueSignedIdentifier> queueAcl);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueRestClient/<SetAccessPolicyAsync>d__23")]
public Task`1<ResponseWithHeaders`1<QueueSetAccessPolicyHeaders>> SetAccessPolicyAsync(Nullable`1<int> timeout, IEnumerable`1<QueueSignedIdentifier> queueAcl, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<QueueSetAccessPolicyHeaders> SetAccessPolicy(Nullable`1<int> timeout, IEnumerable`1<QueueSignedIdentifier> queueAcl, CancellationToken cancellationToken);
}
public class Azure.Storage.Queues.QueueServiceClient : object {
    private Uri _uri;
    private QueueClientConfiguration _clientConfiguration;
    private ServiceRestClient _serviceRestClient;
    private string _accountName;
    public Uri Uri { get; }
    internal QueueClientConfiguration ClientConfiguration { get; }
    internal ServiceRestClient ServiceRestClient { get; }
    public string AccountName { get; }
    public bool CanGenerateAccountSasUri { get; }
    public QueueServiceClient(string connectionString);
    public QueueServiceClient(string connectionString, QueueClientOptions options);
    public QueueServiceClient(Uri serviceUri, QueueClientOptions options);
    public QueueServiceClient(Uri serviceUri, StorageSharedKeyCredential credential, QueueClientOptions options);
    public QueueServiceClient(Uri serviceUri, AzureSasCredential credential, QueueClientOptions options);
    public QueueServiceClient(Uri serviceUri, TokenCredential credential, QueueClientOptions options);
    internal QueueServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, QueueClientOptions options, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential);
    internal QueueServiceClient(Uri serviceUri, QueueClientConfiguration clientConfiguration);
    public virtual Uri get_Uri();
    internal virtual QueueClientConfiguration get_ClientConfiguration();
    internal virtual ServiceRestClient get_ServiceRestClient();
    public virtual string get_AccountName();
    public virtual bool get_CanGenerateAccountSasUri();
    private ServiceRestClient BuildServiceRestClient();
    public virtual QueueClient GetQueueClient(string queueName);
    public virtual Pageable`1<QueueItem> GetQueues(QueueTraits traits, string prefix, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<QueueItem> GetQueuesAsync(QueueTraits traits, string prefix, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueServiceClient/<GetQueuesInternal>d__27")]
internal Task`1<Response`1<ListQueuesSegmentResponse>> GetQueuesInternal(string marker, QueueTraits traits, string prefix, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    public virtual Response`1<QueueServiceProperties> GetProperties(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueServiceClient/<GetPropertiesAsync>d__29")]
public virtual Task`1<Response`1<QueueServiceProperties>> GetPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueServiceClient/<GetPropertiesInternal>d__30")]
private Task`1<Response`1<QueueServiceProperties>> GetPropertiesInternal(bool async, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute]
public virtual Response SetProperties(QueueServiceProperties properties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueServiceClient/<SetPropertiesAsync>d__32")]
[CallerShouldAuditAttribute]
public virtual Task`1<Response> SetPropertiesAsync(QueueServiceProperties properties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueServiceClient/<SetPropertiesInternal>d__33")]
private Task`1<Response> SetPropertiesInternal(QueueServiceProperties properties, bool async, CancellationToken cancellationToken);
    public virtual Response`1<QueueServiceStatistics> GetStatistics(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueServiceClient/<GetStatisticsAsync>d__35")]
public virtual Task`1<Response`1<QueueServiceStatistics>> GetStatisticsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueServiceClient/<GetStatisticsInternal>d__36")]
private Task`1<Response`1<QueueServiceStatistics>> GetStatisticsInternal(bool async, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response`1<QueueClient> CreateQueue(string queueName, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueServiceClient/<CreateQueueAsync>d__38")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response`1<QueueClient>> CreateQueueAsync(string queueName, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
    [ForwardsClientCallsAttribute]
public virtual Response DeleteQueue(string queueName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.QueueServiceClient/<DeleteQueueAsync>d__40")]
[ForwardsClientCallsAttribute]
public virtual Task`1<Response> DeleteQueueAsync(string queueName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute]
public Uri GenerateAccountSasUri(AccountSasPermissions permissions, DateTimeOffset expiresOn, AccountSasResourceTypes resourceTypes);
    [CallerShouldAuditAttribute]
public Uri GenerateAccountSasUri(AccountSasBuilder builder);
}
internal class Azure.Storage.Queues.QueueSetAccessPolicyHeaders : object {
    private Response _response;
    public string Version { get; }
    public QueueSetAccessPolicyHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.QueueSetMetadataHeaders : object {
    private Response _response;
    public string Version { get; }
    public QueueSetMetadataHeaders(Response response);
    public string get_Version();
}
public class Azure.Storage.Queues.QueueUriBuilder : object {
    private Uri _uri;
    private bool _isPathStyleUri;
    private string _scheme;
    private string _host;
    private int _port;
    private string _accountName;
    private string _queueName;
    private bool _messages;
    private string _messageId;
    private SasQueryParameters _sas;
    private string _query;
    public string Scheme { get; public set; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public string AccountName { get; public set; }
    public string QueueName { get; public set; }
    public bool Messages { get; public set; }
    public string MessageId { get; public set; }
    public SasQueryParameters Sas { get; public set; }
    public string Query { get; public set; }
    public QueueUriBuilder(Uri uri);
    public string get_Scheme();
    public void set_Scheme(string value);
    public string get_Host();
    public void set_Host(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_AccountName();
    public void set_AccountName(string value);
    public string get_QueueName();
    public void set_QueueName(string value);
    public bool get_Messages();
    public void set_Messages(bool value);
    public string get_MessageId();
    public void set_MessageId(string value);
    public SasQueryParameters get_Sas();
    public void set_Sas(SasQueryParameters value);
    public string get_Query();
    public void set_Query(string value);
    public Uri ToUri();
    public virtual string ToString();
    private void ResetUri();
    private RequestUriBuilder BuildUri();
}
internal class Azure.Storage.Queues.ServiceGetPropertiesHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceGetPropertiesHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.ServiceGetStatisticsHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceGetStatisticsHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.ServiceListQueuesSegmentHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceListQueuesSegmentHeaders(Response response);
    public string get_Version();
}
internal class Azure.Storage.Queues.ServiceRestClient : object {
    private HttpPipeline _pipeline;
    private string _url;
    private string _version;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    internal ClientDiagnostics ClientDiagnostics { get; }
    public ServiceRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version);
    [CompilerGeneratedAttribute]
internal ClientDiagnostics get_ClientDiagnostics();
    internal HttpMessage CreateSetPropertiesRequest(QueueServiceProperties storageServiceProperties, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.ServiceRestClient/<SetPropertiesAsync>d__8")]
public Task`1<ResponseWithHeaders`1<ServiceSetPropertiesHeaders>> SetPropertiesAsync(QueueServiceProperties storageServiceProperties, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`1<ServiceSetPropertiesHeaders> SetProperties(QueueServiceProperties storageServiceProperties, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateGetPropertiesRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.ServiceRestClient/<GetPropertiesAsync>d__11")]
public Task`1<ResponseWithHeaders`2<QueueServiceProperties, ServiceGetPropertiesHeaders>> GetPropertiesAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<QueueServiceProperties, ServiceGetPropertiesHeaders> GetProperties(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateGetStatisticsRequest(Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.ServiceRestClient/<GetStatisticsAsync>d__14")]
public Task`1<ResponseWithHeaders`2<QueueServiceStatistics, ServiceGetStatisticsHeaders>> GetStatisticsAsync(Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<QueueServiceStatistics, ServiceGetStatisticsHeaders> GetStatistics(Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateListQueuesSegmentRequest(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<string> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.ServiceRestClient/<ListQueuesSegmentAsync>d__17")]
public Task`1<ResponseWithHeaders`2<ListQueuesSegmentResponse, ServiceListQueuesSegmentHeaders>> ListQueuesSegmentAsync(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<string> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListQueuesSegmentResponse, ServiceListQueuesSegmentHeaders> ListQueuesSegment(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<string> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    internal HttpMessage CreateListQueuesSegmentNextPageRequest(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<string> include, Nullable`1<int> timeout);
    [AsyncStateMachineAttribute("Azure.Storage.Queues.ServiceRestClient/<ListQueuesSegmentNextPageAsync>d__20")]
public Task`1<ResponseWithHeaders`2<ListQueuesSegmentResponse, ServiceListQueuesSegmentHeaders>> ListQueuesSegmentNextPageAsync(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<string> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
    public ResponseWithHeaders`2<ListQueuesSegmentResponse, ServiceListQueuesSegmentHeaders> ListQueuesSegmentNextPage(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<string> include, Nullable`1<int> timeout, CancellationToken cancellationToken);
}
internal class Azure.Storage.Queues.ServiceSetPropertiesHeaders : object {
    private Response _response;
    public string Version { get; }
    public ServiceSetPropertiesHeaders(Response response);
    public string get_Version();
}
public class Azure.Storage.Queues.Specialized.ClientSideDecryptionFailureEventArgs : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    internal ClientSideDecryptionFailureEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
internal class Azure.Storage.Queues.Specialized.Models.EncryptedMessage : object {
    [CompilerGeneratedAttribute]
private string <EncryptedMessageText>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionData <EncryptionData>k__BackingField;
    public string EncryptedMessageText { get; public set; }
    public EncryptionData EncryptionData { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EncryptedMessageText();
    [CompilerGeneratedAttribute]
public void set_EncryptedMessageText(string value);
    [CompilerGeneratedAttribute]
public EncryptionData get_EncryptionData();
    [CompilerGeneratedAttribute]
public void set_EncryptionData(EncryptionData value);
}
internal static class Azure.Storage.Queues.Specialized.Models.EncryptedMessageSerializer : object {
    private static string EncryptedMessage_EncryptedMessageTextName;
    public static BinaryData Serialize(EncryptedMessage data);
    public static ReadOnlyMemory`1<byte> SerializeEncryptedMessage(EncryptedMessage message);
    public static void WriteEncryptedMessage(Utf8JsonWriter json, EncryptedMessage message);
    public static bool TryDeserialize(BinaryData serializedData, EncryptedMessage& encryptedMessage);
    public static EncryptedMessage Deserialize(BinaryData serializedData);
    public static EncryptedMessage DeserializeEncryptedMessage(Utf8JsonReader& reader);
    private static EncryptedMessage ReadEncryptionData(JsonElement root);
    private static void ReadPropertyValue(EncryptedMessage data, JsonProperty property);
}
public class Azure.Storage.Queues.Specialized.QueueClientSideEncryptionOptions : ClientSideEncryptionOptions {
    [CompilerGeneratedAttribute]
private EventHandler`1<ClientSideDecryptionFailureEventArgs> DecryptionFailed;
    internal bool UsingDecryptionFailureHandler { get; }
    public QueueClientSideEncryptionOptions(ClientSideEncryptionVersion version);
    [CompilerGeneratedAttribute]
public void add_DecryptionFailed(EventHandler`1<ClientSideDecryptionFailureEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DecryptionFailed(EventHandler`1<ClientSideDecryptionFailureEventArgs> value);
    internal bool get_UsingDecryptionFailureHandler();
    internal void OnDecryptionFailed(object message, Exception e);
    internal static QueueClientSideEncryptionOptions CloneFrom(ClientSideEncryptionOptions options);
}
public class Azure.Storage.Queues.Specialized.SpecializedQueueClientOptions : QueueClientOptions {
    public ClientSideEncryptionOptions ClientSideEncryption { get; public set; }
    public SpecializedQueueClientOptions(ServiceVersion version);
    public ClientSideEncryptionOptions get_ClientSideEncryption();
    public void set_ClientSideEncryption(ClientSideEncryptionOptions value);
}
[ExtensionAttribute]
public static class Azure.Storage.Queues.Specialized.SpecializedQueueExtensions : object {
    [ExtensionAttribute]
public static QueueClient WithClientSideEncryptionOptions(QueueClient client, ClientSideEncryptionOptions clientSideEncryptionOptions);
    [ExtensionAttribute]
public static QueueServiceClient GetParentQueueServiceClient(QueueClient client);
}
[FlagsAttribute]
public enum Azure.Storage.Sas.QueueAccountSasPermissions : Enum {
    public int value__;
    public static QueueAccountSasPermissions Read;
    public static QueueAccountSasPermissions Write;
    public static QueueAccountSasPermissions Delete;
    public static QueueAccountSasPermissions List;
    public static QueueAccountSasPermissions Add;
    public static QueueAccountSasPermissions Update;
    public static QueueAccountSasPermissions Process;
    public static QueueAccountSasPermissions All;
}
public class Azure.Storage.Sas.QueueSasBuilder : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SasProtocol <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private SasIPRange <IPRange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueueName>k__BackingField;
    private static List`1<char> s_validPermissionsInOrder;
    [EditorBrowsableAttribute("1")]
public string Version { get; public set; }
    public SasProtocol Protocol { get; public set; }
    public DateTimeOffset StartsOn { get; public set; }
    public DateTimeOffset ExpiresOn { get; public set; }
    public string Permissions { get; private set; }
    public SasIPRange IPRange { get; public set; }
    public string Identifier { get; public set; }
    public string QueueName { get; public set; }
    public QueueSasBuilder(QueueSasPermissions permissions, DateTimeOffset expiresOn);
    public QueueSasBuilder(QueueAccountSasPermissions permissions, DateTimeOffset expiresOn);
    private static QueueSasBuilder();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public SasProtocol get_Protocol();
    [CompilerGeneratedAttribute]
public void set_Protocol(SasProtocol value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartsOn();
    [CompilerGeneratedAttribute]
public void set_StartsOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_Permissions();
    [CompilerGeneratedAttribute]
private void set_Permissions(string value);
    [CompilerGeneratedAttribute]
public SasIPRange get_IPRange();
    [CompilerGeneratedAttribute]
public void set_IPRange(SasIPRange value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public string get_QueueName();
    [CompilerGeneratedAttribute]
public void set_QueueName(string value);
    public void SetPermissions(QueueSasPermissions permissions);
    public void SetPermissions(QueueAccountSasPermissions permissions);
    public void SetPermissions(string rawPermissions, bool normalize);
    public void SetPermissions(string rawPermissions);
    [CallerShouldAuditAttribute]
public SasQueryParameters ToSasQueryParameters(StorageSharedKeyCredential sharedKeyCredential);
    private static string GetCanonicalName(string account, string queueName);
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private void EnsureState();
    internal static QueueSasBuilder DeepCopy(QueueSasBuilder originalQueueSasBuilder);
}
[FlagsAttribute]
public enum Azure.Storage.Sas.QueueSasPermissions : Enum {
    public int value__;
    public static QueueSasPermissions Read;
    public static QueueSasPermissions Add;
    public static QueueSasPermissions Update;
    public static QueueSasPermissions Process;
    public static QueueSasPermissions All;
}
[ExtensionAttribute]
internal static class Azure.Storage.Sas.SasExtensions : object {
    private static string NoneName;
    private static string HttpsName;
    private static string HttpsAndHttpName;
    [ExtensionAttribute]
internal static string ToPermissionsString(AccountSasResourceTypes resourceTypes);
    internal static AccountSasResourceTypes ParseResourceTypes(string s);
    [ExtensionAttribute]
internal static string ToProtocolString(SasProtocol protocol);
    public static SasProtocol ParseProtocol(string s);
    [ExtensionAttribute]
internal static string ToPermissionsString(AccountSasServices services);
    internal static AccountSasServices ParseAccountServices(string s);
    internal static string FormatTimesForSasSigning(DateTimeOffset time);
    internal static void AddToBuilder(StringBuilder sb, string key, string value);
    internal static string ValidateAndSanitizeRawPermissions(string permissions, List`1<char> validPermissionsInOrder);
}
internal class Azure.Storage.Sas.SasQueryParametersInternals : SasQueryParameters {
    [CompilerGeneratedAttribute]
private static string <DefaultSasVersionInternal>k__BackingField;
    internal static string DefaultSasVersionInternal { get; internal set; }
    private static SasQueryParametersInternals();
    [CompilerGeneratedAttribute]
internal static string get_DefaultSasVersionInternal();
    [CompilerGeneratedAttribute]
internal static void set_DefaultSasVersionInternal(string value);
    internal static SasQueryParameters Create(IDictionary`2<string, string> values);
    internal static SasQueryParameters Create(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth, string encryptionScope);
}
internal interface Azure.Storage.Shared.ISupportsTenantIdChallenges {
    public bool EnableTenantDiscovery { get; }
    public abstract virtual bool get_EnableTenantDiscovery();
}
internal class Azure.Storage.Shared.StorageClientConfiguration : object {
    [CompilerGeneratedAttribute]
private HttpPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageSharedKeyCredential <SharedKeyCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCredential <TokenCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureSasCredential <SasCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <ClientDiagnostics>k__BackingField;
    public HttpPipeline Pipeline { get; private set; }
    public StorageSharedKeyCredential SharedKeyCredential { get; private set; }
    public TokenCredential TokenCredential { get; private set; }
    public AzureSasCredential SasCredential { get; private set; }
    public ClientDiagnostics ClientDiagnostics { get; private set; }
    public StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics);
    public StorageClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics);
    public StorageClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics);
    internal StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics);
    internal StorageClientConfiguration(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics);
    [CompilerGeneratedAttribute]
public virtual HttpPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
private void set_Pipeline(HttpPipeline value);
    [CompilerGeneratedAttribute]
public virtual StorageSharedKeyCredential get_SharedKeyCredential();
    [CompilerGeneratedAttribute]
private void set_SharedKeyCredential(StorageSharedKeyCredential value);
    [CompilerGeneratedAttribute]
public virtual TokenCredential get_TokenCredential();
    [CompilerGeneratedAttribute]
private void set_TokenCredential(TokenCredential value);
    [CompilerGeneratedAttribute]
public virtual AzureSasCredential get_SasCredential();
    [CompilerGeneratedAttribute]
private void set_SasCredential(AzureSasCredential value);
    [CompilerGeneratedAttribute]
public virtual ClientDiagnostics get_ClientDiagnostics();
    [CompilerGeneratedAttribute]
private void set_ClientDiagnostics(ClientDiagnostics value);
}
internal class Azure.Storage.SharedAccessSignatureCredentials : object {
    [CompilerGeneratedAttribute]
private string <SasToken>k__BackingField;
    public string SasToken { get; }
    public SharedAccessSignatureCredentials(string sasToken);
    [CompilerGeneratedAttribute]
public string get_SasToken();
}
internal class Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy : BearerTokenAuthenticationPolicy {
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _scopes;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) tenantId;
    private bool _enableTenantDiscovery;
    public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, string scope, bool enableTenantDiscovery);
    public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, IEnumerable`1<string> scopes, bool enableTenantDiscovery);
    protected virtual void AuthorizeRequest(HttpMessage message);
    protected virtual ValueTask AuthorizeRequestAsync(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy/<AuthorizeRequestInternal>d__7")]
private ValueTask AuthorizeRequestInternal(HttpMessage message, bool async);
    protected virtual bool AuthorizeRequestOnChallenge(HttpMessage message);
    protected virtual ValueTask`1<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy/<AuthorizeRequestOnChallengeInternalAsync>d__10")]
private ValueTask`1<bool> AuthorizeRequestOnChallengeInternalAsync(HttpMessage message, bool async);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageClientOptions : object {
    private static string StorageScope;
    [ExtensionAttribute]
public static void Initialize(ClientOptions options);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(StorageSharedKeyCredential credential);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(AzureSasCredential credential, Uri resourceUri);
    [ExtensionAttribute]
public static HttpPipelinePolicy AsPolicy(TokenCredential credential, string scope, ClientOptions options);
    public static HttpPipelinePolicy GetAuthenticationPolicy(object credentials, string scope, ClientOptions options);
    [ExtensionAttribute]
public static HttpPipeline Build(ClientOptions options, HttpPipelinePolicy authentication, Uri geoRedundantSecondaryStorageUri);
    [ExtensionAttribute]
public static HttpPipeline Build(ClientOptions options, object credentials, Uri geoRedundantSecondaryStorageUri);
}
internal abstract class Azure.Storage.StorageCollectionEnumerator`1 : object {
    public abstract virtual ValueTask`1<Page`1<T>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken);
    public Pageable`1<T> ToSyncCollection(CancellationToken cancellationToken);
    public AsyncPageable`1<T> ToAsyncCollection(CancellationToken cancellationToken);
}
internal class Azure.Storage.StorageConnectionString : object {
    private static KeyValuePair`2<string, Func`2<string, bool>> s_useDevelopmentStorageSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_developmentStorageProxyUriSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_defaultEndpointsProtocolSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountNameSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountKeyNameSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_accountKeySetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_blobEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_queueEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_fileEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_tableEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_blobSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_queueSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_fileSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_tableSecondaryEndpointSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_endpointSuffixSetting;
    private static KeyValuePair`2<string, Func`2<string, bool>> s_sharedAccessSignatureSetting;
    private static StorageConnectionString s_devStoreAccount;
    [CompilerGeneratedAttribute]
private bool <IsDevStoreAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultEndpoints>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <BlobStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <QueueStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <TableStorageUri>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Uri, Uri> <FileStorageUri>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Credentials>k__BackingField;
    internal string _accountName;
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> s_validCredentials;
    internal static bool UseV1MD5 { get; }
    public static StorageConnectionString DevelopmentStorageAccount { get; }
    internal bool IsDevStoreAccount { get; internal set; }
    internal string EndpointSuffix { get; internal set; }
    internal IDictionary`2<string, string> Settings { get; internal set; }
    internal bool DefaultEndpoints { get; internal set; }
    public Uri BlobEndpoint { get; }
    public Uri QueueEndpoint { get; }
    public Uri TableEndpoint { get; }
    public Uri FileEndpoint { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> BlobStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> QueueStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> TableStorageUri { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<Uri, Uri> FileStorageUri { get; public set; }
    public object Credentials { get; public set; }
    public StorageConnectionString(object storageCredentials, ValueTuple`2<Uri, Uri> blobStorageUri, ValueTuple`2<Uri, Uri> queueStorageUri, ValueTuple`2<Uri, Uri> tableStorageUri, ValueTuple`2<Uri, Uri> fileStorageUri);
    private static StorageConnectionString();
    internal static bool get_UseV1MD5();
    public static StorageConnectionString get_DevelopmentStorageAccount();
    [CompilerGeneratedAttribute]
internal bool get_IsDevStoreAccount();
    [CompilerGeneratedAttribute]
internal void set_IsDevStoreAccount(bool value);
    [CompilerGeneratedAttribute]
internal string get_EndpointSuffix();
    [CompilerGeneratedAttribute]
internal void set_EndpointSuffix(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
internal bool get_DefaultEndpoints();
    [CompilerGeneratedAttribute]
internal void set_DefaultEndpoints(bool value);
    public Uri get_BlobEndpoint();
    public Uri get_QueueEndpoint();
    public Uri get_TableEndpoint();
    public Uri get_FileEndpoint();
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_BlobStorageUri();
    [CompilerGeneratedAttribute]
public void set_BlobStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_QueueStorageUri();
    [CompilerGeneratedAttribute]
public void set_QueueStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_TableStorageUri();
    [CompilerGeneratedAttribute]
public void set_TableStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public ValueTuple`2<Uri, Uri> get_FileStorageUri();
    [CompilerGeneratedAttribute]
public void set_FileStorageUri(ValueTuple`2<Uri, Uri> value);
    [CompilerGeneratedAttribute]
public object get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(object value);
    public static StorageConnectionString Parse(string connectionString);
    public static bool TryParse(string connectionString, StorageConnectionString& account);
    private static StorageConnectionString GetDevelopmentStorageAccount(Uri proxyUri);
    internal static bool ParseCore(string connectionString, StorageConnectionString& accountInformation, Action`1<string> error);
    private static IDictionary`2<string, string> ParseStringIntoSettings(string connectionString, Action`1<string> error);
    private static KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, String[] validValues);
    private static KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, Func`2<string, bool> isValid);
    private static bool IsValidBase64String(string settingValue);
    private static bool IsValidUri(string settingValue);
    private static bool IsValidDomain(string settingValue);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AllRequired(KeyValuePair`2[] requiredSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> Optional(KeyValuePair`2[] optionalSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AtLeastOne(KeyValuePair`2[] atLeastOneSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> None(KeyValuePair`2[] atLeastOneSettings);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesAll(Func`2[] filters);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesOne(Func`2[] filters);
    private static Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesExactly(Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> filter);
    private static bool MatchesSpecification(IDictionary`2<string, string> settings, Func`2[] constraints);
    private static object GetCredentials(IDictionary`2<string, string> settings);
    private static ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructFileEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructFileEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructTableEndpoint(IDictionary`2<string, string> settings);
    internal static ValueTuple`2<Uri, Uri> ConstructTableEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken);
    private static ValueTuple`2<Uri, Uri> ConstructUris(string scheme, string accountName, string hostNamePrefix, string endpointSuffix, string sasToken);
    [CompilerGeneratedAttribute]
internal static string <ParseCore>g__settingOrDefault|70_0(string key, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
internal static bool <ParseCore>g__s_isValidEndpointPair|70_1(string primary, string secondary);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<Uri, Uri> <ParseCore>g__createStorageUri|70_2(string primary, string secondary, string sasToken, Func`2<IDictionary`2<string, string>, ValueTuple`2<Uri, Uri>> factory, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
internal static Uri <ParseCore>g__CreateUri|70_3(string endpoint, string sasToken);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageExceptionExtensions : object {
    [ExtensionAttribute]
public static string GetErrorCode(Response response, string errorCode);
    [ExtensionAttribute]
public static bool IsUnavailable(Response`1<T> response);
    [ExtensionAttribute]
public static Response`1<T> AsNoBodyResponse(Response rawResponse);
}
internal class Azure.Storage.StorageRequestValidationPipelinePolicy : HttpPipelineSynchronousPolicy {
    public virtual void OnReceivedResponse(HttpMessage message);
}
internal class Azure.Storage.StorageResponseClassifier : ResponseClassifier {
    [CompilerGeneratedAttribute]
private Uri <SecondaryStorageUri>k__BackingField;
    public Uri SecondaryStorageUri { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_SecondaryStorageUri();
    [CompilerGeneratedAttribute]
public void set_SecondaryStorageUri(Uri value);
    public virtual bool IsRetriableResponse(HttpMessage message);
    public virtual bool IsErrorResponse(HttpMessage message);
}
internal class Azure.Storage.StorageServerTimeoutPolicy : HttpPipelineSynchronousPolicy {
    private static string QueryParameterKeyWithEqualSign;
    [CompilerGeneratedAttribute]
private static StorageServerTimeoutPolicy <Shared>k__BackingField;
    public static StorageServerTimeoutPolicy Shared { get; }
    private static StorageServerTimeoutPolicy();
    [CompilerGeneratedAttribute]
public static StorageServerTimeoutPolicy get_Shared();
    public virtual void OnSendingRequest(HttpMessage message);
}
internal class Azure.Storage.StorageSharedKeyCredentialInternals : StorageSharedKeyCredential {
    private StorageSharedKeyCredentialInternals(string accountName, string accountKey);
    internal static string ComputeSasSignature(StorageSharedKeyCredential credential, string message);
}
internal class Azure.Storage.StorageSharedKeyPipelinePolicy : HttpPipelineSynchronousPolicy {
    private static bool IncludeXMsDate;
    private StorageSharedKeyCredential _credentials;
    public StorageSharedKeyPipelinePolicy(StorageSharedKeyCredential credentials);
    public virtual void OnSendingRequest(HttpMessage message);
    private string BuildStringToSign(HttpMessage message);
    private static void BuildCanonicalizedHeaders(StringBuilder stringBuilder, HttpMessage message);
    private void BuildCanonicalizedResource(StringBuilder stringBuilder, Uri resource);
}
internal class Azure.Storage.StorageTelemetryPolicy : HttpPipelineSynchronousPolicy {
    private static string CseIdentifierV2;
    private static string CseIdentifierV1;
    [CompilerGeneratedAttribute]
private static StorageTelemetryPolicy <Shared>k__BackingField;
    public static StorageTelemetryPolicy Shared { get; }
    private static StorageTelemetryPolicy();
    [CompilerGeneratedAttribute]
public static StorageTelemetryPolicy get_Shared();
    public virtual void OnSendingRequest(HttpMessage message);
    private static void ApplyAzFeatures(HttpMessage message, AzFeatures azFeatures);
    private static string Serialize(AzFeatures azFeatures);
    private static string TransformUserAgent(string userAgent, string injection);
}
[ExtensionAttribute]
internal static class Azure.Storage.StorageVersionExtensions : object {
    public static ServiceVersion LatestVersion;
    internal static ServiceVersion MaxVersion;
    [ExtensionAttribute]
public static string ToVersionString(ServiceVersion version);
}
[ExtensionAttribute]
internal static class Azure.Storage.UriExtensions : object {
    [ExtensionAttribute]
public static Uri AppendToPath(Uri uri, string segment);
    [ExtensionAttribute]
public static IDictionary`2<string, string> GetQueryParameters(Uri uri);
    [ExtensionAttribute]
public static string GetAccountNameFromDomain(Uri uri, string serviceSubDomain);
    public static string GetAccountNameFromDomain(string host, string serviceSubDomain);
    [ExtensionAttribute]
public static string GetPath(Uri uri);
    [ExtensionAttribute]
public static bool IsHostIPEndPointStyle(Uri uri);
    [ExtensionAttribute]
internal static void AppendQueryParameter(StringBuilder sb, string key, string value);
}
internal class Azure.Storage.UriQueryParamsCollection : Dictionary`2<string, string> {
    public UriQueryParamsCollection(string encodedQueryParamString);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.Azure.QueueClientBuilderExtensions : object {
    [ExtensionAttribute]
public static IAzureClientBuilder`2<QueueServiceClient, QueueClientOptions> AddQueueServiceClient(TBuilder builder, string connectionString);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<QueueServiceClient, QueueClientOptions> AddQueueServiceClient(TBuilder builder, Uri serviceUri);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<QueueServiceClient, QueueClientOptions> AddQueueServiceClient(TBuilder builder, Uri serviceUri, StorageSharedKeyCredential sharedKeyCredential);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<QueueServiceClient, QueueClientOptions> AddQueueServiceClient(TBuilder builder, TConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
