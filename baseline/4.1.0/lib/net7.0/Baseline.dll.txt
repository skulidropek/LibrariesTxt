[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Baseline.Cache`2 : object {
    private object _locker;
    private ImHashMap`2<TKey, TValue> _values;
    private Action`1<TValue> _onAddition;
    private Func`2<TKey, TValue> _onMissing;
    [CompilerGeneratedAttribute]
private Func`2<TValue, TKey> <GetKey>k__BackingField;
    unknown Action`1<TValue> OnAddition {public set; }
    unknown Func`2<TKey, TValue> OnMissing {public set; }
    public Func`2<TValue, TKey> GetKey { get; public set; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public Cache`2(Func`2<TKey, TValue> onMissing);
    public Cache`2(IDictionary`2<TKey, TValue> dictionary, Func`2<TKey, TValue> onMissing);
    public Cache`2(IDictionary`2<TKey, TValue> dictionary);
    public void set_OnAddition(Action`1<TValue> value);
    public void set_OnMissing(Func`2<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public Func`2<TValue, TKey> get_GetKey();
    [CompilerGeneratedAttribute]
public void set_GetKey(Func`2<TValue, TKey> value);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    public void FillDefault(TKey key);
    public void Fill(TKey key, Func`2<TKey, TValue> onMissing);
    public void Fill(TKey key, TValue value);
    public bool TryFind(TKey key, TValue& value);
    public TKey[] GetAllKeys();
    public void Remove(TKey key);
    public void ClearAll();
    public IDictionary`2<TKey, TValue> ToDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Baseline.ConcurrentCache`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> _values;
    private Action`1<TValue> _onAddition;
    private Func`2<TKey, TValue> _onMissing;
    [CompilerGeneratedAttribute]
private Func`2<TValue, TKey> <GetKey>k__BackingField;
    unknown Action`1<TValue> OnAddition {public set; }
    unknown Func`2<TKey, TValue> OnMissing {public set; }
    public Func`2<TValue, TKey> GetKey { get; public set; }
    public int Count { get; }
    [ObsoleteAttribute("Use First() or FirstOrDefault().")]
public TValue First { get; }
    public TValue Item { get; public set; }
    public ConcurrentCache`2(Func`2<TKey, TValue> onMissing);
    public ConcurrentCache`2(IDictionary`2<TKey, TValue> dictionary, Func`2<TKey, TValue> onMissing);
    public ConcurrentCache`2(IDictionary`2<TKey, TValue> dictionary);
    public void set_OnAddition(Action`1<TValue> value);
    public void set_OnMissing(Func`2<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public Func`2<TValue, TKey> get_GetKey();
    [CompilerGeneratedAttribute]
public void set_GetKey(Func`2<TValue, TKey> value);
    public int get_Count();
    public TValue get_First();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    public void FillDefault(TKey key);
    public void Fill(TKey key, Func`2<TKey, TValue> onMissing);
    public void Fill(TKey key, TValue value);
    public void Each(Action`1<TValue> action);
    public void Each(Action`2<TKey, TValue> action);
    public bool Has(TKey key);
    public bool Exists(Predicate`1<TValue> predicate);
    public TValue Find(Predicate`1<TValue> predicate);
    public TKey[] GetAllKeys();
    public TValue[] GetAll();
    public void Remove(TKey key);
    public void ClearAll();
    public bool WithValue(TKey key, Action`1<TValue> callback);
    public IDictionary`2<TKey, TValue> ToDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Conversion.ArrayConversion : object {
    private Conversions _conversions;
    public ArrayConversion(Conversions conversions);
    public sealed virtual Func`2<string, object> ConverterFor(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Conversion.Conversions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LightweightCache`2<Type, Func`2<string, object>> _convertors;
    private IList`1<IConversionProvider> _providers;
    [IteratorStateMachineAttribute("Baseline.Conversion.Conversions/<providers>d__3")]
private IEnumerable`1<IConversionProvider> providers();
    [NullableContextAttribute("0")]
public void RegisterConversionProvider();
    public void RegisterConversion(Func`2<string, T> convertor);
    public Func`2<string, object> FindConverter(Type type);
    public object Convert(Type type, string raw);
    public bool Has(Type type);
    [CompilerGeneratedAttribute]
private Func`2<string, object> <.ctor>b__2_0(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Conversion.DateTimeConverter : object {
    public static string TODAY;
    private static Regex iso8601Expression;
    private static DateTimeConverter();
    public static DateTime GetDateTime(string dateString);
    private static DateTime convertToDateFromDayAndTime(string dateString);
    private static bool isDayOfWeek(string text);
    private static int minutesFrom24HourTime(string time);
}
public class Baseline.Conversion.EnumerationConversion : object {
    [NullableContextAttribute("1")]
public sealed virtual Func`2<string, object> ConverterFor(Type type);
}
[NullableContextAttribute("1")]
public interface Baseline.Conversion.IConversionProvider {
    public abstract virtual Func`2<string, object> ConverterFor(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Conversion.NullableConvertor : object {
    private Conversions _conversions;
    public NullableConvertor(Conversions conversions);
    public sealed virtual Func`2<string, object> ConverterFor(Type type);
}
public class Baseline.Conversion.StringConverterProvider : object {
    [NullableContextAttribute("1")]
public sealed virtual Func`2<string, object> ConverterFor(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Conversion.TimeSpanConverter : object {
    private static string TimespanPattern;
    public static TimeSpan GetTimeSpan(string timeString);
}
public enum Baseline.CopyBehavior : Enum {
    public int value__;
    public static CopyBehavior overwrite;
    public static CopyBehavior preserve;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Date : object {
    public static string TimeFormat;
    [CompilerGeneratedAttribute]
private DateTime <Day>k__BackingField;
    public DateTime Day { get; public set; }
    public Date(DateTime date);
    public Date(int month, int day, int year);
    public Date(string ddmmyyyy);
    [CompilerGeneratedAttribute]
public DateTime get_Day();
    [CompilerGeneratedAttribute]
public void set_Day(DateTime value);
    public Date NextDay();
    [NullableContextAttribute("2")]
public bool Equals(Date other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Date left, Date right);
    public static bool op_Inequality(Date left, Date right);
    public virtual int GetHashCode();
    public virtual string ToString();
    public Date AddDays(int daysFromNow);
    public DateTime AtTime(TimeSpan time);
    public DateTime AtTime(string mmhh);
    public static Date Today();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Dates.Clock : object {
    private Func`1<DateTime> _now;
    public sealed virtual DateTime UtcNow();
    public void Live();
    public Clock LocalNow(DateTime localTime, TimeZoneInfo localZone);
    public Clock RestartAtLocal(DateTime desiredLocalTime, TimeZoneInfo localZone);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.Dates.DateTimeExtensions : object {
    [ExtensionAttribute]
public static Date ToDate(DateTime time);
    [ExtensionAttribute]
public static Date FirstDayOfMonth(DateTime time);
    [ExtensionAttribute]
public static Date LastDayOfMonth(DateTime time);
    [ExtensionAttribute]
public static DateTime StartOfTimeZoneDayInUtc(DateTime utcTime, TimeZoneInfo timezone);
    [ExtensionAttribute]
public static DateTime ToLocalTime(DateTime utcTime, TimeZoneInfo targetTimeZone);
    [ExtensionAttribute]
public static DateTime ToLocalTime(Nullable`1<DateTime> utcTime, TimeZoneInfo targetTimeZone);
    [ExtensionAttribute]
public static DateTime ToUniversalTime(DateTime localTime, TimeZoneInfo sourceTimeZone);
    [ExtensionAttribute]
public static LocalTime ToLocal(DateTime localTime, TimeZoneInfo timeZone);
}
public interface Baseline.Dates.IClock {
    public abstract virtual DateTime UtcNow();
}
[NullableContextAttribute("1")]
public interface Baseline.Dates.ISettableClock {
    public abstract virtual ISettableClock LocalNow(DateTime now, TimeZoneInfo timeZone);
    public abstract virtual ISettableClock LocalNow(LocalTime time);
}
[NullableContextAttribute("1")]
public interface Baseline.Dates.ISystemTime {
    public abstract virtual DateTime UtcNow();
    public abstract virtual LocalTime LocalTime();
}
[NullableContextAttribute("1")]
public interface Baseline.Dates.ITimeZoneContext {
    public abstract virtual TimeZoneInfo GetTimeZone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Dates.LocalTime : object {
    [CompilerGeneratedAttribute]
private TimeZoneInfo <TimeZone>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <UtcTime>k__BackingField;
    public TimeZoneInfo TimeZone { get; }
    public DateTime UtcTime { get; }
    public Date Date { get; }
    public TimeSpan TimeOfDay { get; }
    public DateTime Time { get; }
    public LocalTime(DateTime utcTime, TimeZoneInfo timeZone);
    public LocalTime(string representation);
    public static LocalTime AtMachineTime(DateTime time);
    public static LocalTime AtMachineTime(TimeSpan time);
    public static LocalTime AtMachineTime(string timeString);
    public static LocalTime GuessDayFromTimeOfDay(LocalTime currentTime, TimeSpan timeOfDay);
    public static LocalTime Now();
    public LocalTime AtTime(TimeSpan time);
    public static LocalTime AtDayAndTime(Date date, TimeSpan time);
    public LocalTime BeginningOfDay();
    public string Hydrate();
    private static DateTime findLocalTime(string text);
    [CompilerGeneratedAttribute]
public TimeZoneInfo get_TimeZone();
    [CompilerGeneratedAttribute]
public DateTime get_UtcTime();
    public Date get_Date();
    public TimeSpan get_TimeOfDay();
    public TimeSpan Subtract(LocalTime otherTime);
    public LocalTime Add(TimeSpan duration);
    public DateTime get_Time();
    [NullableContextAttribute("2")]
public bool Equals(LocalTime other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(LocalTime other);
    public virtual string ToString();
    public static bool op_GreaterThan(LocalTime left, LocalTime right);
    public static bool op_LessThan(LocalTime left, LocalTime right);
    public static bool op_GreaterThanOrEqual(LocalTime left, LocalTime right);
    public static bool op_LessThanOrEqual(LocalTime left, LocalTime right);
}
public class Baseline.Dates.MachineTimeZoneContext : object {
    [NullableContextAttribute("1")]
public sealed virtual TimeZoneInfo GetTimeZone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Dates.Milestone : object {
    private Nullable`1<DateTime> _timestamp;
    public Nullable`1<DateTime> Timestamp { get; public set; }
    public bool IsTrue { get; }
    public bool IsFalse { get; }
    public Milestone(string timeString);
    public Milestone(LocalTime time);
    public Milestone(DateTime timestamp);
    public static bool op_Implicit(Milestone m);
    public Milestone Capture(DateTime timestamp);
    public Nullable`1<DateTime> get_Timestamp();
    public void set_Timestamp(Nullable`1<DateTime> value);
    public bool get_IsTrue();
    public bool get_IsFalse();
    public bool HappenedBefore(DateTime time);
    [NullableContextAttribute("2")]
public bool Equals(Milestone other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Clear();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Dates.Period : object {
    [CompilerGeneratedAttribute]
private LocalTime <From>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private LocalTime <To>k__BackingField;
    public LocalTime From { get; public set; }
    [NullableAttribute("2")]
public LocalTime To { get; public set; }
    public Period(DateTime utcTime);
    public Period(LocalTime from);
    public Period(LocalTime from, LocalTime to);
    [CompilerGeneratedAttribute]
public LocalTime get_From();
    [CompilerGeneratedAttribute]
public void set_From(LocalTime value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public LocalTime get_To();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_To(LocalTime value);
    public void MarkCompleted(LocalTime completedTime);
    public virtual string ToString();
    public bool IsActiveAt(LocalTime timestamp);
    public bool IsActiveAt(DateTime utcTime);
    [NullableContextAttribute("2")]
public bool Equals(Period other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public LocalTime FindDateTime(TimeSpan time);
    public LocalTime FindDateTime(string timeString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Dates.SettableClock : object {
    private DateTime _time;
    private TimeZoneInfo _timeZone;
    public sealed virtual DateTime UtcNow();
    public sealed virtual LocalTime LocalTime();
    public sealed virtual ISettableClock LocalNow(LocalTime time);
    public sealed virtual ISettableClock LocalNow(DateTime now, TimeZoneInfo timeZone);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Dates.SystemTime : object {
    private IClock _clock;
    private ITimeZoneContext _context;
    public SystemTime(IClock clock, ITimeZoneContext context);
    public sealed virtual LocalTime LocalTime();
    public sealed virtual DateTime UtcNow();
    public static SystemTime Default();
    public static SystemTime AtLocalTime(DateTime now);
    public static SystemTime AtLocalTime(TimeSpan timeOfDay);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.Dates.TimeSpanExtensions : object {
    private static string TIMESPAN_PATTERN;
    [ExtensionAttribute]
public static TimeSpan ToTime(int minutes);
    [ExtensionAttribute]
public static TimeSpan ToTime(string timeString);
    public static TimeSpan GetTimeSpan(string timeString);
    [ExtensionAttribute]
public static TimeSpan Minutes(int number);
    [ExtensionAttribute]
public static TimeSpan Hours(int number);
    [ExtensionAttribute]
public static TimeSpan Days(int number);
    [ExtensionAttribute]
public static TimeSpan Seconds(int number);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(int number);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue Get(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue Get(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static void SmartAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static T Get(IDictionary`2<string, object> dictionary, string key);
    [ExtensionAttribute]
public static IDictionary`2<string, object> Child(IDictionary`2<string, object> dictionary, string key);
    [ExtensionAttribute]
public static IEnumerable`1<IDictionary`2<string, object>> Children(IDictionary`2<string, object> dictionary, string key);
}
[ExtensionAttribute]
public static class Baseline.DisposableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void SafeDispose(IDisposable disposable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Exceptions.ExceptionTransform`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<FilterRule<T>> _rules;
    public sealed virtual bool TryTransform(Exception original, Exception& transformed);
    public ExceptionTransform`1<T> TransformTo(Func`2<T, Exception> transform);
    public FilterRule<T> If(Func`2<T, bool> filter);
    [NullableContextAttribute("2")]
public FilterRule<T> IfInnerIs(Func`2<TInner, bool> innerFilter);
}
[ExtensionAttribute]
public static class Baseline.Exceptions.ExceptionTransformExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void TransformAndThrow(IEnumerable`1<IExceptionTransform> transforms, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Exceptions.ExceptionTransforms : object {
    private IList`1<IExceptionTransform> _transforms;
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IExceptionTransform> GetEnumerator();
    [NullableContextAttribute("0")]
public void AddTransform();
    public void AddTransform(IExceptionTransform transform);
    public ExceptionTransform`1<T> IfExceptionIs();
    public void TransformAndThrow(Exception ex);
}
[NullableContextAttribute("1")]
public interface Baseline.Exceptions.IExceptionTransform {
    public abstract virtual bool TryTransform(Exception original, Exception& transformed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Expressions.FindMembers : ExpressionVisitor {
    internal static PropertyInfo ArrayLength;
    public IList`1<MemberInfo> Members;
    private static FindMembers();
    [NullableContextAttribute("2")]
public static MemberInfo Member(Expression`1<Func`2<T, object>> expression);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected sealed virtual Expression VisitUnary(UnaryExpression node);
    public static MemberInfo[] Determine(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Baseline.Expressions.LambdaBuilder : object {
    public static Func`2<TTarget, TProperty> GetProperty(PropertyInfo property);
    [NullableContextAttribute("2")]
public static Action`2<TTarget, TProperty> SetProperty(PropertyInfo property);
    public static Func`2<TTarget, TField> GetField(FieldInfo field);
    public static Func`2<TTarget, TMember> Getter(MemberInfo member);
    public static Action`2<TTarget, TField> SetField(FieldInfo field);
    [NullableContextAttribute("2")]
public static Action`2<TTarget, TMember> Setter(MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.FileHashingExtensions : object {
    [ExtensionAttribute]
public static string HashByModifiedDate(string filename);
    [ExtensionAttribute]
public static string GetModifiedDateFileText(string filename);
    [ExtensionAttribute]
public static string HashByModifiedDate(IEnumerable`1<string> files);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.FileSet : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeepSearch>k__BackingField;
    [XmlAttributeAttribute]
public string Include { get; public set; }
    [NullableAttribute("2")]
[XmlAttributeAttribute]
public string Exclude { get; public set; }
    public bool DeepSearch { get; public set; }
    public static FileSet Deep(string include, string exclude);
    public static FileSet Shallow(string include, string exclude);
    public void AppendInclude(string include);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Exclude();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public bool get_DeepSearch();
    [CompilerGeneratedAttribute]
public void set_DeepSearch(bool value);
    public void AppendExclude(string exclude);
    public IEnumerable`1<string> IncludedFilesFor(string path);
    private IEnumerable`1<string> getAllDistinctFiles(string path, string pattern);
    public IEnumerable`1<string> ExcludedFilesFor(string path);
    public static FileSet ForAssemblyNames(IEnumerable`1<string> assemblyNames);
    public static FileSet ForAssemblyDebugFiles(IEnumerable`1<string> assemblyNames);
    [NullableContextAttribute("2")]
public bool Equals(FileSet other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static FileSet Everything();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.FileSystem : object {
    public static int BufferSize;
    [NullableContextAttribute("2")]
public sealed virtual void CreateDirectory(string path);
    public sealed virtual long FileSizeOf(string path);
    public sealed virtual void Copy(string source, string destination);
    public sealed virtual void Copy(string source, string destination, CopyBehavior behavior);
    public sealed virtual bool IsFile(string path);
    public sealed virtual bool FileExists(string filename);
    public sealed virtual void WriteStreamToFile(string filename, Stream stream);
    public sealed virtual void WriteStringToFile(string filename, string text);
    public sealed virtual void AppendStringToFile(string filename, string text);
    public sealed virtual string ReadStringFromFile(string filename);
    public sealed virtual string GetFileName(string path);
    public sealed virtual void AlterFlatFile(string path, Action`1<List`1<string>> alteration);
    public sealed virtual void DeleteDirectory(string directory);
    public sealed virtual void CleanDirectory(string directory);
    public sealed virtual bool DirectoryExists(string directory);
    public sealed virtual void WriteObjectToFile(string filename, object target);
    public sealed virtual T LoadFromFileOrThrow(string filename);
    public sealed virtual T LoadFromFile(string filename);
    public sealed virtual void LaunchEditor(string filename);
    public sealed virtual void DeleteFile(string filename);
    public sealed virtual void MoveFile(string from, string to);
    public sealed virtual void MoveFiles(string from, string to);
    public sealed virtual void MoveDirectory(string from, string to);
    public sealed virtual IEnumerable`1<string> ChildDirectoriesFor(string directory);
    public sealed virtual IEnumerable`1<string> FindFiles(string directory, FileSet searchSpecification);
    public sealed virtual void ReadTextFile(string path, Action`1<string> callback);
    public sealed virtual string GetFullPath(string path);
    public sealed virtual string GetDirectory(string path);
    private void internalFileCopy(string source, string destination, CopyBehavior behavior);
    private void internalDirectoryCopy(string source, string destination, CopyBehavior behavior);
    private bool destinationIsFile(string destination);
    public static string Combine(String[] paths);
    public static void LaunchBrowser(string filename);
    public static IEnumerable`1<string> GetChildDirectories(string directory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.FileSystemExtensions : object {
    [ExtensionAttribute]
public static void ResetDirectory(IFileSystem fileSystem, string directory);
    [ExtensionAttribute]
public static void CopyToDirectory(IFileSystem fileSystem, string source, string destination);
    [ExtensionAttribute]
public static void WriteToFlatFile(IFileSystem system, string path, Action`1<IFlatFileWriter> configuration);
    [ExtensionAttribute]
public static bool DirectoryExists(IFileSystem fileSystem, String[] pathParts);
    [ExtensionAttribute]
public static void LaunchEditor(IFileSystem fileSystem, String[] pathParts);
    [ExtensionAttribute]
public static bool FileExists(IFileSystem fileSystem, String[] pathParts);
    [ExtensionAttribute]
public static T LoadFromFile(IFileSystem fileSystem, String[] pathParts);
    [ExtensionAttribute]
public static IEnumerable`1<string> ChildDirectoriesFor(IFileSystem fileSystem, String[] pathParts);
    [ExtensionAttribute]
public static IEnumerable`1<string> FileNamesFor(IFileSystem fileSystem, FileSet set, String[] pathParts);
    [ExtensionAttribute]
public static string ReadStringFromFile(IFileSystem fileSystem, String[] pathParts);
    [ExtensionAttribute]
public static void PersistToFile(IFileSystem fileSystem, object target, String[] pathParts);
    [ExtensionAttribute]
public static void DeleteDirectory(IFileSystem fileSystem, String[] pathParts);
    [ExtensionAttribute]
public static void CreateDirectory(IFileSystem fileSystem, String[] pathParts);
    [ExtensionAttribute]
public static string SearchUpForDirectory(IFileSystem fileSystem, string startingPoint, string directoryToFind);
    [ExtensionAttribute]
public static string SearchUpForDirectory(IFileSystem fileSystem, string directoryToFind);
    [ExtensionAttribute]
public static void ForceClean(IFileSystem system, string path);
    private static void cleanDirectory(string directory, bool remove);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.FlatFileWriter : object {
    [CompilerGeneratedAttribute]
private List`1<string> <List>k__BackingField;
    public List`1<string> List { get; }
    public FlatFileWriter(List`1<string> list);
    public sealed virtual void WriteProperty(string name, string value);
    public sealed virtual void WriteLine(string line);
    public sealed virtual void Sort();
    [CompilerGeneratedAttribute]
public List`1<string> get_List();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.GenericEnumerableExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> dependencies, bool throwOnCycle);
    private static void Visit(T item, ISet`1<T> visited, ISet`1<T> visiting, ICollection`1<T> sorted, Func`2<T, IEnumerable`1<T>> dependencies, bool throwOnCycle);
    [ExtensionAttribute]
public static void Fill(IList`1<T> list, T value);
    [ExtensionAttribute]
public static void Fill(IList`1<T> list, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static void RemoveAll(IList`1<T> list, Func`2<T, bool> whereEvaluator);
    [ExtensionAttribute]
public static string Join(String[] values, string separator);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> values, string separator);
    [ExtensionAttribute]
public static IEnumerable`1<T> Each(IEnumerable`1<T> values, Action`2<T, int> eachAction);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static IEnumerable`1<T> Each(IEnumerable`1<T> values, Action`1<T> eachAction);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static IEnumerable Each(IEnumerable values, Action`1<object> eachAction);
    [ExtensionAttribute]
public static TReturn FirstValue(IEnumerable`1<TItem> enumerable, Func`2<TItem, TReturn> func);
    [ExtensionAttribute]
public static IList`1<T> AddMany(IList`1<T> list, T[] items);
    [ExtensionAttribute]
public static IList`1<T> AddRange(IList`1<T> list, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IEnumerable`1<T> UnionWith(IEnumerable`1<T> first, T[] second);
}
[NullableContextAttribute("1")]
public interface Baseline.IFileSystem {
    public abstract virtual bool FileExists(string filename);
    public abstract virtual void DeleteFile(string filename);
    public abstract virtual void MoveFile(string from, string to);
    public abstract virtual void MoveDirectory(string from, string to);
    public abstract virtual bool IsFile(string path);
    public abstract virtual string GetFullPath(string path);
    public abstract virtual long FileSizeOf(string path);
    public abstract virtual void Copy(string source, string destination);
    public abstract virtual void WriteStreamToFile(string filename, Stream stream);
    public abstract virtual void WriteStringToFile(string filename, string text);
    public abstract virtual void AppendStringToFile(string filename, string text);
    public abstract virtual string ReadStringFromFile(string filename);
    public abstract virtual void WriteObjectToFile(string filename, object target);
    public abstract virtual T LoadFromFile(string filename);
    public abstract virtual T LoadFromFileOrThrow(string filename);
    public abstract virtual void CreateDirectory(string directory);
    public abstract virtual void DeleteDirectory(string directory);
    public abstract virtual void CleanDirectory(string directory);
    public abstract virtual bool DirectoryExists(string directory);
    public abstract virtual void LaunchEditor(string filename);
    public abstract virtual IEnumerable`1<string> ChildDirectoriesFor(string directory);
    public abstract virtual IEnumerable`1<string> FindFiles(string directory, FileSet searchSpecification);
    public abstract virtual void ReadTextFile(string path, Action`1<string> reader);
    public abstract virtual void MoveFiles(string from, string to);
    public abstract virtual string GetDirectory(string path);
    public abstract virtual string GetFileName(string path);
    public abstract virtual void AlterFlatFile(string path, Action`1<List`1<string>> alteration);
    public abstract virtual void Copy(string source, string destination, CopyBehavior behavior);
}
[NullableContextAttribute("1")]
public interface Baseline.IFlatFileWriter {
    public abstract virtual void WriteProperty(string name, string value);
    public abstract virtual void WriteLine(string line);
    public abstract virtual void Sort();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Baseline.LightweightCache`2 : object {
    private IDictionary`2<TKey, TValue> _values;
    private Func`2<TValue, TKey> _getKey;
    private Func`2<TKey, TValue> _onMissing;
    unknown Func`2<TKey, TValue> OnMissing {public set; }
    public Func`2<TValue, TKey> GetKey { get; public set; }
    public int Count { get; }
    [NullableAttribute("2")]
public TValue First { get; }
    public TValue Item { get; public set; }
    public LightweightCache`2(Func`2<TKey, TValue> onMissing);
    public LightweightCache`2(IDictionary`2<TKey, TValue> dictionary, Func`2<TKey, TValue> onMissing);
    public LightweightCache`2(IDictionary`2<TKey, TValue> dictionary);
    public void set_OnMissing(Func`2<TKey, TValue> value);
    public Func`2<TValue, TKey> get_GetKey();
    public void set_GetKey(Func`2<TValue, TKey> value);
    public int get_Count();
    [NullableContextAttribute("2")]
public TValue get_First();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    public void FillDefault(TKey key);
    public void Fill(TKey key, TValue value);
    public bool TryRetrieve(TKey key, TValue& value);
    public void Each(Action`1<TValue> action);
    public void Each(Action`2<TKey, TValue> action);
    public bool Has(TKey key);
    public bool Exists(Predicate`1<TValue> predicate);
    public TValue Find(Predicate`1<TValue> predicate);
    public TValue[] GetAll();
    public void Remove(TKey key);
    public void Clear();
    public void WithValue(TKey key, Action`1<TValue> action);
    public void ClearAll();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Baseline.New`1 : object {
    public static Func`1<T> Instance;
    private static New`1();
    private static Func`1<T> Creator();
}
[ExtensionAttribute]
public static class Baseline.NumberExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static int Times(int maxCount, Action`1<int> eachAction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Baseline.Platform : object {
    [CompilerGeneratedAttribute]
private static bool <IsWindows>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsDarwin>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsLinux>k__BackingField;
    public static bool IsWindows { get; }
    public static bool IsDarwin { get; }
    public static bool IsLinux { get; }
    private static Platform();
    [CompilerGeneratedAttribute]
public static bool get_IsWindows();
    [CompilerGeneratedAttribute]
public static bool get_IsDarwin();
    [CompilerGeneratedAttribute]
public static bool get_IsLinux();
    private static int uname(StringBuilder buf);
    private static string GetUname();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.ReaderWriterLockExtensions : object {
    [ExtensionAttribute]
public static void Write(ReaderWriterLockSlim rwLock, Action action);
    [ExtensionAttribute]
public static T Read(ReaderWriterLockSlim rwLock, Func`1<T> func);
    [ExtensionAttribute]
public static void MaybeWrite(ReaderWriterLockSlim theLock, Action action);
    [ExtensionAttribute]
public static T MaybeWrite(ReaderWriterLockSlim theLock, Func`1<T> answer, Func`1<bool> missingTest, Action write);
}
[NullableContextAttribute("1")]
public interface Baseline.Reflection.Accessor {
    public string FieldName { get; }
    public Type PropertyType { get; }
    [NullableAttribute("2")]
public PropertyInfo InnerProperty { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type OwnerType { get; }
    public String[] PropertyNames { get; }
    public abstract virtual string get_FieldName();
    public abstract virtual Type get_PropertyType();
    [NullableContextAttribute("2")]
public abstract virtual PropertyInfo get_InnerProperty();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_OwnerType();
    public abstract virtual void SetValue(object target, object propertyValue);
    public abstract virtual object GetValue(object target);
    public abstract virtual Accessor GetChildAccessor(Expression`1<Func`2<T, object>> expression);
    public abstract virtual String[] get_PropertyNames();
    public abstract virtual Expression`1<Func`2<T, object>> ToExpression();
    public abstract virtual Accessor Prepend(PropertyInfo property);
    public abstract virtual IEnumerable`1<IValueGetter> Getters();
}
[ExtensionAttribute]
public static class Baseline.Reflection.AccessorExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Accessor Prepend(Accessor accessor, Accessor prefixedAccessor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Reflection.AccessorRules : object {
    private Cache`2<Type, Cache`2<Accessor, IList`1<object>>> _rules;
    public void Add(Accessor accessor, object rule);
    public void Add(Expression`1<Func`2<T, object>> expression, object rule);
    [NullableContextAttribute("2")]
public void Add(Expression`1<Func`2<T, object>> expression);
    public IEnumerable`1<T> AllRulesFor(Accessor accessor);
    [NullableContextAttribute("2")]
public T FirstRule(Accessor accessor);
    public IEnumerable`1<TRule> AllRulesFor(Expression`1<Func`2<T, object>> expression);
    [NullableContextAttribute("2")]
public TRule FirstRule(Expression`1<Func`2<T, object>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Reflection.ArrayIndexer : object {
    private IndexerValueGetter _getter;
    public string FieldName { get; }
    public Type PropertyType { get; }
    [NullableAttribute("2")]
public PropertyInfo InnerProperty { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type OwnerType { get; }
    public String[] PropertyNames { get; }
    public ArrayIndexer(IndexerValueGetter getter);
    public sealed virtual string get_FieldName();
    public sealed virtual Type get_PropertyType();
    [NullableContextAttribute("2")]
public sealed virtual PropertyInfo get_InnerProperty();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual string get_Name();
    public sealed virtual Type get_OwnerType();
    public sealed virtual void SetValue(object target, object propertyValue);
    public sealed virtual object GetValue(object target);
    public sealed virtual Accessor GetChildAccessor(Expression`1<Func`2<T, object>> expression);
    public sealed virtual String[] get_PropertyNames();
    public sealed virtual Expression`1<Func`2<T, object>> ToExpression();
    public sealed virtual Accessor Prepend(PropertyInfo property);
    [IteratorStateMachineAttribute("Baseline.Reflection.ArrayIndexer/<Getters>d__21")]
public sealed virtual IEnumerable`1<IValueGetter> Getters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public abstract class Baseline.Reflection.ExpressionVisitorBase : object {
    public virtual Expression Visit(Expression exp);
    protected virtual MemberBinding VisitBinding(MemberBinding binding);
    protected virtual ElementInit VisitElementInitializer(ElementInit initializer);
    protected virtual Expression VisitUnary(UnaryExpression u);
    protected virtual Expression VisitBinary(BinaryExpression b);
    protected virtual Expression VisitTypeIs(TypeBinaryExpression b);
    protected virtual Expression VisitConstant(ConstantExpression c);
    protected virtual Expression VisitConditional(ConditionalExpression c);
    protected virtual Expression VisitParameter(ParameterExpression p);
    protected virtual Expression VisitMemberAccess(MemberExpression m);
    protected virtual Expression VisitMethodCall(MethodCallExpression m);
    protected virtual ReadOnlyCollection`1<Expression> VisitList(ReadOnlyCollection`1<Expression> original);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual IEnumerable`1<MemberBinding> VisitBindingList(ReadOnlyCollection`1<MemberBinding> original);
    protected virtual IEnumerable`1<ElementInit> VisitElementInitializerList(ReadOnlyCollection`1<ElementInit> original);
    protected virtual Expression VisitLambda(LambdaExpression lambda);
    protected virtual NewExpression VisitNew(NewExpression nex);
    protected virtual Expression VisitMemberInit(MemberInitExpression init);
    protected virtual Expression VisitListInit(ListInitExpression init);
    protected virtual Expression VisitNewArray(NewArrayExpression na);
    protected virtual Expression VisitInvocation(InvocationExpression iv);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Reflection.FindMethodVisitor : ExpressionVisitorBase {
    [NullableAttribute("2")]
private MethodInfo _method;
    public MethodInfo Method { get; }
    public FindMethodVisitor(Expression expression);
    public MethodInfo get_Method();
    protected virtual Expression VisitMethodCall(MethodCallExpression m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Reflection.IndexerValueGetter : object {
    private Type _arrayType;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public string Name { get; }
    public int Index { get; private set; }
    public Type DeclaringType { get; }
    public Type ValueType { get; }
    public IndexerValueGetter(Type arrayType, int index);
    public sealed virtual object GetValue(object target);
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    public sealed virtual Type get_DeclaringType();
    public sealed virtual Type get_ValueType();
    public sealed virtual Expression ChainExpression(Expression body);
    public sealed virtual void SetValue(object target, object propertyValue);
    protected bool Equals(IndexerValueGetter other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
public interface Baseline.Reflection.IValueGetter {
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ValueType { get; }
    public abstract virtual object GetValue(object target);
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ValueType();
    public abstract virtual Expression ChainExpression(Expression body);
    public abstract virtual void SetValue(object target, object propertyValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Reflection.MethodValueGetter : object {
    private MethodInfo _methodInfo;
    private Object[] _arguments;
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ValueType { get; }
    public Type ReturnType { get; }
    public MethodValueGetter(MethodInfo methodInfo, Object[] arguments);
    public sealed virtual object GetValue(object target);
    public sealed virtual string get_Name();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual Type get_ValueType();
    public Type get_ReturnType();
    public sealed virtual Expression ChainExpression(Expression body);
    public sealed virtual void SetValue(object target, object propertyValue);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public bool Equals(MethodValueGetter other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Reflection.PropertyChain : object {
    private IValueGetter[] _chain;
    private IValueGetter[] _valueGetters;
    public IValueGetter[] ValueGetters { get; }
    public Type OwnerType { get; }
    public string FieldName { get; }
    public Type PropertyType { get; }
    [NullableAttribute("2")]
public PropertyInfo InnerProperty { get; }
    public Type DeclaringType { get; }
    public String[] PropertyNames { get; }
    public string Name { get; }
    public PropertyChain(IValueGetter[] valueGetters);
    public IValueGetter[] get_ValueGetters();
    public sealed virtual void SetValue(object target, object propertyValue);
    [NullableContextAttribute("2")]
public sealed virtual object GetValue(object target);
    public sealed virtual Type get_OwnerType();
    public sealed virtual string get_FieldName();
    public sealed virtual Type get_PropertyType();
    [NullableContextAttribute("2")]
public sealed virtual PropertyInfo get_InnerProperty();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual Accessor GetChildAccessor(Expression`1<Func`2<T, object>> expression);
    public sealed virtual String[] get_PropertyNames();
    public sealed virtual Expression`1<Func`2<T, object>> ToExpression();
    public sealed virtual Accessor Prepend(PropertyInfo property);
    public sealed virtual IEnumerable`1<IValueGetter> Getters();
    public sealed virtual string get_Name();
    protected virtual void setValueOnInnerObject(object target, object propertyValue);
    [NullableContextAttribute("2")]
protected object findInnerMostTarget(object target);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public bool Equals(PropertyChain other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Reflection.PropertyValueGetter : object {
    private PropertyInfo _propertyInfo;
    public PropertyInfo PropertyInfo { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ValueType { get; }
    public PropertyValueGetter(PropertyInfo propertyInfo);
    public PropertyInfo get_PropertyInfo();
    public sealed virtual object GetValue(object target);
    public sealed virtual string get_Name();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual Type get_ValueType();
    public sealed virtual Expression ChainExpression(Expression body);
    public sealed virtual void SetValue(object target, object propertyValue);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public bool Equals(PropertyValueGetter other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.Reflection.ReflectionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static U ValueOrDefault(T root, Expression`1<Func`2<T, U>> expression);
    [ExtensionAttribute]
public static T GetAttribute(MemberInfo provider);
    [ExtensionAttribute]
public static T GetAttribute(Assembly provider);
    [ExtensionAttribute]
public static T GetAttribute(Module provider);
    [ExtensionAttribute]
public static T GetAttribute(ParameterInfo provider);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllAttributes(Assembly provider);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllAttributes(MemberInfo provider);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllAttributes(Module provider);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllAttributes(ParameterInfo provider);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllAttributes(Accessor accessor);
    [ExtensionAttribute]
public static bool HasAttribute(Assembly provider);
    [ExtensionAttribute]
public static bool HasAttribute(MemberInfo provider);
    [ExtensionAttribute]
public static bool HasAttribute(Module provider);
    [ExtensionAttribute]
public static bool HasAttribute(ParameterInfo provider);
    [ExtensionAttribute]
public static void ForAttribute(Assembly provider, Action`1<T> action);
    [ExtensionAttribute]
public static void ForAttribute(MemberInfo provider, Action`1<T> action);
    [ExtensionAttribute]
public static void ForAttribute(Module provider, Action`1<T> action);
    [ExtensionAttribute]
public static void ForAttribute(ParameterInfo provider, Action`1<T> action);
    [ExtensionAttribute]
public static void ForAttribute(Assembly provider, Action`1<T> action, Action elseDo);
    [ExtensionAttribute]
public static void ForAttribute(MemberInfo provider, Action`1<T> action, Action elseDo);
    [ExtensionAttribute]
public static void ForAttribute(Module provider, Action`1<T> action, Action elseDo);
    [ExtensionAttribute]
public static void ForAttribute(ParameterInfo provider, Action`1<T> action, Action elseDo);
    [ExtensionAttribute]
public static void ForAttribute(Accessor accessor, Action`1<T> action);
    [ExtensionAttribute]
public static T GetAttribute(Accessor provider);
    [ExtensionAttribute]
public static bool HasAttribute(Accessor provider);
    [ExtensionAttribute]
public static Accessor ToAccessor(Expression`1<Func`2<T, object>> expression);
    [ExtensionAttribute]
public static string GetName(Expression`1<Func`2<T, object>> expression);
    [ExtensionAttribute]
public static void IfPropertyTypeIs(Accessor accessor, Action action);
    [ExtensionAttribute]
public static bool IsInteger(Accessor accessor);
    [ExtensionAttribute]
public static bool HasDefaultConstructor(Type t);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnonymousType(object instance);
    [ExtensionAttribute]
public static string GetPrettyName(Type t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.Reflection.ReflectionHelper : object {
    public static bool MeetsSpecialGenericConstraints(Type genericArgType, Type proposedSpecificType);
    public static PropertyInfo GetProperty(Expression`1<Func`2<TModel, object>> expression);
    public static PropertyInfo GetProperty(Expression`1<Func`2<TModel, T>> expression);
    public static PropertyInfo GetProperty(LambdaExpression expression);
    private static MemberExpression getMemberExpression(Expression`1<Func`2<TModel, T>> expression);
    public static Accessor GetAccessor(LambdaExpression expression);
    [ExtensionAttribute]
public static MemberExpression GetMemberExpression(LambdaExpression expression, bool enforceMemberExpression);
    public static bool IsMemberExpression(Expression`1<Func`2<T, object>> expression);
    [NullableContextAttribute("2")]
public static bool IsMemberExpression(Expression`1<Func`2<T, U>> expression);
    public static Accessor GetAccessor(Expression`1<Func`2<TModel, object>> expression);
    public static Accessor GetAccessor(Expression memberExpression);
    private static void buildValueGetters(Expression expression, IList`1<IValueGetter> list);
    [NullableContextAttribute("2")]
private static bool TryEvaluateExpression(Expression operation, Object& value);
    public static Accessor GetAccessor(Expression`1<Func`2<TModel, T>> expression);
    public static MethodInfo GetMethod(Expression`1<Func`2<T, object>> expression);
    public static MethodInfo GetMethod(Expression`1<Func`1<object>> expression);
    public static MethodInfo GetMethod(Expression expression);
    public static MethodInfo GetMethod(Expression`1<TDelegate> expression);
    public static MethodInfo GetMethod(Expression`1<Func`2<T, U>> expression);
    [NullableContextAttribute("2")]
public static MethodInfo GetMethod(Expression`1<Func`3<T, U, V>> expression);
    public static MethodInfo GetMethod(Expression`1<Action`1<T>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Reflection.SingleMethod : object {
    private MethodValueGetter _getter;
    [NullableAttribute("2")]
private Type _ownerType;
    public string FieldName { get; }
    public Type PropertyType { get; }
    public Type DeclaringType { get; }
    [NullableAttribute("2")]
public PropertyInfo InnerProperty { get; }
    public String[] PropertyNames { get; }
    public string Name { get; }
    public Type OwnerType { get; }
    public SingleMethod(MethodValueGetter getter);
    public SingleMethod(MethodValueGetter getter, Type ownerType);
    public sealed virtual string get_FieldName();
    public sealed virtual Type get_PropertyType();
    public sealed virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public sealed virtual PropertyInfo get_InnerProperty();
    public sealed virtual Accessor GetChildAccessor(Expression`1<Func`2<T, object>> expression);
    public sealed virtual String[] get_PropertyNames();
    public sealed virtual Expression`1<Func`2<T, object>> ToExpression();
    public sealed virtual Accessor Prepend(PropertyInfo property);
    [IteratorStateMachineAttribute("Baseline.Reflection.SingleMethod/<Getters>d__17")]
public sealed virtual IEnumerable`1<IValueGetter> Getters();
    public sealed virtual string get_Name();
    public virtual void SetValue(object target, object propertyValue);
    public sealed virtual object GetValue(object target);
    public sealed virtual Type get_OwnerType();
    [NullableContextAttribute("2")]
public bool Equals(SingleMethod other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.Reflection.SingleProperty : object {
    private PropertyInfo _property;
    [NullableAttribute("2")]
private Type _ownerType;
    public string FieldName { get; }
    public Type PropertyType { get; }
    public Type DeclaringType { get; }
    public PropertyInfo InnerProperty { get; }
    public String[] PropertyNames { get; }
    public string Name { get; }
    public Type OwnerType { get; }
    public SingleProperty(PropertyInfo property);
    public SingleProperty(PropertyInfo property, Type ownerType);
    public sealed virtual string get_FieldName();
    public sealed virtual Type get_PropertyType();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual PropertyInfo get_InnerProperty();
    public sealed virtual Accessor GetChildAccessor(Expression`1<Func`2<T, object>> expression);
    public sealed virtual String[] get_PropertyNames();
    public sealed virtual Expression`1<Func`2<T, object>> ToExpression();
    public sealed virtual Accessor Prepend(PropertyInfo property);
    [IteratorStateMachineAttribute("Baseline.Reflection.SingleProperty/<Getters>d__17")]
public sealed virtual IEnumerable`1<IValueGetter> Getters();
    public sealed virtual string get_Name();
    public virtual void SetValue(object target, object propertyValue);
    public sealed virtual object GetValue(object target);
    public sealed virtual Type get_OwnerType();
    public static SingleProperty Build(Expression`1<Func`2<T, object>> expression);
    public static SingleProperty Build(string propertyName);
    [NullableContextAttribute("2")]
public bool Equals(SingleProperty other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Baseline.SimpleTimeZoneContext : object {
    private TimeZoneInfo _timeZone;
    public SimpleTimeZoneContext(TimeZoneInfo timeZone);
    public sealed virtual TimeZoneInfo GetTimeZone();
}
[ExtensionAttribute]
public static class Baseline.StackFrameExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToDescription(StackFrame frame);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.StreamExtensions : object {
    [ExtensionAttribute]
public static string ReadAllText(Stream stream);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream stream);
    [ExtensionAttribute]
public static Task`1<string> ReadAllTextAsync(Stream stream);
    [AsyncStateMachineAttribute("Baseline.StreamExtensions/<ReadAllBytesAsync>d__3")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadAllBytesAsync(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.StringExtensions : object {
    [ExtensionAttribute]
public static string CombineToPath(string path, string root);
    [ExtensionAttribute]
public static void IfNotNull(string target, Action`1<string> continuation);
    [ExtensionAttribute]
public static string ToFullPath(string path);
    [ExtensionAttribute]
public static string ParentDirectory(string path);
    [ExtensionAttribute]
public static string AppendPath(string path, String[] parts);
    [ExtensionAttribute]
public static string PathRelativeTo(string path, string root);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmpty(string stringValue);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNotEmpty(string stringValue);
    [ExtensionAttribute]
public static void IsNotEmpty(string stringValue, Action`1<string> action);
    [ExtensionAttribute]
public static bool ToBool(string stringValue);
    [ExtensionAttribute]
public static string ToFormat(string stringFormat, Object[] args);
    [ExtensionAttribute]
public static bool EqualsIgnoreCase(string thisString, string otherString);
    [ExtensionAttribute]
public static string Capitalize(string stringValue);
    [ExtensionAttribute]
public static string ConvertCRLFToBreaks(string plainText);
    [ExtensionAttribute]
public static DateTime ToDateTime(string dateTimeValue);
    [ExtensionAttribute]
public static string ToGmtFormattedDate(DateTime date);
    [ExtensionAttribute]
public static String[] ToDelimitedArray(string content);
    [ExtensionAttribute]
public static String[] ToDelimitedArray(string content, char delimiter);
    [ExtensionAttribute]
public static bool IsValidNumber(string number);
    [ExtensionAttribute]
public static bool IsValidNumber(string number, CultureInfo culture);
    [ExtensionAttribute]
public static IList`1<string> getPathParts(string path);
    [ExtensionAttribute]
public static string DirectoryPath(string path);
    [IteratorStateMachineAttribute("Baseline.StringExtensions/<ReadLines>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(string text);
    [ExtensionAttribute]
public static void ReadLines(string text, Action`1<string> callback);
    [ExtensionAttribute]
public static string ToHash(string text);
    [ExtensionAttribute]
public static string SplitCamelCase(string str);
    [ExtensionAttribute]
public static string SplitPascalCase(string str);
    [ExtensionAttribute]
public static string ToCamelCase(string s);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TEnum ToEnum(string text);
    [ExtensionAttribute]
public static string FileEscape(string file);
    [ExtensionAttribute]
public static string ReplaceFirst(string text, string search, string replace);
    [ExtensionAttribute]
public static bool Contains(string source, string value, StringComparison comparison);
    [ExtensionAttribute]
public static bool ContainsIgnoreCase(string source, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.TypeExtensions : object {
    private static IList`1<Type> _integerTypes;
    private static TypeExtensions();
    [ExtensionAttribute]
public static T As(object target);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullableOfT(Type theType);
    [ExtensionAttribute]
public static bool IsNullableOf(Type theType, Type otherType);
    [ExtensionAttribute]
public static bool IsTypeOrNullableOf(Type theType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool CanBeCastTo(Type type);
    [ExtensionAttribute]
public static bool CanBeCastTo(Type type, Type destinationType);
    [ExtensionAttribute]
public static bool IsInNamespace(Type type, string nameSpace);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOpenGeneric(Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGenericEnumerable(Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConcreteTypeOf(Type pluggedType);
    [ExtensionAttribute]
public static bool ImplementsInterfaceTemplate(Type pluggedType, Type templateType);
    [ExtensionAttribute]
public static bool IsConcreteWithDefaultCtor(Type type);
    [ExtensionAttribute]
public static Type FindInterfaceThatCloses(Type type, Type openType);
    [ExtensionAttribute]
public static Type FindParameterTypeTo(Type type, Type openType);
    [ExtensionAttribute]
public static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool Closes(Type type, Type openType);
    [ExtensionAttribute]
public static Type GetInnerTypeFromNullable(Type nullableType);
    [ExtensionAttribute]
public static string GetName(Type type);
    [ExtensionAttribute]
public static string GetFullName(Type type);
    [ExtensionAttribute]
public static bool IsString(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsSimple(Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConcrete(Type type);
    [ExtensionAttribute]
public static bool IsNotConcrete(Type type);
    [ExtensionAttribute]
public static bool IsDateTime(Type typeToCheck);
    [ExtensionAttribute]
public static bool IsBoolean(Type typeToCheck);
    [ExtensionAttribute]
public static string PrettyPrint(Type type);
    [ExtensionAttribute]
public static string PrettyPrint(Type type, Func`2<Type, string> selector);
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    [ExtensionAttribute]
public static bool IsIntegerBased(Type type);
    [ExtensionAttribute]
public static bool IsFloatingPoint(Type type);
    [ExtensionAttribute]
public static T CloseAndBuildAs(Type openType, Type[] parameterTypes);
    [ExtensionAttribute]
public static T CloseAndBuildAs(Type openType, object ctorArgument, Type[] parameterTypes);
    [ExtensionAttribute]
public static T CloseAndBuildAs(Type openType, object ctorArgument1, object ctorArgument2, Type[] parameterTypes);
    [ExtensionAttribute]
public static bool PropertyMatches(PropertyInfo prop1, PropertyInfo prop2);
    [ExtensionAttribute]
public static T Create(Type type);
    [ExtensionAttribute]
public static object Create(Type type);
    [ExtensionAttribute]
public static Type DeriveElementType(Type type);
    [ExtensionAttribute]
public static Type IsAnEnumerationOf(Type type);
    [ExtensionAttribute]
public static void ForAttribute(Type type, Action`1<T> action);
    [ExtensionAttribute]
public static void ForAttribute(Type type, Action`1<T> action, Action elseDo);
    [ExtensionAttribute]
public static bool HasAttribute(Type type);
    [ExtensionAttribute]
public static T GetAttribute(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Baseline.UrlExtensions : object {
    [ExtensionAttribute]
public static string AppendUrl(string url, string part);
    [ExtensionAttribute]
public static string ChildUrl(string url);
    [ExtensionAttribute]
public static string ParentUrl(string url);
    [ExtensionAttribute]
public static string MoveUp(string relativeUrl);
}
[ExtensionAttribute]
public static class ImTools.ArrayTools : object {
    public static T[] Empty();
    [ExtensionAttribute]
public static T[] One(T one);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] source);
    [ExtensionAttribute]
public static T[] EmptyIfNull(T[] source);
    [ExtensionAttribute]
public static T[] ToArrayOrSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IList`1<T> ToListOrSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T[] Copy(T[] source);
    [ExtensionAttribute]
public static T[] CopyNonEmpty(T[] source);
    [ExtensionAttribute]
public static T[] Append(T[] source, T[] added);
    [ExtensionAttribute]
public static T[] Append(IEnumerable`1<T> source, IEnumerable`1<T> other);
    [ExtensionAttribute]
public static T[] AppendOrUpdate(T[] source, T value, int index);
    [ExtensionAttribute]
public static T[] UpdateNonEmpty(T[] source, T value, int index);
    [ExtensionAttribute]
public static T[] AppendNonEmpty(T[] source, T[] added);
    [ExtensionAttribute]
public static T[] Append(T[] source, T value);
    [ExtensionAttribute]
public static T[] AppendToNonEmpty(T[] source, T value);
    [ExtensionAttribute]
public static T[] PrependToNonEmpty(T[] source, T value);
    [ExtensionAttribute]
public static int IndexOf(T[] source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(T[] source, S state, Func`3<S, T, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(T[] source, T value);
    [ExtensionAttribute]
public static int IndexOfReference(T[] source, T reference);
    [ExtensionAttribute]
public static T[] RemoveAt(T[] source, int index);
    [ExtensionAttribute]
public static T[] Remove(T[] source, T value);
    [ExtensionAttribute]
public static T FindFirst(T[] source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T FindFirst(T[] source, S state, Func`3<S, T, bool> predicate);
    [ExtensionAttribute]
public static T FindFirst(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T SingleOrDefaultIfMany(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static void ForEach(T[] source, Action`1<T> action);
    public static T[] AppendTo(T[] source, int sourcePos, int count, T[] results);
    private static R[] AppendTo(T[] source, int sourcePos, int count, Func`2<T, R> map, R[] results);
    private static R[] AppendTo(T[] source, S state, int sourcePos, int count, Func`3<S, T, R> map, R[] results);
    private static R[] AppendTo(T[] source, A a, B b, int sourcePos, int count, Func`4<A, B, T, R> map, R[] results);
    [ExtensionAttribute]
public static T[] Match(T[] source, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static T[] Match(T[] source, S state, Func`3<S, T, bool> condition);
    [ExtensionAttribute]
public static T[] Match(T[] source, A a, B b, Func`4<A, B, T, bool> condition);
    [ExtensionAttribute]
public static R[] Match(T[] source, Func`2<T, bool> condition, Func`2<T, R> map);
    [ExtensionAttribute]
public static R[] Match(T[] source, S state, Func`3<S, T, bool> condition, Func`3<S, T, R> map);
    [ExtensionAttribute]
public static R[] Match(T[] source, A a, B b, Func`4<A, B, T, bool> condition, Func`4<A, B, T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, Func`2<T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, S state, Func`3<S, T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, A a, B b, Func`4<A, B, T, R> map);
    [ExtensionAttribute]
public static IEnumerable`1<R> Map(IEnumerable`1<T> source, Func`2<T, R> map);
    [ExtensionAttribute]
public static IEnumerable`1<T> Match(IEnumerable`1<T> source, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IEnumerable`1<R> Match(IEnumerable`1<T> source, Func`2<T, bool> condition, Func`2<T, R> map);
}
[ExtensionAttribute]
public static class ImTools.Fun : object {
    public static bool Always(T _);
    public static T Id(T x);
    [ExtensionAttribute]
public static R To(T x, Func`2<T, R> map);
    [ExtensionAttribute]
public static R To(T x, S state, Func`3<T, S, R> map);
    [ExtensionAttribute]
public static R To(object x);
    [ExtensionAttribute]
public static T Do(T x, Action`1<T> effect);
    [ExtensionAttribute]
public static T Do(T x, S state, Action`2<T, S> effect);
    [ExtensionAttribute]
public static R ToFunc(R result, T ignoredArg);
    public static void Swap(T& a, T& b);
}
public static class ImTools.GrowingList : object {
    public static int DefaultInitialCapacity;
    public static T& PushSlot(T[]& items, int count);
    public static void Push(T[]& items, int count, T item);
    internal static void Expand(T[]& items);
    public static T[] ResizeToArray(T[] items, int count);
    public static string ToString(T[] items, int count);
}
public class ImTools.GrowingList`1 : ValueType {
    public static int DefaultInitialCapacity;
    public T[] Items;
    public int Count;
    public GrowingList`1(T[] items, int count);
    public T& PushSlot();
    public void Push(T item);
    public void Pop();
    public T[] ResizeToArray();
    public T PopItem();
    public virtual string ToString();
}
public static class ImTools.Hasher : object {
    public static int Combine(T1 a, T2 b);
    public static int Combine(int h1, int h2);
}
[ExtensionAttribute]
public static class ImTools.ImHashMap : object {
    private static object _enumerationB3Tombstone;
    private static ImHashMap();
    [ExtensionAttribute]
public static string ToMermaidString(ImHashMap`2<K, V> map);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3, Entry& e4);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3, Entry& e4, Entry& e5);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3, Entry& e4, Entry& e5, Entry& e6);
    [ExtensionAttribute]
public static Enumerable`1<V> Enumerate(ImHashMap`2<int, V> map);
    [ExtensionAttribute]
public static Enumerable`2<K, V> Enumerate(ImHashMap`2<K, V> map);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2<K, V> map, S state, Action`3<ImHashMapEntry`2<K, V>, int, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2<int, V> map, S state, Action`3<VEntry`1<V>, int, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static void ForEach(ImHashMap`2<int, V> map, Action`2<VEntry`1<V>, int> handler, MapParentStack parents);
    [ExtensionAttribute]
public static void ForEach(ImHashMap`2<K, V> map, Action`2<ImHashMapEntry`2<K, V>, int> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S Fold(ImHashMap`2<int, V> map, S state, Func`4<VEntry`1<V>, int, S, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S Fold(ImHashMap`2<K, V> map, S state, Func`4<ImHashMapEntry`2<K, V>, int, S, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S[] ToArray(ImHashMap`2<int, V> map, Func`2<VEntry`1<V>, S> selector);
    [ExtensionAttribute]
public static S[] ToArray(ImHashMap`2<K, V> map, Func`2<ImHashMapEntry`2<K, V>, S> selector);
    [ExtensionAttribute]
public static VEntry`1[] ToArray(ImHashMap`2<int, V> map);
    [ExtensionAttribute]
public static ImHashMapEntry`2[] ToArray(ImHashMap`2<K, V> map);
    [ExtensionAttribute]
public static Dictionary`2<K, V> ToDictionary(ImHashMap`2<K, V> map);
    [ExtensionAttribute]
public static Dictionary`2<int, V> ToDictionary(ImHashMap`2<int, V> map);
    [ExtensionAttribute]
public static bool Contains(ImHashMap`2<int, V> map, int key);
    [ExtensionAttribute]
public static bool Contains(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static bool Contains(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<int, V> GetSurePresent(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetSurePresent(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetSurePresentByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<int, V> GetEntryOrDefault(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefault(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefault(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<int, V> map, int hash, V defaultValue);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, int hash, K key, V defaultValue);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, K key, V defaultValue);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2<int, V> map, int hash, V& value);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2<K, V> map, int hash, K key, V& value);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2<K, V> map, K key, V& value);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key, V& value);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2<K, V> map, K key, V& value);
    public static ImHashMapEntry`2<int, V> Entry(int key, V value);
    public static ImHashMapEntry`2<int, V> EntryWithDefaultValue(int key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<int, V> WithDefaultValue(ImHashMapEntry`2<int, V> e);
    public static ImHashMapEntry`2<K, V> Entry(int hash, K key, V value);
    public static ImHashMapEntry`2<K, V> EntryWithHash(K key, V value);
    public static ImHashMapEntry`2<K, V> EntryWithDefaultValue(int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> WithDefaultValue(ImHashMapEntry`2<K, V> e);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> SetValue(ImHashMapEntry`2<K, V> e, V value);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3);
    public static ImHashMap`2<K, V> BuildUnchecked(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4, ImHashMapEntry`2<K, V> e5);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4, ImHashMapEntry`2<K, V> e5, ImHashMapEntry`2<K, V> e6);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4, ImHashMapEntry`2<K, V> e5, ImHashMapEntry`2<K, V> e6, ImHashMapEntry`2<K, V> e7, ImHashMapEntry`2<K, V> e8, ImHashMapEntry`2<K, V> e9);
    public static ImHashMapEntry`2<K, V> Entry(HKV`2& item);
    public static ImHashMap`2<K, V> BuildUnchecked(E items);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrGetEntry(ImHashMap`2<int, V> map, ImHashMapEntry`2<int, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrGetEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrGetEntryByReferenceEquals(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateEntryByReferenceEquals(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrUpdate(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddSureNotPresent(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateByReferenceEquals(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddSureNotPresentEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddSureNotPresent(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddSureNotPresent(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrUpdate(ImHashMap`2<int, V> map, int hash, V value, Update`2<int, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, int hash, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrKeep(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeepEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeepEntryByReferenceEquals(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeep(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeep(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> Update(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> UpdateToDefault(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> UpdateToDefault(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> UpdateToDefault(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, int hash, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> Remove(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Remove(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Remove(ImHashMap`2<K, V> map, K key);
}
public class ImTools.ImHashMap`2 : object {
    public static ImHashMap`2<K, V> Empty;
    public bool IsEmpty { get; }
    internal bool MayTurnToBranch2 { get; }
    private static ImHashMap`2();
    public virtual string ToString();
    internal virtual StringBuilder ToMermaidNodeId(StringBuilder s);
    internal virtual StringBuilder ToMermaidNodeItem(StringBuilder s);
    internal virtual StringBuilder ToMermaidString(StringBuilder s);
    public bool get_IsEmpty();
    public virtual int Count();
    internal virtual bool get_MayTurnToBranch2();
    internal virtual Entry<K, V> GetMinHashEntryOrDefault();
    internal virtual Entry<K, V> GetMaxHashEntryOrDefault();
    internal virtual Entry<K, V> GetEntryOrNull(int hash);
    internal virtual Entry<K, V> GetSurePresentEntry(int hash);
    internal virtual ImHashMap`2<K, V> AddOrGetEntry(int hash, Entry<K, V> entry);
    internal virtual ImHashMap`2<K, V> AddSureNotPresentEntry(Entry<K, V> entry);
    internal virtual ImHashMap`2<K, V> ReplaceEntry(Entry<K, V> oldEntry, Entry<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> RemoveEntry(Entry<K, V> entry);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntry(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntryByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
}
public abstract class ImTools.ImHashMapEntry`2 : Entry<K, V> {
    public V Value;
    protected ImHashMapEntry`2(int hash);
    protected ImHashMapEntry`2(int hash, V value);
    public virtual string ToString();
    public sealed virtual int Count();
    internal virtual int ForEach(S state, int startIndex, Action`3<ImHashMapEntry`2<K, V>, int, S> handler);
}
[ExtensionAttribute]
public static class ImTools.ImList : object {
    [ExtensionAttribute]
public static void Deconstruct(ImList`1<T> list, T& head, ImList`1& tail, Boolean& isEmpty);
    public static ImList`1<T> List(T[] items);
    [ExtensionAttribute]
public static ImList`1<T> ToImList(IList`1<T> source);
    [ExtensionAttribute]
public static ImList`1<T> ToImList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImList`1<T> List(T head);
    [ExtensionAttribute]
public static ImList`1<T> List(T head, ImList`1<T> tail);
    [ExtensionAttribute]
public static void ForEach(ImList`1<T> list, Action`1<T> effect);
    [ExtensionAttribute]
public static S Fold(ImList`1<T> list, S state, Func`3<T, S, S> handler);
    [ExtensionAttribute]
public static S Fold(ImList`1<T> list, S state, Func`4<T, int, S, S> handler);
    [ExtensionAttribute]
public static ImList`1<T> Reverse(ImList`1<T> list);
    [ExtensionAttribute]
public static ImList`1<R> Map(ImList`1<T> list, Func`2<T, R> map);
    [ExtensionAttribute]
public static ImList`1<R> Map(ImList`1<T> list, Func`3<T, int, R> map);
    [ExtensionAttribute]
public static T[] ToArray(ImList`1<T> source);
}
public class ImTools.ImList`1 : object {
    public static ImList`1<T> Empty;
    public T Head;
    public ImList`1<T> Tail;
    public bool IsEmpty { get; }
    private ImList`1(T head, ImList`1<T> tail);
    private static ImList`1();
    public bool get_IsEmpty();
    public ImList`1<T> Push(T head);
    [IteratorStateMachineAttribute("ImTools.ImList`1/<Enumerate>d__6")]
public IEnumerable`1<T> Enumerate();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class ImTools.ImZipper : object {
    public static ImZipper`1<T> Zip(T[] items);
    [ExtensionAttribute]
public static T[] ToArray(ImZipper`1<T> z);
    [ExtensionAttribute]
public static ImZipper`1<T> ShiftTo(ImZipper`1<T> z, int i);
    [ExtensionAttribute]
public static ImZipper`1<T> Update(ImZipper`1<T> z, Func`2<T, T> update);
    [ExtensionAttribute]
public static ImZipper`1<T> UpdateAt(ImZipper`1<T> z, int i, Func`2<T, T> update);
    [ExtensionAttribute]
public static ImZipper`1<T> RemoveAt(ImZipper`1<T> z, int i);
    [ExtensionAttribute]
public static S Fold(ImZipper`1<T> z, S state, Func`3<T, S, S> handler);
    [ExtensionAttribute]
public static S Fold(ImZipper`1<T> z, S state, Func`4<T, int, S, S> handler);
    [ExtensionAttribute]
public static void ForEach(ImZipper`1<T> z, Action`1<T> effect);
}
public class ImTools.ImZipper`1 : object {
    public static ImZipper`1<T> Empty;
    public int Index;
    public int Count;
    public ImList`1<T> Left;
    public ImList`1<T> Right;
    public T Focus;
    public bool IsEmpty { get; }
    private ImZipper`1(ImList`1<T> left, T focus, int index, ImList`1<T> right, int count);
    private static ImZipper`1();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ImZipper`1<T> Append(T focus);
    public ImZipper`1<T> PushLeft(T focus);
    public ImZipper`1<T> Insert(T focus);
    public ImZipper`1<T> PushRight(T focus);
    public ImZipper`1<T> PopLeft();
    public ImZipper`1<T> PopRight();
    public ImZipper`1<T> ShiftLeft();
    public ImZipper`1<T> ShiftRight();
    public ImZipper`1<T> WithFocus(T focus);
    public ImZipper`1<R> Map(Func`2<T, R> map);
    public ImZipper`1<R> Map(Func`3<T, int, R> map);
}
public interface ImTools.IPrintable {
    public abstract virtual StringBuilder Print(StringBuilder s, Func`3<StringBuilder, object, StringBuilder> printer);
}
[ExtensionAttribute]
public static class ImTools.KeyValuePair : object {
    [ExtensionAttribute]
public static KeyValuePair`2<K, V> Pair(K key, V value);
}
[ExtensionAttribute]
public static class ImTools.KV : object {
    public static KV`2<K, V> Of(K key, V value);
    [ExtensionAttribute]
public static KV`2<K, V> WithValue(KV`2<K, V> kv, V value);
}
public class ImTools.KV`2 : object {
    public K Key;
    public V Value;
    public KV`2(K key, V value);
    public sealed virtual StringBuilder Print(StringBuilder s, Func`3<StringBuilder, object, StringBuilder> printer);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ImTools.KVEntry`2 : ImHashMapEntry`2<K, V> {
    internal K _key;
    public K Key { get; }
    public KVEntry`2(int hash, K key);
    public KVEntry`2(int hash, K key, V value);
    public virtual K get_Key();
    public virtual string ToString();
    internal virtual StringBuilder ToMermaidNodeItem(StringBuilder s);
    internal virtual ImHashMapEntry`2<K, V> GetOrNullWithTheSameHash(K key);
    internal virtual ImHashMapEntry`2<K, V> GetOrNullWithTheSameHashByReferenceEquals(K key);
    internal virtual V GetValueOrDefaultWithTheSameHashByReferenceEquals(K key);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<K, V> newEntry, Update`2<K, V> update);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<K, V> newEntry, Update`2<K, V> update);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntry(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntryByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> UpdatedOrNullWithTheSameHash(ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> UpdatedOrNullWithTheSameHash(K key, V value, Update`2<K, V> update);
    internal virtual Entry<K, V> RemovedOrNullWithTheSameHash(K key);
    public virtual Entry<K, V> AppendOrUpdateInPlaceOrKeep(S state, ImHashMapEntry`2<K, V> newEntry, UpdaterInPlaceOrKeeper`1<K, V, S> updateOrKeep);
    public virtual Entry<K, V> AppendOrUpdateInPlaceOrKeepByReferenceEquals(S state, ImHashMapEntry`2<K, V> newEntry, UpdaterInPlaceOrKeeper`1<K, V, S> updateOrKeep);
}
public static class ImTools.Lazy : object {
    public static Lazy`1<T> Of(Func`1<T> valueFactory);
}
public class ImTools.MapParentStack : object {
    private static int DefaultInitialCapacity;
    private Object[] _items;
    public void Put(object item, int index);
    public object Get(int index);
    private static Object[] Expand(Object[] items);
}
public class ImTools.MapParentStack`2 : object {
    private static int DefaultInitialCapacity;
    public Entry[] Items;
    public MapParentStack`2(int capacity);
    public void Put(int index, Entry<K, V> entry, ImHashMap`2<K, V> branch);
    private static Entry[] Expand(Entry[] items);
}
public class ImTools.Opt`1 : ValueType {
    public T Value;
    public bool HasValue;
    public Opt`1(T value);
    public static Opt`1<T> op_Implicit(T value);
    public T OrDefault(T defaultValue);
}
[ExtensionAttribute]
public static class ImTools.PartitionedHashMap : object {
    public static int PARTITION_COUNT_POWER_OF_TWO;
    public static int PARTITION_HASH_MASK;
    public static ImHashMap`2[] CreateEmpty(int partitionCountOfPowerOfTwo);
    public static ImHashMap`2[] CreateEmpty(int partitionCountOfPowerOfTwo);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2[] parts, int hash, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2[] parts, int hash, K key, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2[] parts, K key, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2[] parts, int hash, K key, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2[] parts, K key, int partHashMask);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2[] parts, int hash, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2[] parts, int hash, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2[] parts, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2[] parts, int hash, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2[] parts, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, V value, int partHashMask);
    private static void RefAddOrUpdatePart(ImHashMap`2& part, int hash, V value);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, K key, V value, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, K key, V value, int partHashMask);
    private static void RefAddOrUpdatePart(ImHashMap`2& part, int hash, K key, V value);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, V value, Update`2<int, V> update, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, K key, V value, Update`2<K, V> update, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, K key, V value, Update`2<K, V> update, int partHashMask);
    [ExtensionAttribute]
public static void AddOrKeep(ImHashMap`2[] parts, int hash, V value, int partHashMask);
    private static void RefAddOrKeepPart(ImHashMap`2& part, int hash, V value);
    [ExtensionAttribute]
public static void AddOrKeep(ImHashMap`2[] parts, int hash, K key, V value, int partHashMask);
    private static void RefAddOrKeepPart(ImHashMap`2& part, int hash, K key, V value);
    [ExtensionAttribute]
public static void Update(ImHashMap`2[] parts, int hash, V value, int partHashMask);
    private static void RefUpdatePart(ImHashMap`2& part, int hash, V value);
    [ExtensionAttribute]
public static Enumerable`1<V> Enumerate(ImHashMap`2[] parts);
    [ExtensionAttribute]
public static Enumerable`2<K, V> Enumerate(ImHashMap`2[] parts);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2[] parts, S state, Action`3<VEntry`1<V>, int, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2[] parts, S state, Action`3<ImHashMapEntry`2<K, V>, int, S> handler, MapParentStack parents);
}
[ExtensionAttribute]
public static class ImTools.Ref : object {
    public static int RETRY_COUNT_UNTIL_THROW;
    public static Ref`1<T> Of(T value);
    [ExtensionAttribute]
public static Ref`1<T> NewRef(Ref`1<T> original);
    public static T Swap(T& value, Func`2<T, T> getNewValue, int retryCountUntilThrow);
    private static void ThrowRetryCountExceeded(int retryCountExceeded);
    public static T Swap(T& value, A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public static T SwapAndGetNewValue(T& value, Func`2<T, T> getNewValue, int retryCountUntilThrow);
    public static T SwapAndGetNewValue(T& value, A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public static T Swap(T& value, A a, B b, Func`4<T, A, B, T> getNewValue, int retryCountUntilThrow);
    public static T Swap(T& value, A a, B b, C c, Func`5<T, A, B, C, T> getNewValue, int retryCountUntilThrow);
    public static T Swap(T& value, A a, B b, C c, D d, Func`6<T, A, B, C, D, T> getNewValue, int retryCountUntilThrow);
}
public class ImTools.Ref`1 : object {
    private T _value;
    public T Value { get; }
    public Ref`1(T initialValue);
    public T get_Value();
    public T Swap(Func`2<T, T> getNewValue);
    public T Swap(A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public T Swap(A a, B b, Func`4<T, A, B, T> getNewValue, int retryCountUntilThrow);
    public T SwapAndGetNewValue(Func`2<T, T> getNewValue, int retryCountUntilThrow);
    public T SwapAndGetNewValue(A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public T Swap(T newValue);
    public T SetNonAtomic(T newValue);
    public bool TrySwapIfStillCurrent(T currentValue, T newValue);
    public void UnsafeSet(T newValue);
}
public class ImTools.SmallArrayPool`1 : ValueType {
    public static byte MaxArrayLength;
    private static T[][] Arrays;
    private static SmallArrayPool`1();
    public static T[] RentOrNew(int requiredLength);
    public static void Return(T[] arr);
}
public static class ImTools.St : object {
    public static St`1<A> Of(A a);
    public static St`1<A> Rent(A a);
    public static St`2<A, B> Of(A a, B b);
    public static St`2<A, B> Rent(A a, B b);
}
public class ImTools.St`1 : object {
    public A a;
    internal static St`1<A> Pooled;
    public void Pool();
    public void Reset();
    public A ResetButGetA();
}
public class ImTools.St`2 : object {
    public A a;
    public B b;
    internal static St`2<A, B> Pooled;
    public St`2<A, B> Pool();
    public void Reset();
    public A ResetButGetA();
    public B ResetButGetB();
}
public class ImTools.StackPool`1 : object {
    private Stack<T> _s;
    public T RentOrNull();
    public void Return(T x);
}
public class ImTools.Update`1 : MulticastDelegate {
    public Update`1(object object, IntPtr method);
    public virtual V Invoke(V oldValue, V newValue);
    public virtual IAsyncResult BeginInvoke(V oldValue, V newValue, AsyncCallback callback, object object);
    public virtual V EndInvoke(IAsyncResult result);
}
public class ImTools.Update`2 : MulticastDelegate {
    public Update`2(object object, IntPtr method);
    public virtual V Invoke(K key, V oldValue, V newValue);
    public virtual IAsyncResult BeginInvoke(K key, V oldValue, V newValue, AsyncCallback callback, object object);
    public virtual V EndInvoke(IAsyncResult result);
}
public class ImTools.VEntry`1 : ImHashMapEntry`2<int, V> {
    public int Key { get; }
    public VEntry`1(int hash);
    public VEntry`1(int hash, V value);
    public virtual int get_Key();
    internal virtual StringBuilder ToMermaidNodeItem(StringBuilder s);
    internal virtual ImHashMapEntry`2<int, V> GetOrNullWithTheSameHash(int key);
    internal virtual ImHashMapEntry`2<int, V> GetOrNullWithTheSameHashByReferenceEquals(int key);
    internal virtual V GetValueOrDefaultWithTheSameHashByReferenceEquals(int key);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<int, V> newEntry, Update`2<int, V> update);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<int, V> newEntry, Update`2<int, V> update);
    internal virtual ImHashMap`2<int, V> GetMapOrReplaceWithEntry(ImHashMap`2<int, V> oldMap, ImHashMapEntry`2<int, V> newEntry);
    internal virtual ImHashMap`2<int, V> AddOrKeepWithTheSameHash(ImHashMap`2<int, V> oldMap, ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> UpdatedOrNullWithTheSameHash(ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> UpdatedOrNullWithTheSameHash(int key, V value, Update`2<int, V> update);
    internal virtual Entry<int, V> RemovedOrNullWithTheSameHash(int key);
    public virtual Entry<int, V> AppendOrUpdateInPlaceOrKeep(S state, ImHashMapEntry`2<int, V> newEntry, UpdaterInPlaceOrKeeper`1<int, V, S> updateOrKeep);
    public virtual Entry<int, V> AppendOrUpdateInPlaceOrKeepByReferenceEquals(S state, ImHashMapEntry`2<int, V> newEntry, UpdaterInPlaceOrKeeper`1<int, V, S> updateOrKeep);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
