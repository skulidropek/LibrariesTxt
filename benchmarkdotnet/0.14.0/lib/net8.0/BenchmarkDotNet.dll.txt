[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Analysers.AnalyserBase : object {
    public string Id { get; }
    public abstract virtual string get_Id();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.AnalyserBase/<Analyse>d__2")]
public sealed virtual IEnumerable`1<Conclusion> Analyse(Summary summary);
    [PublicAPIAttribute]
protected virtual IEnumerable`1<Conclusion> AnalyseSummary(Summary summary);
    [PublicAPIAttribute]
protected virtual IEnumerable`1<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary);
    protected Conclusion CreateHint(string message, BenchmarkReport report, bool mergeable);
    protected Conclusion CreateWarning(string message, BenchmarkReport report, bool mergeable);
    protected Conclusion CreateError(string message, BenchmarkReport report, bool mergeable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.BaselineCustomAnalyzer : AnalyserBase {
    public static IAnalyser Default;
    public string Id { get; }
    private static BaselineCustomAnalyzer();
    public virtual string get_Id();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.BaselineCustomAnalyzer/<AnalyseSummary>d__3")]
protected virtual IEnumerable`1<Conclusion> AnalyseSummary(Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.CompositeAnalyser : object {
    private ImmutableHashSet`1<IAnalyser> analysers;
    public string Id { get; }
    public CompositeAnalyser(ImmutableHashSet`1<IAnalyser> analysers);
    public sealed virtual string get_Id();
    public sealed virtual IEnumerable`1<Conclusion> Analyse(Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.Conclusion : object {
    [CompilerGeneratedAttribute]
private string <AnalyserId>k__BackingField;
    [CompilerGeneratedAttribute]
private ConclusionKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Mergeable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private BenchmarkReport <Report>k__BackingField;
    public string AnalyserId { get; }
    public ConclusionKind Kind { get; }
    public bool Mergeable { get; }
    public string Message { get; }
    [NullableAttribute("2")]
public BenchmarkReport Report { get; }
    private Conclusion(string analyserId, ConclusionKind kind, string message, BenchmarkReport report, bool mergeable);
    [CompilerGeneratedAttribute]
public string get_AnalyserId();
    [CompilerGeneratedAttribute]
public ConclusionKind get_Kind();
    [CompilerGeneratedAttribute]
public bool get_Mergeable();
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public BenchmarkReport get_Report();
    public static Conclusion CreateHint(string analyserId, string message, BenchmarkReport report, bool mergeable);
    public static Conclusion CreateWarning(string analyserId, string message, BenchmarkReport report, bool mergeable);
    public static Conclusion CreateError(string analyserId, string message, BenchmarkReport report, bool mergeable);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Conclusion other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Analysers.ConclusionHelper : object {
    public static void Print(ILogger logger, IEnumerable`1<Conclusion> conclusions);
    private static void PrintFiltered(IEnumerable`1<Conclusion> conclusions, ConclusionKind kind, string title, Action`1<string> printLine);
    private static string GetTitle(Conclusion conclusion);
}
public enum BenchmarkDotNet.Analysers.ConclusionKind : Enum {
    public int value__;
    public static ConclusionKind Error;
    public static ConclusionKind Warning;
    public static ConclusionKind Hint;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.EnvironmentAnalyser : AnalyserBase {
    public static IAnalyser Default;
    public string Id { get; }
    private static EnvironmentAnalyser();
    public virtual string get_Id();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.EnvironmentAnalyser/<AnalyseReport>d__4")]
protected virtual IEnumerable`1<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.EnvironmentAnalyser/<AnalyseSummary>d__5")]
protected virtual IEnumerable`1<Conclusion> AnalyseSummary(Summary summary);
    private static string CreateWarningAboutAntivirus(ICollection`1<Antivirus> avProducts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.HideColumnsAnalyser : AnalyserBase {
    public static IAnalyser Default;
    public string Id { get; }
    private static HideColumnsAnalyser();
    public virtual string get_Id();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.HideColumnsAnalyser/<AnalyseSummary>d__3")]
protected virtual IEnumerable`1<Conclusion> AnalyseSummary(Summary summary);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Analysers.IAnalyser {
    [PublicAPIAttribute]
public string Id { get; }
    public abstract virtual string get_Id();
    [PublicAPIAttribute]
public abstract virtual IEnumerable`1<Conclusion> Analyse(Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.MinIterationTimeAnalyser : AnalyserBase {
    private static TimeInterval MinSufficientIterationTime;
    public static IAnalyser Default;
    public string Id { get; }
    private static MinIterationTimeAnalyser();
    public virtual string get_Id();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.MinIterationTimeAnalyser/<AnalyseReport>d__5")]
protected virtual IEnumerable`1<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer : AnalyserBase {
    public static IAnalyser Default;
    public string Id { get; }
    private static MultimodalDistributionAnalyzer();
    public virtual string get_Id();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer/<AnalyseReport>d__4")]
protected virtual IEnumerable`1<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary);
    private Conclusion Create(string kind, double mValue, BenchmarkReport report, CultureInfo cultureInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.OutliersAnalyser : AnalyserBase {
    public static IAnalyser Default;
    public string Id { get; }
    private static OutliersAnalyser();
    public virtual string get_Id();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.OutliersAnalyser/<AnalyseReport>d__4")]
protected virtual IEnumerable`1<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary);
    [PublicAPIAttribute]
[PureAttribute]
public static string GetMessage(Double[] actualOutliers, Double[] allOutliers, Double[] lowerOutliers, Double[] upperOutliers, CultureInfo cultureInfo);
    private static string GetRangeMessage(Double[] values);
    [CompilerGeneratedAttribute]
internal static string <GetMessage>g__Format|5_0(int n, string verb);
    [CompilerGeneratedAttribute]
internal static string <GetRangeMessage>g__Format|6_0(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.RuntimeErrorAnalyser : AnalyserBase {
    public static IAnalyser Default;
    public string Id { get; }
    private static RuntimeErrorAnalyser();
    public virtual string get_Id();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.RuntimeErrorAnalyser/<AnalyseReport>d__4")]
protected virtual IEnumerable`1<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Analysers.ZeroMeasurementAnalyser : AnalyserBase {
    public static IAnalyser Default;
    private static TimeInterval FallbackCpuResolutionValue;
    public string Id { get; }
    private static ZeroMeasurementAnalyser();
    public virtual string get_Id();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Analysers.ZeroMeasurementAnalyser/<AnalyseReport>d__5")]
protected virtual IEnumerable`1<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Analysers.ZeroMeasurementHelper : object {
    public static bool IsNegligible(Sample results, double threshold);
    public static bool IsNoticeable(Sample results, double threshold);
    public static bool AreIndistinguishable(Double[] workload, Double[] overhead, Threshold threshold);
    public static bool AreIndistinguishable(Sample workload, Sample overhead, Threshold threshold);
    public static bool AreDistinguishable(Double[] workload, Double[] overhead, Threshold threshold);
    public static bool AreDistinguishable(Sample workload, Sample overhead, Threshold threshold);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.AllCategoriesFilterAttribute : FilterConfigBaseAttribute {
    [NullableContextAttribute("1")]
public AllCategoriesFilterAttribute(String[] targetCategories);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.AllStatisticsColumnAttribute : ColumnConfigBaseAttribute {
}
public class BenchmarkDotNet.Attributes.AnyCategoriesFilterAttribute : FilterConfigBaseAttribute {
    [NullableContextAttribute("1")]
public AnyCategoriesFilterAttribute(String[] targetCategories);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.ArtifactsPathAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public string Value { get; }
    public IConfig Config { get; }
    public ArtifactsPathAttribute(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
public class BenchmarkDotNet.Attributes.AsciiDocExporterAttribute : ExporterConfigBaseAttribute {
}
public class BenchmarkDotNet.Attributes.BaselineColumnAttribute : ColumnConfigBaseAttribute {
}
public class BenchmarkDotNet.Attributes.CategoriesColumnAttribute : ColumnConfigBaseAttribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.CategoryDiscovererAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public CategoryDiscovererAttribute(bool inherit);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[ObsoleteAttribute("Please use [SimpleJob(RuntimeMoniker.Net$)] instead.", "False")]
public class BenchmarkDotNet.Attributes.ClrJobAttribute : JobConfigBaseAttribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public abstract class BenchmarkDotNet.Attributes.ColumnConfigBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    protected ColumnConfigBaseAttribute(IColumn[] columns);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.ConfidenceIntervalErrorColumnAttribute : ColumnConfigBaseAttribute {
    public ConfidenceIntervalErrorColumnAttribute(ConfidenceLevel level);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.ConfigAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public ConfigAttribute(Type type);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[ObsoleteAttribute("Please use [SimpleJob(RuntimeMoniker.NetCoreApp$)] instead.", "False")]
public class BenchmarkDotNet.Attributes.CoreJobAttribute : JobConfigBaseAttribute {
}
public class BenchmarkDotNet.Attributes.CsvExporterAttribute : ExporterConfigBaseAttribute {
    public CsvExporterAttribute(CsvSeparator separator);
}
public class BenchmarkDotNet.Attributes.CsvMeasurementsExporterAttribute : ExporterConfigBaseAttribute {
    public CsvMeasurementsExporterAttribute(CsvSeparator separator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.DisassemblyDiagnoserAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public DisassemblyDiagnoserAttribute(int maxDepth, DisassemblySyntax syntax, bool printSource, bool printInstructionAddresses, bool exportGithubMarkdown, bool exportHtml, bool exportCombinedDisassemblyReport, bool exportDiff, String[] filters);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[ObsoleteAttribute("Please use [DryJob(RuntimeMoniker.Net$)] instead.", "False")]
public class BenchmarkDotNet.Attributes.DryClrJobAttribute : JobConfigBaseAttribute {
}
[ObsoleteAttribute("Please use [DryJob(RuntimeMoniker.NetCoreApp$)] instead.", "False")]
public class BenchmarkDotNet.Attributes.DryCoreJobAttribute : JobConfigBaseAttribute {
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.DryJobAttribute : JobConfigBaseAttribute {
    public DryJobAttribute(RuntimeMoniker runtimeMoniker);
    public DryJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform);
}
[ObsoleteAttribute("Please use [DryJob(RuntimeMoniker.Mono)] instead.", "False")]
public class BenchmarkDotNet.Attributes.DryMonoJobAttribute : JobConfigBaseAttribute {
}
[AttributeUsageAttribute("5")]
[ObsoleteAttribute("Don't use it")]
public class BenchmarkDotNet.Attributes.EncodingAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    [NullableAttribute("1")]
public IConfig Config { get; }
    [NullableContextAttribute("1")]
private EncodingAttribute(Encoding encoding);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.EvaluateOverheadAttribute : JobMutatorConfigBaseAttribute {
    public EvaluateOverheadAttribute(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.EventPipeProfilerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public EventPipeProfilerAttribute(EventPipeProfile profile);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.ExceptionDiagnoserAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.ExecutionValidatorAttribute : ValidatorConfigBaseAttribute {
    public ExecutionValidatorAttribute(bool failOnError);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.ExporterConfigBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    protected ExporterConfigBaseAttribute(IExporter[] exporters);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("69")]
public abstract class BenchmarkDotNet.Attributes.FilterConfigBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    protected FilterConfigBaseAttribute(IFilter[] filters);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
public class BenchmarkDotNet.Attributes.Filters.AotFilterAttribute : FilterConfigBaseAttribute {
    [NullableContextAttribute("2")]
public AotFilterAttribute(string reason);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.GcConcurrentAttribute : JobMutatorConfigBaseAttribute {
    public GcConcurrentAttribute(bool value);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.GcForceAttribute : JobMutatorConfigBaseAttribute {
    public GcForceAttribute(bool value);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.GcServerAttribute : JobMutatorConfigBaseAttribute {
    public GcServerAttribute(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.GroupBenchmarksByAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public GroupBenchmarksByAttribute(BenchmarkLogicalGroupRule[] rules);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.HardwareCountersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public HardwareCountersAttribute(HardwareCounter[] counters);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.HideColumnsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public HideColumnsAttribute(String[] names);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
public class BenchmarkDotNet.Attributes.HtmlExporterAttribute : ExporterConfigBaseAttribute {
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.InnerIterationCountAttribute : JobMutatorConfigBaseAttribute {
    public InnerIterationCountAttribute(int invocationCount);
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.InProcessAttribute : JobConfigBaseAttribute {
    public InProcessAttribute(bool dontLogOutput);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.InvocationCountAttribute : JobMutatorConfigBaseAttribute {
    public InvocationCountAttribute(int invocationCount, int unrollFactor);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.IterationCountAttribute : JobMutatorConfigBaseAttribute {
    public IterationCountAttribute(int targetIterationCount);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.IterationsColumnAttribute : ColumnConfigBaseAttribute {
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.IterationTimeAttribute : JobMutatorConfigBaseAttribute {
    public IterationTimeAttribute(double milliseconds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.JobConfigBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    protected JobConfigBaseAttribute(Job job);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
    protected static Job GetJob(Job sourceJob, RuntimeMoniker runtimeMoniker, Nullable`1<Jit> jit, Nullable`1<Platform> platform);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("68")]
public class BenchmarkDotNet.Attributes.JobMutatorConfigBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    protected JobMutatorConfigBaseAttribute(Job job);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.JsonExporterAttribute : ExporterConfigBaseAttribute {
    [NullableContextAttribute("1")]
private JsonExporterAttribute(IExporter exporter);
    [NullableContextAttribute("1")]
public JsonExporterAttribute(string fileNameSuffix, bool indentJson, bool excludeMeasurements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.KeepBenchmarkFilesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public KeepBenchmarkFilesAttribute(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
public class BenchmarkDotNet.Attributes.KurtosisColumnAttribute : ColumnConfigBaseAttribute {
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.LegacyJitX64JobAttribute : JobConfigBaseAttribute {
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.LegacyJitX86JobAttribute : JobConfigBaseAttribute {
}
public class BenchmarkDotNet.Attributes.LogicalGroupColumnAttribute : ColumnConfigBaseAttribute {
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.LongRunJobAttribute : JobConfigBaseAttribute {
    public LongRunJobAttribute(RuntimeMoniker runtimeMoniker);
    public LongRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.MarkdownExporterAttribute : ExporterConfigBaseAttribute {
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.MaxAbsoluteErrorAttribute : JobMutatorConfigBaseAttribute {
    public MaxAbsoluteErrorAttribute(double nanoseconds);
}
public class BenchmarkDotNet.Attributes.MaxColumnAttribute : ColumnConfigBaseAttribute {
}
public class BenchmarkDotNet.Attributes.MaxIterationCountAttribute : JobMutatorConfigBaseAttribute {
    public MaxIterationCountAttribute(int maxTargetIterationCount);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.MaxRelativeErrorAttribute : JobMutatorConfigBaseAttribute {
    public MaxRelativeErrorAttribute(double maxRelativeError);
}
public class BenchmarkDotNet.Attributes.MaxWarmupCountAttribute : JobMutatorConfigBaseAttribute {
    public MaxWarmupCountAttribute(int maxWarmupCount, bool forceAutoWarmup);
}
public class BenchmarkDotNet.Attributes.MeanColumnAttribute : ColumnConfigBaseAttribute {
}
public class BenchmarkDotNet.Attributes.MedianColumnAttribute : ColumnConfigBaseAttribute {
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.MediumRunJobAttribute : JobConfigBaseAttribute {
    public MediumRunJobAttribute(RuntimeMoniker runtimeMoniker);
    public MediumRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.MemoryDiagnoserAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public MemoryDiagnoserAttribute(bool displayGenColumns);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
public class BenchmarkDotNet.Attributes.MemoryRandomizationAttribute : JobMutatorConfigBaseAttribute {
    public MemoryRandomizationAttribute(bool enable, OutlierMode outlierMode);
}
public class BenchmarkDotNet.Attributes.MinColumnAttribute : ColumnConfigBaseAttribute {
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.MinInvokeCountAttribute : JobMutatorConfigBaseAttribute {
    public MinInvokeCountAttribute(int minInvokeCount);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.MinIterationCountAttribute : JobMutatorConfigBaseAttribute {
    public MinIterationCountAttribute(int minTargetIterationCount);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.MinIterationTimeAttribute : JobMutatorConfigBaseAttribute {
    public MinIterationTimeAttribute(double milliseconds);
}
public class BenchmarkDotNet.Attributes.MinWarmupCountAttribute : JobMutatorConfigBaseAttribute {
    public MinWarmupCountAttribute(int minWarmupCount, bool forceAutoWarmup);
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.MonoJobAttribute : JobConfigBaseAttribute {
    public MonoJobAttribute(bool baseline);
    public MonoJobAttribute(RuntimeMoniker runtimeMoniker, bool baseline);
    [NullableContextAttribute("1")]
public MonoJobAttribute(string name, string path, bool baseline);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.MValueColumnAttribute : ColumnConfigBaseAttribute {
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.NamespaceColumnAttribute : ColumnConfigBaseAttribute {
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.OperatingSystemsArchitectureFilterAttribute : FilterConfigBaseAttribute {
    [NullableContextAttribute("1")]
public OperatingSystemsArchitectureFilterAttribute(bool allowed, Architecture[] architectures);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.OperatingSystemsFilterAttribute : FilterConfigBaseAttribute {
    private static OSPlatform browser;
    [NullableContextAttribute("1")]
public OperatingSystemsFilterAttribute(bool allowed, OS[] platforms);
    private static OperatingSystemsFilterAttribute();
    private static OSPlatform Map(OS platform);
}
public class BenchmarkDotNet.Attributes.OperationsPerSecondAttribute : ColumnConfigBaseAttribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.OrdererAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public OrdererAttribute(SummaryOrderPolicy summaryOrderPolicy, MethodOrderPolicy methodOrderPolicy);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
public enum BenchmarkDotNet.Attributes.OS : Enum {
    public byte value__;
    public static OS Windows;
    public static OS Linux;
    public static OS macOS;
    public static OS Browser;
}
public class BenchmarkDotNet.Attributes.OutliersAttribute : JobMutatorConfigBaseAttribute {
    public OutliersAttribute(OutlierMode outlierMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.PerfCollectProfilerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public PerfCollectProfilerAttribute(bool performExtraBenchmarksRun, int timeoutInSeconds);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
public class BenchmarkDotNet.Attributes.PlainExporterAttribute : ExporterConfigBaseAttribute {
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.ProcessCountAttribute : JobMutatorConfigBaseAttribute {
    public ProcessCountAttribute(int processLaunchCount);
}
public class BenchmarkDotNet.Attributes.Q1ColumnAttribute : ColumnConfigBaseAttribute {
}
public class BenchmarkDotNet.Attributes.Q3ColumnAttribute : ColumnConfigBaseAttribute {
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.RankColumnAttribute : ColumnConfigBaseAttribute {
    public RankColumnAttribute(NumeralSystem system);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.ReturnValueValidatorAttribute : ValidatorConfigBaseAttribute {
    public ReturnValueValidatorAttribute(bool failOnError);
}
public class BenchmarkDotNet.Attributes.RPlotExporterAttribute : ExporterConfigBaseAttribute {
}
public class BenchmarkDotNet.Attributes.RunOncePerIterationAttribute : JobMutatorConfigBaseAttribute {
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.RyuJitX64JobAttribute : JobConfigBaseAttribute {
}
[PublicAPIAttribute]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.RyuJitX86JobAttribute : JobConfigBaseAttribute {
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.ShortRunJobAttribute : JobConfigBaseAttribute {
    public ShortRunJobAttribute(RuntimeMoniker runtimeMoniker);
    public ShortRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.SimpleJobAttribute : JobConfigBaseAttribute {
    private static int DefaultValue;
    [PublicAPIAttribute]
public SimpleJobAttribute(int launchCount, int warmupCount, int iterationCount, int invocationCount, string id, bool baseline);
    [PublicAPIAttribute]
public SimpleJobAttribute(RunStrategy runStrategy, int launchCount, int warmupCount, int iterationCount, int invocationCount, string id, bool baseline);
    [PublicAPIAttribute]
public SimpleJobAttribute(RuntimeMoniker runtimeMoniker, int launchCount, int warmupCount, int iterationCount, int invocationCount, string id, bool baseline);
    [PublicAPIAttribute]
public SimpleJobAttribute(RunStrategy runStrategy, RuntimeMoniker runtimeMoniker, int launchCount, int warmupCount, int iterationCount, int invocationCount, string id, bool baseline);
    [NullableContextAttribute("1")]
private static Job CreateJob(string id, int launchCount, int warmupCount, int iterationCount, int invocationCount, Nullable`1<RunStrategy> runStrategy, bool baseline, RuntimeMoniker runtimeMoniker);
}
public class BenchmarkDotNet.Attributes.SkewnessColumnAttribute : ColumnConfigBaseAttribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.StatisticalTestColumnAttribute : ColumnConfigBaseAttribute {
    public StatisticalTestColumnAttribute(string threshold);
    public StatisticalTestColumnAttribute(string threshold, SignificanceLevel significanceLevel);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.StdDevColumnAttribute : ColumnConfigBaseAttribute {
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.StdErrorColumnAttribute : ColumnConfigBaseAttribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.StopOnFirstErrorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    public StopOnFirstErrorAttribute(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class BenchmarkDotNet.Attributes.ThreadingDiagnoserAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.UnicodeConsoleLoggerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5")]
public abstract class BenchmarkDotNet.Attributes.ValidatorConfigBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    public IConfig Config { get; }
    protected ValidatorConfigBaseAttribute(IValidator[] validators);
    [CompilerGeneratedAttribute]
public sealed virtual IConfig get_Config();
}
[PublicAPIAttribute]
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.VeryLongRunJobAttribute : JobConfigBaseAttribute {
    public VeryLongRunJobAttribute(RuntimeMoniker runtimeMoniker);
    public VeryLongRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Attributes.WarmupCountAttribute : JobMutatorConfigBaseAttribute {
    public WarmupCountAttribute(int warmupCount);
}
[AttributeUsageAttribute("5")]
public class BenchmarkDotNet.Attributes.XmlExporterAttribute : ExporterConfigBaseAttribute {
    [NullableContextAttribute("1")]
private XmlExporterAttribute(IExporter exporter);
    [NullableContextAttribute("1")]
public XmlExporterAttribute(string fileNameSuffix, bool indentXml, bool excludeMeasurements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class BenchmarkDotNet.Characteristics.Characteristic : object {
    public static object EmptyValue;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreOnApply>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DontShowInSummary>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CharacteristicType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <FallbackValue>k__BackingField;
    public string Id { get; }
    public string FullId { get; }
    public bool IgnoreOnApply { get; }
    public bool DontShowInSummary { get; }
    [DynamicallyAccessedMembersAttribute("1632")]
public Type CharacteristicType { get; }
    public Type DeclaringType { get; }
    private object FallbackValue { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public bool HasChildCharacteristics { get; }
    protected Characteristic(string id, Type characteristicType, Type declaringType, object fallbackValue, bool ignoreOnApply, bool dontShowInSummary);
    private static Characteristic();
    public static Characteristic`1<T> Create(string memberName);
    public static Characteristic`1<T> Create(string memberName, T fallbackValue);
    public static Characteristic`1<T> Create(string memberName, Func`3<CharacteristicObject, T, T> resolver, T fallbackValue, bool ignoreOnApply);
    public static Characteristic`1<T> CreateHidden(string memberName);
    public static Characteristic`1<T> CreateIgnoreOnApply(string memberName);
    [CompilerGeneratedAttribute]
public string get_Id();
    public string get_FullId();
    [CompilerGeneratedAttribute]
public bool get_IgnoreOnApply();
    [CompilerGeneratedAttribute]
public bool get_DontShowInSummary();
    [CompilerGeneratedAttribute]
public Type get_CharacteristicType();
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
private object get_FallbackValue();
    public object get_Item(CharacteristicObject obj);
    public void set_Item(CharacteristicObject obj, object value);
    public bool get_HasChildCharacteristics();
    internal virtual object ResolveValueCore(CharacteristicObject obj, object currentValue);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class BenchmarkDotNet.Characteristics.Characteristic`1 : Characteristic {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`3<CharacteristicObject, T, T> <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private T <FallbackValue>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<CharacteristicObject, T, T> Resolver { get; }
    public T FallbackValue { get; }
    public T Item { get; public set; }
    internal Characteristic`1(string id, Type declaringType, Func`3<CharacteristicObject, T, T> resolver, T fallbackValue, bool ignoreOnApply, bool dontShowInSummary);
    [CompilerGeneratedAttribute]
private Func`3<CharacteristicObject, T, T> get_Resolver();
    [CompilerGeneratedAttribute]
public T get_FallbackValue();
    public T get_Item(CharacteristicObject obj);
    public void set_Item(CharacteristicObject obj, T value);
    internal virtual object ResolveValueCore(CharacteristicObject obj, object currentValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Characteristics.CharacteristicHelper : object {
    private static IReadOnlyList`1<Characteristic> EmptyCharacteristics;
    private static ConcurrentDictionary`2<Type, IReadOnlyList`1<Characteristic>> ThisTypeCharacteristics;
    private static ConcurrentDictionary`2<Type, IReadOnlyList`1<Characteristic>> AllTypeCharacteristics;
    private static CharacteristicHelper();
    internal static bool IsCharacteristicObjectSubclass(Type type);
    private static bool IsCharacteristicSubclass(Type type);
    private static Characteristic AssertHasValue(MemberInfo member, Characteristic value);
    [ExtensionAttribute]
public static bool IsPresentableCharacteristic(Characteristic c, bool includeIgnoreOnApply);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static IReadOnlyList`1<Characteristic> GetThisTypeCharacteristics(CharacteristicObject obj);
    public static IReadOnlyList`1<Characteristic> GetThisTypeCharacteristics(Type characteristicObjectType);
    private static IReadOnlyList`1<Characteristic> GetThisTypeCharacteristicsCore(Type characteristicObjectType);
    [ExtensionAttribute]
public static IReadOnlyList`1<Characteristic> GetAllCharacteristics(CharacteristicObject obj);
    public static IReadOnlyList`1<Characteristic> GetAllCharacteristics(Type characteristicObjectType);
    private static IReadOnlyList`1<Characteristic> GetAllCharacteristicsCore(Type characteristicObjectType);
    private static void FillAllCharacteristicsCore(Type characteristicObjectType, List`1<Characteristic> result, HashSet`1<Characteristic> visited);
    public static IReadOnlyList`1<Characteristic> GetAllPresentableCharacteristics(Type characteristicObjectType, bool includeIgnoreOnApply);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DynamicallyAccessedMembersAttribute("1632")]
public abstract class BenchmarkDotNet.Characteristics.CharacteristicObject : object {
    internal static DynamicallyAccessedMemberTypes CharacteristicMemberTypes;
    public static Characteristic`1<string> IdCharacteristic;
    private Dictionary`2<Characteristic, object> sharedValues;
    private bool frozen;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CharacteristicObject <Owner>k__BackingField;
    [NullableAttribute("2")]
private CharacteristicObject Owner { get; private set; }
    protected CharacteristicObject OwnerOrSelf { get; }
    public bool Frozen { get; }
    protected bool IsPropertyBag { get; }
    public bool HasChanges { get; }
    public string Id { get; }
    [NullableContextAttribute("2")]
protected CharacteristicObject(string id);
    private static CharacteristicObject();
    protected static string ResolveId(CharacteristicObject obj, string actual);
    private void AssertNotFrozen();
    private void AssertIsRoot();
    private void AssertIsNonFrozenRoot();
    private static void AssertIsAssignable(Characteristic characteristic, object value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private CharacteristicObject get_Owner();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Owner(CharacteristicObject value);
    protected CharacteristicObject get_OwnerOrSelf();
    public bool get_Frozen();
    protected virtual bool get_IsPropertyBag();
    public bool get_HasChanges();
    public IEnumerable`1<Characteristic> GetCharacteristicsWithValues();
    private IEnumerable`1<Characteristic> GetCharacteristicsToApply();
    private IEnumerable`1<Characteristic> GetCharacteristicsToApply(CharacteristicObject other);
    public bool HasValue(Characteristic characteristic);
    internal T GetValue(Characteristic`1<T> characteristic);
    internal object GetValue(Characteristic characteristic);
    private object ResolveCore(Characteristic characteristic, object result);
    public T ResolveValue(Characteristic`1<T> characteristic, IResolver resolver);
    public T ResolveValue(Characteristic`1<T> characteristic, IResolver resolver, T defaultValue);
    public object ResolveValue(Characteristic characteristic, IResolver resolver);
    public object ResolveValue(Characteristic characteristic, IResolver resolver, object defaultValue);
    public T ResolveValue(Characteristic`1<T> characteristic, T defaultValue);
    [PublicAPIAttribute]
public object ResolveValue(Characteristic characteristic, object defaultValue);
    [NullableContextAttribute("0")]
public Nullable`1<T> ResolveValueAsNullable(Characteristic`1<T> characteristic);
    internal void SetValue(Characteristic`1<T> characteristic, T value);
    internal void SetValue(Characteristic characteristic, object value);
    private void SetValueCore(Characteristic characteristic, object value);
    private void SetOwnerCore(CharacteristicObject newOwner);
    private void DetachFromOwner(Characteristic thisCharacteristic);
    private void AttachToOwner(CharacteristicObject newOwner, Characteristic thisCharacteristic);
    private void SetValueOnAttach(Characteristic characteristic, object value);
    [PublicAPIAttribute]
public void Apply(CharacteristicObject other);
    protected CharacteristicObject ApplyCore(CharacteristicObject other);
    private CharacteristicObject ApplyCore(CharacteristicObject other, IEnumerable`1<Characteristic> characteristicsToApply);
    [PublicAPIAttribute]
public void Freeze();
    protected CharacteristicObject FreezeCore();
    [PublicAPIAttribute]
public CharacteristicObject UnfreezeCopy();
    protected CharacteristicObject UnfreezeCopyCore();
    public string get_Id();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Characteristics.CharacteristicObject`1 : CharacteristicObject {
    [NullableContextAttribute("2")]
protected CharacteristicObject`1(string id);
    public T Apply(CharacteristicObject other);
    [PublicAPIAttribute]
public T Apply(CharacteristicObject[] others);
    [PublicAPIAttribute]
public T ApplyAndFreeze(CharacteristicObject other);
    [PublicAPIAttribute]
public T ApplyAndFreeze(CharacteristicObject[] others);
    public T Freeze();
    public T UnfreezeCopy();
    protected static Characteristic`1<TC> CreateCharacteristic(string memberName);
    protected static Characteristic`1<TC> CreateHiddenCharacteristic(string memberName);
    protected static Characteristic`1<TC> CreateIgnoreOnApplyCharacteristic(string memberName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Characteristics.CharacteristicPresenter : object {
    public static CharacteristicPresenter DefaultPresenter;
    public static CharacteristicPresenter FolderPresenter;
    public static CharacteristicPresenter SummaryPresenter;
    public static CharacteristicPresenter SourceCodePresenter;
    private static CharacteristicPresenter();
    public abstract virtual string ToPresentation(CharacteristicObject obj, Characteristic characteristic);
    public abstract virtual string ToPresentation(object characteristicValue, Characteristic characteristic);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class BenchmarkDotNet.Characteristics.CharacteristicSet : CharacteristicObject`1<CharacteristicSet> {
    protected bool IsPropertyBag { get; }
    [PublicAPIAttribute]
public CharacteristicSet(CharacteristicObject other);
    [PublicAPIAttribute]
public CharacteristicSet(CharacteristicObject[] others);
    protected virtual bool get_IsPropertyBag();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Characteristics.CharacteristicSetPresenter : object {
    [PublicAPIAttribute]
public static CharacteristicSetPresenter Default;
    [PublicAPIAttribute]
public static CharacteristicSetPresenter Display;
    [PublicAPIAttribute]
public static CharacteristicSetPresenter Folder;
    [PublicAPIAttribute]
public static CharacteristicSetPresenter SourceCode;
    private static CharacteristicSetPresenter();
    public abstract virtual string ToPresentation(CharacteristicObject obj);
    protected virtual IEnumerable`1<Characteristic> GetPresentableCharacteristics(CharacteristicObject obj, bool includeIgnoreOnApply);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Characteristics.CompositeResolver : object {
    private IResolver[] resolvers;
    public CompositeResolver(IResolver[] resolvers);
    public sealed virtual bool CanResolve(Characteristic characteristic);
    public sealed virtual object Resolve(CharacteristicObject obj, Characteristic characteristic);
    public sealed virtual T Resolve(CharacteristicObject obj, Characteristic`1<T> characteristic);
    public sealed virtual object Resolve(CharacteristicObject obj, Characteristic characteristic, object defaultValue);
    public sealed virtual T Resolve(CharacteristicObject obj, Characteristic`1<T> characteristic, T defaultValue);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Characteristics.IResolver {
    public abstract virtual bool CanResolve(Characteristic characteristic);
    public abstract virtual object Resolve(CharacteristicObject obj, Characteristic characteristic);
    public abstract virtual T Resolve(CharacteristicObject obj, Characteristic`1<T> characteristic);
    public abstract virtual object Resolve(CharacteristicObject obj, Characteristic characteristic, object defaultValue);
    public abstract virtual T Resolve(CharacteristicObject obj, Characteristic`1<T> characteristic, T defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Characteristics.Resolver : object {
    private Dictionary`2<Characteristic, Func`2<CharacteristicObject, object>> resolvers;
    protected void Register(Characteristic`1<T> characteristic, Func`1<T> resolver);
    protected void Register(Characteristic`1<T> characteristic, Func`2<CharacteristicObject, T> resolver);
    public sealed virtual bool CanResolve(Characteristic characteristic);
    public sealed virtual object Resolve(CharacteristicObject obj, Characteristic characteristic);
    public sealed virtual T Resolve(CharacteristicObject obj, Characteristic`1<T> characteristic);
    public sealed virtual object Resolve(CharacteristicObject obj, Characteristic characteristic, object defaultValue);
    public sealed virtual T Resolve(CharacteristicObject obj, Characteristic`1<T> characteristic, T defaultValue);
}
internal static class BenchmarkDotNet.Code.ArrayParam : object {
    [NullableContextAttribute("1")]
public static string GetDisplayString(Array array);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Code.ArrayParam`1 : object {
    private T[] array;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<T, string> toSourceCode;
    public object Value { get; }
    public string DisplayText { get; }
    private ArrayParam`1(T[] array, Func`2<T, string> toSourceCode);
    public sealed virtual object get_Value();
    public sealed virtual string get_DisplayText();
    public sealed virtual string ToSourceCode();
    public static ArrayParam`1<T> ForPrimitives(T[] array);
    [PublicAPIAttribute]
public static ArrayParam`1<T> ForComplexTypes(T[] array, Func`2<T, string> toSourceCode);
    internal static IParam FromObject(object array);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <ToSourceCode>b__7_0(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Code.ByReadOnlyRefDeclarationsProvider : ByRefDeclarationsProvider {
    public string ReturnsDefinition { get; }
    public string WorkloadMethodReturnTypeModifiers { get; }
    public ByReadOnlyRefDeclarationsProvider(Descriptor descriptor);
    public virtual string get_ReturnsDefinition();
    public virtual string get_WorkloadMethodReturnTypeModifiers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Code.ByRefDeclarationsProvider : NonVoidDeclarationsProvider {
    protected Type OverheadMethodReturnType { get; }
    public string WorkloadMethodReturnTypeName { get; }
    public string ConsumeField { get; }
    public string OverheadImplementation { get; }
    public string ReturnsDefinition { get; }
    public string WorkloadMethodReturnTypeModifiers { get; }
    public ByRefDeclarationsProvider(Descriptor descriptor);
    protected virtual Type get_OverheadMethodReturnType();
    public virtual string get_WorkloadMethodReturnTypeName();
    public virtual string get_ConsumeField();
    public virtual string get_OverheadImplementation();
    public virtual string get_ReturnsDefinition();
    public virtual string get_WorkloadMethodReturnTypeModifiers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Code.CodeGenerator : object {
    internal static string Generate(BuildPartition buildPartition);
    private static void AddNonEmptyUnique(HashSet`1<string> items, string value);
    private static ValueTuple`2<bool, string> GetShadowCopySettings();
    private static string Unroll(string text, int factor);
    private static string GetJobsSetDefinition(BenchmarkCase benchmarkCase);
    private static DeclarationsProvider GetDeclarationsProvider(Descriptor descriptor);
    internal static string GetParamsContent(BenchmarkCase benchmarkCase);
    private static string GetArgumentsDefinition(BenchmarkCase benchmarkCase);
    private static string GetDeclareArgumentFields(BenchmarkCase benchmarkCase);
    private static string GetInitializeArgumentFields(BenchmarkCase benchmarkCase);
    private static string GetLoadArguments(BenchmarkCase benchmarkCase);
    private static string GetPassArguments(BenchmarkCase benchmarkCase);
    private static string GetExtraAttributes(Descriptor descriptor);
    private static string GetEngineFactoryTypeName(BenchmarkCase benchmarkCase);
    private static string GetParameterModifier(ParameterInfo parameterInfo);
    private static string GetNativeAotSwitch(BuildPartition buildPartition);
    private static Type GetFieldType(Type argumentType, ParameterInstance argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class BenchmarkDotNet.Code.DeclarationsProvider : object {
    private static string EmptyAction;
    protected Descriptor Descriptor;
    public string OperationsPerInvoke { get; }
    public string WorkloadTypeName { get; }
    public string GlobalSetupMethodName { get; }
    public string GlobalCleanupMethodName { get; }
    public string IterationSetupMethodName { get; }
    public string IterationCleanupMethodName { get; }
    public string ReturnsDefinition { get; }
    protected Type WorkloadMethodReturnType { get; }
    public string WorkloadMethodReturnTypeName { get; }
    public string WorkloadMethodReturnTypeModifiers { get; }
    public string ConsumeField { get; }
    protected Type OverheadMethodReturnType { get; }
    public string OverheadMethodReturnTypeName { get; }
    public string OverheadImplementation { get; }
    internal DeclarationsProvider(Descriptor descriptor);
    public string get_OperationsPerInvoke();
    public string get_WorkloadTypeName();
    public string get_GlobalSetupMethodName();
    public string get_GlobalCleanupMethodName();
    public string get_IterationSetupMethodName();
    public string get_IterationCleanupMethodName();
    public abstract virtual string get_ReturnsDefinition();
    protected virtual Type get_WorkloadMethodReturnType();
    public virtual string get_WorkloadMethodReturnTypeName();
    public virtual string WorkloadMethodDelegate(string passArguments);
    public virtual string get_WorkloadMethodReturnTypeModifiers();
    public virtual string GetWorkloadMethodCall(string passArguments);
    public virtual string get_ConsumeField();
    protected abstract virtual Type get_OverheadMethodReturnType();
    public string get_OverheadMethodReturnTypeName();
    public abstract virtual string get_OverheadImplementation();
    private string GetMethodName(MethodInfo method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Code.EnumParam : object {
    private Type type;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public string DisplayText { get; }
    private EnumParam(object value, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    public sealed virtual string get_DisplayText();
    public sealed virtual string ToSourceCode();
    internal static IParam FromObject(object value, Type type);
    private string ToInvariantCultureString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Code.GenericTaskDeclarationsProvider : NonVoidDeclarationsProvider {
    protected Type WorkloadMethodReturnType { get; }
    public GenericTaskDeclarationsProvider(Descriptor descriptor);
    protected virtual Type get_WorkloadMethodReturnType();
    public virtual string WorkloadMethodDelegate(string passArguments);
    public virtual string GetWorkloadMethodCall(string passArguments);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Code.IParam {
    public object Value { get; }
    public string DisplayText { get; }
    public abstract virtual object get_Value();
    public abstract virtual string get_DisplayText();
    public abstract virtual string ToSourceCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Code.NonVoidDeclarationsProvider : DeclarationsProvider {
    public string ConsumeField { get; }
    protected Type OverheadMethodReturnType { get; }
    public string OverheadImplementation { get; }
    public string ReturnsDefinition { get; }
    public NonVoidDeclarationsProvider(Descriptor descriptor);
    public virtual string get_ConsumeField();
    protected virtual Type get_OverheadMethodReturnType();
    public virtual string get_OverheadImplementation();
    public virtual string get_ReturnsDefinition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Code.TaskDeclarationsProvider : VoidDeclarationsProvider {
    protected Type WorkloadMethodReturnType { get; }
    public TaskDeclarationsProvider(Descriptor descriptor);
    public virtual string WorkloadMethodDelegate(string passArguments);
    public virtual string GetWorkloadMethodCall(string passArguments);
    protected virtual Type get_WorkloadMethodReturnType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Code.VoidDeclarationsProvider : DeclarationsProvider {
    public string ReturnsDefinition { get; }
    protected Type OverheadMethodReturnType { get; }
    public string OverheadImplementation { get; }
    public VoidDeclarationsProvider(Descriptor descriptor);
    public virtual string get_ReturnsDefinition();
    protected virtual Type get_OverheadMethodReturnType();
    public virtual string get_OverheadImplementation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.BaselineAllocationRatioColumn : BaselineCustomColumn {
    public static IColumn RatioMean;
    public string Id { get; }
    public string ColumnName { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    private static BaselineAllocationRatioColumn();
    public virtual string get_Id();
    public virtual string get_ColumnName();
    public virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary`2<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary`2<string, Metric> currentMetrics, bool isBaseline);
    private static bool IsNonBaselinesPrecise(Summary summary, IReadOnlyDictionary`2<string, Metric> baselineMetric, BenchmarkCase benchmarkCase);
    private static Nullable`1<double> GetAllocationRatio(IReadOnlyDictionary`2<string, Metric> current, IReadOnlyDictionary`2<string, Metric> baseline);
    private static Nullable`1<double> GetAllocatedBytes(IReadOnlyDictionary`2<string, Metric> metrics);
    public virtual ColumnCategory get_Category();
    public virtual int get_PriorityInCategory();
    public virtual bool get_IsNumeric();
    public virtual UnitType get_UnitType();
    public virtual string get_Legend();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.BaselineColumn : object {
    [PublicAPIAttribute]
public static IColumn Default;
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    private static BaselineColumn();
    public sealed virtual string get_Id();
    public sealed virtual string get_ColumnName();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool get_IsNumeric();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string get_Legend();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Columns.BaselineCustomColumn : object {
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_ColumnName();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    [PublicAPIAttribute]
public abstract virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary`2<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary`2<string, Metric> currentMetrics, bool isBaseline);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual bool get_AlwaysShow();
    public virtual ColumnCategory get_Category();
    public abstract virtual int get_PriorityInCategory();
    public abstract virtual bool get_IsNumeric();
    public abstract virtual UnitType get_UnitType();
    public abstract virtual string get_Legend();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public virtual string ToString();
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    internal static bool ResultsAreInvalid(Summary summary, BenchmarkCase benchmarkCase, BenchmarkCase baseline);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.BaselineRatioColumn : BaselineCustomColumn {
    public static IColumn RatioMean;
    public static IColumn RatioStdDev;
    [CompilerGeneratedAttribute]
private RatioMetric <Metric>k__BackingField;
    public RatioMetric Metric { get; }
    public string Id { get; }
    public string ColumnName { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    private BaselineRatioColumn(RatioMetric metric);
    private static BaselineRatioColumn();
    [CompilerGeneratedAttribute]
public RatioMetric get_Metric();
    public virtual string get_Id();
    public virtual string get_ColumnName();
    public virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary`2<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary`2<string, Metric> currentMetrics, bool isBaseline);
    private static bool IsNonBaselinesPrecise(Summary summary, Statistics baselineStat, BenchmarkCase benchmarkCase);
    [NullableContextAttribute("2")]
private static Statistics GetRatioStatistics(Statistics current, Statistics baseline);
    public virtual int get_PriorityInCategory();
    public virtual bool get_IsNumeric();
    public virtual UnitType get_UnitType();
    public virtual string get_Legend();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Use BaselineRatioColumn")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Columns.BaselineScaledColumn : BaselineCustomColumn {
    public static IColumn Scaled;
    [CompilerGeneratedAttribute]
private ScaledKind <Kind>k__BackingField;
    public ScaledKind Kind { get; }
    public string Id { get; }
    public string ColumnName { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    private BaselineScaledColumn(ScaledKind kind);
    private static BaselineScaledColumn();
    [CompilerGeneratedAttribute]
public ScaledKind get_Kind();
    public virtual string get_Id();
    public virtual string get_ColumnName();
    public virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary`2<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary`2<string, Metric> currentMetrics, bool isBaseline);
    private static bool IsNonBaselinesPrecise(Summary summary, Statistics baselineStat, BenchmarkCase benchmarkCase);
    public virtual int get_PriorityInCategory();
    public virtual bool get_IsNumeric();
    public virtual UnitType get_UnitType();
    public virtual string get_Legend();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.CategoriesColumn : object {
    public static IColumn Default;
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    private static CategoriesColumn();
    public sealed virtual string get_Id();
    public sealed virtual string get_ColumnName();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool get_IsNumeric();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string get_Legend();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public static class BenchmarkDotNet.Columns.Column : object {
    public static string Namespace;
    public static string Type;
    public static string Method;
    public static string Job;
    public static string Mean;
    public static string StdErr;
    public static string StdDev;
    public static string Error;
    public static string OperationPerSecond;
    public static string Min;
    public static string Q1;
    public static string Median;
    public static string Q3;
    public static string Max;
    public static string Skewness;
    public static string Kurtosis;
    public static string MValue;
    public static string Iterations;
    public static string P0;
    public static string P25;
    public static string P50;
    public static string P67;
    public static string P80;
    public static string P85;
    public static string P90;
    public static string P95;
    public static string P100;
    public static string Categories;
    public static string LogicalGroup;
    public static string Rank;
    public static string Ratio;
    public static string RatioSD;
    public static string AllocRatio;
    public static string Allocated;
    public static string Gen0;
    public static string Gen1;
    public static string Gen2;
    public static string AllocatedNativeMemory;
    public static string NativeMemoryLeak;
    public static string CompletedWorkItems;
    public static string LockContentions;
    public static string CodeSize;
    public static string Exceptions;
    public static string Id;
    public static string MaxRelativeError;
    public static string MaxAbsoluteError;
    public static string MinIterationTime;
    public static string MinInvokeCount;
    public static string EvaluateOverhead;
    public static string OutlierMode;
    public static string AnalyzeLaunchVariance;
    public static string Platform;
    public static string Jit;
    public static string Runtime;
    public static string Affinity;
    public static string Gc;
    public static string EnvironmentVariables;
    public static string PowerPlanMode;
    public static string Server;
    public static string Concurrent;
    public static string CpuGroups;
    public static string Force;
    public static string AllowVeryLargeObjects;
    public static string RetainVm;
    public static string NoAffinitize;
    public static string HeapAffinitizeMask;
    public static string HeapCount;
    public static string Toolchain;
    public static string Clock;
    public static string EngineFactory;
    public static string BuildConfiguration;
    public static string Arguments;
    public static string NuGetReferences;
    public static string Environment;
    public static string Run;
    public static string Infrastructure;
    public static string Accuracy;
    public static string Meta;
    public static string Baseline;
    public static string IsMutator;
    public static string IsDefault;
    public static string RunStrategy;
    public static string LaunchCount;
    public static string InvocationCount;
    public static string UnrollFactor;
    public static string IterationCount;
    public static string MinIterationCount;
    public static string MaxIterationCount;
    public static string IterationTime;
    public static string WarmupCount;
    public static string MinWarmupIterationCount;
    public static string MaxWarmupIterationCount;
    public static string MemoryRandomization;
}
public enum BenchmarkDotNet.Columns.ColumnCategory : Enum {
    public int value__;
    public static ColumnCategory Job;
    public static ColumnCategory Params;
    public static ColumnCategory Statistics;
    public static ColumnCategory Baseline;
    public static ColumnCategory Custom;
    public static ColumnCategory Meta;
    public static ColumnCategory Metric;
}
[ExtensionAttribute]
public static class BenchmarkDotNet.Columns.ColumnExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IColumnProvider ToProvider(IColumn column);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Columns.ColumnHidingByIdRule : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    public ColumnHidingByIdRule(IColumn column);
    [CompilerGeneratedAttribute]
public string get_Id();
    public sealed virtual bool NeedToHide(IColumn column);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Columns.ColumnHidingByNameRule : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public ColumnHidingByNameRule(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual bool NeedToHide(IColumn column);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.CompositeColumnProvider : object {
    private IColumnProvider[] providers;
    public CompositeColumnProvider(IColumnProvider[] providers);
    public sealed virtual IEnumerable`1<IColumn> GetColumns(Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Columns.DefaultColumnProviders : object {
    [PublicAPIAttribute]
public static IColumnProvider Descriptor;
    [PublicAPIAttribute]
public static IColumnProvider Job;
    [PublicAPIAttribute]
public static IColumnProvider Statistics;
    [PublicAPIAttribute]
public static IColumnProvider Params;
    [PublicAPIAttribute]
public static IColumnProvider Metrics;
    public static IColumnProvider[] Instance;
    private static DefaultColumnProviders();
}
public class BenchmarkDotNet.Columns.EmptyColumnProvider : object {
    [NullableAttribute("1")]
public static IColumnProvider Instance;
    private static EmptyColumnProvider();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<IColumn> GetColumns(Summary summary);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Columns.IColumn {
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_ColumnName();
    public abstract virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public abstract virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public abstract virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    public abstract virtual bool IsAvailable(Summary summary);
    public abstract virtual bool get_AlwaysShow();
    public abstract virtual ColumnCategory get_Category();
    public abstract virtual int get_PriorityInCategory();
    public abstract virtual bool get_IsNumeric();
    public abstract virtual UnitType get_UnitType();
    public abstract virtual string get_Legend();
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Columns.IColumnHidingRule {
    public abstract virtual bool NeedToHide(IColumn column);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Columns.IColumnProvider {
    public abstract virtual IEnumerable`1<IColumn> GetColumns(Summary summary);
}
public interface BenchmarkDotNet.Columns.IStatisticColumn {
    [NullableContextAttribute("1")]
public abstract virtual List`1<double> GetAllValues(Summary summary, SummaryStyle style);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.JobCharacteristicColumn : object {
    private static CharacteristicPresenter Presenter;
    private Characteristic characteristic;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    private static Lazy`1<IColumn[]> LazyAllColumns;
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public static IColumn[] AllColumns { get; }
    public string Legend { get; }
    private JobCharacteristicColumn(Characteristic characteristic);
    private static JobCharacteristicColumn();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool get_IsNumeric();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public static IColumn[] get_AllColumns();
    public sealed virtual string get_Legend();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.LogicalGroupColumn : object {
    [PublicAPIAttribute]
public static IColumn Default;
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    private static LogicalGroupColumn();
    public sealed virtual string get_Id();
    public sealed virtual string get_ColumnName();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool get_IsNumeric();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string get_Legend();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.MetricColumn : object {
    internal static string UnknownRepresentation;
    private IMetricDescriptor descriptor;
    public string Id { get; }
    public string ColumnName { get; }
    public string Legend { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public MetricColumn(IMetricDescriptor metricDescriptor);
    public sealed virtual string get_Id();
    public sealed virtual string get_ColumnName();
    public sealed virtual string get_Legend();
    public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool get_IsNumeric();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <IsAvailable>b__20_0(BenchmarkReport report);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.ParamColumn : object {
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PriorityInCategory>k__BackingField;
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; private set; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    public ParamColumn(string columnName, int priorityInCategory);
    public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PriorityInCategory();
    [CompilerGeneratedAttribute]
private void set_PriorityInCategory(int value);
    public virtual string ToString();
    public sealed virtual bool get_IsNumeric();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public sealed virtual string get_Legend();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetValue>b__7_0(ParameterInstance item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.RankColumn : object {
    private NumeralSystem numeralSystem;
    [PublicAPIAttribute]
public static IColumn Arabic;
    [PublicAPIAttribute]
public static IColumn Roman;
    [PublicAPIAttribute]
public static IColumn Stars;
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public int PriorityInCategory { get; }
    public string Legend { get; }
    public RankColumn(NumeralSystem system);
    private static RankColumn();
    public sealed virtual string get_Id();
    public sealed virtual string get_ColumnName();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    public sealed virtual bool get_IsNumeric();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public sealed virtual int get_PriorityInCategory();
    public virtual string ToString();
    public sealed virtual string get_Legend();
}
public enum BenchmarkDotNet.Columns.RatioStyle : Enum {
    public int value__;
    public static RatioStyle Value;
    public static RatioStyle Percentage;
    public static RatioStyle Trend;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.SimpleColumnProvider : object {
    private IColumn[] columns;
    public SimpleColumnProvider(IColumn[] columns);
    public sealed virtual IEnumerable`1<IColumn> GetColumns(Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.StatisticalTestColumn : BaselineCustomColumn {
    private static SignificanceLevel DefaultSignificanceLevel;
    [CompilerGeneratedAttribute]
private Threshold <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private SignificanceLevel <SignificanceLevel>k__BackingField;
    public Threshold Threshold { get; }
    public SignificanceLevel SignificanceLevel { get; }
    public string Id { get; }
    public string ColumnName { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    public StatisticalTestColumn(Threshold threshold, Nullable`1<SignificanceLevel> significanceLevel);
    private static StatisticalTestColumn();
    public static StatisticalTestColumn CreateDefault();
    public static StatisticalTestColumn Create(Threshold threshold, Nullable`1<SignificanceLevel> significanceLevel);
    public static StatisticalTestColumn Create(string threshold, Nullable`1<SignificanceLevel> significanceLevel);
    [CompilerGeneratedAttribute]
public Threshold get_Threshold();
    [CompilerGeneratedAttribute]
public SignificanceLevel get_SignificanceLevel();
    public virtual string get_Id();
    public virtual string get_ColumnName();
    public virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary`2<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary`2<string, Metric> currentMetrics, bool isBaseline);
    public virtual int get_PriorityInCategory();
    public virtual bool get_IsNumeric();
    public virtual UnitType get_UnitType();
    public virtual string get_Legend();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.StatisticColumn : object {
    public static IStatisticColumn Mean;
    public static IColumn StdErr;
    public static IColumn StdDev;
    public static IColumn Error;
    public static IColumn OperationsPerSecond;
    public static IColumn Min;
    public static IColumn Q1;
    public static IColumn Median;
    public static IColumn Q3;
    public static IColumn Max;
    public static IColumn Skewness;
    public static IColumn Kurtosis;
    public static IColumn MValue;
    public static IColumn Iterations;
    public static IColumn P0;
    public static IColumn P25;
    public static IColumn P50;
    public static IColumn P67;
    public static IColumn P80;
    public static IColumn P85;
    public static IColumn P90;
    public static IColumn P95;
    public static IColumn P100;
    public static IColumn[] AllStatistics;
    private Func`2<Statistics, double> calc;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    private Priority priority;
    private IStatisticColumn parentColumn;
    [CompilerGeneratedAttribute]
private UnitType <UnitType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Legend>k__BackingField;
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    private StatisticColumn(string columnName, string legend, Func`2<Statistics, double> calc, Priority priority, UnitType type, IStatisticColumn parentColumn);
    private static StatisticColumn();
    [PublicAPIAttribute]
public static IColumn CiLower(ConfidenceLevel level);
    [PublicAPIAttribute]
public static IColumn CiUpper(ConfidenceLevel level);
    [PublicAPIAttribute]
public static IColumn CiError(ConfidenceLevel level);
    public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool get_IsNumeric();
    [CompilerGeneratedAttribute]
public sealed virtual UnitType get_UnitType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Legend();
    public sealed virtual List`1<double> GetAllValues(Summary summary, SummaryStyle style);
    private string Format(Summary summary, ImmutableConfig config, Statistics statistics, SummaryStyle style);
    public virtual string ToString();
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    private static IColumn CreatePercentileColumn(int percentiles, string columnName, Func`2<Statistics, double> calc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.TagColumn : object {
    private Func`2<string, string> getTag;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    public TagColumn(string columnName, Func`2<string, string> getTag);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsAvailable(Summary summary);
    public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool get_IsNumeric();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string get_Legend();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Columns.TargetMethodColumn : object {
    public static IColumn Namespace;
    public static IColumn Type;
    public static IColumn Method;
    private Func`2<BenchmarkCase, string> valueProvider;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysShow>k__BackingField;
    public string Id { get; }
    public string ColumnName { get; }
    public bool AlwaysShow { get; }
    public ColumnCategory Category { get; }
    public int PriorityInCategory { get; }
    public bool IsNumeric { get; }
    public UnitType UnitType { get; }
    public string Legend { get; }
    private TargetMethodColumn(string columnName, Func`2<BenchmarkCase, string> valueProvider, bool alwaysShow);
    private static TargetMethodColumn();
    public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase);
    public sealed virtual bool IsAvailable(Summary summary);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AlwaysShow();
    public sealed virtual ColumnCategory get_Category();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool get_IsNumeric();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string get_Legend();
    public sealed virtual string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style);
    public virtual string ToString();
    public sealed virtual bool IsDefault(Summary summary, BenchmarkCase benchmarkCase);
}
public enum BenchmarkDotNet.Columns.UnitType : Enum {
    public int value__;
    public static UnitType Dimensionless;
    public static UnitType Time;
    public static UnitType Size;
    public static UnitType CodeSize;
}
public enum BenchmarkDotNet.Configs.BenchmarkLogicalGroupRule : Enum {
    public int value__;
    public static BenchmarkLogicalGroupRule ByMethod;
    public static BenchmarkLogicalGroupRule ByJob;
    public static BenchmarkLogicalGroupRule ByParams;
    public static BenchmarkLogicalGroupRule ByCategory;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Configs.ConfigExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddColumn() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, IColumn[] columns);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddColumn(IConfig config, IColumn[] columns);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddColumnProvider() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, IColumnProvider[] columnProviders);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddColumnProvider(IConfig config, IColumnProvider[] columnProviders);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddLogger() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, ILogger[] loggers);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddLogger(IConfig config, ILogger[] loggers);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddExporter() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, IExporter[] exporters);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddExporter(IConfig config, IExporter[] exporters);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddDiagnoser() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, IDiagnoser[] diagnosers);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddDiagnoser(IConfig config, IDiagnoser[] diagnosers);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddAnalyser() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, IAnalyser[] analysers);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddAnalyser(IConfig config, IAnalyser[] analysers);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddValidator() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, IValidator[] validators);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddValidator(IConfig config, IValidator[] validators);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddJob() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, Job[] jobs);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddJob(IConfig config, Job job);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .WithOrderer() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, IOrderer orderer);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig WithOrderer(IConfig config, IOrderer orderer);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddHardwareCounters() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, HardwareCounter[] counters);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddHardwareCounters(IConfig config, HardwareCounter[] counters);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddFilter() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, IFilter[] filters);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddFilter(IConfig config, IFilter[] filters);
    [ExtensionAttribute]
[ObsoleteAttribute("To enable unicode support, use .AddLogger(ConsoleLogger.Unicode)")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, Encoding encoding);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .WithSummaryStyle() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, SummaryStyle summaryStyle);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig WithSummaryStyle(IConfig config, SummaryStyle summaryStyle);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig WithArtifactsPath(IConfig config, string artifactsPath);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig WithUnionRule(IConfig config, ConfigUnionRule unionRule);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig WithCultureInfo(IConfig config, CultureInfo cultureInfo);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static IConfig KeepBenchmarkFiles(IConfig config, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static IConfig DontOverwriteResults(IConfig config, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static IConfig StopOnFirstError(IConfig config, bool value);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .WithOptions() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, ConfigOptions options);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig WithOption(IConfig config, ConfigOptions option, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig WithOptions(IConfig config, ConfigOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("This method will soon be removed, please start using .AddLogicalGroupRules() instead.")]
[EditorBrowsableAttribute("1")]
public static IConfig With(IConfig config, BenchmarkLogicalGroupRule[] rules);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddLogicalGroupRules(IConfig config, BenchmarkLogicalGroupRule[] rules);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig AddEventProcessor(IConfig config, EventProcessor[] eventProcessors);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig HideColumns(IConfig config, String[] columnNames);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig HideColumns(IConfig config, IColumn[] columns);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static ManualConfig HideColumns(IConfig config, IColumnHidingRule[] rules);
    [ExtensionAttribute]
public static ImmutableConfig CreateImmutableConfig(IConfig config);
    [ExtensionAttribute]
internal static ILogger GetNonNullCompositeLogger(IConfig config);
    [ExtensionAttribute]
private static ManualConfig With(IConfig config, Action`1<ManualConfig> addAction);
}
[FlagsAttribute]
public enum BenchmarkDotNet.Configs.ConfigOptions : Enum {
    public int value__;
    public static ConfigOptions Default;
    public static ConfigOptions KeepBenchmarkFiles;
    public static ConfigOptions JoinSummary;
    public static ConfigOptions StopOnFirstError;
    public static ConfigOptions DisableOptimizationsValidator;
    public static ConfigOptions DontOverwriteResults;
    public static ConfigOptions DisableLogFile;
    public static ConfigOptions LogBuildOutput;
    public static ConfigOptions GenerateMSBuildBinLog;
    public static ConfigOptions ApplesToApples;
    public static ConfigOptions Resume;
}
[ExtensionAttribute]
internal static class BenchmarkDotNet.Configs.ConfigOptionsExtensions : object {
    [ExtensionAttribute]
internal static bool IsSet(ConfigOptions currentValue, ConfigOptions flag);
    [ExtensionAttribute]
internal static ConfigOptions Set(ConfigOptions currentValue, bool value, ConfigOptions flag);
}
public enum BenchmarkDotNet.Configs.ConfigUnionRule : Enum {
    public int value__;
    public static ConfigUnionRule Union;
    public static ConfigUnionRule AlwaysUseLocal;
    public static ConfigUnionRule AlwaysUseGlobal;
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Configs.DebugBuildConfig : DebugConfig {
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<Job> GetJobs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Configs.DebugConfig : object {
    private static Conclusion[] emptyConclusion;
    public IOrderer Orderer { get; }
    [NullableAttribute("2")]
public ICategoryDiscoverer CategoryDiscoverer { get; }
    public SummaryStyle SummaryStyle { get; }
    public ConfigUnionRule UnionRule { get; }
    public TimeSpan BuildTimeout { get; }
    public string ArtifactsPath { get; }
    public CultureInfo CultureInfo { get; }
    public ConfigOptions Options { get; }
    public IReadOnlyList`1<Conclusion> ConfigAnalysisConclusion { get; }
    private static DebugConfig();
    public abstract virtual IEnumerable`1<Job> GetJobs();
    public sealed virtual IEnumerable`1<IValidator> GetValidators();
    public sealed virtual IEnumerable`1<IColumnProvider> GetColumnProviders();
    public sealed virtual IEnumerable`1<IExporter> GetExporters();
    public sealed virtual IEnumerable`1<ILogger> GetLoggers();
    public sealed virtual IEnumerable`1<IDiagnoser> GetDiagnosers();
    public sealed virtual IEnumerable`1<IAnalyser> GetAnalysers();
    public sealed virtual IEnumerable`1<HardwareCounter> GetHardwareCounters();
    public sealed virtual IEnumerable`1<EventProcessor> GetEventProcessors();
    public sealed virtual IEnumerable`1<IFilter> GetFilters();
    public sealed virtual IEnumerable`1<IColumnHidingRule> GetColumnHidingRules();
    public sealed virtual IOrderer get_Orderer();
    [NullableContextAttribute("2")]
public sealed virtual ICategoryDiscoverer get_CategoryDiscoverer();
    public sealed virtual SummaryStyle get_SummaryStyle();
    public sealed virtual ConfigUnionRule get_UnionRule();
    public sealed virtual TimeSpan get_BuildTimeout();
    public sealed virtual string get_ArtifactsPath();
    public sealed virtual CultureInfo get_CultureInfo();
    public sealed virtual IEnumerable`1<BenchmarkLogicalGroupRule> GetLogicalGroupRules();
    public sealed virtual ConfigOptions get_Options();
    public sealed virtual IReadOnlyList`1<Conclusion> get_ConfigAnalysisConclusion();
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Configs.DebugInProcessConfig : DebugConfig {
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<Job> GetJobs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Configs.DefaultConfig : object {
    public static IConfig Instance;
    private static Conclusion[] emptyConclusion;
    public IOrderer Orderer { get; }
    [NullableAttribute("2")]
public ICategoryDiscoverer CategoryDiscoverer { get; }
    public ConfigUnionRule UnionRule { get; }
    public CultureInfo CultureInfo { get; }
    public ConfigOptions Options { get; }
    public SummaryStyle SummaryStyle { get; }
    public TimeSpan BuildTimeout { get; }
    public string ArtifactsPath { get; }
    public IReadOnlyList`1<Conclusion> ConfigAnalysisConclusion { get; }
    private static DefaultConfig();
    public sealed virtual IEnumerable`1<IColumnProvider> GetColumnProviders();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Configs.DefaultConfig/<GetExporters>d__4")]
public sealed virtual IEnumerable`1<IExporter> GetExporters();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Configs.DefaultConfig/<GetLoggers>d__5")]
public sealed virtual IEnumerable`1<ILogger> GetLoggers();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Configs.DefaultConfig/<GetAnalysers>d__6")]
public sealed virtual IEnumerable`1<IAnalyser> GetAnalysers();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Configs.DefaultConfig/<GetValidators>d__7")]
public sealed virtual IEnumerable`1<IValidator> GetValidators();
    public sealed virtual IOrderer get_Orderer();
    [NullableContextAttribute("2")]
public sealed virtual ICategoryDiscoverer get_CategoryDiscoverer();
    public sealed virtual ConfigUnionRule get_UnionRule();
    public sealed virtual CultureInfo get_CultureInfo();
    public sealed virtual ConfigOptions get_Options();
    public sealed virtual SummaryStyle get_SummaryStyle();
    public sealed virtual TimeSpan get_BuildTimeout();
    public sealed virtual string get_ArtifactsPath();
    public sealed virtual IReadOnlyList`1<Conclusion> get_ConfigAnalysisConclusion();
    public sealed virtual IEnumerable`1<Job> GetJobs();
    public sealed virtual IEnumerable`1<BenchmarkLogicalGroupRule> GetLogicalGroupRules();
    public sealed virtual IEnumerable`1<IDiagnoser> GetDiagnosers();
    public sealed virtual IEnumerable`1<HardwareCounter> GetHardwareCounters();
    public sealed virtual IEnumerable`1<IFilter> GetFilters();
    public sealed virtual IEnumerable`1<EventProcessor> GetEventProcessors();
    public sealed virtual IEnumerable`1<IColumnHidingRule> GetColumnHidingRules();
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Configs.IConfig {
    [NullableAttribute("2")]
public IOrderer Orderer { get; }
    [NullableAttribute("2")]
public ICategoryDiscoverer CategoryDiscoverer { get; }
    public SummaryStyle SummaryStyle { get; }
    public ConfigUnionRule UnionRule { get; }
    public string ArtifactsPath { get; }
    [NullableAttribute("2")]
public CultureInfo CultureInfo { get; }
    public ConfigOptions Options { get; }
    public TimeSpan BuildTimeout { get; }
    public IReadOnlyList`1<Conclusion> ConfigAnalysisConclusion { get; }
    public abstract virtual IEnumerable`1<IColumnProvider> GetColumnProviders();
    public abstract virtual IEnumerable`1<IExporter> GetExporters();
    public abstract virtual IEnumerable`1<ILogger> GetLoggers();
    public abstract virtual IEnumerable`1<IDiagnoser> GetDiagnosers();
    public abstract virtual IEnumerable`1<IAnalyser> GetAnalysers();
    public abstract virtual IEnumerable`1<Job> GetJobs();
    public abstract virtual IEnumerable`1<IValidator> GetValidators();
    public abstract virtual IEnumerable`1<HardwareCounter> GetHardwareCounters();
    public abstract virtual IEnumerable`1<IFilter> GetFilters();
    public abstract virtual IEnumerable`1<BenchmarkLogicalGroupRule> GetLogicalGroupRules();
    public abstract virtual IEnumerable`1<EventProcessor> GetEventProcessors();
    public abstract virtual IEnumerable`1<IColumnHidingRule> GetColumnHidingRules();
    [NullableContextAttribute("2")]
public abstract virtual IOrderer get_Orderer();
    [NullableContextAttribute("2")]
public abstract virtual ICategoryDiscoverer get_CategoryDiscoverer();
    public abstract virtual SummaryStyle get_SummaryStyle();
    public abstract virtual ConfigUnionRule get_UnionRule();
    public abstract virtual string get_ArtifactsPath();
    [NullableContextAttribute("2")]
public abstract virtual CultureInfo get_CultureInfo();
    public abstract virtual ConfigOptions get_Options();
    public abstract virtual TimeSpan get_BuildTimeout();
    public abstract virtual IReadOnlyList`1<Conclusion> get_ConfigAnalysisConclusion();
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Configs.IConfigSource {
    public IConfig Config { get; }
    public abstract virtual IConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Configs.ImmutableConfig : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IColumnProvider> columnProviders;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IExporter> exporters;
    private ImmutableHashSet`1<ILogger> loggers;
    private ImmutableHashSet`1<IDiagnoser> diagnosers;
    private ImmutableHashSet`1<IAnalyser> analysers;
    private ImmutableHashSet`1<IValidator> validators;
    private ImmutableHashSet`1<Job> jobs;
    private ImmutableHashSet`1<HardwareCounter> hardwareCounters;
    private ImmutableHashSet`1<IFilter> filters;
    [NullableAttribute("0")]
private ImmutableArray`1<BenchmarkLogicalGroupRule> rules;
    private ImmutableHashSet`1<EventProcessor> eventProcessors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IColumnHidingRule> columnHidingRules;
    [CompilerGeneratedAttribute]
private ConfigUnionRule <UnionRule>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArtifactsPath>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IOrderer <Orderer>k__BackingField;
    [CompilerGeneratedAttribute]
private ICategoryDiscoverer <CategoryDiscoverer>k__BackingField;
    [CompilerGeneratedAttribute]
private SummaryStyle <SummaryStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <BuildTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Conclusion> <ConfigAnalysisConclusion>k__BackingField;
    public ConfigUnionRule UnionRule { get; }
    public string ArtifactsPath { get; }
    public CultureInfo CultureInfo { get; }
    public ConfigOptions Options { get; }
    public IOrderer Orderer { get; }
    public ICategoryDiscoverer CategoryDiscoverer { get; }
    public SummaryStyle SummaryStyle { get; }
    public TimeSpan BuildTimeout { get; }
    public IReadOnlyList`1<Conclusion> ConfigAnalysisConclusion { get; private set; }
    internal ImmutableConfig(ImmutableArray`1<IColumnProvider> uniqueColumnProviders, ImmutableHashSet`1<ILogger> uniqueLoggers, ImmutableHashSet`1<HardwareCounter> uniqueHardwareCounters, ImmutableHashSet`1<IDiagnoser> uniqueDiagnosers, ImmutableArray`1<IExporter> uniqueExporters, ImmutableHashSet`1<IAnalyser> uniqueAnalyzers, ImmutableHashSet`1<IValidator> uniqueValidators, ImmutableHashSet`1<IFilter> uniqueFilters, ImmutableArray`1<BenchmarkLogicalGroupRule> uniqueRules, ImmutableArray`1<IColumnHidingRule> uniqueColumnHidingRules, ImmutableHashSet`1<Job> uniqueRunnableJobs, ImmutableHashSet`1<EventProcessor> uniqueEventProcessors, ConfigUnionRule unionRule, string artifactsPath, CultureInfo cultureInfo, IOrderer orderer, ICategoryDiscoverer categoryDiscoverer, SummaryStyle summaryStyle, ConfigOptions options, TimeSpan buildTimeout, IReadOnlyList`1<Conclusion> configAnalysisConclusion);
    [CompilerGeneratedAttribute]
public sealed virtual ConfigUnionRule get_UnionRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ArtifactsPath();
    [CompilerGeneratedAttribute]
public sealed virtual CultureInfo get_CultureInfo();
    [CompilerGeneratedAttribute]
public sealed virtual ConfigOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual IOrderer get_Orderer();
    [CompilerGeneratedAttribute]
public sealed virtual ICategoryDiscoverer get_CategoryDiscoverer();
    [CompilerGeneratedAttribute]
public sealed virtual SummaryStyle get_SummaryStyle();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_BuildTimeout();
    public sealed virtual IEnumerable`1<IColumnProvider> GetColumnProviders();
    public sealed virtual IEnumerable`1<IExporter> GetExporters();
    public sealed virtual IEnumerable`1<ILogger> GetLoggers();
    public sealed virtual IEnumerable`1<IDiagnoser> GetDiagnosers();
    public sealed virtual IEnumerable`1<IAnalyser> GetAnalysers();
    public sealed virtual IEnumerable`1<Job> GetJobs();
    public sealed virtual IEnumerable`1<IValidator> GetValidators();
    public sealed virtual IEnumerable`1<HardwareCounter> GetHardwareCounters();
    public sealed virtual IEnumerable`1<IFilter> GetFilters();
    public sealed virtual IEnumerable`1<BenchmarkLogicalGroupRule> GetLogicalGroupRules();
    public sealed virtual IEnumerable`1<EventProcessor> GetEventProcessors();
    public sealed virtual IEnumerable`1<IColumnHidingRule> GetColumnHidingRules();
    public ILogger GetCompositeLogger();
    public IExporter GetCompositeExporter();
    public IValidator GetCompositeValidator();
    public IAnalyser GetCompositeAnalyser();
    public IDiagnoser GetCompositeDiagnoser();
    public bool HasMemoryDiagnoser();
    public bool HasThreadingDiagnoser();
    public bool HasExceptionDiagnoser();
    internal bool HasPerfCollectProfiler();
    public bool HasExtraStatsDiagnoser();
    public IDiagnoser GetCompositeDiagnoser(BenchmarkCase benchmarkCase, RunMode runMode);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<Conclusion> get_ConfigAnalysisConclusion();
    [CompilerGeneratedAttribute]
private void set_ConfigAnalysisConclusion(IReadOnlyList`1<Conclusion> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Configs.ImmutableConfigBuilder : object {
    private static IValidator[] MandatoryValidators;
    private static ImmutableConfigBuilder();
    public static ImmutableConfig Create(IConfig source);
    private static ImmutableHashSet`1<IDiagnoser> GetDiagnosers(IEnumerable`1<IDiagnoser> diagnosers, ImmutableHashSet`1<HardwareCounter> uniqueHardwareCounters);
    private static ImmutableArray`1<IExporter> GetExporters(IEnumerable`1<IExporter> exporters, ImmutableHashSet`1<IDiagnoser> uniqueDiagnosers, IList`1<Conclusion> configAnalyse);
    private static ImmutableHashSet`1<IAnalyser> GetAnalysers(IEnumerable`1<IAnalyser> analysers, ImmutableHashSet`1<IDiagnoser> uniqueDiagnosers);
    private static ImmutableHashSet`1<IValidator> GetValidators(IEnumerable`1<IValidator> configuredValidators, IValidator[] mandatoryValidators, ConfigOptions options);
    private static IReadOnlyList`1<Job> GetRunnableJobs(IEnumerable`1<Job> jobs);
    [CompilerGeneratedAttribute]
internal static void <GetExporters>g__AddWarning|3_0(string message, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Configs.ManualConfig : object {
    private static Conclusion[] emptyConclusion;
    private List`1<IColumnProvider> columnProviders;
    private List`1<IExporter> exporters;
    private List`1<ILogger> loggers;
    private List`1<IDiagnoser> diagnosers;
    private List`1<IAnalyser> analysers;
    private List`1<IValidator> validators;
    private List`1<Job> jobs;
    private HashSet`1<HardwareCounter> hardwareCounters;
    private List`1<IFilter> filters;
    private List`1<BenchmarkLogicalGroupRule> logicalGroupRules;
    private List`1<EventProcessor> eventProcessors;
    private List`1<IColumnHidingRule> columnHidingRules;
    [CompilerGeneratedAttribute]
private ConfigOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigUnionRule <UnionRule>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArtifactsPath>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IOrderer <Orderer>k__BackingField;
    [CompilerGeneratedAttribute]
private ICategoryDiscoverer <CategoryDiscoverer>k__BackingField;
    [CompilerGeneratedAttribute]
private SummaryStyle <SummaryStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <BuildTimeout>k__BackingField;
    [PublicAPIAttribute]
public ConfigOptions Options { get; public set; }
    [PublicAPIAttribute]
public ConfigUnionRule UnionRule { get; public set; }
    [PublicAPIAttribute]
public string ArtifactsPath { get; public set; }
    [PublicAPIAttribute]
public CultureInfo CultureInfo { get; public set; }
    [PublicAPIAttribute]
public IOrderer Orderer { get; public set; }
    [PublicAPIAttribute]
public ICategoryDiscoverer CategoryDiscoverer { get; public set; }
    [PublicAPIAttribute]
public SummaryStyle SummaryStyle { get; public set; }
    [PublicAPIAttribute]
public TimeSpan BuildTimeout { get; public set; }
    public IReadOnlyList`1<Conclusion> ConfigAnalysisConclusion { get; }
    private static ManualConfig();
    public sealed virtual IEnumerable`1<IColumnProvider> GetColumnProviders();
    public sealed virtual IEnumerable`1<IExporter> GetExporters();
    public sealed virtual IEnumerable`1<ILogger> GetLoggers();
    public sealed virtual IEnumerable`1<IDiagnoser> GetDiagnosers();
    public sealed virtual IEnumerable`1<IAnalyser> GetAnalysers();
    public sealed virtual IEnumerable`1<IValidator> GetValidators();
    public sealed virtual IEnumerable`1<Job> GetJobs();
    public sealed virtual IEnumerable`1<HardwareCounter> GetHardwareCounters();
    public sealed virtual IEnumerable`1<IFilter> GetFilters();
    public sealed virtual IEnumerable`1<BenchmarkLogicalGroupRule> GetLogicalGroupRules();
    public sealed virtual IEnumerable`1<EventProcessor> GetEventProcessors();
    public sealed virtual IEnumerable`1<IColumnHidingRule> GetColumnHidingRules();
    [CompilerGeneratedAttribute]
public sealed virtual ConfigOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(ConfigOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual ConfigUnionRule get_UnionRule();
    [CompilerGeneratedAttribute]
public void set_UnionRule(ConfigUnionRule value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ArtifactsPath();
    [CompilerGeneratedAttribute]
public void set_ArtifactsPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual CultureInfo get_CultureInfo();
    [CompilerGeneratedAttribute]
public void set_CultureInfo(CultureInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual IOrderer get_Orderer();
    [CompilerGeneratedAttribute]
public void set_Orderer(IOrderer value);
    [CompilerGeneratedAttribute]
public sealed virtual ICategoryDiscoverer get_CategoryDiscoverer();
    [CompilerGeneratedAttribute]
public void set_CategoryDiscoverer(ICategoryDiscoverer value);
    [CompilerGeneratedAttribute]
public sealed virtual SummaryStyle get_SummaryStyle();
    [CompilerGeneratedAttribute]
public void set_SummaryStyle(SummaryStyle value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_BuildTimeout();
    [CompilerGeneratedAttribute]
public void set_BuildTimeout(TimeSpan value);
    public sealed virtual IReadOnlyList`1<Conclusion> get_ConfigAnalysisConclusion();
    public ManualConfig WithOption(ConfigOptions option, bool value);
    public ManualConfig WithOptions(ConfigOptions options);
    public ManualConfig WithUnionRule(ConfigUnionRule unionRule);
    public ManualConfig WithArtifactsPath(string artifactsPath);
    public ManualConfig WithSummaryStyle(SummaryStyle summaryStyle);
    public ManualConfig WithOrderer(IOrderer orderer);
    public ManualConfig WithCategoryDiscoverer(ICategoryDiscoverer categoryDiscoverer);
    public ManualConfig WithBuildTimeout(TimeSpan buildTimeout);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddColumn() instead.")]
public void Add(IColumn[] newColumns);
    public ManualConfig AddColumn(IColumn[] newColumns);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddColumnProvider() instead.")]
public void Add(IColumnProvider[] newColumnProviders);
    public ManualConfig AddColumnProvider(IColumnProvider[] newColumnProviders);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddExporter() instead.")]
public void Add(IExporter[] newExporters);
    public ManualConfig AddExporter(IExporter[] newExporters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddLogger() instead.")]
public void Add(ILogger[] newLoggers);
    public ManualConfig AddLogger(ILogger[] newLoggers);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddDiagnoser() instead.")]
public void Add(IDiagnoser[] newDiagnosers);
    public ManualConfig AddDiagnoser(IDiagnoser[] newDiagnosers);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddAnalyser() instead.")]
public void Add(IAnalyser[] newAnalysers);
    public ManualConfig AddAnalyser(IAnalyser[] newAnalysers);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddValidator() instead.")]
public void Add(IValidator[] newValidators);
    public ManualConfig AddValidator(IValidator[] newValidators);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddJob() instead.")]
public void Add(Job[] newJobs);
    public ManualConfig AddJob(Job[] newJobs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using ..AddHardwareCounters()() instead.")]
public void Add(HardwareCounter[] newHardwareCounters);
    public ManualConfig AddHardwareCounters(HardwareCounter[] newHardwareCounters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddFilter() instead.")]
public void Add(IFilter[] newFilters);
    public ManualConfig AddFilter(IFilter[] newFilters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .AddLogicalGroupRules() instead.")]
public void Add(BenchmarkLogicalGroupRule[] rules);
    public ManualConfig AddLogicalGroupRules(BenchmarkLogicalGroupRule[] rules);
    public ManualConfig AddEventProcessor(EventProcessor[] newEventProcessors);
    [PublicAPIAttribute]
public ManualConfig HideColumns(String[] columnNames);
    [PublicAPIAttribute]
public ManualConfig HideColumns(IColumn[] columns);
    [PublicAPIAttribute]
public ManualConfig HideColumns(IColumnHidingRule[] rules);
    [PublicAPIAttribute]
public void Add(IConfig config);
    public static ManualConfig CreateEmpty();
    public static ManualConfig CreateMinimumViable();
    public static ManualConfig Create(IConfig config);
    public static ManualConfig Union(IConfig globalConfig, IConfig localConfig);
    internal void RemoveAllJobs();
    internal void RemoveAllDiagnosers();
    private static TimeSpan GetBuildTimeout(TimeSpan current, TimeSpan other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.ConsoleArguments.CommandLineOptions : object {
    private static int DefaultDisassemblerRecursiveDepth;
    private bool useDisassemblyDiagnoser;
    [CompilerGeneratedAttribute]
private string <BaseJob>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Runtimes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Exporters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseMemoryDiagnoser>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseThreadingDiagnoser>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseExceptionDiagnoser>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Profiler>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <HiddenColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunInProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryInfo <ArtifactsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private OutlierMode <Outliers>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Affinity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayAllStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <AllCategories>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <AnyCategories>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <AttributeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Join>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepBenchmarkFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DontOverwriteResults>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <HardwareCounters>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfo <CliPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryInfo <RestorePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FileInfo> <CoreRunPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfo <MonoPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ILCompilerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryInfo <IlcPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LaunchCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <WarmupIterationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinWarmupIterationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxWarmupIterationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <IterationTimeInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <IterationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinIterationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxIterationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <InvocationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <UnrollFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RunStrategy> <RunStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Platform> <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunOncePerIteration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplesToApples>k__BackingField;
    [CompilerGeneratedAttribute]
private ListBenchmarkCaseMode <ListBenchmarkCaseMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DisassemblerRecursiveDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <DisassemblerFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisassemblerDiff>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogBuildOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMSBuildBinLog>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TimeOutInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopOnFirstError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StatisticalTestThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableLogFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxParameterColumnWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MemoryRandomization>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfo <WasmJavascriptEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WasmJavaScriptEngineArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomRuntimePack>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfo <AOTCompilerPath>k__BackingField;
    [CompilerGeneratedAttribute]
private MonoAotCompilerMode <AOTCompilerMode>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryInfo <WasmDataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoForcedGCs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoEvaluationOverhead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Resume>k__BackingField;
    [OptionAttribute("j", "job")]
public string BaseJob { get; public set; }
    [OptionAttribute("r", "runtimes")]
public IEnumerable`1<string> Runtimes { get; public set; }
    [OptionAttribute("e", "exporters")]
public IEnumerable`1<string> Exporters { get; public set; }
    [OptionAttribute("m", "memory")]
public bool UseMemoryDiagnoser { get; public set; }
    [OptionAttribute("t", "threading")]
public bool UseThreadingDiagnoser { get; public set; }
    [OptionAttribute("exceptions")]
public bool UseExceptionDiagnoser { get; public set; }
    [OptionAttribute("d", "disasm")]
public bool UseDisassemblyDiagnoser { get; public set; }
    [OptionAttribute("p", "profiler")]
public string Profiler { get; public set; }
    [OptionAttribute("f", "filter")]
public IEnumerable`1<string> Filters { get; public set; }
    [OptionAttribute("h", "hide")]
public IEnumerable`1<string> HiddenColumns { get; public set; }
    [OptionAttribute("i", "inProcess")]
public bool RunInProcess { get; public set; }
    [OptionAttribute("a", "artifacts")]
public DirectoryInfo ArtifactsDirectory { get; public set; }
    [OptionAttribute]
public OutlierMode Outliers { get; public set; }
    [OptionAttribute("affinity")]
public Nullable`1<int> Affinity { get; public set; }
    [OptionAttribute("allStats")]
public bool DisplayAllStatistics { get; public set; }
    [OptionAttribute("allCategories")]
public IEnumerable`1<string> AllCategories { get; public set; }
    [OptionAttribute("anyCategories")]
public IEnumerable`1<string> AnyCategories { get; public set; }
    [OptionAttribute("attribute")]
public IEnumerable`1<string> AttributeNames { get; public set; }
    [OptionAttribute("join")]
public bool Join { get; public set; }
    [OptionAttribute("keepFiles")]
public bool KeepBenchmarkFiles { get; public set; }
    [OptionAttribute("noOverwrite")]
public bool DontOverwriteResults { get; public set; }
    [OptionAttribute("counters")]
public IEnumerable`1<string> HardwareCounters { get; public set; }
    [OptionAttribute("cli")]
public FileInfo CliPath { get; public set; }
    [OptionAttribute("packages")]
public DirectoryInfo RestorePath { get; public set; }
    [OptionAttribute("coreRun")]
public IReadOnlyList`1<FileInfo> CoreRunPaths { get; public set; }
    [OptionAttribute("monoPath")]
public FileInfo MonoPath { get; public set; }
    [OptionAttribute("clrVersion")]
public string ClrVersion { get; public set; }
    [OptionAttribute("ilCompilerVersion")]
public string ILCompilerVersion { get; public set; }
    [OptionAttribute("ilcPackages")]
public DirectoryInfo IlcPackages { get; public set; }
    [OptionAttribute("launchCount")]
public Nullable`1<int> LaunchCount { get; public set; }
    [OptionAttribute("warmupCount")]
public Nullable`1<int> WarmupIterationCount { get; public set; }
    [OptionAttribute("minWarmupCount")]
public Nullable`1<int> MinWarmupIterationCount { get; public set; }
    [OptionAttribute("maxWarmupCount")]
public Nullable`1<int> MaxWarmupIterationCount { get; public set; }
    [OptionAttribute("iterationTime")]
public Nullable`1<int> IterationTimeInMilliseconds { get; public set; }
    [OptionAttribute("iterationCount")]
public Nullable`1<int> IterationCount { get; public set; }
    [OptionAttribute("minIterationCount")]
public Nullable`1<int> MinIterationCount { get; public set; }
    [OptionAttribute("maxIterationCount")]
public Nullable`1<int> MaxIterationCount { get; public set; }
    [OptionAttribute("invocationCount")]
public Nullable`1<long> InvocationCount { get; public set; }
    [OptionAttribute("unrollFactor")]
public Nullable`1<int> UnrollFactor { get; public set; }
    [OptionAttribute("strategy")]
public Nullable`1<RunStrategy> RunStrategy { get; public set; }
    [OptionAttribute("platform")]
public Nullable`1<Platform> Platform { get; public set; }
    [OptionAttribute("runOncePerIteration")]
public bool RunOncePerIteration { get; public set; }
    [OptionAttribute("info")]
public bool PrintInformation { get; public set; }
    [OptionAttribute("apples")]
public bool ApplesToApples { get; public set; }
    [OptionAttribute("list")]
public ListBenchmarkCaseMode ListBenchmarkCaseMode { get; public set; }
    [OptionAttribute("disasmDepth")]
public int DisassemblerRecursiveDepth { get; public set; }
    [OptionAttribute("disasmFilter")]
public IEnumerable`1<string> DisassemblerFilters { get; public set; }
    [OptionAttribute("disasmDiff")]
public bool DisassemblerDiff { get; public set; }
    [OptionAttribute("logBuildOutput")]
public bool LogBuildOutput { get; public set; }
    [OptionAttribute("generateBinLog")]
public bool GenerateMSBuildBinLog { get; public set; }
    [OptionAttribute("buildTimeout")]
public Nullable`1<int> TimeOutInSeconds { get; public set; }
    [OptionAttribute("stopOnFirstError")]
public bool StopOnFirstError { get; public set; }
    [OptionAttribute("statisticalTest")]
public string StatisticalTestThreshold { get; public set; }
    [OptionAttribute("disableLogFile")]
public bool DisableLogFile { get; public set; }
    [OptionAttribute("maxWidth")]
public Nullable`1<int> MaxParameterColumnWidth { get; public set; }
    [OptionAttribute("envVars")]
public IEnumerable`1<string> EnvironmentVariables { get; public set; }
    [OptionAttribute("memoryRandomization")]
public bool MemoryRandomization { get; public set; }
    [OptionAttribute("wasmEngine")]
public FileInfo WasmJavascriptEngine { get; public set; }
    [OptionAttribute("wasmArgs")]
public string WasmJavaScriptEngineArguments { get; public set; }
    [OptionAttribute("customRuntimePack")]
public string CustomRuntimePack { get; public set; }
    [OptionAttribute("AOTCompilerPath")]
public FileInfo AOTCompilerPath { get; public set; }
    [OptionAttribute("AOTCompilerMode")]
public MonoAotCompilerMode AOTCompilerMode { get; public set; }
    [OptionAttribute("wasmDataDir")]
public DirectoryInfo WasmDataDirectory { get; public set; }
    [OptionAttribute("noForcedGCs")]
public bool NoForcedGCs { get; public set; }
    [OptionAttribute("noOverheadEvaluation")]
public bool NoEvaluationOverhead { get; public set; }
    [OptionAttribute("resume")]
public bool Resume { get; public set; }
    internal bool UserProvidedFilters { get; }
    [UsageAttribute]
[PublicAPIAttribute]
public static IEnumerable`1<Example> Examples { get; }
    [CompilerGeneratedAttribute]
public string get_BaseJob();
    [CompilerGeneratedAttribute]
public void set_BaseJob(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Runtimes();
    [CompilerGeneratedAttribute]
public void set_Runtimes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Exporters();
    [CompilerGeneratedAttribute]
public void set_Exporters(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_UseMemoryDiagnoser();
    [CompilerGeneratedAttribute]
public void set_UseMemoryDiagnoser(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseThreadingDiagnoser();
    [CompilerGeneratedAttribute]
public void set_UseThreadingDiagnoser(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseExceptionDiagnoser();
    [CompilerGeneratedAttribute]
public void set_UseExceptionDiagnoser(bool value);
    public bool get_UseDisassemblyDiagnoser();
    public void set_UseDisassemblyDiagnoser(bool value);
    [CompilerGeneratedAttribute]
public string get_Profiler();
    [CompilerGeneratedAttribute]
public void set_Profiler(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Filters();
    [CompilerGeneratedAttribute]
public void set_Filters(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_HiddenColumns();
    [CompilerGeneratedAttribute]
public void set_HiddenColumns(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_RunInProcess();
    [CompilerGeneratedAttribute]
public void set_RunInProcess(bool value);
    [CompilerGeneratedAttribute]
public DirectoryInfo get_ArtifactsDirectory();
    [CompilerGeneratedAttribute]
public void set_ArtifactsDirectory(DirectoryInfo value);
    [CompilerGeneratedAttribute]
public OutlierMode get_Outliers();
    [CompilerGeneratedAttribute]
public void set_Outliers(OutlierMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Affinity();
    [CompilerGeneratedAttribute]
public void set_Affinity(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_DisplayAllStatistics();
    [CompilerGeneratedAttribute]
public void set_DisplayAllStatistics(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_AllCategories();
    [CompilerGeneratedAttribute]
public void set_AllCategories(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_AnyCategories();
    [CompilerGeneratedAttribute]
public void set_AnyCategories(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_AttributeNames();
    [CompilerGeneratedAttribute]
public void set_AttributeNames(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_Join();
    [CompilerGeneratedAttribute]
public void set_Join(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepBenchmarkFiles();
    [CompilerGeneratedAttribute]
public void set_KeepBenchmarkFiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_DontOverwriteResults();
    [CompilerGeneratedAttribute]
public void set_DontOverwriteResults(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_HardwareCounters();
    [CompilerGeneratedAttribute]
public void set_HardwareCounters(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public FileInfo get_CliPath();
    [CompilerGeneratedAttribute]
public void set_CliPath(FileInfo value);
    [CompilerGeneratedAttribute]
public DirectoryInfo get_RestorePath();
    [CompilerGeneratedAttribute]
public void set_RestorePath(DirectoryInfo value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FileInfo> get_CoreRunPaths();
    [CompilerGeneratedAttribute]
public void set_CoreRunPaths(IReadOnlyList`1<FileInfo> value);
    [CompilerGeneratedAttribute]
public FileInfo get_MonoPath();
    [CompilerGeneratedAttribute]
public void set_MonoPath(FileInfo value);
    [CompilerGeneratedAttribute]
public string get_ClrVersion();
    [CompilerGeneratedAttribute]
public void set_ClrVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ILCompilerVersion();
    [CompilerGeneratedAttribute]
public void set_ILCompilerVersion(string value);
    [CompilerGeneratedAttribute]
public DirectoryInfo get_IlcPackages();
    [CompilerGeneratedAttribute]
public void set_IlcPackages(DirectoryInfo value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LaunchCount();
    [CompilerGeneratedAttribute]
public void set_LaunchCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_WarmupIterationCount();
    [CompilerGeneratedAttribute]
public void set_WarmupIterationCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinWarmupIterationCount();
    [CompilerGeneratedAttribute]
public void set_MinWarmupIterationCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxWarmupIterationCount();
    [CompilerGeneratedAttribute]
public void set_MaxWarmupIterationCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_IterationTimeInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_IterationTimeInMilliseconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_IterationCount();
    [CompilerGeneratedAttribute]
public void set_IterationCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinIterationCount();
    [CompilerGeneratedAttribute]
public void set_MinIterationCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxIterationCount();
    [CompilerGeneratedAttribute]
public void set_MaxIterationCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_InvocationCount();
    [CompilerGeneratedAttribute]
public void set_InvocationCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_UnrollFactor();
    [CompilerGeneratedAttribute]
public void set_UnrollFactor(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<RunStrategy> get_RunStrategy();
    [CompilerGeneratedAttribute]
public void set_RunStrategy(Nullable`1<RunStrategy> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Platform> get_Platform();
    [CompilerGeneratedAttribute]
public void set_Platform(Nullable`1<Platform> value);
    [CompilerGeneratedAttribute]
public bool get_RunOncePerIteration();
    [CompilerGeneratedAttribute]
public void set_RunOncePerIteration(bool value);
    [CompilerGeneratedAttribute]
public bool get_PrintInformation();
    [CompilerGeneratedAttribute]
public void set_PrintInformation(bool value);
    [CompilerGeneratedAttribute]
public bool get_ApplesToApples();
    [CompilerGeneratedAttribute]
public void set_ApplesToApples(bool value);
    [CompilerGeneratedAttribute]
public ListBenchmarkCaseMode get_ListBenchmarkCaseMode();
    [CompilerGeneratedAttribute]
public void set_ListBenchmarkCaseMode(ListBenchmarkCaseMode value);
    [CompilerGeneratedAttribute]
public int get_DisassemblerRecursiveDepth();
    [CompilerGeneratedAttribute]
public void set_DisassemblerRecursiveDepth(int value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_DisassemblerFilters();
    [CompilerGeneratedAttribute]
public void set_DisassemblerFilters(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_DisassemblerDiff();
    [CompilerGeneratedAttribute]
public void set_DisassemblerDiff(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogBuildOutput();
    [CompilerGeneratedAttribute]
public void set_LogBuildOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateMSBuildBinLog();
    [CompilerGeneratedAttribute]
public void set_GenerateMSBuildBinLog(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TimeOutInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeOutInSeconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_StopOnFirstError();
    [CompilerGeneratedAttribute]
public void set_StopOnFirstError(bool value);
    [CompilerGeneratedAttribute]
public string get_StatisticalTestThreshold();
    [CompilerGeneratedAttribute]
public void set_StatisticalTestThreshold(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableLogFile();
    [CompilerGeneratedAttribute]
public void set_DisableLogFile(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxParameterColumnWidth();
    [CompilerGeneratedAttribute]
public void set_MaxParameterColumnWidth(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_MemoryRandomization();
    [CompilerGeneratedAttribute]
public void set_MemoryRandomization(bool value);
    [CompilerGeneratedAttribute]
public FileInfo get_WasmJavascriptEngine();
    [CompilerGeneratedAttribute]
public void set_WasmJavascriptEngine(FileInfo value);
    [CompilerGeneratedAttribute]
public string get_WasmJavaScriptEngineArguments();
    [CompilerGeneratedAttribute]
public void set_WasmJavaScriptEngineArguments(string value);
    [CompilerGeneratedAttribute]
public string get_CustomRuntimePack();
    [CompilerGeneratedAttribute]
public void set_CustomRuntimePack(string value);
    [CompilerGeneratedAttribute]
public FileInfo get_AOTCompilerPath();
    [CompilerGeneratedAttribute]
public void set_AOTCompilerPath(FileInfo value);
    [CompilerGeneratedAttribute]
public MonoAotCompilerMode get_AOTCompilerMode();
    [CompilerGeneratedAttribute]
public void set_AOTCompilerMode(MonoAotCompilerMode value);
    [CompilerGeneratedAttribute]
public DirectoryInfo get_WasmDataDirectory();
    [CompilerGeneratedAttribute]
public void set_WasmDataDirectory(DirectoryInfo value);
    [CompilerGeneratedAttribute]
public bool get_NoForcedGCs();
    [CompilerGeneratedAttribute]
public void set_NoForcedGCs(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoEvaluationOverhead();
    [CompilerGeneratedAttribute]
public void set_NoEvaluationOverhead(bool value);
    [CompilerGeneratedAttribute]
public bool get_Resume();
    [CompilerGeneratedAttribute]
public void set_Resume(bool value);
    internal bool get_UserProvidedFilters();
    [IteratorStateMachineAttribute("BenchmarkDotNet.ConsoleArguments.CommandLineOptions/<get_Examples>d__268")]
public static IEnumerable`1<Example> get_Examples();
    private static string Escape(string input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.ConsoleArguments.ConfigParser : object {
    private static int MinimumDisplayWidth;
    private static char EnvVarKeyValueSeparator;
    private static IReadOnlyDictionary`2<string, Job> AvailableJobs;
    private static IReadOnlyDictionary`2<string, IExporter[]> AvailableExporters;
    private static ConfigParser();
    public static ValueTuple`3<bool, IConfig, CommandLineOptions> Parse(String[] args, ILogger logger, IConfig globalConfig);
    private static ValueTuple`2<bool, String[]> ExpandResponseFile(String[] args, ILogger logger);
    [IteratorStateMachineAttribute("BenchmarkDotNet.ConsoleArguments.ConfigParser/<ConsumeTokens>d__6")]
private static IEnumerable`1<string> ConsumeTokens(string line);
    internal static bool TryUpdateArgs(String[] args, String[]& updatedArgs, Action`1<CommandLineOptions> updater);
    private static Parser CreateParser(ILogger logger);
    private static bool Validate(CommandLineOptions options, ILogger logger);
    private static IConfig CreateConfig(CommandLineOptions options, IConfig globalConfig, String[] args);
    private static Job GetBaseJob(CommandLineOptions options, IConfig globalConfig);
    [IteratorStateMachineAttribute("BenchmarkDotNet.ConsoleArguments.ConfigParser/<Expand>d__12")]
private static IEnumerable`1<Job> Expand(Job baseJob, CommandLineOptions options, String[] args);
    private static Job CreateJobForGivenRuntime(Job baseJob, string runtimeId, CommandLineOptions options);
    private static Job CreateAotJob(Job baseJob, CommandLineOptions options, RuntimeMoniker runtimeMoniker, string ilCompilerVersion, string nuGetFeedUrl);
    private static Job MakeMonoJob(Job baseJob, CommandLineOptions options, MonoRuntime runtime);
    private static Job MakeMonoAOTLLVMJob(Job baseJob, CommandLineOptions options, string msBuildMoniker, RuntimeMoniker moniker);
    private static Job MakeWasmJob(Job baseJob, CommandLineOptions options, string msBuildMoniker, RuntimeMoniker moniker);
    [IteratorStateMachineAttribute("BenchmarkDotNet.ConsoleArguments.ConfigParser/<GetFilters>d__18")]
private static IEnumerable`1<IFilter> GetFilters(CommandLineOptions options);
    private static int GetMaximumDisplayWidth();
    private static Job CreateCoreRunJob(Job baseJob, CommandLineOptions options, FileInfo coreRunPath);
    private static Job CreateCoreJobWithCli(Job baseJob, CommandLineOptions options);
    private static string GetCoreRunToolchainDisplayName(IReadOnlyList`1<FileInfo> paths, FileInfo coreRunPath);
    internal static bool TryParse(string runtime, RuntimeMoniker& runtimeMoniker);
    [CompilerGeneratedAttribute]
internal static string <ConsumeTokens>g__GetToken|6_0(<>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.ConsoleArguments.CorrectionsSuggester : object {
    private HashSet`1<string> possibleBenchmarkNameFilters;
    private HashSet`1<string> actualFullBenchmarkNames;
    private static int PossibleTyposCount { get; }
    public CorrectionsSuggester(IReadOnlyList`1<Type> types);
    private static int get_PossibleTyposCount();
    public String[] SuggestFor(string userInput);
    public String[] GetAllBenchmarkNames();
    [IteratorStateMachineAttribute("BenchmarkDotNet.ConsoleArguments.CorrectionsSuggester/<GetAllPartialNames>d__7")]
private static IEnumerable`1<string> GetAllPartialNames(String[] nameParts);
}
internal class BenchmarkDotNet.ConsoleArguments.LevenshteinDistanceCalculator : object {
    [NullableContextAttribute("1")]
public int Calculate(string string1, string string2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.ConsoleArguments.ListBenchmarks.BenchmarkCasesPrinter : object {
    private IBenchmarkCasesPrinter printer;
    public BenchmarkCasesPrinter(ListBenchmarkCaseMode listBenchmarkCaseMode);
    public static void PrintList(ILogger nonNullLogger, IConfig effectiveConfig, IReadOnlyList`1<Type> allAvailableTypesWithRunnableBenchmarks, CommandLineOptions options);
    public sealed virtual void Print(IEnumerable`1<string> testNames, ILogger logger);
}
internal class BenchmarkDotNet.ConsoleArguments.ListBenchmarks.FlatBenchmarkCasesPrinter : object {
    [NullableContextAttribute("1")]
public sealed virtual void Print(IEnumerable`1<string> testNames, ILogger logger);
}
[NullableContextAttribute("1")]
internal interface BenchmarkDotNet.ConsoleArguments.ListBenchmarks.IBenchmarkCasesPrinter {
    public abstract virtual void Print(IEnumerable`1<string> testNames, ILogger logger);
}
public enum BenchmarkDotNet.ConsoleArguments.ListBenchmarks.ListBenchmarkCaseMode : Enum {
    public int value__;
    public static ListBenchmarkCaseMode Disabled;
    public static ListBenchmarkCaseMode Flat;
    public static ListBenchmarkCaseMode Tree;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.ConsoleArguments.ListBenchmarks.Node : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Node> <Children>k__BackingField;
    public string Name { get; public set; }
    public List`1<Node> Children { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<Node> get_Children();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.ConsoleArguments.ListBenchmarks.TreeBenchmarkCasesPrinter : object {
    private static string Cross;
    private static string Corner;
    private static string Vertical;
    private static string Space;
    public sealed virtual void Print(IEnumerable`1<string> testNames, ILogger logger);
    private static void PrepareNodeTree(List`1<Node> nodes, String[] partsOfName, int index);
    private void PrintNode(Node node, string indent, ILogger logger);
    private void PrintChildNode(Node node, string indent, bool isLast, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.ConsoleArguments.LoggerWrapper : TextWriter {
    private ILogger logger;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Encoding Encoding { get; }
    public LoggerWrapper(ILogger logger);
    [CompilerGeneratedAttribute]
public virtual Encoding get_Encoding();
    public virtual void Write(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Diagnosers.AllocatedMemoryMetricDescriptor : object {
    internal static IMetricDescriptor Instance;
    public string Id { get; }
    public string DisplayName { get; }
    public string Legend { get; }
    public string NumberFormat { get; }
    public UnitType UnitType { get; }
    public string Unit { get; }
    public bool TheGreaterTheBetter { get; }
    public int PriorityInCategory { get; }
    private static AllocatedMemoryMetricDescriptor();
    public sealed virtual string get_Id();
    public sealed virtual string get_DisplayName();
    public sealed virtual string get_Legend();
    public sealed virtual string get_NumberFormat();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string get_Unit();
    public sealed virtual bool get_TheGreaterTheBetter();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool GetIsAvailable(Metric metric);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Diagnosers.AllocatedNativeMemoryDescriptor : object {
    internal static IMetricDescriptor Instance;
    public string Id { get; }
    public string DisplayName { get; }
    public string Legend { get; }
    public string NumberFormat { get; }
    public UnitType UnitType { get; }
    public string Unit { get; }
    public bool TheGreaterTheBetter { get; }
    public int PriorityInCategory { get; }
    private static AllocatedNativeMemoryDescriptor();
    public sealed virtual string get_Id();
    public sealed virtual string get_DisplayName();
    public sealed virtual string get_Legend();
    public sealed virtual string get_NumberFormat();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string get_Unit();
    public sealed virtual bool get_TheGreaterTheBetter();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool GetIsAvailable(Metric metric);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.CompositeDiagnoser : object {
    private ImmutableHashSet`1<IDiagnoser> diagnosers;
    public IEnumerable`1<string> Ids { get; }
    public IEnumerable`1<IExporter> Exporters { get; }
    public IEnumerable`1<IAnalyser> Analysers { get; }
    public CompositeDiagnoser(ImmutableHashSet`1<IDiagnoser> diagnosers);
    public sealed virtual RunMode GetRunMode(BenchmarkCase benchmarkCase);
    public sealed virtual IEnumerable`1<string> get_Ids();
    public sealed virtual IEnumerable`1<IExporter> get_Exporters();
    public sealed virtual IEnumerable`1<IAnalyser> get_Analysers();
    public sealed virtual void Handle(HostSignal signal, DiagnoserActionParameters parameters);
    public sealed virtual IEnumerable`1<Metric> ProcessResults(DiagnoserResults results);
    public sealed virtual void DisplayResults(ILogger logger);
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.DiagnoserActionParameters : object {
    [CompilerGeneratedAttribute]
private Process <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private BenchmarkCase <BenchmarkCase>k__BackingField;
    [CompilerGeneratedAttribute]
private BenchmarkId <BenchmarkId>k__BackingField;
    public Process Process { get; }
    public BenchmarkCase BenchmarkCase { get; }
    public BenchmarkId BenchmarkId { get; }
    public ImmutableConfig Config { get; }
    public DiagnoserActionParameters(Process process, BenchmarkCase benchmarkCase, BenchmarkId benchmarkId);
    [CompilerGeneratedAttribute]
public Process get_Process();
    [CompilerGeneratedAttribute]
public BenchmarkCase get_BenchmarkCase();
    [CompilerGeneratedAttribute]
public BenchmarkId get_BenchmarkId();
    public ImmutableConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.DiagnoserResults : object {
    [CompilerGeneratedAttribute]
private BenchmarkCase <BenchmarkCase>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private GcStats <GcStats>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadingStats <ThreadingStats>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ExceptionFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildResult <BuildResult>k__BackingField;
    public BenchmarkCase BenchmarkCase { get; }
    public long TotalOperations { get; }
    public GcStats GcStats { get; }
    public ThreadingStats ThreadingStats { get; }
    public double ExceptionFrequency { get; }
    public BuildResult BuildResult { get; }
    public DiagnoserResults(BenchmarkCase benchmarkCase, ExecuteResult executeResult, BuildResult buildResult);
    [CompilerGeneratedAttribute]
public BenchmarkCase get_BenchmarkCase();
    [CompilerGeneratedAttribute]
public long get_TotalOperations();
    [CompilerGeneratedAttribute]
public GcStats get_GcStats();
    [CompilerGeneratedAttribute]
public ThreadingStats get_ThreadingStats();
    [CompilerGeneratedAttribute]
public double get_ExceptionFrequency();
    [CompilerGeneratedAttribute]
public BuildResult get_BuildResult();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Diagnosers.DiagnosersLoader : object {
    private static string WindowsDiagnosticAssemblyFileName;
    private static string WindowsDiagnosticAssemblyName;
    private static Lazy`1<IDiagnoser[]> LazyLoadedDiagnosers;
    private static DiagnosersLoader();
    internal static IDiagnoser GetImplementation();
    internal static IDiagnoser GetImplementation(Predicate`1<TDiagnoser> filter);
    private static IDiagnoser GetUnresolvedDiagnoser();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.DiagnosersLoader/<LoadDiagnosers>d__6")]
private static IEnumerable`1<IDiagnoser> LoadDiagnosers();
    private static IDiagnoser[] LoadWindowsDiagnosers();
    private static IDiagnoser CreateDiagnoser(Assembly loadedAssembly, string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser : object {
    private static Lazy`1<string> ptrace_scope;
    private WindowsDisassembler windowsDifferentArchitectureDisassembler;
    private SameArchitectureDisassembler sameArchitectureDisassembler;
    private MonoDisassembler monoDisassembler;
    private Dictionary`2<BenchmarkCase, DisassemblyResult> results;
    [CompilerGeneratedAttribute]
private DisassemblyDiagnoserConfig <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IExporter> <Exporters>k__BackingField;
    public DisassemblyDiagnoserConfig Config { get; }
    public IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> Results { get; }
    public IEnumerable`1<string> Ids { get; }
    public IEnumerable`1<IExporter> Exporters { get; }
    public IEnumerable`1<IAnalyser> Analysers { get; }
    public DisassemblyDiagnoser(DisassemblyDiagnoserConfig config);
    private static DisassemblyDiagnoser();
    [CompilerGeneratedAttribute]
public DisassemblyDiagnoserConfig get_Config();
    public IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> get_Results();
    public sealed virtual IEnumerable`1<string> get_Ids();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IExporter> get_Exporters();
    public sealed virtual IEnumerable`1<IAnalyser> get_Analysers();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser/<ProcessResults>d__18")]
public sealed virtual IEnumerable`1<Metric> ProcessResults(DiagnoserResults diagnoserResults);
    public sealed virtual RunMode GetRunMode(BenchmarkCase benchmarkCase);
    public sealed virtual void Handle(HostSignal signal, DiagnoserActionParameters parameters);
    public sealed virtual void DisplayResults(ILogger logger);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser/<Validate>d__22")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    private static bool ShouldUseMonoDisassembler(BenchmarkCase benchmarkCase);
    private static bool ShouldUseClrMdDisassembler(BenchmarkCase benchmarkCase);
    private static bool ShouldUseSameArchitectureDisassembler(BenchmarkCase benchmarkCase, DiagnoserActionParameters parameters);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser/<GetExporters>d__26")]
private static IEnumerable`1<IExporter> GetExporters(Dictionary`2<BenchmarkCase, DisassemblyResult> results, DisassemblyDiagnoserConfig config);
    private static long SumNativeCodeSize(DisassemblyResult disassembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.DisassemblyDiagnoserConfig : object {
    [CompilerGeneratedAttribute]
private bool <PrintSource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintInstructionAddresses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private DisassemblySyntax <Syntax>k__BackingField;
    [CompilerGeneratedAttribute]
private FormatterOptions <Formatting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExportGithubMarkdown>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExportHtml>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExportCombinedDisassemblyReport>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExportDiff>k__BackingField;
    public bool PrintSource { get; }
    public bool PrintInstructionAddresses { get; }
    public int MaxDepth { get; }
    public String[] Filters { get; }
    public DisassemblySyntax Syntax { get; }
    public FormatterOptions Formatting { get; }
    public bool ExportGithubMarkdown { get; }
    public bool ExportHtml { get; }
    public bool ExportCombinedDisassemblyReport { get; }
    public bool ExportDiff { get; }
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public DisassemblyDiagnoserConfig(int maxDepth, DisassemblySyntax syntax, String[] filters, FormatterOptions formatterOptions, bool printSource, bool printInstructionAddresses, bool exportGithubMarkdown, bool exportHtml, bool exportCombinedDisassemblyReport, bool exportDiff);
    [CompilerGeneratedAttribute]
public bool get_PrintSource();
    [CompilerGeneratedAttribute]
public bool get_PrintInstructionAddresses();
    [CompilerGeneratedAttribute]
public int get_MaxDepth();
    [CompilerGeneratedAttribute]
public String[] get_Filters();
    [CompilerGeneratedAttribute]
public DisassemblySyntax get_Syntax();
    [CompilerGeneratedAttribute]
public FormatterOptions get_Formatting();
    [CompilerGeneratedAttribute]
public bool get_ExportGithubMarkdown();
    [CompilerGeneratedAttribute]
public bool get_ExportHtml();
    [CompilerGeneratedAttribute]
public bool get_ExportCombinedDisassemblyReport();
    [CompilerGeneratedAttribute]
public bool get_ExportDiff();
    internal Formatter GetFormatterWithSymbolSolver(IReadOnlyDictionary`2<ulong, string> addressToNameMapping);
    private static FormatterOptions GetDefaults(DisassemblySyntax syntax);
}
public enum BenchmarkDotNet.Diagnosers.DisassemblySyntax : Enum {
    public int value__;
    public static DisassemblySyntax Masm;
    public static DisassemblySyntax Intel;
    public static DisassemblySyntax Att;
}
public enum BenchmarkDotNet.Diagnosers.EventPipeProfile : Enum {
    public int value__;
    public static EventPipeProfile CpuSampling;
    public static EventPipeProfile GcVerbose;
    public static EventPipeProfile GcCollect;
    public static EventPipeProfile Jit;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Diagnosers.EventPipeProfileMapper : object {
    private static string DotNetRuntimeProviderName;
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<EventPipeProfile, IReadOnlyList`1<EventPipeProvider>> <DotNetRuntimeProfiles>k__BackingField;
    internal static IReadOnlyDictionary`2<EventPipeProfile, IReadOnlyList`1<EventPipeProvider>> DotNetRuntimeProfiles { get; }
    private static EventPipeProfileMapper();
    [CompilerGeneratedAttribute]
internal static IReadOnlyDictionary`2<EventPipeProfile, IReadOnlyList`1<EventPipeProvider>> get_DotNetRuntimeProfiles();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.EventPipeProfiler : object {
    public static EventPipeProfiler Default;
    private Dictionary`2<BenchmarkCase, string> benchmarkToTraceFile;
    private ImmutableHashSet`1<EventPipeProvider> eventPipeProviders;
    private bool performExtraBenchmarksRun;
    private Task collectingTask;
    public string ShortName { get; }
    public IEnumerable`1<string> Ids { get; }
    public IEnumerable`1<IExporter> Exporters { get; }
    public IEnumerable`1<IAnalyser> Analysers { get; }
    public EventPipeProfiler(EventPipeProfile profile, IReadOnlyCollection`1<EventPipeProvider> providers, bool performExtraBenchmarksRun);
    private static EventPipeProfiler();
    public sealed virtual string get_ShortName();
    public sealed virtual IEnumerable`1<string> get_Ids();
    public sealed virtual IEnumerable`1<IExporter> get_Exporters();
    public sealed virtual IEnumerable`1<IAnalyser> get_Analysers();
    public sealed virtual RunMode GetRunMode(BenchmarkCase benchmarkCase);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.EventPipeProfiler/<Validate>d__16")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    public sealed virtual void Handle(HostSignal signal, DiagnoserActionParameters parameters);
    private static void CopyEventStreamToFile(EventPipeSession session, string fileName, ILogger logger);
    public sealed virtual IEnumerable`1<Metric> ProcessResults(DiagnoserResults results);
    public sealed virtual void DisplayResults(ILogger resultLogger);
    internal static ImmutableHashSet`1<EventPipeProvider> MapToProviders(EventPipeProfile profile, IReadOnlyCollection`1<EventPipeProvider> providers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.ExceptionDiagnoser : object {
    public static ExceptionDiagnoser Default;
    public IEnumerable`1<string> Ids { get; }
    public IEnumerable`1<IExporter> Exporters { get; }
    public IEnumerable`1<IAnalyser> Analysers { get; }
    private static ExceptionDiagnoser();
    public sealed virtual IEnumerable`1<string> get_Ids();
    public sealed virtual IEnumerable`1<IExporter> get_Exporters();
    public sealed virtual IEnumerable`1<IAnalyser> get_Analysers();
    public sealed virtual void DisplayResults(ILogger logger);
    public sealed virtual RunMode GetRunMode(BenchmarkCase benchmarkCase);
    public sealed virtual void Handle(HostSignal signal, DiagnoserActionParameters parameters);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.ExceptionDiagnoser/<ProcessResults>d__11")]
public sealed virtual IEnumerable`1<Metric> ProcessResults(DiagnoserResults results);
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
public enum BenchmarkDotNet.Diagnosers.HardwareCounter : Enum {
    public int value__;
    public static HardwareCounter NotSet;
    public static HardwareCounter Timer;
    public static HardwareCounter TotalIssues;
    public static HardwareCounter BranchInstructions;
    public static HardwareCounter CacheMisses;
    public static HardwareCounter BranchMispredictions;
    public static HardwareCounter TotalCycles;
    public static HardwareCounter UnhaltedCoreCycles;
    public static HardwareCounter InstructionRetired;
    public static HardwareCounter UnhaltedReferenceCycles;
    public static HardwareCounter LlcReference;
    public static HardwareCounter LlcMisses;
    public static HardwareCounter BranchInstructionRetired;
    public static HardwareCounter BranchMispredictsRetired;
}
[ExtensionAttribute]
public static class BenchmarkDotNet.Diagnosers.HardwareCounterExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToShortName(HardwareCounter hardwareCounter);
    [ExtensionAttribute]
public static bool TheGreaterTheBetter(HardwareCounter hardwareCounter);
}
public interface BenchmarkDotNet.Diagnosers.IConfigurableDiagnoser`1 {
    [NullableContextAttribute("1")]
[PublicAPIAttribute]
public abstract virtual IConfigurableDiagnoser`1<TConfig> Configure(TConfig config);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Diagnosers.IDiagnoser {
    public IEnumerable`1<string> Ids { get; }
    public IEnumerable`1<IExporter> Exporters { get; }
    public IEnumerable`1<IAnalyser> Analysers { get; }
    public abstract virtual IEnumerable`1<string> get_Ids();
    public abstract virtual IEnumerable`1<IExporter> get_Exporters();
    public abstract virtual IEnumerable`1<IAnalyser> get_Analysers();
    public abstract virtual RunMode GetRunMode(BenchmarkCase benchmarkCase);
    public abstract virtual void Handle(HostSignal signal, DiagnoserActionParameters parameters);
    public abstract virtual IEnumerable`1<Metric> ProcessResults(DiagnoserResults results);
    public abstract virtual void DisplayResults(ILogger logger);
    public abstract virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
[NullableContextAttribute("1")]
internal interface BenchmarkDotNet.Diagnosers.IHardwareCountersDiagnoser {
    public IReadOnlyDictionary`2<BenchmarkCase, PmcStats> Results { get; }
    public abstract virtual IReadOnlyDictionary`2<BenchmarkCase, PmcStats> get_Results();
}
[NullableContextAttribute("1")]
internal interface BenchmarkDotNet.Diagnosers.IProfiler {
    public string ShortName { get; }
    public abstract virtual string get_ShortName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.MemoryDiagnoser : object {
    private static string DiagnoserId;
    public static MemoryDiagnoser Default;
    [CompilerGeneratedAttribute]
private MemoryDiagnoserConfig <Config>k__BackingField;
    public MemoryDiagnoserConfig Config { get; }
    public IEnumerable`1<string> Ids { get; }
    public IEnumerable`1<IExporter> Exporters { get; }
    public IEnumerable`1<IAnalyser> Analysers { get; }
    public MemoryDiagnoser(MemoryDiagnoserConfig config);
    private static MemoryDiagnoser();
    [CompilerGeneratedAttribute]
public MemoryDiagnoserConfig get_Config();
    public sealed virtual RunMode GetRunMode(BenchmarkCase benchmarkCase);
    public sealed virtual IEnumerable`1<string> get_Ids();
    public sealed virtual IEnumerable`1<IExporter> get_Exporters();
    public sealed virtual IEnumerable`1<IAnalyser> get_Analysers();
    public sealed virtual void DisplayResults(ILogger logger);
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    public sealed virtual void Handle(HostSignal signal, DiagnoserActionParameters parameters);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.MemoryDiagnoser/<ProcessResults>d__16")]
public sealed virtual IEnumerable`1<Metric> ProcessResults(DiagnoserResults diagnoserResults);
}
public class BenchmarkDotNet.Diagnosers.MemoryDiagnoserConfig : object {
    [CompilerGeneratedAttribute]
private bool <DisplayGenColumns>k__BackingField;
    public bool DisplayGenColumns { get; }
    [PublicAPIAttribute]
public MemoryDiagnoserConfig(bool displayGenColumns);
    [CompilerGeneratedAttribute]
public bool get_DisplayGenColumns();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Diagnosers.NativeMemoryLeakDescriptor : object {
    internal static IMetricDescriptor Instance;
    public string Id { get; }
    public string DisplayName { get; }
    public string Legend { get; }
    public string NumberFormat { get; }
    public UnitType UnitType { get; }
    public string Unit { get; }
    public bool TheGreaterTheBetter { get; }
    public int PriorityInCategory { get; }
    private static NativeMemoryLeakDescriptor();
    public sealed virtual string get_Id();
    public sealed virtual string get_DisplayName();
    public sealed virtual string get_Legend();
    public sealed virtual string get_NumberFormat();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string get_Unit();
    public sealed virtual bool get_TheGreaterTheBetter();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool GetIsAvailable(Metric metric);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.PerfCollectProfiler : object {
    public static IDiagnoser Default;
    private PerfCollectProfilerConfig config;
    private DateTime creationTime;
    private Dictionary`2<BenchmarkCase, FileInfo> benchmarkToTraceFile;
    private HashSet`1<string> cliPathWithSymbolsInstalled;
    private FileInfo perfCollectFile;
    private Process perfCollectProcess;
    public string ShortName { get; }
    public IEnumerable`1<string> Ids { get; }
    public IEnumerable`1<IExporter> Exporters { get; }
    public IEnumerable`1<IAnalyser> Analysers { get; }
    [PublicAPIAttribute]
public PerfCollectProfiler(PerfCollectProfilerConfig config);
    private static PerfCollectProfiler();
    public sealed virtual string get_ShortName();
    public sealed virtual IEnumerable`1<string> get_Ids();
    public sealed virtual IEnumerable`1<IExporter> get_Exporters();
    public sealed virtual IEnumerable`1<IAnalyser> get_Analysers();
    public sealed virtual IEnumerable`1<Metric> ProcessResults(DiagnoserResults results);
    public sealed virtual RunMode GetRunMode(BenchmarkCase benchmarkCase);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.PerfCollectProfiler/<Validate>d__18")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    public sealed virtual void DisplayResults(ILogger logger);
    public sealed virtual void Handle(HostSignal signal, DiagnoserActionParameters parameters);
    private bool TryInstallPerfCollect(ValidationParameters validationParameters);
    private Process StartCollection(DiagnoserActionParameters parameters);
    private void StopCollection(DiagnoserActionParameters parameters);
    private void EnsureSymbolsForNativeRuntime(DiagnoserActionParameters parameters);
    private FileInfo GetTraceFile(DiagnoserActionParameters parameters, string extension);
}
public class BenchmarkDotNet.Diagnosers.PerfCollectProfilerConfig : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private RunMode <RunMode>k__BackingField;
    public TimeSpan Timeout { get; }
    public RunMode RunMode { get; }
    public PerfCollectProfilerConfig(bool performExtraBenchmarksRun, int timeoutInSeconds);
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public RunMode get_RunMode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Diagnosers.PmcMetricDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Legend>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TheGreaterTheBetter>k__BackingField;
    public string Id { get; }
    public string DisplayName { get; }
    public string Legend { get; }
    public bool TheGreaterTheBetter { get; }
    public string NumberFormat { get; }
    public UnitType UnitType { get; }
    public string Unit { get; }
    public int PriorityInCategory { get; }
    internal PmcMetricDescriptor(PreciseMachineCounter counter);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Legend();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TheGreaterTheBetter();
    public sealed virtual string get_NumberFormat();
    public sealed virtual UnitType get_UnitType();
    public sealed virtual string get_Unit();
    public sealed virtual int get_PriorityInCategory();
    public sealed virtual bool GetIsAvailable(Metric metric);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.PmcStats : object {
    [CompilerGeneratedAttribute]
private long <TotalOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<HardwareCounter, PreciseMachineCounter> <Counters>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<int, PreciseMachineCounter> <CountersByProfileSourceId>k__BackingField;
    public long TotalOperations { get; public set; }
    public IReadOnlyDictionary`2<HardwareCounter, PreciseMachineCounter> Counters { get; }
    private IReadOnlyDictionary`2<int, PreciseMachineCounter> CountersByProfileSourceId { get; }
    public PmcStats(IReadOnlyCollection`1<HardwareCounter> hardwareCounters, Func`2<HardwareCounter, PreciseMachineCounter> factory);
    [CompilerGeneratedAttribute]
public long get_TotalOperations();
    [CompilerGeneratedAttribute]
public void set_TotalOperations(long value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<HardwareCounter, PreciseMachineCounter> get_Counters();
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<int, PreciseMachineCounter> get_CountersByProfileSourceId();
    internal void Handle(int profileSourceId, ulong instructionPointer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.PreciseMachineCounter : object {
    [CompilerGeneratedAttribute]
private int <ProfileSourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private HardwareCounter <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ulong, ulong> <PerInstructionPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Count>k__BackingField;
    [PublicAPIAttribute]
public int ProfileSourceId { get; }
    [PublicAPIAttribute]
public string Name { get; }
    [PublicAPIAttribute]
public HardwareCounter Counter { get; }
    [PublicAPIAttribute]
public int Interval { get; }
    [PublicAPIAttribute]
public Dictionary`2<ulong, ulong> PerInstructionPointer { get; }
    public ulong Count { get; private set; }
    internal PreciseMachineCounter(int profileSourceId, string name, HardwareCounter counter, int interval);
    [CompilerGeneratedAttribute]
public int get_ProfileSourceId();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public HardwareCounter get_Counter();
    [CompilerGeneratedAttribute]
public int get_Interval();
    [CompilerGeneratedAttribute]
public Dictionary`2<ulong, ulong> get_PerInstructionPointer();
    [CompilerGeneratedAttribute]
public ulong get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(ulong value);
    public void OnSample(ulong instructionPointer);
}
public enum BenchmarkDotNet.Diagnosers.RunMode : Enum {
    public byte value__;
    public static RunMode None;
    public static RunMode ExtraRun;
    public static RunMode NoOverhead;
    public static RunMode SeparateLogic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Diagnosers.SpeedScopeExporter : object {
    internal static string Convert(string traceFilePath, ILogger logger);
    private static void ConvertToSpeedscope(string fileToConvert, string outputFilename, bool continueOnError);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.ThreadingDiagnoser : object {
    public static ThreadingDiagnoser Default;
    public IEnumerable`1<string> Ids { get; }
    public IEnumerable`1<IExporter> Exporters { get; }
    public IEnumerable`1<IAnalyser> Analysers { get; }
    private static ThreadingDiagnoser();
    public sealed virtual IEnumerable`1<string> get_Ids();
    public sealed virtual IEnumerable`1<IExporter> get_Exporters();
    public sealed virtual IEnumerable`1<IAnalyser> get_Analysers();
    public sealed virtual void DisplayResults(ILogger logger);
    public sealed virtual RunMode GetRunMode(BenchmarkCase benchmarkCase);
    public sealed virtual void Handle(HostSignal signal, DiagnoserActionParameters parameters);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.ThreadingDiagnoser/<ProcessResults>d__11")]
public sealed virtual IEnumerable`1<Metric> ProcessResults(DiagnoserResults results);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Diagnosers.ThreadingDiagnoser/<Validate>d__12")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Diagnosers.UnresolvedDiagnoser : object {
    private Type unresolved;
    public IEnumerable`1<string> Ids { get; }
    public IEnumerable`1<IExporter> Exporters { get; }
    public IEnumerable`1<IAnalyser> Analysers { get; }
    public UnresolvedDiagnoser(Type unresolved);
    public sealed virtual RunMode GetRunMode(BenchmarkCase benchmarkCase);
    public sealed virtual IEnumerable`1<string> get_Ids();
    public sealed virtual IEnumerable`1<IExporter> get_Exporters();
    public sealed virtual IEnumerable`1<IAnalyser> get_Analysers();
    public sealed virtual void Handle(HostSignal signal, DiagnoserActionParameters parameters);
    public sealed virtual IEnumerable`1<Metric> ProcessResults(DiagnoserResults _);
    public sealed virtual void DisplayResults(ILogger logger);
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    private string GetErrorMessage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Disassemblers.Arm64Asm : Asm {
    [CompilerGeneratedAttribute]
private Arm64Instruction <Instruction>k__BackingField;
    public Arm64Instruction Instruction { get; public set; }
    [CompilerGeneratedAttribute]
public Arm64Instruction get_Instruction();
    [CompilerGeneratedAttribute]
public void set_Instruction(Arm64Instruction value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.Arm64Disassembler : ClrMdV2Disassembler {
    private static Dictionary`2<Version, RuntimeSpecificData> runtimeSpecificData;
    private static Arm64Disassembler();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Disassemblers.Arm64Disassembler/<Decode>d__2")]
protected virtual IEnumerable`1<Asm> Decode(Byte[] code, ulong startAddress, State state, int depth, ClrMethod currentMethod, DisassemblySyntax syntax);
    private static bool TryGetReferencedAddress(Arm64Instruction instruction, RegisterValueAccumulator accumulator, UInt32 pointerSize, UInt64& referencedAddress, Boolean& isReferencedAddressIndirect);
    private static DisassembleSyntax Map(DisassemblySyntax syntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Disassemblers.Arm64InstructionFormatter : object {
    internal static string Format(Arm64Asm asm, FormatterOptions formatterOptions, bool printInstructionAddresses, UInt32 pointerSize, IReadOnlyDictionary`2<ulong, string> symbols);
    private static void FormatInstructionPointer(Arm64Instruction instruction, FormatterOptions formatterOptions, UInt32 pointerSize, StringBuilder output);
}
public abstract class BenchmarkDotNet.Disassemblers.Asm : SourceCode {
    [CompilerGeneratedAttribute]
private int <InstructionLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <ReferencedAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReferencedAddressIndirect>k__BackingField;
    public int InstructionLength { get; public set; }
    public Nullable`1<ulong> ReferencedAddress { get; public set; }
    public bool IsReferencedAddressIndirect { get; public set; }
    [CompilerGeneratedAttribute]
public int get_InstructionLength();
    [CompilerGeneratedAttribute]
public void set_InstructionLength(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<ulong> get_ReferencedAddress();
    [CompilerGeneratedAttribute]
public void set_ReferencedAddress(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
public bool get_IsReferencedAddressIndirect();
    [CompilerGeneratedAttribute]
public void set_IsReferencedAddressIndirect(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class BenchmarkDotNet.Disassemblers.ClrMdV2Disassembler : object {
    private static ulong MinValidAddress;
    private static ClrMdV2Disassembler();
    private static ulong GetMinValidAddress();
    private static bool IsValidAddress(ulong address);
    internal DisassemblyResult AttachAndDisassemble(Settings settings);
    private static void ConfigureSymbols(DataTarget dataTarget);
    private static void FilterAndEnqueue(State state, Settings settings);
    private DisassembledMethod[] Disassemble(Settings settings, State state);
    private static bool CanBeDisassembled(ClrMethod method);
    private DisassembledMethod DisassembleMethod(MethodInfo methodInfo, State state, Settings settings, DisassemblySyntax syntax, SourceCodeProvider sourceCodeProvider);
    private IEnumerable`1<Asm> Decode(ILToNativeMap map, State state, int depth, ClrMethod currentMethod, DisassemblySyntax syntax);
    protected abstract virtual IEnumerable`1<Asm> Decode(Byte[] code, ulong startAddress, State state, int depth, ClrMethod currentMethod, DisassemblySyntax syntax);
    private static ILToNativeMap[] GetCompleteNativeMap(ClrMethod method, ClrRuntime runtime);
    private static DisassembledMethod CreateEmpty(ClrMethod method, string reason);
    protected static bool TryReadNativeCodeAddresses(ClrRuntime runtime, ClrMethod method, UInt64& startAddress, UInt64& endAddress);
    protected void TryTranslateAddressToName(ulong address, bool isAddressPrecodeMD, State state, int depth, ClrMethod currentMethod);
    protected void FlushCachedDataIfNeeded(IDataReader dataTargetDataReader, ulong address, Byte[] buffer);
    private static ClrMethod WorkaroundGetMethodByInstructionPointerBug(ClrRuntime runtime, ClrMethod method, ulong newAddress);
}
internal static class BenchmarkDotNet.Disassemblers.CodeFormatter : object {
    [NullableContextAttribute("1")]
internal static string Format(SourceCode sourceCode, Formatter formatter, bool printInstructionAddresses, UInt32 pointerSize, IReadOnlyDictionary`2<ulong, string> symbols);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Disassemblers.DisassembledMethod : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <NativeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Problem>k__BackingField;
    [CompilerGeneratedAttribute]
private Map[] <Maps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLine>k__BackingField;
    public string Name { get; public set; }
    public ulong NativeCode { get; public set; }
    public string Problem { get; public set; }
    public Map[] Maps { get; public set; }
    public string CommandLine { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ulong get_NativeCode();
    [CompilerGeneratedAttribute]
public void set_NativeCode(ulong value);
    [CompilerGeneratedAttribute]
public string get_Problem();
    [CompilerGeneratedAttribute]
public void set_Problem(string value);
    [CompilerGeneratedAttribute]
public Map[] get_Maps();
    [CompilerGeneratedAttribute]
public void set_Maps(Map[] value);
    [CompilerGeneratedAttribute]
public string get_CommandLine();
    [CompilerGeneratedAttribute]
public void set_CommandLine(string value);
    public static DisassembledMethod Empty(string fullSignature, ulong nativeCode, string problem);
}
public static class BenchmarkDotNet.Disassemblers.DisassemblerConstants : object {
    [NullableAttribute("1")]
public static string DisassemblerEntryMethodName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.DisassemblyAnalyzer : object {
    private IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results;
    public string Id { get; }
    internal DisassemblyAnalyzer(IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results);
    public sealed virtual string get_Id();
    public sealed virtual IEnumerable`1<Conclusion> Analyse(Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Disassemblers.DisassemblyResult : object {
    [CompilerGeneratedAttribute]
private DisassembledMethod[] <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private MutablePair[] <SerializedAddressToNameMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PointerSize>k__BackingField;
    [XmlIgnoreAttribute]
private Dictionary`2<ulong, string> _addressToNameMapping;
    public DisassembledMethod[] Methods { get; public set; }
    public String[] Errors { get; public set; }
    public MutablePair[] SerializedAddressToNameMapping { get; public set; }
    public UInt32 PointerSize { get; public set; }
    [XmlIgnoreAttribute]
public Dictionary`2<ulong, string> AddressToNameMapping { get; }
    [CompilerGeneratedAttribute]
public DisassembledMethod[] get_Methods();
    [CompilerGeneratedAttribute]
public void set_Methods(DisassembledMethod[] value);
    [CompilerGeneratedAttribute]
public String[] get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(String[] value);
    [CompilerGeneratedAttribute]
public MutablePair[] get_SerializedAddressToNameMapping();
    [CompilerGeneratedAttribute]
public void set_SerializedAddressToNameMapping(MutablePair[] value);
    [CompilerGeneratedAttribute]
public UInt32 get_PointerSize();
    [CompilerGeneratedAttribute]
public void set_PointerSize(UInt32 value);
    public Dictionary`2<ulong, string> get_AddressToNameMapping();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.Exporters.CombinedDisassemblyExporter : ExporterBase {
    internal static string CssDefinition;
    private IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results;
    private DisassemblyDiagnoserConfig config;
    protected string FileExtension { get; }
    protected string FileCaption { get; }
    internal CombinedDisassemblyExporter(IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results, DisassemblyDiagnoserConfig config);
    protected virtual string get_FileExtension();
    protected virtual string get_FileCaption();
    public virtual void ExportToLog(Summary summary, ILogger logger);
    private void PrintTable(BenchmarkCase[] benchmarksCase, ILogger logger, string title, Func`2<BenchmarkCase, string> headerTitleProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Disassemblers.Exporters.DisassemblyPrettifier : object {
    internal static IReadOnlyList`1<Element> Prettify(DisassembledMethod method, DisassemblyResult disassemblyResult, DisassemblyDiagnoserConfig config, string labelPrefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.Exporters.GithubMarkdownDiffDisassemblyExporter : ExporterBase {
    private IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results;
    private DisassemblyDiagnoserConfig config;
    protected string FileExtension { get; }
    protected string FileCaption { get; }
    internal GithubMarkdownDiffDisassemblyExporter(IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results, DisassemblyDiagnoserConfig config);
    protected virtual string get_FileExtension();
    protected virtual string get_FileCaption();
    public virtual void ExportToLog(Summary summary, ILogger logger);
    private void ExportDiff(Summary summary, ILogger logger, BenchmarkCase firstBenchmarkCase, BenchmarkCase secondBenchmarkCase);
    private string SaveDisassemblyResult(Summary summary, DisassemblyResult disassemblyResult);
    private static string GetImportantInfo(BenchmarkReport benchmarkReport);
    private static void RunGitDiff(string firstFile, string secondFile, StringBuilder result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.Exporters.GithubMarkdownDisassemblyExporter : ExporterBase {
    private IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results;
    private DisassemblyDiagnoserConfig config;
    protected string FileExtension { get; }
    protected string FileCaption { get; }
    internal GithubMarkdownDisassemblyExporter(IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results, DisassemblyDiagnoserConfig config);
    protected virtual string get_FileExtension();
    protected virtual string get_FileCaption();
    public virtual void ExportToLog(Summary summary, ILogger logger);
    internal static void Export(ILogger logger, DisassemblyResult disassemblyResult, DisassemblyDiagnoserConfig config, bool quotingCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.Exporters.HtmlDisassemblyExporter : ExporterBase {
    private static Lazy`1<string> HighlightingLabelsScript;
    private IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results;
    private DisassemblyDiagnoserConfig config;
    protected string FileExtension { get; }
    protected string FileCaption { get; }
    internal HtmlDisassemblyExporter(IReadOnlyDictionary`2<BenchmarkCase, DisassemblyResult> results, DisassemblyDiagnoserConfig config);
    private static HtmlDisassemblyExporter();
    protected virtual string get_FileExtension();
    protected virtual string get_FileCaption();
    public virtual void ExportToLog(Summary summary, ILogger logger);
    private void Export(ILogger logger, Summary summary, DisassemblyResult disassemblyResult, BenchmarkCase benchmarkCase, Int32& referenceIndex);
}
internal class BenchmarkDotNet.Disassemblers.Exporters.SymbolResolver : object {
    [NullableAttribute("1")]
private IReadOnlyDictionary`2<ulong, string> _mappings;
    [NullableContextAttribute("1")]
public SymbolResolver(IReadOnlyDictionary`2<ulong, string> mappings);
    public bool TryGetSymbol(Instruction& instruction, int operand, int instructionOperand, ulong address, int addressSize, SymbolResult& symbol);
    private sealed virtual override bool Iced.Intel.ISymbolResolver.TryGetSymbol(Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand, int instructionOperand, ulong address, int addressSize, SymbolResult& symbol);
}
public class BenchmarkDotNet.Disassemblers.IntelAsm : Asm {
    [CompilerGeneratedAttribute]
private Instruction <Instruction>k__BackingField;
    public Instruction Instruction { get; public set; }
    [CompilerGeneratedAttribute]
public Instruction get_Instruction();
    [CompilerGeneratedAttribute]
public void set_Instruction(Instruction value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.IntelDisassembler : ClrMdV2Disassembler {
    private static Dictionary`2<Version, RuntimeSpecificData> runtimeSpecificData;
    private static IntelDisassembler();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Disassemblers.IntelDisassembler/<Decode>d__2")]
protected virtual IEnumerable`1<Asm> Decode(Byte[] code, ulong startAddress, State state, int depth, ClrMethod currentMethod, DisassemblySyntax syntax);
    private static bool TryGetReferencedAddress(Instruction instruction, UInt32 pointerSize, UInt64& referencedAddress);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Disassemblers.IntelInstructionFormatter : object {
    internal static string Format(Instruction instruction, Formatter formatter, bool printInstructionAddresses, UInt32 pointerSize);
    private static void FormatInstructionPointer(Instruction instruction, Formatter formatter, UInt32 pointerSize, StringOutput output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Disassemblers.Map : object {
    [CompilerGeneratedAttribute]
private SourceCode[] <SourceCodes>k__BackingField;
    [XmlArrayAttribute("Instructions")]
[XmlArrayItemAttribute("SourceCode", "BenchmarkDotNet.Disassemblers.SourceCode")]
[XmlArrayItemAttribute("Sharp", "BenchmarkDotNet.Disassemblers.Sharp")]
[XmlArrayItemAttribute("IntelAsm", "BenchmarkDotNet.Disassemblers.IntelAsm")]
public SourceCode[] SourceCodes { get; public set; }
    [CompilerGeneratedAttribute]
public SourceCode[] get_SourceCodes();
    [CompilerGeneratedAttribute]
public void set_SourceCodes(SourceCode[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class BenchmarkDotNet.Disassemblers.MethodInfo : ValueType {
    [CompilerGeneratedAttribute]
private ClrMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    internal ClrMethod Method { get; }
    internal int Depth { get; }
    internal MethodInfo(ClrMethod method, int depth);
    [CompilerGeneratedAttribute]
internal ClrMethod get_Method();
    [CompilerGeneratedAttribute]
internal int get_Depth();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Disassemblers.MonoCode : SourceCode {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.MonoDisassembler : object {
    internal MonoDisassembler(DisassemblyDiagnoserConfig _);
    internal DisassemblyResult Disassemble(BenchmarkCase benchmarkCase, MonoRuntime mono);
    private static string GetEnvironmentVariables(Dictionary`2<string, string> environmentVariables);
    private static string GetMethodName(Descriptor descriptor);
    private static string GetLlvmFlag(Job job);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.RegisterValueAccumulator : ValueType {
    private State _state;
    private long _value;
    private int _expectedMovkShift;
    private Arm64RegisterId _registerId;
    private ClrRuntime _runtime;
    public bool HasValue { get; }
    public long Value { get; }
    public Arm64RegisterId RegisterId { get; }
    public void Init(ClrRuntime runtime);
    public void Feed(Arm64Instruction instruction);
    public bool get_HasValue();
    public long get_Value();
    public Arm64RegisterId get_RegisterId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.SameArchitectureDisassembler : object {
    private DisassemblyDiagnoserConfig config;
    [NullableAttribute("2")]
private ClrMdV2Disassembler clrMdV2Disassembler;
    internal SameArchitectureDisassembler(DisassemblyDiagnoserConfig config);
    internal DisassemblyResult Disassemble(DiagnoserActionParameters parameters);
    private static ClrMdV2Disassembler CreateDisassemblerForCurrentArchitecture();
    private Settings BuildDisassemblerSettings(DiagnoserActionParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.Settings : object {
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintSource>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDepth>k__BackingField;
    internal String[] Filters;
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultsPath>k__BackingField;
    internal int ProcessId { get; }
    internal string TypeName { get; }
    internal string MethodName { get; }
    internal bool PrintSource { get; }
    internal int MaxDepth { get; }
    internal string Syntax { get; }
    internal string TargetFrameworkMoniker { get; }
    internal string ResultsPath { get; }
    internal Settings(int processId, string typeName, string methodName, bool printSource, int maxDepth, string resultsPath, string syntax, string tfm, String[] filters);
    [CompilerGeneratedAttribute]
internal int get_ProcessId();
    [CompilerGeneratedAttribute]
internal string get_TypeName();
    [CompilerGeneratedAttribute]
internal string get_MethodName();
    [CompilerGeneratedAttribute]
internal bool get_PrintSource();
    [CompilerGeneratedAttribute]
internal int get_MaxDepth();
    [CompilerGeneratedAttribute]
internal string get_Syntax();
    [CompilerGeneratedAttribute]
internal string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
internal string get_ResultsPath();
    internal static Settings FromArgs(String[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Disassemblers.Sharp : SourceCode {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    public string Text { get; public set; }
    public string FilePath { get; public set; }
    public int LineNumber { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
}
public abstract class BenchmarkDotNet.Disassemblers.SourceCode : object {
    [CompilerGeneratedAttribute]
private ulong <InstructionPointer>k__BackingField;
    public ulong InstructionPointer { get; public set; }
    [CompilerGeneratedAttribute]
public ulong get_InstructionPointer();
    [CompilerGeneratedAttribute]
public void set_InstructionPointer(ulong value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.SourceCodeProvider : object {
    private Dictionary`2<SourceFile, String[]> sourceFileCache;
    private Dictionary`2<SourceFile, string> sourceFilePathsCache;
    private Dictionary`2<PdbInfo, ManagedSymbolModule> pdbReaders;
    private SymbolReader symbolReader;
    public sealed virtual void Dispose();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Disassemblers.SourceCodeProvider/<GetSource>d__5")]
internal IEnumerable`1<Sharp> GetSource(ClrMethod method, ILToNativeMap map);
    private string GetFilePath(SourceFile sourceFile);
    private string ReadSourceLine(SourceFile file, int line);
    private static string GetSmartPointer(string sourceLine, Nullable`1<int> start, Nullable`1<int> end);
    internal SourceLocation GetSourceLocation(ClrMethod method, int ilOffset);
    internal SourceLocation GetSourceLocation(ClrStackFrame frame);
    private static int FindIlOffset(ClrStackFrame frame);
    private ManagedSymbolModule GetReaderForMethod(ClrMethod method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Disassemblers.State : object {
    [CompilerGeneratedAttribute]
private ClrRuntime <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private Queue`1<MethodInfo> <Todo>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ClrMethod> <HandledMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ulong, string> <AddressToNameMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <RuntimeVersion>k__BackingField;
    internal ClrRuntime Runtime { get; }
    internal string TargetFrameworkMoniker { get; }
    internal Queue`1<MethodInfo> Todo { get; }
    internal HashSet`1<ClrMethod> HandledMethods { get; }
    internal Dictionary`2<ulong, string> AddressToNameMapping { get; }
    internal Version RuntimeVersion { get; }
    internal State(ClrRuntime runtime, string targetFrameworkMoniker);
    [CompilerGeneratedAttribute]
internal ClrRuntime get_Runtime();
    [CompilerGeneratedAttribute]
internal string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
internal Queue`1<MethodInfo> get_Todo();
    [CompilerGeneratedAttribute]
internal HashSet`1<ClrMethod> get_HandledMethods();
    [CompilerGeneratedAttribute]
internal Dictionary`2<ulong, string> get_AddressToNameMapping();
    [CompilerGeneratedAttribute]
internal Version get_RuntimeVersion();
    internal static Version ParseVersion(string targetFrameworkMoniker);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Disassemblers.WindowsDisassembler : object {
    private DisassemblyDiagnoserConfig config;
    [PublicAPIAttribute]
public WindowsDisassembler(DisassemblyDiagnoserConfig config);
    [PublicAPIAttribute]
public DisassemblyResult Disassemble(DiagnoserActionParameters parameters);
    internal static Platform GetDisassemblerArchitecture(Process process, Platform platform);
    private static string GetDisassemblerPath(Process process, Platform platform);
    private static string GetDisassemblerPath(string architectureName);
    private static void CopyAllRequiredDependencies(Assembly assemblyWithDisassemblersInResources, string destinationFolder);
    private static void CopyFromResources(Assembly assembly, string resourceName, string destinationPath);
    private string BuildArguments(DiagnoserActionParameters parameters, string resultsPath);
    private static string Escape(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.AnonymousPipesHost : object {
    internal static string AnonymousPipesDescriptors;
    internal static Encoding UTF8NoBOM;
    private StreamWriter outWriter;
    private StreamReader inReader;
    public AnonymousPipesHost(string writHandle, string readHandle);
    private static AnonymousPipesHost();
    private Stream OpenAnonymousPipe(string fileHandle, FileAccess access);
    public sealed virtual void Dispose();
    public sealed virtual void Write(string message);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(string message);
    public sealed virtual void SendSignal(HostSignal hostSignal);
    public sealed virtual void SendError(string message);
    public sealed virtual void ReportResults(RunResults runResults);
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public static bool TryGetFileHandles(String[] args, String& writeHandle, String& readHandle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.AutoWarmupStoppingCriteria : StoppingCriteriaBase {
    private static int DefaultMinFluctuationCount;
    private int minIterationCount;
    private int maxIterationCount;
    private int minFluctuationCount;
    private string maxIterationMessage;
    private string minFluctuationMessage;
    public AutoWarmupStoppingCriteria(int minIterationCount, int maxIterationCount, int minFluctuationCount);
    public virtual StoppingResult Evaluate(IReadOnlyList`1<Measurement> measurements);
    protected virtual string GetTitle();
    protected virtual int GetMaxIterationCount();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Engines.AutoWarmupStoppingCriteria/<GetWarnings>d__10")]
protected virtual IEnumerable`1<string> GetWarnings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.Consumer : object {
    private static HashSet`1<Type> SupportedTypes;
    private Byte modreq(System.Runtime.CompilerServices.IsVolatile) byteHolder;
    private SByte modreq(System.Runtime.CompilerServices.IsVolatile) sbyteHolder;
    private Int16 modreq(System.Runtime.CompilerServices.IsVolatile) shortHolder;
    private UInt16 modreq(System.Runtime.CompilerServices.IsVolatile) ushortHolder;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) intHolder;
    private UInt32 modreq(System.Runtime.CompilerServices.IsVolatile) uintHolder;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) boolHolder;
    private Char modreq(System.Runtime.CompilerServices.IsVolatile) charHolder;
    private Single modreq(System.Runtime.CompilerServices.IsVolatile) floatHolder;
    private double doubleHolder;
    private long longHolder;
    private ulong ulongHolder;
    [NullableAttribute("2")]
private Object modreq(System.Runtime.CompilerServices.IsVolatile) objectHolder;
    private IntPtr modreq(System.Runtime.CompilerServices.IsVolatile) ptrHolder;
    private UIntPtr modreq(System.Runtime.CompilerServices.IsVolatile) uptrHolder;
    private static Consumer();
    [PublicAPIAttribute]
public void Consume(byte byteValue);
    [CLSCompliantAttribute("False")]
[PublicAPIAttribute]
public void Consume(sbyte sbyteValue);
    [PublicAPIAttribute]
public void Consume(short shortValue);
    [CLSCompliantAttribute("False")]
[PublicAPIAttribute]
public void Consume(ushort ushortValue);
    [PublicAPIAttribute]
public void Consume(int intValue);
    [CLSCompliantAttribute("False")]
[PublicAPIAttribute]
public void Consume(UInt32 uintValue);
    [PublicAPIAttribute]
public void Consume(bool boolValue);
    [PublicAPIAttribute]
public void Consume(char charValue);
    [PublicAPIAttribute]
public void Consume(float floatValue);
    [PublicAPIAttribute]
public void Consume(double doubleValue);
    [PublicAPIAttribute]
public void Consume(long longValue);
    [PublicAPIAttribute]
public void Consume(IntPtr intPtrValue);
    [PublicAPIAttribute]
public void Consume(UIntPtr uintPtrValue);
    [CLSCompliantAttribute("False")]
[PublicAPIAttribute]
public void Consume(ulong ulongValue);
    [PublicAPIAttribute]
public void Consume(string stringValue);
    [PublicAPIAttribute]
public void Consume(object objectValue);
    [PublicAPIAttribute]
public void Consume(T objectValue);
    [NullableContextAttribute("0")]
public void Consume(T* ptrValue);
    [NullableContextAttribute("0")]
public void Consume(Void* ptrValue);
    public void Consume(T& value);
    internal static bool IsConsumable(Type type);
    internal static bool HasConsumableField(Type type, FieldInfo& consumableField);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Engines.ConsumerExtensions : object {
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void Consume(IEnumerable enumerable, Consumer consumer);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void Consume(IQueryable queryable, Consumer consumer);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void Consume(IEnumerable`1<T> enumerable, Consumer consumer);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void Consume(IQueryable`1<T> queryable, Consumer consumer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Engines.DeadCodeEliminationHelper : object {
    [UsedImplicitlyAttribute]
public static void KeepAliveWithoutBoxing(T value);
    [UsedImplicitlyAttribute]
public static void KeepAliveWithoutBoxing(T& value);
    [UsedImplicitlyAttribute]
public static void KeepAliveWithoutBoxingReadonly(T& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.DefaultStoppingCriteriaFactory : object {
    public static DefaultStoppingCriteriaFactory Instance;
    private static int MinOverheadIterationCount;
    internal static int MaxOverheadIterationCount;
    private static DefaultStoppingCriteriaFactory();
    public virtual IStoppingCriteria CreateWarmupWorkload(Job job, IResolver resolver, RunStrategy runStrategy);
    public virtual IStoppingCriteria CreateWarmupOverhead();
    public virtual IStoppingCriteria CreateWarmup(Job job, IResolver resolver, IterationMode mode, RunStrategy runStrategy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UsedImplicitlyAttribute]
public class BenchmarkDotNet.Engines.Engine : object {
    public static int MinInvokeCount;
    [CompilerGeneratedAttribute]
private IHost <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<long> <WorkloadAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <Dummy1Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <Dummy2Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <Dummy3Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<long> <OverheadAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Job <TargetJob>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OperationsPerInvoke>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <GlobalSetupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <GlobalCleanupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <IterationSetupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <IterationCleanupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BenchmarkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IClock <Clock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceGcCleanups>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnrollFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private RunStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EvaluateOverhead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MemoryRandomization>k__BackingField;
    private List`1<Measurement> jittingMeasurements;
    private EnginePilotStage pilotStage;
    private EngineWarmupStage warmupStage;
    private EngineActualStage actualStage;
    private bool includeExtraStats;
    private Random random;
    [PublicAPIAttribute]
public IHost Host { get; }
    [PublicAPIAttribute]
public Action`1<long> WorkloadAction { get; }
    [PublicAPIAttribute]
public Action Dummy1Action { get; }
    [PublicAPIAttribute]
public Action Dummy2Action { get; }
    [PublicAPIAttribute]
public Action Dummy3Action { get; }
    [PublicAPIAttribute]
public Action`1<long> OverheadAction { get; }
    [PublicAPIAttribute]
public Job TargetJob { get; }
    [PublicAPIAttribute]
public long OperationsPerInvoke { get; }
    [PublicAPIAttribute]
public Action GlobalSetupAction { get; }
    [PublicAPIAttribute]
public Action GlobalCleanupAction { get; }
    [PublicAPIAttribute]
public Action IterationSetupAction { get; }
    [PublicAPIAttribute]
public Action IterationCleanupAction { get; }
    [PublicAPIAttribute]
public IResolver Resolver { get; }
    [PublicAPIAttribute]
public CultureInfo CultureInfo { get; }
    [PublicAPIAttribute]
public string BenchmarkName { get; }
    private IClock Clock { get; }
    private bool ForceGcCleanups { get; }
    private int UnrollFactor { get; }
    private RunStrategy Strategy { get; }
    private bool EvaluateOverhead { get; }
    private bool MemoryRandomization { get; }
    internal Engine(IHost host, IResolver resolver, Action dummy1Action, Action dummy2Action, Action dummy3Action, Action`1<long> overheadAction, Action`1<long> workloadAction, Job targetJob, Action globalSetupAction, Action globalCleanupAction, Action iterationSetupAction, Action iterationCleanupAction, long operationsPerInvoke, bool includeExtraStats, string benchmarkName);
    [CompilerGeneratedAttribute]
public sealed virtual IHost get_Host();
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<long> get_WorkloadAction();
    [CompilerGeneratedAttribute]
public Action get_Dummy1Action();
    [CompilerGeneratedAttribute]
public Action get_Dummy2Action();
    [CompilerGeneratedAttribute]
public Action get_Dummy3Action();
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<long> get_OverheadAction();
    [CompilerGeneratedAttribute]
public sealed virtual Job get_TargetJob();
    [CompilerGeneratedAttribute]
public sealed virtual long get_OperationsPerInvoke();
    [CompilerGeneratedAttribute]
public sealed virtual Action get_GlobalSetupAction();
    [CompilerGeneratedAttribute]
public sealed virtual Action get_GlobalCleanupAction();
    [CompilerGeneratedAttribute]
public Action get_IterationSetupAction();
    [CompilerGeneratedAttribute]
public Action get_IterationCleanupAction();
    [CompilerGeneratedAttribute]
public sealed virtual IResolver get_Resolver();
    [CompilerGeneratedAttribute]
public CultureInfo get_CultureInfo();
    [CompilerGeneratedAttribute]
public string get_BenchmarkName();
    [CompilerGeneratedAttribute]
private IClock get_Clock();
    [CompilerGeneratedAttribute]
private bool get_ForceGcCleanups();
    [CompilerGeneratedAttribute]
private int get_UnrollFactor();
    [CompilerGeneratedAttribute]
private RunStrategy get_Strategy();
    [CompilerGeneratedAttribute]
private bool get_EvaluateOverhead();
    [CompilerGeneratedAttribute]
private bool get_MemoryRandomization();
    public sealed virtual void Dispose();
    public sealed virtual RunResults Run();
    public sealed virtual Measurement RunIteration(IterationData data);
    private ClockSpan MeasureWithRandomMemory(Action`1<long> action, long invokeCount);
    [NullableContextAttribute("0")]
private void Consume(Byte* _);
    private ClockSpan Measure(Action`1<long> action, long invokeCount);
    [NullableContextAttribute("0")]
private ValueTuple`3<GcStats, ThreadingStats, double> GetExtraStats(IterationData data);
    private void RandomizeManagedHeapMemory();
    private void GcCollect();
    private static void ForceGcCollect();
    public sealed virtual void WriteLine(string text);
    public sealed virtual void WriteLine();
    private static void EnableMonitoring();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.EngineActualStage : EngineStage {
    internal static int MaxOverheadIterationCount;
    private static double MaxOverheadRelativeError;
    private static int DefaultWorkloadCount;
    private Nullable`1<int> iterationCount;
    private double maxRelativeError;
    private Nullable`1<TimeInterval> maxAbsoluteError;
    private OutlierMode outlierMode;
    private int minIterationCount;
    private int maxIterationCount;
    public EngineActualStage(IEngine engine);
    public IReadOnlyList`1<Measurement> RunOverhead(long invokeCount, int unrollFactor);
    public IReadOnlyList`1<Measurement> RunWorkload(long invokeCount, int unrollFactor, bool forceSpecific);
    internal IReadOnlyList`1<Measurement> Run(long invokeCount, IterationMode iterationMode, bool runAuto, int unrollFactor, bool forceSpecific);
    private List`1<Measurement> RunAuto(long invokeCount, IterationMode iterationMode, int unrollFactor);
    private List`1<Measurement> RunSpecific(long invokeCount, IterationMode iterationMode, int iterationCount, int unrollFactor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EventSourceAttribute]
public class BenchmarkDotNet.Engines.EngineEventSource : EventSource {
    public static string SourceName;
    [PublicAPIAttribute]
public static int BenchmarkStartEventId;
    [PublicAPIAttribute]
public static int BenchmarkStopEventId;
    [PublicAPIAttribute]
public static int OverheadJittingStartEventId;
    [PublicAPIAttribute]
public static int OverheadJittingStopEventId;
    [PublicAPIAttribute]
public static int WorkloadJittingStartEventId;
    [PublicAPIAttribute]
public static int WorkloadJittingStopEventId;
    [PublicAPIAttribute]
public static int WorkloadPilotStartEventId;
    [PublicAPIAttribute]
public static int WorkloadPilotStopEventId;
    [PublicAPIAttribute]
public static int OverheadWarmupStartEventId;
    [PublicAPIAttribute]
public static int OverheadWarmupStopEventId;
    [PublicAPIAttribute]
public static int OverheadActualStartEventId;
    [PublicAPIAttribute]
public static int OverheadActualStopEventId;
    [PublicAPIAttribute]
public static int WorkloadWarmupStartEventId;
    [PublicAPIAttribute]
public static int WorkloadWarmupStopEventId;
    [PublicAPIAttribute]
public static int WorkloadActualStartEventId;
    [PublicAPIAttribute]
public static int WorkloadActualStopEventId;
    internal static EngineEventSource Log;
    private static EngineEventSource();
    [EventAttribute("1")]
internal void BenchmarkStart(string benchmarkName);
    [EventAttribute("2")]
internal void BenchmarkStop(string benchmarkName);
    [EventAttribute("3")]
internal void OverheadJittingStart(long totalOperations);
    [EventAttribute("4")]
internal void OverheadJittingStop(long totalOperations);
    [EventAttribute("5")]
internal void WorkloadJittingStart(long totalOperations);
    [EventAttribute("6")]
internal void WorkloadJittingStop(long totalOperations);
    [EventAttribute("7")]
internal void WorkloadPilotStart(long totalOperations);
    [EventAttribute("8")]
internal void WorkloadPilotStop(long totalOperations);
    [EventAttribute("9")]
internal void OverheadWarmupStart(long totalOperations);
    [EventAttribute("10")]
internal void OverheadWarmupStop(long totalOperations);
    [EventAttribute("11")]
internal void OverheadActualStart(long totalOperations);
    [EventAttribute("12")]
internal void OverheadActualStop(long totalOperations);
    [EventAttribute("13")]
internal void WorkloadWarmupStart(long totalOperations);
    [EventAttribute("14")]
internal void WorkloadWarmupStop(long totalOperations);
    [EventAttribute("15")]
internal void WorkloadActualStart(long totalOperations);
    [EventAttribute("16")]
internal void WorkloadActualStop(long totalOperations);
    [NonEventAttribute]
internal void IterationStart(IterationMode mode, IterationStage stage, long totalOperations);
    [NonEventAttribute]
internal void IterationStop(IterationMode mode, IterationStage stage, long totalOperations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.EngineFactory : object {
    public sealed virtual IEngine CreateReadyToRun(EngineParameters engineParameters);
    private static TimeInterval Jit(Engine engine, int jitIndex, int invokeCount, int unrollFactor);
    private static Engine CreateMultiActionEngine(EngineParameters engineParameters);
    private static Engine CreateSingleActionEngine(EngineParameters engineParameters);
    private static Engine CreateEngine(EngineParameters engineParameters, Job job, Action`1<long> idle, Action`1<long> main);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.EngineParameters : object {
    public static IResolver DefaultResolver;
    [CompilerGeneratedAttribute]
private IHost <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<long> <WorkloadActionNoUnroll>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<long> <WorkloadActionUnroll>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <Dummy1Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <Dummy2Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <Dummy3Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<long> <OverheadActionNoUnroll>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<long> <OverheadActionUnroll>k__BackingField;
    [CompilerGeneratedAttribute]
private Job <TargetJob>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OperationsPerInvoke>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <GlobalSetupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <GlobalCleanupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <IterationSetupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <IterationCleanupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MeasureExtraStats>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BenchmarkName>k__BackingField;
    public IHost Host { get; public set; }
    public Action`1<long> WorkloadActionNoUnroll { get; public set; }
    public Action`1<long> WorkloadActionUnroll { get; public set; }
    public Action Dummy1Action { get; public set; }
    public Action Dummy2Action { get; public set; }
    public Action Dummy3Action { get; public set; }
    public Action`1<long> OverheadActionNoUnroll { get; public set; }
    public Action`1<long> OverheadActionUnroll { get; public set; }
    public Job TargetJob { get; public set; }
    public long OperationsPerInvoke { get; public set; }
    public Action GlobalSetupAction { get; public set; }
    public Action GlobalCleanupAction { get; public set; }
    public Action IterationSetupAction { get; public set; }
    public Action IterationCleanupAction { get; public set; }
    public bool MeasureExtraStats { get; public set; }
    [PublicAPIAttribute]
public string BenchmarkName { get; public set; }
    public bool NeedsJitting { get; }
    public bool HasInvocationCount { get; }
    public bool HasUnrollFactor { get; }
    public int UnrollFactor { get; }
    public TimeInterval IterationTime { get; }
    private static EngineParameters();
    [CompilerGeneratedAttribute]
public IHost get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(IHost value);
    [CompilerGeneratedAttribute]
public Action`1<long> get_WorkloadActionNoUnroll();
    [CompilerGeneratedAttribute]
public void set_WorkloadActionNoUnroll(Action`1<long> value);
    [CompilerGeneratedAttribute]
public Action`1<long> get_WorkloadActionUnroll();
    [CompilerGeneratedAttribute]
public void set_WorkloadActionUnroll(Action`1<long> value);
    [CompilerGeneratedAttribute]
public Action get_Dummy1Action();
    [CompilerGeneratedAttribute]
public void set_Dummy1Action(Action value);
    [CompilerGeneratedAttribute]
public Action get_Dummy2Action();
    [CompilerGeneratedAttribute]
public void set_Dummy2Action(Action value);
    [CompilerGeneratedAttribute]
public Action get_Dummy3Action();
    [CompilerGeneratedAttribute]
public void set_Dummy3Action(Action value);
    [CompilerGeneratedAttribute]
public Action`1<long> get_OverheadActionNoUnroll();
    [CompilerGeneratedAttribute]
public void set_OverheadActionNoUnroll(Action`1<long> value);
    [CompilerGeneratedAttribute]
public Action`1<long> get_OverheadActionUnroll();
    [CompilerGeneratedAttribute]
public void set_OverheadActionUnroll(Action`1<long> value);
    [CompilerGeneratedAttribute]
public Job get_TargetJob();
    [CompilerGeneratedAttribute]
public void set_TargetJob(Job value);
    [CompilerGeneratedAttribute]
public long get_OperationsPerInvoke();
    [CompilerGeneratedAttribute]
public void set_OperationsPerInvoke(long value);
    [CompilerGeneratedAttribute]
public Action get_GlobalSetupAction();
    [CompilerGeneratedAttribute]
public void set_GlobalSetupAction(Action value);
    [CompilerGeneratedAttribute]
public Action get_GlobalCleanupAction();
    [CompilerGeneratedAttribute]
public void set_GlobalCleanupAction(Action value);
    [CompilerGeneratedAttribute]
public Action get_IterationSetupAction();
    [CompilerGeneratedAttribute]
public void set_IterationSetupAction(Action value);
    [CompilerGeneratedAttribute]
public Action get_IterationCleanupAction();
    [CompilerGeneratedAttribute]
public void set_IterationCleanupAction(Action value);
    [CompilerGeneratedAttribute]
public bool get_MeasureExtraStats();
    [CompilerGeneratedAttribute]
public void set_MeasureExtraStats(bool value);
    [CompilerGeneratedAttribute]
public string get_BenchmarkName();
    [CompilerGeneratedAttribute]
public void set_BenchmarkName(string value);
    public bool get_NeedsJitting();
    public bool get_HasInvocationCount();
    public bool get_HasUnrollFactor();
    public int get_UnrollFactor();
    public TimeInterval get_IterationTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Engines.EnginePilotStage : EngineStage {
    internal static long MaxInvokeCount;
    private int unrollFactor;
    private TimeInterval minIterationTime;
    private int minInvokeCount;
    private double maxRelativeError;
    private Nullable`1<TimeInterval> maxAbsoluteError;
    private double targetIterationTime;
    private double resolution;
    public EnginePilotStage(IEngine engine);
    public PilotStageResult Run();
    private PilotStageResult RunAuto();
    private PilotStageResult RunSpecific();
    private long Autocorrect(long count);
}
public class BenchmarkDotNet.Engines.EngineResolver : Resolver {
    internal static int DefaultMinWorkloadIterationCount;
    internal static int DefaultMaxWorkloadIterationCount;
    internal static int DefaultIterationTime;
    internal static int ForceAutoWarmup;
    internal static int DefaultMinWarmupIterationCount;
    internal static int DefaultMaxWarmupIterationCount;
    [NullableAttribute("1")]
public static IResolver Instance;
    private static EngineResolver();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private OutlierMode <.ctor>b__7_11(CharacteristicObject job);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.EngineStage : object {
    private IEngine engine;
    protected Job TargetJob { get; }
    protected EngineStage(IEngine engine);
    protected Job get_TargetJob();
    protected Measurement RunIteration(IterationMode mode, IterationStage stage, int index, long invokeCount, int unrollFactor);
    internal List`1<Measurement> Run(IStoppingCriteria criteria, long invokeCount, IterationMode mode, IterationStage stage, int unrollFactor);
    protected void WriteLine();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Engines.EngineWarmupStage : EngineStage {
    private IEngine engine;
    public EngineWarmupStage(IEngine engine);
    public IReadOnlyList`1<Measurement> RunOverhead(long invokeCount, int unrollFactor);
    public IReadOnlyList`1<Measurement> RunWorkload(long invokeCount, int unrollFactor, RunStrategy runStrategy);
    internal IReadOnlyList`1<Measurement> Run(long invokeCount, IterationMode iterationMode, int unrollFactor, RunStrategy runStrategy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Engines.ExceptionsStats : object {
    internal static string ResultsLinePrefix;
    private long exceptionsCount;
    internal long ExceptionsCount { get; }
    internal long get_ExceptionsCount();
    public void StartListening();
    public void Stop();
    private void OnFirstChanceException(object sender, FirstChanceExceptionEventArgs e);
    public static string ToOutputLine(double exceptionCount);
    public static double Parse(string line);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.FixedStoppingCriteria : StoppingCriteriaBase {
    private int iterationCount;
    private string message;
    public FixedStoppingCriteria(int iterationCount);
    public virtual StoppingResult Evaluate(IReadOnlyList`1<Measurement> measurements);
    protected virtual string GetTitle();
    protected virtual int GetMaxIterationCount();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Engines.FixedStoppingCriteria/<GetWarnings>d__6")]
protected virtual IEnumerable`1<string> GetWarnings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.GcStats : ValueType {
    internal static string ResultsLinePrefix;
    public static long AllocationQuantum;
    public static GcStats Empty;
    [CompilerGeneratedAttribute]
private int <Gen0Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Gen1Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Gen2Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <AllocatedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalOperations>k__BackingField;
    public int Gen0Collections { get; }
    public int Gen1Collections { get; }
    public int Gen2Collections { get; }
    private Nullable`1<long> AllocatedBytes { get; }
    public long TotalOperations { get; }
    private GcStats(int gen0Collections, int gen1Collections, int gen2Collections, Nullable`1<long> allocatedBytes, long totalOperations);
    private static GcStats();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Gen0Collections();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Gen1Collections();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Gen2Collections();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private Nullable`1<long> get_AllocatedBytes();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TotalOperations();
    public Nullable`1<long> GetBytesAllocatedPerOperation(BenchmarkCase benchmarkCase);
    public static GcStats op_Addition(GcStats left, GcStats right);
    public static GcStats op_Subtraction(GcStats left, GcStats right);
    private static Nullable`1<long> ClampToPositive(Nullable`1<long> num);
    public GcStats WithTotalOperations(long totalOperationsCount);
    public int GetCollectionsCount(int generation);
    public Nullable`1<long> GetTotalAllocatedBytes(bool excludeAllocationQuantumSideEffects);
    public static GcStats ReadInitial();
    public static GcStats ReadFinal();
    [PublicAPIAttribute]
public static GcStats FromForced(int forcedFullGarbageCollections);
    private static Nullable`1<long> GetAllocatedBytes();
    public string ToOutputLine();
    public static GcStats Parse(string line);
    private static bool TryParse(string s, Nullable`1& result);
    public virtual string ToString();
    private static long CalculateAllocationQuantumSize();
    public sealed virtual bool Equals(GcStats other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Engines.HostExtensions : object {
    [ExtensionAttribute]
[StringFormatMethodAttribute("messageFormat")]
public static void WriteLine(IHost host, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void BeforeAnythingElse(IHost host);
    [ExtensionAttribute]
public static void BeforeMainRun(IHost host);
    [ExtensionAttribute]
public static void AfterMainRun(IHost host);
    [ExtensionAttribute]
public static void AfterAll(IHost host);
}
public enum BenchmarkDotNet.Engines.HostSignal : Enum {
    public int value__;
    public static HostSignal BeforeProcessStart;
    public static HostSignal BeforeAnythingElse;
    public static HostSignal BeforeActualRun;
    public static HostSignal AfterActualRun;
    public static HostSignal AfterAll;
    public static HostSignal SeparateLogic;
    public static HostSignal AfterProcessExit;
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Engines.IEngine {
    public IHost Host { get; }
    public Job TargetJob { get; }
    public long OperationsPerInvoke { get; }
    [NullableAttribute("2")]
public Action GlobalSetupAction { get; }
    [NullableAttribute("2")]
public Action GlobalCleanupAction { get; }
    public Action`1<long> WorkloadAction { get; }
    public Action`1<long> OverheadAction { get; }
    public IResolver Resolver { get; }
    public abstract virtual IHost get_Host();
    public abstract virtual void WriteLine();
    public abstract virtual void WriteLine(string line);
    public abstract virtual Job get_TargetJob();
    public abstract virtual long get_OperationsPerInvoke();
    [NullableContextAttribute("2")]
public abstract virtual Action get_GlobalSetupAction();
    [NullableContextAttribute("2")]
public abstract virtual Action get_GlobalCleanupAction();
    public abstract virtual Action`1<long> get_WorkloadAction();
    public abstract virtual Action`1<long> get_OverheadAction();
    public abstract virtual IResolver get_Resolver();
    public abstract virtual Measurement RunIteration(IterationData data);
    public abstract virtual RunResults Run();
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Engines.IEngineFactory {
    public abstract virtual IEngine CreateReadyToRun(EngineParameters engineParameters);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Engines.IHost {
    public abstract virtual void Write(string message);
    public abstract virtual void WriteLine();
    public abstract virtual void WriteLine(string message);
    public abstract virtual void SendSignal(HostSignal hostSignal);
    public abstract virtual void SendError(string message);
    public abstract virtual void ReportResults(RunResults runResults);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Engines.IStoppingCriteria {
    public string Title { get; }
    public int MaxIterationCount { get; }
    public IReadOnlyList`1<string> Warnings { get; }
    public abstract virtual StoppingResult Evaluate(IReadOnlyList`1<Measurement> measurements);
    public abstract virtual string get_Title();
    public abstract virtual int get_MaxIterationCount();
    public abstract virtual IReadOnlyList`1<string> get_Warnings();
}
public class BenchmarkDotNet.Engines.IterationData : ValueType {
    [CompilerGeneratedAttribute]
private IterationMode <IterationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IterationStage <IterationStage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private long <InvokeCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnrollFactor>k__BackingField;
    public IterationMode IterationMode { get; }
    public IterationStage IterationStage { get; }
    public int Index { get; }
    public long InvokeCount { get; }
    public int UnrollFactor { get; }
    public IterationData(IterationMode iterationMode, IterationStage iterationStage, int index, long invokeCount, int unrollFactor);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IterationMode get_IterationMode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IterationStage get_IterationStage();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_InvokeCount();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_UnrollFactor();
}
public enum BenchmarkDotNet.Engines.IterationMode : Enum {
    public int value__;
    public static IterationMode Overhead;
    public static IterationMode Workload;
    public static IterationMode Unknown;
}
public enum BenchmarkDotNet.Engines.IterationStage : Enum {
    public int value__;
    public static IterationStage Jitting;
    public static IterationStage Pilot;
    public static IterationStage Warmup;
    public static IterationStage Actual;
    public static IterationStage Result;
    public static IterationStage Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost : object {
    private TextWriter outWriter;
    public sealed virtual void Write(string message);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(string message);
    public sealed virtual void SendSignal(HostSignal hostSignal);
    public sealed virtual void SendError(string message);
    public sealed virtual void ReportResults(RunResults runResults);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.RunResults : ValueType {
    private OutlierMode outlierMode;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Measurement> <EngineMeasurements>k__BackingField;
    [CompilerGeneratedAttribute]
private GcStats <GCStats>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadingStats <ThreadingStats>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ExceptionFrequency>k__BackingField;
    [PublicAPIAttribute]
public IReadOnlyList`1<Measurement> EngineMeasurements { get; }
    [NullableAttribute("2")]
[PublicAPIAttribute]
public IReadOnlyList`1<Measurement> Overhead { get; }
    [PublicAPIAttribute]
public IReadOnlyList`1<Measurement> Workload { get; }
    public GcStats GCStats { get; }
    public ThreadingStats ThreadingStats { get; }
    public double ExceptionFrequency { get; }
    public RunResults(IReadOnlyList`1<Measurement> engineMeasurements, OutlierMode outlierMode, GcStats gcStats, ThreadingStats threadingStats, double exceptionFrequency);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IReadOnlyList`1<Measurement> get_EngineMeasurements();
    [NullableContextAttribute("2")]
public IReadOnlyList`1<Measurement> get_Overhead();
    public IReadOnlyList`1<Measurement> get_Workload();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GcStats get_GCStats();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ThreadingStats get_ThreadingStats();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_ExceptionFrequency();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Engines.RunResults/<GetWorkloadResultMeasurements>d__18")]
public IEnumerable`1<Measurement> GetWorkloadResultMeasurements();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Engines.RunResults/<GetAllMeasurements>d__19")]
public IEnumerable`1<Measurement> GetAllMeasurements();
    public void Print(TextWriter outWriter);
    private static bool IsSuspiciouslySmall(double value);
}
public enum BenchmarkDotNet.Engines.RunStrategy : Enum {
    public int value__;
    public static RunStrategy Throughput;
    public static RunStrategy ColdStart;
    public static RunStrategy Monitoring;
}
[ExtensionAttribute]
public static class BenchmarkDotNet.Engines.RunStrategyExtensions : object {
    [ExtensionAttribute]
public static bool NeedsJitting(RunStrategy runStrategy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Engines.StoppingCriteriaBase : object {
    private Lazy`1<string> lazyTitle;
    private Lazy`1<int> lazyMaxIterationCount;
    private Lazy`1<String[]> lazyWarnings;
    public string Title { get; }
    public int MaxIterationCount { get; }
    public IReadOnlyList`1<string> Warnings { get; }
    public sealed virtual string get_Title();
    public sealed virtual int get_MaxIterationCount();
    public sealed virtual IReadOnlyList`1<string> get_Warnings();
    public abstract virtual StoppingResult Evaluate(IReadOnlyList`1<Measurement> measurements);
    protected abstract virtual string GetTitle();
    protected abstract virtual int GetMaxIterationCount();
    protected abstract virtual IEnumerable`1<string> GetWarnings();
    [CompilerGeneratedAttribute]
private String[] <.ctor>b__9_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.StoppingResult : ValueType {
    public bool IsFinished;
    public string Message;
    public static StoppingResult NotFinished;
    private StoppingResult(bool isFinished, string message);
    private static StoppingResult();
    [NullableContextAttribute("1")]
public static StoppingResult CreateFinished(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Engines.ThreadingStats : ValueType {
    internal static string ResultsLinePrefix;
    private static Func`1<long> GetCompletedWorkItemCountDelegate;
    private static Func`1<long> GetLockContentionCountDelegate;
    [CompilerGeneratedAttribute]
private long <CompletedWorkItemCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LockContentionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalOperations>k__BackingField;
    public static ThreadingStats Empty { get; }
    public long CompletedWorkItemCount { get; }
    public long LockContentionCount { get; }
    public long TotalOperations { get; }
    public ThreadingStats(long completedWorkItemCount, long lockContentionCount, long totalOperations);
    private static ThreadingStats();
    public static ThreadingStats get_Empty();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_CompletedWorkItemCount();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_LockContentionCount();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TotalOperations();
    public static ThreadingStats ReadInitial();
    public static ThreadingStats ReadFinal();
    public string ToOutputLine();
    public static ThreadingStats Parse(string line);
    public static ThreadingStats op_Addition(ThreadingStats left, ThreadingStats right);
    public static ThreadingStats op_Subtraction(ThreadingStats left, ThreadingStats right);
    public ThreadingStats WithTotalOperations(long totalOperationsCount);
    public virtual string ToString();
    private static Func`1<long> CreateGetterDelegate(Type type, string propertyName);
    public sealed virtual bool Equals(ThreadingStats other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo : object {
    internal static string RuntimeInfoPrefix;
    internal static string GcInfoPrefix;
    internal static string HardwareIntrinsicsPrefix;
    [CompilerGeneratedAttribute]
private string <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAttachedDebugger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasRyuJit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JitInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HardwareIntrinsicsShort>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerGC>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConcurrentGC>k__BackingField;
    [CompilerGeneratedAttribute]
private long <GCAllocationQuantum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InDocker>k__BackingField;
    [PublicAPIAttribute]
public string Architecture { get; protected set; }
    [PublicAPIAttribute]
public string Configuration { get; protected set; }
    [PublicAPIAttribute]
public string RuntimeVersion { get; protected set; }
    [PublicAPIAttribute]
public bool HasAttachedDebugger { get; protected set; }
    [PublicAPIAttribute]
public bool HasRyuJit { get; protected set; }
    [PublicAPIAttribute]
public string JitInfo { get; protected set; }
    [PublicAPIAttribute]
public string HardwareIntrinsicsShort { get; protected set; }
    [PublicAPIAttribute]
public bool IsServerGC { get; protected set; }
    [PublicAPIAttribute]
public bool IsConcurrentGC { get; protected set; }
    [PublicAPIAttribute]
public long GCAllocationQuantum { get; protected set; }
    [PublicAPIAttribute]
public bool InDocker { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Architecture();
    [CompilerGeneratedAttribute]
protected void set_Architecture(string value);
    [CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
protected void set_Configuration(string value);
    [CompilerGeneratedAttribute]
public string get_RuntimeVersion();
    [CompilerGeneratedAttribute]
protected void set_RuntimeVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_HasAttachedDebugger();
    [CompilerGeneratedAttribute]
protected void set_HasAttachedDebugger(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasRyuJit();
    [CompilerGeneratedAttribute]
protected void set_HasRyuJit(bool value);
    [CompilerGeneratedAttribute]
public string get_JitInfo();
    [CompilerGeneratedAttribute]
protected void set_JitInfo(string value);
    [CompilerGeneratedAttribute]
public string get_HardwareIntrinsicsShort();
    [CompilerGeneratedAttribute]
protected void set_HardwareIntrinsicsShort(string value);
    [CompilerGeneratedAttribute]
public bool get_IsServerGC();
    [CompilerGeneratedAttribute]
protected void set_IsServerGC(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsConcurrentGC();
    [CompilerGeneratedAttribute]
protected void set_IsConcurrentGC(bool value);
    [CompilerGeneratedAttribute]
public long get_GCAllocationQuantum();
    [CompilerGeneratedAttribute]
protected void set_GCAllocationQuantum(long value);
    [CompilerGeneratedAttribute]
public bool get_InDocker();
    [CompilerGeneratedAttribute]
protected void set_InDocker(bool value);
    public static BenchmarkEnvironmentInfo GetCurrent();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo/<ToFormattedString>d__49")]
public virtual IEnumerable`1<string> ToFormattedString();
    [PublicAPIAttribute]
protected string GetConfigurationFlag();
    [PublicAPIAttribute]
protected string GetDebuggerFlag();
    [PublicAPIAttribute]
protected string GetGcServerFlag();
    [PublicAPIAttribute]
protected string GetGcConcurrentFlag();
    internal string GetRuntimeInfo();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo/<Validate>d__55")]
public static IEnumerable`1<ValidationError> Validate(Job job);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Environments.ClrRuntime : Runtime {
    public static ClrRuntime Net461;
    public static ClrRuntime Net462;
    public static ClrRuntime Net47;
    public static ClrRuntime Net471;
    public static ClrRuntime Net472;
    public static ClrRuntime Net48;
    public static ClrRuntime Net481;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    private ClrRuntime(RuntimeMoniker runtimeMoniker, string msBuildMoniker, string displayName, string version);
    private static ClrRuntime();
    [CompilerGeneratedAttribute]
public string get_Version();
    public static ClrRuntime CreateForLocalFullNetFrameworkBuild(string version);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ClrRuntime other);
    public virtual int GetHashCode();
    internal static ClrRuntime GetCurrentVersion();
}
[ObsoleteAttribute("Please use NativeAotRuntime instead.", "True")]
public class BenchmarkDotNet.Environments.CoreRtRuntime : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Environments.CoreRuntime : Runtime {
    public static CoreRuntime Core20;
    public static CoreRuntime Core21;
    public static CoreRuntime Core22;
    public static CoreRuntime Core30;
    public static CoreRuntime Core31;
    public static CoreRuntime Core50;
    public static CoreRuntime Core60;
    public static CoreRuntime Core70;
    public static CoreRuntime Core80;
    public static CoreRuntime Core90;
    public static CoreRuntime Latest { get; }
    public bool IsPlatformSpecific { get; }
    private CoreRuntime(RuntimeMoniker runtimeMoniker, string msBuildMoniker, string displayName);
    private static CoreRuntime();
    public static CoreRuntime get_Latest();
    public bool get_IsPlatformSpecific();
    public static CoreRuntime CreateForNewVersion(string msBuildMoniker, string displayName);
    internal static CoreRuntime GetCurrentVersion();
    internal static CoreRuntime FromVersion(Version version);
    [NullableContextAttribute("2")]
internal static bool TryGetVersion(Version& version);
    internal static bool TryGetVersionFromRuntimeDirectory(string runtimeDirectory, Version& version);
    internal static bool TryGetVersionFromProductInfo(string productVersion, string productName, Version& version);
    internal static bool TryGetVersionFromFrameworkName(string frameworkName, Version& version);
    private static string GetParsableVersionPart(string fullVersionName);
    private static CoreRuntime GetPlatformSpecific(CoreRuntime fallback);
}
public abstract class BenchmarkDotNet.Environments.CustomRuntime : Runtime {
    [NullableContextAttribute("1")]
protected CustomRuntime(RuntimeMoniker runtimeMoniker, string msBuildMoniker, string displayName);
}
public class BenchmarkDotNet.Environments.EnvironmentResolver : Resolver {
    public static int DefaultUnrollFactorForThroughput;
    [NullableAttribute("1")]
public static IResolver Instance;
    private static EnvironmentResolver();
}
public class BenchmarkDotNet.Environments.GcResolver : Resolver {
    [NullableAttribute("1")]
public static IResolver Instance;
    private static GcResolver();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Environments.HostEnvironmentInfo : BenchmarkEnvironmentInfo {
    public static string BenchmarkDotNetCaption;
    [NullableAttribute("2")]
private static HostEnvironmentInfo current;
    [CompilerGeneratedAttribute]
private string <BenchmarkDotNetVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<string> <OsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<CpuInfo> <CpuInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<string> <DotNetSdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<bool> <IsMonoInstalled>k__BackingField;
    [CompilerGeneratedAttribute]
private Frequency <ChronometerFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private HardwareTimerKind <HardwareTimerKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<ICollection`1<Antivirus>> <AntivirusProducts>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<VirtualMachineHypervisor> <VirtualMachineHypervisor>k__BackingField;
    public static ILogger FallbackLogger { get; }
    public string BenchmarkDotNetVersion { get; protected set; }
    public Lazy`1<string> OsVersion { get; protected set; }
    public Lazy`1<CpuInfo> CpuInfo { get; protected set; }
    public Lazy`1<string> DotNetSdkVersion { get; protected set; }
    public Lazy`1<bool> IsMonoInstalled { get; }
    [PublicAPIAttribute]
public Frequency ChronometerFrequency { get; protected set; }
    [PublicAPIAttribute]
public TimeInterval ChronometerResolution { get; }
    public HardwareTimerKind HardwareTimerKind { get; protected set; }
    public Lazy`1<ICollection`1<Antivirus>> AntivirusProducts { get; }
    public Lazy`1<VirtualMachineHypervisor> VirtualMachineHypervisor { get; protected set; }
    public static ILogger get_FallbackLogger();
    [CompilerGeneratedAttribute]
public string get_BenchmarkDotNetVersion();
    [CompilerGeneratedAttribute]
protected void set_BenchmarkDotNetVersion(string value);
    [CompilerGeneratedAttribute]
public Lazy`1<string> get_OsVersion();
    [CompilerGeneratedAttribute]
protected void set_OsVersion(Lazy`1<string> value);
    [CompilerGeneratedAttribute]
public Lazy`1<CpuInfo> get_CpuInfo();
    [CompilerGeneratedAttribute]
protected void set_CpuInfo(Lazy`1<CpuInfo> value);
    [CompilerGeneratedAttribute]
public Lazy`1<string> get_DotNetSdkVersion();
    [CompilerGeneratedAttribute]
protected void set_DotNetSdkVersion(Lazy`1<string> value);
    [CompilerGeneratedAttribute]
public Lazy`1<bool> get_IsMonoInstalled();
    [CompilerGeneratedAttribute]
public Frequency get_ChronometerFrequency();
    [CompilerGeneratedAttribute]
protected void set_ChronometerFrequency(Frequency value);
    public TimeInterval get_ChronometerResolution();
    [CompilerGeneratedAttribute]
public HardwareTimerKind get_HardwareTimerKind();
    [CompilerGeneratedAttribute]
protected void set_HardwareTimerKind(HardwareTimerKind value);
    [CompilerGeneratedAttribute]
public Lazy`1<ICollection`1<Antivirus>> get_AntivirusProducts();
    [CompilerGeneratedAttribute]
public Lazy`1<VirtualMachineHypervisor> get_VirtualMachineHypervisor();
    [CompilerGeneratedAttribute]
protected void set_VirtualMachineHypervisor(Lazy`1<VirtualMachineHypervisor> value);
    public static HostEnvironmentInfo GetCurrent();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Environments.HostEnvironmentInfo/<ToFormattedString>d__42")]
public virtual IEnumerable`1<string> ToFormattedString();
    [PublicAPIAttribute]
public bool IsDotNetCliInstalled();
    [PublicAPIAttribute]
public static string GetInformation();
}
public class BenchmarkDotNet.Environments.InfrastructureResolver : Resolver {
    [NullableAttribute("1")]
public static IResolver Instance;
    private static InfrastructureResolver();
}
public enum BenchmarkDotNet.Environments.Jit : Enum {
    public int value__;
    public static Jit Default;
    public static Jit LegacyJit;
    public static Jit RyuJit;
    public static Jit Llvm;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Environments.MonoAotLLVMRuntime : Runtime {
    [EditorBrowsableAttribute("1")]
internal static MonoAotLLVMRuntime Default;
    [CompilerGeneratedAttribute]
private FileInfo <AOTCompilerPath>k__BackingField;
    [CompilerGeneratedAttribute]
private MonoAotCompilerMode <AOTCompilerMode>k__BackingField;
    public FileInfo AOTCompilerPath { get; }
    public MonoAotCompilerMode AOTCompilerMode { get; }
    public bool IsAOT { get; }
    public MonoAotLLVMRuntime(FileInfo aotCompilerPath, MonoAotCompilerMode aotCompilerMode, string msBuildMoniker, string displayName, RuntimeMoniker moniker);
    private MonoAotLLVMRuntime(string msBuildMoniker, string displayName);
    private static MonoAotLLVMRuntime();
    [CompilerGeneratedAttribute]
public FileInfo get_AOTCompilerPath();
    [CompilerGeneratedAttribute]
public MonoAotCompilerMode get_AOTCompilerMode();
    public virtual bool get_IsAOT();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MonoAotLLVMRuntime other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Environments.MonoRuntime : Runtime {
    public static MonoRuntime Default;
    public static MonoRuntime Mono60;
    public static MonoRuntime Mono70;
    public static MonoRuntime Mono80;
    public static MonoRuntime Mono90;
    [CompilerGeneratedAttribute]
private string <CustomPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AotArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MonoBclPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDotNetBuiltIn>k__BackingField;
    public string CustomPath { get; }
    public string AotArgs { get; }
    public bool IsAOT { get; }
    public string MonoBclPath { get; }
    internal bool IsDotNetBuiltIn { get; }
    private MonoRuntime(string name);
    private MonoRuntime(string name, RuntimeMoniker runtimeMoniker, string msBuildMoniker, bool isDotNetBuiltIn);
    public MonoRuntime(string name, string customPath);
    public MonoRuntime(string name, string customPath, string aotArgs, string monoBclPath);
    private static MonoRuntime();
    [CompilerGeneratedAttribute]
public string get_CustomPath();
    [CompilerGeneratedAttribute]
public string get_AotArgs();
    public virtual bool get_IsAOT();
    [CompilerGeneratedAttribute]
public string get_MonoBclPath();
    [CompilerGeneratedAttribute]
internal bool get_IsDotNetBuiltIn();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MonoRuntime other);
    public virtual int GetHashCode();
    internal static Runtime GetCurrentVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Environments.NativeAotRuntime : Runtime {
    public static NativeAotRuntime Net60;
    public static NativeAotRuntime Net70;
    public static NativeAotRuntime Net80;
    public static NativeAotRuntime Net90;
    public bool IsAOT { get; }
    private NativeAotRuntime(RuntimeMoniker runtimeMoniker, string msBuildMoniker, string displayName);
    private static NativeAotRuntime();
    public virtual bool get_IsAOT();
    public static NativeAotRuntime GetCurrentVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Environments.OsBrandStringHelper : object {
    private static Dictionary`2<string, string> WindowsBrandVersions;
    private static OsBrandStringHelper();
    public static string Prettify(string osName, string osVersion, Nullable`1<int> windowsUbr);
    private static string PrettifyWindows(string osVersion, Nullable`1<int> windowsUbr);
    public static string PrettifyMacOSX(string systemVersion, string kernelVersion);
}
public enum BenchmarkDotNet.Environments.Platform : Enum {
    public int value__;
    public static Platform AnyCpu;
    public static Platform X86;
    public static Platform X64;
    public static Platform Arm;
    public static Platform Arm64;
    public static Platform Wasm;
    public static Platform S390x;
    public static Platform LoongArch64;
    public static Platform Armv6;
    public static Platform Ppc64le;
}
public enum BenchmarkDotNet.Environments.PowerPlan : Enum {
    public int value__;
    public static PowerPlan HighPerformance;
    public static PowerPlan UserPowerPlan;
    public static PowerPlan PowerSaver;
    public static PowerPlan Balanced;
    public static PowerPlan UltimatePerformance;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Environments.ProcessorBrandStringHelper : object {
    private static Lazy`1<Dictionary`2<string, string>> KnownMicroarchitectures;
    private static ProcessorBrandStringHelper();
    public static string Prettify(CpuInfo cpuInfo, bool includeMaxFrequency);
    private static string GetBrandStyledActualFrequency(Nullable`1<Frequency> frequency);
    private static string ParseMicroarchitecture(string processorName);
    internal static string ParseIntelCoreMicroarchitecture(string modelNumber);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Environments.Runtime : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeMoniker <RuntimeMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MsBuildMoniker>k__BackingField;
    [PublicAPIAttribute]
public string Name { get; }
    public RuntimeMoniker RuntimeMoniker { get; }
    public string MsBuildMoniker { get; }
    public bool IsAOT { get; }
    protected Runtime(RuntimeMoniker runtimeMoniker, string msBuildMoniker, string displayName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public RuntimeMoniker get_RuntimeMoniker();
    [CompilerGeneratedAttribute]
public string get_MsBuildMoniker();
    public virtual bool get_IsAOT();
    public virtual string ToString();
    public sealed virtual bool Equals(Runtime other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Environments.WasmRuntime : Runtime {
    [EditorBrowsableAttribute("1")]
internal static WasmRuntime Default;
    [CompilerGeneratedAttribute]
private string <JavaScriptEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JavaScriptEngineArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Aot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WasmDataDir>k__BackingField;
    public string JavaScriptEngine { get; }
    public string JavaScriptEngineArguments { get; }
    public bool Aot { get; }
    public string WasmDataDir { get; }
    public WasmRuntime(string msBuildMoniker, string displayName, string javaScriptEngine, string javaScriptEngineArguments, bool aot, string wasmDataDir, RuntimeMoniker moniker);
    private static WasmRuntime();
    [CompilerGeneratedAttribute]
public string get_JavaScriptEngine();
    [CompilerGeneratedAttribute]
public string get_JavaScriptEngineArguments();
    [CompilerGeneratedAttribute]
public bool get_Aot();
    [CompilerGeneratedAttribute]
public string get_WasmDataDir();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WasmRuntime other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.EventProcessors.CompositeEventProcessor : EventProcessor {
    private HashSet`1<EventProcessor> eventProcessors;
    public CompositeEventProcessor(BenchmarkRunInfo[] benchmarkRunInfos);
    public virtual void OnStartValidationStage();
    public virtual void OnValidationError(ValidationError validationError);
    public virtual void OnEndValidationStage();
    public virtual void OnStartBuildStage(IReadOnlyList`1<BuildPartition> partitions);
    public virtual void OnBuildComplete(BuildPartition buildPartition, BuildResult buildResult);
    public virtual void OnEndBuildStage();
    public virtual void OnStartRunStage();
    public virtual void OnEndRunStage();
    public virtual void OnStartRunBenchmarksInType(Type type, IReadOnlyList`1<BenchmarkCase> benchmarks);
    public virtual void OnEndRunBenchmarksInType(Type type, Summary summary);
    public virtual void OnEndRunBenchmark(BenchmarkCase benchmarkCase, BenchmarkReport report);
    public virtual void OnStartRunBenchmark(BenchmarkCase benchmarkCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.EventProcessors.EventProcessor : object {
    public virtual void OnStartValidationStage();
    public virtual void OnValidationError(ValidationError validationError);
    public virtual void OnEndValidationStage();
    public virtual void OnStartBuildStage(IReadOnlyList`1<BuildPartition> partitions);
    public virtual void OnBuildComplete(BuildPartition partition, BuildResult buildResult);
    public virtual void OnEndBuildStage();
    public virtual void OnStartRunStage();
    public virtual void OnStartRunBenchmarksInType(Type type, IReadOnlyList`1<BenchmarkCase> benchmarks);
    public virtual void OnEndRunBenchmarksInType(Type type, Summary summary);
    public virtual void OnStartRunBenchmark(BenchmarkCase benchmarkCase);
    public virtual void OnEndRunBenchmark(BenchmarkCase benchmarkCase, BenchmarkReport report);
    public virtual void OnEndRunStage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.AsciiDocExporter : ExporterBase {
    public static IExporter Default;
    protected string FileExtension { get; }
    private static AsciiDocExporter();
    protected virtual string get_FileExtension();
    public virtual void ExportToLog(Summary summary, ILogger logger);
    private static void PrintTable(SummaryTable table, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.BenchmarkReportExporter : ExporterBase {
    public static IExporter Default;
    private static BenchmarkReportExporter();
    public virtual void ExportToLog(Summary summary, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.CompositeExporter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IExporter> exporters;
    public string Name { get; }
    public CompositeExporter(ImmutableArray`1<IExporter> exporters);
    public sealed virtual string get_Name();
    public sealed virtual void ExportToLog(Summary summary, ILogger logger);
    public sealed virtual IEnumerable`1<string> ExportToFiles(Summary summary, ILogger consoleLogger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.Csv.CsvExporter : ExporterBase {
    private CsvSeparator separator;
    [NullableAttribute("2")]
private SummaryStyle style;
    public static IExporter Default;
    protected string FileExtension { get; }
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public CsvExporter(CsvSeparator separator, SummaryStyle style);
    private static CsvExporter();
    protected virtual string get_FileExtension();
    public virtual void ExportToLog(Summary summary, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Exporters.Csv.CsvHelper : object {
    private static string Quote;
    private static string TwoQuotes;
    private static Char[] ForbiddenSymbols;
    private static CsvHelper();
    public static string Escape(string value, string currentListSeparator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.Csv.CsvMeasurementsExporter : ExporterBase {
    public static CsvMeasurementsExporter Default;
    private static CharacteristicPresenter Presenter;
    private static Lazy`1<MeasurementColumn[]> Columns;
    private CsvSeparator separator;
    [CompilerGeneratedAttribute]
private SummaryStyle <Style>k__BackingField;
    public string Separator { get; }
    protected string FileExtension { get; }
    protected string FileCaption { get; }
    [PublicAPIAttribute]
public SummaryStyle Style { get; }
    [NullableContextAttribute("2")]
public CsvMeasurementsExporter(CsvSeparator separator, SummaryStyle style);
    private static CsvMeasurementsExporter();
    [PublicAPIAttribute]
public static CsvMeasurementsExporter WithStyle(SummaryStyle style);
    public string get_Separator();
    protected virtual string get_FileExtension();
    protected virtual string get_FileCaption();
    [CompilerGeneratedAttribute]
public SummaryStyle get_Style();
    [PublicAPIAttribute]
public static Job[] GetJobs(Summary summary);
    public virtual void ExportToLog(Summary summary, ILogger logger);
    private static MeasurementColumn[] GetColumns(Summary summary);
    private static MeasurementColumn[] BuildColumns();
}
public enum BenchmarkDotNet.Exporters.Csv.CsvSeparator : Enum {
    public int value__;
    public static CsvSeparator Comma;
    public static CsvSeparator Semicolon;
    public static CsvSeparator CurrentCulture;
}
[ExtensionAttribute]
public static class BenchmarkDotNet.Exporters.Csv.CsvSeparatorExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToRealSeparator(CsvSeparator separator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Exporters.DefaultExporters : object {
    [PublicAPIAttribute]
public static IExporter AsciiDoc;
    [PublicAPIAttribute]
public static IExporter Csv;
    [PublicAPIAttribute]
public static IExporter CsvMeasurements;
    [PublicAPIAttribute]
public static IExporter Html;
    [PublicAPIAttribute]
public static IExporter Markdown;
    [PublicAPIAttribute]
public static IExporter Plain;
    [PublicAPIAttribute]
public static IExporter RPlot;
    [PublicAPIAttribute]
public static IExporter Json;
    [PublicAPIAttribute]
public static IExporter JsonBrief;
    [PublicAPIAttribute]
public static IExporter JsonBriefCompressed;
    [PublicAPIAttribute]
public static IExporter JsonFull;
    [PublicAPIAttribute]
public static IExporter JsonFullCompressed;
    [PublicAPIAttribute]
public static IExporter Xml;
    [PublicAPIAttribute]
public static IExporter XmlBrief;
    [PublicAPIAttribute]
public static IExporter XmlBriefCompressed;
    [PublicAPIAttribute]
public static IExporter XmlFull;
    [PublicAPIAttribute]
public static IExporter XmlFullCompressed;
    private static DefaultExporters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Exporters.ExporterBase : object {
    public string Name { get; }
    protected string FileExtension { get; }
    protected string FileNameSuffix { get; }
    protected string FileCaption { get; }
    public sealed virtual string get_Name();
    protected virtual string get_FileExtension();
    protected virtual string get_FileNameSuffix();
    protected virtual string get_FileCaption();
    public abstract virtual void ExportToLog(Summary summary, ILogger logger);
    public sealed virtual IEnumerable`1<string> ExportToFiles(Summary summary, ILogger consoleLogger);
    internal string GetArtifactFullName(Summary summary);
    private static string GetFileName(Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Exporters.FullNameProvider : object {
    private static IReadOnlyDictionary`2<Type, string> Aliases;
    private static FullNameProvider();
    [PublicAPIAttribute("used by the dotnet/performance repository")]
public static string GetBenchmarkName(BenchmarkCase benchmarkCase);
    private static string GetNestedTypes(Type type);
    internal static string GetTypeName(Type type);
    internal static string GetMethodName(BenchmarkCase benchmarkCase);
    private static string GetBenchmarkParameters(MethodInfo method, ParameterInstances benchmarkParameters);
    private static string GetArgument(object argumentValue, Type argumentType);
    private static string GetArray(IEnumerable collection);
    private static string GetTypeArgumentName(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.HtmlExporter : ExporterBase {
    private static string CssDefinition;
    public static IExporter Default;
    protected string FileExtension { get; }
    private static HtmlExporter();
    protected virtual string get_FileExtension();
    public virtual void ExportToLog(Summary summary, ILogger logger);
    private static void PrintAll(Summary summary, ILogger logger);
    private static void PrintTable(SummaryTable table, ILogger logger);
    private static void PrintLine(SummaryTable table, String[] line, ILogger logger, string leftDel, string rightDel);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Exporters.IExporter {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void ExportToLog(Summary summary, ILogger logger);
    public abstract virtual IEnumerable`1<string> ExportToFiles(Summary summary, ILogger consoleLogger);
}
[NullableContextAttribute("1")]
internal interface BenchmarkDotNet.Exporters.IExporterDependencies {
    public IEnumerable`1<IExporter> Dependencies { get; }
    public abstract virtual IEnumerable`1<IExporter> get_Dependencies();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Exporters.InstructionPointerExporter : object {
    internal static string CssStyle;
    private IHardwareCountersDiagnoser hardwareCountersDiagnoser;
    private DisassemblyDiagnoser disassemblyDiagnoser;
    public string Name { get; }
    internal InstructionPointerExporter(IHardwareCountersDiagnoser hardwareCountersDiagnoser, DisassemblyDiagnoser disassemblyDiagnoser);
    public sealed virtual string get_Name();
    public sealed virtual void ExportToLog(Summary summary, ILogger logger);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Exporters.InstructionPointerExporter/<ExportToFiles>d__7")]
public sealed virtual IEnumerable`1<string> ExportToFiles(Summary summary, ILogger consoleLogger);
    private string Export(Summary summary, BenchmarkCase benchmarkCase, DisassemblyResult disassemblyResult, PmcStats pmcStats);
    private static Dictionary`2<HardwareCounter, ValueTuple`2<ulong, ulong>> SumHardwareCountersStatsOfBenchmarkedCode(DisassemblyResult disassemblyResult, PmcStats pmcStats);
    private static IReadOnlyList`1<MethodWithCounters> SumHardwareCountersPerMethod(DisassemblyResult disassemblyResult, PmcStats pmcStats);
    private void Export(ILogger logger, BenchmarkCase benchmarkCase, Dictionary`2<HardwareCounter, ValueTuple`2<ulong, ulong>> totals, IReadOnlyList`1<MethodWithCounters> model, HardwareCounter[] hardwareCounters);
    private static string GetShortRuntimeInfo(string fullInfo);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Exporters.InstructionPointerExporter/<<SumHardwareCountersStatsOfBenchmarkedCode>g__Range|9_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ulong> <SumHardwareCountersStatsOfBenchmarkedCode>g__Range|9_0(Asm asm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.Json.JsonExporter : JsonExporterBase {
    public static IExporter Brief;
    public static IExporter Full;
    public static IExporter BriefCompressed;
    public static IExporter FullCompressed;
    public static IExporter Default;
    [CompilerGeneratedAttribute]
private string <FileNameSuffix>k__BackingField;
    protected string FileNameSuffix { get; }
    public JsonExporter(string fileNameSuffix, bool indentJson, bool excludeMeasurements);
    private static JsonExporter();
    [CompilerGeneratedAttribute]
protected virtual string get_FileNameSuffix();
    public static IExporter Custom(string fileNameSuffix, bool indentJson, bool excludeMeasurements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Exporters.Json.JsonExporterBase : ExporterBase {
    [CompilerGeneratedAttribute]
private bool <IndentJson>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeMeasurements>k__BackingField;
    protected string FileExtension { get; }
    private bool IndentJson { get; }
    private bool ExcludeMeasurements { get; }
    protected JsonExporterBase(bool indentJson, bool excludeMeasurements);
    protected virtual string get_FileExtension();
    [CompilerGeneratedAttribute]
private bool get_IndentJson();
    [CompilerGeneratedAttribute]
private bool get_ExcludeMeasurements();
    public virtual void ExportToLog(Summary summary, ILogger logger);
    protected virtual IReadOnlyDictionary`2<string, object> GetDataToSerialize(Summary summary);
    protected virtual IReadOnlyDictionary`2<string, object> GetDataToSerialize(HostEnvironmentInfo environmentInfo);
    protected virtual IReadOnlyDictionary`2<string, object> GetDataToSerialize(BenchmarkReport report);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.MarkdownExporter : ExporterBase {
    [CompilerGeneratedAttribute]
private string <Dialect>k__BackingField;
    public static IExporter Default;
    public static IExporter Console;
    public static IExporter StackOverflow;
    public static IExporter GitHub;
    public static IExporter Atlassian;
    internal static IExporter Mock;
    [PublicAPIAttribute]
protected string Prefix;
    [PublicAPIAttribute]
protected bool UseCodeBlocks;
    [PublicAPIAttribute]
protected string CodeBlockStart;
    [PublicAPIAttribute]
protected string CodeBlockEnd;
    [PublicAPIAttribute]
protected MarkdownHighlightStrategy StartOfGroupHighlightStrategy;
    [PublicAPIAttribute]
protected string TableHeaderSeparator;
    [PublicAPIAttribute]
protected string TableColumnSeparator;
    [PublicAPIAttribute]
protected bool UseHeaderSeparatingRow;
    [PublicAPIAttribute]
protected bool ColumnsStartWithSeparator;
    [PublicAPIAttribute]
protected string BoldMarkupFormat;
    [PublicAPIAttribute]
protected bool EscapeHtml;
    protected string FileExtension { get; }
    protected string FileNameSuffix { get; }
    protected string Dialect { get; protected set; }
    private static MarkdownExporter();
    protected virtual string get_FileExtension();
    protected virtual string get_FileNameSuffix();
    [CompilerGeneratedAttribute]
protected string get_Dialect();
    [CompilerGeneratedAttribute]
protected void set_Dialect(string value);
    public virtual void ExportToLog(Summary summary, ILogger logger);
    private ILogger GetRightLogger(ILogger logger);
    private void PrintTable(SummaryTable table, ILogger logger);
    private static string GetHeaderSeparatorIndicator(bool isNumeric);
    private static string GetHeaderSeparatorColumnDivider(int columnIndex, int columnCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.PlainExporter : ExporterBase {
    public static IExporter Default;
    private static PlainExporter();
    public virtual void ExportToLog(Summary summary, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.RPlotExporter : object {
    public static IExporter Default;
    private static string ImageExtension;
    private static object BuildScriptLock;
    public string Name { get; }
    public IEnumerable`1<IExporter> Dependencies { get; }
    private static RPlotExporter();
    public sealed virtual string get_Name();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Exporters.RPlotExporter/<get_Dependencies>d__6")]
public sealed virtual IEnumerable`1<IExporter> get_Dependencies();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Exporters.RPlotExporter/<ExportToFiles>d__7")]
public sealed virtual IEnumerable`1<string> ExportToFiles(Summary summary, ILogger consoleLogger);
    public sealed virtual void ExportToLog(Summary summary, ILogger logger);
    private static bool TryFindRScript(ILogger consoleLogger, String& rscriptPath);
    private static string FindInPath(string fileName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Exporters.Xml.BenchmarkReportDto : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Measurement> <Measurements>k__BackingField;
    private BenchmarkReport report;
    public string DisplayInfo { get; }
    public string Namespace { get; }
    public string Type { get; }
    public string Method { get; }
    public string MethodTitle { get; }
    public string Parameters { get; }
    public Statistics Statistics { get; }
    public IEnumerable`1<Metric> Metrics { get; }
    public GcStats Memory { get; }
    [PublicAPIAttribute]
public IEnumerable`1<Measurement> Measurements { get; }
    public BenchmarkReportDto(BenchmarkReport report, bool excludeMeasurements);
    public string get_DisplayInfo();
    public string get_Namespace();
    public string get_Type();
    public string get_Method();
    public string get_MethodTitle();
    public string get_Parameters();
    public Statistics get_Statistics();
    public IEnumerable`1<Metric> get_Metrics();
    public GcStats get_Memory();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Measurement> get_Measurements();
}
internal class BenchmarkDotNet.Exporters.Xml.ChronometerDto : object {
    private Frequency frequency;
    public double Hertz { get; }
    public ChronometerDto(Frequency frequency);
    public double get_Hertz();
}
internal class BenchmarkDotNet.Exporters.Xml.GcStats : ValueType {
    [CompilerGeneratedAttribute]
private int <Gen0Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Gen1Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Gen2Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BytesAllocatedPerOperation>k__BackingField;
    public int Gen0Collections { get; public set; }
    public int Gen1Collections { get; public set; }
    public int Gen2Collections { get; public set; }
    public long TotalOperations { get; public set; }
    public Nullable`1<long> BytesAllocatedPerOperation { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Gen0Collections();
    [CompilerGeneratedAttribute]
public void set_Gen0Collections(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Gen1Collections();
    [CompilerGeneratedAttribute]
public void set_Gen1Collections(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Gen2Collections();
    [CompilerGeneratedAttribute]
public void set_Gen2Collections(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TotalOperations();
    [CompilerGeneratedAttribute]
public void set_TotalOperations(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<long> get_BytesAllocatedPerOperation();
    [CompilerGeneratedAttribute]
public void set_BytesAllocatedPerOperation(Nullable`1<long> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Exporters.Xml.HostEnvironmentInfoDto : object {
    private HostEnvironmentInfo hei;
    public string BenchmarkDotNetCaption { get; }
    public string BenchmarkDotNetVersion { get; }
    public string OsVersion { get; }
    public string ProcessorName { get; }
    public string PhysicalProcessorCount { get; }
    public string PhysicalCoreCount { get; }
    public string LogicalCoreCount { get; }
    public string RuntimeVersion { get; }
    public string Architecture { get; }
    public bool HasAttachedDebugger { get; }
    public bool HasRyuJit { get; }
    public string Configuration { get; }
    public string DotNetSdkVersion { get; }
    public ChronometerDto ChronometerFrequency { get; }
    public string HardwareTimerKind { get; }
    public HostEnvironmentInfoDto(HostEnvironmentInfo hei);
    public string get_BenchmarkDotNetCaption();
    public string get_BenchmarkDotNetVersion();
    public string get_OsVersion();
    public string get_ProcessorName();
    public string get_PhysicalProcessorCount();
    public string get_PhysicalCoreCount();
    public string get_LogicalCoreCount();
    public string get_RuntimeVersion();
    public string get_Architecture();
    public bool get_HasAttachedDebugger();
    public bool get_HasRyuJit();
    public string get_Configuration();
    public string get_DotNetSdkVersion();
    public ChronometerDto get_ChronometerFrequency();
    public string get_HardwareTimerKind();
}
[NullableContextAttribute("1")]
internal interface BenchmarkDotNet.Exporters.Xml.IXmlSerializer {
    public abstract virtual void Serialize(IXmlWriter writer, object source);
}
[NullableContextAttribute("1")]
internal interface BenchmarkDotNet.Exporters.Xml.IXmlWriter {
    public abstract virtual void WriteStartDocument();
    public abstract virtual void WriteEndDocument();
    public abstract virtual void WriteStartElement(string localName);
    public abstract virtual void WriteEndElement();
    public abstract virtual void WriteElementString(string localName, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Exporters.Xml.SimpleXmlWriter : object {
    private XmlWriter writer;
    public SimpleXmlWriter(TextWriter writer, bool indent);
    public sealed virtual void WriteElementString(string localName, string value);
    public sealed virtual void WriteEndDocument();
    public sealed virtual void WriteEndElement();
    public sealed virtual void WriteStartDocument();
    public sealed virtual void WriteStartElement(string localName);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Exporters.Xml.SummaryDto : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<BenchmarkReportDto> <Benchmarks>k__BackingField;
    private Summary summary;
    public string Title { get; }
    public HostEnvironmentInfoDto HostEnvironmentInfo { get; }
    [PublicAPIAttribute]
public IEnumerable`1<BenchmarkReportDto> Benchmarks { get; }
    public SummaryDto(Summary summary, bool excludeMeasurements);
    public string get_Title();
    public HostEnvironmentInfoDto get_HostEnvironmentInfo();
    [CompilerGeneratedAttribute]
public IEnumerable`1<BenchmarkReportDto> get_Benchmarks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Exporters.Xml.Utf8StringWriter : StringWriter {
    public Encoding Encoding { get; }
    public Utf8StringWriter(StringBuilder builder);
    public virtual Encoding get_Encoding();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Exporters.Xml.XmlExporter : XmlExporterBase {
    public static IExporter Brief;
    public static IExporter Full;
    public static IExporter BriefCompressed;
    public static IExporter FullCompressed;
    public static IExporter Default;
    [CompilerGeneratedAttribute]
private string <FileNameSuffix>k__BackingField;
    protected string FileNameSuffix { get; }
    public XmlExporter(string fileNameSuffix, bool indentXml, bool excludeMeasurements);
    private static XmlExporter();
    [CompilerGeneratedAttribute]
protected virtual string get_FileNameSuffix();
    [PublicAPIAttribute]
public static IExporter Custom(string fileNameSuffix, bool indentXml, bool excludeMeasurements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Exporters.Xml.XmlExporterBase : ExporterBase {
    private bool indentXml;
    private bool excludeMeasurements;
    protected string FileExtension { get; }
    protected XmlExporterBase(bool indentXml, bool excludeMeasurements);
    protected virtual string get_FileExtension();
    public virtual void ExportToLog(Summary summary, ILogger logger);
    private IXmlSerializer BuildSerializer(Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Exporters.Xml.XmlSerializer : object {
    private Type type;
    private string rootName;
    private IReadOnlyDictionary`2<string, string> collectionItemNameMap;
    private IReadOnlyCollection`1<string> excludedPropertyNames;
    private IXmlWriter writer;
    public static string DefaultItemName;
    private XmlSerializer(XmlSerializerBuilder builder);
    public static XmlSerializerBuilder GetBuilder(Type type);
    public sealed virtual void Serialize(IXmlWriter newWriter, object source);
    private void Write(object source);
    private void WriteRoot(object source, string elementName);
    private void WriteProperty(object source, PropertyInfo property);
    private void WriteSimpleProperty(object source, PropertyInfo property);
    private void WriteComplexProperty(object source, PropertyInfo propertyInfo);
    private void WriteCollectionProperty(object source, PropertyInfo property);
    private void WriteComplexItem(object item, string itemName);
    private static bool IsSimple(TypeInfo type);
    private static bool IsCollection(PropertyInfo property);
    private static bool IsCollectionWritable(IEnumerable collection);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Extensions.AssemblyExtensions : object {
    [ExtensionAttribute]
internal static Nullable`1<bool> IsJitOptimizationDisabled(Assembly assembly);
    [ExtensionAttribute]
internal static Nullable`1<bool> IsDebug(Assembly assembly);
    [ExtensionAttribute]
internal static bool IsTrue(Nullable`1<bool> valueOrNothing);
    private static DebuggableAttribute GetDebuggableAttribute(Assembly assembly);
    [ExtensionAttribute]
private static Nullable`1<bool> IsJitOptimizerDisabled(DebuggableAttribute attribute);
    [ExtensionAttribute]
private static Nullable`1<bool> IsJitTrackingEnabled(DebuggableAttribute attribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Extensions.CommonExtensions : object {
    [ExtensionAttribute]
public static string GetColumnTitle(IColumn column, SummaryStyle style);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullOrEmpty(IReadOnlyCollection`1<T> value);
    [ExtensionAttribute]
public static bool IsEmpty(IReadOnlyCollection`1<T> value);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> value);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static void AddRange(HashSet`1<T> hashSet, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static double Sqr(double x);
    [ExtensionAttribute]
public static double Pow(double x, double k);
    [ExtensionAttribute]
internal static void ForEach(IList`1<T> source, Action`1<T> command);
    [ExtensionAttribute]
internal static string CreateIfNotExists(string directoryPath);
    [ExtensionAttribute]
internal static DirectoryInfo CreateIfNotExists(DirectoryInfo directory);
    [ExtensionAttribute]
internal static string DeleteFileIfExists(string filePath);
    [ExtensionAttribute]
internal static string EnsureFolderExists(string filePath);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsNotNullButDoesNotExist(FileSystemInfo fileInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Extensions.ConfigurationExtensions : object {
    [ExtensionAttribute]
[PublicAPIAttribute]
public static string ToConfig(Platform platform);
    [ExtensionAttribute]
public static string ToConfig(Jit jit);
}
[ExtensionAttribute]
internal static class BenchmarkDotNet.Extensions.CultureInfoExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetActualListSeparator(CultureInfo cultureInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Extensions.DoubleExtensions : object {
    [ExtensionAttribute]
public static string ToInvariantString(double value);
    [ExtensionAttribute]
public static string ToInvariantString(double value, string format);
}
[ExtensionAttribute]
internal static class BenchmarkDotNet.Extensions.EncodingExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static string ToTemplateString(Encoding encoding);
}
internal static class BenchmarkDotNet.Extensions.Hashing : object {
    private static UInt32 _defaultSeed;
    [NullableContextAttribute("1")]
internal static UInt32 HashString(string str);
    private static UInt32 MurmurHash(UInt32 hash, ReadOnlySpan`1<char> span, bool toUpper);
    private static UInt32 MurmurRound(UInt32 hash, UInt32 chunk);
    private static UInt32 MixHash(UInt32 hash);
    private static UInt32 Rotate(UInt32 x, int r);
}
internal static class BenchmarkDotNet.Extensions.PathFeatures : object {
    private static State s_osEnabled;
    private static State s_onCore;
    private static bool RunningOnCoreLib { get; }
    internal static bool AreAllLongPathsAvailable();
    internal static bool IsUsingLegacyPathNormalization();
    internal static bool AreLongPathsBlocked();
    [NullableContextAttribute("1")]
private static bool HasLegacyIoBehavior(string propertyName);
    private static bool get_RunningOnCoreLib();
    private static bool AreOsLongPathsEnabled();
    private static bool RtlAreLongPathsEnabled();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[PublicAPIAttribute]
public static class BenchmarkDotNet.Extensions.ProcessExtensions : object {
    private static TimeSpan DefaultKillTimeout;
    private static ProcessExtensions();
    [ExtensionAttribute]
public static void EnsureHighPriority(Process process, ILogger logger);
    [ExtensionAttribute]
internal static string ToPresentation(IntPtr processorAffinity, int processorCount);
    private static IntPtr FixAffinity(IntPtr processorAffinity);
    [ExtensionAttribute]
public static bool TrySetPriority(Process process, ProcessPriorityClass priority, ILogger logger);
    [ExtensionAttribute]
public static bool TrySetAffinity(Process process, IntPtr processorAffinity, ILogger logger);
    [ExtensionAttribute]
public static Nullable`1<IntPtr> TryGetAffinity(Process process);
    [ExtensionAttribute]
internal static void SetEnvironmentVariables(ProcessStartInfo start, BenchmarkCase benchmarkCase, IResolver resolver);
    [ExtensionAttribute]
public static void KillTree(Process process);
    [ExtensionAttribute]
public static void KillTree(Process process, TimeSpan timeout);
    private static void KillProcessUnix(int processId, TimeSpan timeout);
    private static void GetAllChildIdsUnix(int parentId, HashSet`1<int> children, TimeSpan timeout);
    private static ValueTuple`2<int, string> RunProcessAndReadOutput(string fileName, string arguments, TimeSpan timeout);
    private static int RunProcessAndIgnoreOutput(string fileName, string arguments, TimeSpan timeout);
    [ExtensionAttribute]
private static void SetCoreRunEnvironmentVariables(ProcessStartInfo start, BenchmarkCase benchmarkCase, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Extensions.ReflectionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static T ResolveAttribute(Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static T ResolveAttribute(MemberInfo memberInfo);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool HasAttribute(MemberInfo memberInfo);
    [ExtensionAttribute]
internal static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool IsInitOnly(PropertyInfo propertyInfo);
    [ExtensionAttribute]
internal static string GetCorrectCSharpTypeName(Type type, bool includeNamespace, bool includeGenericArgumentsNamespace);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Extensions.ReflectionExtensions/<GetNestedTypeNames>d__6")]
private static IEnumerable`1<string> GetNestedTypeNames(Type type, bool includeGenericArgumentsNamespace);
    [ExtensionAttribute]
internal static string GetDisplayName(Type type);
    [ExtensionAttribute]
private static string GetDisplayName(TypeInfo typeInfo);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Extensions.ReflectionExtensions/<GetAllMethods>d__9")]
[ExtensionAttribute]
internal static IEnumerable`1<MethodInfo> GetAllMethods(Type type);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Extensions.ReflectionExtensions/<GetAllFields>d__10")]
[ExtensionAttribute]
internal static IEnumerable`1<FieldInfo> GetAllFields(Type type);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Extensions.ReflectionExtensions/<GetAllProperties>d__11")]
[ExtensionAttribute]
internal static IEnumerable`1<PropertyInfo> GetAllProperties(Type type);
    [ExtensionAttribute]
internal static Type[] GetRunnableBenchmarks(Assembly assembly);
    [ExtensionAttribute]
internal static bool ContainsRunnableBenchmarks(Type type);
    [ExtensionAttribute]
private static MethodInfo[] GetBenchmarks(TypeInfo typeInfo);
    [ExtensionAttribute]
internal static ValueTuple`4[] GetTypeMembersWithGivenAttribute(Type type, BindingFlags reflectionFlags);
    [ExtensionAttribute]
internal static bool IsStackOnlyWithImplicitCast(Type argumentType, object argumentInstance);
    private static bool IsRunnableGenericType(TypeInfo typeInfo);
    [ExtensionAttribute]
internal static bool IsLinqPad(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Extensions.ReportExtensions : object {
    [ExtensionAttribute]
public static BenchmarkReport GetReportFor(Summary summary, Expression`1<Action`1<T>> actionExp);
    [ExtensionAttribute]
public static IList`1<Measurement> GetRunsFor(Summary summary, Expression`1<Action`1<T>> actionExp);
    [ExtensionAttribute]
public static Statistics GetStatistics(IReadOnlyCollection`1<Measurement> runs);
    [ExtensionAttribute]
public static Statistics GetStatistics(IEnumerable`1<Measurement> runs);
}
[ExtensionAttribute]
internal static class BenchmarkDotNet.Extensions.RuntimeMonikerExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static Runtime GetRuntime(RuntimeMoniker runtimeMoniker);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Extensions.StatisticsExtensions : object {
    private static string NullSummaryMessage;
    [ExtensionAttribute]
public static Func`2<double, string> CreateNanosecondFormatter(Statistics s, CultureInfo cultureInfo, string format);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static string ToString(Statistics s, CultureInfo cultureInfo, Func`2<double, string> formatter, bool calcHistogram);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Extensions.StringAndTextExtensions : object {
    private static Lazy`1<Dictionary`2<string, string>> InvalidFileNameCharactersMappings;
    private static StringAndTextExtensions();
    [ExtensionAttribute]
internal static string ToLowerCase(bool value);
    [ExtensionAttribute]
internal static string EscapeCommandLine(string cliArg);
    [ExtensionAttribute]
internal static string EscapeSpecialCharacters(string str, bool quote);
    [ExtensionAttribute]
internal static string EscapeSpecialCharacter(char c, bool quote);
    [ExtensionAttribute]
internal static string AsValidFileName(string inputPath);
    private static Dictionary`2<string, string> BuildInvalidPathCharactersMappings();
    [ExtensionAttribute]
internal static string HtmlEncode(string s);
    [ExtensionAttribute]
internal static string GetBaseName(string path, string directory);
    [ExtensionAttribute]
internal static StringBuilder AppendArgument(StringBuilder stringBuilder, string argument);
    [ExtensionAttribute]
internal static StringBuilder AppendArgument(StringBuilder stringBuilder, object argument);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsBlank(string value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNotBlank(string value);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class BenchmarkDotNet.Extensions.ThreadExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool TrySetPriority(Thread thread, ThreadPriority priority, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Filters.AllCategoriesFilter : object {
    private String[] targetCategories;
    public AllCategoriesFilter(String[] targetCategories);
    public sealed virtual bool Predicate(BenchmarkCase benchmarkCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Filters.AnyCategoriesFilter : object {
    private String[] targetCategories;
    public AnyCategoriesFilter(String[] targetCategories);
    public sealed virtual bool Predicate(BenchmarkCase benchmarkCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Filters.AttributesFilter : object {
    private String[] attributes;
    public AttributesFilter(String[] attributes);
    public sealed virtual bool Predicate(BenchmarkCase benchmarkCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Filters.DisjunctionFilter : object {
    private IFilter[] filters;
    public DisjunctionFilter(IFilter[] filters);
    public sealed virtual bool Predicate(BenchmarkCase benchmarkCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Filters.GlobFilter : object {
    private Regex[] patterns;
    public GlobFilter(String[] patterns);
    public sealed virtual bool Predicate(BenchmarkCase benchmarkCase);
    internal static Regex[] ToRegex(String[] patterns);
    private static string WildcardToRegex(string pattern);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Filters.IFilter {
    public abstract virtual bool Predicate(BenchmarkCase benchmarkCase);
}
public class BenchmarkDotNet.Filters.NameFilter : SimpleFilter {
    [NullableContextAttribute("1")]
public NameFilter(Func`2<string, bool> predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Filters.SimpleFilter : object {
    private Func`2<BenchmarkCase, bool> predicate;
    [PublicAPIAttribute]
public SimpleFilter(Func`2<BenchmarkCase, bool> predicate);
    [PublicAPIAttribute]
public sealed virtual bool Predicate(BenchmarkCase benchmarkCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Filters.UnionFilter : object {
    private IFilter[] filters;
    public UnionFilter(IFilter[] filters);
    public sealed virtual bool Predicate(BenchmarkCase benchmarkCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.HashCode : ValueType {
    private int hashCode;
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    [IsReadOnlyAttribute]
public int ToHashCode();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8, T9 value9, T10 value10);
    private static int Hash(int hashCode, T value);
    private static int Hash(int hashCode, T value, IEqualityComparer`1<T> comparer);
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Helpers.ArtifactFileNameHelper : object {
    private static int WindowsOldPathLimit;
    private static int CommonSenseLimit;
    internal static string GetTraceFilePath(DiagnoserActionParameters details, DateTime creationTime, string fileExtension);
    internal static string GetFilePath(DiagnoserActionParameters details, string subfolder, Nullable`1<DateTime> creationTime, string fileExtension, int reserve);
    private static string GetFilePathNoLimits(DiagnoserActionParameters details, string subfolder, Nullable`1<DateTime> creationTime, string fileExtension);
    private static string GetLimitedFilePath(DiagnoserActionParameters details, string subfolder, Nullable`1<DateTime> creationTime, string fileExtension, int limit);
    private static string GetFilePath(string fileName, DiagnoserActionParameters details, string subfolder, Nullable`1<DateTime> creationTime, string fileExtension);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Helpers.AsciiHelper : object {
    private static string Mu;
    [ExtensionAttribute]
public static string ToAscii(string s);
}
internal static class BenchmarkDotNet.Helpers.Assertion : object {
    [NullableContextAttribute("1")]
[AssertionMethodAttribute]
public static void NotNull(string name, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Helpers.AwaitHelper : object {
    public static void GetResult(Task task);
    public static T GetResult(Task`1<T> task);
    public static void GetResult(ValueTask task);
    public static T GetResult(ValueTask`1<T> task);
    internal static MethodInfo GetGetResultMethod(Type taskType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Helpers.ConsoleExitHandler : object {
    private Process process;
    private ILogger logger;
    internal ConsoleExitHandler(Process process, ILogger logger);
    public sealed virtual void Dispose();
    private void Attach();
    private void Detach();
    private void ProcessOnExited(object sender, EventArgs e);
    private void CancelKeyPressHandlerCallback(object sender, ConsoleCancelEventArgs e);
    private void ProcessExitEventHandlerHandlerCallback(object sender, EventArgs e);
    internal void KillProcessTree();
}
internal static class BenchmarkDotNet.Helpers.DefaultCultureInfo : object {
    [NullableAttribute("1")]
public static CultureInfo Instance;
    private static DefaultCultureInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Helpers.ExternalToolsHelper : object {
    public static Lazy`1<Dictionary`2<string, string>> MacSystemProfilerData;
    private static ExternalToolsHelper();
    private static Lazy`1<T> LazyParse(Func`1<bool> isAvailable, string fileName, string arguments, Func`2<string, T> parseFunc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Helpers.FolderNameHelper : object {
    public static string ToFolderName(object value);
    public static string ToFolderName(Type type, bool includeNamespace, bool includeGenericArgumentsNamespace);
    private static string Escape(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Helpers.FrameworkVersionHelper : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2[] FrameworkVersions;
    private static string ProgramFilesX86DirectoryPath;
    private static FrameworkVersionHelper();
    internal static string GetFrameworkDescription();
    internal static string GetFrameworkReleaseVersion();
    internal static string MapToReleaseVersion(string servicingVersion);
    [SupportedOSPlatformAttribute("windows")]
private static Nullable`1<int> GetReleaseNumberFromWindowsRegistry();
    [SupportedOSPlatformAttribute("windows")]
internal static string GetLatestNetDeveloperPackVersion();
    private static bool IsDeveloperPackInstalled(string version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Helpers.GenericBenchmarksBuilder : object {
    internal static Type[] GetRunnableBenchmarks(IEnumerable`1<Type> types);
    internal static IEnumerable`1<ValueTuple`2<bool, Type>> BuildGenericsIfNeeded(Type type);
    private static IEnumerable`1<ValueTuple`2<bool, Type>> BuildGenericTypes(Type type, IEnumerable`1<Type[]> typeArguments);
    [ExtensionAttribute]
private static bool TryMakeGenericType(Type type, Type[] typeArguments, Type& result);
}
internal static class BenchmarkDotNet.Helpers.LinuxOsReleaseHelper : object {
    [NullableContextAttribute("1")]
public static string GetNameByOsRelease(String[] lines);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Helpers.PowerManagementHelper : object {
    private static UInt32 ErrorMoreData;
    private static UInt32 SuccessCode;
    internal static Nullable`1<Guid> CurrentPlan { get; }
    internal static string CurrentPlanFriendlyName { get; }
    internal static Nullable`1<Guid> get_CurrentPlan();
    internal static string get_CurrentPlanFriendlyName();
    internal static bool Set(Guid newPolicy);
    private static UInt32 PowerReadFriendlyName(IntPtr RootPowerKey, IntPtr SchemeGuid, IntPtr SubGroupOfPowerSettingGuid, IntPtr PowerSettingGuid, StringBuilder Buffer, UInt32& BufferSize);
    private static int PowerSetActiveScheme(IntPtr ReservedZero, Guid& policyGuid);
    private static UInt32 PowerGetActiveScheme(IntPtr UserRootPowerKey, IntPtr& ActivePolicyGuid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Helpers.ProcessHelper : object {
    internal static string RunAndReadOutput(string fileName, string arguments, ILogger logger);
    internal static ValueTuple`2<int, ImmutableArray`1<string>> RunAndReadOutputLineByLine(string fileName, string arguments, string workingDirectory, Dictionary`2<string, string> environmentVariables, bool includeErrors, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Helpers.Reflection.Emit.EmitParameterInfo : ParameterInfo {
    public EmitParameterInfo(int position, string name, Type parameterType);
    public EmitParameterInfo(int position, string name, Type parameterType, ParameterAttributes parameterAttributes, MemberInfo member);
    public static ParameterInfo CreateReturnVoidParameter();
    public static ParameterInfo CreateReturnParameter(Type parameterType);
    public static ParameterInfo CreateReturnParameter(Type parameterType, ParameterAttributes parameterAttributes);
    public ParameterInfo SetMember(MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Helpers.Reflection.Emit.IlGeneratorCallExtensions : object {
    [ExtensionAttribute]
public static LocalBuilder DeclareOptionalLocalForInstanceCall(ILGenerator ilBuilder, Type localType, MethodInfo methodToCall);
    [ExtensionAttribute]
public static void EmitStaticCall(ILGenerator ilBuilder, MethodInfo methodToCall, LocalBuilder[] argLocals);
    [ExtensionAttribute]
public static void EmitInstanceCallThisValueOnStack(ILGenerator ilBuilder, LocalBuilder optionalLocalThis, MethodInfo methodToCall, LocalBuilder[] argLocals);
    [ExtensionAttribute]
public static void EmitInstanceCallThisValueOnStack(ILGenerator ilBuilder, LocalBuilder optionalLocalThis, MethodInfo methodToCall, IEnumerable`1<LocalBuilder> argLocals, bool forceDirectCall);
    [ExtensionAttribute]
private static void EmitCallCore(ILGenerator ilBuilder, LocalBuilder optionalLocalThis, MethodInfo methodToCall, IEnumerable`1<LocalBuilder> argLocals, bool forceDirectCall);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Helpers.Reflection.Emit.IlGeneratorDefaultValueExtensions : object {
    [ExtensionAttribute]
public static LocalBuilder DeclareOptionalLocalForReturnDefault(ILGenerator ilBuilder, Type resultType);
    [ExtensionAttribute]
public static void EmitSetLocalToDefault(ILGenerator ilBuilder, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitReturnDefault(ILGenerator ilBuilder, Type resultType, LocalBuilder optionalLocalForInitobj);
    [ExtensionAttribute]
private static bool IsInitLocalPrimitive(Type t);
    [ExtensionAttribute]
private static bool IsReturnDefaultPrimitive(Type t);
    [ExtensionAttribute]
private static bool UseInitObjForInitLocal(Type resultType);
    [ExtensionAttribute]
private static bool UseInitObjForReturnDefault(Type resultType);
    private static void EmitInitObj(ILGenerator ilBuilder, Type resultType, LocalBuilder optionalLocalForInitobj);
    [ExtensionAttribute]
private static void EmitLoadDefaultPrimitive(ILGenerator ilBuilder, Type resultType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Helpers.Reflection.Emit.IlGeneratorEmitOpExtensions : object {
    [ExtensionAttribute]
public static void EmitStloc(ILGenerator ilBuilder, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitLdloc(ILGenerator ilBuilder, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitLdloca(ILGenerator ilBuilder, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitLdargs(ILGenerator ilBuilder, IEnumerable`1<ParameterInfo> arguments);
    [ExtensionAttribute]
public static void EmitLdLocals(ILGenerator ilBuilder, IEnumerable`1<LocalBuilder> locals);
    [ExtensionAttribute]
public static void EmitLdarg(ILGenerator ilBuilder, ParameterInfo argument);
    [ExtensionAttribute]
public static void EmitLdindStind(ILGenerator ilBuilder, Type resultType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Helpers.Reflection.Emit.IlGeneratorStatementExtensions : object {
    [ExtensionAttribute]
public static void EmitCallBaseParameterlessCtor(ILGenerator ilGenerator, ConstructorBuilder constructorBuilder);
    [ExtensionAttribute]
public static void EmitCtorReturn(ILGenerator ilBuilder, ConstructorBuilder methodBuilder);
    [ExtensionAttribute]
public static void EmitVoidReturn(ILGenerator ilBuilder, MethodBuilder methodBuilder);
    [ExtensionAttribute]
public static void EmitSetDelegateToThisField(ILGenerator ilBuilder, FieldBuilder delegateField, MethodInfo delegateMethod);
    [ExtensionAttribute]
public static void EmitLoopBeginFromLocToArg(ILGenerator ilBuilder, Label loopStartLabel, Label loopHeadLabel, LocalBuilder indexLocal, ParameterInfo toArg);
    [ExtensionAttribute]
public static void EmitLoopEndFromLocToArg(ILGenerator ilBuilder, Label loopStartLabel, Label loopHeadLabel, LocalBuilder indexLocal, ParameterInfo toArg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Helpers.Reflection.Emit.MethodBuilderExtensions : object {
    [ExtensionAttribute]
public static Type[] GetParameterTypes(MethodBase method);
    [ExtensionAttribute]
public static ParameterInfo[] GetEmitParameters(MethodBuilder method, IEnumerable`1<ParameterInfo> signatureParameters);
    [ExtensionAttribute]
public static MethodBuilder SetNoInliningImplementationFlag(MethodBuilder methodBuilder);
    [ExtensionAttribute]
public static MethodBuilder SetNoOptimizationImplementationFlag(MethodBuilder methodBuilder);
    [ExtensionAttribute]
public static MethodBuilder SetAggressiveOptimizationImplementationFlag(MethodBuilder methodBuilder);
}
[ExtensionAttribute]
internal static class BenchmarkDotNet.Helpers.Reflection.Emit.ModuleBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Type EmitCustomDelegate(ModuleBuilder moduleBuilder, string delegateTypeName, ParameterInfo returnType, ParameterInfo[] parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Helpers.Reflection.Emit.TypeBuilderExtensions : object {
    [ExtensionAttribute]
private static void DefineParameters(ConstructorBuilder constructorBuilder, ParameterInfo[] parameters);
    [ExtensionAttribute]
private static void DefineParameters(MethodBuilder methodBuilder, ParameterInfo returnType, ParameterInfo[] parameters);
    public static MethodInfo GetDelegateInvokeMethod(Type delegateType);
    [ExtensionAttribute]
public static ConstructorBuilder DefinePublicInstanceCtor(TypeBuilder typeBuilder, ParameterInfo[] parameters);
    [ExtensionAttribute]
public static MethodBuilder DefinePublicNonVirtualVoidInstanceMethod(TypeBuilder typeBuilder, string name, ParameterInfo[] parameters);
    [ExtensionAttribute]
public static MethodBuilder DefinePrivateVoidInstanceMethod(TypeBuilder typeBuilder, string name, ParameterInfo[] parameters);
    [ExtensionAttribute]
public static MethodBuilder DefineNonVirtualInstanceMethod(TypeBuilder typeBuilder, string name, MethodAttributes visibility, ParameterInfo returnType, ParameterInfo[] parameters);
    [ExtensionAttribute]
public static MethodBuilder DefineStaticMethod(TypeBuilder typeBuilder, string name, MethodAttributes visibility, ParameterInfo returnType, ParameterInfo[] parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Helpers.ResourceHelper : object {
    internal static string LoadTemplate(string name);
    internal static string LoadResource(string resourceName);
    private static Stream GetResourceStream(string resourceName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Helpers.SectionsHelper : object {
    public static Dictionary`2<string, string> ParseSection(string content, char separator);
    public static List`1<Dictionary`2<string, string>> ParseSections(string content, char separator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Helpers.SourceCodeHelper : object {
    public static string ToSourceCode(object value);
    public static bool IsCompilationTimeConstant(object value);
    public static bool IsCompilationTimeConstant(Type type);
    private static string ToSourceCode(double value);
    private static string ToSourceCode(float value);
    private static string ToInvariantCultureString(object enum);
}
internal class BenchmarkDotNet.Helpers.TaskbarProgress : object {
    private static bool OsVersionIsSupported;
    [NullableAttribute("2")]
private Com com;
    [NullableAttribute("2")]
private Terminal terminal;
    private bool IsEnabled { get; }
    internal TaskbarProgress(TaskbarProgressState initialTaskbarState);
    private static TaskbarProgress();
    private bool get_IsEnabled();
    internal void SetState(TaskbarProgressState state);
    internal void SetProgress(float progressValue);
    [NullableContextAttribute("1")]
private void OnConsoleCancelEvent(object sender, ConsoleCancelEventArgs e);
    public sealed virtual void Dispose();
}
internal enum BenchmarkDotNet.Helpers.TaskbarProgressState : Enum {
    public int value__;
    public static TaskbarProgressState NoProgress;
    public static TaskbarProgressState Indeterminate;
    public static TaskbarProgressState Normal;
    public static TaskbarProgressState Error;
    public static TaskbarProgressState Paused;
    public static TaskbarProgressState Warning;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Helpers.UnitHelper : object {
    public static UnitPresentation DefaultPresentation;
    private static UnitHelper();
    [ExtensionAttribute]
public static string ToDefaultString(TimeInterval timeInterval, string format);
}
internal static class BenchmarkDotNet.Helpers.UserInteractionHelper : object {
    [NullableContextAttribute("1")]
public static string EscapeCommandExample(string input);
}
internal static class BenchmarkDotNet.Helpers.XUnitHelper : object {
    [NullableAttribute("1")]
public static Lazy`1<bool> IsIntegrationTest;
    private static XUnitHelper();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class BenchmarkDotNet.Jobs.AccuracyMode : JobMode`1<AccuracyMode> {
    public static Characteristic`1<double> MaxRelativeErrorCharacteristic;
    public static Characteristic`1<TimeInterval> MaxAbsoluteErrorCharacteristic;
    public static Characteristic`1<TimeInterval> MinIterationTimeCharacteristic;
    public static Characteristic`1<int> MinInvokeCountCharacteristic;
    public static Characteristic`1<bool> EvaluateOverheadCharacteristic;
    public static Characteristic`1<OutlierMode> OutlierModeCharacteristic;
    public static Characteristic`1<bool> AnalyzeLaunchVarianceCharacteristic;
    public double MaxRelativeError { get; public set; }
    public TimeInterval MaxAbsoluteError { get; public set; }
    public TimeInterval MinIterationTime { get; public set; }
    public int MinInvokeCount { get; public set; }
    public bool EvaluateOverhead { get; public set; }
    public OutlierMode OutlierMode { get; public set; }
    public bool AnalyzeLaunchVariance { get; public set; }
    private static AccuracyMode();
    public double get_MaxRelativeError();
    public void set_MaxRelativeError(double value);
    public TimeInterval get_MaxAbsoluteError();
    public void set_MaxAbsoluteError(TimeInterval value);
    public TimeInterval get_MinIterationTime();
    public void set_MinIterationTime(TimeInterval value);
    public int get_MinInvokeCount();
    public void set_MinInvokeCount(int value);
    public bool get_EvaluateOverhead();
    public void set_EvaluateOverhead(bool value);
    public OutlierMode get_OutlierMode();
    public void set_OutlierMode(OutlierMode value);
    public bool get_AnalyzeLaunchVariance();
    public void set_AnalyzeLaunchVariance(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Jobs.Argument : object {
    [CompilerGeneratedAttribute]
private string <TextRepresentation>k__BackingField;
    [PublicAPIAttribute]
public string TextRepresentation { get; }
    protected Argument(string value);
    [CompilerGeneratedAttribute]
public string get_TextRepresentation();
    public virtual string ToString();
    public sealed virtual bool Equals(Argument other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class BenchmarkDotNet.Jobs.EnvironmentMode : JobMode`1<EnvironmentMode> {
    public static Characteristic`1<Platform> PlatformCharacteristic;
    public static Characteristic`1<Jit> JitCharacteristic;
    public static Characteristic`1<Runtime> RuntimeCharacteristic;
    public static Characteristic`1<IntPtr> AffinityCharacteristic;
    public static Characteristic`1<GcMode> GcCharacteristic;
    public static Characteristic`1<IReadOnlyList`1<EnvironmentVariable>> EnvironmentVariablesCharacteristic;
    public static Characteristic`1<Nullable`1<Guid>> PowerPlanModeCharacteristic;
    public static Characteristic`1<bool> LargeAddressAwareCharacteristic;
    public static EnvironmentMode LegacyJitX86;
    public static EnvironmentMode LegacyJitX64;
    public static EnvironmentMode RyuJitX64;
    public static EnvironmentMode RyuJitX86;
    public Platform Platform { get; public set; }
    public Jit Jit { get; public set; }
    public Runtime Runtime { get; public set; }
    public IntPtr Affinity { get; public set; }
    public GcMode Gc { get; }
    public IReadOnlyList`1<EnvironmentVariable> EnvironmentVariables { get; public set; }
    public Nullable`1<Guid> PowerPlanMode { get; public set; }
    public bool LargeAddressAware { get; public set; }
    [PublicAPIAttribute]
public EnvironmentMode(Runtime runtime);
    [PublicAPIAttribute]
public EnvironmentMode(string id, Jit jit, Platform platform);
    [PublicAPIAttribute]
public EnvironmentMode(string id);
    private static EnvironmentMode();
    public Platform get_Platform();
    public void set_Platform(Platform value);
    public Jit get_Jit();
    public void set_Jit(Jit value);
    public Runtime get_Runtime();
    public void set_Runtime(Runtime value);
    public IntPtr get_Affinity();
    public void set_Affinity(IntPtr value);
    public GcMode get_Gc();
    public IReadOnlyList`1<EnvironmentVariable> get_EnvironmentVariables();
    public void set_EnvironmentVariables(IReadOnlyList`1<EnvironmentVariable> value);
    public Nullable`1<Guid> get_PowerPlanMode();
    public void set_PowerPlanMode(Nullable`1<Guid> value);
    public bool get_LargeAddressAware();
    public void set_LargeAddressAware(bool value);
    public void SetEnvironmentVariable(EnvironmentVariable variable);
    internal Runtime GetRuntime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Jobs.EnvironmentVariable : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    public string Value { get; }
    public EnvironmentVariable(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
    public virtual string ToString();
    public sealed virtual bool Equals(EnvironmentVariable other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class BenchmarkDotNet.Jobs.GcMode : JobMode`1<GcMode> {
    public static Characteristic`1<bool> ServerCharacteristic;
    public static Characteristic`1<bool> ConcurrentCharacteristic;
    public static Characteristic`1<bool> CpuGroupsCharacteristic;
    public static Characteristic`1<bool> ForceCharacteristic;
    public static Characteristic`1<bool> AllowVeryLargeObjectsCharacteristic;
    public static Characteristic`1<bool> RetainVmCharacteristic;
    public static Characteristic`1<bool> NoAffinitizeCharacteristic;
    public static Characteristic`1<int> HeapAffinitizeMaskCharacteristic;
    public static Characteristic`1<int> HeapCountCharacteristic;
    public bool Server { get; public set; }
    public bool Concurrent { get; public set; }
    public bool CpuGroups { get; public set; }
    public bool Force { get; public set; }
    public bool AllowVeryLargeObjects { get; public set; }
    public bool RetainVm { get; public set; }
    public bool NoAffinitize { get; public set; }
    public int HeapAffinitizeMask { get; public set; }
    public int HeapCount { get; public set; }
    private static GcMode();
    public bool get_Server();
    public void set_Server(bool value);
    public bool get_Concurrent();
    public void set_Concurrent(bool value);
    public bool get_CpuGroups();
    public void set_CpuGroups(bool value);
    public bool get_Force();
    public void set_Force(bool value);
    public bool get_AllowVeryLargeObjects();
    public void set_AllowVeryLargeObjects(bool value);
    public bool get_RetainVm();
    public void set_RetainVm(bool value);
    public bool get_NoAffinitize();
    public void set_NoAffinitize(bool value);
    public int get_HeapAffinitizeMask();
    public void set_HeapAffinitizeMask(int value);
    public int get_HeapCount();
    public void set_HeapCount(int value);
    public sealed virtual bool Equals(GcMode other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Jobs.GcModeExtensions : object {
    [ExtensionAttribute]
[PublicAPIAttribute]
public static GcMode WithServer(GcMode mode, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static GcMode WithConcurrent(GcMode mode, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static GcMode WithCpuGroups(GcMode mode, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static GcMode WithForce(GcMode mode, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static GcMode WithAllowVeryLargeObjects(GcMode mode, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static GcMode WithRetainVm(GcMode mode, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static GcMode WithHeapCount(GcMode mode, int heapCount);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static GcMode WithNoAffinitize(GcMode mode, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static GcMode WithHeapAffinitizeMask(GcMode mode, int heapAffinitizeMask);
    [ExtensionAttribute]
private static GcMode WithCore(GcMode mode, Action`1<GcMode> updateCallback);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class BenchmarkDotNet.Jobs.InfrastructureMode : JobMode`1<InfrastructureMode> {
    public static string ReleaseConfigurationName;
    public static Characteristic`1<IToolchain> ToolchainCharacteristic;
    public static Characteristic`1<IClock> ClockCharacteristic;
    public static Characteristic`1<IEngineFactory> EngineFactoryCharacteristic;
    public static Characteristic`1<string> BuildConfigurationCharacteristic;
    public static Characteristic`1<IReadOnlyList`1<Argument>> ArgumentsCharacteristic;
    public static Characteristic`1<IReadOnlyCollection`1<NuGetReference>> NuGetReferencesCharacteristic;
    public static InfrastructureMode InProcess;
    public static InfrastructureMode InProcessDontLogOutput;
    public IToolchain Toolchain { get; public set; }
    public IClock Clock { get; public set; }
    public IEngineFactory EngineFactory { get; public set; }
    public string BuildConfiguration { get; public set; }
    public IReadOnlyList`1<Argument> Arguments { get; public set; }
    public IReadOnlyCollection`1<NuGetReference> NuGetReferences { get; public set; }
    private InfrastructureMode(IToolchain toolchain);
    private static InfrastructureMode();
    public IToolchain get_Toolchain();
    public void set_Toolchain(IToolchain value);
    public IClock get_Clock();
    public void set_Clock(IClock value);
    public IEngineFactory get_EngineFactory();
    public void set_EngineFactory(IEngineFactory value);
    public string get_BuildConfiguration();
    public void set_BuildConfiguration(string value);
    public IReadOnlyList`1<Argument> get_Arguments();
    public void set_Arguments(IReadOnlyList`1<Argument> value);
    public IReadOnlyCollection`1<NuGetReference> get_NuGetReferences();
    public void set_NuGetReferences(IReadOnlyCollection`1<NuGetReference> value);
    public bool TryGetToolchain(IToolchain& toolchain);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class BenchmarkDotNet.Jobs.Job : JobMode`1<Job> {
    [PublicAPIAttribute]
public static Characteristic`1<EnvironmentMode> EnvironmentCharacteristic;
    [PublicAPIAttribute]
public static Characteristic`1<RunMode> RunCharacteristic;
    [PublicAPIAttribute]
public static Characteristic`1<InfrastructureMode> InfrastructureCharacteristic;
    [PublicAPIAttribute]
public static Characteristic`1<AccuracyMode> AccuracyCharacteristic;
    [PublicAPIAttribute]
public static Characteristic`1<MetaMode> MetaCharacteristic;
    public static Job LegacyJitX86;
    public static Job LegacyJitX64;
    public static Job RyuJitX64;
    public static Job RyuJitX86;
    public static Job Dry;
    public static Job ShortRun;
    public static Job MediumRun;
    public static Job LongRun;
    public static Job VeryLongRun;
    public static Job InProcess;
    public static Job InProcessDontLogOutput;
    public EnvironmentMode Environment { get; }
    public RunMode Run { get; }
    public InfrastructureMode Infrastructure { get; }
    public AccuracyMode Accuracy { get; }
    public MetaMode Meta { get; }
    public string ResolvedId { get; }
    public string FolderInfo { get; }
    public string DisplayInfo { get; }
    [NullableContextAttribute("2")]
public Job(string id);
    public Job(CharacteristicObject other);
    public Job(CharacteristicObject[] others);
    public Job(string id, CharacteristicObject other);
    public Job(string id, CharacteristicObject[] others);
    private static Job();
    public EnvironmentMode get_Environment();
    public RunMode get_Run();
    public InfrastructureMode get_Infrastructure();
    public AccuracyMode get_Accuracy();
    public MetaMode get_Meta();
    public string get_ResolvedId();
    public string get_FolderInfo();
    public string get_DisplayInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Jobs.JobComparer : object {
    public static JobComparer Instance;
    private static JobComparer();
    public sealed virtual int Compare(Job x, Job y);
    public sealed virtual bool Equals(Job x, Job y);
    public sealed virtual int GetHashCode(Job obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Jobs.JobExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithPlatform instead")]
public static Job With(Job job, Platform platform);
    [ExtensionAttribute]
public static Job WithPlatform(Job job, Platform platform);
    [ExtensionAttribute]
public static Job WithId(Job job, string id);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithJit instead")]
public static Job With(Job job, Jit jit);
    [ExtensionAttribute]
public static Job WithJit(Job job, Jit jit);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithRuntime instead")]
public static Job With(Job job, Runtime runtime);
    [ExtensionAttribute]
public static Job WithRuntime(Job job, Runtime runtime);
    [ExtensionAttribute]
public static Job WithAffinity(Job job, IntPtr affinity);
    [ExtensionAttribute]
public static Job WithGcServer(Job job, bool value);
    [ExtensionAttribute]
public static Job WithGcConcurrent(Job job, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Job WithGcCpuGroups(Job job, bool value);
    [ExtensionAttribute]
public static Job WithGcForce(Job job, bool value);
    [ExtensionAttribute]
public static Job WithGcAllowVeryLargeObjects(Job job, bool value);
    [ExtensionAttribute]
public static Job WithLargeAddressAware(Job job, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Job WithGcRetainVm(Job job, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Job WithHeapCount(Job job, int heapCount);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Job WithNoAffinitize(Job job, bool value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Job WithHeapAffinitizeMask(Job job, int heapAffinitizeMask);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithGcMode instead")]
public static Job With(Job job, GcMode gc);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Job WithGcMode(Job job, GcMode gc);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithStrategy instead")]
public static Job With(Job job, RunStrategy strategy);
    [ExtensionAttribute]
public static Job WithStrategy(Job job, RunStrategy strategy);
    [ExtensionAttribute]
public static Job WithLaunchCount(Job job, int count);
    [ExtensionAttribute]
public static Job WithWarmupCount(Job job, int count);
    [ExtensionAttribute]
public static Job WithMinWarmupCount(Job job, int count);
    [ExtensionAttribute]
public static Job WithMaxWarmupCount(Job job, int count);
    [ExtensionAttribute]
public static Job WithIterationCount(Job job, int count);
    [ExtensionAttribute]
public static Job WithIterationTime(Job job, TimeInterval time);
    [ExtensionAttribute]
public static Job WithInvocationCount(Job job, long count);
    [ExtensionAttribute]
public static Job WithUnrollFactor(Job job, int factor);
    [ExtensionAttribute]
public static Job RunOncePerIteration(Job job);
    [ExtensionAttribute]
public static Job WithMinIterationCount(Job job, int count);
    [ExtensionAttribute]
public static Job WithMaxIterationCount(Job job, int count);
    [ExtensionAttribute]
public static Job WithPowerPlan(Job job, PowerPlan powerPlan);
    [ExtensionAttribute]
public static Job WithPowerPlan(Job job, Guid powerPlanGuid);
    [ExtensionAttribute]
public static Job DontEnforcePowerPlan(Job job);
    [ExtensionAttribute]
public static Job WithMemoryRandomization(Job job, bool enable);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithToolchain instead")]
public static Job With(Job job, IToolchain toolchain);
    [ExtensionAttribute]
public static Job WithToolchain(Job job, IToolchain toolchain);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithClock instead")]
public static Job With(Job job, IClock clock);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Job WithClock(Job job, IClock clock);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithEngineFactory instead")]
public static Job With(Job job, IEngineFactory engineFactory);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Job WithEngineFactory(Job job, IEngineFactory engineFactory);
    [ExtensionAttribute]
public static Job WithCustomBuildConfiguration(Job job, string buildConfiguration);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithEnvironmentVariables instead")]
public static Job With(Job job, IReadOnlyList`1<EnvironmentVariable> environmentVariables);
    [ExtensionAttribute]
public static Job WithEnvironmentVariables(Job job, EnvironmentVariable[] environmentVariables);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using .WithEnvironmentVariable instead")]
public static Job With(Job job, EnvironmentVariable environmentVariable);
    [ExtensionAttribute]
public static Job WithEnvironmentVariable(Job job, EnvironmentVariable environmentVariable);
    [ExtensionAttribute]
public static Job WithEnvironmentVariable(Job job, string key, string value);
    [ExtensionAttribute]
public static Job WithoutEnvironmentVariables(Job job);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will soon be removed, please start using ..WithArguments() instead")]
public static Job With(Job job, IReadOnlyList`1<Argument> arguments);
    [ExtensionAttribute]
public static Job WithArguments(Job job, IReadOnlyList`1<Argument> arguments);
    [ExtensionAttribute]
public static Job WithNuGet(Job job, string packageName, string packageVersion, Uri source, bool prerelease);
    [ExtensionAttribute]
public static Job WithNuGet(Job job, NuGetReferenceList nuGetReferences);
    [ExtensionAttribute]
public static Job WithMaxRelativeError(Job job, double value);
    [ExtensionAttribute]
public static Job WithMaxAbsoluteError(Job job, TimeInterval interval);
    [ExtensionAttribute]
public static Job WithMinIterationTime(Job job, TimeInterval interval);
    [ExtensionAttribute]
public static Job WithMinInvokeCount(Job job, int value);
    [ExtensionAttribute]
public static Job WithEvaluateOverhead(Job job, bool value);
    [ExtensionAttribute]
public static Job WithOutlierMode(Job job, OutlierMode value);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Job WithAnalyzeLaunchVariance(Job job, bool value);
    [ExtensionAttribute]
public static Job AsBaseline(Job job);
    [ExtensionAttribute]
public static Job WithBaseline(Job job, bool value);
    [ExtensionAttribute]
public static Job AsMutator(Job job);
    [ExtensionAttribute]
public static Job AsDefault(Job job, bool value);
    [ExtensionAttribute]
internal static Job MakeSettingsUserFriendly(Job job, Descriptor descriptor);
    [ExtensionAttribute]
internal static bool IsNativeAOT(Job job);
    [ExtensionAttribute]
private static Job WithCore(Job job, Action`1<Job> updateCallback);
    [ExtensionAttribute]
internal static bool HasDynamicBuildCharacteristic(Job job);
}
public static class BenchmarkDotNet.Jobs.JobIdGenerator : object {
    [NullableContextAttribute("1")]
public static string GenerateRandomId(Job job);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class BenchmarkDotNet.Jobs.JobMode`1 : CharacteristicObject`1<T> {
    public static T Default;
    [PublicAPIAttribute]
public Job Job { get; }
    [NullableContextAttribute("2")]
protected JobMode`1(string id);
    private static JobMode`1();
    public Job get_Job();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class BenchmarkDotNet.Jobs.MetaMode : JobMode`1<MetaMode> {
    [PublicAPIAttribute]
public static Characteristic`1<bool> BaselineCharacteristic;
    [PublicAPIAttribute]
public static Characteristic`1<bool> IsMutatorCharacteristic;
    [PublicAPIAttribute]
public static Characteristic`1<bool> IsDefaultCharacteristic;
    public bool Baseline { get; public set; }
    public bool IsMutator { get; public set; }
    public bool IsDefault { get; public set; }
    private static MetaMode();
    public bool get_Baseline();
    public void set_Baseline(bool value);
    public bool get_IsMutator();
    public void set_IsMutator(bool value);
    public bool get_IsDefault();
    public void set_IsDefault(bool value);
}
public class BenchmarkDotNet.Jobs.MonoArgument : Argument {
    [NullableContextAttribute("1")]
public MonoArgument(string value);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Jobs.MsBuildArgument : Argument {
    [NullableContextAttribute("1")]
public MsBuildArgument(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Jobs.NuGetReference : object {
    [CompilerGeneratedAttribute]
private string <PackageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Prerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageSource>k__BackingField;
    private static Regex PreReleaseValidator;
    public string PackageName { get; }
    public string PackageVersion { get; }
    public bool Prerelease { get; }
    public Uri PackageSource { get; }
    public NuGetReference(string packageName, string packageVersion, Uri source, bool prerelease);
    private static NuGetReference();
    [CompilerGeneratedAttribute]
public string get_PackageName();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
    [CompilerGeneratedAttribute]
public bool get_Prerelease();
    [CompilerGeneratedAttribute]
public Uri get_PackageSource();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NuGetReference other);
    public virtual int GetHashCode();
    public virtual string ToString();
    private bool IsValidVersion(string version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Jobs.NuGetReferenceList : object {
    private List`1<NuGetReference> references;
    public int Count { get; }
    public NuGetReferenceList(IReadOnlyCollection`1<NuGetReference> readOnlyCollection);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<NuGetReference> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(NuGetReference reference);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class BenchmarkDotNet.Jobs.RunMode : JobMode`1<RunMode> {
    public static Characteristic`1<RunStrategy> RunStrategyCharacteristic;
    public static Characteristic`1<int> LaunchCountCharacteristic;
    public static Characteristic`1<long> InvocationCountCharacteristic;
    public static Characteristic`1<int> UnrollFactorCharacteristic;
    public static Characteristic`1<int> IterationCountCharacteristic;
    public static Characteristic`1<int> MinIterationCountCharacteristic;
    public static Characteristic`1<int> MaxIterationCountCharacteristic;
    public static Characteristic`1<TimeInterval> IterationTimeCharacteristic;
    public static Characteristic`1<int> WarmupCountCharacteristic;
    public static Characteristic`1<int> MinWarmupIterationCountCharacteristic;
    public static Characteristic`1<int> MaxWarmupIterationCountCharacteristic;
    public static Characteristic`1<bool> MemoryRandomizationCharacteristic;
    public static RunMode Dry;
    public static RunMode Short;
    public static RunMode Medium;
    public static RunMode Long;
    public static RunMode VeryLong;
    public RunStrategy RunStrategy { get; public set; }
    public int LaunchCount { get; public set; }
    public int WarmupCount { get; public set; }
    public int IterationCount { get; public set; }
    public TimeInterval IterationTime { get; public set; }
    public long InvocationCount { get; public set; }
    public int UnrollFactor { get; public set; }
    public int MinIterationCount { get; public set; }
    public int MaxIterationCount { get; public set; }
    public int MinWarmupIterationCount { get; public set; }
    public int MaxWarmupIterationCount { get; public set; }
    public bool MemoryRandomization { get; public set; }
    private RunMode(string id);
    private static RunMode();
    public RunStrategy get_RunStrategy();
    public void set_RunStrategy(RunStrategy value);
    public int get_LaunchCount();
    public void set_LaunchCount(int value);
    public int get_WarmupCount();
    public void set_WarmupCount(int value);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public TimeInterval get_IterationTime();
    public void set_IterationTime(TimeInterval value);
    public long get_InvocationCount();
    public void set_InvocationCount(long value);
    public int get_UnrollFactor();
    public void set_UnrollFactor(int value);
    public int get_MinIterationCount();
    public void set_MinIterationCount(int value);
    public int get_MaxIterationCount();
    public void set_MaxIterationCount(int value);
    public int get_MinWarmupIterationCount();
    public void set_MinWarmupIterationCount(int value);
    public int get_MaxWarmupIterationCount();
    public void set_MaxWarmupIterationCount(int value);
    public bool get_MemoryRandomization();
    public void set_MemoryRandomization(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Loggers.AccumulationLogger : object {
    private StringBuilder builder;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    public int Priority { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    public sealed virtual int get_Priority();
    public virtual void Write(LogKind logKind, string text);
    public virtual void WriteLine();
    public virtual void WriteLine(LogKind logKind, string text);
    public sealed virtual void Flush();
    public void ClearLog();
    public string GetLog();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Loggers.AsyncProcessOutputReader : object {
    private Process process;
    private ILogger logger;
    private bool logOutput;
    private bool readStandardError;
    private static TimeSpan FinishEventTimeout;
    private AutoResetEvent outputFinishEvent;
    private AutoResetEvent errorFinishEvent;
    private ConcurrentQueue`1<string> output;
    private ConcurrentQueue`1<string> error;
    private long status;
    internal AsyncProcessOutputReader(Process process, bool logOutput, ILogger logger, bool readStandardError);
    private static AsyncProcessOutputReader();
    public sealed virtual void Dispose();
    internal void BeginRead();
    internal void CancelRead();
    internal void StopRead();
    internal ImmutableArray`1<string> GetOutputLines();
    internal ImmutableArray`1<string> GetErrorLines();
    internal ImmutableArray`1<string> GetOutputAndErrorLines();
    internal string GetOutputText();
    internal string GetErrorText();
    private void Attach();
    private void Detach();
    private void ProcessOnOutputDataReceived(object sender, DataReceivedEventArgs e);
    private void ProcessOnErrorDataReceived(object sender, DataReceivedEventArgs e);
    private T ReturnIfStopped(Func`1<T> getter);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <GetOutputLines>b__15_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <GetErrorLines>b__16_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <GetOutputAndErrorLines>b__17_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <GetOutputText>b__18_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <GetErrorText>b__19_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Loggers.Broker : object {
    private ILogger logger;
    private Process process;
    private IDiagnoser diagnoser;
    private AnonymousPipeServerStream inputFromBenchmark;
    private AnonymousPipeServerStream acknowledgments;
    private DiagnoserActionParameters diagnoserActionParameters;
    private ManualResetEvent finished;
    [CompilerGeneratedAttribute]
private List`1<string> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <PrefixedOutput>k__BackingField;
    internal List`1<string> Results { get; }
    internal List`1<string> PrefixedOutput { get; }
    public Broker(ILogger logger, Process process, IDiagnoser diagnoser, BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, AnonymousPipeServerStream inputFromBenchmark, AnonymousPipeServerStream acknowledgments);
    [CompilerGeneratedAttribute]
internal List`1<string> get_Results();
    [CompilerGeneratedAttribute]
internal List`1<string> get_PrefixedOutput();
    internal void ProcessData();
    private void OnProcessExited(object sender, EventArgs e);
    private void ProcessDataBlocking();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Loggers.CompositeLogger : object {
    private ImmutableHashSet`1<ILogger> loggers;
    public string Id { get; }
    public int Priority { get; }
    internal CompositeLogger(ImmutableHashSet`1<ILogger> loggers);
    public sealed virtual string get_Id();
    public sealed virtual int get_Priority();
    public sealed virtual void Write(LogKind logKind, string text);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(LogKind logKind, string text);
    public sealed virtual void Flush();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Loggers.ConsoleLogger : object {
    private static ConsoleColor DefaultColor;
    public static ILogger Default;
    public static ILogger Ascii;
    public static ILogger Unicode;
    private static bool ConsoleSupportsColors;
    private bool unicodeSupport;
    private Dictionary`2<LogKind, ConsoleColor> colorScheme;
    public string Id { get; }
    public int Priority { get; }
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public ConsoleLogger(bool unicodeSupport, Dictionary`2<LogKind, ConsoleColor> colorScheme);
    private static ConsoleLogger();
    public sealed virtual string get_Id();
    public sealed virtual int get_Priority();
    public sealed virtual void Write(LogKind logKind, string text);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(LogKind logKind, string text);
    public sealed virtual void Flush();
    private void Write(LogKind logKind, Action`1<string> write, string text);
    private ConsoleColor GetColor(LogKind logKind);
    private static Dictionary`2<LogKind, ConsoleColor> CreateColorfulScheme();
    [PublicAPIAttribute]
public static Dictionary`2<LogKind, ConsoleColor> CreateGrayScheme();
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Loggers.ILogger {
    public string Id { get; }
    public int Priority { get; }
    public abstract virtual string get_Id();
    public abstract virtual int get_Priority();
    public abstract virtual void Write(LogKind logKind, string text);
    public abstract virtual void WriteLine();
    public abstract virtual void WriteLine(LogKind logKind, string text);
    public abstract virtual void Flush();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Loggers.LinqPadLogger : object {
    private static string DefaultColor;
    private MethodInfo withStyle;
    private IReadOnlyDictionary`2<LogKind, string> colorScheme;
    public static Lazy`1<LinqPadLogger> lazyInstance;
    public static bool IsAvailable { get; }
    public static ILogger Instance { get; }
    public string Id { get; }
    public int Priority { get; }
    private LinqPadLogger(MethodInfo withStyle, IReadOnlyDictionary`2<LogKind, string> colorScheme);
    private static LinqPadLogger();
    public static bool get_IsAvailable();
    public static ILogger get_Instance();
    public sealed virtual string get_Id();
    public sealed virtual int get_Priority();
    public sealed virtual void Write(LogKind logKind, string text);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(LogKind logKind, string text);
    public sealed virtual void Flush();
    private void Write(LogKind logKind, Action`1<object> write, string text);
    private object WithStyle(object data, string htmlStyle);
    private string GetColor(LogKind logKind);
    private static IReadOnlyDictionary`2<LogKind, string> CreateDarkScheme();
    private static IReadOnlyDictionary`2<LogKind, string> CreateLightScheme();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Loggers.LogCapture : object {
    private List`1<OutputLine> capturedOutput;
    public IReadOnlyList`1<OutputLine> CapturedOutput { get; }
    public string Id { get; }
    public int Priority { get; }
    public IReadOnlyList`1<OutputLine> get_CapturedOutput();
    public sealed virtual string get_Id();
    public sealed virtual int get_Priority();
    public sealed virtual void Write(LogKind logKind, string text);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(LogKind logKind, string text);
    public sealed virtual void Flush();
    public void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Loggers.LoggerExtensions : object {
    [ExtensionAttribute]
public static void WriteLine(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteLineHelp(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteLineHeader(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteLineResult(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteLineStatistic(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteLineInfo(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteLineError(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteLineWarning(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteLineHint(ILogger logger, string text);
    [ExtensionAttribute]
public static void Write(ILogger logger, string text);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void WriteHelp(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteHeader(ILogger logger, string text);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void WriteResult(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteStatistic(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteInfo(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteError(ILogger logger, string text);
    [ExtensionAttribute]
public static void WriteWarning(ILogger logger, string text);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static void WriteHint(ILogger logger, string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Loggers.LoggerWithPrefix : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    private bool isNewLine;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    private ILogger Logger { get; }
    private string Prefix { get; }
    public string Id { get; }
    public int Priority { get; }
    public LoggerWithPrefix(ILogger logger, string prefix);
    [CompilerGeneratedAttribute]
private ILogger get_Logger();
    [CompilerGeneratedAttribute]
private string get_Prefix();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    public sealed virtual int get_Priority();
    public sealed virtual void Write(LogKind logKind, string text);
    private void WriteSimple(LogKind logKind, string text);
    private void AddPrefixIfNeeded(LogKind logKind, string text);
    public sealed virtual void WriteLine(LogKind logKind, string text);
    public sealed virtual void WriteLine();
    public sealed virtual void Flush();
}
public enum BenchmarkDotNet.Loggers.LogKind : Enum {
    public int value__;
    public static LogKind Default;
    public static LogKind Help;
    public static LogKind Header;
    public static LogKind Result;
    public static LogKind Statistic;
    public static LogKind Info;
    public static LogKind Error;
    public static LogKind Hint;
    public static LogKind Warning;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Loggers.NullLogger : object {
    public static ILogger Instance;
    public string Id { get; }
    public int Priority { get; }
    private static NullLogger();
    public sealed virtual string get_Id();
    public sealed virtual int get_Priority();
    public sealed virtual void Write(LogKind logKind, string text);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(LogKind logKind, string text);
    public sealed virtual void Flush();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Loggers.OutputLine : ValueType {
    [CompilerGeneratedAttribute]
private LogKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public LogKind Kind { get; public set; }
    public string Text { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LogKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(LogKind value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Loggers.StreamLogger : TextLogger {
    public string Id { get; }
    public StreamLogger(StreamWriter writer);
    [PublicAPIAttribute]
public StreamLogger(string filePath, bool append);
    public virtual string get_Id();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Loggers.TextLogger : object {
    private TextWriter writer;
    public string Id { get; }
    public int Priority { get; }
    public TextLogger(TextWriter writer);
    public virtual string get_Id();
    public sealed virtual int get_Priority();
    public sealed virtual void Write(LogKind logKind, string text);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(LogKind logKind, string text);
    public sealed virtual void Flush();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class BenchmarkDotNet.Mathematics.ConfidenceLevelExtensions : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<LegacyConfidenceLevel, ValueTuple`2<int, int>> ConfidenceLevelDetails;
    private static ConfidenceLevelExtensions();
    [ExtensionAttribute]
public static double GetZValue(LegacyConfidenceLevel level, int n);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToPercentStr(LegacyConfidenceLevel level);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static double ToPercent(LegacyConfidenceLevel level);
    private static Dictionary`2<LegacyConfidenceLevel, ValueTuple`2<int, int>> CreateConfidenceLevelMapping();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Mathematics.LegacyConfidenceInterval : ValueType {
    [CompilerGeneratedAttribute]
private int <N>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyConfidenceLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Margin>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Lower>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Upper>k__BackingField;
    [PublicAPIAttribute]
public int N { get; }
    [PublicAPIAttribute]
public double Mean { get; }
    [PublicAPIAttribute]
public double StandardError { get; }
    [PublicAPIAttribute]
public LegacyConfidenceLevel Level { get; }
    [PublicAPIAttribute]
public double Margin { get; }
    [PublicAPIAttribute]
public double Lower { get; }
    [PublicAPIAttribute]
public double Upper { get; }
    public LegacyConfidenceInterval(double mean, double standardError, int n, LegacyConfidenceLevel level);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_N();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Mean();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_StandardError();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LegacyConfidenceLevel get_Level();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Margin();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Lower();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Upper();
    public bool Contains(double value);
    private string GetLevelHint(bool showLevel);
    public virtual string ToString();
    public string ToString(CultureInfo cultureInfo, string format, bool showLevel);
    public string ToString(Func`2<double, string> formatter, bool showLevel);
}
public enum BenchmarkDotNet.Mathematics.LegacyConfidenceLevel : Enum {
    public int value__;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L50;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L70;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L75;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L80;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L85;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L90;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L92;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L95;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L96;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L97;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L98;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L99;
    [PublicAPIAttribute]
public static LegacyConfidenceLevel L999;
}
internal static class BenchmarkDotNet.Mathematics.MathHelper : object {
    [NullableAttribute("1")]
public static Threshold DefaultThreshold;
    public static SignificanceLevel DefaultSignificanceLevel;
    private static MathHelper();
    public static int Clamp(int value, int min, int max);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
internal class BenchmarkDotNet.Mathematics.MeasurementsStatistics : ValueType {
    [CompilerGeneratedAttribute]
private double <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfidenceInterval <LegacyConfidenceInterval>k__BackingField;
    [PublicAPIAttribute]
public double StandardError { get; }
    public double Mean { get; }
    public ConfidenceInterval LegacyConfidenceInterval { get; }
    private MeasurementsStatistics(double standardError, double mean, ConfidenceInterval legacyConfidenceInterval);
    [CompilerGeneratedAttribute]
public double get_StandardError();
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
public ConfidenceInterval get_LegacyConfidenceInterval();
    public static MeasurementsStatistics Calculate(List`1<Measurement> measurements, OutlierMode outlierMode);
    private static double Sum(List`1<Measurement> measurements);
    private static void SumWithoutOutliers(OutlierMode outlierMode, List`1<Measurement> measurements, double lowerFence, double upperFence, Double& sum, Int32& n);
    private static double Variance(List`1<Measurement> measurements, int n, double mean);
    private static double VarianceWithoutOutliers(OutlierMode outlierMode, List`1<Measurement> measurements, int n, double mean, double lowerFence, double upperFence);
    private static double GetQuartile(List`1<Measurement> measurements, int count);
    private static bool IsOutlier(OutlierMode outlierMode, double value, double lowerFence, double upperFence);
}
public enum BenchmarkDotNet.Mathematics.NumeralSystem : Enum {
    public int value__;
    public static NumeralSystem Arabic;
    public static NumeralSystem Roman;
    public static NumeralSystem Stars;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Mathematics.NumeralSystemExtensions : object {
    [ExtensionAttribute]
public static string ToPresentation(NumeralSystem system, int value);
    private static string ToRoman(int number);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Mathematics.PercentileValues : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<double> <SortedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P0>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P25>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P50>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P67>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P80>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P85>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P90>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P95>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P100>k__BackingField;
    private IReadOnlyList`1<double> SortedValues { get; }
    public double P0 { get; }
    public double P25 { get; }
    public double P50 { get; }
    public double P67 { get; }
    public double P80 { get; }
    public double P85 { get; }
    public double P90 { get; }
    public double P95 { get; }
    public double P100 { get; }
    internal PercentileValues(IReadOnlyList`1<double> sortedValues);
    [PublicAPIAttribute]
public double Percentile(int percentile);
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<double> get_SortedValues();
    [CompilerGeneratedAttribute]
public double get_P0();
    [CompilerGeneratedAttribute]
public double get_P25();
    [CompilerGeneratedAttribute]
public double get_P50();
    [CompilerGeneratedAttribute]
public double get_P67();
    [CompilerGeneratedAttribute]
public double get_P80();
    [CompilerGeneratedAttribute]
public double get_P85();
    [CompilerGeneratedAttribute]
public double get_P90();
    [CompilerGeneratedAttribute]
public double get_P95();
    [CompilerGeneratedAttribute]
public double get_P100();
    public virtual string ToString();
    public string ToString(Func`2<double, string> formatter);
    public string ToString(CultureInfo cultureInfo, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Mathematics.RankHelper : object {
    public static Int32[] GetRanks(Statistics[] stats);
    private static bool AreSame(Statistics x, Statistics y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Mathematics.Statistics : object {
    [CompilerGeneratedAttribute]
private Sample <Sample>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<double> <OriginalValues>k__BackingField;
    [CompilerGeneratedAttribute]
private int <N>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LowerFence>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Q1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Median>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Q3>k__BackingField;
    [CompilerGeneratedAttribute]
private double <UpperFence>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private double <InterquartileRange>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <LowerOutliers>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <UpperOutliers>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <AllOutliers>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardDeviation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Skewness>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Kurtosis>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfidenceIntervalEstimator <ConfidenceIntervalEstimator>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfidenceInterval <PerfolizerConfidenceInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyConfidenceInterval <ConfidenceInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private PercentileValues <Percentiles>k__BackingField;
    private TukeyOutlierDetector outlierDetector;
    internal Sample Sample { get; }
    public IReadOnlyList`1<double> OriginalValues { get; }
    public int N { get; }
    public double Min { get; }
    public double LowerFence { get; }
    public double Q1 { get; }
    public double Median { get; }
    public double Mean { get; }
    public double Q3 { get; }
    public double UpperFence { get; }
    public double Max { get; }
    public double InterquartileRange { get; }
    public Double[] LowerOutliers { get; }
    public Double[] UpperOutliers { get; }
    public Double[] AllOutliers { get; }
    public double StandardError { get; }
    public double Variance { get; }
    public double StandardDeviation { get; }
    public double Skewness { get; }
    public double Kurtosis { get; }
    private ConfidenceIntervalEstimator ConfidenceIntervalEstimator { get; }
    internal ConfidenceInterval PerfolizerConfidenceInterval { get; }
    public LegacyConfidenceInterval ConfidenceInterval { get; }
    public PercentileValues Percentiles { get; }
    public Statistics(Double[] values);
    public Statistics(IEnumerable`1<int> values);
    public Statistics(IEnumerable`1<double> values);
    public Statistics(Sample sample);
    [CompilerGeneratedAttribute]
internal Sample get_Sample();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<double> get_OriginalValues();
    [CompilerGeneratedAttribute]
public int get_N();
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
public double get_LowerFence();
    [CompilerGeneratedAttribute]
public double get_Q1();
    [CompilerGeneratedAttribute]
public double get_Median();
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
public double get_Q3();
    [CompilerGeneratedAttribute]
public double get_UpperFence();
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
public double get_InterquartileRange();
    [CompilerGeneratedAttribute]
public Double[] get_LowerOutliers();
    [CompilerGeneratedAttribute]
public Double[] get_UpperOutliers();
    [CompilerGeneratedAttribute]
public Double[] get_AllOutliers();
    [CompilerGeneratedAttribute]
public double get_StandardError();
    [CompilerGeneratedAttribute]
public double get_Variance();
    [CompilerGeneratedAttribute]
public double get_StandardDeviation();
    [CompilerGeneratedAttribute]
public double get_Skewness();
    [CompilerGeneratedAttribute]
public double get_Kurtosis();
    [CompilerGeneratedAttribute]
private ConfidenceIntervalEstimator get_ConfidenceIntervalEstimator();
    [CompilerGeneratedAttribute]
internal ConfidenceInterval get_PerfolizerConfidenceInterval();
    [CompilerGeneratedAttribute]
public LegacyConfidenceInterval get_ConfidenceInterval();
    [CompilerGeneratedAttribute]
public PercentileValues get_Percentiles();
    [PublicAPIAttribute]
public ConfidenceInterval GetConfidenceInterval(ConfidenceLevel level);
    [PublicAPIAttribute]
public bool IsLowerOutlier(double value);
    [PublicAPIAttribute]
public bool IsUpperOutlier(double value);
    [PublicAPIAttribute]
public bool IsOutlier(double value);
    [PublicAPIAttribute]
public Double[] WithoutOutliers();
    [PublicAPIAttribute]
public double CalcCentralMoment(int k);
    public bool IsActualOutlier(double value, OutlierMode outlierMode);
    [PublicAPIAttribute]
public Double[] GetActualOutliers(OutlierMode outlierMode);
    public virtual string ToString();
    public bool CanBeInverted();
    public Statistics Invert();
    public static double MulMean(Statistics x, Statistics y);
    [NullableContextAttribute("2")]
public static double DivMean(Statistics x, Statistics y);
    public static Statistics Divide(Statistics x, Statistics y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Order.CategoryComparer : object {
    private static string Separator;
    public static CategoryComparer Instance;
    private static CategoryComparer();
    public sealed virtual int Compare(String[] x, String[] y);
    private static string GetUniqueId(String[] categories);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Order.DefaultOrderer : object {
    public static IOrderer Instance;
    private IComparer`1<String[]> categoryComparer;
    private IComparer`1<ParameterInstances> paramsComparer;
    private IComparer`1<Job> jobComparer;
    private IComparer`1<Descriptor> targetComparer;
    [CompilerGeneratedAttribute]
private SummaryOrderPolicy <SummaryOrderPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodOrderPolicy <MethodOrderPolicy>k__BackingField;
    public SummaryOrderPolicy SummaryOrderPolicy { get; }
    public MethodOrderPolicy MethodOrderPolicy { get; }
    public bool SeparateLogicalGroups { get; }
    public DefaultOrderer(SummaryOrderPolicy summaryOrderPolicy, MethodOrderPolicy methodOrderPolicy);
    private static DefaultOrderer();
    [CompilerGeneratedAttribute]
public SummaryOrderPolicy get_SummaryOrderPolicy();
    [CompilerGeneratedAttribute]
public MethodOrderPolicy get_MethodOrderPolicy();
    [PublicAPIAttribute]
public virtual IEnumerable`1<BenchmarkCase> GetExecutionOrder(ImmutableArray`1<BenchmarkCase> benchmarkCases, IEnumerable`1<BenchmarkLogicalGroupRule> order);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Order.DefaultOrderer/<GetSummaryOrder>d__13")]
public virtual IEnumerable`1<BenchmarkCase> GetSummaryOrder(ImmutableArray`1<BenchmarkCase> benchmarksCases, Summary summary);
    protected virtual IEnumerable`1<BenchmarkCase> GetSummaryOrderForGroup(ImmutableArray`1<BenchmarkCase> benchmarksCase, Summary summary);
    public sealed virtual string GetHighlightGroupKey(BenchmarkCase benchmarkCase);
    public sealed virtual string GetLogicalGroupKey(ImmutableArray`1<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase);
    public virtual IEnumerable`1<IGrouping`2<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable`1<IGrouping`2<string, BenchmarkCase>> logicalGroups, IEnumerable`1<BenchmarkLogicalGroupRule> order);
    public sealed virtual bool get_SeparateLogicalGroups();
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Order.IOrderer {
    [PublicAPIAttribute]
public bool SeparateLogicalGroups { get; }
    [PublicAPIAttribute]
public abstract virtual IEnumerable`1<BenchmarkCase> GetExecutionOrder(ImmutableArray`1<BenchmarkCase> benchmarksCase, IEnumerable`1<BenchmarkLogicalGroupRule> order);
    [PublicAPIAttribute]
public abstract virtual IEnumerable`1<BenchmarkCase> GetSummaryOrder(ImmutableArray`1<BenchmarkCase> benchmarksCases, Summary summary);
    [PublicAPIAttribute]
public abstract virtual string GetHighlightGroupKey(BenchmarkCase benchmarkCase);
    [PublicAPIAttribute]
public abstract virtual string GetLogicalGroupKey(ImmutableArray`1<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase);
    [PublicAPIAttribute]
public abstract virtual IEnumerable`1<IGrouping`2<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable`1<IGrouping`2<string, BenchmarkCase>> logicalGroups, IEnumerable`1<BenchmarkLogicalGroupRule> order);
    public abstract virtual bool get_SeparateLogicalGroups();
}
public enum BenchmarkDotNet.Order.MethodOrderPolicy : Enum {
    public int value__;
    public static MethodOrderPolicy Alphabetical;
    public static MethodOrderPolicy Declared;
}
public enum BenchmarkDotNet.Order.SummaryOrderPolicy : Enum {
    public int value__;
    public static SummaryOrderPolicy Default;
    public static SummaryOrderPolicy FastestToSlowest;
    public static SummaryOrderPolicy SlowestToFastest;
    public static SummaryOrderPolicy Method;
    public static SummaryOrderPolicy Declared;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Parameters.ParameterComparer : object {
    public static ParameterComparer Instance;
    private static ParameterComparer();
    public sealed virtual int Compare(ParameterInstances x, ParameterInstances y);
    private int CompareValues(object x, object y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Parameters.ParameterDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PriorityInCategory>k__BackingField;
    public string Name { get; }
    public bool IsStatic { get; }
    public Object[] Values { get; }
    public bool IsArgument { get; }
    public Type ParameterType { get; }
    public int PriorityInCategory { get; }
    public ParameterDefinition(string name, bool isStatic, Object[] values, bool isArgument, Type parameterType, int priorityInCategory);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
public Object[] get_Values();
    [CompilerGeneratedAttribute]
public bool get_IsArgument();
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
public int get_PriorityInCategory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Parameters.ParameterDefinitions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ParameterDefinition> <Items>k__BackingField;
    [PublicAPIAttribute]
public IReadOnlyList`1<ParameterDefinition> Items { get; }
    public ParameterDefinitions(IReadOnlyList`1<ParameterDefinition> items);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ParameterDefinition> get_Items();
    public IReadOnlyList`1<ParameterInstances> Expand(SummaryStyle summaryStyle);
    private static IReadOnlyList`1<ParameterInstances> Expand(IReadOnlyList`1<ParameterInstances> instancesList, IReadOnlyList`1<ParameterDefinition> definitions, SummaryStyle summaryStyle);
    public virtual string ToString();
}
public static class BenchmarkDotNet.Parameters.ParameterExtractor : object {
    [NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public static T GetParameter(IEnumerable`1<T> parameters, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Parameters.ParameterInstance : object {
    public static string NullParameterTextRepresentation;
    [CompilerGeneratedAttribute]
private ParameterDefinition <Definition>k__BackingField;
    private object value;
    private int maxParameterColumnWidthFromConfig;
    [PublicAPIAttribute]
public ParameterDefinition Definition { get; }
    public string Name { get; }
    public bool IsStatic { get; }
    public bool IsArgument { get; }
    public object Value { get; }
    public ParameterInstance(ParameterDefinition definition, object value, SummaryStyle summaryStyle);
    [CompilerGeneratedAttribute]
public ParameterDefinition get_Definition();
    public sealed virtual void Dispose();
    public string get_Name();
    public bool get_IsStatic();
    public bool get_IsArgument();
    public object get_Value();
    public string ToSourceCode();
    private string ToDisplayText(CultureInfo cultureInfo, int maxParameterColumnWidth);
    public string ToDisplayText(SummaryStyle summary);
    public string ToDisplayText();
    public virtual string ToString();
    private static string Trim(string value, int maxDisplayTextInnerLength);
    private static bool IsFirstCharInSurrogatePair(char c);
    private static bool IsSecondCharInSurrogatePair(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class BenchmarkDotNet.Parameters.ParameterInstances : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ParameterInstance> <Items>k__BackingField;
    private string printInfo;
    public IReadOnlyList`1<ParameterInstance> Items { get; }
    public int Count { get; }
    public ParameterInstance Item { get; }
    public object Item { get; }
    public string FolderInfo { get; }
    public string DisplayInfo { get; }
    public string ValueInfo { get; }
    public string PrintInfo { get; }
    public ParameterInstances(IReadOnlyList`1<ParameterInstance> items);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ParameterInstance> get_Items();
    public int get_Count();
    public ParameterInstance get_Item(int index);
    public object get_Item(string name);
    public sealed virtual void Dispose();
    public string get_FolderInfo();
    public string get_DisplayInfo();
    public string get_ValueInfo();
    public string get_PrintInfo();
    public ParameterInstance GetArgument(string name);
    public sealed virtual bool Equals(ParameterInstances other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Parameters.SmartArgument : object {
    private ParameterDefinition[] parameterDefinitions;
    private MemberInfo source;
    private int sourceIndex;
    private int argumentIndex;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public string DisplayText { get; }
    public SmartArgument(ParameterDefinition[] parameterDefinitions, object value, MemberInfo source, int sourceIndex, int argumentIndex);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    public sealed virtual string get_DisplayText();
    public sealed virtual string ToSourceCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Parameters.SmartParamBuilder : object {
    internal static Object[] CreateForParams(Type parameterType, MemberInfo source, Object[] values);
    internal static ParameterInstances CreateForArguments(MethodInfo benchmark, ParameterDefinition[] parameterDefinitions, ValueTuple`2<MemberInfo, Object[]> valuesInfo, int sourceIndex, SummaryStyle summaryStyle);
    private static ParameterInstance Create(ParameterDefinition[] parameterDefinitions, object value, MemberInfo source, int sourceIndex, int argumentIndex, SummaryStyle summaryStyle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Parameters.SmartParameter : object {
    private Type parameterType;
    private MemberInfo source;
    private MethodBase method;
    private int index;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public string DisplayText { get; }
    public SmartParameter(Type parameterType, MemberInfo source, object value, int index);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    public sealed virtual string get_DisplayText();
    public sealed virtual string ToSourceCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Portability.Antivirus : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [PublicAPIAttribute]
public string Name { get; }
    [PublicAPIAttribute]
public string Path { get; }
    public Antivirus(string name, string path);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Path();
    public virtual string ToString();
}
public static class BenchmarkDotNet.Portability.CodeGenHelper : object {
    public static MethodImplOptions AggressiveOptimizationOption;
    public static MethodImplAttributes AggressiveOptimizationOptionForEmit;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Portability.Cpu.CpuInfo : object {
    [CompilerGeneratedAttribute]
private string <ProcessorName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PhysicalProcessorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PhysicalCoreCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LogicalCoreCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Frequency> <NominalFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Frequency> <MinFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Frequency> <MaxFrequency>k__BackingField;
    public string ProcessorName { get; }
    public Nullable`1<int> PhysicalProcessorCount { get; }
    public Nullable`1<int> PhysicalCoreCount { get; }
    public Nullable`1<int> LogicalCoreCount { get; }
    public Nullable`1<Frequency> NominalFrequency { get; }
    public Nullable`1<Frequency> MinFrequency { get; }
    public Nullable`1<Frequency> MaxFrequency { get; }
    internal CpuInfo(string processorName, Nullable`1<Frequency> nominalFrequency);
    public CpuInfo(string processorName, Nullable`1<int> physicalProcessorCount, Nullable`1<int> physicalCoreCount, Nullable`1<int> logicalCoreCount, Nullable`1<Frequency> nominalFrequency, Nullable`1<Frequency> minFrequency, Nullable`1<Frequency> maxFrequency);
    [CompilerGeneratedAttribute]
public string get_ProcessorName();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PhysicalProcessorCount();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PhysicalCoreCount();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LogicalCoreCount();
    [CompilerGeneratedAttribute]
public Nullable`1<Frequency> get_NominalFrequency();
    [CompilerGeneratedAttribute]
public Nullable`1<Frequency> get_MinFrequency();
    [CompilerGeneratedAttribute]
public Nullable`1<Frequency> get_MaxFrequency();
}
public static class BenchmarkDotNet.Portability.Cpu.CpuInfoFormatter : object {
    [NullableContextAttribute("1")]
public static string Format(CpuInfo cpuInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Portability.Cpu.HardwareIntrinsics : object {
    internal static bool IsX86BaseSupported { get; }
    internal static bool IsX86SseSupported { get; }
    internal static bool IsX86Sse2Supported { get; }
    internal static bool IsX86Sse3Supported { get; }
    internal static bool IsX86Ssse3Supported { get; }
    internal static bool IsX86Sse41Supported { get; }
    internal static bool IsX86Sse42Supported { get; }
    internal static bool IsX86AvxSupported { get; }
    internal static bool IsX86Avx2Supported { get; }
    internal static bool IsX86Avx512FSupported { get; }
    internal static bool IsX86Avx512FVLSupported { get; }
    internal static bool IsX86Avx512BWSupported { get; }
    internal static bool IsX86Avx512CDSupported { get; }
    internal static bool IsX86Avx512DQSupported { get; }
    internal static bool IsX86Avx512VbmiSupported { get; }
    internal static bool IsX86AesSupported { get; }
    internal static bool IsX86Bmi1Supported { get; }
    internal static bool IsX86Bmi2Supported { get; }
    internal static bool IsX86FmaSupported { get; }
    internal static bool IsX86LzcntSupported { get; }
    internal static bool IsX86PclmulqdqSupported { get; }
    internal static bool IsX86PopcntSupported { get; }
    internal static bool IsX86AvxVnniSupported { get; }
    internal static bool IsX86SerializeSupported { get; }
    internal static bool IsArmBaseSupported { get; }
    internal static bool IsArmAdvSimdSupported { get; }
    internal static bool IsArmAesSupported { get; }
    internal static bool IsArmCrc32Supported { get; }
    internal static bool IsArmDpSupported { get; }
    internal static bool IsArmRdmSupported { get; }
    internal static bool IsArmSha1Supported { get; }
    internal static bool IsArmSha256Supported { get; }
    internal static string GetVectorSize();
    internal static string GetShortInfo();
    internal static string GetFullInfo(Platform platform);
    private static string GetShortAvx512Representation();
    internal static bool get_IsX86BaseSupported();
    internal static bool get_IsX86SseSupported();
    internal static bool get_IsX86Sse2Supported();
    internal static bool get_IsX86Sse3Supported();
    internal static bool get_IsX86Ssse3Supported();
    internal static bool get_IsX86Sse41Supported();
    internal static bool get_IsX86Sse42Supported();
    internal static bool get_IsX86AvxSupported();
    internal static bool get_IsX86Avx2Supported();
    internal static bool get_IsX86Avx512FSupported();
    internal static bool get_IsX86Avx512FVLSupported();
    internal static bool get_IsX86Avx512BWSupported();
    internal static bool get_IsX86Avx512CDSupported();
    internal static bool get_IsX86Avx512DQSupported();
    internal static bool get_IsX86Avx512VbmiSupported();
    internal static bool get_IsX86AesSupported();
    internal static bool get_IsX86Bmi1Supported();
    internal static bool get_IsX86Bmi2Supported();
    internal static bool get_IsX86FmaSupported();
    internal static bool get_IsX86LzcntSupported();
    internal static bool get_IsX86PclmulqdqSupported();
    internal static bool get_IsX86PopcntSupported();
    internal static bool get_IsX86AvxVnniSupported();
    internal static bool get_IsX86SerializeSupported();
    internal static bool get_IsArmBaseSupported();
    internal static bool get_IsArmAdvSimdSupported();
    internal static bool get_IsArmAesSupported();
    internal static bool get_IsArmCrc32Supported();
    internal static bool get_IsArmDpSupported();
    internal static bool get_IsArmRdmSupported();
    internal static bool get_IsArmSha1Supported();
    internal static bool get_IsArmSha256Supported();
    private static bool GetIsSupported(string typeName);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Portability.Cpu.HardwareIntrinsics/<<GetFullInfo>g__GetCurrentProcessInstructionSets|2_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetFullInfo>g__GetCurrentProcessInstructionSets|2_0(Platform platform);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Portability.Cpu.MosCpuInfoProvider : object {
    [SupportedOSPlatformAttribute("windows")]
internal static Lazy`1<CpuInfo> MosCpuInfo;
    private static MosCpuInfoProvider();
    [SupportedOSPlatformAttribute("windows")]
private static CpuInfo Load();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Portability.Cpu.ProcCpuInfoKeyNames : object {
    internal static string PhysicalId;
    internal static string CpuCores;
    internal static string ModelName;
    internal static string MaxFrequency;
    internal static string MinFrequency;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Portability.Cpu.ProcCpuInfoParser : object {
    internal static CpuInfo ParseOutput(string content);
    internal static Frequency ParseFrequencyFromBrandString(string brandString);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Portability.Cpu.ProcCpuInfoProvider : object {
    [NullableAttribute("1")]
internal static Lazy`1<CpuInfo> ProcCpuInfo;
    private static ProcCpuInfoProvider();
    private static CpuInfo Load();
    private static string GetCpuSpeed();
    private static string ParseCpuFrequencies(String[] input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Portability.Cpu.SysctlCpuInfoParser : object {
    internal static CpuInfo ParseOutput(string content);
    private static Nullable`1<int> GetPositiveIntValue(Dictionary`2<string, string> sysctl, string keyName);
    private static Nullable`1<long> GetPositiveLongValue(Dictionary`2<string, string> sysctl, string keyName);
}
internal static class BenchmarkDotNet.Portability.Cpu.SysctlCpuInfoProvider : object {
    [NullableAttribute("1")]
internal static Lazy`1<CpuInfo> SysctlCpuInfo;
    private static SysctlCpuInfoProvider();
    [NullableContextAttribute("2")]
private static CpuInfo Load();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Portability.Cpu.WmicCpuInfoKeyNames : object {
    internal static string NumberOfLogicalProcessors;
    internal static string NumberOfCores;
    internal static string Name;
    internal static string MaxClockSpeed;
}
internal static class BenchmarkDotNet.Portability.Cpu.WmicCpuInfoParser : object {
    [NullableContextAttribute("1")]
internal static CpuInfo ParseOutput(string content);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Portability.Cpu.WmicCpuInfoProvider : object {
    internal static Lazy`1<CpuInfo> WmicCpuInfo;
    private static string DefaultWmicPath;
    private static WmicCpuInfoProvider();
    [NullableContextAttribute("2")]
private static CpuInfo Load();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Portability.HyperV : VirtualMachineHypervisor {
    [CompilerGeneratedAttribute]
private static HyperV <Default>k__BackingField;
    public static HyperV Default { get; }
    public string Name { get; }
    private static HyperV();
    [CompilerGeneratedAttribute]
public static HyperV get_Default();
    public virtual string get_Name();
    public virtual bool IsVirtualMachine(string manufacturer, string model);
}
internal static class BenchmarkDotNet.Portability.libc : object {
    internal static int getppid();
    internal static UInt32 getuid();
    internal static int kill(int pid, int sig);
    [NullableContextAttribute("1")]
internal static int chmod(string path, UInt32 mode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Portability.RuntimeInformation : object {
    internal static string DebugConfigurationName;
    internal static string ReleaseConfigurationName;
    internal static string Unknown;
    [CompilerGeneratedAttribute]
private static bool <IsMono>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOldMono>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNewMono>k__BackingField;
    public static bool IsMono { get; }
    public static bool IsOldMono { get; }
    public static bool IsNewMono { get; }
    public static bool IsFullFramework { get; }
    [PublicAPIAttribute]
public static bool IsNetNative { get; }
    public static bool IsNetCore { get; }
    public static bool IsNativeAOT { get; }
    [SupportedOSPlatformGuardAttribute("browser")]
public static bool IsWasm { get; }
    public static bool IsAot { get; }
    public static bool IsRunningInContainer { get; }
    internal static string ExecutableExtension { get; }
    internal static string ScriptFileExtension { get; }
    private static RuntimeInformation();
    [CompilerGeneratedAttribute]
public static bool get_IsMono();
    [CompilerGeneratedAttribute]
public static bool get_IsOldMono();
    [CompilerGeneratedAttribute]
public static bool get_IsNewMono();
    public static bool get_IsFullFramework();
    public static bool get_IsNetNative();
    public static bool get_IsNetCore();
    public static bool get_IsNativeAOT();
    public static bool get_IsWasm();
    public static bool get_IsAot();
    public static bool get_IsRunningInContainer();
    internal static string get_ExecutableExtension();
    internal static string get_ScriptFileExtension();
    internal static string GetArchitecture();
    [SupportedOSPlatformGuardAttribute("windows")]
internal static bool IsWindows();
    [SupportedOSPlatformGuardAttribute("linux")]
internal static bool IsLinux();
    [SupportedOSPlatformGuardAttribute("macos")]
internal static bool IsMacOS();
    [SupportedOSPlatformGuardAttribute("android")]
internal static bool IsAndroid();
    [SupportedOSPlatformGuardAttribute("ios")]
internal static bool IsIOS();
    [SupportedOSPlatformGuardAttribute("tvos")]
internal static bool IsTvOS();
    public static string GetOsVersion();
    [NullableContextAttribute("2")]
private static string GetLinuxOsVersion();
    private static bool IsUnderWsl();
    private static Nullable`1<int> GetWindowsUbr();
    internal static CpuInfo GetCpuInfo();
    internal static string GetRuntimeVersion();
    private static string GetNetCoreVersion();
    internal static Runtime GetCurrentRuntime();
    public static Platform GetCurrentPlatform();
    public static bool Is64BitPlatform();
    internal static bool HasRyuJit();
    internal static Jit GetCurrentJit();
    internal static string GetJitInfo();
    internal static IntPtr GetCurrentAffinity();
    internal static string GetConfiguration();
    internal static ICollection`1<Antivirus> GetAntivirusProducts();
    internal static VirtualMachineHypervisor GetVirtualMachineHypervisor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Portability.StringExtensions : object {
    [ExtensionAttribute]
internal static bool EqualsWithIgnoreCase(string left, string right);
    [ExtensionAttribute]
internal static bool ContainsWithIgnoreCase(string text, string word);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Portability.VirtualBox : VirtualMachineHypervisor {
    [CompilerGeneratedAttribute]
private static VirtualBox <Default>k__BackingField;
    public static VirtualBox Default { get; }
    public string Name { get; }
    private static VirtualBox();
    [CompilerGeneratedAttribute]
public static VirtualBox get_Default();
    public virtual string get_Name();
    public virtual bool IsVirtualMachine(string manufacturer, string model);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Portability.VirtualMachineHypervisor : object {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool IsVirtualMachine(string manufacturer, string model);
    protected static bool ContainsVmIdentifier(string systemInformation, string vmIdentifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Portability.VMware : VirtualMachineHypervisor {
    [CompilerGeneratedAttribute]
private static VMware <Default>k__BackingField;
    public static VMware Default { get; }
    public string Name { get; }
    private static VMware();
    [CompilerGeneratedAttribute]
public static VMware get_Default();
    public virtual string get_Name();
    public virtual bool IsVirtualMachine(string manufacturer, string model);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Properties.BenchmarkDotNetInfo : object {
    private static Lazy`1<BenchmarkDotNetInfo> LazyInstance;
    [CompilerGeneratedAttribute]
private static BenchmarkDotNetInfo <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <AssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelop>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNightly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BrandTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BrandVersion>k__BackingField;
    internal static string PublicKey;
    public static BenchmarkDotNetInfo Instance { get; }
    public Version AssemblyVersion { get; }
    public string FullVersion { get; }
    public bool IsDevelop { get; }
    public bool IsNightly { get; }
    public bool IsRelease { get; }
    public string BrandTitle { get; }
    public string BrandVersion { get; }
    public BenchmarkDotNetInfo(Version assemblyVersion, string fullVersion);
    private static BenchmarkDotNetInfo();
    [CompilerGeneratedAttribute]
public static BenchmarkDotNetInfo get_Instance();
    [CompilerGeneratedAttribute]
public Version get_AssemblyVersion();
    [CompilerGeneratedAttribute]
public string get_FullVersion();
    [CompilerGeneratedAttribute]
public bool get_IsDevelop();
    [CompilerGeneratedAttribute]
public bool get_IsNightly();
    [CompilerGeneratedAttribute]
public bool get_IsRelease();
    [CompilerGeneratedAttribute]
public string get_BrandTitle();
    [CompilerGeneratedAttribute]
public string get_BrandVersion();
    internal static string RemoveVersionMetadata(string version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Reports.BaseliningStrategy : object {
    private static BaseliningStrategy Disabled;
    private static BaseliningStrategy DescriptorOnly;
    private static BaseliningStrategy JobOnly;
    private static BaseliningStrategy DescriptorAndJob;
    private bool useDescriptors;
    private bool useJobs;
    public BaseliningStrategy(bool useDescriptors, bool useJobs);
    private static BaseliningStrategy();
    public static BaseliningStrategy Create(ImmutableArray`1<BenchmarkCase> benchmarkCases);
    public bool IsBaseline(BenchmarkCase benchmark);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Reports.BenchmarkReport : object {
    [CompilerGeneratedAttribute]
private BenchmarkCase <BenchmarkCase>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Measurement> <AllMeasurements>k__BackingField;
    [CompilerGeneratedAttribute]
private GcStats <GcStats>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private GenerateResult <GenerateResult>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildResult <BuildResult>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, Metric> <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ExecuteResult> <ExecuteResults>k__BackingField;
    [NullableAttribute("2")]
private Statistics resultStatistics;
    public BenchmarkCase BenchmarkCase { get; }
    public IReadOnlyList`1<Measurement> AllMeasurements { get; }
    public GcStats GcStats { get; }
    [PublicAPIAttribute]
public bool Success { get; }
    [PublicAPIAttribute]
public GenerateResult GenerateResult { get; }
    [PublicAPIAttribute]
public BuildResult BuildResult { get; }
    [PublicAPIAttribute]
public IReadOnlyDictionary`2<string, Metric> Metrics { get; }
    public IReadOnlyList`1<ExecuteResult> ExecuteResults { get; }
    [NullableAttribute("2")]
public Statistics ResultStatistics { get; }
    public BenchmarkReport(bool success, BenchmarkCase benchmarkCase, GenerateResult generateResult, BuildResult buildResult, IReadOnlyList`1<ExecuteResult> executeResults, IReadOnlyList`1<Metric> metrics);
    [CompilerGeneratedAttribute]
public BenchmarkCase get_BenchmarkCase();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Measurement> get_AllMeasurements();
    [CompilerGeneratedAttribute]
public GcStats get_GcStats();
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public GenerateResult get_GenerateResult();
    [CompilerGeneratedAttribute]
public BuildResult get_BuildResult();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, Metric> get_Metrics();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ExecuteResult> get_ExecuteResults();
    [NullableContextAttribute("2")]
public Statistics get_ResultStatistics();
    public virtual string ToString();
    public IReadOnlyList`1<Measurement> GetResultRuns();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Reports.BenchmarkReportExtensions : object {
    private static string DisplayedRuntimeInfoPrefix;
    private static string DisplayedGcInfoPrefix;
    private static string DisplayedHardwareIntrinsicsPrefix;
    [ExtensionAttribute]
public static string GetRuntimeInfo(BenchmarkReport report);
    [ExtensionAttribute]
public static string GetGcInfo(BenchmarkReport report);
    [ExtensionAttribute]
public static string GetHardwareIntrinsicsInfo(BenchmarkReport report);
    [ExtensionAttribute]
private static string GetInfoFromOutput(BenchmarkReport report, string prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Reports.DisplayPrecisionManager : object {
    private static int MinPrecision;
    private static int MaxPrecision;
    private IDictionary`2<string, int> precision;
    private Summary summary;
    public DisplayPrecisionManager(Summary summary);
    public int GetPrecision(SummaryStyle summaryStyle, IStatisticColumn column, IStatisticColumn parentColumn);
    internal static int CalcPrecision(IList`1<double> values);
    internal static int CalcPrecision(IList`1<double> values, int parentPrecision);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Reports.IMetricDescriptor {
    [PublicAPIAttribute]
public string Id { get; }
    [PublicAPIAttribute]
public string DisplayName { get; }
    [PublicAPIAttribute]
public string Legend { get; }
    [PublicAPIAttribute]
public string NumberFormat { get; }
    [PublicAPIAttribute]
public UnitType UnitType { get; }
    [PublicAPIAttribute]
public string Unit { get; }
    [PublicAPIAttribute]
public bool TheGreaterTheBetter { get; }
    [PublicAPIAttribute]
public int PriorityInCategory { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_Legend();
    public abstract virtual string get_NumberFormat();
    public abstract virtual UnitType get_UnitType();
    public abstract virtual string get_Unit();
    public abstract virtual bool get_TheGreaterTheBetter();
    public abstract virtual int get_PriorityInCategory();
    [PublicAPIAttribute]
public abstract virtual bool GetIsAvailable(Metric metric);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Reports.Measurement : ValueType {
    private static CultureInfo MainCultureInfo;
    private static string NsSymbol;
    private static string OpSymbol;
    private static int IterationInfoNameMaxWidth;
    [CompilerGeneratedAttribute]
private IterationMode <IterationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IterationStage <IterationStage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LaunchIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IterationIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Nanoseconds>k__BackingField;
    public IterationMode IterationMode { get; }
    public IterationStage IterationStage { get; }
    public int LaunchIndex { get; }
    public int IterationIndex { get; }
    public long Operations { get; }
    public double Nanoseconds { get; }
    public Measurement(int launchIndex, IterationMode iterationMode, IterationStage iterationStage, int iterationIndex, long operations, double nanoseconds);
    private static Measurement();
    private static Measurement Error();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IterationMode get_IterationMode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IterationStage get_IterationStage();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_LaunchIndex();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_IterationIndex();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Operations();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Nanoseconds();
    private static IterationMode ParseIterationMode(string name);
    private static IterationStage ParseIterationStage(string name);
    public TimeInterval GetAverageTime();
    public sealed virtual int CompareTo(Measurement other);
    public virtual string ToString();
    public static Measurement Parse(string line, int processIndex);
}
[ExtensionAttribute]
public static class BenchmarkDotNet.Reports.MeasurementExtensions : object {
    private static int NanosecondsInSecond;
    [ExtensionAttribute]
public static double GetOpsPerSecond(Measurement report);
    [ExtensionAttribute]
public static bool Is(Measurement measurement, IterationMode mode, IterationStage stage);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static bool IsOverhead(Measurement measurement);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static bool IsWorkload(Measurement measurement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Reports.Metric : object {
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetricDescriptor <Descriptor>k__BackingField;
    public double Value { get; }
    public IMetricDescriptor Descriptor { get; }
    public Metric(IMetricDescriptor descriptor, double value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public IMetricDescriptor get_Descriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class BenchmarkDotNet.Reports.MetricDescriptorEqualityComparer : EqualityComparer`1<IMetricDescriptor> {
    public static EqualityComparer`1<IMetricDescriptor> Instance;
    private static MetricDescriptorEqualityComparer();
    public virtual bool Equals(IMetricDescriptor x, IMetricDescriptor y);
    public virtual int GetHashCode(IMetricDescriptor obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class BenchmarkDotNet.Reports.Summary : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultsDirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private HostEnvironmentInfo <HostEnvironmentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TotalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private SummaryStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private IOrderer <Orderer>k__BackingField;
    [CompilerGeneratedAttribute]
private SummaryTable <Table>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllRuntimes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValidationError> <ValidationErrors>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IColumnHidingRule> <ColumnHidingRules>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<BenchmarkCase> <BenchmarksCases>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<BenchmarkReport> <Reports>k__BackingField;
    [CompilerGeneratedAttribute]
private DisplayPrecisionManager <DisplayPrecisionManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<BenchmarkCase, BenchmarkReport> <ReportMap>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseliningStrategy <BaseliningStrategy>k__BackingField;
    private Nullable`1<bool> isMultipleRuntimes;
    [PublicAPIAttribute]
public string Title { get; }
    [PublicAPIAttribute]
public string ResultsDirectoryPath { get; }
    [PublicAPIAttribute]
public string LogFilePath { get; }
    [PublicAPIAttribute]
public HostEnvironmentInfo HostEnvironmentInfo { get; }
    [PublicAPIAttribute]
public TimeSpan TotalTime { get; }
    [PublicAPIAttribute]
public SummaryStyle Style { get; }
    [PublicAPIAttribute]
public IOrderer Orderer { get; }
    [PublicAPIAttribute]
public SummaryTable Table { get; }
    [PublicAPIAttribute]
public string AllRuntimes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PublicAPIAttribute]
public ImmutableArray`1<ValidationError> ValidationErrors { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PublicAPIAttribute]
public ImmutableArray`1<IColumnHidingRule> ColumnHidingRules { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PublicAPIAttribute]
public ImmutableArray`1<BenchmarkCase> BenchmarksCases { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PublicAPIAttribute]
public ImmutableArray`1<BenchmarkReport> Reports { get; }
    internal DisplayPrecisionManager DisplayPrecisionManager { get; }
    private ImmutableDictionary`2<BenchmarkCase, BenchmarkReport> ReportMap { get; }
    private BaseliningStrategy BaseliningStrategy { get; }
    [NullableAttribute("2")]
public BenchmarkReport Item { get; }
    public bool HasCriticalValidationErrors { get; }
    public bool IsMultipleRuntimes { get; }
    public Summary(string title, ImmutableArray`1<BenchmarkReport> reports, HostEnvironmentInfo hostEnvironmentInfo, string resultsDirectoryPath, string logFilePath, TimeSpan totalTime, CultureInfo cultureInfo, ImmutableArray`1<ValidationError> validationErrors, ImmutableArray`1<IColumnHidingRule> columnHidingRules, SummaryStyle summaryStyle);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public string get_ResultsDirectoryPath();
    [CompilerGeneratedAttribute]
public string get_LogFilePath();
    [CompilerGeneratedAttribute]
public HostEnvironmentInfo get_HostEnvironmentInfo();
    [CompilerGeneratedAttribute]
public TimeSpan get_TotalTime();
    [CompilerGeneratedAttribute]
public SummaryStyle get_Style();
    [CompilerGeneratedAttribute]
public IOrderer get_Orderer();
    [CompilerGeneratedAttribute]
public SummaryTable get_Table();
    [CompilerGeneratedAttribute]
public string get_AllRuntimes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValidationError> get_ValidationErrors();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IColumnHidingRule> get_ColumnHidingRules();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BenchmarkCase> get_BenchmarksCases();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BenchmarkReport> get_Reports();
    [CompilerGeneratedAttribute]
internal DisplayPrecisionManager get_DisplayPrecisionManager();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<BenchmarkCase, BenchmarkReport> get_ReportMap();
    [CompilerGeneratedAttribute]
private BaseliningStrategy get_BaseliningStrategy();
    [PublicAPIAttribute]
public bool HasReport(BenchmarkCase benchmarkCase);
    public BenchmarkReport get_Item(BenchmarkCase benchmarkCase);
    public bool get_HasCriticalValidationErrors();
    public int GetNumberOfExecutedBenchmarks();
    public bool get_IsMultipleRuntimes();
    internal static Summary ValidationFailed(string title, string resultsDirectoryPath, string logFilePath, Nullable`1<ImmutableArray`1<ValidationError>> validationErrors);
    internal static Summary Join(List`1<Summary> summaries, ClockSpan clockSpan);
    internal static string BuildAllRuntimes(HostEnvironmentInfo hostEnvironmentInfo, IEnumerable`1<BenchmarkReport> reports);
    internal SummaryTable GetTable(SummaryStyle style);
    public string GetLogicalGroupKey(BenchmarkCase benchmarkCase);
    public bool IsBaseline(BenchmarkCase benchmarkCase);
    [NullableContextAttribute("2")]
public BenchmarkCase GetBaseline(string logicalGroupKey);
    public IEnumerable`1<BenchmarkCase> GetNonBaselines(string logicalGroupKey);
    public bool HasBaselines();
    private static IOrderer GetConfiguredOrdererOrDefaultOne(IEnumerable`1<ImmutableConfig> configs);
    private static SummaryStyle GetConfiguredSummaryStyleOrDefaultOne(ImmutableArray`1<BenchmarkCase> benchmarkCases);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private BenchmarkReport <.ctor>b__49_4(BenchmarkCase b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Reports.SummaryExtensions : object {
    [ExtensionAttribute]
public static IColumn[] GetColumns(Summary summary);
    [ExtensionAttribute]
public static IEnumerable`1<BenchmarkCase> GetLogicalGroupForBenchmark(Summary summary, BenchmarkCase benchmarkCase);
    [ExtensionAttribute]
[PureAttribute]
public static CultureInfo GetCultureInfo(Summary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Reports.SummaryStyle : object {
    public static SummaryStyle Default;
    internal static int DefaultMaxParameterColumnWidth;
    [CompilerGeneratedAttribute]
private bool <PrintUnitsInHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintUnitsInContent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintZeroValuesInContent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxParameterColumnWidth>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SizeUnit <SizeUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private SizeUnit <CodeSizeUnit>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TimeUnit <TimeUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private RatioStyle <RatioStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private TextJustification <TextColumnJustification>k__BackingField;
    [CompilerGeneratedAttribute]
private TextJustification <NumericColumnJustification>k__BackingField;
    public bool PrintUnitsInHeader { get; }
    public bool PrintUnitsInContent { get; }
    public bool PrintZeroValuesInContent { get; }
    public int MaxParameterColumnWidth { get; }
    [NullableAttribute("2")]
public SizeUnit SizeUnit { get; }
    internal SizeUnit CodeSizeUnit { get; }
    [NullableAttribute("2")]
public TimeUnit TimeUnit { get; }
    public CultureInfo CultureInfo { get; }
    public RatioStyle RatioStyle { get; }
    public TextJustification TextColumnJustification { get; }
    public TextJustification NumericColumnJustification { get; }
    [NullableContextAttribute("2")]
public SummaryStyle(CultureInfo cultureInfo, bool printUnitsInHeader, SizeUnit sizeUnit, TimeUnit timeUnit, bool printUnitsInContent, bool printZeroValuesInContent, int maxParameterColumnWidth, RatioStyle ratioStyle, TextJustification textColumnJustification, TextJustification numericColumnJustification);
    private static SummaryStyle();
    [CompilerGeneratedAttribute]
public bool get_PrintUnitsInHeader();
    [CompilerGeneratedAttribute]
public bool get_PrintUnitsInContent();
    [CompilerGeneratedAttribute]
public bool get_PrintZeroValuesInContent();
    [CompilerGeneratedAttribute]
public int get_MaxParameterColumnWidth();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SizeUnit get_SizeUnit();
    [CompilerGeneratedAttribute]
internal SizeUnit get_CodeSizeUnit();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TimeUnit get_TimeUnit();
    [CompilerGeneratedAttribute]
public CultureInfo get_CultureInfo();
    [CompilerGeneratedAttribute]
public RatioStyle get_RatioStyle();
    [CompilerGeneratedAttribute]
public TextJustification get_TextColumnJustification();
    [CompilerGeneratedAttribute]
public TextJustification get_NumericColumnJustification();
    public SummaryStyle WithTimeUnit(TimeUnit timeUnit);
    public SummaryStyle WithSizeUnit(SizeUnit sizeUnit);
    public SummaryStyle WithZeroMetricValuesInContent();
    public SummaryStyle WithMaxParameterColumnWidth(int maxParameterColumnWidth);
    public SummaryStyle WithCultureInfo(CultureInfo cultureInfo);
    public SummaryStyle WithRatioStyle(RatioStyle ratioStyle);
    public sealed virtual bool Equals(SummaryStyle other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SummaryStyle left, SummaryStyle right);
    public static bool op_Inequality(SummaryStyle left, SummaryStyle right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Reports.SummaryTable : object {
    [CompilerGeneratedAttribute]
private Summary <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private SummaryTableColumn[] <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnCount>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FullHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private String[][] <FullContent>k__BackingField;
    [CompilerGeneratedAttribute]
private Boolean[] <FullContentStartOfHighlightGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private Boolean[] <FullContentStartOfLogicalGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private String[][] <FullContentWithHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Boolean[] <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private SummaryStyle <EffectiveSummaryStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SeparateLogicalGroups>k__BackingField;
    [PublicAPIAttribute]
public Summary Summary { get; }
    public SummaryTableColumn[] Columns { get; }
    public int ColumnCount { get; }
    public String[] FullHeader { get; }
    public String[][] FullContent { get; }
    public Boolean[] FullContentStartOfHighlightGroup { get; }
    public Boolean[] FullContentStartOfLogicalGroup { get; }
    public String[][] FullContentWithHeader { get; }
    [PublicAPIAttribute]
public Boolean[] IsDefault { get; }
    public SummaryStyle EffectiveSummaryStyle { get; }
    public bool SeparateLogicalGroups { get; }
    internal SummaryTable(Summary summary, SummaryStyle style);
    [CompilerGeneratedAttribute]
public Summary get_Summary();
    [CompilerGeneratedAttribute]
public SummaryTableColumn[] get_Columns();
    [CompilerGeneratedAttribute]
public int get_ColumnCount();
    [CompilerGeneratedAttribute]
public String[] get_FullHeader();
    [CompilerGeneratedAttribute]
public String[][] get_FullContent();
    [CompilerGeneratedAttribute]
public Boolean[] get_FullContentStartOfHighlightGroup();
    [CompilerGeneratedAttribute]
public Boolean[] get_FullContentStartOfLogicalGroup();
    [CompilerGeneratedAttribute]
public String[][] get_FullContentWithHeader();
    [CompilerGeneratedAttribute]
public Boolean[] get_IsDefault();
    [CompilerGeneratedAttribute]
public SummaryStyle get_EffectiveSummaryStyle();
    [CompilerGeneratedAttribute]
public bool get_SeparateLogicalGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class BenchmarkDotNet.Reports.SummaryTableExtensions : object {
    [ThreadStaticAttribute]
private static StringBuilder sharedBuffer;
    [ExtensionAttribute]
public static void PrintCommonColumns(SummaryTable table, ILogger logger);
    [ExtensionAttribute]
public static void PrintLine(SummaryTable table, String[] line, ILogger logger, string leftDel, string rightDel);
    [ExtensionAttribute]
public static void PrintLine(SummaryTable table, String[] line, ILogger logger, string leftDel, string rightDel, bool highlightRow, bool startOfGroup, MarkdownHighlightStrategy startOfGroupHighlightStrategy, string boldMarkupFormat, bool escapeHtml);
    private static string BuildStandardText(SummaryTable table, String[] line, string leftDel, string rightDel, int columnIndex);
    private static string BuildBoldText(SummaryTable table, String[] line, string leftDel, string rightDel, int columnIndex, string boldMarkupFormat);
    private static StringBuilder GetClearBuffer();
    private static void AddPadding(SummaryTable table, String[] line, string leftDel, string rightDel, int columnIndex, StringBuilder buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Running.BenchmarkBuildInfo : object {
    [CompilerGeneratedAttribute]
private BenchmarkCase <BenchmarkCase>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableConfig <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private BenchmarkId <Id>k__BackingField;
    public BenchmarkCase BenchmarkCase { get; }
    public ImmutableConfig Config { get; }
    public BenchmarkId Id { get; }
    public BenchmarkBuildInfo(BenchmarkCase benchmarkCase, ImmutableConfig config, int id);
    [CompilerGeneratedAttribute]
public BenchmarkCase get_BenchmarkCase();
    [CompilerGeneratedAttribute]
public ImmutableConfig get_Config();
    [CompilerGeneratedAttribute]
public BenchmarkId get_Id();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Running.BenchmarkCase : object {
    [CompilerGeneratedAttribute]
private Descriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInstances <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableConfig <Config>k__BackingField;
    public Descriptor Descriptor { get; }
    public Job Job { get; }
    public ParameterInstances Parameters { get; }
    public ImmutableConfig Config { get; }
    public string FolderInfo { get; }
    public string DisplayInfo { get; }
    public bool HasParameters { get; }
    public bool HasArguments { get; }
    internal BenchmarkCase(Descriptor descriptor, Job job, ParameterInstances parameters, ImmutableConfig config);
    [CompilerGeneratedAttribute]
public Descriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public ParameterInstances get_Parameters();
    [CompilerGeneratedAttribute]
public ImmutableConfig get_Config();
    public string get_FolderInfo();
    public string get_DisplayInfo();
    public virtual string ToString();
    public Runtime GetRuntime();
    public sealed virtual void Dispose();
    public sealed virtual int CompareTo(BenchmarkCase other);
    public bool get_HasParameters();
    public bool get_HasArguments();
    public static BenchmarkCase Create(Descriptor descriptor, Job job, ParameterInstances parameters, ImmutableConfig config);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Running.BenchmarkConverter : object {
    private static BindingFlags AllMethodsFlags;
    private static HttpClient Client;
    private static BenchmarkConverter();
    public static BenchmarkRunInfo TypeToBenchmarks(Type type, IConfig config);
    public static BenchmarkRunInfo MethodsToBenchmarks(Type containingType, MethodInfo[] benchmarkMethods, IConfig config);
    private static MethodInfo[] GetOrderedBenchmarkMethods(MethodInfo[] methods);
    private static BenchmarkRunInfo MethodsToBenchmarksWithFullConfig(Type type, MethodInfo[] benchmarkMethods, IConfig config);
    private static ImmutableConfig GetFullTypeConfig(Type type, IConfig config);
    private static ImmutableConfig GetFullMethodConfig(MethodInfo method, ImmutableConfig typeConfig);
    private static IEnumerable`1<Descriptor> GetTargets(MethodInfo[] targetMethods, Type type, Tuple`2[] globalSetupMethods, Tuple`2[] globalCleanupMethods, Tuple`2[] iterationSetupMethods, Tuple`2[] iterationCleanupMethods, IConfig config);
    private static MethodInfo GetTargetedMatchingMethod(MethodInfo benchmarkMethod, Tuple`2[] methods);
    private static Tuple`2[] GetAttributedMethods(MethodInfo[] methods, string methodName);
    private static Descriptor CreateDescriptor(Type type, MethodInfo globalSetupMethod, MethodInfo methodInfo, MethodInfo globalCleanupMethod, MethodInfo iterationSetupMethod, MethodInfo iterationCleanupMethod, BenchmarkAttribute attr, MethodInfo[] targetMethods, IConfig config);
    private static ParameterDefinitions GetParameterDefinitions(Type type);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Running.BenchmarkConverter/<GetArgumentsDefinitions>d__12")]
private static IEnumerable`1<ParameterInstances> GetArgumentsDefinitions(MethodInfo benchmark, Type target, SummaryStyle summaryStyle);
    private static ImmutableArray`1<BenchmarkCase> GetFilteredBenchmarks(IEnumerable`1<BenchmarkCase> benchmarks, IEnumerable`1<IFilter> filters);
    private static void AssertMethodHasCorrectSignature(string methodType, MethodInfo methodInfo);
    private static void AssertMethodIsAccessible(string methodType, MethodInfo methodInfo);
    private static void AssertMethodIsNotGeneric(string methodType, MethodInfo methodInfo);
    private static Object[] GetValidValues(Object[] values, Type parameterType);
    private static object Map(object providedValue, Type type);
    private static ValueTuple`2<MemberInfo, Object[]> GetValidValuesForParamsSource(Type parentType, string sourceName);
    private static Object[] ToArray(object sourceValue, MemberInfo memberInfo, Type type);
    private static Object[] GetAllValidValues(Type parameterType);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will be removed soon as it is not supported in .NET Core")]
public static BenchmarkRunInfo[] UrlToBenchmarks(string url, IConfig config);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will be removed soon as it is not supported in .NET Core")]
public static BenchmarkRunInfo[] SourceToBenchmarks(string source, IConfig config);
    private static string GetRawUrl(string url);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Running.BenchmarkId : ValueType {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullBenchmarkName>k__BackingField;
    public int Value { get; }
    private string JobId { get; }
    private string FullBenchmarkName { get; }
    public BenchmarkId(int value, BenchmarkCase benchmarkCase);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private string get_JobId();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private string get_FullBenchmarkName();
    [PublicAPIAttribute]
public bool Equals(BenchmarkId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string ToArguments();
    public string ToArguments(string fromBenchmark, string toBenchmark);
    public virtual string ToString();
    private static string GetBenchmarkName(BenchmarkCase benchmark);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Running.BenchmarkPartitioner : object {
    public static BuildPartition[] CreateForBuild(BenchmarkRunInfo[] supportedBenchmarks, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Running.BenchmarkRunInfo : object {
    [CompilerGeneratedAttribute]
private BenchmarkCase[] <BenchmarksCases>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableConfig <Config>k__BackingField;
    public BenchmarkCase[] BenchmarksCases { get; }
    public Type Type { get; }
    public ImmutableConfig Config { get; }
    public BenchmarkRunInfo(BenchmarkCase[] benchmarksCase, Type type, ImmutableConfig config);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public BenchmarkCase[] get_BenchmarksCases();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public ImmutableConfig get_Config();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Running.BenchmarkRunner : object {
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public static Summary Run(IConfig config, String[] args);
    [PublicAPIAttribute]
public static Summary Run(Type type, IConfig config, String[] args);
    [PublicAPIAttribute]
public static Summary[] Run(Type[] types, IConfig config, String[] args);
    [PublicAPIAttribute]
public static Summary Run(Type type, MethodInfo[] methods, IConfig config);
    [PublicAPIAttribute]
public static Summary[] Run(Assembly assembly, IConfig config, String[] args);
    [PublicAPIAttribute]
public static Summary Run(BenchmarkRunInfo benchmarkRunInfo);
    [PublicAPIAttribute]
public static Summary[] Run(BenchmarkRunInfo[] benchmarkRunInfos);
    [PublicAPIAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will be removed soon as it is not supported in .NET Core")]
public static Summary RunUrl(string url, IConfig config);
    [PublicAPIAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method will be removed soon as it is not supported in .NET Core")]
public static Summary RunSource(string source, IConfig config);
    private static Summary RunWithDirtyAssemblyResolveHelper(Type type, IConfig config, String[] args);
    private static Summary RunWithDirtyAssemblyResolveHelper(Type type, MethodInfo[] methods, IConfig config);
    private static Summary[] RunWithDirtyAssemblyResolveHelper(Assembly assembly, IConfig config, String[] args);
    private static Summary[] RunWithDirtyAssemblyResolveHelper(Type[] types, IConfig config, String[] args);
    private static Summary[] RunWithDirtyAssemblyResolveHelper(BenchmarkRunInfo[] benchmarkRunInfos);
    private static Summary RunUrlWithDirtyAssemblyResolveHelper(string url, IConfig config);
    private static Summary RunSourceWithDirtyAssemblyResolveHelper(string source, IConfig config);
    private static Summary RunWithExceptionHandling(Func`1<Summary> run);
    private static Summary[] RunWithExceptionHandling(Func`1<Summary[]> run);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Running.BenchmarkRunnerClean : object {
    internal static string DateTimeFormat;
    internal static IResolver DefaultResolver;
    private static BenchmarkRunnerClean();
    internal static Summary[] Run(BenchmarkRunInfo[] benchmarkRunInfos);
    private static Summary Run(BenchmarkRunInfo benchmarkRunInfo, Dictionary`2<BenchmarkCase, ValueTuple`2<BenchmarkId, BuildResult>> buildResults, IResolver resolver, ILogger logger, EventProcessor eventProcessor, List`1<string> artifactsToCleanup, string resultsFolderPath, string logFilePath, int totalBenchmarkCount, StartedClock& runsChronometer, Int32& benchmarksToRunCount, TaskbarProgress taskbarProgress);
    private static void PrintSummary(ILogger logger, ImmutableConfig config, Summary summary);
    private static ImmutableArray`1<ValidationError> Validate(BenchmarkRunInfo[] benchmarks);
    private static Dictionary`2<BuildPartition, BuildResult> BuildInParallel(ILogger logger, string rootArtifactsFolderPath, BuildPartition[] buildPartitions, StartedClock& globalChronometer, EventProcessor eventProcessor);
    private static BuildResult Build(BuildPartition buildPartition, string rootArtifactsFolderPath, ILogger buildLogger);
    private static BenchmarkReport RunCore(BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, ILogger logger, IResolver resolver, BuildResult buildResult);
    private static ValueTuple`3<bool, List`1<ExecuteResult>, List`1<Metric>> Execute(ILogger logger, BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, IToolchain toolchain, BuildResult buildResult, IResolver resolver);
    private static ExecuteResult RunExecute(ILogger logger, BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, IToolchain toolchain, BuildResult buildResult, IResolver resolver, IDiagnoser diagnoser, int launchIndex);
    private static void LogTotalTime(ILogger logger, TimeSpan time, int executedBenchmarksCount, string message);
    private static ValueTuple`2<BenchmarkRunInfo[], List`1<ValidationError>> GetSupportedBenchmarks(BenchmarkRunInfo[] benchmarkRunInfos, IResolver resolver);
    private static string GetRootArtifactsFolderPath(BenchmarkRunInfo[] benchmarkRunInfos);
    private static string GetTitle(BenchmarkRunInfo[] benchmarkRunInfos, int desiredMaxLength);
    private static string GetResultsFolderPath(string rootArtifactsFolderPath, BenchmarkRunInfo[] benchmarkRunInfos);
    private static StreamWriter GetLogFileStreamWriter(BenchmarkRunInfo[] benchmarkRunInfos, string logFilePath);
    private static ILogger CreateCompositeLogger(BenchmarkRunInfo[] benchmarkRunInfos, StreamLogger streamLogger);
    private static void Cleanup(ILogger logger, HashSet`1<string> artifactsToCleanup);
    private static void LogProgress(ILogger logger, StartedClock& runsChronometer, int totalBenchmarkCount, int benchmarksToRunCount, ConsoleTitler consoleTitler, TaskbarProgress taskbarProgress);
    private static TimeSpan GetEstimatedFinishTime(StartedClock& runsChronometer, int benchmarksToRunCount, int executedBenchmarkCount);
    private static void PrintValidationErrors(ILogger logger, IEnumerable`1<ValidationError> validationErrors);
    private static int GetIdToResume(string rootArtifactsFolderPath, string currentLogFileName, BenchmarkRunInfo[] benchmarkRunInfos);
    [CompilerGeneratedAttribute]
internal static string <BuildInParallel>g__GetFormattedDifference|6_5(ClockSpan before, ClockSpan after);
    [CompilerGeneratedAttribute]
internal static void <CreateCompositeLogger>g__AddLogger|17_0(ILogger logger, <>c__DisplayClass17_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Running.BenchmarkSwitcher : object {
    private IUserInteraction userInteraction;
    private List`1<Type> types;
    private List`1<Assembly> assemblies;
    internal BenchmarkSwitcher(IUserInteraction userInteraction);
    [PublicAPIAttribute]
public BenchmarkSwitcher(Type[] types);
    [PublicAPIAttribute]
public BenchmarkSwitcher(Assembly assembly);
    [PublicAPIAttribute]
public BenchmarkSwitcher(Assembly[] assemblies);
    [PublicAPIAttribute]
public BenchmarkSwitcher With(Type type);
    [PublicAPIAttribute]
public BenchmarkSwitcher With(Type[] types);
    [PublicAPIAttribute]
public BenchmarkSwitcher With(Assembly assembly);
    [PublicAPIAttribute]
public BenchmarkSwitcher With(Assembly[] assemblies);
    [PublicAPIAttribute]
public static BenchmarkSwitcher FromTypes(Type[] types);
    [PublicAPIAttribute]
public static BenchmarkSwitcher FromAssembly(Assembly assembly);
    [PublicAPIAttribute]
public static BenchmarkSwitcher FromAssemblies(Assembly[] assemblies);
    [PublicAPIAttribute]
public IEnumerable`1<Summary> RunAll(IConfig config, String[] args);
    [PublicAPIAttribute]
public Summary RunAllJoined(IConfig config, String[] args);
    [PublicAPIAttribute]
public IEnumerable`1<Summary> Run(String[] args, IConfig config);
    internal IEnumerable`1<Summary> RunWithDirtyAssemblyResolveHelper(String[] args, IConfig config, bool askUserForInput);
    private static void PrintList(ILogger nonNullLogger, IConfig effectiveConfig, IReadOnlyList`1<Type> allAvailableTypesWithRunnableBenchmarks, CommandLineOptions options);
    private IEnumerable`1<Summary> ApplesToApples(ImmutableConfig effectiveConfig, IReadOnlyList`1<Type> benchmarksToFilter, ILogger logger, CommandLineOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Running.BuildPartition : object {
    [CompilerGeneratedAttribute]
private BenchmarkBuildInfo[] <Benchmarks>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProgramName>k__BackingField;
    [CompilerGeneratedAttribute]
private BenchmarkCase <RepresentativeBenchmarkCase>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogBuildOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMSBuildBinLog>k__BackingField;
    public BenchmarkBuildInfo[] Benchmarks { get; }
    public string ProgramName { get; }
    public BenchmarkCase RepresentativeBenchmarkCase { get; }
    public IResolver Resolver { get; }
    public string AssemblyLocation { get; }
    public string BuildConfiguration { get; }
    public Platform Platform { get; }
    [PublicAPIAttribute]
public Jit Jit { get; }
    public bool IsNativeAot { get; }
    public bool IsWasm { get; }
    public bool IsNetFramework { get; }
    public Runtime Runtime { get; }
    public bool IsCustomBuildConfiguration { get; }
    public TimeSpan Timeout { get; }
    public bool LogBuildOutput { get; }
    public bool GenerateMSBuildBinLog { get; }
    internal bool ForcedNoDependenciesForIntegrationTests { get; }
    public BuildPartition(BenchmarkBuildInfo[] benchmarks, IResolver resolver);
    [CompilerGeneratedAttribute]
public BenchmarkBuildInfo[] get_Benchmarks();
    [CompilerGeneratedAttribute]
public string get_ProgramName();
    [CompilerGeneratedAttribute]
public BenchmarkCase get_RepresentativeBenchmarkCase();
    [CompilerGeneratedAttribute]
public IResolver get_Resolver();
    public string get_AssemblyLocation();
    public string get_BuildConfiguration();
    public Platform get_Platform();
    public Jit get_Jit();
    public bool get_IsNativeAot();
    public bool get_IsWasm();
    public bool get_IsNetFramework();
    public Runtime get_Runtime();
    public bool get_IsCustomBuildConfiguration();
    public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public bool get_LogBuildOutput();
    [CompilerGeneratedAttribute]
public bool get_GenerateMSBuildBinLog();
    public virtual string ToString();
    private static string GetResolvedAssemblyLocation(Assembly assembly);
    internal bool get_ForcedNoDependenciesForIntegrationTests();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Running.ConsoleTitler : object {
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    private string oldConsoleTitle;
    public bool IsEnabled { get; private set; }
    public ConsoleTitler(string initialTitle);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
private void set_IsEnabled(bool value);
    [SupportedOSPlatformGuardAttribute("windows")]
private static bool PlatformSupportsTitleRead();
    public void UpdateTitle(string title);
    public sealed virtual void Dispose();
}
public class BenchmarkDotNet.Running.DefaultCategoryDiscoverer : object {
    [NullableAttribute("1")]
public static ICategoryDiscoverer Instance;
    private bool inherit;
    public DefaultCategoryDiscoverer(bool inherit);
    private static DefaultCategoryDiscoverer();
    [NullableContextAttribute("1")]
public virtual String[] GetCategories(MethodInfo method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Running.Descriptor : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <WorkloadMethod>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MethodInfo <GlobalSetupMethod>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MethodInfo <GlobalCleanupMethod>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MethodInfo <IterationSetupMethod>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MethodInfo <IterationCleanupMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalLogic>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationsPerInvoke>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkloadMethodDisplayInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MethodIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Baseline>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Categories>k__BackingField;
    public Type Type { get; }
    public MethodInfo WorkloadMethod { get; }
    [NullableAttribute("2")]
public MethodInfo GlobalSetupMethod { get; }
    [NullableAttribute("2")]
public MethodInfo GlobalCleanupMethod { get; }
    [NullableAttribute("2")]
public MethodInfo IterationSetupMethod { get; }
    [NullableAttribute("2")]
public MethodInfo IterationCleanupMethod { get; }
    public string AdditionalLogic { get; }
    public int OperationsPerInvoke { get; }
    public string WorkloadMethodDisplayInfo { get; }
    public int MethodIndex { get; }
    public bool Baseline { get; }
    public String[] Categories { get; }
    internal string TypeInfo { get; }
    private string MethodFolderInfo { get; }
    public string FolderInfo { get; }
    public string DisplayInfo { get; }
    [NullableContextAttribute("2")]
public Descriptor(Type type, MethodInfo workloadMethod, MethodInfo globalSetupMethod, MethodInfo globalCleanupMethod, MethodInfo iterationSetupMethod, MethodInfo iterationCleanupMethod, string description, string additionalLogic, bool baseline, String[] categories, int operationsPerInvoke, int methodIndex);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public MethodInfo get_WorkloadMethod();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MethodInfo get_GlobalSetupMethod();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MethodInfo get_GlobalCleanupMethod();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MethodInfo get_IterationSetupMethod();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MethodInfo get_IterationCleanupMethod();
    [CompilerGeneratedAttribute]
public string get_AdditionalLogic();
    [CompilerGeneratedAttribute]
public int get_OperationsPerInvoke();
    [CompilerGeneratedAttribute]
public string get_WorkloadMethodDisplayInfo();
    [CompilerGeneratedAttribute]
public int get_MethodIndex();
    [CompilerGeneratedAttribute]
public bool get_Baseline();
    [CompilerGeneratedAttribute]
public String[] get_Categories();
    internal string get_TypeInfo();
    private string get_MethodFolderInfo();
    public string get_FolderInfo();
    public string get_DisplayInfo();
    public virtual string ToString();
    [NullableContextAttribute("2")]
private static string FormatDescription(string description);
    public bool HasCategory(string category);
    public string GetFilterName();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Descriptor other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Running.DescriptorComparer : object {
    [PublicAPIAttribute]
public static IComparer`1<Descriptor> Alphabetical;
    [PublicAPIAttribute]
public static IComparer`1<Descriptor> Declared;
    private MethodOrderPolicy methodOrderPolicy;
    public DescriptorComparer(MethodOrderPolicy methodOrderPolicy);
    private static DescriptorComparer();
    public sealed virtual int Compare(Descriptor x, Descriptor y);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Running.ICategoryDiscoverer {
    public abstract virtual String[] GetCategories(MethodInfo method);
}
public class BenchmarkDotNet.Running.InvalidBenchmarkDeclarationException : Exception {
    [NullableContextAttribute("1")]
public InvalidBenchmarkDeclarationException(string message);
}
[NullableContextAttribute("1")]
internal interface BenchmarkDotNet.Running.IUserInteraction {
    public abstract virtual void PrintNoBenchmarksError(ILogger logger);
    public abstract virtual void PrintWrongFilterInfo(IReadOnlyList`1<Type> allTypes, ILogger logger, String[] userFilters);
    public abstract virtual IReadOnlyList`1<Type> AskUser(IReadOnlyList`1<Type> allTypes, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Running.PowerManagementApplier : object {
    private static Guid UserPowerPlan;
    private static Dictionary`2<PowerPlan, Guid> PowerPlansDict;
    private ILogger logger;
    private Nullable`1<Guid> userCurrentPowerPlan;
    private bool powerPlanChanged;
    private bool isInitialized;
    internal PowerManagementApplier(ILogger logger);
    private static PowerManagementApplier();
    public sealed virtual void Dispose();
    internal static Guid Map(PowerPlan value);
    internal void ApplyPerformancePlan(Guid id);
    private void ApplyUserPowerPlan();
    private void ApplyPlanByGuid(Guid guid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Running.TypeFilter : object {
    public static ValueTuple`2<bool, IReadOnlyList`1<Type>> GetTypesWithRunnableBenchmarks(IEnumerable`1<Type> types, IEnumerable`1<Assembly> assemblies, ILogger logger);
    public static BenchmarkRunInfo[] Filter(IConfig effectiveConfig, IEnumerable`1<Type> types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Running.UserInteraction : object {
    private static bool consoleCancelKeyPressed;
    private static UserInteraction();
    public sealed virtual void PrintNoBenchmarksError(ILogger logger);
    public sealed virtual IReadOnlyList`1<Type> AskUser(IReadOnlyList`1<Type> allTypes, ILogger logger);
    public sealed virtual void PrintWrongFilterInfo(IReadOnlyList`1<Type> allTypes, ILogger logger, String[] userFilters);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Running.UserInteraction/<GetMatching>d__5")]
private static IEnumerable`1<Type> GetMatching(IReadOnlyList`1<Type> allTypes, String[] userInput);
    private static void PrintAvailable(IReadOnlyList`1<Type> allTypes, ILogger logger);
    [CompilerGeneratedAttribute]
internal static bool <GetMatching>g__IsInteger|5_2(string str);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Toolchains.AppConfigGenerator : object {
    private static HashSet`1<string> JobRuntimeSettings;
    private static AppConfigGenerator();
    internal static void Generate(Job job, TextReader source, TextWriter destination, IResolver resolver);
    private static XmlNode GetOrCreateConfigurationElement(XmlDocument xmlDocument, XmlReader xmlReader);
    private static XmlNode GetOrCreateRuntimeElement(XmlDocument xmlDocument, XmlNode configurationElement);
    private static void ClearAllRuntimeSettingsThatCanBeSetOnlyByJobConfiguration(XmlNode runtimeElement);
    private static void ClearStartupSettingsForCustomClr(XmlNode configurationElement, Runtime runtime);
    private static void GenerateJitSettings(XmlDocument xmlDocument, XmlNode runtimeElement, EnvironmentMode environmentMode);
    private static void GenerateGCSettings(XmlDocument xmlDocument, XmlNode runtimeElement, GcMode gcMode, IResolver resolver);
    private static void CreateNodeWithAttribute(XmlDocument document, XmlNode parentNode, string nodeName, string attributeName, string attributeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.ArtifactsPaths : object {
    public static ArtifactsPaths Empty;
    [CompilerGeneratedAttribute]
private string <RootArtifactsFolderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildArtifactsDirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BinariesDirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IntermediateDirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProgramCodePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuGetConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildScriptFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecutablePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProgramName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectoryName>k__BackingField;
    [PublicAPIAttribute]
public string RootArtifactsFolderPath { get; }
    [PublicAPIAttribute]
public string BuildArtifactsDirectoryPath { get; }
    [PublicAPIAttribute]
public string BinariesDirectoryPath { get; }
    [PublicAPIAttribute]
public string IntermediateDirectoryPath { get; }
    [PublicAPIAttribute]
public string ProgramCodePath { get; }
    [PublicAPIAttribute]
public string AppConfigPath { get; }
    [PublicAPIAttribute]
public string NuGetConfigPath { get; }
    [PublicAPIAttribute]
public string ProjectFilePath { get; }
    [PublicAPIAttribute]
public string BuildScriptFilePath { get; }
    [PublicAPIAttribute]
public string ExecutablePath { get; }
    [PublicAPIAttribute]
public string ProgramName { get; }
    [PublicAPIAttribute]
public string PackagesDirectoryName { get; }
    public ArtifactsPaths(string rootArtifactsFolderPath, string buildArtifactsDirectoryPath, string binariesDirectoryPath, string intermediateDirectoryPath, string programCodePath, string appConfigPath, string nuGetConfigPath, string projectFilePath, string buildScriptFilePath, string executablePath, string programName, string packagesDirectoryName);
    private static ArtifactsPaths();
    [CompilerGeneratedAttribute]
public string get_RootArtifactsFolderPath();
    [CompilerGeneratedAttribute]
public string get_BuildArtifactsDirectoryPath();
    [CompilerGeneratedAttribute]
public string get_BinariesDirectoryPath();
    [CompilerGeneratedAttribute]
public string get_IntermediateDirectoryPath();
    [CompilerGeneratedAttribute]
public string get_ProgramCodePath();
    [CompilerGeneratedAttribute]
public string get_AppConfigPath();
    [CompilerGeneratedAttribute]
public string get_NuGetConfigPath();
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public string get_BuildScriptFilePath();
    [CompilerGeneratedAttribute]
public string get_ExecutablePath();
    [CompilerGeneratedAttribute]
public string get_ProgramName();
    [CompilerGeneratedAttribute]
public string get_PackagesDirectoryName();
}
[ObsoleteAttribute("Please use NativeAotToolchain instead.", "True")]
public class BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchain : object {
}
[ObsoleteAttribute("Please use NativeAotToolchainBuilder instead.", "True")]
public class BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchainBuilder : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.CoreRun.CoreRunGenerator : CsProjGenerator {
    [CompilerGeneratedAttribute]
private FileInfo <SourceCoreRun>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfo <CopyCoreRun>k__BackingField;
    private FileInfo SourceCoreRun { get; }
    private FileInfo CopyCoreRun { get; }
    private bool NeedsCopy { get; }
    public CoreRunGenerator(FileInfo sourceCoreRun, FileInfo copyCoreRun, string targetFrameworkMoniker, string cliPath, string packagesPath);
    [CompilerGeneratedAttribute]
private FileInfo get_SourceCoreRun();
    [CompilerGeneratedAttribute]
private FileInfo get_CopyCoreRun();
    private bool get_NeedsCopy();
    protected virtual string GetPackagesDirectoryPath(string buildArtifactsDirectoryPath);
    protected virtual string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration);
    protected virtual void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths);
    protected virtual String[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths);
    private static void CopyFilesRecursively(DirectoryInfo source, DirectoryInfo target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.CoreRun.CoreRunPublisher : object {
    [CompilerGeneratedAttribute]
private FileInfo <CoreRun>k__BackingField;
    [CompilerGeneratedAttribute]
private DotNetCliPublisher <DotNetCliPublisher>k__BackingField;
    private FileInfo CoreRun { get; }
    private DotNetCliPublisher DotNetCliPublisher { get; }
    public CoreRunPublisher(FileInfo coreRun, FileInfo customDotNetCliPath);
    [CompilerGeneratedAttribute]
private FileInfo get_CoreRun();
    [CompilerGeneratedAttribute]
private DotNetCliPublisher get_DotNetCliPublisher();
    public sealed virtual BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
    private void UpdateDuplicatedDependencies(ArtifactsPaths artifactsPaths, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.CoreRun.CoreRunToolchain : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IGenerator <Generator>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private IExecutor <Executor>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfo <SourceCoreRun>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfo <CopyCoreRun>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfo <CustomDotNetCliPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryInfo <RestorePath>k__BackingField;
    public string Name { get; }
    public IGenerator Generator { get; }
    public IBuilder Builder { get; }
    public IExecutor Executor { get; }
    public bool IsInProcess { get; }
    public FileInfo SourceCoreRun { get; }
    public FileInfo CopyCoreRun { get; }
    public FileInfo CustomDotNetCliPath { get; }
    public DirectoryInfo RestorePath { get; }
    public CoreRunToolchain(FileInfo coreRun, bool createCopy, string targetFrameworkMoniker, FileInfo customDotNetCliPath, DirectoryInfo restorePath, string displayName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IGenerator get_Generator();
    [CompilerGeneratedAttribute]
public sealed virtual IBuilder get_Builder();
    [CompilerGeneratedAttribute]
public sealed virtual IExecutor get_Executor();
    public sealed virtual bool get_IsInProcess();
    [CompilerGeneratedAttribute]
public FileInfo get_SourceCoreRun();
    [CompilerGeneratedAttribute]
public FileInfo get_CopyCoreRun();
    [CompilerGeneratedAttribute]
public FileInfo get_CustomDotNetCliPath();
    [CompilerGeneratedAttribute]
public DirectoryInfo get_RestorePath();
    public virtual string ToString();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.CoreRun.CoreRunToolchain/<Validate>d__28")]
public sealed virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmark, IResolver resolver);
    private static FileInfo GetShadowCopyPath(FileInfo coreRunPath);
    [CompilerGeneratedAttribute]
internal static bool <GetShadowCopyPath>g__TryToCreateSubfolder|29_0(DirectoryInfo directory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.CsProj.CsProjClassicNetToolchain : Toolchain {
    [PublicAPIAttribute]
public static IToolchain Net461;
    [PublicAPIAttribute]
public static IToolchain Net462;
    [PublicAPIAttribute]
public static IToolchain Net47;
    [PublicAPIAttribute]
public static IToolchain Net471;
    [PublicAPIAttribute]
public static IToolchain Net472;
    [PublicAPIAttribute]
public static IToolchain Net48;
    [PublicAPIAttribute]
public static IToolchain Net481;
    [CompilerGeneratedAttribute]
private string <CustomDotNetCliPath>k__BackingField;
    internal string CustomDotNetCliPath { get; }
    private CsProjClassicNetToolchain(string targetFrameworkMoniker, string name, string packagesPath, string customDotNetCliPath);
    private static CsProjClassicNetToolchain();
    [CompilerGeneratedAttribute]
internal string get_CustomDotNetCliPath();
    public static IToolchain From(string targetFrameworkMoniker, string packagesPath, string customDotNetCliPath);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.CsProj.CsProjClassicNetToolchain/<Validate>d__12")]
public virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationError> <>n__0(BenchmarkCase benchmarkCase, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.CsProj.CsProjCoreToolchain : Toolchain {
    [PublicAPIAttribute]
public static IToolchain NetCoreApp20;
    [PublicAPIAttribute]
public static IToolchain NetCoreApp21;
    [PublicAPIAttribute]
public static IToolchain NetCoreApp22;
    [PublicAPIAttribute]
public static IToolchain NetCoreApp30;
    [PublicAPIAttribute]
public static IToolchain NetCoreApp31;
    [PublicAPIAttribute]
public static IToolchain NetCoreApp50;
    [PublicAPIAttribute]
public static IToolchain NetCoreApp60;
    [PublicAPIAttribute]
public static IToolchain NetCoreApp70;
    [PublicAPIAttribute]
public static IToolchain NetCoreApp80;
    [PublicAPIAttribute]
public static IToolchain NetCoreApp90;
    [CompilerGeneratedAttribute]
private string <CustomDotNetCliPath>k__BackingField;
    internal string CustomDotNetCliPath { get; }
    internal CsProjCoreToolchain(string name, IGenerator generator, IBuilder builder, IExecutor executor, string customDotNetCliPath);
    private static CsProjCoreToolchain();
    [CompilerGeneratedAttribute]
internal string get_CustomDotNetCliPath();
    [PublicAPIAttribute]
public static IToolchain From(NetCoreAppSettings settings);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.CsProj.CsProjCoreToolchain/<Validate>d__15")]
public virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CsProjCoreToolchain other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationError> <>n__0(BenchmarkCase benchmarkCase, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.CsProj.CsProjGenerator : DotNetCliGenerator {
    private static string DefaultSdkName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> SettingsWeWantToCopy;
    [CompilerGeneratedAttribute]
private string <RuntimeFrameworkVersion>k__BackingField;
    public string RuntimeFrameworkVersion { get; }
    public CsProjGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string runtimeFrameworkVersion, bool isNetCore);
    private static CsProjGenerator();
    [CompilerGeneratedAttribute]
public string get_RuntimeFrameworkVersion();
    protected virtual string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName);
    protected virtual string GetProjectFilePath(string buildArtifactsDirectoryPath);
    protected virtual string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration);
    protected virtual string GetIntermediateDirectoryPath(string buildArtifactsDirectoryPath, string configuration);
    protected virtual void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger);
    [PublicAPIAttribute]
protected virtual string GetRuntimeSettings(GcMode gcMode, IResolver resolver);
    internal ValueTuple`2<string, string> GetSettingsThatNeedToBeCopied(XmlDocument xmlDoc, FileInfo projectFile);
    private static void GetSettingsThatNeedToBeCopied(XmlElement projectElement, XmlDocument& itemGroupsettings, XmlDocument& propertyGroupSettings, FileInfo projectFile);
    private static void CopyProperties(XmlElement projectElement, XmlDocument& copyToDocument, string groupName);
    private static string GetIndentedXmlString(XmlDocument doc);
    [PublicAPIAttribute]
protected virtual FileInfo GetProjectFilePath(Type benchmarkTarget, ILogger logger);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CsProjGenerator other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder : object {
    protected Dictionary`2<string, string> Feeds;
    protected string runtimeIdentifier;
    protected string customDotNetCliPath;
    protected string displayName;
    protected string runtimeFrameworkVersion;
    protected bool useNuGetClearTag;
    protected bool useTempFolderForRestore;
    private string targetFrameworkMoniker;
    public abstract virtual IToolchain ToToolchain();
    [PublicAPIAttribute]
public CustomDotNetCliToolchainBuilder AdditionalNuGetFeed(string feedName, string feedAddress);
    public CustomDotNetCliToolchainBuilder UseNuGetClearTag(bool value);
    [PublicAPIAttribute]
public CustomDotNetCliToolchainBuilder TargetFrameworkMoniker(string targetFrameworkMoniker);
    protected string GetTargetFrameworkMoniker();
    [PublicAPIAttribute]
public CustomDotNetCliToolchainBuilder DotNetCli(string newCustomDotNetCliPath);
    [PublicAPIAttribute]
public CustomDotNetCliToolchainBuilder RuntimeIdentifier(string newRuntimeIdentifier);
    [PublicAPIAttribute]
public CustomDotNetCliToolchainBuilder RuntimeFrameworkVersion(string newRuntimeFrameworkVersion);
    [PublicAPIAttribute]
public CustomDotNetCliToolchainBuilder DisplayName(string newDisplayName);
    [PublicAPIAttribute]
public CustomDotNetCliToolchainBuilder UseTempFolderForRestore(bool value);
    internal static string GetPortableRuntimeIdentifier();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliBuilder : object {
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomDotNetCliPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogOutput>k__BackingField;
    private string TargetFrameworkMoniker { get; }
    private string CustomDotNetCliPath { get; }
    private bool LogOutput { get; }
    [PublicAPIAttribute]
public DotNetCliBuilder(string targetFrameworkMoniker, string customDotNetCliPath, bool logOutput);
    [CompilerGeneratedAttribute]
private string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
private string get_CustomDotNetCliPath();
    [CompilerGeneratedAttribute]
private bool get_LogOutput();
    public sealed virtual BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommand : object {
    [CompilerGeneratedAttribute]
private string <CliPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private GenerateResult <GenerateResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildPartition <BuildPartition>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EnvironmentVariable> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogOutput>k__BackingField;
    [PublicAPIAttribute]
public string CliPath { get; }
    [PublicAPIAttribute]
public string Arguments { get; }
    [PublicAPIAttribute]
public GenerateResult GenerateResult { get; }
    [PublicAPIAttribute]
public ILogger Logger { get; }
    [PublicAPIAttribute]
public BuildPartition BuildPartition { get; }
    [PublicAPIAttribute]
public IReadOnlyList`1<EnvironmentVariable> EnvironmentVariables { get; }
    [PublicAPIAttribute]
public TimeSpan Timeout { get; }
    [PublicAPIAttribute]
public bool LogOutput { get; }
    public DotNetCliCommand(string cliPath, string arguments, GenerateResult generateResult, ILogger logger, BuildPartition buildPartition, IReadOnlyList`1<EnvironmentVariable> environmentVariables, TimeSpan timeout, bool logOutput);
    [CompilerGeneratedAttribute]
public string get_CliPath();
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public GenerateResult get_GenerateResult();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public BuildPartition get_BuildPartition();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EnvironmentVariable> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public bool get_LogOutput();
    public DotNetCliCommand WithArguments(string arguments);
    public DotNetCliCommand WithCliPath(string cliPath);
    [PublicAPIAttribute]
public BuildResult RestoreThenBuild();
    [PublicAPIAttribute]
public BuildResult RestoreThenBuildThenPublish();
    public DotNetCliCommandResult AddPackages();
    public DotNetCliCommandResult Restore();
    public DotNetCliCommandResult Build();
    public DotNetCliCommandResult BuildNoRestore();
    public DotNetCliCommandResult Publish();
    public DotNetCliCommandResult PublishNoRestore();
    internal static IEnumerable`1<string> GetAddPackagesCommands(BuildPartition buildPartition);
    internal static string GetRestoreCommand(ArtifactsPaths artifactsPaths, BuildPartition buildPartition, string extraArguments, string binLogSuffix, bool excludeOutput);
    internal static string GetBuildCommand(ArtifactsPaths artifactsPaths, BuildPartition buildPartition, string extraArguments, string binLogSuffix, bool excludeOutput);
    internal static string GetPublishCommand(ArtifactsPaths artifactsPaths, BuildPartition buildPartition, string extraArguments, string binLogSuffix);
    private static string GetMsBuildBinLogArgument(BuildPartition buildPartition, string suffix);
    private static string GetCustomMsBuildArguments(BenchmarkCase benchmarkCase, IResolver resolver);
    private static IEnumerable`1<string> GetNuGetAddPackageCommands(BenchmarkCase benchmarkCase, IResolver resolver);
    private static string GetMandatoryMsBuildSettings(string buildConfiguration);
    private static string BuildAddPackageCommand(NuGetReference reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public static class BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandExecutor : object {
    internal static Lazy`1<string> DefaultDotNetCliPath;
    private static DotNetCliCommandExecutor();
    [PublicAPIAttribute]
public static DotNetCliCommandResult Execute(DotNetCliCommand parameters);
    [NullableContextAttribute("2")]
internal static string GetDotNetSdkVersion();
    internal static void LogEnvVars(DotNetCliCommand command);
    internal static ProcessStartInfo BuildStartInfo(string customDotNetCliPath, string workingDirectory, string arguments, IReadOnlyList`1<EnvironmentVariable> environmentVariables, bool redirectStandardInput, bool redirectStandardError, bool redirectStandardOutput);
    private static string GetDefaultDotNetCliPath();
    internal static string GetSdkPath(string cliPath);
}
[ExtensionAttribute]
internal static class BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static StringBuilder MaybeAppendOutputPaths(StringBuilder stringBuilder, ArtifactsPaths artifactsPaths, bool isRestore, bool excludeOutput);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandResult : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardError>k__BackingField;
    [PublicAPIAttribute]
public bool IsSuccess { get; }
    [PublicAPIAttribute]
public TimeSpan ExecutionTime { get; }
    [PublicAPIAttribute]
public string StandardOutput { get; }
    [PublicAPIAttribute]
public string StandardError { get; }
    public string AllInformation { get; }
    [PublicAPIAttribute]
public bool HasNonEmptyErrorMessage { get; }
    private DotNetCliCommandResult(bool isSuccess, TimeSpan executionTime, string standardOutput, string standardError);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsSuccess();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TimeSpan get_ExecutionTime();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_StandardOutput();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_StandardError();
    public string get_AllInformation();
    public bool get_HasNonEmptyErrorMessage();
    public static DotNetCliCommandResult Success(TimeSpan time, string standardOutput);
    public static DotNetCliCommandResult Failure(TimeSpan time, string standardError, string standardOutput);
    [PublicAPIAttribute]
public BuildResult ToBuildResult(GenerateResult generateResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliExecutor : object {
    [CompilerGeneratedAttribute]
private string <CustomDotNetCliPath>k__BackingField;
    private string CustomDotNetCliPath { get; }
    public DotNetCliExecutor(string customDotNetCliPath);
    [CompilerGeneratedAttribute]
private string get_CustomDotNetCliPath();
    public sealed virtual ExecuteResult Execute(ExecuteParameters executeParameters);
    private ExecuteResult Execute(BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, ILogger logger, ArtifactsPaths artifactsPaths, IDiagnoser diagnoser, string executableName, IResolver resolver, int launchIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public abstract class BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliGenerator : GeneratorBase {
    private static String[] ProjectExtensions;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CliPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNetCore>k__BackingField;
    [PublicAPIAttribute]
public string TargetFrameworkMoniker { get; }
    [PublicAPIAttribute]
public string CliPath { get; }
    [PublicAPIAttribute]
public string PackagesPath { get; }
    protected bool IsNetCore { get; }
    [PublicAPIAttribute]
protected DotNetCliGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, bool isNetCore);
    private static DotNetCliGenerator();
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
public string get_CliPath();
    [CompilerGeneratedAttribute]
public string get_PackagesPath();
    [CompilerGeneratedAttribute]
protected bool get_IsNetCore();
    protected virtual string GetExecutableExtension();
    protected virtual string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName);
    internal static bool GetSolutionRootDirectory(DirectoryInfo& directoryInfo);
    internal static bool GetProjectRootDirectory(DirectoryInfo& directoryInfo);
    internal static bool GetRootDirectory(Func`2<DirectoryInfo, bool> condition, DirectoryInfo& directoryInfo);
    protected virtual String[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths);
    protected virtual void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths);
    protected virtual string GetPackagesDirectoryPath(string buildArtifactsDirectoryPath);
    protected virtual void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths);
    private static bool IsRootSolutionFolder(DirectoryInfo directoryInfo);
    private static bool IsRootProjectFolder(DirectoryInfo directoryInfo);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliPublisher : object {
    [CompilerGeneratedAttribute]
private string <CustomDotNetCliPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtraArguments>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<EnvironmentVariable> <EnvironmentVariables>k__BackingField;
    private string CustomDotNetCliPath { get; }
    private string ExtraArguments { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<EnvironmentVariable> EnvironmentVariables { get; }
    public DotNetCliPublisher(string customDotNetCliPath, string extraArguments, IReadOnlyList`1<EnvironmentVariable> environmentVariables);
    [CompilerGeneratedAttribute]
private string get_CustomDotNetCliPath();
    [CompilerGeneratedAttribute]
private string get_ExtraArguments();
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EnvironmentVariable> get_EnvironmentVariables();
    [NullableContextAttribute("1")]
public sealed virtual BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Toolchains.DotNetCli.MsBuildErrorMapper : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2[] Rules;
    private static MsBuildErrorMapper();
    internal static bool TryToExplainFailureReason(BuildResult buildResult, String& reason);
    private static string Map(Capture capture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings : object {
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp20;
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp21;
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp22;
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp30;
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp31;
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp50;
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp60;
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp70;
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp80;
    [PublicAPIAttribute]
public static NetCoreAppSettings NetCoreApp90;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <RuntimeFrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CustomDotNetCliPath>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <PackagesPath>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CustomRuntimePack>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <AOTCompilerPath>k__BackingField;
    [CompilerGeneratedAttribute]
private MonoAotCompilerMode <AOTCompilerMode>k__BackingField;
    public string TargetFrameworkMoniker { get; }
    [NullableAttribute("2")]
public string RuntimeFrameworkVersion { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string CustomDotNetCliPath { get; }
    [NullableAttribute("2")]
public string PackagesPath { get; }
    [NullableAttribute("2")]
public string CustomRuntimePack { get; }
    [NullableAttribute("2")]
public string AOTCompilerPath { get; }
    public MonoAotCompilerMode AOTCompilerMode { get; }
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public NetCoreAppSettings(string targetFrameworkMoniker, string runtimeFrameworkVersion, string name, string customDotNetCliPath, string packagesPath, string customRuntimePack, string aotCompilerPath, MonoAotCompilerMode aotCompilerMode);
    private static NetCoreAppSettings();
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMoniker();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_RuntimeFrameworkVersion();
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_CustomDotNetCliPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_PackagesPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_CustomRuntimePack();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_AOTCompilerPath();
    [CompilerGeneratedAttribute]
public MonoAotCompilerMode get_AOTCompilerMode();
    public NetCoreAppSettings WithCustomDotNetCliPath(string customDotNetCliPath, string displayName);
    public NetCoreAppSettings WithCustomPackagesRestorePath(string packagesPath, string displayName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute("Used by some of our Superusers that implement their own Toolchains (e.g. Kestrel team)")]
public class BenchmarkDotNet.Toolchains.Executor : object {
    public sealed virtual ExecuteResult Execute(ExecuteParameters executeParameters);
    private static ExecuteResult Execute(BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, ILogger logger, ArtifactsPaths artifactsPaths, IDiagnoser diagnoser, IResolver resolver, int launchIndex);
    private static ExecuteResult Execute(Process process, BenchmarkCase benchmarkCase, Broker broker, ILogger logger, ConsoleExitHandler consoleExitHandler, int launchIndex, AsyncProcessOutputReader processOutputReader);
    private static ProcessStartInfo CreateStartInfo(BenchmarkCase benchmarkCase, ArtifactsPaths artifactsPaths, string args, IResolver resolver);
    private static string GetMonoArguments(Job job, string exePath, string args, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public abstract class BenchmarkDotNet.Toolchains.GeneratorBase : object {
    public sealed virtual GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath);
    [PublicAPIAttribute]
protected abstract virtual string GetBuildArtifactsDirectoryPath(BuildPartition assemblyLocation, string programName);
    [PublicAPIAttribute]
protected virtual string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration);
    [PublicAPIAttribute]
protected virtual string GetIntermediateDirectoryPath(string buildArtifactsDirectoryPath, string configuration);
    [PublicAPIAttribute]
protected virtual string GetExecutableExtension();
    [PublicAPIAttribute]
protected virtual string GetProjectFilePath(string buildArtifactsDirectoryPath);
    [PublicAPIAttribute]
protected abstract virtual String[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths);
    [PublicAPIAttribute]
protected virtual void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths);
    [PublicAPIAttribute]
protected virtual void GenerateNuGetConfig(ArtifactsPaths artifactsPaths);
    [PublicAPIAttribute]
protected virtual void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger);
    [PublicAPIAttribute]
protected abstract virtual void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths);
    [PublicAPIAttribute]
protected virtual string GetPackagesDirectoryPath(string buildArtifactsDirectoryPath);
    [PublicAPIAttribute]
protected virtual void GenerateAppConfig(BuildPartition buildPartition, ArtifactsPaths artifactsPaths);
    [PublicAPIAttribute]
protected virtual void GenerateCode(BuildPartition buildPartition, ArtifactsPaths artifactsPaths);
    protected virtual string GetExecutablePath(string binariesDirectoryPath, string programName);
    private ArtifactsPaths GetArtifactsPaths(BuildPartition buildPartition, string rootArtifactsFolderPath);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Toolchains.IBuilder {
    public abstract virtual BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Toolchains.IExecutor {
    public abstract virtual ExecuteResult Execute(ExecuteParameters executeParameters);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Toolchains.IGenerator {
    public abstract virtual GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.ByRefConsumeEmitter : ConsumeEmitter {
    private FieldBuilder workloadDefaultValueHolderField;
    private MethodInfo overheadKeepAliveWithoutBoxingMethod;
    private MethodInfo workloadKeepAliveWithoutBoxingMethod;
    private LocalBuilder resultLocal;
    public ByRefConsumeEmitter(ConsumableTypeInfo consumableTypeInfo);
    protected virtual void OnDefineFieldsOverride(TypeBuilder runnableBuilder);
    protected virtual void EmitDisassemblyDiagnoserReturnDefaultOverride(ILGenerator ilBuilder);
    protected virtual void OnEmitMembersOverride(TypeBuilder runnableBuilder);
    protected virtual void DeclareActionLocalsOverride(ILGenerator ilBuilder);
    protected virtual void EmitActionBeforeLoopOverride(ILGenerator ilBuilder);
    protected virtual void EmitActionBeforeCallOverride(ILGenerator ilBuilder);
    protected virtual void EmitActionAfterCallOverride(ILGenerator ilBuilder);
    protected virtual void EmitActionAfterLoopOverride(ILGenerator ilBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.ConsumableConsumeEmitter : ConsumeEmitter {
    private FieldBuilder consumerField;
    private LocalBuilder disassemblyDiagnoserLocal;
    public ConsumableConsumeEmitter(ConsumableTypeInfo consumableTypeInfo);
    private static MethodInfo GetConsumeMethod(Type consumableType);
    protected virtual void OnDefineFieldsOverride(TypeBuilder runnableBuilder);
    protected virtual void DeclareDisassemblyDiagnoserLocalsOverride(ILGenerator ilBuilder);
    protected virtual void EmitDisassemblyDiagnoserReturnDefaultOverride(ILGenerator ilBuilder);
    protected virtual void OnEmitCtorBodyOverride(ConstructorBuilder constructorBuilder, ILGenerator ilBuilder);
    protected virtual void EmitActionBeforeCallOverride(ILGenerator ilBuilder);
    protected virtual void EmitActionAfterCallOverride(ILGenerator ilBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.ConsumableTypeInfo : object {
    [CompilerGeneratedAttribute]
private Type <OriginMethodReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <WorkloadMethodReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <OverheadMethodReturnType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MethodInfo <GetResultMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVoid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsByRef>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConsumable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FieldInfo <WorkloadConsumableField>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAwaitable>k__BackingField;
    public Type OriginMethodReturnType { get; }
    public Type WorkloadMethodReturnType { get; }
    public Type OverheadMethodReturnType { get; }
    [NullableAttribute("2")]
public MethodInfo GetResultMethod { get; }
    public bool IsVoid { get; }
    public bool IsByRef { get; }
    public bool IsConsumable { get; }
    [NullableAttribute("2")]
public FieldInfo WorkloadConsumableField { get; }
    public bool IsAwaitable { get; }
    public ConsumableTypeInfo(Type methodReturnType);
    [CompilerGeneratedAttribute]
public Type get_OriginMethodReturnType();
    [CompilerGeneratedAttribute]
public Type get_WorkloadMethodReturnType();
    [CompilerGeneratedAttribute]
public Type get_OverheadMethodReturnType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MethodInfo get_GetResultMethod();
    [CompilerGeneratedAttribute]
public bool get_IsVoid();
    [CompilerGeneratedAttribute]
public bool get_IsByRef();
    [CompilerGeneratedAttribute]
public bool get_IsConsumable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public FieldInfo get_WorkloadConsumableField();
    [CompilerGeneratedAttribute]
public bool get_IsAwaitable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.ConsumeEmitter : object {
    [CompilerGeneratedAttribute]
private ConsumableTypeInfo <ConsumableInfo>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILGenerator <IlBuilder>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MethodBuilder <ActionMethodBuilder>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MethodInfo <ActionInvokeMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RunnableActionKind> <ActionKind>k__BackingField;
    protected ConsumableTypeInfo ConsumableInfo { get; }
    [NullableAttribute("2")]
protected ILGenerator IlBuilder { get; private set; }
    [NullableAttribute("2")]
protected MethodBuilder ActionMethodBuilder { get; private set; }
    [NullableAttribute("2")]
protected MethodInfo ActionInvokeMethod { get; private set; }
    protected Nullable`1<RunnableActionKind> ActionKind { get; private set; }
    protected ConsumeEmitter(ConsumableTypeInfo consumableTypeInfo);
    public static ConsumeEmitter GetConsumeEmitter(ConsumableTypeInfo consumableTypeInfo);
    [CompilerGeneratedAttribute]
protected ConsumableTypeInfo get_ConsumableInfo();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected ILGenerator get_IlBuilder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_IlBuilder(ILGenerator value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected MethodBuilder get_ActionMethodBuilder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ActionMethodBuilder(MethodBuilder value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected MethodInfo get_ActionInvokeMethod();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ActionInvokeMethod(MethodInfo value);
    [CompilerGeneratedAttribute]
protected Nullable`1<RunnableActionKind> get_ActionKind();
    [CompilerGeneratedAttribute]
private void set_ActionKind(Nullable`1<RunnableActionKind> value);
    [AssertionMethodAttribute]
private void AssertNoBuilder();
    [AssertionMethodAttribute]
private void AssertHasBuilder(ILGenerator ilBuilder);
    public void OnDefineFields(TypeBuilder runnableBuilder);
    protected virtual void OnDefineFieldsOverride(TypeBuilder runnableBuilder);
    public void OnEmitMembers(TypeBuilder runnableBuilder);
    protected virtual void OnEmitMembersOverride(TypeBuilder runnableBuilder);
    public void OnEmitCtorBody(ConstructorBuilder constructorBuilder, ILGenerator ilBuilder);
    protected virtual void OnEmitCtorBodyOverride(ConstructorBuilder constructorBuilder, ILGenerator ilBuilder);
    public void DeclareDisassemblyDiagnoserLocals(ILGenerator ilBuilder);
    protected virtual void DeclareDisassemblyDiagnoserLocalsOverride(ILGenerator ilBuilder);
    public void EmitDisassemblyDiagnoserReturnDefault(ILGenerator ilBuilder);
    protected virtual void EmitDisassemblyDiagnoserReturnDefaultOverride(ILGenerator ilBuilder);
    public void BeginEmitAction(MethodBuilder actionMethodBuilder, ILGenerator ilBuilder, MethodInfo actionInvokeMethod, RunnableActionKind actionKind);
    protected virtual void BeginEmitActionOverride(ILGenerator ilBuilder);
    public void CompleteEmitAction(ILGenerator ilBuilder);
    protected virtual void CompleteEmitActionOverride(ILGenerator ilBuilder);
    public void DeclareActionLocals(ILGenerator ilBuilder);
    protected virtual void DeclareActionLocalsOverride(ILGenerator ilBuilder);
    public void EmitActionBeforeLoop(ILGenerator ilBuilder);
    protected virtual void EmitActionBeforeLoopOverride(ILGenerator ilBuilder);
    public void EmitActionAfterLoop(ILGenerator ilBuilder);
    protected virtual void EmitActionAfterLoopOverride(ILGenerator ilBuilder);
    public void EmitActionBeforeCall(ILGenerator ilBuilder);
    protected virtual void EmitActionBeforeCallOverride(ILGenerator ilBuilder);
    public void EmitActionAfterCall(ILGenerator ilBuilder);
    protected virtual void EmitActionAfterCallOverride(ILGenerator ilBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.EmitExtensions : object {
    [ExtensionAttribute]
internal static void Save(AssemblyBuilder assemblyBuilder, string assemblyFileName);
    [ExtensionAttribute]
internal static ModuleBuilder DefineDynamicModule(AssemblyBuilder assemblyBuilder, string moduleName, string moduleFileName);
    [ExtensionAttribute]
internal static AssemblyBuilder DefineDynamicAssembly(AppDomain domain, AssemblyName assemblyName, AssemblyBuilderAccess assemblyMode, string assemblyDirectory);
    private static object ExecuteMethodUsingReflection(T instance, string methodName, Object[] arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.NonConsumableConsumeEmitter : ConsumeEmitter {
    private MethodInfo overheadKeepAliveWithoutBoxingMethod;
    private MethodInfo nonGenericKeepAliveWithoutBoxingMethod;
    private LocalBuilder resultLocal;
    private LocalBuilder disassemblyDiagnoserLocal;
    public NonConsumableConsumeEmitter(ConsumableTypeInfo consumableTypeInfo);
    protected virtual void OnEmitMembersOverride(TypeBuilder runnableBuilder);
    protected virtual void DeclareDisassemblyDiagnoserLocalsOverride(ILGenerator ilBuilder);
    protected virtual void EmitDisassemblyDiagnoserReturnDefaultOverride(ILGenerator ilBuilder);
    private MethodBuilder EmitNonGenericKeepAliveWithoutBoxing(string methodName, TypeBuilder runnableBuilder);
    protected virtual void DeclareActionLocalsOverride(ILGenerator ilBuilder);
    protected virtual void EmitActionBeforeLoopOverride(ILGenerator ilBuilder);
    protected virtual void EmitActionAfterCallOverride(ILGenerator ilBuilder);
    protected virtual void EmitActionAfterLoopOverride(ILGenerator ilBuilder);
}
public enum BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableActionKind : Enum {
    public int value__;
    public static RunnableActionKind Overhead;
    public static RunnableActionKind Workload;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableConstants : object {
    public static string IsByRefLikeAttributeTypeName;
    public static string OpImplicitMethodName;
    public static string DynamicAssemblySuffix;
    public static string EmittedTypePrefix;
    public static string WorkloadDelegateTypeSuffix;
    public static string OverheadDelegateTypeSuffix;
    public static string ArgFieldPrefix;
    public static string ArgParamPrefix;
    public static string GlobalSetupActionFieldName;
    public static string GlobalCleanupActionFieldName;
    public static string IterationSetupActionFieldName;
    public static string IterationCleanupActionFieldName;
    public static string WorkloadDelegateFieldName;
    public static string OverheadDelegateFieldName;
    public static string NotElevenFieldName;
    public static string DummyVarFieldName;
    public static string TrickTheJitCoreMethodName;
    public static string Dummy1MethodName;
    public static string Dummy2MethodName;
    public static string Dummy3MethodName;
    public static string WorkloadImplementationMethodName;
    public static string OverheadImplementationMethodName;
    public static string OverheadActionUnrollMethodName;
    public static string OverheadActionNoUnrollMethodName;
    public static string WorkloadActionUnrollMethodName;
    public static string WorkloadActionNoUnrollMethodName;
    public static string ForDisassemblyDiagnoserMethodName;
    public static string InvokeCountParamName;
    public static string ConsumerFieldName;
    public static string NonGenericKeepAliveWithoutBoxingMethodName;
    public static string DummyParamName;
    public static string WorkloadDefaultValueHolderFieldName;
    public static string GlobalSetupMethodName;
    public static string GlobalCleanupMethodName;
    public static string IterationSetupMethodName;
    public static string IterationCleanupMethodName;
    public static string RunMethodName;
    public static int DummyUnrollFactor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableEmitter : object {
    private BuildPartition buildPartition;
    private ModuleBuilder moduleBuilder;
    private BenchmarkBuildInfo benchmark;
    private List`1<ArgFieldInfo> argFields;
    private int jobUnrollFactor;
    private int dummyUnrollFactor;
    private Type overheadDelegateType;
    private Type workloadDelegateType;
    private TypeBuilder runnableBuilder;
    private ConsumableTypeInfo consumableInfo;
    private ConsumeEmitter consumeEmitter;
    private FieldBuilder globalSetupActionField;
    private FieldBuilder globalCleanupActionField;
    private FieldBuilder iterationSetupActionField;
    private FieldBuilder iterationCleanupActionField;
    private FieldBuilder overheadDelegateField;
    private FieldBuilder workloadDelegateField;
    private FieldBuilder notElevenField;
    private FieldBuilder dummyVarField;
    private ConstructorBuilder ctorMethod;
    private MethodBuilder trickTheJitMethod;
    private MethodBuilder dummy1Method;
    private MethodBuilder dummy2Method;
    private MethodBuilder dummy3Method;
    private MethodInfo workloadImplementationMethod;
    private MethodBuilder overheadImplementationMethod;
    private MethodBuilder overheadActionUnrollMethod;
    private MethodBuilder overheadActionNoUnrollMethod;
    private MethodBuilder workloadActionUnrollMethod;
    private MethodBuilder workloadActionNoUnrollMethod;
    private MethodBuilder forDisassemblyDiagnoserMethod;
    private MethodBuilder globalSetupMethod;
    private MethodBuilder globalCleanupMethod;
    private MethodBuilder iterationSetupMethod;
    private MethodBuilder iterationCleanupMethod;
    private MethodBuilder runMethod;
    private Descriptor Descriptor { get; }
    private RunnableEmitter(BuildPartition buildPartition, ModuleBuilder moduleBuilder);
    public static Assembly EmitPartitionAssembly(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
    private static bool ShouldSaveToDisk(IConfig config);
    private static string GetRunnableTypeName(BenchmarkBuildInfo benchmark);
    private static AssemblyBuilder DefineAssemblyBuilder(string assemblyResultPath, bool saveToDisk);
    private static void DefineAssemblyAttributes(AssemblyBuilder assemblyBuilder);
    private static ModuleBuilder DefineModuleBuilder(AssemblyBuilder assemblyBuilder, string moduleFileName, bool saveToDisk);
    private static TypeBuilder DefineRunnableTypeBuilder(BenchmarkBuildInfo benchmark, ModuleBuilder moduleBuilder);
    private static void EmitNoArgsMethodCallPopReturn(MethodBuilder methodBuilder, MethodInfo targetMethod, ILGenerator ilBuilder, bool forceDirectCall);
    private Descriptor get_Descriptor();
    private Type EmitRunnableCore(BenchmarkBuildInfo newBenchmark);
    private void InitForEmitRunnable(BenchmarkBuildInfo newBenchmark);
    private Type EmitOverheadDelegateType();
    private Type EmitWorkloadDelegateType();
    private void DefineFields();
    private ConstructorBuilder DefineCtor();
    private MethodBuilder DefineTrickTheJitMethod();
    private MethodBuilder EmitDummyMethod(string methodName, int unrollFactor);
    private MethodBuilder EmitOverheadImplementation(string methodName);
    private MethodInfo EmitWorkloadImplementation(string methodName);
    private MethodBuilder EmitOverheadAction(string methodName, int unrollFactor);
    private MethodBuilder EmitWorkloadAction(string methodName, int unrollFactor);
    private MethodBuilder EmitActionImpl(string methodName, RunnableActionKind actionKind, int unrollFactor);
    private IReadOnlyList`1<LocalBuilder> EmitDeclareArgLocals(ILGenerator ilBuilder, bool skipFirst);
    private void EmitLoadArgFieldsToLocals(ILGenerator ilBuilder, IReadOnlyList`1<LocalBuilder> argLocals, bool skipFirstArg);
    private MethodBuilder EmitForDisassemblyDiagnoser(string methodName);
    private void EmitSetupCleanupMethods();
    private MethodBuilder EmitWrapperMethod(string methodName, MethodInfo optionalTargetMethod);
    private void EmitCtorBody();
    private void EmitTrickTheJitBody();
    private MethodBuilder EmitRunMethod();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableProgram : object {
    public static int Run(BenchmarkId benchmarkId, Assembly partitionAssembly, BenchmarkCase benchmarkCase, IHost host);
    private static MethodInfo GetRunCallback(BenchmarkId benchmarkId, Assembly partitionAssembly);
    private static string GetRunnableTypeName(BenchmarkId benchmarkId);
    private static void DumpOutOfMemory(IHost host, Exception oom);
    private static void DumpError(IHost host, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableReflectionHelpers : object {
    public static BindingFlags BindingFlagsNonPublicInstance;
    public static BindingFlags BindingFlagsPublicInstance;
    public static BindingFlags BindingFlagsPublicStatic;
    public static BindingFlags BindingFlagsAllStatic;
    public static BindingFlags BindingFlagsAllInstance;
    private static object TryChangeType(object value, Type targetType);
    public static bool IsRefLikeType(Type t);
    public static MethodInfo GetImplicitConversionOpFromTo(Type from, Type to);
    private static MethodInfo GetImplicitConversionOpCore(Type owner, Type from, Type to);
    public static void SetArgumentField(T instance, BenchmarkCase benchmarkCase, ParameterInfo argInfo, int argIndex);
    public static void SetParameter(T instance, ParameterInstance paramInfo);
    public static Action CallbackFromField(T instance, string memberName);
    public static Action CallbackFromMethod(T instance, string memberName);
    public static Action`1<long> LoopCallbackFromMethod(T instance, string memberName);
    private static TResult GetFieldValueCore(T instance, string memberName);
    private static TDelegate GetDelegateCore(T instance, string memberName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableReuse : object {
    public static ValueTuple`3<Job, EngineParameters, IEngineFactory> PrepareForRun(T instance, BenchmarkCase benchmarkCase, IHost host);
    public static void FillObjectMembers(T instance, BenchmarkCase benchmarkCase);
    private static void DumpEnvironment(IHost host);
    private static Job CreateJob(BenchmarkCase benchmarkCase);
    private static void DumpJob(IHost host, Job job);
    private static IEngineFactory GetEngineFactory(BenchmarkCase benchmarkCase);
    private static EngineParameters CreateEngineParameters(T instance, BenchmarkCase benchmarkCase, IHost host);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.VoidConsumeEmitter : ConsumeEmitter {
    public VoidConsumeEmitter(ConsumableTypeInfo consumableTypeInfo);
    protected virtual void EmitDisassemblyDiagnoserReturnDefaultOverride(ILGenerator ilBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitArtifactsPath : ArtifactsPaths {
    [CompilerGeneratedAttribute]
private Assembly <GeneratedAssembly>k__BackingField;
    public Assembly GeneratedAssembly { get; }
    public InProcessEmitArtifactsPath(Assembly generatedAssembly, ArtifactsPaths baseArtifacts);
    [CompilerGeneratedAttribute]
public Assembly get_GeneratedAssembly();
}
public class BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitBuilder : object {
    [NullableContextAttribute("1")]
public sealed virtual BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor : object {
    private static TimeSpan UnderDebuggerTimeout;
    private static TimeSpan UnderProfilerTimeout;
    public static TimeSpan DefaultTimeout;
    [CompilerGeneratedAttribute]
private TimeSpan <ExecutionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogOutput>k__BackingField;
    public TimeSpan ExecutionTimeout { get; }
    public bool LogOutput { get; }
    public InProcessEmitExecutor(TimeSpan timeout, bool logOutput);
    private static InProcessEmitExecutor();
    [CompilerGeneratedAttribute]
public TimeSpan get_ExecutionTimeout();
    [CompilerGeneratedAttribute]
public bool get_LogOutput();
    public sealed virtual ExecuteResult Execute(ExecuteParameters executeParameters);
    private TimeSpan GetTimeout(ExecuteParameters executeParameters);
    private int ExecuteCore(IHost host, ExecuteParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitGenerator : object {
    public sealed virtual GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath);
    private string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath);
    private string GetExecutableExtension();
    private string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition);
    private ArtifactsPaths GetArtifactsPaths(BuildPartition buildPartition, string rootArtifactsFolderPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain : Toolchain {
    public static IToolchain Instance;
    public static IToolchain DontLogOutput;
    public bool IsInProcess { get; }
    public InProcessEmitToolchain(bool logOutput);
    public InProcessEmitToolchain(TimeSpan timeout, bool logOutput);
    private static InProcessEmitToolchain();
    public virtual bool get_IsInProcess();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.InProcess.InProcessHost : object {
    private ILogger logger;
    [NullableAttribute("2")]
private IDiagnoser diagnoser;
    [NullableAttribute("2")]
private DiagnoserActionParameters diagnoserActionParameters;
    [CompilerGeneratedAttribute]
private bool <IsDiagnoserAttached>k__BackingField;
    [CompilerGeneratedAttribute]
private RunResults <RunResults>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfig <Config>k__BackingField;
    [PublicAPIAttribute]
public bool IsDiagnoserAttached { get; }
    public RunResults RunResults { get; private set; }
    [PublicAPIAttribute]
public IConfig Config { get; public set; }
    public InProcessHost(BenchmarkCase benchmarkCase, ILogger logger, IDiagnoser diagnoser);
    [CompilerGeneratedAttribute]
public bool get_IsDiagnoserAttached();
    [CompilerGeneratedAttribute]
public RunResults get_RunResults();
    [CompilerGeneratedAttribute]
private void set_RunResults(RunResults value);
    [CompilerGeneratedAttribute]
public IConfig get_Config();
    [CompilerGeneratedAttribute]
public void set_Config(IConfig value);
    public sealed virtual void Write(string message);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(string message);
    public sealed virtual void SendSignal(HostSignal hostSignal);
    public sealed virtual void SendError(string message);
    public sealed virtual void ReportResults(RunResults runResults);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.InProcess.InProcessValidator : object {
    private static IReadOnlyDictionary`2<Characteristic, Func`3<Job, Characteristic, string>> ValidationRules;
    public static IValidator DontFailOnError;
    public static IValidator FailOnError;
    [CompilerGeneratedAttribute]
private bool <TreatsWarningsAsErrors>k__BackingField;
    public bool TreatsWarningsAsErrors { get; }
    private InProcessValidator(bool failOnErrors);
    private static InProcessValidator();
    private static string DontValidate(Job job, Characteristic characteristic);
    private static string ValidateEnvironment(Job job, Characteristic characteristic);
    private static string ValidatePlatform(Job job, Characteristic characteristic);
    private static string ValidateToolchain(Job job, Characteristic characteristic);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.InProcess.InProcessValidator/<Validate>d__7")]
public static IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.InProcess.InProcessValidator/<ValidateJob>d__8")]
private static IEnumerable`1<ValidationError> ValidateJob(Job job, bool isCritical);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatsWarningsAsErrors();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.InProcess.InProcessValidator/<Validate>d__13")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ValidationError> <Validate>b__13_3(Job job);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public abstract class BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction : object {
    [CompilerGeneratedAttribute]
private Action <InvokeSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<long> <InvokeUnroll>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<long> <InvokeNoUnroll>k__BackingField;
    public Action InvokeSingle { get; protected set; }
    public Action`1<long> InvokeUnroll { get; protected set; }
    public Action`1<long> InvokeNoUnroll { get; protected set; }
    public object LastRunResult { get; }
    [CompilerGeneratedAttribute]
public Action get_InvokeSingle();
    [CompilerGeneratedAttribute]
protected void set_InvokeSingle(Action value);
    [CompilerGeneratedAttribute]
public Action`1<long> get_InvokeUnroll();
    [CompilerGeneratedAttribute]
protected void set_InvokeUnroll(Action`1<long> value);
    [CompilerGeneratedAttribute]
public Action`1<long> get_InvokeNoUnroll();
    [CompilerGeneratedAttribute]
protected void set_InvokeNoUnroll(Action`1<long> value);
    public virtual object get_LastRunResult();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory : object {
    private static MethodInfo FallbackSignature;
    private static MethodInfo DummyMethod;
    private static BenchmarkActionFactory();
    private static BenchmarkAction CreateCore(object instance, MethodInfo targetMethod, MethodInfo fallbackIdleSignature, int unrollFactor);
    private static void PrepareInstanceAndResultType(object instance, MethodInfo targetMethod, MethodInfo fallbackIdleSignature, Object& resultInstance, Type& resultType);
    private static BenchmarkActionBase Create(Type actionType, object instance, MethodInfo method, int unrollFactor);
    private static void FallbackMethod();
    public static BenchmarkAction CreateWorkload(Descriptor descriptor, object instance, int unrollFactor);
    public static BenchmarkAction CreateOverhead(Descriptor descriptor, object instance, int unrollFactor);
    public static BenchmarkAction CreateGlobalSetup(Descriptor descriptor, object instance);
    public static BenchmarkAction CreateGlobalCleanup(Descriptor descriptor, object instance);
    public static BenchmarkAction CreateIterationSetup(Descriptor descriptor, object instance);
    public static BenchmarkAction CreateIterationCleanup(Descriptor descriptor, object instance);
    public static BenchmarkAction CreateDummy();
}
public class BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitBuilder : object {
    [NullableContextAttribute("1")]
public sealed virtual BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor : object {
    private static TimeSpan UnderDebuggerTimeout;
    public static TimeSpan DefaultTimeout;
    [CompilerGeneratedAttribute]
private TimeSpan <ExecutionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogOutput>k__BackingField;
    public TimeSpan ExecutionTimeout { get; }
    public bool LogOutput { get; }
    public InProcessNoEmitExecutor(TimeSpan timeout, bool logOutput);
    private static InProcessNoEmitExecutor();
    [CompilerGeneratedAttribute]
public TimeSpan get_ExecutionTimeout();
    [CompilerGeneratedAttribute]
public bool get_LogOutput();
    [NullableContextAttribute("1")]
public sealed virtual ExecuteResult Execute(ExecuteParameters executeParameters);
    [NullableContextAttribute("1")]
private int ExecuteCore(IHost host, ExecuteParameters parameters);
}
public class BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitGenerator : object {
    [NullableContextAttribute("1")]
public sealed virtual GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath);
}
internal class BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitRunner : object {
    [NullableContextAttribute("1")]
public static int Run(IHost host, BenchmarkCase benchmarkCase);
    [NullableContextAttribute("1")]
internal static void FillMembers(object instance, BenchmarkCase benchmarkCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain : object {
    public static IToolchain Instance;
    public static IToolchain DontLogOutput;
    [CompilerGeneratedAttribute]
private IGenerator <Generator>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private IExecutor <Executor>k__BackingField;
    public string Name { get; }
    public IGenerator Generator { get; }
    public IBuilder Builder { get; }
    public IExecutor Executor { get; }
    public bool IsInProcess { get; }
    public InProcessNoEmitToolchain(bool logOutput);
    public InProcessNoEmitToolchain(TimeSpan timeout, bool logOutput);
    private static InProcessNoEmitToolchain();
    public sealed virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IGenerator get_Generator();
    [CompilerGeneratedAttribute]
public sealed virtual IBuilder get_Builder();
    [CompilerGeneratedAttribute]
public sealed virtual IExecutor get_Executor();
    public sealed virtual bool get_IsInProcess();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Toolchains.IToolchain {
    [PublicAPIAttribute]
public string Name { get; }
    public IGenerator Generator { get; }
    public IBuilder Builder { get; }
    public IExecutor Executor { get; }
    public bool IsInProcess { get; }
    public abstract virtual string get_Name();
    public abstract virtual IGenerator get_Generator();
    public abstract virtual IBuilder get_Builder();
    public abstract virtual IExecutor get_Executor();
    public abstract virtual bool get_IsInProcess();
    public abstract virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Toolchains.LargeAddressAware : object {
    public static void SetLargeAddressAware(string filePath);
    private static void PrepareStream(string filePath, Action`2<Stream, BinaryReader> action);
}
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.Mono.MonoAotBuilder : object {
    [NullableContextAttribute("1")]
[PublicAPIAttribute]
public sealed virtual BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.Mono.MonoAotToolchain : Toolchain {
    public static IToolchain Instance;
    private static MonoAotToolchain();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.Mono.MonoAotToolchain/<Validate>d__2")]
public virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationError> <>n__0(BenchmarkCase benchmarkCase, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.Mono.MonoGenerator : CsProjGenerator {
    public MonoGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string runtimeFrameworkVersion);
    protected virtual string GetRuntimeSettings(GcMode gcMode, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.Mono.MonoPublisher : object {
    [CompilerGeneratedAttribute]
private string <CustomDotNetCliPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtraArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EnvironmentVariable> <EnvironmentVariables>k__BackingField;
    private string CustomDotNetCliPath { get; }
    private string ExtraArguments { get; }
    private IReadOnlyList`1<EnvironmentVariable> EnvironmentVariables { get; }
    public MonoPublisher(string customDotNetCliPath);
    [CompilerGeneratedAttribute]
private string get_CustomDotNetCliPath();
    [CompilerGeneratedAttribute]
private string get_ExtraArguments();
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EnvironmentVariable> get_EnvironmentVariables();
    public sealed virtual BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.Mono.MonoToolchain : CsProjCoreToolchain {
    [PublicAPIAttribute]
public static IToolchain Mono60;
    [PublicAPIAttribute]
public static IToolchain Mono70;
    [PublicAPIAttribute]
public static IToolchain Mono80;
    [PublicAPIAttribute]
public static IToolchain Mono90;
    private MonoToolchain(string name, IGenerator generator, IBuilder builder, IExecutor executor, string customDotNetCliPath);
    private static MonoToolchain();
    [PublicAPIAttribute]
public static IToolchain From(NetCoreAppSettings settings);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MonoToolchain other);
    public virtual int GetHashCode();
}
public enum BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotCompilerMode : Enum {
    public int value__;
    public static MonoAotCompilerMode mini;
    public static MonoAotCompilerMode llvm;
    public static MonoAotCompilerMode wasm;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMGenerator : CsProjGenerator {
    private string CustomRuntimePack;
    private string AotCompilerPath;
    private MonoAotCompilerMode AotCompilerMode;
    public MonoAotLLVMGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string customRuntimePack, string aotCompilerPath, MonoAotCompilerMode aotCompilerMode);
    protected virtual void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger);
    protected virtual string GetExecutablePath(string binariesDirectoryPath, string programName);
    protected virtual string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMToolChain : Toolchain {
    private string _customDotNetCliPath;
    public MonoAotLLVMToolChain(string name, IGenerator generator, IBuilder builder, IExecutor executor, string customDotNetCliPath);
    public static IToolchain From(NetCoreAppSettings netCoreAppSettings);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMToolChain/<Validate>d__3")]
public virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationError> <>n__0(BenchmarkCase benchmarkCase, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Toolchains.MonoWasm.WasmExecutor : object {
    public sealed virtual ExecuteResult Execute(ExecuteParameters executeParameters);
    private static ExecuteResult Execute(BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, ILogger logger, ArtifactsPaths artifactsPaths, IDiagnoser diagnoser, IResolver resolver, int launchIndex);
    private static Process CreateProcess(BenchmarkCase benchmarkCase, ArtifactsPaths artifactsPaths, string args, IResolver resolver);
    private static ExecuteResult Execute(Process process, BenchmarkCase benchmarkCase, AsyncProcessOutputReader processOutputReader, ILogger logger, ConsoleExitHandler consoleExitHandler, int launchIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.MonoWasm.WasmGenerator : CsProjGenerator {
    private string CustomRuntimePack;
    private bool Aot;
    private string MainJS;
    public WasmGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string customRuntimePack, bool aot);
    protected virtual void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger);
    protected void GenerateProjectFile(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, bool aot, ILogger logger);
    protected virtual string GetExecutablePath(string binariesDirectoryPath, string programName);
    protected virtual string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.MonoWasm.WasmToolchain : Toolchain {
    [CompilerGeneratedAttribute]
private string <CustomDotNetCliPath>k__BackingField;
    private string CustomDotNetCliPath { get; }
    private WasmToolchain(string name, IGenerator generator, IBuilder builder, IExecutor executor, string customDotNetCliPath);
    [CompilerGeneratedAttribute]
private string get_CustomDotNetCliPath();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.MonoWasm.WasmToolchain/<Validate>d__4")]
public virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
    [PublicAPIAttribute]
public static IToolchain From(NetCoreAppSettings netCoreAppSettings);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationError> <>n__0(BenchmarkCase benchmarkCase, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.NativeAot.Generator : CsProjGenerator {
    internal static string NativeAotNuGetFeed;
    internal static string GeneratedRdXmlFileName;
    internal IReadOnlyDictionary`2<string, string> Feeds;
    private string ilCompilerVersion;
    private string runtimeIdentifier;
    private bool useNuGetClearTag;
    private bool useTempFolderForRestore;
    private bool rootAllApplicationAssemblies;
    private bool ilcGenerateCompleteTypeMetadata;
    private bool ilcGenerateStackTraceData;
    private string ilcOptimizationPreference;
    private string ilcInstructionSet;
    internal Generator(string ilCompilerVersion, string runtimeFrameworkVersion, string targetFrameworkMoniker, string cliPath, string runtimeIdentifier, IReadOnlyDictionary`2<string, string> feeds, bool useNuGetClearTag, bool useTempFolderForRestore, string packagesRestorePath, bool rootAllApplicationAssemblies, bool ilcGenerateCompleteTypeMetadata, bool ilcGenerateStackTraceData, string ilcOptimizationPreference, string ilcInstructionSet);
    protected virtual string GetExecutableExtension();
    protected virtual string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName);
    protected virtual string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration);
    protected virtual void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths);
    private static string GetPackagesDirectoryPath(bool useTempFolderForRestore, string packagesRestorePath);
    protected virtual String[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths);
    protected virtual void GenerateNuGetConfig(ArtifactsPaths artifactsPaths);
    protected virtual void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger);
    private string GenerateProjectForNuGetBuild(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger);
    private string GetILCompilerPackageReference();
    private string GetTrimmingSettings();
    private string GetInstructionSetSettings(BuildPartition buildPartition);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.NativeAot.Generator/<GetRdXmlFiles>d__25")]
public IEnumerable`1<string> GetRdXmlFiles(Type benchmarkTarget, ILogger logger);
    private void GenerateReflectionFile(ArtifactsPaths artifactsPaths);
    private string GetCurrentInstructionSet(Platform platform);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.NativeAot.Generator/<GetCurrentProcessInstructionSets>d__28")]
private IEnumerable`1<string> GetCurrentProcessInstructionSets(Platform platform);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain : Toolchain {
    public static IToolchain Net60;
    public static IToolchain Net70;
    public static IToolchain Net80;
    public static IToolchain Net90;
    [CompilerGeneratedAttribute]
private string <CustomDotNetCliPath>k__BackingField;
    internal string CustomDotNetCliPath { get; }
    internal NativeAotToolchain(string displayName, string ilCompilerVersion, string runtimeFrameworkVersion, string targetFrameworkMoniker, string runtimeIdentifier, string customDotNetCliPath, string packagesRestorePath, Dictionary`2<string, string> feeds, bool useNuGetClearTag, bool useTempFolderForRestore, bool rootAllApplicationAssemblies, bool ilcGenerateCompleteTypeMetadata, bool ilcGenerateStackTraceData, string ilcOptimizationPreference, string ilcInstructionSet);
    private static NativeAotToolchain();
    [CompilerGeneratedAttribute]
internal string get_CustomDotNetCliPath();
    public static NativeAotToolchainBuilder CreateBuilder();
    public static string GetExtraArguments(string runtimeIdentifier);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain/<Validate>d__10")]
public virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationError> <>n__0(BenchmarkCase benchmarkCase, IResolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder : CustomDotNetCliToolchainBuilder {
    private string ilCompilerVersion;
    private string packagesRestorePath;
    private bool rootAllApplicationAssemblies;
    private bool ilcGenerateCompleteTypeMetadata;
    private bool ilcGenerateStackTraceData;
    private string ilcOptimizationPreference;
    [NullableAttribute("2")]
private string ilcInstructionSet;
    private bool isIlCompilerConfigured;
    public static NativeAotToolchainBuilder Create();
    [PublicAPIAttribute]
public NativeAotToolchainBuilder UseNuGet(string microsoftDotNetILCompilerVersion, string nuGetFeedUrl);
    [PublicAPIAttribute]
public NativeAotToolchainBuilder UseLocalBuild(DirectoryInfo ilcPackages);
    [PublicAPIAttribute]
public NativeAotToolchainBuilder PackagesRestorePath(string packagesRestorePath);
    [PublicAPIAttribute]
public NativeAotToolchainBuilder RootAllApplicationAssemblies(bool value);
    [PublicAPIAttribute]
public NativeAotToolchainBuilder IlcGenerateCompleteTypeMetadata(bool value);
    [PublicAPIAttribute]
public NativeAotToolchainBuilder IlcGenerateStackTraceData(bool value);
    [PublicAPIAttribute]
public NativeAotToolchainBuilder IlcOptimizationPreference(string value);
    [PublicAPIAttribute]
public NativeAotToolchainBuilder IlcInstructionSet(string value);
    [PublicAPIAttribute]
public virtual IToolchain ToToolchain();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.Parameters.ExecuteParameters : object {
    internal static TimeSpan ProcessExitTimeout;
    [CompilerGeneratedAttribute]
private BuildResult <BuildResult>k__BackingField;
    [CompilerGeneratedAttribute]
private BenchmarkCase <BenchmarkCase>k__BackingField;
    [CompilerGeneratedAttribute]
private BenchmarkId <BenchmarkId>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IDiagnoser <Diagnoser>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LaunchIndex>k__BackingField;
    public BuildResult BuildResult { get; }
    public BenchmarkCase BenchmarkCase { get; }
    public BenchmarkId BenchmarkId { get; }
    public ILogger Logger { get; }
    public IResolver Resolver { get; }
    public IDiagnoser Diagnoser { get; }
    public int LaunchIndex { get; }
    public ExecuteParameters(BuildResult buildResult, BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, ILogger logger, IResolver resolver, int launchIndex, IDiagnoser diagnoser);
    private static ExecuteParameters();
    [CompilerGeneratedAttribute]
public BuildResult get_BuildResult();
    [CompilerGeneratedAttribute]
public BenchmarkCase get_BenchmarkCase();
    [CompilerGeneratedAttribute]
public BenchmarkId get_BenchmarkId();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public IResolver get_Resolver();
    [CompilerGeneratedAttribute]
public IDiagnoser get_Diagnoser();
    [CompilerGeneratedAttribute]
public int get_LaunchIndex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.Results.BuildResult : GenerateResult {
    [CompilerGeneratedAttribute]
private bool <IsBuildSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public bool IsBuildSuccess { get; }
    public string ErrorMessage { get; }
    private BuildResult(GenerateResult generateResult, bool isBuildSuccess, string errorMessage);
    [CompilerGeneratedAttribute]
public bool get_IsBuildSuccess();
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [PublicAPIAttribute]
public static BuildResult Success(GenerateResult generateResult);
    [PublicAPIAttribute]
public static BuildResult Failure(GenerateResult generateResult, string errorMessage);
    [PublicAPIAttribute]
public static BuildResult Failure(GenerateResult generateResult, Exception exception);
    public virtual string ToString();
    internal bool TryToExplainFailureReason(String& reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.Results.ExecuteResult : object {
    [CompilerGeneratedAttribute]
private bool <FoundExecutable>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <StandardOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PrefixedLines>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Results>k__BackingField;
    internal GcStats GcStats;
    internal ThreadingStats ThreadingStats;
    internal double ExceptionFrequency;
    private List`1<string> errors;
    private List`1<Measurement> measurements;
    public bool FoundExecutable { get; }
    public Nullable`1<int> ExitCode { get; }
    public Nullable`1<int> ProcessId { get; }
    public IReadOnlyList`1<string> Errors { get; }
    public IReadOnlyList`1<Measurement> Measurements { get; }
    public IReadOnlyList`1<string> StandardOutput { get; }
    public IReadOnlyList`1<string> PrefixedLines { get; }
    public IReadOnlyList`1<string> Results { get; }
    public bool IsSuccess { get; }
    public ExecuteResult(bool foundExecutable, Nullable`1<int> exitCode, Nullable`1<int> processId, IReadOnlyList`1<string> results, IReadOnlyList`1<string> prefixedLines, IReadOnlyList`1<string> standardOutput, int launchIndex);
    internal ExecuteResult(List`1<Measurement> measurements, GcStats gcStats, ThreadingStats threadingStats, double exceptionFrequency);
    internal ExecuteResult(List`1<Measurement> measurements);
    [CompilerGeneratedAttribute]
public bool get_FoundExecutable();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ExitCode();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProcessId();
    public IReadOnlyList`1<string> get_Errors();
    public IReadOnlyList`1<Measurement> get_Measurements();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_StandardOutput();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PrefixedLines();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Results();
    public bool get_IsSuccess();
    internal static ExecuteResult FromRunResults(RunResults runResults, int exitCode);
    internal static ExecuteResult CreateFailed(int exitCode);
    internal static ExecuteResult CreateFailed(string error);
    public virtual string ToString();
    public void LogIssues(ILogger logger, BuildResult buildResult);
    private static void Parse(IReadOnlyList`1<string> results, IReadOnlyList`1<string> prefixedLines, int launchIndex, List`1& measurements, List`1& errors, GcStats& gcStats, ThreadingStats& threadingStats, Double& exceptionFrequency);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.Results.GenerateResult : object {
    [CompilerGeneratedAttribute]
private ArtifactsPaths <ArtifactsPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGenerateSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <GenerateException>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <ArtifactsToCleanup>k__BackingField;
    public ArtifactsPaths ArtifactsPaths { get; }
    public bool IsGenerateSuccess { get; }
    public Exception GenerateException { get; }
    public IReadOnlyCollection`1<string> ArtifactsToCleanup { get; }
    public GenerateResult(ArtifactsPaths artifactsPaths, bool isGenerateSuccess, Exception generateException, IReadOnlyCollection`1<string> artifactsToCleanup);
    [CompilerGeneratedAttribute]
public ArtifactsPaths get_ArtifactsPaths();
    [CompilerGeneratedAttribute]
public bool get_IsGenerateSuccess();
    [CompilerGeneratedAttribute]
public Exception get_GenerateException();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_ArtifactsToCleanup();
    public static GenerateResult Success(ArtifactsPaths artifactsPaths, IReadOnlyCollection`1<string> artifactsToCleanup);
    public static GenerateResult Failure(ArtifactsPaths artifactsPaths, IReadOnlyCollection`1<string> artifactsToCleanup, Exception exception);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.Roslyn.Builder : object {
    private static string MissingReferenceError;
    public static IBuilder Instance;
    private static Lazy`1<AssemblyMetadata[]> FrameworkAssembliesMetadata;
    private static Builder();
    [PublicAPIAttribute]
public sealed virtual BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger);
    private BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger, CancellationToken cancellationToken);
    private static ValueTuple`2<BuildResult, AssemblyMetadata[]> Build(GenerateResult generateResult, BuildPartition buildPartition, SyntaxTree syntaxTree, CSharpCompilationOptions compilationOptions, IEnumerable`1<PortableExecutableReference> references, CancellationToken cancellationToken);
    private Platform GetPlatform(Platform platform);
    private static AssemblyMetadata[] GetFrameworkAssembliesMetadata();
    private static String[] GetFrameworkAssembliesPaths();
    private static AssemblyMetadata[] GetMissingReferences(Diagnostic[] compilationErrors);
    private static string GetAssemblyName(Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.Roslyn.Generator : GeneratorBase {
    protected virtual string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName);
    [PublicAPIAttribute]
protected virtual String[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths);
    protected virtual void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths);
    internal static IEnumerable`1<Assembly> GetAllReferences(BenchmarkCase benchmarkCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class BenchmarkDotNet.Toolchains.Roslyn.RoslynToolchain : Toolchain {
    public static IToolchain Instance;
    private static RoslynToolchain();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.Roslyn.RoslynToolchain/<Validate>d__2")]
[PublicAPIAttribute]
public virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationError> <>n__0(BenchmarkCase benchmarkCase, IResolver resolver);
}
[ExtensionAttribute]
internal static class BenchmarkDotNet.Toolchains.Roslyn.RoslynWorkarounds : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static CSharpCompilationOptions WithIgnoreCorLibraryDuplicatedTypes(CSharpCompilationOptions compilationOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Toolchains.Toolchain : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IGenerator <Generator>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private IExecutor <Executor>k__BackingField;
    public string Name { get; }
    public IGenerator Generator { get; }
    public IBuilder Builder { get; }
    public IExecutor Executor { get; }
    public bool IsInProcess { get; }
    public Toolchain(string name, IGenerator generator, IBuilder builder, IExecutor executor);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IGenerator get_Generator();
    [CompilerGeneratedAttribute]
public sealed virtual IBuilder get_Builder();
    [CompilerGeneratedAttribute]
public sealed virtual IExecutor get_Executor();
    public virtual bool get_IsInProcess();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Toolchains.Toolchain/<Validate>d__15")]
public virtual IEnumerable`1<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class BenchmarkDotNet.Toolchains.ToolchainExtensions : object {
    [ExtensionAttribute]
internal static IToolchain GetToolchain(BenchmarkCase benchmarkCase);
    [ExtensionAttribute]
internal static IToolchain GetToolchain(Job job);
    private static IToolchain GetToolchain(Job job, Descriptor descriptor);
    [ExtensionAttribute]
internal static IToolchain GetToolchain(Runtime runtime, Descriptor descriptor, bool preferMsBuildToolchains);
    private static IToolchain GetToolchain(RuntimeMoniker runtimeMoniker);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.BaselineValidator : object {
    public static BaselineValidator FailOnError;
    public bool TreatsWarningsAsErrors { get; }
    private static BaselineValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Validators.BaselineValidator/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters input);
    private ValidationError CreateError(string subject, string property, string groupName, string className, string actual);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.CompilationValidator : object {
    private static char Underscore;
    public static IValidator FailOnError;
    private static ImmutableHashSet`1<string> CsharpKeywords;
    public bool TreatsWarningsAsErrors { get; }
    private static CompilationValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    private static IEnumerable`1<ValidationError> ValidateCSharpNaming(IEnumerable`1<BenchmarkCase> benchmarks);
    private static IEnumerable`1<ValidationError> ValidateNamingConflicts(IEnumerable`1<BenchmarkCase> benchmarks);
    private static IEnumerable`1<ValidationError> ValidateAccessModifiers(IEnumerable`1<BenchmarkCase> benchmarks);
    private static IEnumerable`1<ValidationError> ValidateBindingModifiers(IEnumerable`1<BenchmarkCase> benchmarks);
    private static bool IsValidCSharpIdentifier(string identifier);
    private static bool IsUsingNameUsedInternallyByOurTemplate(string identifier);
    private static bool HasPrivateGenericArguments(Type type);
    private static IEnumerable`1<string> GetCsharpKeywords();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class BenchmarkDotNet.Validators.CompositeValidator : object {
    private ImmutableHashSet`1<IValidator> validators;
    public bool TreatsWarningsAsErrors { get; }
    public CompositeValidator(ImmutableHashSet`1<IValidator> validators);
    public sealed virtual bool get_TreatsWarningsAsErrors();
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
public class BenchmarkDotNet.Validators.ConfigCompatibilityValidator : object {
    [NullableAttribute("1")]
public static ConfigCompatibilityValidator FailOnError;
    public bool TreatsWarningsAsErrors { get; }
    private static ConfigCompatibilityValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("BenchmarkDotNet.Validators.ConfigCompatibilityValidator/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.ConfigValidator : object {
    public static IValidator DontFailOnError;
    public bool TreatsWarningsAsErrors { get; }
    private static ConfigValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Validators.ConfigValidator/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    private static ValidationError ValidateArtifactsPath(string artifactsPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.DeferredExecutionValidator : object {
    public static IValidator DontFailOnError;
    public static IValidator FailOnError;
    [CompilerGeneratedAttribute]
private bool <TreatsWarningsAsErrors>k__BackingField;
    public bool TreatsWarningsAsErrors { get; }
    private DeferredExecutionValidator(bool failOnError);
    private static DeferredExecutionValidator();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatsWarningsAsErrors();
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    private bool IsDeferredExecution(Type returnType);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <Validate>b__6_0(BenchmarkCase benchmark);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValidationError <Validate>b__6_1(BenchmarkCase benchmark);
}
public class BenchmarkDotNet.Validators.DiagnosersValidator : object {
    [NullableAttribute("1")]
public static IValidator Composite;
    public bool TreatsWarningsAsErrors { get; }
    private static DiagnosersValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class BenchmarkDotNet.Validators.DotNetSdkValidator : object {
    private static Lazy`1<List`1<string>> cachedFrameworkSdks;
    private static DotNetSdkValidator();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Validators.DotNetSdkValidator/<ValidateCoreSdks>d__1")]
public static IEnumerable`1<ValidationError> ValidateCoreSdks(string customDotNetCliPath, BenchmarkCase benchmark);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Validators.DotNetSdkValidator/<ValidateFrameworkSdks>d__2")]
public static IEnumerable`1<ValidationError> ValidateFrameworkSdks(BenchmarkCase benchmark);
    public static bool IsCliPathInvalid(string customDotNetCliPath, BenchmarkCase benchmarkCase, ValidationError& validationError);
    private static bool TryGetSdkVersion(BenchmarkCase benchmark, String& sdkVersion);
    private static IEnumerable`1<string> GetInstalledDotNetSdks(string customDotNetCliPath);
    public static List`1<string> GetInstalledFrameworkSdks();
    private static void Get45PlusFromRegistry(List`1<string> versions);
    private static string CheckFor45PlusVersion(int releaseKey);
    private static string GetSdkVersionFromMoniker(RuntimeMoniker runtimeMoniker);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.ExecutionValidator : ExecutionValidatorBase {
    public static ExecutionValidator DontFailOnError;
    public static ExecutionValidator FailOnError;
    private ExecutionValidator(bool failOnError);
    private static ExecutionValidator();
    protected virtual void ExecuteBenchmarks(object benchmarkTypeInstance, IEnumerable`1<BenchmarkCase> benchmarks, List`1<ValidationError> errors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class BenchmarkDotNet.Validators.ExecutionValidatorBase : object {
    [CompilerGeneratedAttribute]
private bool <TreatsWarningsAsErrors>k__BackingField;
    public bool TreatsWarningsAsErrors { get; }
    protected ExecutionValidatorBase(bool failOnError);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatsWarningsAsErrors();
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    private bool TryCreateBenchmarkTypeInstance(Type type, List`1<ValidationError> errors, Object& instance);
    private bool TryToCallGlobalSetup(object benchmarkTypeInstance, List`1<ValidationError> errors);
    private void TryToCallGlobalCleanup(object benchmarkTypeInstance, List`1<ValidationError> errors);
    private bool TryToCallGlobalMethod(object benchmarkTypeInstance, List`1<ValidationError> errors);
    private string GetAttributeName(Type type);
    private void TryToGetTaskResult(object result);
    private bool TryToSetParamsFields(object benchmarkTypeInstance, List`1<ValidationError> errors);
    private bool TryToSetParamsProperties(object benchmarkTypeInstance, List`1<ValidationError> errors);
    protected static string GetDisplayExceptionMessage(Exception ex);
    protected abstract virtual void ExecuteBenchmarks(object benchmarkTypeInstance, IEnumerable`1<BenchmarkCase> benchmarks, List`1<ValidationError> errors);
}
public class BenchmarkDotNet.Validators.GenericBenchmarksValidator : object {
    [NullableAttribute("1")]
public static IValidator DontFailOnError;
    public bool TreatsWarningsAsErrors { get; }
    private static GenericBenchmarksValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
[NullableContextAttribute("1")]
public interface BenchmarkDotNet.Validators.IValidator {
    public bool TreatsWarningsAsErrors { get; }
    public abstract virtual bool get_TreatsWarningsAsErrors();
    public abstract virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.JitOptimizationsValidator : object {
    public static IValidator DontFailOnError;
    public static IValidator FailOnError;
    [CompilerGeneratedAttribute]
private bool <TreatsWarningsAsErrors>k__BackingField;
    public bool TreatsWarningsAsErrors { get; }
    private JitOptimizationsValidator(bool failOnErrors);
    private static JitOptimizationsValidator();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatsWarningsAsErrors();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Validators.JitOptimizationsValidator/<Validate>d__6")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.ParamsAllValuesValidator : object {
    public static ParamsAllValuesValidator FailOnError;
    private static BindingFlags ReflectionFlags;
    public bool TreatsWarningsAsErrors { get; }
    private static ParamsAllValuesValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters input);
    private bool IsBool(Type paramType);
    private bool IsEnum(Type paramType);
    private bool IsFlagsEnum(Type paramType);
    private bool IsNullable(Type paramType, Type& underlyingType);
    private ValidationError GetErrorOrDefault(Type parameterType);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValidationError <Validate>b__5_2(ValueTuple`4<string, ParamsAllValuesAttribute, bool, Type> member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.ParamsValidator : object {
    public static ParamsValidator FailOnError;
    public bool TreatsWarningsAsErrors { get; }
    private static ParamsValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters input);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Validators.ParamsValidator/<Validate>d__4")]
private IEnumerable`1<ValidationError> Validate(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.ReturnValueValidator : ExecutionValidatorBase {
    [CompilerGeneratedAttribute]
private static ReturnValueValidator <DontFailOnError>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReturnValueValidator <FailOnError>k__BackingField;
    public static ReturnValueValidator DontFailOnError { get; }
    public static ReturnValueValidator FailOnError { get; }
    private ReturnValueValidator(bool failOnError);
    private static ReturnValueValidator();
    [CompilerGeneratedAttribute]
public static ReturnValueValidator get_DontFailOnError();
    [CompilerGeneratedAttribute]
public static ReturnValueValidator get_FailOnError();
    protected virtual void ExecuteBenchmarks(object benchmarkTypeInstance, IEnumerable`1<BenchmarkCase> benchmarks, List`1<ValidationError> errors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.RunModeValidator : object {
    public static IValidator FailOnError;
    public bool TreatsWarningsAsErrors { get; }
    private static RunModeValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    [IteratorStateMachineAttribute("BenchmarkDotNet.Validators.RunModeValidator/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Validators.RunModeValidator/<ValidateMinMax>d__5")]
private static IEnumerable`1<ValidationError> ValidateMinMax(RunMode run, CompositeResolver resolver, BenchmarkCase benchmark, Characteristic`1<int> minCharacteristic, Characteristic`1<int> maxCharacteristic);
    [CompilerGeneratedAttribute]
internal static string <ValidateMinMax>g__GetName|5_0(Characteristic characteristic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.SetupCleanupValidator : object {
    public static SetupCleanupValidator FailOnError;
    public bool TreatsWarningsAsErrors { get; }
    private static SetupCleanupValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters input);
    [IteratorStateMachineAttribute("BenchmarkDotNet.Validators.SetupCleanupValidator/<ValidateAttributes>d__5`1")]
private IEnumerable`1<ValidationError> ValidateAttributes(string benchmarkClassName, IEnumerable`1<MethodInfo> allMethods);
}
public class BenchmarkDotNet.Validators.ShadowCopyValidator : object {
    [NullableAttribute("1")]
public static IValidator DontFailOnError;
    public bool TreatsWarningsAsErrors { get; }
    private static ShadowCopyValidator();
    public sealed virtual bool get_TreatsWarningsAsErrors();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<ValidationError> Validate(ValidationParameters validationParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.ValidationError : object {
    [CompilerGeneratedAttribute]
private bool <IsCritical>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private BenchmarkCase <BenchmarkCase>k__BackingField;
    [PublicAPIAttribute]
public bool IsCritical { get; }
    [PublicAPIAttribute]
public string Message { get; }
    [NullableAttribute("2")]
[PublicAPIAttribute]
public BenchmarkCase BenchmarkCase { get; }
    public ValidationError(bool isCritical, string message, BenchmarkCase benchmarkCase);
    [CompilerGeneratedAttribute]
public bool get_IsCritical();
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public BenchmarkCase get_BenchmarkCase();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ValidationError other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ValidationError left, ValidationError right);
    public static bool op_Inequality(ValidationError left, ValidationError right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class BenchmarkDotNet.Validators.ValidationErrorReporter : object {
    public static string ConsoleErrorPrefix;
    [UsedImplicitlyAttribute]
public static bool ReportIfAny(IEnumerable`1<ValidationError> validationErrors, IHost host);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class BenchmarkDotNet.Validators.ValidationParameters : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<BenchmarkCase> <Benchmarks>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableConfig <Config>k__BackingField;
    public IReadOnlyList`1<BenchmarkCase> Benchmarks { get; }
    public ImmutableConfig Config { get; }
    public ValidationParameters(IReadOnlyList`1<BenchmarkCase> benchmarks, ImmutableConfig config);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<BenchmarkCase> get_Benchmarks();
    [CompilerGeneratedAttribute]
public ImmutableConfig get_Config();
    public static ValidationParameters op_Implicit(BenchmarkCase[] benchmarksCase);
    public static ValidationParameters op_Implicit(BenchmarkRunInfo benchmarkRunInfo);
}
internal class DirtyAssemblyResolveHelper : object {
    [NullableContextAttribute("1")]
internal static IDisposable Create();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
private Assembly HelpTheFrameworkToResolveTheAssembly(object sender, ResolveEventArgs args);
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.AspAttributeRoutingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <HttpVerb>k__BackingField;
    public string HttpVerb { get; public set; }
    [CompilerGeneratedAttribute]
public string get_HttpVerb();
    [CompilerGeneratedAttribute]
public void set_HttpVerb(string value);
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.AspChildControlTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ControlType>k__BackingField;
    [NotNullAttribute]
public string TagName { get; }
    [NotNullAttribute]
public Type ControlType { get; }
    public AspChildControlTypeAttribute(string tagName, Type controlType);
    [CompilerGeneratedAttribute]
public string get_TagName();
    [CompilerGeneratedAttribute]
public Type get_ControlType();
}
[AttributeUsageAttribute("192")]
internal class JetBrains.Annotations.AspDataFieldAttribute : Attribute {
}
[AttributeUsageAttribute("192")]
internal class JetBrains.Annotations.AspDataFieldsAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspDefaultRouteValuesAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.AspMethodPropertyAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AspMinimalApiDeclarationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <HttpVerb>k__BackingField;
    public string HttpVerb { get; public set; }
    [CompilerGeneratedAttribute]
public string get_HttpVerb();
    [CompilerGeneratedAttribute]
public void set_HttpVerb(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AspMinimalApiGroupAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMinimalApiHandlerAttribute : Attribute {
}
[AttributeUsageAttribute("2496")]
internal class JetBrains.Annotations.AspMvcActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; }
    public AspMvcActionAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
}
[AttributeUsageAttribute("2176")]
internal class JetBrains.Annotations.AspMvcActionSelectorAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.AspMvcAreaAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; }
    public AspMvcAreaAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcAreaMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; }
    public AspMvcAreaMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcAreaPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; }
    public AspMvcAreaPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcAreaViewComponentViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; }
    public AspMvcAreaViewComponentViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcAreaViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; }
    public AspMvcAreaViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
}
[AttributeUsageAttribute("2496")]
internal class JetBrains.Annotations.AspMvcControllerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; }
    public AspMvcControllerAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.AspMvcDisplayTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.AspMvcEditorTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.AspMvcMasterAttribute : Attribute {
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; }
    public AspMvcMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcModelTypeAttribute : Attribute {
}
[AttributeUsageAttribute("2496")]
internal class JetBrains.Annotations.AspMvcPartialViewAttribute : Attribute {
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; }
    public AspMvcPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
}
[AttributeUsageAttribute("68")]
internal class JetBrains.Annotations.AspMvcSuppressViewErrorAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.AspMvcTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2496")]
internal class JetBrains.Annotations.AspMvcViewAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.AspMvcViewComponentAttribute : Attribute {
}
[AttributeUsageAttribute("2496")]
internal class JetBrains.Annotations.AspMvcViewComponentViewAttribute : Attribute {
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcViewComponentViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; }
    public AspMvcViewComponentViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; }
    public AspMvcViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.AspRequiredAttributeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Attribute>k__BackingField;
    [NotNullAttribute]
public string Attribute { get; }
    public AspRequiredAttributeAttribute(string attribute);
    [CompilerGeneratedAttribute]
public string get_Attribute();
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AspRouteConventionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PredefinedPattern>k__BackingField;
    [CanBeNullAttribute]
public string PredefinedPattern { get; }
    public AspRouteConventionAttribute(string predefinedPattern);
    [CompilerGeneratedAttribute]
public string get_PredefinedPattern();
}
[AttributeUsageAttribute("2176")]
internal class JetBrains.Annotations.AspRouteOrderAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspRouteValuesConstraintsAttribute : Attribute {
}
[AttributeUsageAttribute("2176")]
internal class JetBrains.Annotations.AspRouteVerbsAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.AspTypePropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <CreateConstructorReferences>k__BackingField;
    public bool CreateConstructorReferences { get; }
    public AspTypePropertyAttribute(bool createConstructorReferences);
    [CompilerGeneratedAttribute]
public bool get_CreateConstructorReferences();
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AssertionConditionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private AssertionConditionType <ConditionType>k__BackingField;
    public AssertionConditionType ConditionType { get; }
    public AssertionConditionAttribute(AssertionConditionType conditionType);
    [CompilerGeneratedAttribute]
public AssertionConditionType get_ConditionType();
}
internal enum JetBrains.Annotations.AssertionConditionType : Enum {
    public int value__;
    public static AssertionConditionType IS_TRUE;
    public static AssertionConditionType IS_FALSE;
    public static AssertionConditionType IS_NULL;
    public static AssertionConditionType IS_NOT_NULL;
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AssertionMethodAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
internal class JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
internal class JetBrains.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[AttributeUsageAttribute("2044")]
internal class JetBrains.Annotations.CodeTemplateAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <SearchTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatAfterReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MatchSimilarConstructs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShortenReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuppressionKey>k__BackingField;
    public string SearchTemplate { get; }
    public string Message { get; public set; }
    public string ReplaceTemplate { get; public set; }
    public string ReplaceMessage { get; public set; }
    public bool FormatAfterReplace { get; public set; }
    public bool MatchSimilarConstructs { get; public set; }
    public bool ShortenReferences { get; public set; }
    public string SuppressionKey { get; public set; }
    public CodeTemplateAttribute(string searchTemplate);
    [CompilerGeneratedAttribute]
public string get_SearchTemplate();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ReplaceTemplate();
    [CompilerGeneratedAttribute]
public void set_ReplaceTemplate(string value);
    [CompilerGeneratedAttribute]
public string get_ReplaceMessage();
    [CompilerGeneratedAttribute]
public void set_ReplaceMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_FormatAfterReplace();
    [CompilerGeneratedAttribute]
public void set_FormatAfterReplace(bool value);
    [CompilerGeneratedAttribute]
public bool get_MatchSimilarConstructs();
    [CompilerGeneratedAttribute]
public void set_MatchSimilarConstructs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShortenReferences();
    [CompilerGeneratedAttribute]
public void set_ShortenReferences(bool value);
    [CompilerGeneratedAttribute]
public string get_SuppressionKey();
    [CompilerGeneratedAttribute]
public void set_SuppressionKey(string value);
}
[AttributeUsageAttribute("8416")]
internal class JetBrains.Annotations.CollectionAccessAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CollectionAccessType <CollectionAccessType>k__BackingField;
    public CollectionAccessType CollectionAccessType { get; }
    public CollectionAccessAttribute(CollectionAccessType collectionAccessType);
    [CompilerGeneratedAttribute]
public CollectionAccessType get_CollectionAccessType();
}
[FlagsAttribute]
internal enum JetBrains.Annotations.CollectionAccessType : Enum {
    public int value__;
    public static CollectionAccessType None;
    public static CollectionAccessType Read;
    public static CollectionAccessType ModifyExistingContent;
    public static CollectionAccessType UpdatedContent;
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    [NotNullAttribute]
public string Contract { get; }
    public bool ForceFullStates { get; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.HtmlAttributeValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    public HtmlAttributeValueAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.HtmlElementAttributesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CanBeNullAttribute]
public string Name { get; }
    public HtmlElementAttributesAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithInheritors;
    public static ImplicitUseTargetFlags WithMembers;
}
internal enum JetBrains.Annotations.InjectedLanguage : Enum {
    public int value__;
    public static InjectedLanguage CSS;
    public static InjectedLanguage HTML;
    public static InjectedLanguage JAVASCRIPT;
    public static InjectedLanguage JSON;
    public static InjectedLanguage XML;
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InstantHandleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <RequireAwait>k__BackingField;
    public bool RequireAwait { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RequireAwait();
    [CompilerGeneratedAttribute]
public void set_RequireAwait(bool value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemNotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.LanguageInjectionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private InjectedLanguage <InjectedLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InjectedLanguageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    public InjectedLanguage InjectedLanguage { get; }
    [CanBeNullAttribute]
public string InjectedLanguageName { get; }
    [CanBeNullAttribute]
public string Prefix { get; public set; }
    [CanBeNullAttribute]
public string Suffix { get; public set; }
    public LanguageInjectionAttribute(InjectedLanguage injectedLanguage);
    public LanguageInjectionAttribute(string injectedLanguage);
    [CompilerGeneratedAttribute]
public InjectedLanguage get_InjectedLanguage();
    [CompilerGeneratedAttribute]
public string get_InjectedLanguageName();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public void set_Suffix(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.MacroAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Editable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CanBeNullAttribute]
public string Expression { get; public set; }
    public int Editable { get; public set; }
    [CanBeNullAttribute]
public string Target { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(string value);
    [CompilerGeneratedAttribute]
public int get_Editable();
    [CompilerGeneratedAttribute]
public void set_Editable(int value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
}
[AttributeUsageAttribute("18436")]
internal class JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
}
[AttributeUsageAttribute("16384")]
internal class JetBrains.Annotations.MeansTestSubjectAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.MustUseReturnValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [CanBeNullAttribute]
public string Justification { get; }
    public MustUseReturnValueAttribute(string justification);
    [CompilerGeneratedAttribute]
public string get_Justification();
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.NoEnumerationAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.NonNegativeValueAttribute : Attribute {
}
[AttributeUsageAttribute("1052")]
internal class JetBrains.Annotations.NoReorderAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CanBeNullAttribute]
public string ParameterName { get; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CanBeNullAttribute]
public string BasePath { get; }
    public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
}
[AttributeUsageAttribute("19916")]
internal class JetBrains.Annotations.ProvidesContextAttribute : Attribute {
}
[MeansImplicitUseAttribute("3")]
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CanBeNullAttribute]
public string Comment { get; }
    public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorDirectiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Directive>k__BackingField;
    [NotNullAttribute]
public string Directive { get; }
    public RazorDirectiveAttribute(string directive);
    [CompilerGeneratedAttribute]
public string get_Directive();
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.RazorHelperCommonAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorImportNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    public RazorImportNamespaceAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorInjectionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [NotNullAttribute]
public string Type { get; }
    [NotNullAttribute]
public string FieldName { get; }
    public RazorInjectionAttribute(string type, string fieldName);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_FieldName();
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.RazorLayoutAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorPageBaseTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PageName>k__BackingField;
    [NotNullAttribute]
public string BaseType { get; }
    [CanBeNullAttribute]
public string PageName { get; }
    public RazorPageBaseTypeAttribute(string baseType);
    public RazorPageBaseTypeAttribute(string baseType, string pageName);
    [CompilerGeneratedAttribute]
public string get_BaseType();
    [CompilerGeneratedAttribute]
public string get_PageName();
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.RazorSectionAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.RazorWriteLiteralMethodAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.RazorWriteMethodAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.RazorWriteMethodParameterAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.RegexPatternAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.RequireStaticDelegateAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    public bool IsError { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public void set_IsError(bool value);
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.RouteParameterConstraintAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ConstraintName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ProposedType>k__BackingField;
    [NotNullAttribute]
public string ConstraintName { get; }
    [CanBeNullAttribute]
public Type ProposedType { get; public set; }
    public RouteParameterConstraintAttribute(string constraintName);
    [CompilerGeneratedAttribute]
public string get_ConstraintName();
    [CompilerGeneratedAttribute]
public Type get_ProposedType();
    [CompilerGeneratedAttribute]
public void set_ProposedType(Type value);
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.RouteTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.SourceTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("4320")]
internal class JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    [NotNullAttribute]
public string FormatParameterName { get; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.StructuredMessageTemplateAttribute : Attribute {
}
[ObsoleteAttribute("Use [ContractAnnotation('=> halt')] instead")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.TerminatesProgramAttribute : Attribute {
}
[AttributeUsageAttribute("1220")]
internal class JetBrains.Annotations.TestSubjectAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Subject>k__BackingField;
    [NotNullAttribute]
public Type Subject { get; }
    public TestSubjectAttribute(Type subject);
    [CompilerGeneratedAttribute]
public Type get_Subject();
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.UriStringAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <HttpVerb>k__BackingField;
    [CanBeNullAttribute]
public string HttpVerb { get; }
    public UriStringAttribute(string httpVerb);
    [CompilerGeneratedAttribute]
public string get_HttpVerb();
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; }
    public ImplicitUseTargetFlags TargetFlags { get; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.ValueProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    public ValueProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ValueRangeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <From>k__BackingField;
    [CompilerGeneratedAttribute]
private object <To>k__BackingField;
    public object From { get; }
    public object To { get; }
    public ValueRangeAttribute(long from, long to);
    public ValueRangeAttribute(ulong from, ulong to);
    public ValueRangeAttribute(long value);
    public ValueRangeAttribute(ulong value);
    [CompilerGeneratedAttribute]
public object get_From();
    [CompilerGeneratedAttribute]
public object get_To();
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.XamlItemBindingOfItemsControlAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.XamlItemsControlAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.XamlItemStyleOfItemsControlAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
internal class JetBrains.Annotations.XamlOneWayBindingModeByDefaultAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
internal class JetBrains.Annotations.XamlTwoWayBindingModeByDefaultAttribute : Attribute {
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
internal interface SimpleJson.IJsonSerializerStrategy {
    public bool Indent { get; public set; }
    public abstract virtual bool TrySerializeNonPrimitiveObject(object input, Object& output);
    public abstract virtual object DeserializeObject(object value, Type type);
    public abstract virtual bool get_Indent();
    public abstract virtual void set_Indent(bool value);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
[EditorBrowsableAttribute("1")]
internal class SimpleJson.JsonArray : List`1<object> {
    public JsonArray(int capacity);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[GeneratedCodeAttribute("simple-json", "1.0.0")]
[EditorBrowsableAttribute("1")]
internal class SimpleJson.JsonObject : object {
    private Dictionary`2<string, object> _members;
    public object Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JsonObject(IEqualityComparer`1<string> comparer);
    public object get_Item(int index);
    internal static object GetAtIndex(IDictionary`2<string, object> obj, int index);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
internal class SimpleJson.PocoJsonSerializerStrategy : object {
    internal IDictionary`2<Type, ConstructorDelegate> ConstructorCache;
    internal IDictionary`2<Type, IDictionary`2<string, GetDelegate>> GetCache;
    internal IDictionary`2<Type, IDictionary`2<string, KeyValuePair`2<Type, SetDelegate>>> SetCache;
    internal static Type[] EmptyTypes;
    internal static Type[] ArrayConstructorParameterTypes;
    private static String[] Iso8601Format;
    [CompilerGeneratedAttribute]
private bool <Indent>k__BackingField;
    public bool Indent { get; public set; }
    private static PocoJsonSerializerStrategy();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Indent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Indent(bool value);
    protected virtual string MapClrMemberNameToJsonFieldName(string clrPropertyName);
    internal virtual ConstructorDelegate ContructorDelegateFactory(Type key);
    internal virtual IDictionary`2<string, GetDelegate> GetterValueFactory(Type type);
    internal virtual IDictionary`2<string, KeyValuePair`2<Type, SetDelegate>> SetterValueFactory(Type type);
    public virtual bool TrySerializeNonPrimitiveObject(object input, Object& output);
    public virtual object DeserializeObject(object value, Type type);
    protected virtual object SerializeEnum(Enum p);
    protected virtual bool TrySerializeKnownTypes(object input, Object& output);
    protected virtual bool TrySerializeUnknownTypes(object input, Object& output);
}
[GeneratedCodeAttribute("reflection-utils", "1.0.0")]
internal class SimpleJson.Reflection.ReflectionUtils : object {
    private static Object[] EmptyObjects;
    private static ReflectionUtils();
    public static Type GetTypeInfo(Type type);
    public static Attribute GetAttribute(MemberInfo info, Type type);
    public static Type GetGenericListElementType(Type type);
    public static Attribute GetAttribute(Type objectType, Type attributeType);
    public static Type[] GetGenericTypeArguments(Type type);
    public static bool IsTypeGeneric(Type type);
    public static bool IsTypeGenericeCollectionInterface(Type type);
    public static bool IsAssignableFrom(Type type1, Type type2);
    public static bool IsTypeDictionary(Type type);
    public static bool IsNullableType(Type type);
    public static object ToNullableType(object obj, Type nullableType);
    public static bool IsValueType(Type type);
    public static IEnumerable`1<ConstructorInfo> GetConstructors(Type type);
    public static ConstructorInfo GetConstructorInfo(Type type, Type[] argsType);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static IEnumerable`1<FieldInfo> GetFields(Type type);
    public static MethodInfo GetGetterMethodInfo(PropertyInfo propertyInfo);
    public static MethodInfo GetSetterMethodInfo(PropertyInfo propertyInfo);
    public static ConstructorDelegate GetContructor(ConstructorInfo constructorInfo);
    public static ConstructorDelegate GetContructor(Type type, Type[] argsType);
    public static ConstructorDelegate GetConstructorByReflection(ConstructorInfo constructorInfo);
    public static ConstructorDelegate GetConstructorByReflection(Type type, Type[] argsType);
    public static ConstructorDelegate GetConstructorByExpression(ConstructorInfo constructorInfo);
    public static ConstructorDelegate GetConstructorByExpression(Type type, Type[] argsType);
    public static GetDelegate GetGetMethod(PropertyInfo propertyInfo);
    public static GetDelegate GetGetMethod(FieldInfo fieldInfo);
    public static GetDelegate GetGetMethodByReflection(PropertyInfo propertyInfo);
    public static GetDelegate GetGetMethodByReflection(FieldInfo fieldInfo);
    public static GetDelegate GetGetMethodByExpression(PropertyInfo propertyInfo);
    public static GetDelegate GetGetMethodByExpression(FieldInfo fieldInfo);
    public static SetDelegate GetSetMethod(PropertyInfo propertyInfo);
    public static SetDelegate GetSetMethod(FieldInfo fieldInfo);
    public static SetDelegate GetSetMethodByReflection(PropertyInfo propertyInfo);
    public static SetDelegate GetSetMethodByReflection(FieldInfo fieldInfo);
    public static SetDelegate GetSetMethodByExpression(PropertyInfo propertyInfo);
    public static SetDelegate GetSetMethodByExpression(FieldInfo fieldInfo);
    public static BinaryExpression Assign(Expression left, Expression right);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
internal static class SimpleJson.SimpleJson : object {
    private static int TOKEN_NONE;
    private static int TOKEN_CURLY_OPEN;
    private static int TOKEN_CURLY_CLOSE;
    private static int TOKEN_SQUARED_OPEN;
    private static int TOKEN_SQUARED_CLOSE;
    private static int TOKEN_COLON;
    private static int TOKEN_COMMA;
    private static int TOKEN_STRING;
    private static int TOKEN_NUMBER;
    private static int TOKEN_TRUE;
    private static int TOKEN_FALSE;
    private static int TOKEN_NULL;
    private static int BUILDER_CAPACITY;
    internal static string JSON_EMPTY_STRING;
    private static Char[] EscapeTable;
    private static Char[] EscapeCharacters;
    private static string EscapeCharactersString;
    private static char WhiteSpaceCharacter;
    private static int indentationLevel;
    private static string indentationText;
    private static int spacesPerIndent;
    private static IJsonSerializerStrategy _currentJsonSerializerStrategy;
    private static PocoJsonSerializerStrategy _pocoJsonSerializerStrategy;
    public static IJsonSerializerStrategy CurrentJsonSerializerStrategy { get; public set; }
    [EditorBrowsableAttribute("2")]
public static PocoJsonSerializerStrategy PocoJsonSerializerStrategy { get; }
    private static SimpleJson();
    public static object DeserializeObject(string json);
    public static bool TryDeserializeObject(string json, Object& obj);
    public static object DeserializeObject(string json, Type type, IJsonSerializerStrategy jsonSerializerStrategy);
    public static object DeserializeObject(string json, Type type);
    public static T DeserializeObject(string json, IJsonSerializerStrategy jsonSerializerStrategy);
    public static T DeserializeObject(string json);
    public static string SerializeObject(object json, IJsonSerializerStrategy jsonSerializerStrategy);
    public static string SerializeObject(object json);
    public static string EscapeToJavascriptString(string jsonString);
    private static IDictionary`2<string, object> ParseObject(Char[] json, Int32& index, Boolean& success);
    private static JsonArray ParseArray(Char[] json, Int32& index, Boolean& success);
    private static object ParseValue(Char[] json, Int32& index, Boolean& success);
    private static string ParseString(Char[] json, Int32& index, Boolean& success);
    private static string ConvertFromUtf32(int utf32);
    private static object ParseNumber(Char[] json, Int32& index, Boolean& success);
    private static int GetLastIndexOfNumber(Char[] json, int index);
    private static void EatWhitespace(Char[] json, Int32& index);
    private static int LookAhead(Char[] json, int index);
    private static int NextToken(Char[] json, Int32& index);
    private static bool SerializeValue(IJsonSerializerStrategy jsonSerializerStrategy, object value, StringBuilder builder);
    private static bool SerializeObject(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable keys, IEnumerable values, StringBuilder builder);
    private static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, StringBuilder builder);
    private static bool SerializeString(string aString, StringBuilder builder);
    private static bool SerializeNumber(object number, StringBuilder builder);
    private static bool IsNumeric(object value);
    internal static object ReplaceUnsupportedNumericValues(object value);
    private static void ResetIndentationText();
    private static void HandleIndent(int change);
    public static IJsonSerializerStrategy get_CurrentJsonSerializerStrategy();
    public static void set_CurrentJsonSerializerStrategy(IJsonSerializerStrategy value);
    public static PocoJsonSerializerStrategy get_PocoJsonSerializerStrategy();
}
