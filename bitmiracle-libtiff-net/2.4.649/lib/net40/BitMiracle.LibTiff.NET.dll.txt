internal enum BitMiracle.LibJpeg.Classic.DensityUnit : Enum {
    public int value__;
    public static DensityUnit Unknown;
    public static DensityUnit DotsInch;
    public static DensityUnit DotsCm;
}
internal class BitMiracle.LibJpeg.Classic.Internal.arith_entropy_decoder : jpeg_entropy_decoder {
    public arith_entropy_decoder(jpeg_decompress_struct cinfo);
    public virtual void start_pass();
}
internal class BitMiracle.LibJpeg.Classic.Internal.arith_entropy_encoder : jpeg_entropy_encoder {
    public arith_entropy_encoder(jpeg_compress_struct cinfo);
    public virtual void start_pass(bool gather_statistics);
}
internal class BitMiracle.LibJpeg.Classic.Internal.bitread_perm_state : ValueType {
    public int get_buffer;
    public int bits_left;
}
[DefaultMemberAttribute("Item")]
internal class BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer : object {
    private Byte[][] m_buffer;
    private Int32[] m_funnyIndices;
    private int m_funnyOffset;
    public Byte[] Item { get; }
    public Byte[] get_Item(int i);
    public void SetBuffer(Byte[][] buf, Int32[] funnyIndices, int funnyOffset);
}
internal class BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl : object {
    public Int32[] maxcode;
    public Int32[] valoffset;
    public JHUFF_TBL pub;
    public Int32[] look_nbits;
    public Byte[] look_sym;
}
internal class BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder : jpeg_entropy_decoder {
    private static int BIT_BUF_SIZE;
    private static int MIN_GET_BITS;
    private static Int32[] bmask;
    private static Int32[][] jpeg_zigzag_order;
    private static Int32[][] jpeg_zigzag_order7;
    private static Int32[][] jpeg_zigzag_order6;
    private static Int32[][] jpeg_zigzag_order5;
    private static Int32[][] jpeg_zigzag_order4;
    private static Int32[][] jpeg_zigzag_order3;
    private static Int32[][] jpeg_zigzag_order2;
    private bitread_perm_state m_bitstate;
    private savable_state m_saved;
    private bool m_insufficient_data;
    private int m_restarts_to_go;
    private d_derived_tbl[] derived_tbls;
    private d_derived_tbl ac_derived_tbl;
    private d_derived_tbl[] m_dc_derived_tbls;
    private d_derived_tbl[] m_ac_derived_tbls;
    private d_derived_tbl[] m_dc_cur_tbls;
    private d_derived_tbl[] m_ac_cur_tbls;
    private Int32[] coef_limit;
    private jpeg_decompress_struct m_cinfo;
    private int get_buffer;
    private int bits_left;
    public huff_entropy_decoder(jpeg_decompress_struct cinfo);
    private static huff_entropy_decoder();
    public virtual void start_pass();
    private bool decode_mcu_full(JBLOCK[] MCU_data);
    private bool decode_mcu_sub(JBLOCK[] MCU_data);
    private bool decode_mcu_DC_first(JBLOCK[] MCU_data);
    private bool decode_mcu_AC_first(JBLOCK[] MCU_data);
    private bool decode_mcu_DC_refine(JBLOCK[] MCU_data);
    private bool decode_mcu_AC_refine(JBLOCK[] MCU_data);
    public void finish_pass_huff();
    private bool process_restart();
    private void BITREAD_LOAD_STATE();
    private void BITREAD_SAVE_STATE();
    private void CHECK_BIT_BUFFER(int nbits);
    private int HUFF_DECODE(d_derived_tbl htbl);
    private void jpeg_fill_bit_buffer(int nbits);
    private void jpeg_make_d_derived_tbl(bool isDC, int tblno, d_derived_tbl& dtbl);
    protected int jpeg_huff_decode(d_derived_tbl htbl, int min_bits);
}
internal class BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder : jpeg_entropy_encoder {
    private static int MAX_COEF_BITS;
    private static int MAX_CORR_BITS;
    private savable_state m_saved;
    private int m_restarts_to_go;
    private int m_next_restart_num;
    private c_derived_tbl[] m_dc_derived_tbls;
    private c_derived_tbl[] m_ac_derived_tbls;
    private Int64[][] m_dc_count_ptrs;
    private Int64[][] m_ac_count_ptrs;
    private bool m_gather_statistics;
    private jpeg_compress_struct m_cinfo;
    private int ac_tbl_no;
    private UInt32 EOBRUN;
    private UInt32 BE;
    private Char[] bit_buffer;
    public huff_entropy_encoder(jpeg_compress_struct cinfo);
    public virtual void start_pass(bool gather_statistics);
    private bool encode_mcu_huff(JBLOCK[][] MCU_data);
    private void finish_pass_huff();
    private bool encode_mcu_gather(JBLOCK[][] MCU_data);
    private void finish_pass_gather();
    private bool encode_one_block(savable_state state, Int16[] block, int last_dc_val, c_derived_tbl dctbl, c_derived_tbl actbl);
    private void htest_one_block(Int16[] block, int last_dc_val, Int64[] dc_counts, Int64[] ac_counts);
    private bool emit_byte_s(int val);
    private void emit_byte_e(int val);
    private bool dump_buffer_s();
    private bool dump_buffer_e();
    private bool emit_bits_s(savable_state state, int code, int size);
    private void emit_bits_e(int code, int size);
    private bool flush_bits_s(savable_state state);
    private void flush_bits_e();
    private void emit_dc_symbol(int tbl_no, int symbol);
    private void emit_ac_symbol(int tbl_no, int symbol);
    private void emit_buffered_bits(UInt32 offset, UInt32 nbits);
    private void emit_eobrun();
    private bool emit_restart_s(savable_state state, int restart_num);
    private void emit_restart_e(int restart_num);
    private static int IRIGHT_SHIFT(int x, int shft);
    private bool encode_mcu_DC_first(JBLOCK[][] MCU_data);
    private bool encode_mcu_AC_first(JBLOCK[][] MCU_data);
    private bool encode_mcu_DC_refine(JBLOCK[][] MCU_data);
    private bool encode_mcu_AC_refine(JBLOCK[][] MCU_data);
    private void jpeg_make_c_derived_tbl(bool isDC, int tblno, c_derived_tbl& dtbl);
    protected void jpeg_gen_optimal_table(JHUFF_TBL htbl, Int64[] freq);
}
internal enum BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE : Enum {
    public int value__;
    public static J_BUF_MODE JBUF_PASS_THRU;
    public static J_BUF_MODE JBUF_SAVE_SOURCE;
    public static J_BUF_MODE JBUF_CRANK_DEST;
    public static J_BUF_MODE JBUF_SAVE_AND_PASS;
}
internal interface BitMiracle.LibJpeg.Classic.Internal.jpeg_c_coef_controller {
    public abstract virtual void start_pass(J_BUF_MODE pass_mode);
    public abstract virtual bool compress_data(Byte[][][] input_buf);
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller : object {
    private jpeg_compress_struct m_cinfo;
    private int m_cur_iMCU_row;
    private int m_rowgroup_ctr;
    private bool m_suspended;
    private Byte[][][] m_buffer;
    public jpeg_c_main_controller(jpeg_compress_struct cinfo);
    public void start_pass(J_BUF_MODE pass_mode);
    public void process_data(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail);
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller : object {
    private jpeg_compress_struct m_cinfo;
    private Byte[][][] m_color_buf;
    private int m_colorBufRowsOffset;
    private int m_rows_to_go;
    private int m_next_buf_row;
    private int m_this_row_group;
    private int m_next_buf_stop;
    public jpeg_c_prep_controller(jpeg_compress_struct cinfo);
    public void start_pass(J_BUF_MODE pass_mode);
    public void pre_process_data(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private void create_context_buffer();
    private void pre_process_WithoutContext(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private void pre_process_context(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private static void expand_bottom_edge(Byte[][] image_data, int rowsOffset, int num_cols, int input_rows, int output_rows);
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter : object {
    private static int SCALEBITS;
    private static int CBCR_OFFSET;
    private static int ONE_HALF;
    private static int R_Y_OFF;
    private static int G_Y_OFF;
    private static int B_Y_OFF;
    private static int R_CB_OFF;
    private static int G_CB_OFF;
    private static int B_CB_OFF;
    private static int R_CR_OFF;
    private static int G_CR_OFF;
    private static int B_CR_OFF;
    private static int TABLE_SIZE;
    private jpeg_compress_struct m_cinfo;
    private bool m_useNullStart;
    private Int32[] m_rgb_ycc_tab;
    internal convertMethod color_convert;
    public jpeg_color_converter(jpeg_compress_struct cinfo);
    public void start_pass();
    private void rgb_ycc_start();
    private static int FIX(double x);
    private void rgb_ycc_convert(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void rgb_gray_convert(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void cmyk_ycck_convert(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void rgb_rgb1_convert(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void grayscale_convert(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void rgb_convert(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void null_convert(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter : object {
    private static int SCALEBITS;
    private static int ONE_HALF;
    private static int R_Y_OFF;
    private static int G_Y_OFF;
    private static int B_Y_OFF;
    private static int TABLE_SIZE;
    private color_convert_func m_converter;
    private jpeg_decompress_struct m_cinfo;
    private Int32[] m_perComponentOffsets;
    private Int32[] m_Cr_r_tab;
    private Int32[] m_Cb_b_tab;
    private Int32[] m_Cr_g_tab;
    private Int32[] m_Cb_g_tab;
    private Int32[] rgb_y_tab;
    public jpeg_color_deconverter(jpeg_decompress_struct cinfo);
    public void color_convert(ComponentBuffer[] input_buf, Int32[] perComponentOffsets, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void build_ycc_rgb_table();
    private void build_bg_ycc_rgb_table();
    private void ycc_rgb_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void build_rgb_y_table();
    private void rgb_gray_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void rgb1_rgb_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void rgb1_gray_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void rgb_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void ycck_cmyk_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void gray_rgb_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void grayscale_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void cmyk_rgb_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void ycck_rgb_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void null_convert(ComponentBuffer[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private static int FIX(double x);
}
internal interface BitMiracle.LibJpeg.Classic.Internal.jpeg_color_quantizer {
    public abstract virtual void start_pass(bool is_pre_scan);
    public abstract virtual void color_quantize(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public abstract virtual void finish_pass();
    public abstract virtual void new_color_map();
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master : object {
    private jpeg_compress_struct m_cinfo;
    private bool m_call_pass_startup;
    private bool m_is_last_pass;
    private c_pass_type m_pass_type;
    private int m_pass_number;
    private int m_total_passes;
    private int m_scan_number;
    public jpeg_comp_master(jpeg_compress_struct cinfo, bool transcode_only);
    public void prepare_for_pass();
    public void pass_startup();
    public void finish_pass();
    public bool IsLastPass();
    public bool MustCallPassStartup();
    private void prepare_for_main_pass();
    private bool prepare_for_huff_opt_pass();
    private void prepare_for_output_pass();
    private void select_scan_parameters();
    private void per_scan_setup();
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller : object {
    private static int SAVED_COEFS;
    private static int Q01_POS;
    private static int Q10_POS;
    private static int Q20_POS;
    private static int Q11_POS;
    private static int Q02_POS;
    private jpeg_decompress_struct m_cinfo;
    private bool m_useDummyConsumeData;
    private DecompressorType m_decompressor;
    private int m_MCU_ctr;
    private int m_MCU_vert_offset;
    private int m_MCU_rows_per_iMCU_row;
    private JBLOCK[] m_MCU_buffer;
    private jvirt_array`1[] m_whole_image;
    private jvirt_array`1[] m_coef_arrays;
    private Int32[] m_coef_bits_latch;
    private int m_coef_bits_savedOffset;
    public jpeg_d_coef_controller(jpeg_decompress_struct cinfo, bool need_full_buffer);
    public void start_input_pass();
    public ReadResult consume_data();
    public void start_output_pass();
    public ReadResult decompress_data(ComponentBuffer[] output_buf);
    public jvirt_array`1[] GetCoefArrays();
    private ReadResult decompress_onepass(ComponentBuffer[] output_buf);
    private ReadResult decompress_data_ordinary(ComponentBuffer[] output_buf);
    private ReadResult decompress_smooth_data(ComponentBuffer[] output_buf);
    private bool smoothing_ok();
    private void start_iMCU_row();
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller : object {
    private static int CTX_PREPARE_FOR_IMCU;
    private static int CTX_PROCESS_IMCU;
    private static int CTX_POSTPONED_ROW;
    private DataProcessor m_dataProcessor;
    private jpeg_decompress_struct m_cinfo;
    private Byte[][][] m_buffer;
    private bool m_buffer_full;
    private int m_rowgroup_ctr;
    private Int32[][][] m_funnyIndices;
    private Int32[] m_funnyOffsets;
    private int m_whichFunny;
    private int m_context_state;
    private int m_rowgroups_avail;
    private int m_iMCU_row_ctr;
    public jpeg_d_main_controller(jpeg_decompress_struct cinfo);
    public void start_pass(J_BUF_MODE pass_mode);
    public void process_data(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void process_data_simple_main(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void process_data_context_main(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void process_data_crank_post(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void alloc_funny_pointers();
    private void make_funny_pointers();
    private void set_wraparound_pointers();
    private void set_bottom_pointers();
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller : object {
    private ProcessorType m_processor;
    private jpeg_decompress_struct m_cinfo;
    private jvirt_array`1<byte> m_whole_image;
    private Byte[][] m_buffer;
    private int m_strip_height;
    private int m_starting_row;
    private int m_next_row;
    public jpeg_d_post_controller(jpeg_decompress_struct cinfo, bool need_full_buffer);
    public void start_pass(J_BUF_MODE pass_mode);
    public void post_process_data(ComponentBuffer[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void post_process_1pass(ComponentBuffer[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void post_process_prepass(ComponentBuffer[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Int32& out_row_ctr);
    private void post_process_2pass(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master : object {
    private jpeg_decompress_struct m_cinfo;
    private int m_pass_number;
    private bool m_is_dummy_pass;
    private bool m_using_merged_upsample;
    private jpeg_color_quantizer m_quantizer_1pass;
    private jpeg_color_quantizer m_quantizer_2pass;
    public jpeg_decomp_master(jpeg_decompress_struct cinfo);
    public void prepare_for_output_pass();
    public void finish_output_pass();
    public bool IsDummyPass();
    private void master_selection();
    private void prepare_range_limit_table();
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler : object {
    private downSampleMethod[] m_downSamplers;
    private Int32[] rowgroup_height;
    private Byte[] h_expand;
    private Byte[] v_expand;
    private jpeg_compress_struct m_cinfo;
    private bool m_need_context_rows;
    public jpeg_downsampler(jpeg_compress_struct cinfo);
    public void downsample(Byte[][][] input_buf, int in_row_index, Byte[][][] output_buf, int out_row_group_index);
    public bool NeedContextRows();
    private void int_downsample(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void fullsize_downsample(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void h2v1_downsample(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void h2v2_downsample(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void h2v2_smooth_downsample(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void fullsize_smooth_downsample(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private static void expand_right_edge(Byte[][] image_data, int startInputRow, int num_rows, int input_cols, int output_cols);
}
internal abstract class BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_decoder : object {
    public decode_mcu_delegate decode_mcu;
    public finish_pass_delegate finish_pass;
    public abstract virtual void start_pass();
}
internal abstract class BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder : object {
    public encode_mcu_delegate encode_mcu;
    public finish_pass_delegate finish_pass;
    public abstract virtual void start_pass(bool gather_statistics);
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct : object {
    private static int FAST_INTEGER_CONST_BITS;
    private static int FAST_INTEGER_FIX_0_382683433;
    private static int FAST_INTEGER_FIX_0_541196100;
    private static int FAST_INTEGER_FIX_0_707106781;
    private static int FAST_INTEGER_FIX_1_306562965;
    private static int SLOW_INTEGER_CONST_BITS;
    private static int SLOW_INTEGER_PASS1_BITS;
    private static int SLOW_INTEGER_FIX_0_298631336;
    private static int SLOW_INTEGER_FIX_0_390180644;
    private static int SLOW_INTEGER_FIX_0_541196100;
    private static int SLOW_INTEGER_FIX_0_765366865;
    private static int SLOW_INTEGER_FIX_0_899976223;
    private static int SLOW_INTEGER_FIX_1_175875602;
    private static int SLOW_INTEGER_FIX_1_501321110;
    private static int SLOW_INTEGER_FIX_1_847759065;
    private static int SLOW_INTEGER_FIX_1_961570560;
    private static int SLOW_INTEGER_FIX_2_053119869;
    private static int SLOW_INTEGER_FIX_2_562915447;
    private static int SLOW_INTEGER_FIX_3_072711026;
    private static int CONST_BITS;
    private static Int16[] aanscales;
    private static Double[] aanscalefactor;
    private jpeg_compress_struct m_cinfo;
    private forward_DCT_method_ptr[] do_dct;
    private float_DCT_method_ptr[] do_float_dct;
    public forward_DCT_ptr[] forward_DCT;
    private divisor_table[] m_dctTables;
    public jpeg_forward_dct(jpeg_compress_struct cinfo);
    private static jpeg_forward_dct();
    public virtual void start_pass();
    private void forwardDCTImpl(jpeg_component_info compptr, Byte[][] sample_data, JBLOCK[] coef_blocks, int start_row, int start_col, int num_blocks);
    private void forwardDCTFloatImpl(jpeg_component_info compptr, Byte[][] sample_data, JBLOCK[] coef_blocks, int start_row, int start_col, int num_blocks);
    private static void jpeg_fdct_float(Single[] data, Byte[][] sample_data, int start_row, int start_col);
    private static void jpeg_fdct_ifast(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private static void jpeg_fdct_islow(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private static int FAST_INTEGER_MULTIPLY(int var, int c);
    private static int SLOW_INTEGER_FIX(double x);
    private void jpeg_fdct_1x1(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_2x2(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_3x3(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_4x4(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_5x5(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_6x6(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_7x7(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_9x9(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_10x10(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_11x11(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_12x12(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_13x13(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_14x14(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_15x15(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_16x16(Int32[] data1, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_16x8(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_14x7(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_12x6(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_10x5(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_8x4(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_6x3(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_4x2(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_2x1(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_8x16(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_7x14(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_6x12(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_5x10(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_4x8(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_3x6(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_2x4(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
    private void jpeg_fdct_1x2(Int32[] data, Byte[][] sample_data, int start_row, int start_col);
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller : object {
    private jpeg_decompress_struct m_cinfo;
    private bool m_consumeData;
    private int m_inheaders;
    private bool m_has_multiple_scans;
    private bool m_eoi_reached;
    public jpeg_input_controller(jpeg_decompress_struct cinfo);
    public ReadResult consume_input();
    public void reset_input_controller();
    public void start_input_pass();
    public void finish_input_pass();
    public bool HasMultipleScans();
    public bool EOIReached();
    public void jpeg_core_output_dimensions();
    private ReadResult consume_markers();
    private void initial_setup();
    private void latch_quant_tables();
    private void per_scan_setup();
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct : object {
    private static int IFAST_SCALE_BITS;
    private static int RANGE_MASK;
    private static int RANGE_CENTER;
    private static int RANGE_SUBSET;
    private static int SLOW_INTEGER_CONST_BITS;
    private static int SLOW_INTEGER_PASS1_BITS;
    private static int SLOW_INTEGER_PASS1_PLUS3_BITS;
    private static int SLOW_INTEGER_FIX_0_298631336;
    private static int SLOW_INTEGER_FIX_0_390180644;
    private static int SLOW_INTEGER_FIX_0_541196100;
    private static int SLOW_INTEGER_FIX_0_765366865;
    private static int SLOW_INTEGER_FIX_0_899976223;
    private static int SLOW_INTEGER_FIX_1_175875602;
    private static int SLOW_INTEGER_FIX_1_501321110;
    private static int SLOW_INTEGER_FIX_1_847759065;
    private static int SLOW_INTEGER_FIX_1_961570560;
    private static int SLOW_INTEGER_FIX_2_053119869;
    private static int SLOW_INTEGER_FIX_2_562915447;
    private static int SLOW_INTEGER_FIX_3_072711026;
    private static int FAST_INTEGER_CONST_BITS;
    private static int FAST_INTEGER_PASS1_BITS;
    private static int FAST_INTEGER_FIX_1_082392200;
    private static int FAST_INTEGER_FIX_1_414213562;
    private static int FAST_INTEGER_FIX_1_847759065;
    private static int FAST_INTEGER_FIX_2_613125930;
    private static int REDUCED_CONST_BITS;
    private static int REDUCED_PASS1_BITS;
    private static int REDUCED_FIX_0_211164243;
    private static int REDUCED_FIX_0_509795579;
    private static int REDUCED_FIX_0_601344887;
    private static int REDUCED_FIX_0_720959822;
    private static int REDUCED_FIX_0_765366865;
    private static int REDUCED_FIX_0_850430095;
    private static int REDUCED_FIX_0_899976223;
    private static int REDUCED_FIX_1_061594337;
    private static int REDUCED_FIX_1_272758580;
    private static int REDUCED_FIX_1_451774981;
    private static int REDUCED_FIX_1_847759065;
    private static int REDUCED_FIX_2_172734803;
    private static int REDUCED_FIX_2_562915447;
    private static int REDUCED_FIX_3_624509785;
    private static Int16[] aanscales;
    private static int CONST_BITS;
    private static Double[] aanscalefactor;
    private inverse_method[] m_inverse_DCT_method;
    private multiplier_table[] m_dctTables;
    private jpeg_decompress_struct m_cinfo;
    private Int32[] m_cur_method;
    private ComponentBuffer m_componentBuffer;
    private Int32[] m_workspace;
    private Single[] m_fworkspace;
    public jpeg_inverse_dct(jpeg_decompress_struct cinfo);
    private static jpeg_inverse_dct();
    public void start_pass();
    public void inverse(int component_index, Int16[] coef_block, ComponentBuffer output_buf, int output_row, int output_col);
    private void jpeg_idct_islow(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int SLOW_INTEGER_FIX(double x);
    private void jpeg_idct_ifast(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int FAST_INTEGER_MULTIPLY(int var, int c);
    private static int FAST_INTEGER_DEQUANTIZE(short coef, int quantval);
    private static int FAST_INTEGER_IRIGHT_SHIFT(int x, int shft);
    private void jpeg_idct_float(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static float FLOAT_DEQUANTIZE(short coef, float quantval);
    private void jpeg_idct_4x4(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_2x2(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_1x1(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int REDUCED_DEQUANTIZE(short coef, int quantval);
    private void jpeg_idct_3x3(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_5x5(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_6x6(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_7x7(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_9x9(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_10x10(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_11x11(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_12x12(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_13x13(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_14x14(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_15x15(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_16x16(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_16x8(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_14x7(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_12x6(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_10x5(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_8x4(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_6x3(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_4x2(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_2x1(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_8x16(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_7x14(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_6x12(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_5x10(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_4x8(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_3x6(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_2x4(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void jpeg_idct_1x2(int component_index, Int16[] coef_block, int output_row, int output_col);
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader : object {
    private static int APP0_DATA_LEN;
    private static int APP14_DATA_LEN;
    private static int APPN_DATA_LEN;
    private jpeg_decompress_struct m_cinfo;
    private jpeg_marker_parser_method m_process_COM;
    private jpeg_marker_parser_method[] m_process_APPn;
    private int m_length_limit_COM;
    private Int32[] m_length_limit_APPn;
    private bool m_saw_SOI;
    private bool m_saw_SOF;
    private int m_next_restart_num;
    private int m_discarded_bytes;
    private jpeg_marker_struct m_cur_marker;
    private int m_bytes_read;
    public jpeg_marker_reader(jpeg_decompress_struct cinfo);
    public void reset_marker_reader();
    public ReadResult read_markers();
    public bool read_restart_marker();
    public bool next_marker();
    public void jpeg_set_marker_processor(int marker_code, jpeg_marker_parser_method routine);
    public void jpeg_save_markers(int marker_code, int length_limit);
    public bool SawSOI();
    public bool SawSOF();
    public int NextRestartNumber();
    public int DiscardedByteCount();
    public void SkipBytes(int count);
    private static bool save_marker(jpeg_decompress_struct cinfo);
    private static bool skip_variable(jpeg_decompress_struct cinfo);
    private static bool get_interesting_appn(jpeg_decompress_struct cinfo);
    private static void examine_app0(jpeg_decompress_struct cinfo, Byte[] data, int datalen, int remaining);
    private static void examine_app14(jpeg_decompress_struct cinfo, Byte[] data, int datalen, int remaining);
    private void get_soi();
    private bool get_sof(bool is_baseline, bool is_prog, bool is_arith);
    private bool get_sos();
    private bool get_dac();
    private bool get_dht();
    private bool get_dqt();
    private bool get_dri();
    private bool get_lse();
    private bool first_marker();
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer : object {
    private jpeg_compress_struct m_cinfo;
    private int m_last_restart_interval;
    public jpeg_marker_writer(jpeg_compress_struct cinfo);
    public void write_file_header();
    public void write_frame_header();
    public void write_scan_header();
    public void write_file_trailer();
    public void write_tables_only();
    public void write_marker_header(int marker, int datalen);
    public void write_marker_byte(byte val);
    private void emit_sos();
    private void emit_lse_ict();
    private void emit_sof(JPEG_MARKER code);
    private void emit_adobe_app14();
    private void emit_dri();
    private void emit_dht(int index, bool is_ac);
    private int emit_dqt(int index);
    private void emit_dac();
    private void emit_pseudo_sos();
    private void emit_jfif_app0();
    private void emit_marker(JPEG_MARKER mark);
    private void emit_2bytes(int value);
    private void emit_byte(int val);
}
internal class BitMiracle.LibJpeg.Classic.Internal.jpeg_scan_info : object {
    public int comps_in_scan;
    public Int32[] component_index;
    public int Ss;
    public int Se;
    public int Ah;
    public int Al;
}
internal abstract class BitMiracle.LibJpeg.Classic.Internal.jpeg_upsampler : object {
    protected bool m_need_context_rows;
    public abstract virtual void start_pass();
    public abstract virtual void upsample(ComponentBuffer[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    public bool NeedContextRows();
}
internal class BitMiracle.LibJpeg.Classic.Internal.JpegUtils : object {
    public static Int32[] jpeg_natural_order;
    public static Int32[] jpeg_natural_order7;
    public static Int32[] jpeg_natural_order6;
    public static Int32[] jpeg_natural_order5;
    public static Int32[] jpeg_natural_order4;
    public static Int32[] jpeg_natural_order3;
    public static Int32[] jpeg_natural_order2;
    public static Int32[] jpeg_aritab;
    private static JpegUtils();
    public static int DESCALE(int x, int n);
    public static long jdiv_round_up(long a, long b);
    public static int jround_up(int a, int b);
    public static void jcopy_sample_rows(ComponentBuffer input_array, int source_row, Byte[][] output_array, int dest_row, int num_rows, int num_cols);
    public static void jcopy_sample_rows(ComponentBuffer input_array, int source_row, ComponentBuffer output_array, int dest_row, int num_rows, int num_cols);
    public static void jcopy_sample_rows(Byte[][] input_array, int source_row, Byte[][] output_array, int dest_row, int num_rows, int num_cols);
}
internal class BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer : object {
    private static Int32[] RGB_order;
    private static int MAX_Q_COMPS;
    private static int ODITHER_SIZE;
    private static int ODITHER_CELLS;
    private static int ODITHER_MASK;
    private static Byte[][] base_dither_matrix;
    private QuantizerType m_quantizer;
    private jpeg_decompress_struct m_cinfo;
    private Byte[][] m_sv_colormap;
    private int m_sv_actual;
    private Byte[][] m_colorindex;
    private Int32[] m_colorindexOffset;
    private bool m_is_padded;
    private Int32[] m_Ncolors;
    private int m_row_index;
    private Int32[][][] m_odither;
    private Int16[][] m_fserrors;
    private bool m_on_odd_row;
    public my_1pass_cquantizer(jpeg_decompress_struct cinfo);
    private static my_1pass_cquantizer();
    public virtual void start_pass(bool is_pre_scan);
    public virtual void color_quantize(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public virtual void finish_pass();
    public virtual void new_color_map();
    private void quantize(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void quantize3(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void quantize_ord_dither(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void quantize3_ord_dither(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void quantize_fs_dither(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void create_colormap();
    private void create_colorindex();
    private void create_odither_tables();
    private void alloc_fs_workspace();
    private static int largest_input_value(int j, int maxj);
    private static int output_value(int j, int maxj);
    private int select_ncolors(Int32[] Ncolors);
    private static Int32[][] make_odither_array(int ncolors);
}
internal class BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer : object {
    private static int MAXNUMCOLORS;
    private static int HIST_C0_BITS;
    private static int HIST_C1_BITS;
    private static int HIST_C2_BITS;
    private static int HIST_C0_ELEMS;
    private static int HIST_C1_ELEMS;
    private static int HIST_C2_ELEMS;
    private static int C0_SHIFT;
    private static int C1_SHIFT;
    private static int C2_SHIFT;
    private static int R_SCALE;
    private static int G_SCALE;
    private static int B_SCALE;
    private static int BOX_C0_LOG;
    private static int BOX_C1_LOG;
    private static int BOX_C2_LOG;
    private static int BOX_C0_ELEMS;
    private static int BOX_C1_ELEMS;
    private static int BOX_C2_ELEMS;
    private static int BOX_C0_SHIFT;
    private static int BOX_C1_SHIFT;
    private static int BOX_C2_SHIFT;
    private QuantizerType m_quantizer;
    private bool m_useFinishPass1;
    private jpeg_decompress_struct m_cinfo;
    private Byte[][] m_sv_colormap;
    private int m_desired;
    private UInt16[][] m_histogram;
    private bool m_needs_zeroed;
    private Int16[] m_fserrors;
    private bool m_on_odd_row;
    private Int32[] m_error_limiter;
    public my_2pass_cquantizer(jpeg_decompress_struct cinfo);
    public virtual void start_pass(bool is_pre_scan);
    public virtual void color_quantize(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public virtual void finish_pass();
    public virtual void new_color_map();
    private void prescan_quantize(Byte[][] input_buf, int in_row, int num_rows);
    private void pass2_fs_dither(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void pass2_no_dither(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void finish_pass1();
    private void compute_color(box[] boxlist, int boxIndex, int icolor);
    private void select_colors(int desired_colors);
    private int median_cut(box[] boxlist, int numboxes, int desired_colors);
    private static int find_biggest_color_pop(box[] boxlist, int numboxes);
    private static int find_biggest_volume(box[] boxlist, int numboxes);
    private void update_box(box[] boxlist, int boxIndex);
    private void init_error_limit();
    private int find_nearby_colors(int minc0, int minc1, int minc2, Byte[] colorlist);
    private void find_best_colors(int minc0, int minc1, int minc2, int numcolors, Byte[] colorlist, Byte[] bestcolor);
    private void fill_inverse_cmap(int c0, int c1, int c2);
}
internal class BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller : object {
    private J_BUF_MODE m_passModeSetByLastStartPass;
    private jpeg_compress_struct m_cinfo;
    private int m_iMCU_row_num;
    private int m_mcu_ctr;
    private int m_MCU_vert_offset;
    private int m_MCU_rows_per_iMCU_row;
    private JBLOCK[][] m_MCU_buffer;
    private jvirt_array`1[] m_whole_image;
    public my_c_coef_controller(jpeg_compress_struct cinfo, bool need_full_buffer);
    public virtual void start_pass(J_BUF_MODE pass_mode);
    public virtual bool compress_data(Byte[][][] input_buf);
    private bool compressDataImpl(Byte[][][] input_buf);
    private bool compressFirstPass(Byte[][][] input_buf);
    private bool compressOutput();
    private void start_iMCU_row();
}
internal class BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr : jpeg_destination_mgr {
    private static int OUTPUT_BUF_SIZE;
    private jpeg_compress_struct m_cinfo;
    private Stream m_outfile;
    private Byte[] m_buffer;
    public my_destination_mgr(jpeg_compress_struct cinfo, Stream alreadyOpenFile);
    public virtual void init_destination();
    public virtual bool empty_output_buffer();
    public virtual void term_destination();
    private void writeBuffer(int dataCount);
}
internal class BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler : jpeg_upsampler {
    private static int SCALEBITS;
    private static int ONE_HALF;
    private jpeg_decompress_struct m_cinfo;
    private bool m_use_2v_upsample;
    private Int32[] m_Cr_r_tab;
    private Int32[] m_Cb_b_tab;
    private Int32[] m_Cr_g_tab;
    private Int32[] m_Cb_g_tab;
    private Byte[] m_spare_row;
    private bool m_spare_full;
    private int m_out_row_width;
    private int m_rows_to_go;
    public my_merged_upsampler(jpeg_decompress_struct cinfo);
    public virtual void start_pass();
    public virtual void upsample(ComponentBuffer[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void merged_1v_upsample(ComponentBuffer[] input_buf, Int32& in_row_group_ctr, Byte[][] output_buf, Int32& out_row_ctr);
    private void merged_2v_upsample(ComponentBuffer[] input_buf, Int32& in_row_group_ctr, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void h2v1_merged_upsample(ComponentBuffer[] input_buf, int in_row_group_ctr, Byte[][] output_buf, int outRow);
    private void h2v2_merged_upsample(ComponentBuffer[] input_buf, int in_row_group_ctr, Byte[][] output_buf);
    private void build_ycc_rgb_table();
    private void build_bg_ycc_rgb_table();
    private static int FIX(double x);
}
internal class BitMiracle.LibJpeg.Classic.Internal.my_source_mgr : jpeg_source_mgr {
    private static int INPUT_BUF_SIZE;
    private jpeg_decompress_struct m_cinfo;
    private Stream m_infile;
    private Byte[] m_buffer;
    private bool m_start_of_file;
    public my_source_mgr(jpeg_decompress_struct cinfo);
    public void Attach(Stream infile);
    public virtual void init_source();
    public virtual bool fill_input_buffer();
}
internal class BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller : object {
    private jpeg_compress_struct m_cinfo;
    private int m_iMCU_row_num;
    private int m_mcu_ctr;
    private int m_MCU_vert_offset;
    private int m_MCU_rows_per_iMCU_row;
    private jvirt_array`1[] m_whole_image;
    private JBLOCK[][] m_dummy_buffer;
    public my_trans_c_coef_controller(jpeg_compress_struct cinfo, jvirt_array`1[] coef_arrays);
    public virtual void start_pass(J_BUF_MODE pass_mode);
    public virtual bool compress_data(Byte[][][] input_buf);
    private void start_iMCU_row();
}
internal class BitMiracle.LibJpeg.Classic.Internal.my_upsampler : jpeg_upsampler {
    private jpeg_decompress_struct m_cinfo;
    private ComponentBuffer[] m_color_buf;
    private Int32[] m_perComponentOffsets;
    private ComponentUpsampler[] m_upsampleMethods;
    private int m_currentComponent;
    private int m_upsampleRowOffset;
    private int m_next_row_out;
    private int m_rows_to_go;
    private Int32[] m_rowgroup_height;
    private Byte[] m_h_expand;
    private Byte[] m_v_expand;
    public my_upsampler(jpeg_decompress_struct cinfo);
    public virtual void start_pass();
    public virtual void upsample(ComponentBuffer[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void upsampleComponent(ComponentBuffer input_data);
    private static void noop_upsample();
    private void fullsize_upsample(ComponentBuffer input_data);
    private void h2v1_upsample(ComponentBuffer input_data);
    private void h2v2_upsample(ComponentBuffer input_data);
    private void int_upsample(ComponentBuffer input_data);
}
internal enum BitMiracle.LibJpeg.Classic.J_COLOR_SPACE : Enum {
    public int value__;
    public static J_COLOR_SPACE JCS_UNKNOWN;
    public static J_COLOR_SPACE JCS_GRAYSCALE;
    public static J_COLOR_SPACE JCS_RGB;
    public static J_COLOR_SPACE JCS_YCbCr;
    public static J_COLOR_SPACE JCS_CMYK;
    public static J_COLOR_SPACE JCS_YCCK;
    public static J_COLOR_SPACE JCS_BG_RGB;
    public static J_COLOR_SPACE JCS_BG_YCC;
    public static J_COLOR_SPACE JCS_NCHANNEL;
}
internal enum BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM : Enum {
    public int value__;
    public static J_COLOR_TRANSFORM JCT_NONE;
    public static J_COLOR_TRANSFORM JCT_SUBTRACT_GREEN;
}
internal enum BitMiracle.LibJpeg.Classic.J_DCT_METHOD : Enum {
    public int value__;
    public static J_DCT_METHOD JDCT_ISLOW;
    public static J_DCT_METHOD JDCT_IFAST;
    public static J_DCT_METHOD JDCT_FLOAT;
}
internal enum BitMiracle.LibJpeg.Classic.J_DITHER_MODE : Enum {
    public int value__;
    public static J_DITHER_MODE JDITHER_NONE;
    public static J_DITHER_MODE JDITHER_ORDERED;
    public static J_DITHER_MODE JDITHER_FS;
}
internal enum BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE : Enum {
    public int value__;
    public static J_MESSAGE_CODE JMSG_NOMESSAGE;
    public static J_MESSAGE_CODE JERR_BAD_BUFFER_MODE;
    public static J_MESSAGE_CODE JERR_BAD_COMPONENT_ID;
    public static J_MESSAGE_CODE JERR_BAD_CROP_SPEC;
    public static J_MESSAGE_CODE JERR_BAD_DCT_COEF;
    public static J_MESSAGE_CODE JERR_BAD_DCTSIZE;
    public static J_MESSAGE_CODE JERR_BAD_DROP_SAMPLING;
    public static J_MESSAGE_CODE JERR_BAD_HUFF_TABLE;
    public static J_MESSAGE_CODE JERR_BAD_IN_COLORSPACE;
    public static J_MESSAGE_CODE JERR_BAD_J_COLORSPACE;
    public static J_MESSAGE_CODE JERR_BAD_LENGTH;
    public static J_MESSAGE_CODE JERR_BAD_MCU_SIZE;
    public static J_MESSAGE_CODE JERR_BAD_PRECISION;
    public static J_MESSAGE_CODE JERR_BAD_PROGRESSION;
    public static J_MESSAGE_CODE JERR_BAD_PROG_SCRIPT;
    public static J_MESSAGE_CODE JERR_BAD_SAMPLING;
    public static J_MESSAGE_CODE JERR_BAD_SCAN_SCRIPT;
    public static J_MESSAGE_CODE JERR_BAD_STATE;
    public static J_MESSAGE_CODE JERR_BAD_VIRTUAL_ACCESS;
    public static J_MESSAGE_CODE JERR_BUFFER_SIZE;
    public static J_MESSAGE_CODE JERR_CANT_SUSPEND;
    public static J_MESSAGE_CODE JERR_CCIR601_NOTIMPL;
    public static J_MESSAGE_CODE JERR_COMPONENT_COUNT;
    public static J_MESSAGE_CODE JERR_CONVERSION_NOTIMPL;
    public static J_MESSAGE_CODE JERR_DAC_INDEX;
    public static J_MESSAGE_CODE JERR_DAC_VALUE;
    public static J_MESSAGE_CODE JERR_DHT_INDEX;
    public static J_MESSAGE_CODE JERR_DQT_INDEX;
    public static J_MESSAGE_CODE JERR_EMPTY_IMAGE;
    public static J_MESSAGE_CODE JERR_EOI_EXPECTED;
    public static J_MESSAGE_CODE JERR_FILE_WRITE;
    public static J_MESSAGE_CODE JERR_FRACT_SAMPLE_NOTIMPL;
    public static J_MESSAGE_CODE JERR_HUFF_CLEN_OVERFLOW;
    public static J_MESSAGE_CODE JERR_HUFF_MISSING_CODE;
    public static J_MESSAGE_CODE JERR_IMAGE_TOO_BIG;
    public static J_MESSAGE_CODE JERR_INPUT_EMPTY;
    public static J_MESSAGE_CODE JERR_INPUT_EOF;
    public static J_MESSAGE_CODE JERR_MISMATCHED_QUANT_TABLE;
    public static J_MESSAGE_CODE JERR_MISSING_DATA;
    public static J_MESSAGE_CODE JERR_MODE_CHANGE;
    public static J_MESSAGE_CODE JERR_NOTIMPL;
    public static J_MESSAGE_CODE JERR_NOT_COMPILED;
    public static J_MESSAGE_CODE JERR_NO_ARITH_TABLE;
    public static J_MESSAGE_CODE JERR_NO_HUFF_TABLE;
    public static J_MESSAGE_CODE JERR_NO_IMAGE;
    public static J_MESSAGE_CODE JERR_NO_QUANT_TABLE;
    public static J_MESSAGE_CODE JERR_NO_SOI;
    public static J_MESSAGE_CODE JERR_OUT_OF_MEMORY;
    public static J_MESSAGE_CODE JERR_QUANT_COMPONENTS;
    public static J_MESSAGE_CODE JERR_QUANT_FEW_COLORS;
    public static J_MESSAGE_CODE JERR_QUANT_MANY_COLORS;
    public static J_MESSAGE_CODE JERR_SOF_BEFORE;
    public static J_MESSAGE_CODE JERR_SOF_DUPLICATE;
    public static J_MESSAGE_CODE JERR_SOF_NO_SOS;
    public static J_MESSAGE_CODE JERR_SOF_UNSUPPORTED;
    public static J_MESSAGE_CODE JERR_SOI_DUPLICATE;
    public static J_MESSAGE_CODE JERR_SOS_NO_SOF;
    public static J_MESSAGE_CODE JERR_TOO_LITTLE_DATA;
    public static J_MESSAGE_CODE JERR_UNKNOWN_MARKER;
    public static J_MESSAGE_CODE JERR_WIDTH_OVERFLOW;
    public static J_MESSAGE_CODE JTRC_16BIT_TABLES;
    public static J_MESSAGE_CODE JTRC_ADOBE;
    public static J_MESSAGE_CODE JTRC_APP0;
    public static J_MESSAGE_CODE JTRC_APP14;
    public static J_MESSAGE_CODE JTRC_DAC;
    public static J_MESSAGE_CODE JTRC_DHT;
    public static J_MESSAGE_CODE JTRC_DQT;
    public static J_MESSAGE_CODE JTRC_DRI;
    public static J_MESSAGE_CODE JTRC_EOI;
    public static J_MESSAGE_CODE JTRC_HUFFBITS;
    public static J_MESSAGE_CODE JTRC_JFIF;
    public static J_MESSAGE_CODE JTRC_JFIF_BADTHUMBNAILSIZE;
    public static J_MESSAGE_CODE JTRC_JFIF_EXTENSION;
    public static J_MESSAGE_CODE JTRC_JFIF_THUMBNAIL;
    public static J_MESSAGE_CODE JTRC_MISC_MARKER;
    public static J_MESSAGE_CODE JTRC_PARMLESS_MARKER;
    public static J_MESSAGE_CODE JTRC_QUANTVALS;
    public static J_MESSAGE_CODE JTRC_QUANT_3_NCOLORS;
    public static J_MESSAGE_CODE JTRC_QUANT_NCOLORS;
    public static J_MESSAGE_CODE JTRC_QUANT_SELECTED;
    public static J_MESSAGE_CODE JTRC_RECOVERY_ACTION;
    public static J_MESSAGE_CODE JTRC_RST;
    public static J_MESSAGE_CODE JTRC_SMOOTH_NOTIMPL;
    public static J_MESSAGE_CODE JTRC_SOF;
    public static J_MESSAGE_CODE JTRC_SOF_COMPONENT;
    public static J_MESSAGE_CODE JTRC_SOI;
    public static J_MESSAGE_CODE JTRC_SOS;
    public static J_MESSAGE_CODE JTRC_SOS_COMPONENT;
    public static J_MESSAGE_CODE JTRC_SOS_PARAMS;
    public static J_MESSAGE_CODE JTRC_THUMB_JPEG;
    public static J_MESSAGE_CODE JTRC_THUMB_PALETTE;
    public static J_MESSAGE_CODE JTRC_THUMB_RGB;
    public static J_MESSAGE_CODE JTRC_UNKNOWN_IDS;
    public static J_MESSAGE_CODE JWRN_ADOBE_XFORM;
    public static J_MESSAGE_CODE JWRN_ARITH_BAD_CODE;
    public static J_MESSAGE_CODE JWRN_BOGUS_PROGRESSION;
    public static J_MESSAGE_CODE JWRN_EXTRANEOUS_DATA;
    public static J_MESSAGE_CODE JWRN_HIT_MARKER;
    public static J_MESSAGE_CODE JWRN_HUFF_BAD_CODE;
    public static J_MESSAGE_CODE JWRN_JFIF_MAJOR;
    public static J_MESSAGE_CODE JWRN_JPEG_EOF;
    public static J_MESSAGE_CODE JWRN_MUST_RESYNC;
    public static J_MESSAGE_CODE JWRN_NOT_SEQUENTIAL;
    public static J_MESSAGE_CODE JWRN_TOO_MUCH_DATA;
    public static J_MESSAGE_CODE JMSG_UNKNOWNMSGCODE;
    public static J_MESSAGE_CODE JMSG_LASTMSGCODE;
}
[DefaultMemberAttribute("Item")]
internal class BitMiracle.LibJpeg.Classic.JBLOCK : object {
    internal Int16[] data;
    public short Item { get; public set; }
    public short get_Item(int index);
    public void set_Item(int index, short value);
}
internal class BitMiracle.LibJpeg.Classic.JHUFF_TBL : object {
    private Byte[] m_bits;
    private Byte[] m_huffval;
    private bool m_sent_table;
    internal Byte[] Bits { get; }
    internal Byte[] Huffval { get; }
    public bool Sent_table { get; public set; }
    internal Byte[] get_Bits();
    internal Byte[] get_Huffval();
    public bool get_Sent_table();
    public void set_Sent_table(bool value);
}
internal abstract class BitMiracle.LibJpeg.Classic.jpeg_common_struct : object {
    internal jpeg_error_mgr m_err;
    internal jpeg_progress_mgr m_progress;
    internal JpegState m_global_state;
    public bool IsDecompressor { get; }
    public jpeg_progress_mgr Progress { get; public set; }
    public jpeg_error_mgr Err { get; public set; }
    public static string Version { get; }
    public static string Copyright { get; }
    protected jpeg_common_struct(jpeg_error_mgr errorManager);
    public abstract virtual bool get_IsDecompressor();
    public jpeg_progress_mgr get_Progress();
    public void set_Progress(jpeg_progress_mgr value);
    public jpeg_error_mgr get_Err();
    public void set_Err(jpeg_error_mgr value);
    public static string get_Version();
    public static string get_Copyright();
    public static jvirt_array`1<byte> CreateSamplesArray(int samplesPerRow, int numberOfRows);
    public static jvirt_array`1<JBLOCK> CreateBlocksArray(int blocksPerRow, int numberOfRows);
    public static Byte[][] AllocJpegSamples(int samplesPerRow, int numberOfRows);
    private static JBLOCK[][] allocJpegBlocks(int blocksPerRow, int numberOfRows);
    public void jpeg_abort();
    public void jpeg_destroy();
    public void ERREXIT(J_MESSAGE_CODE code);
    public void ERREXIT(J_MESSAGE_CODE code, Object[] args);
    public void ERREXIT(int code, Object[] args);
    public void WARNMS(J_MESSAGE_CODE code);
    public void WARNMS(J_MESSAGE_CODE code, Object[] args);
    public void WARNMS(int code, Object[] args);
    public void TRACEMS(int lvl, J_MESSAGE_CODE code);
    public void TRACEMS(int lvl, J_MESSAGE_CODE code, Object[] args);
    public void TRACEMS(int lvl, int code, Object[] args);
}
internal class BitMiracle.LibJpeg.Classic.jpeg_component_info : object {
    private int component_id;
    private int component_index;
    private int h_samp_factor;
    private int v_samp_factor;
    private int quant_tbl_no;
    private int dc_tbl_no;
    private int ac_tbl_no;
    private int width_in_blocks;
    internal int height_in_blocks;
    internal int DCT_h_scaled_size;
    internal int DCT_v_scaled_size;
    internal int downsampled_width;
    internal int downsampled_height;
    internal bool component_needed;
    internal int MCU_width;
    internal int MCU_height;
    internal int MCU_blocks;
    internal int MCU_sample_width;
    internal int last_col_width;
    internal int last_row_height;
    internal JQUANT_TBL quant_table;
    public int Component_id { get; public set; }
    public int Component_index { get; public set; }
    public int H_samp_factor { get; public set; }
    public int V_samp_factor { get; public set; }
    public int Quant_tbl_no { get; public set; }
    public int Dc_tbl_no { get; public set; }
    public int Ac_tbl_no { get; public set; }
    public int Width_in_blocks { get; public set; }
    public int Downsampled_width { get; }
    internal void Assign(jpeg_component_info ci);
    public int get_Component_id();
    public void set_Component_id(int value);
    public int get_Component_index();
    public void set_Component_index(int value);
    public int get_H_samp_factor();
    public void set_H_samp_factor(int value);
    public int get_V_samp_factor();
    public void set_V_samp_factor(int value);
    public int get_Quant_tbl_no();
    public void set_Quant_tbl_no(int value);
    public int get_Dc_tbl_no();
    public void set_Dc_tbl_no(int value);
    public int get_Ac_tbl_no();
    public void set_Ac_tbl_no(int value);
    public int get_Width_in_blocks();
    public void set_Width_in_blocks(int value);
    public int get_Downsampled_width();
    internal static jpeg_component_info[] createArrayOfComponents(int length);
}
internal class BitMiracle.LibJpeg.Classic.jpeg_compress_struct : jpeg_common_struct {
    private static Int32[] std_luminance_quant_tbl;
    private static Int32[] std_chrominance_quant_tbl;
    private static Byte[] bits_dc_luminance;
    private static Byte[] val_dc_luminance;
    private static Byte[] bits_dc_chrominance;
    private static Byte[] val_dc_chrominance;
    private static Byte[] bits_ac_luminance;
    private static Byte[] val_ac_luminance;
    private static Byte[] bits_ac_chrominance;
    private static Byte[] val_ac_chrominance;
    internal jpeg_destination_mgr m_dest;
    internal int m_image_width;
    internal int m_image_height;
    internal int m_input_components;
    internal J_COLOR_SPACE m_in_color_space;
    public int scale_num;
    public int scale_denom;
    internal int jpeg_width;
    internal int jpeg_height;
    internal int m_data_precision;
    internal int m_num_components;
    internal J_COLOR_SPACE m_jpeg_color_space;
    private jpeg_component_info[] m_comp_info;
    internal JQUANT_TBL[] m_quant_tbl_ptrs;
    public Int32[] q_scale_factor;
    internal JHUFF_TBL[] m_dc_huff_tbl_ptrs;
    internal JHUFF_TBL[] m_ac_huff_tbl_ptrs;
    internal Byte[] arith_dc_L;
    internal Byte[] arith_dc_U;
    internal Byte[] arith_ac_K;
    internal int m_num_scans;
    internal jpeg_scan_info[] m_scan_info;
    internal bool m_raw_data_in;
    internal bool arith_code;
    internal bool m_optimize_coding;
    internal bool m_CCIR601_sampling;
    public bool do_fancy_downsampling;
    internal int m_smoothing_factor;
    internal J_DCT_METHOD m_dct_method;
    internal int m_restart_interval;
    internal int m_restart_in_rows;
    internal bool m_write_JFIF_header;
    internal byte m_JFIF_major_version;
    internal byte m_JFIF_minor_version;
    internal DensityUnit m_density_unit;
    internal short m_X_density;
    internal short m_Y_density;
    internal bool m_write_Adobe_marker;
    public J_COLOR_TRANSFORM color_transform;
    internal int m_next_scanline;
    internal bool m_progressive_mode;
    internal int m_max_h_samp_factor;
    internal int m_max_v_samp_factor;
    internal int min_DCT_h_scaled_size;
    internal int min_DCT_v_scaled_size;
    internal int m_total_iMCU_rows;
    internal int m_comps_in_scan;
    internal Int32[] m_cur_comp_info;
    internal int m_MCUs_per_row;
    internal int m_MCU_rows_in_scan;
    internal int m_blocks_in_MCU;
    internal Int32[] m_MCU_membership;
    internal int m_Ss;
    internal int m_Se;
    internal int m_Ah;
    internal int m_Al;
    public int block_size;
    internal Int32[] natural_order;
    internal int lim_Se;
    internal jpeg_comp_master m_master;
    internal jpeg_c_main_controller m_main;
    internal jpeg_c_prep_controller m_prep;
    internal jpeg_c_coef_controller m_coef;
    internal jpeg_marker_writer m_marker;
    internal jpeg_color_converter m_cconvert;
    internal jpeg_downsampler m_downsample;
    internal jpeg_forward_dct m_fdct;
    internal jpeg_entropy_encoder m_entropy;
    internal jpeg_scan_info[] m_script_space;
    internal int m_script_space_size;
    public bool IsDecompressor { get; }
    public jpeg_destination_mgr Dest { get; public set; }
    public int Image_width { get; public set; }
    public int Image_height { get; public set; }
    public int Input_components { get; public set; }
    public J_COLOR_SPACE In_color_space { get; public set; }
    public int Data_precision { get; public set; }
    public int Num_components { get; public set; }
    public J_COLOR_SPACE Jpeg_color_space { get; public set; }
    public bool Raw_data_in { get; public set; }
    public bool Optimize_coding { get; public set; }
    public bool CCIR601_sampling { get; public set; }
    public int Smoothing_factor { get; public set; }
    public J_DCT_METHOD Dct_method { get; public set; }
    public int Restart_interval { get; public set; }
    public int Restart_in_rows { get; public set; }
    public bool Write_JFIF_header { get; public set; }
    public byte JFIF_major_version { get; public set; }
    public byte JFIF_minor_version { get; public set; }
    public DensityUnit Density_unit { get; public set; }
    public short X_density { get; public set; }
    public short Y_density { get; public set; }
    public bool Write_Adobe_marker { get; public set; }
    public int Max_v_samp_factor { get; }
    public jpeg_component_info[] Component_info { get; }
    public JQUANT_TBL[] Quant_tbl_ptrs { get; }
    public JHUFF_TBL[] Dc_huff_tbl_ptrs { get; }
    public JHUFF_TBL[] Ac_huff_tbl_ptrs { get; }
    public int Next_scanline { get; }
    public jpeg_compress_struct(jpeg_error_mgr errorManager);
    private static jpeg_compress_struct();
    public virtual bool get_IsDecompressor();
    public jpeg_destination_mgr get_Dest();
    public void set_Dest(jpeg_destination_mgr value);
    public int get_Image_width();
    public void set_Image_width(int value);
    public int get_Image_height();
    public void set_Image_height(int value);
    public int get_Input_components();
    public void set_Input_components(int value);
    public J_COLOR_SPACE get_In_color_space();
    public void set_In_color_space(J_COLOR_SPACE value);
    public int get_Data_precision();
    public void set_Data_precision(int value);
    public int get_Num_components();
    public void set_Num_components(int value);
    public J_COLOR_SPACE get_Jpeg_color_space();
    public void set_Jpeg_color_space(J_COLOR_SPACE value);
    public bool get_Raw_data_in();
    public void set_Raw_data_in(bool value);
    public bool get_Optimize_coding();
    public void set_Optimize_coding(bool value);
    public bool get_CCIR601_sampling();
    public void set_CCIR601_sampling(bool value);
    public int get_Smoothing_factor();
    public void set_Smoothing_factor(int value);
    public J_DCT_METHOD get_Dct_method();
    public void set_Dct_method(J_DCT_METHOD value);
    public int get_Restart_interval();
    public void set_Restart_interval(int value);
    public int get_Restart_in_rows();
    public void set_Restart_in_rows(int value);
    public bool get_Write_JFIF_header();
    public void set_Write_JFIF_header(bool value);
    public byte get_JFIF_major_version();
    public void set_JFIF_major_version(byte value);
    public byte get_JFIF_minor_version();
    public void set_JFIF_minor_version(byte value);
    public DensityUnit get_Density_unit();
    public void set_Density_unit(DensityUnit value);
    public short get_X_density();
    public void set_X_density(short value);
    public short get_Y_density();
    public void set_Y_density(short value);
    public bool get_Write_Adobe_marker();
    public void set_Write_Adobe_marker(bool value);
    public int get_Max_v_samp_factor();
    public jpeg_component_info[] get_Component_info();
    public JQUANT_TBL[] get_Quant_tbl_ptrs();
    public JHUFF_TBL[] get_Dc_huff_tbl_ptrs();
    public JHUFF_TBL[] get_Ac_huff_tbl_ptrs();
    public int get_Next_scanline();
    public void jpeg_abort_compress();
    public void jpeg_suppress_tables(bool suppress);
    public void jpeg_finish_compress();
    public void jpeg_write_marker(int marker, Byte[] data);
    public void jpeg_write_m_header(int marker, int datalen);
    public void jpeg_write_m_byte(byte val);
    public void jpeg_write_tables();
    public void jpeg_stdio_dest(Stream outfile);
    public void jpeg_set_defaults();
    public void jpeg_set_colorspace(J_COLOR_SPACE colorspace);
    public void jpeg_default_colorspace();
    public void jpeg_set_quality(int quality, bool force_baseline);
    public void jpeg_default_qtables(bool force_baseline);
    public void jpeg_set_linear_quality(int scale_factor, bool force_baseline);
    public void jpeg_add_quant_table(int which_tbl, Int32[] basic_table, int scale_factor, bool force_baseline);
    public static int jpeg_quality_scaling(int quality);
    public void jpeg_simple_progression();
    public void jpeg_start_compress(bool write_all_tables);
    public int jpeg_write_scanlines(Byte[][] scanlines, int num_lines);
    public int jpeg_write_raw_data(Byte[][][] data, int num_lines);
    public void jpeg_write_coefficients(jvirt_array`1[] coef_arrays);
    private void jpeg_calc_jpeg_dimensions();
    private void jpeg_calc_trans_dimensions();
    private void initialize();
    private void jinit_compress_master();
    private void jinit_c_master_control(bool transcode_only);
    private void jinit_c_main_controller(bool need_full_buffer);
    private void transencode_master_selection(jvirt_array`1[] coef_arrays);
    private void initial_setup(bool transcode_only);
    private void validate_script();
    private void reduce_script();
    private void std_huff_tables();
    private void add_huff_table(JHUFF_TBL& htblptr, Byte[] bits, Byte[] val);
    private void fill_a_scan(Int32& scanIndex, int ci, int Ss, int Se, int Ah, int Al);
    private void fill_dc_scans(Int32& scanIndex, int ncomps, int Ah, int Al);
    private void fill_scans(Int32& scanIndex, int ncomps, int Ss, int Se, int Ah, int Al);
    private void jpeg_set_colorspace_SET_COMP(int index, int id, int hsamp, int vsamp, int quant, int dctbl, int actbl);
}
internal class BitMiracle.LibJpeg.Classic.jpeg_decompress_struct : jpeg_common_struct {
    internal jpeg_source_mgr m_src;
    internal int m_image_width;
    internal int m_image_height;
    internal int m_num_components;
    internal J_COLOR_SPACE m_jpeg_color_space;
    internal J_COLOR_SPACE m_out_color_space;
    internal int m_scale_num;
    internal int m_scale_denom;
    internal bool m_buffered_image;
    internal bool m_raw_data_out;
    internal J_DCT_METHOD m_dct_method;
    internal bool m_do_fancy_upsampling;
    internal bool m_do_block_smoothing;
    internal bool m_quantize_colors;
    internal J_DITHER_MODE m_dither_mode;
    internal bool m_two_pass_quantize;
    internal int m_desired_number_of_colors;
    internal bool m_enable_1pass_quant;
    internal bool m_enable_external_quant;
    internal bool m_enable_2pass_quant;
    internal int m_output_width;
    internal int m_output_height;
    internal int m_out_color_components;
    internal int m_output_components;
    internal int m_rec_outbuf_height;
    internal int m_actual_number_of_colors;
    internal Byte[][] m_colormap;
    internal int m_output_scanline;
    internal int m_input_scan_number;
    internal int m_input_iMCU_row;
    internal int m_output_scan_number;
    internal int m_output_iMCU_row;
    internal Int32[][] m_coef_bits;
    internal JQUANT_TBL[] m_quant_tbl_ptrs;
    internal JHUFF_TBL[] m_dc_huff_tbl_ptrs;
    internal JHUFF_TBL[] m_ac_huff_tbl_ptrs;
    internal int m_data_precision;
    private jpeg_component_info[] m_comp_info;
    internal bool is_baseline;
    internal bool m_progressive_mode;
    internal bool arith_code;
    internal Byte[] arith_dc_L;
    internal Byte[] arith_dc_U;
    internal Byte[] arith_ac_K;
    internal int m_restart_interval;
    internal bool m_saw_JFIF_marker;
    internal byte m_JFIF_major_version;
    internal byte m_JFIF_minor_version;
    internal DensityUnit m_density_unit;
    internal short m_X_density;
    internal short m_Y_density;
    internal bool m_saw_Adobe_marker;
    internal byte m_Adobe_transform;
    internal J_COLOR_TRANSFORM color_transform;
    internal bool m_CCIR601_sampling;
    internal List`1<jpeg_marker_struct> m_marker_list;
    internal int m_max_h_samp_factor;
    internal int m_max_v_samp_factor;
    internal int min_DCT_h_scaled_size;
    internal int min_DCT_v_scaled_size;
    internal int m_total_iMCU_rows;
    internal Byte[] m_sample_range_limit;
    internal int m_sampleRangeLimitOffset;
    internal int m_comps_in_scan;
    internal Int32[] m_cur_comp_info;
    internal int m_MCUs_per_row;
    internal int m_MCU_rows_in_scan;
    internal int m_blocks_in_MCU;
    internal Int32[] m_MCU_membership;
    internal int m_Ss;
    internal int m_Se;
    internal int m_Ah;
    internal int m_Al;
    internal int block_size;
    internal Int32[] natural_order;
    internal int lim_Se;
    internal int m_unread_marker;
    internal jpeg_decomp_master m_master;
    internal jpeg_d_main_controller m_main;
    internal jpeg_d_coef_controller m_coef;
    internal jpeg_d_post_controller m_post;
    internal jpeg_input_controller m_inputctl;
    internal jpeg_marker_reader m_marker;
    internal jpeg_entropy_decoder m_entropy;
    internal jpeg_inverse_dct m_idct;
    internal jpeg_upsampler m_upsample;
    internal jpeg_color_deconverter m_cconvert;
    internal jpeg_color_quantizer m_cquantize;
    public bool IsDecompressor { get; }
    public jpeg_source_mgr Src { get; public set; }
    public int Image_width { get; }
    public int Image_height { get; }
    public int Num_components { get; }
    public J_COLOR_SPACE Jpeg_color_space { get; public set; }
    public ReadOnlyCollection`1<jpeg_marker_struct> Marker_list { get; }
    public J_COLOR_SPACE Out_color_space { get; public set; }
    public int Scale_num { get; public set; }
    public int Scale_denom { get; public set; }
    public bool Buffered_image { get; public set; }
    public bool Raw_data_out { get; public set; }
    public J_DCT_METHOD Dct_method { get; public set; }
    public bool Do_fancy_upsampling { get; public set; }
    public bool Do_block_smoothing { get; public set; }
    public bool Quantize_colors { get; public set; }
    public J_DITHER_MODE Dither_mode { get; public set; }
    public bool Two_pass_quantize { get; public set; }
    public int Desired_number_of_colors { get; public set; }
    public bool Enable_1pass_quant { get; public set; }
    public bool Enable_external_quant { get; public set; }
    public bool Enable_2pass_quant { get; public set; }
    public int Output_width { get; }
    public int Output_height { get; }
    public int Out_color_components { get; }
    public int Output_components { get; }
    public int Rec_outbuf_height { get; }
    public int Actual_number_of_colors { get; public set; }
    public Byte[][] Colormap { get; public set; }
    public int Output_scanline { get; }
    public int Input_scan_number { get; }
    public int Input_iMCU_row { get; }
    public int Output_scan_number { get; }
    public int Output_iMCU_row { get; }
    public Int32[][] Coef_bits { get; }
    public DensityUnit Density_unit { get; }
    public short X_density { get; }
    public short Y_density { get; }
    public int Data_precision { get; }
    public int Max_v_samp_factor { get; }
    public int Unread_marker { get; }
    public jpeg_component_info[] Comp_info { get; internal set; }
    public jpeg_decompress_struct(jpeg_error_mgr errorManager);
    public virtual bool get_IsDecompressor();
    public jpeg_source_mgr get_Src();
    public void set_Src(jpeg_source_mgr value);
    public int get_Image_width();
    public int get_Image_height();
    public int get_Num_components();
    public J_COLOR_SPACE get_Jpeg_color_space();
    public void set_Jpeg_color_space(J_COLOR_SPACE value);
    public ReadOnlyCollection`1<jpeg_marker_struct> get_Marker_list();
    public J_COLOR_SPACE get_Out_color_space();
    public void set_Out_color_space(J_COLOR_SPACE value);
    public int get_Scale_num();
    public void set_Scale_num(int value);
    public int get_Scale_denom();
    public void set_Scale_denom(int value);
    public bool get_Buffered_image();
    public void set_Buffered_image(bool value);
    public bool get_Raw_data_out();
    public void set_Raw_data_out(bool value);
    public J_DCT_METHOD get_Dct_method();
    public void set_Dct_method(J_DCT_METHOD value);
    public bool get_Do_fancy_upsampling();
    public void set_Do_fancy_upsampling(bool value);
    public bool get_Do_block_smoothing();
    public void set_Do_block_smoothing(bool value);
    public bool get_Quantize_colors();
    public void set_Quantize_colors(bool value);
    public J_DITHER_MODE get_Dither_mode();
    public void set_Dither_mode(J_DITHER_MODE value);
    public bool get_Two_pass_quantize();
    public void set_Two_pass_quantize(bool value);
    public int get_Desired_number_of_colors();
    public void set_Desired_number_of_colors(int value);
    public bool get_Enable_1pass_quant();
    public void set_Enable_1pass_quant(bool value);
    public bool get_Enable_external_quant();
    public void set_Enable_external_quant(bool value);
    public bool get_Enable_2pass_quant();
    public void set_Enable_2pass_quant(bool value);
    public int get_Output_width();
    public int get_Output_height();
    public int get_Out_color_components();
    public int get_Output_components();
    public int get_Rec_outbuf_height();
    public int get_Actual_number_of_colors();
    public void set_Actual_number_of_colors(int value);
    public Byte[][] get_Colormap();
    public void set_Colormap(Byte[][] value);
    public int get_Output_scanline();
    public int get_Input_scan_number();
    public int get_Input_iMCU_row();
    public int get_Output_scan_number();
    public int get_Output_iMCU_row();
    public Int32[][] get_Coef_bits();
    public DensityUnit get_Density_unit();
    public short get_X_density();
    public short get_Y_density();
    public int get_Data_precision();
    public int get_Max_v_samp_factor();
    public int get_Unread_marker();
    public jpeg_component_info[] get_Comp_info();
    internal void set_Comp_info(jpeg_component_info[] value);
    public void jpeg_stdio_src(Stream infile);
    public ReadResult jpeg_read_header(bool require_image);
    public bool jpeg_start_decompress();
    public int jpeg_read_scanlines(Byte[][] scanlines, int max_lines);
    public bool jpeg_finish_decompress();
    public int jpeg_read_raw_data(Byte[][][] data, int max_lines);
    public bool jpeg_has_multiple_scans();
    public bool jpeg_start_output(int scan_number);
    public bool jpeg_finish_output();
    public bool jpeg_input_complete();
    public ReadResult jpeg_consume_input();
    public void jpeg_calc_output_dimensions();
    public jvirt_array`1[] jpeg_read_coefficients();
    public void jpeg_copy_critical_parameters(jpeg_compress_struct dstinfo);
    public void jpeg_abort_decompress();
    public void jpeg_set_marker_processor(int marker_code, jpeg_marker_parser_method routine);
    public void jpeg_save_markers(int marker_code, int length_limit);
    internal bool use_merged_upsample();
    private void initialize();
    private void transdecode_master_selection();
    private bool output_pass_setup();
    private void default_decompress_parms();
    private void jpeg_consume_input_start();
    private ReadResult jpeg_consume_input_inHeader();
}
internal abstract class BitMiracle.LibJpeg.Classic.jpeg_destination_mgr : object {
    private Byte[] m_buffer;
    private int m_position;
    private int m_free_in_buffer;
    protected int freeInBuffer { get; }
    public abstract virtual void init_destination();
    public abstract virtual bool empty_output_buffer();
    public abstract virtual void term_destination();
    public virtual bool emit_byte(int val);
    protected void initInternalBuffer(Byte[] buffer, int offset);
    protected int get_freeInBuffer();
}
internal class BitMiracle.LibJpeg.Classic.jpeg_error_mgr : object {
    internal int m_msg_code;
    internal Object[] m_msg_parm;
    internal int m_trace_level;
    internal int m_num_warnings;
    public int Trace_level { get; public set; }
    public int Num_warnings { get; }
    public int get_Trace_level();
    public void set_Trace_level(int value);
    public int get_Num_warnings();
    public virtual void error_exit();
    public virtual void emit_message(int msg_level);
    public virtual void output_message();
    public virtual string format_message();
    public virtual void reset_error_mgr();
    protected virtual string GetMessageText(int code);
}
internal enum BitMiracle.LibJpeg.Classic.JPEG_MARKER : Enum {
    public int value__;
    public static JPEG_MARKER SOF0;
    public static JPEG_MARKER SOF1;
    public static JPEG_MARKER SOF2;
    public static JPEG_MARKER SOF3;
    public static JPEG_MARKER SOF5;
    public static JPEG_MARKER SOF6;
    public static JPEG_MARKER SOF7;
    public static JPEG_MARKER JPG;
    public static JPEG_MARKER SOF9;
    public static JPEG_MARKER SOF10;
    public static JPEG_MARKER SOF11;
    public static JPEG_MARKER SOF13;
    public static JPEG_MARKER SOF14;
    public static JPEG_MARKER SOF15;
    public static JPEG_MARKER DHT;
    public static JPEG_MARKER DAC;
    public static JPEG_MARKER RST0;
    public static JPEG_MARKER RST1;
    public static JPEG_MARKER RST2;
    public static JPEG_MARKER RST3;
    public static JPEG_MARKER RST4;
    public static JPEG_MARKER RST5;
    public static JPEG_MARKER RST6;
    public static JPEG_MARKER RST7;
    public static JPEG_MARKER SOI;
    public static JPEG_MARKER EOI;
    public static JPEG_MARKER SOS;
    public static JPEG_MARKER DQT;
    public static JPEG_MARKER DNL;
    public static JPEG_MARKER DRI;
    public static JPEG_MARKER DHP;
    public static JPEG_MARKER EXP;
    public static JPEG_MARKER APP0;
    public static JPEG_MARKER APP1;
    public static JPEG_MARKER APP2;
    public static JPEG_MARKER APP3;
    public static JPEG_MARKER APP4;
    public static JPEG_MARKER APP5;
    public static JPEG_MARKER APP6;
    public static JPEG_MARKER APP7;
    public static JPEG_MARKER APP8;
    public static JPEG_MARKER APP9;
    public static JPEG_MARKER APP10;
    public static JPEG_MARKER APP11;
    public static JPEG_MARKER APP12;
    public static JPEG_MARKER APP13;
    public static JPEG_MARKER APP14;
    public static JPEG_MARKER APP15;
    public static JPEG_MARKER JPG0;
    public static JPEG_MARKER JPG8;
    public static JPEG_MARKER JPG13;
    public static JPEG_MARKER COM;
    public static JPEG_MARKER TEM;
    public static JPEG_MARKER ERROR;
}
internal class BitMiracle.LibJpeg.Classic.jpeg_marker_struct : object {
    private byte m_marker;
    private int m_originalLength;
    private Byte[] m_data;
    public byte Marker { get; }
    public int OriginalLength { get; }
    public Byte[] Data { get; }
    internal jpeg_marker_struct(byte marker, int originalDataLength, int lengthLimit);
    public byte get_Marker();
    public int get_OriginalLength();
    public Byte[] get_Data();
}
internal class BitMiracle.LibJpeg.Classic.jpeg_progress_mgr : object {
    private int m_passCounter;
    private int m_passLimit;
    private int m_completedPasses;
    private int m_totalPasses;
    [CompilerGeneratedAttribute]
private EventHandler OnProgress;
    public int Pass_counter { get; public set; }
    public int Pass_limit { get; public set; }
    public int Completed_passes { get; public set; }
    public int Total_passes { get; public set; }
    [CompilerGeneratedAttribute]
public void add_OnProgress(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnProgress(EventHandler value);
    public int get_Pass_counter();
    public void set_Pass_counter(int value);
    public int get_Pass_limit();
    public void set_Pass_limit(int value);
    public int get_Completed_passes();
    public void set_Completed_passes(int value);
    public int get_Total_passes();
    public void set_Total_passes(int value);
    public void Updated();
}
internal abstract class BitMiracle.LibJpeg.Classic.jpeg_source_mgr : object {
    private Byte[] m_next_input_byte;
    private int m_bytes_in_buffer;
    private int m_position;
    public abstract virtual void init_source();
    public abstract virtual bool fill_input_buffer();
    protected void initInternalBuffer(Byte[] buffer, int size);
    public virtual void skip_input_data(int num_bytes);
    public virtual bool resync_to_restart(jpeg_decompress_struct cinfo, int desired);
    public virtual void term_source();
    public virtual bool GetTwoBytes(Int32& V);
    public virtual bool GetByte(Int32& V);
    public virtual int GetBytes(Byte[] dest, int amount);
    public virtual bool MakeByteAvailable();
}
internal static class BitMiracle.LibJpeg.Classic.JpegConstants : object {
    public static int DCTSIZE;
    public static int DCTSIZE2;
    public static int NUM_QUANT_TBLS;
    public static int NUM_HUFF_TBLS;
    public static int NUM_ARITH_TBLS;
    public static int MAX_COMPS_IN_SCAN;
    public static int C_MAX_BLOCKS_IN_MCU;
    public static int D_MAX_BLOCKS_IN_MCU;
    public static int MAX_SAMP_FACTOR;
    public static int MAX_COMPONENTS;
    public static int BITS_IN_JSAMPLE;
    public static J_DCT_METHOD JDCT_DEFAULT;
    public static J_DCT_METHOD JDCT_FASTEST;
    public static int JPEG_MAX_DIMENSION;
    public static int MAXJSAMPLE;
    public static int CENTERJSAMPLE;
    public static int RGB_RED;
    public static int RGB_GREEN;
    public static int RGB_BLUE;
    public static int RGB_PIXELSIZE;
    public static int HUFF_LOOKAHEAD;
}
internal class BitMiracle.LibJpeg.Classic.JQUANT_TBL : object {
    private bool m_sent_table;
    internal Int16[] quantval;
    public bool Sent_table { get; public set; }
    public bool get_Sent_table();
    public void set_Sent_table(bool value);
}
internal class BitMiracle.LibJpeg.Classic.jvirt_array`1 : object {
    private jpeg_common_struct m_cinfo;
    private T[][] m_buffer;
    public jpeg_common_struct ErrorProcessor { get; public set; }
    internal jvirt_array`1(int width, int height, Allocator<T> allocator);
    public jpeg_common_struct get_ErrorProcessor();
    public void set_ErrorProcessor(jpeg_common_struct value);
    public T[][] Access(int startRow, int numberOfRows);
}
internal enum BitMiracle.LibJpeg.Classic.ReadResult : Enum {
    public int value__;
    public static ReadResult JPEG_SUSPENDED;
    public static ReadResult JPEG_HEADER_OK;
    public static ReadResult JPEG_HEADER_TABLES_ONLY;
    public static ReadResult JPEG_REACHED_SOS;
    public static ReadResult JPEG_REACHED_EOI;
    public static ReadResult JPEG_ROW_COMPLETED;
    public static ReadResult JPEG_SCAN_COMPLETED;
}
public enum BitMiracle.LibTiff.Classic.CleanFaxData : Enum {
    public int value__;
    public static CleanFaxData CLEAN;
    public static CleanFaxData REGENERATED;
    public static CleanFaxData UNCLEAN;
}
public enum BitMiracle.LibTiff.Classic.ColorResponseUnit : Enum {
    public int value__;
    public static ColorResponseUnit CRU10S;
    public static ColorResponseUnit CRU100S;
    public static ColorResponseUnit CRU1000S;
    public static ColorResponseUnit CRU10000S;
    public static ColorResponseUnit CRU100000S;
}
public enum BitMiracle.LibTiff.Classic.Compression : Enum {
    public int value__;
    public static Compression NONE;
    public static Compression CCITTRLE;
    public static Compression CCITTFAX3;
    public static Compression CCITT_T4;
    public static Compression CCITTFAX4;
    public static Compression CCITT_T6;
    public static Compression LZW;
    public static Compression OJPEG;
    public static Compression JPEG;
    public static Compression NEXT;
    public static Compression CCITTRLEW;
    public static Compression PACKBITS;
    public static Compression THUNDERSCAN;
    public static Compression IT8CTPAD;
    public static Compression IT8LW;
    public static Compression IT8MP;
    public static Compression IT8BL;
    public static Compression PIXARFILM;
    public static Compression PIXARLOG;
    public static Compression DEFLATE;
    public static Compression ADOBE_DEFLATE;
    public static Compression DCS;
    public static Compression JBIG;
    public static Compression SGILOG;
    public static Compression SGILOG24;
    public static Compression JP2000;
}
public enum BitMiracle.LibTiff.Classic.ExtraSample : Enum {
    public int value__;
    public static ExtraSample UNSPECIFIED;
    public static ExtraSample ASSOCALPHA;
    public static ExtraSample UNASSALPHA;
}
[FlagsAttribute]
public enum BitMiracle.LibTiff.Classic.FaxMode : Enum {
    public int value__;
    public static FaxMode CLASSIC;
    public static FaxMode NORTC;
    public static FaxMode NOEOL;
    public static FaxMode BYTEALIGN;
    public static FaxMode WORDALIGN;
    public static FaxMode CLASSF;
}
public static class BitMiracle.LibTiff.Classic.FieldBit : object {
    internal static int SetLongs;
    internal static short ImageDimensions;
    internal static short TileDimensions;
    internal static short Resolution;
    internal static short Position;
    internal static short SubFileType;
    internal static short BitsPerSample;
    internal static short Compression;
    internal static short Photometric;
    internal static short Thresholding;
    internal static short FillOrder;
    internal static short Orientation;
    internal static short SamplesPerPixel;
    internal static short RowsPerStrip;
    internal static short MinSampleValue;
    internal static short MaxSampleValue;
    internal static short PlanarConfig;
    internal static short ResolutionUnit;
    internal static short PageNumber;
    internal static short StripByteCounts;
    internal static short StripOffsets;
    internal static short ColorMap;
    internal static short ExtraSamples;
    internal static short SampleFormat;
    internal static short SMinSampleValue;
    internal static short SMaxSampleValue;
    internal static short ImageDepth;
    internal static short TileDepth;
    internal static short HalftoneHints;
    internal static short YCbCrSubsampling;
    internal static short YCbCrPositioning;
    internal static short RefBlackWhite;
    internal static short TransferFunction;
    internal static short InkNames;
    internal static short SubIFD;
    public static short Ignore;
    public static short Pseudo;
    public static short Custom;
    public static short Codec;
    public static short Last;
}
public class BitMiracle.LibTiff.Classic.FieldValue : ValueType {
    private object m_value;
    public object Value { get; }
    internal FieldValue(object o);
    internal static FieldValue[] FromParams(Object[] list);
    internal void Set(object o);
    public object get_Value();
    public byte ToByte();
    public short ToShort();
    [CLSCompliantAttribute("False")]
public ushort ToUShort();
    public int ToInt();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt();
    public long ToLong();
    public float ToFloat();
    public double ToDouble();
    public virtual string ToString();
    public Byte[] GetBytes();
    public Byte[] ToByteArray();
    public Int16[] ToShortArray();
    [CLSCompliantAttribute("False")]
public UInt16[] ToUShortArray();
    public Int32[] ToIntArray();
    [CLSCompliantAttribute("False")]
public UInt32[] ToUIntArray();
    public Int64[] TolongArray();
    public Single[] ToFloatArray();
    public Double[] ToDoubleArray();
}
[FlagsAttribute]
public enum BitMiracle.LibTiff.Classic.FileType : Enum {
    public int value__;
    public static FileType REDUCEDIMAGE;
    public static FileType PAGE;
    public static FileType MASK;
}
public enum BitMiracle.LibTiff.Classic.FillOrder : Enum {
    public int value__;
    public static FillOrder MSB2LSB;
    public static FillOrder LSB2MSB;
}
public enum BitMiracle.LibTiff.Classic.GrayResponseUnit : Enum {
    public int value__;
    public static GrayResponseUnit GRU10S;
    public static GrayResponseUnit GRU100S;
    public static GrayResponseUnit GRU1000S;
    public static GrayResponseUnit GRU10000S;
    public static GrayResponseUnit GRU100000S;
}
[FlagsAttribute]
public enum BitMiracle.LibTiff.Classic.Group3Opt : Enum {
    public int value__;
    public static Group3Opt UNKNOWN;
    public static Group3Opt ENCODING2D;
    public static Group3Opt UNCOMPRESSED;
    public static Group3Opt FILLBITS;
}
public enum BitMiracle.LibTiff.Classic.InkSet : Enum {
    public int value__;
    public static InkSet CMYK;
    public static InkSet MULTIINK;
}
internal class BitMiracle.LibTiff.Classic.Internal.CCITTCodec : TiffCodec {
    public static int FIELD_BADFAXLINES;
    public static int FIELD_CLEANFAXDATA;
    public static int FIELD_BADFAXRUN;
    public static int FIELD_RECVPARAMS;
    public static int FIELD_SUBADDRESS;
    public static int FIELD_RECVTIME;
    public static int FIELD_FAXDCS;
    public static int FIELD_OPTIONS;
    internal FaxMode m_mode;
    internal Group3Opt m_groupoptions;
    internal CleanFaxData m_cleanfaxdata;
    internal int m_badfaxlines;
    internal int m_badfaxrun;
    internal int m_recvparams;
    internal string m_subaddress;
    internal int m_recvtime;
    internal string m_faxdcs;
    internal FaxFillFunc fill;
    private static int EOL_CODE;
    private static byte S_Null;
    private static byte S_Pass;
    private static byte S_Horiz;
    private static byte S_V0;
    private static byte S_VR;
    private static byte S_VL;
    private static byte S_Ext;
    private static byte S_TermW;
    private static byte S_TermB;
    private static byte S_MakeUpW;
    private static byte S_MakeUpB;
    private static byte S_MakeUp;
    private static byte S_EOL;
    private static short G3CODE_EOL;
    private static short G3CODE_INVALID;
    private static short G3CODE_EOF;
    private static short G3CODE_INCOMP;
    private static TiffFieldInfo[] m_faxFieldInfo;
    private static TiffFieldInfo[] m_fax3FieldInfo;
    private static TiffFieldInfo[] m_fax4FieldInfo;
    private TiffTagMethods m_parentTagMethods;
    private TiffTagMethods m_tagMethods;
    private int m_rw_mode;
    private int m_rowbytes;
    private int m_rowpixels;
    private Decoder m_decoder;
    private Byte[] m_bitmap;
    private int m_data;
    private int m_bit;
    private int m_EOLcnt;
    private Int32[] m_runs;
    private int m_refruns;
    private int m_curruns;
    private int m_a0;
    private int m_RunLength;
    private int m_thisrun;
    private int m_pa;
    private int m_pb;
    private Fax3Encoder m_encoder;
    private bool m_encodingFax4;
    private Byte[] m_refline;
    private int m_k;
    private int m_maxk;
    private int m_line;
    private Byte[] m_buffer;
    private int m_offset;
    private static Int32[] m_faxMainTable;
    private static Int32[] m_faxWhiteTable;
    private static Int32[] m_faxBlackTable;
    private static Int16[] m_faxWhiteCodes;
    private static Int16[] m_faxBlackCodes;
    private static tableEntry m_horizcode;
    private static tableEntry m_passcode;
    private static tableEntry[] m_vcodes;
    private static Int32[] m_msbmask;
    private static Byte[] m_zeroruns;
    private static Byte[] m_oneruns;
    private static Byte[] fillMasks;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public CCITTCodec(Tiff tif, Compression scheme, string name);
    private static CCITTCodec();
    private void cleanState();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Close();
    public virtual void Cleanup();
    private bool is2DEncoding();
    private void CHECK_b1(Int32& b1);
    private static void SWAP(Int32& a, Int32& b);
    private static bool isLongAligned(int offset);
    private static bool isShortAligned(int offset);
    private static void FILL(int n, Byte[] cp, Int32& offset, byte value);
    private static void fax3FillRuns(Byte[] buffer, int offset, Int32[] runs, int thisRunOffset, int nextRunOffset, int width);
    private static int find0span(Byte[] bp, int bpOffset, int bs, int be);
    private static int find1span(Byte[] bp, int bpOffset, int bs, int be);
    private static int finddiff(Byte[] bp, int bpOffset, int _bs, int _be, int _color);
    private static int finddiff2(Byte[] bp, int bpOffset, int _bs, int _be, int _color);
    private bool EndOfData();
    private int GetBits(int n);
    private void ClrBits(int n);
    private bool NeedBits8(int n);
    private bool NeedBits16(int n);
    private bool LOOKUP8(faxTableEntry& TabEnt, int wid);
    private bool LOOKUP16(faxTableEntry& TabEnt, int wid, bool useBlack);
    private bool SYNC_EOL();
    private bool setupState();
    private void Fax3Unexpected(string module);
    private void Fax3Extension(string module);
    private void Fax3BadLength(string module);
    private void Fax3PrematureEOF(string module);
    private bool Fax3Decode1D(Byte[] buffer, int offset, int count);
    private bool Fax3Decode2D(Byte[] buffer, int offset, int count);
    private bool Fax3Encode1DRow();
    private bool Fax3Encode2DRow();
    private static int Fax3Encode2DRow_Pixel(Byte[] buf, int bufOffset, int ix);
    private bool Fax3Encode(Byte[] buffer, int offset, int count);
    private bool Fax3PostEncode();
    private void InitCCITTFax3();
    private bool TIFFInitCCITTFax3();
    private void flushBits();
    private void putBits(int bits, int length);
    private void putcode(tableEntry te);
    private void putspan(int span, bool useBlack);
    private void Fax3PutEOL();
    private void SETVALUE(int x);
    private void CLEANUP_RUNS(string module);
    private void handlePrematureEOFinExpand2D(string module);
    private bool EXPAND1D(string module);
    private bool EXPAND2D(string module, int b1);
    private bool TIFFInitCCITTRLE();
    private bool TIFFInitCCITTRLEW();
    private bool Fax3DecodeRLE(Byte[] buffer, int offset, int count);
    private bool TIFFInitCCITTFax4();
    private bool Fax4Decode(Byte[] buffer, int offset, int count);
    private bool Fax4Encode(Byte[] buffer, int offset, int count);
    private bool Fax4PostEncode();
}
internal class BitMiracle.LibTiff.Classic.Internal.CCITTCodecTagMethods : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal class BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor : TiffCodec {
    public static int FIELD_PREDICTOR;
    private static TiffFieldInfo[] m_predictFieldInfo;
    private Predictor m_predictor;
    private int m_stride;
    private int m_rowSize;
    private TiffTagMethods m_parentTagMethods;
    private TiffTagMethods m_tagMethods;
    private TiffTagMethods m_childTagMethods;
    private bool m_passThruDecode;
    private bool m_passThruEncode;
    private PredictorType m_predictorType;
    public CodecWithPredictor(Tiff tif, Compression scheme, string name);
    private static CodecWithPredictor();
    public void TIFFPredictorInit(TiffTagMethods tagMethods);
    public void TIFFPredictorCleanup();
    public virtual bool SetupDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_setupdecode();
    public virtual bool predictor_decoderow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_decodestrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_decodetile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_setupencode();
    public virtual bool predictor_encoderow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_encodestrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_encodetile(Byte[] buffer, int offset, int count, short plane);
    public Predictor GetPredictorValue();
    public void SetPredictorValue(Predictor value);
    public TiffTagMethods GetChildTagMethods();
    private void predictorFunc(Byte[] buffer, int offset, int count);
    private void horAcc8(Byte[] buffer, int offset, int count);
    private void horAcc16(Byte[] buffer, int offset, int count);
    private void horAcc32(Byte[] buffer, int offset, int count);
    private void swabHorAcc16(Byte[] buffer, int offset, int count);
    private void swabHorAcc32(Byte[] buffer, int offset, int count);
    private void horDiff8(Byte[] buffer, int offset, int count);
    private void horDiff16(Byte[] buffer, int offset, int count);
    private void horDiff32(Byte[] buffer, int offset, int count);
    private void fpAcc(Byte[] buffer, int offset, int count);
    private void fpDiff(Byte[] buffer, int offset, int count);
    private bool PredictorDecodeRow(Byte[] buffer, int offset, int count, short plane);
    private bool PredictorDecodeTile(Byte[] buffer, int offset, int count, short plane);
    private bool PredictorEncodeRow(Byte[] buffer, int offset, int count, short plane);
    private bool PredictorEncodeTile(Byte[] buffer, int offset, int count, short plane);
    private bool PredictorSetupDecode();
    private bool PredictorSetupEncode();
    private bool PredictorSetup();
}
internal class BitMiracle.LibTiff.Classic.Internal.CodecWithPredictorTagMethods : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal class BitMiracle.LibTiff.Classic.Internal.DeflateCodec : CodecWithPredictor {
    public static int ZSTATE_INIT_DECODE;
    public static int ZSTATE_INIT_ENCODE;
    public ZStream m_stream;
    public int m_zipquality;
    public int m_state;
    private static TiffFieldInfo[] zipFieldInfo;
    private TiffTagMethods m_tagMethods;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public DeflateCodec(Tiff tif, Compression scheme, string name);
    private static DeflateCodec();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual void Cleanup();
    public virtual bool predictor_setupdecode();
    public virtual bool predictor_decoderow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_decodestrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_decodetile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_setupencode();
    public virtual bool predictor_encoderow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_encodestrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_encodetile(Byte[] buffer, int offset, int count, short plane);
    private void ZIPCleanup();
    private bool ZIPDecode(Byte[] buffer, int offset, int count, short plane);
    private bool ZIPEncode(Byte[] buffer, int offset, int count, short plane);
    private bool ZIPPostEncode();
    private bool ZIPPreDecode(short s);
    private bool ZIPPreEncode(short s);
    private bool ZIPSetupDecode();
    private bool ZIPSetupEncode();
}
internal class BitMiracle.LibTiff.Classic.Internal.DeflateCodecTagMethods : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
}
internal class BitMiracle.LibTiff.Classic.Internal.DumpModeCodec : TiffCodec {
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public DumpModeCodec(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool Seek(int row);
    private bool DumpModeEncode(Byte[] buffer, int offset, int count, short plane);
    private bool DumpModeDecode(Byte[] buffer, int offset, int count, short plane);
}
internal class BitMiracle.LibTiff.Classic.Internal.JpegCodec : TiffCodec {
    public static int FIELD_JPEGTABLES;
    public static int FIELD_RECVPARAMS;
    public static int FIELD_SUBADDRESS;
    public static int FIELD_RECVTIME;
    public static int FIELD_FAXDCS;
    internal jpeg_compress_struct m_compression;
    internal jpeg_decompress_struct m_decompression;
    internal jpeg_common_struct m_common;
    internal int m_h_sampling;
    internal int m_v_sampling;
    internal Byte[] m_jpegtables;
    internal int m_jpegtables_length;
    internal int m_jpegquality;
    internal JpegColorMode m_jpegcolormode;
    internal JpegTablesMode m_jpegtablesmode;
    internal bool m_ycbcrsampling_fetched;
    internal int m_recvparams;
    internal string m_subaddress;
    internal int m_recvtime;
    internal string m_faxdcs;
    private static TiffFieldInfo[] jpegFieldInfo;
    private bool m_rawDecode;
    private bool m_rawEncode;
    private TiffTagMethods m_tagMethods;
    private TiffTagMethods m_parentTagMethods;
    private bool m_cinfo_initialized;
    internal jpeg_error_mgr m_err;
    private Photometric m_photometric;
    private int m_bytesperline;
    private Byte[][][] m_ds_buffer;
    private int m_scancount;
    private int m_samplesperclump;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public JpegCodec(Tiff tif, Compression scheme, string name);
    private static JpegCodec();
    private void cleanState();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Cleanup();
    public virtual int DefStripSize(int size);
    public virtual void DefTileSize(Int32& width, Int32& height);
    public bool InitializeLibJPEG(bool force_encode, bool force_decode);
    public Tiff GetTiff();
    public void JPEGResetUpsampled();
    private bool JPEGPreEncode(short s);
    private bool JPEGSetupEncode();
    private bool JPEGPostEncode();
    private void JPEGCleanup();
    private bool JPEGPreDecode(short s);
    private bool prepare_JPEGTables();
    private bool JPEGSetupDecode();
    private int TIFFjpeg_read_scanlines(Byte[][] scanlines, int max_lines);
    private bool JPEGDecode(Byte[] buffer, int offset, int count, short plane);
    private bool JPEGDecodeRaw(Byte[] buffer, int offset, int count, short plane);
    private bool JPEGEncode(Byte[] buffer, int offset, int count, short plane);
    private bool JPEGEncodeRaw(Byte[] buffer, int offset, int count, short plane);
    private int JPEGDefaultStripSize(int s);
    private void JPEGDefaultTileSize(Int32& tw, Int32& th);
    private bool TIFFjpeg_create_compress();
    private bool TIFFjpeg_create_decompress();
    private bool TIFFjpeg_set_defaults();
    private bool TIFFjpeg_set_colorspace(J_COLOR_SPACE colorspace);
    private bool TIFFjpeg_set_quality(int quality, bool force_baseline);
    private bool TIFFjpeg_suppress_tables(bool suppress);
    private bool TIFFjpeg_start_compress(bool write_all_tables);
    private int TIFFjpeg_write_scanlines(Byte[][] scanlines, int num_lines);
    private int TIFFjpeg_write_raw_data(Byte[][][] data, int num_lines);
    private bool TIFFjpeg_finish_compress();
    private bool TIFFjpeg_write_tables();
    private ReadResult TIFFjpeg_read_header(bool require_image);
    private bool TIFFjpeg_start_decompress();
    private int TIFFjpeg_read_raw_data(Byte[][][] data, int max_lines);
    private bool TIFFjpeg_finish_decompress();
    private bool TIFFjpeg_abort();
    private bool TIFFjpeg_destroy();
    private static Byte[][] TIFFjpeg_alloc_sarray(int samplesperrow, int numrows);
    private bool alloc_downsampled_buffers(jpeg_component_info[] comp_info, int num_components);
    private void unsuppress_quant_table(int tblno);
    private void unsuppress_huff_table(int tblno);
    private void TIFFjpeg_data_dest();
    private bool TIFFjpeg_tables_dest();
}
internal class BitMiracle.LibTiff.Classic.Internal.JpegCodecTagMethods : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
    private static void JPEGFixupTestSubsampling(Tiff tif);
}
internal class BitMiracle.LibTiff.Classic.Internal.JpegErrorManager : jpeg_error_mgr {
    private JpegCodec m_sp;
    public JpegErrorManager(JpegCodec sp);
    public virtual void error_exit();
    public virtual void output_message();
}
internal class BitMiracle.LibTiff.Classic.Internal.JpegStdDestination : jpeg_destination_mgr {
    private Tiff m_tif;
    public JpegStdDestination(Tiff tif);
    public virtual void init_destination();
    public virtual bool empty_output_buffer();
    public virtual void term_destination();
}
internal class BitMiracle.LibTiff.Classic.Internal.JpegStdSource : jpeg_source_mgr {
    private static Byte[] dummy_EOI;
    protected JpegCodec m_sp;
    public JpegStdSource(JpegCodec sp);
    private static JpegStdSource();
    public virtual void init_source();
    public virtual bool fill_input_buffer();
}
internal class BitMiracle.LibTiff.Classic.Internal.JpegTablesDestination : jpeg_destination_mgr {
    private JpegCodec m_sp;
    public JpegTablesDestination(JpegCodec sp);
    public virtual void init_destination();
    public virtual bool empty_output_buffer();
    public virtual void term_destination();
}
internal class BitMiracle.LibTiff.Classic.Internal.JpegTablesSource : JpegStdSource {
    public JpegTablesSource(JpegCodec sp);
    public virtual void init_source();
}
internal class BitMiracle.LibTiff.Classic.Internal.LZWCodec : CodecWithPredictor {
    private bool LZW_CHECKEOS;
    private static short BITS_MIN;
    private static short BITS_MAX;
    private static short CODE_CLEAR;
    private static short CODE_EOI;
    private static short CODE_FIRST;
    private static short CODE_MAX;
    private static short CODE_MIN;
    private static int HSIZE;
    private static int HSHIFT;
    private static int CSIZE;
    private static int CHECK_GAP;
    private bool m_compatDecode;
    private short m_nbits;
    private short m_maxcode;
    private short m_free_ent;
    private int m_nextdata;
    private int m_nextbits;
    private int m_rw_mode;
    private int m_dec_nbitsmask;
    private int m_dec_restart;
    private long m_dec_bitsleft;
    private bool m_oldStyleCodeFound;
    private int m_dec_codep;
    private int m_dec_oldcodep;
    private int m_dec_free_entp;
    private int m_dec_maxcodep;
    private code_t[] m_dec_codetab;
    private int m_enc_oldcode;
    private int m_enc_checkpoint;
    private int m_enc_ratio;
    private int m_enc_incount;
    private int m_enc_outcount;
    private int m_enc_rawlimit;
    private hash_t[] m_enc_hashtab;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public LZWCodec(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual void Cleanup();
    public virtual bool predictor_setupdecode();
    public virtual bool predictor_decoderow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_decodestrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_decodetile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_setupencode();
    public virtual bool predictor_encoderow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_encodestrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool predictor_encodetile(Byte[] buffer, int offset, int count, short plane);
    private bool LZWSetupDecode();
    private bool LZWPreDecode(short s);
    private bool LZWDecode(Byte[] buffer, int offset, int count);
    private bool LZWDecodeCompat(Byte[] buffer, int offset, int count);
    private bool LZWDecodeImpl(Byte[] buffer, int offset, int count, bool compat, string callerName);
    private bool LZWSetupEncode();
    private bool LZWPreEncode(short s);
    private bool LZWPostEncode();
    private bool LZWEncode(Byte[] buffer, int offset, int count, short plane);
    private void LZWCleanup();
    private static int MAXCODE(int n);
    private void PutNextCode(int c);
    private void cl_hash();
    private void NextCode(Int16& _code, bool compat);
    private void GetNextCode(Int16& code);
    private void GetNextCodeCompat(Int16& code);
    private void codeLoop();
}
internal class BitMiracle.LibTiff.Classic.Internal.OJpegCodec : TiffCodec {
    internal static int FIELD_OJPEG_JPEGINTERCHANGEFORMAT;
    internal static int FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH;
    internal static int FIELD_OJPEG_JPEGQTABLES;
    internal static int FIELD_OJPEG_JPEGDCTABLES;
    internal static int FIELD_OJPEG_JPEGACTABLES;
    internal static int FIELD_OJPEG_JPEGPROC;
    internal static int FIELD_OJPEG_JPEGRESTARTINTERVAL;
    internal static int FIELD_OJPEG_COUNT;
    private static int OJPEG_BUFFER;
    private static TiffFieldInfo[] ojpeg_field_info;
    internal UInt32 m_jpeg_interchange_format;
    internal UInt32 m_jpeg_interchange_format_length;
    internal byte m_jpeg_proc;
    internal bool m_subsamplingcorrect_done;
    internal bool m_subsampling_tag;
    internal byte m_subsampling_hor;
    internal byte m_subsampling_ver;
    internal byte m_qtable_offset_count;
    internal byte m_dctable_offset_count;
    internal byte m_actable_offset_count;
    internal UInt32[] m_qtable_offset;
    internal UInt32[] m_dctable_offset;
    internal UInt32[] m_actable_offset;
    internal ushort m_restart_interval;
    internal jpeg_decompress_struct m_libjpeg_jpeg_decompress_struct;
    private TiffTagMethods m_tagMethods;
    private TiffTagMethods m_parentTagMethods;
    private UInt32 m_file_size;
    private UInt32 m_image_width;
    private UInt32 m_image_length;
    private UInt32 m_strile_width;
    private UInt32 m_strile_length;
    private UInt32 m_strile_length_total;
    private byte m_samples_per_pixel;
    private byte m_plane_sample_offset;
    private byte m_samples_per_pixel_per_plane;
    private bool m_subsamplingcorrect;
    private bool m_subsampling_force_desubsampling_inside_decompression;
    private Byte[][] m_qtable;
    private Byte[][] m_dctable;
    private Byte[][] m_actable;
    private byte m_restart_index;
    private bool m_sof_log;
    private byte m_sof_marker_id;
    private UInt32 m_sof_x;
    private UInt32 m_sof_y;
    private Byte[] m_sof_c;
    private Byte[] m_sof_hv;
    private Byte[] m_sof_tq;
    private Byte[] m_sos_cs;
    private Byte[] m_sos_tda;
    private SosEnd[] m_sos_end;
    private bool m_readheader_done;
    private bool m_writeheader_done;
    private short m_write_cursample;
    private UInt32 m_write_curstrile;
    private bool m_libjpeg_session_active;
    private byte m_libjpeg_jpeg_query_style;
    private jpeg_error_mgr m_libjpeg_jpeg_error_mgr;
    private jpeg_source_mgr m_libjpeg_jpeg_source_mgr;
    private bool m_subsampling_convert_log;
    private UInt32 m_subsampling_convert_ylinelen;
    private UInt32 m_subsampling_convert_ylines;
    private UInt32 m_subsampling_convert_clinelen;
    private UInt32 m_subsampling_convert_clines;
    private Byte[][] m_subsampling_convert_ybuf;
    private Byte[][] m_subsampling_convert_cbbuf;
    private Byte[][] m_subsampling_convert_crbuf;
    private Byte[][][] m_subsampling_convert_ycbcrimage;
    private UInt32 m_subsampling_convert_clinelenout;
    private UInt32 m_subsampling_convert_state;
    private UInt32 m_bytes_per_line;
    private UInt32 m_lines_per_strile;
    private OJPEGStateInBufferSource m_in_buffer_source;
    private UInt32 m_in_buffer_next_strile;
    private UInt32 m_in_buffer_strile_count;
    private UInt32 m_in_buffer_file_pos;
    private bool m_in_buffer_file_pos_log;
    private UInt32 m_in_buffer_file_togo;
    private ushort m_in_buffer_togo;
    private int m_in_buffer_cur;
    private Byte[] m_in_buffer;
    private OJPEGStateOutState m_out_state;
    private Byte[] m_out_buffer;
    private Byte[] m_skip_buffer;
    private bool m_forceProcessedRgbOutput;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public OJpegCodec(Tiff tif, Compression scheme, string name);
    private static OJpegCodec();
    private void cleanState();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public Tiff GetTiff();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Cleanup();
    internal void ForceProcessedRgbOutput(bool force);
    private bool OJPEGSetupDecode();
    private bool OJPEGPreDecode(short s);
    private bool OJPEGDecode(Byte[] buf, int offset, int cc, short s);
    private bool OJpegEncodeIsUnsupported();
    private void OJPEGCleanup();
    private bool OJPEGPreDecodeSkipRaw();
    private bool OJPEGPreDecodeSkipScanlines();
    private bool OJPEGDecodeRaw(Byte[] buf, int offset, int cc);
    private bool OJPEGDecodeScanlines(Byte[] buf, int offset, int cc);
    public void OJPEGSubsamplingCorrect();
    private bool OJPEGReadHeaderInfo();
    private bool OJPEGReadSecondarySos(short s);
    private bool OJPEGWriteHeaderInfo();
    private void OJPEGLibjpegSessionAbort();
    private bool OJPEGReadHeaderInfoSec();
    private bool OJPEGReadHeaderInfoSecStreamDri();
    private bool OJPEGReadHeaderInfoSecStreamDqt();
    private bool OJPEGReadHeaderInfoSecStreamDht();
    private bool OJPEGReadHeaderInfoSecStreamSof(byte marker_id);
    private bool OJPEGReadHeaderInfoSecStreamSos();
    private bool OJPEGReadHeaderInfoSecTablesQTable();
    private bool OJPEGReadHeaderInfoSecTablesDcTable();
    private bool OJPEGReadHeaderInfoSecTablesAcTable();
    private bool OJPEGReadBufferFill();
    private bool OJPEGReadByte(Byte& b);
    public bool OJPEGReadBytePeek(Byte& b);
    private void OJPEGReadByteAdvance();
    private bool OJPEGReadWord(UInt16& word);
    public bool OJPEGReadBlock(ushort len, Byte[] mem, int offset);
    private void OJPEGReadSkip(ushort len);
    internal bool OJPEGWriteStream(Byte[]& mem, UInt32& len);
    private void OJPEGWriteStreamSoi(Byte[]& mem, UInt32& len);
    private void OJPEGWriteStreamQTable(byte table_index, Byte[]& mem, UInt32& len);
    private void OJPEGWriteStreamDcTable(byte table_index, Byte[]& mem, UInt32& len);
    private void OJPEGWriteStreamAcTable(byte table_index, Byte[]& mem, UInt32& len);
    private void OJPEGWriteStreamDri(Byte[]& mem, UInt32& len);
    private void OJPEGWriteStreamSof(Byte[]& mem, UInt32& len);
    private void OJPEGWriteStreamSos(Byte[]& mem, UInt32& len);
    private bool OJPEGWriteStreamCompressed(Byte[]& mem, UInt32& len);
    private void OJPEGWriteStreamRst(Byte[]& mem, UInt32& len);
    private void OJPEGWriteStreamEoi(Byte[]& mem, UInt32& len);
    private bool jpeg_create_decompress_encap();
    private ReadResult jpeg_read_header_encap(bool require_image);
    private bool jpeg_start_decompress_encap();
    private int jpeg_read_scanlines_encap(Byte[] scanlines, int max_lines);
    private int jpeg_read_raw_data_encap(int max_lines);
}
internal class BitMiracle.LibTiff.Classic.Internal.OJpegCodecTagMethods : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal class BitMiracle.LibTiff.Classic.Internal.OJpegErrorManager : jpeg_error_mgr {
    private OJpegCodec m_sp;
    public OJpegErrorManager(OJpegCodec sp);
    public virtual void error_exit();
    public virtual void output_message();
}
internal class BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager : jpeg_source_mgr {
    protected OJpegCodec m_sp;
    public OJpegSrcManager(OJpegCodec sp);
    public virtual void init_source();
    public virtual bool fill_input_buffer();
    public virtual void skip_input_data(int num_bytes);
    public virtual bool resync_to_restart(jpeg_decompress_struct cinfo, int desired);
    public virtual void term_source();
}
internal class BitMiracle.LibTiff.Classic.Internal.PackBitsCodec : TiffCodec {
    private int m_rowsize;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public PackBitsCodec(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    private bool PackBitsPreEncode(short s);
    private bool PackBitsEncode(Byte[] buf, int offset, int cc, short s);
    private bool PackBitsEncodeChunk(Byte[] buffer, int offset, int count, short plane);
    private bool PackBitsDecode(Byte[] buffer, int offset, int count, short plane);
}
internal class BitMiracle.LibTiff.Classic.Internal.TagCompare : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal class BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB : object {
    public static int CIELABTORGB_TABLE_RANGE;
    private int range;
    private float rstep;
    private float gstep;
    private float bstep;
    private float X0;
    private float Y0;
    private float Z0;
    private TiffDisplay display;
    private Single[] Yr2r;
    private Single[] Yg2g;
    private Single[] Yb2b;
    public void Init(TiffDisplay refDisplay, Single[] refWhite);
    public void CIELabToXYZ(int l, int a, int b, Single& X, Single& Y, Single& Z);
    public void XYZToRGB(float X, float Y, float Z, Int32& r, Int32& g, Int32& b);
    private static int rInt(float R);
}
internal class BitMiracle.LibTiff.Classic.Internal.TiffDirectory : object {
    public Int32[] td_fieldsset;
    public int td_imagewidth;
    public int td_imagelength;
    public int td_imagedepth;
    public int td_tilewidth;
    public int td_tilelength;
    public int td_tiledepth;
    public FileType td_subfiletype;
    public short td_bitspersample;
    public SampleFormat td_sampleformat;
    public Compression td_compression;
    public Photometric td_photometric;
    public Threshold td_threshholding;
    public FillOrder td_fillorder;
    public Orientation td_orientation;
    public short td_samplesperpixel;
    public int td_rowsperstrip;
    public ushort td_minsamplevalue;
    public ushort td_maxsamplevalue;
    public double td_sminsamplevalue;
    public double td_smaxsamplevalue;
    public float td_xresolution;
    public float td_yresolution;
    public ResUnit td_resolutionunit;
    public PlanarConfig td_planarconfig;
    public float td_xposition;
    public float td_yposition;
    public Int16[] td_pagenumber;
    public Int16[][] td_colormap;
    public Int16[] td_halftonehints;
    public short td_extrasamples;
    public ExtraSample[] td_sampleinfo;
    public int td_stripsperimage;
    public int td_nstrips;
    public UInt64[] td_stripoffset;
    public UInt64[] td_stripbytecount;
    public bool td_stripbytecountsorted;
    public int td_nsubifd;
    public Int64[] td_subifd;
    public Int16[] td_ycbcrsubsampling;
    public YCbCrPosition td_ycbcrpositioning;
    public Single[] td_refblackwhite;
    public Int16[][] td_transferfunction;
    public int td_inknameslen;
    public string td_inknames;
    public int td_customValueCount;
    public TiffTagValue[] td_customValues;
}
internal class BitMiracle.LibTiff.Classic.Internal.TiffDirEntry : object {
    public TiffTag tdir_tag;
    public TiffType tdir_type;
    public int tdir_count;
    public ulong tdir_offset;
    public string ToString();
    public static int SizeInBytes(bool isBigTiff);
}
internal class BitMiracle.LibTiff.Classic.Internal.TiffDisplay : object {
    internal Single[][] d_mat;
    internal float d_YCR;
    internal float d_YCG;
    internal float d_YCB;
    internal int d_Vrwr;
    internal int d_Vrwg;
    internal int d_Vrwb;
    internal float d_Y0R;
    internal float d_Y0G;
    internal float d_Y0B;
    internal float d_gammaR;
    internal float d_gammaG;
    internal float d_gammaB;
    public TiffDisplay(Single[] mat0, Single[] mat1, Single[] mat2, float YCR, float YCG, float YCB, int Vrwr, int Vrwg, int Vrwb, float Y0R, float Y0G, float Y0B, float gammaR, float gammaG, float gammaB);
}
[FlagsAttribute]
internal enum BitMiracle.LibTiff.Classic.Internal.TiffFlags : Enum {
    public int value__;
    public static TiffFlags MSB2LSB;
    public static TiffFlags LSB2MSB;
    public static TiffFlags FILLORDER;
    public static TiffFlags DIRTYDIRECT;
    public static TiffFlags BUFFERSETUP;
    public static TiffFlags CODERSETUP;
    public static TiffFlags BEENWRITING;
    public static TiffFlags SWAB;
    public static TiffFlags NOBITREV;
    public static TiffFlags MYBUFFER;
    public static TiffFlags ISTILED;
    public static TiffFlags POSTENCODE;
    public static TiffFlags INSUBIFD;
    public static TiffFlags UPSAMPLED;
    public static TiffFlags STRIPCHOP;
    public static TiffFlags HEADERONLY;
    public static TiffFlags NOREADRAW;
    public static TiffFlags ISBIGTIFF;
    public static TiffFlags NOBIGTIFF;
}
internal class BitMiracle.LibTiff.Classic.Internal.TiffHeader : ValueType {
    public static int TIFF_MAGIC_SIZE;
    public static int TIFF_VERSION_SIZE;
    public static int TIFF_DIROFFSET_SIZE;
    public short tiff_magic;
    public short tiff_version;
    public ulong tiff_diroff;
    public short tiff_offsize;
    public short tiff_fill;
    public static int SizeInBytes(bool isBigTiff);
}
internal class BitMiracle.LibTiff.Classic.Internal.TiffTagValue : ValueType {
    public TiffFieldInfo info;
    public int count;
    public Byte[] value;
}
internal class BitMiracle.LibTiff.Classic.Internal.TiffYCbCrToRGB : object {
    private static int clamptabOffset;
    private static int SHIFT;
    private static int ONE_HALF;
    private Byte[] clamptab;
    private Int32[] Cr_r_tab;
    private Int32[] Cb_b_tab;
    private Int32[] Cr_g_tab;
    private Int32[] Cb_g_tab;
    private Int32[] Y_tab;
    public void Init(Single[] luma, Single[] refBlackWhite);
    public void YCbCrtoRGB(int Y, int Cb, int Cr, Int32& r, Int32& g, Int32& b);
    private static int fix(float x);
    private static int code2V(int c, float RB, float RW, float CR);
    private static int clamp(int f, int min, int max);
    private static int hiClamp(int f, int max);
}
public enum BitMiracle.LibTiff.Classic.JpegColorMode : Enum {
    public int value__;
    public static JpegColorMode RAW;
    public static JpegColorMode RGB;
}
public enum BitMiracle.LibTiff.Classic.JpegProc : Enum {
    public int value__;
    public static JpegProc BASELINE;
    public static JpegProc LOSSLESS;
}
[FlagsAttribute]
public enum BitMiracle.LibTiff.Classic.JpegTablesMode : Enum {
    public int value__;
    public static JpegTablesMode NONE;
    public static JpegTablesMode QUANT;
    public static JpegTablesMode HUFF;
}
public enum BitMiracle.LibTiff.Classic.OFileType : Enum {
    public int value__;
    public static OFileType IMAGE;
    public static OFileType REDUCEDIMAGE;
    public static OFileType PAGE;
}
public enum BitMiracle.LibTiff.Classic.Orientation : Enum {
    public int value__;
    public static Orientation TOPLEFT;
    public static Orientation TOPRIGHT;
    public static Orientation BOTRIGHT;
    public static Orientation BOTLEFT;
    public static Orientation LEFTTOP;
    public static Orientation RIGHTTOP;
    public static Orientation RIGHTBOT;
    public static Orientation LEFTBOT;
}
public enum BitMiracle.LibTiff.Classic.Photometric : Enum {
    public int value__;
    public static Photometric MINISWHITE;
    public static Photometric MINISBLACK;
    public static Photometric RGB;
    public static Photometric PALETTE;
    public static Photometric MASK;
    public static Photometric SEPARATED;
    public static Photometric YCBCR;
    public static Photometric CIELAB;
    public static Photometric ICCLAB;
    public static Photometric ITULAB;
    public static Photometric LOGL;
    public static Photometric LOGLUV;
}
public enum BitMiracle.LibTiff.Classic.PlanarConfig : Enum {
    public int value__;
    public static PlanarConfig UNKNOWN;
    public static PlanarConfig CONTIG;
    public static PlanarConfig SEPARATE;
}
public enum BitMiracle.LibTiff.Classic.Predictor : Enum {
    public int value__;
    public static Predictor NONE;
    public static Predictor HORIZONTAL;
    public static Predictor FLOATINGPOINT;
}
public enum BitMiracle.LibTiff.Classic.ResUnit : Enum {
    public int value__;
    public static ResUnit NONE;
    public static ResUnit INCH;
    public static ResUnit CENTIMETER;
}
public enum BitMiracle.LibTiff.Classic.SampleFormat : Enum {
    public int value__;
    public static SampleFormat UINT;
    public static SampleFormat INT;
    public static SampleFormat IEEEFP;
    public static SampleFormat VOID;
    public static SampleFormat COMPLEXINT;
    public static SampleFormat COMPLEXIEEEFP;
}
public enum BitMiracle.LibTiff.Classic.Threshold : Enum {
    public int value__;
    public static Threshold BILEVEL;
    public static Threshold HALFTONE;
    public static Threshold ERRORDIFFUSE;
}
public class BitMiracle.LibTiff.Classic.Tiff : object {
    private static TiffErrorHandler m_errorHandler;
    private static TiffExtendProc m_extender;
    private static TiffFieldInfo[] tiffFieldInfo;
    private static TiffFieldInfo[] exifFieldInfo;
    [CompilerGeneratedAttribute]
private ulong <PenultimateDirectoryOffset>k__BackingField;
    private static int TIFF_VERSION;
    private static int TIFF_BIGTIFF_VERSION;
    private static short TIFF_BIGENDIAN;
    private static short TIFF_LITTLEENDIAN;
    private static short MDI_LITTLEENDIAN;
    private static float D50_X0;
    private static float D50_Y0;
    private static float D50_Z0;
    internal static int STRIP_SIZE_DEFAULT;
    internal static TiffFlags STRIPCHOP_DEFAULT;
    internal static bool DEFAULT_EXTRASAMPLE_AS_ALPHA;
    internal static bool CHECK_JPEG_YCBCR_SUBSAMPLING;
    internal static Encoding Latin1Encoding;
    internal string m_name;
    internal int m_mode;
    internal TiffFlags m_flags;
    internal ulong m_diroff;
    internal TiffDirectory m_dir;
    internal int m_row;
    internal int m_curstrip;
    internal int m_curtile;
    internal int m_tilesize;
    internal TiffCodec m_currentCodec;
    internal int m_scanlinesize;
    internal Byte[] m_rawdata;
    internal int m_rawdatasize;
    internal int m_rawcp;
    internal int m_rawcc;
    internal object m_clientdata;
    internal PostDecodeMethodType m_postDecodeMethod;
    internal TiffTagMethods m_tagmethods;
    private ulong m_nextdiroff;
    private UInt64[] m_dirlist;
    private int m_dirlistsize;
    private short m_dirnumber;
    private TiffHeader m_header;
    private Int32[] m_typeshift;
    private UInt32[] m_typemask;
    private short m_curdir;
    private ulong m_curoff;
    private ulong m_dataoff;
    private short m_nsubifd;
    private ulong m_subifdoff;
    private int m_col;
    private bool m_decodestatus;
    private TiffFieldInfo[] m_fieldinfo;
    private int m_nfields;
    private TiffFieldInfo m_foundfield;
    private clientInfoLink m_clientinfo;
    private TiffCodec[] m_builtInCodecs;
    private codecList m_registeredCodecs;
    private TiffTagMethods m_defaultTagMethods;
    private bool m_disposed;
    private Stream m_fileStream;
    private TiffStream m_stream;
    private static UInt32[] typemask;
    private static Int32[] bigTypeshift;
    private static Int32[] litTypeshift;
    private static String[] photoNames;
    private static String[] orientNames;
    private static int NOSTRIP;
    private static int NOTILE;
    internal static int O_RDONLY;
    internal static int O_WRONLY;
    internal static int O_CREAT;
    internal static int O_TRUNC;
    internal static int O_RDWR;
    private static Byte[] TIFFBitRevTable;
    private static Byte[] TIFFNoBitRevTable;
    private ulong PenultimateDirectoryOffset { get; private set; }
    public static string AssemblyVersion { get; }
    private static Tiff();
    private static Tiff Open(string fileName, string mode, TiffErrorHandler errorHandler);
    private static Tiff Open(string fileName, string mode, TiffErrorHandler errorHandler, TiffExtendProc extender);
    private static Tiff ClientOpen(string name, string mode, object clientData, TiffStream stream, TiffErrorHandler errorHandler);
    private static Tiff ClientOpen(string name, string mode, object clientData, TiffStream stream, TiffErrorHandler errorHandler, TiffExtendProc extender);
    private static TiffErrorHandler setErrorHandlerImpl(TiffErrorHandler errorHandler);
    private static TiffExtendProc setTagExtenderImpl(TiffExtendProc extender);
    private static TiffErrorHandler getErrorHandler(Tiff tif);
    private static bool defaultTransferFunction(TiffDirectory td);
    private static void defaultRefBlackWhite(TiffDirectory td);
    internal static ulong readULong(Byte[] buffer, int offset);
    internal static int readInt(Byte[] buffer, int offset);
    internal static void writeInt(int value, Byte[] buffer, int offset);
    internal static void writeULong(ulong value, Byte[] buffer, int offset);
    internal static short readShort(Byte[] buffer, int offset);
    internal static void fprintf(Stream fd, string format, Object[] list);
    private static string encodeOctalString(byte value);
    private void setupBuiltInCodecs();
    internal static bool isPseudoTag(TiffTag t);
    private bool isFillOrder(FillOrder o);
    private static int BITn(int n);
    private bool okToChangeTag(TiffTag tag);
    private void setupDefaultDirectory();
    private bool advanceDirectory(UInt64& nextdir, Int64& off);
    private void issueAdvanceDirectoryWarning(string module);
    internal static void setString(String& cpp, string cp);
    internal static void setShortArray(Int16[]& wpp, Int16[] wp, int n);
    internal static void setLongArray(Int32[]& lpp, Int32[] lp, int n);
    internal static void setLong8Array(Int64[]& lpp, Int64[] lp, int n);
    internal static void setFloatArray(Single[]& fpp, Single[] fp, int n);
    internal bool fieldSet(int field);
    internal void setFieldBit(int field);
    internal void clearFieldBit(int field);
    private static TiffFieldInfo[] getFieldInfo(Int32& size);
    private static TiffFieldInfo[] getExifFieldInfo(Int32& size);
    private void setupFieldInfo(TiffFieldInfo[] info, int n);
    private TiffType sampleToTagType();
    private static TiffFieldInfo createAnonFieldInfo(TiffTag tag, TiffType field_type);
    internal static int dataSize(TiffType type);
    private long extractData(TiffDirEntry dir);
    private bool byteCountLooksBad(TiffDirectory td);
    private static int howMany8(int x);
    private bool estimateStripByteCounts(TiffDirEntry[] dir, long dircount);
    private void missingRequired(string tagname);
    private int fetchFailed(TiffDirEntry dir);
    private static long readDirectoryFind(TiffDirEntry[] dir, ulong dircount, TiffTag tagid);
    private bool checkDirOffset(ulong diroff);
    private ulong fetchDirectory(ulong diroff, TiffDirEntry[]& pdir, UInt64& nextdiroff);
    private bool fetchSubjectDistance(TiffDirEntry dir);
    private bool checkDirCount(TiffDirEntry dir, int count);
    private int fetchData(TiffDirEntry dir, Byte[] buffer);
    private int fetchString(TiffDirEntry dir, String& cp);
    private bool cvtRational(TiffDirEntry dir, int num, int denom, Single& rv);
    private bool cvtRational(TiffDirEntry dir, UInt32 num, UInt32 denom, Single& rv);
    private float fetchRational(TiffDirEntry dir);
    private float fetchFloat(TiffDirEntry dir);
    private bool fetchByteArray(TiffDirEntry dir, Byte[] v);
    private bool fetchShortArray(TiffDirEntry dir, Int16[] v);
    private bool fetchShortPair(TiffDirEntry dir);
    private bool fetchULongArray(TiffDirEntry dir, UInt32[] v);
    private bool fetchLongArray(TiffDirEntry dir, Int32[] v);
    private bool fetchLong8Array(TiffDirEntry dir, Int64[] v);
    private bool fetchRationalArray(TiffDirEntry dir, Single[] v);
    private bool fetchFloatArray(TiffDirEntry dir, Single[] v);
    private bool fetchDoubleArray(TiffDirEntry dir, Double[] v);
    private bool fetchAnyArray(TiffDirEntry dir, Double[] v);
    private bool fetchNormalTag(TiffDirEntry dir);
    private bool fetchPerSampleShorts(TiffDirEntry dir, Int16& pl);
    private bool fetchPerSampleLongs(TiffDirEntry dir, Int32& pl);
    private bool fetchPerSampleAnys(TiffDirEntry dir, Double& pl);
    private bool fetchStripThing(TiffDirEntry dir, int nstrips, Int64[]& lpp);
    private bool fetchStripThing(TiffDirEntry dir, int nstrips, UInt64[]& lpp);
    private bool fetchRefBlackWhite(TiffDirEntry dir);
    private void chopUpSingleUncompressedStrip();
    internal static int roundUp(int x, int y);
    internal static int howMany(int x, int y);
    internal static ulong howMany(ulong x, ulong y);
    [CompilerGeneratedAttribute]
private ulong get_PenultimateDirectoryOffset();
    [CompilerGeneratedAttribute]
private void set_PenultimateDirectoryOffset(ulong value);
    private ulong insertData(TiffType type, int v);
    private static void resetFieldBit(Int32[] fields, short f);
    private static bool fieldSet(Int32[] fields, short f);
    private bool writeRational(TiffType type, TiffTag tag, TiffDirEntry& dir, float v);
    private bool writeRationalPair(TiffDirEntry[] entries, int dirOffset, TiffType type, TiffTag tag1, float v1, TiffTag tag2, float v2);
    private bool writeDirectory(bool done);
    private bool MakeBigTIFF();
    private bool writeNormalTag(TiffDirEntry& dir, TiffFieldInfo fip);
    private void setupShortLong(TiffTag tag, TiffDirEntry& dir, int v);
    private void setupShort(TiffTag tag, TiffDirEntry& dir, short v);
    private bool writePerSampleShorts(TiffTag tag, TiffDirEntry& dir);
    private bool writePerSampleAnys(TiffType type, TiffTag tag, TiffDirEntry& dir);
    private bool setupShortPair(TiffTag tag, TiffDirEntry& dir);
    private bool writeShortTable(TiffTag tag, TiffDirEntry& dir, int n, Int16[][] table);
    private bool writeByteArray(TiffDirEntry& dir, Byte[] cp);
    private bool writeShortArray(TiffDirEntry& dir, Int16[] v);
    private bool writeLongArray(TiffDirEntry& dir, Int32[] v);
    private bool writeLongArray(TiffDirEntry& dir, UInt32[] v);
    private bool writeLong8Array(TiffDirEntry& dir, Int64[] v);
    private bool writeLong8Array(TiffDirEntry& dir, UInt64[] v);
    private bool writeRationalArray(TiffDirEntry& dir, Single[] v);
    private bool writeFloatArray(TiffDirEntry& dir, Single[] v);
    private bool writeDoubleArray(TiffDirEntry& dir, Double[] v);
    private bool writeAnyArray(TiffType type, TiffTag tag, TiffDirEntry& dir, int n, Double[] v);
    private bool writeTransferFunction(TiffDirEntry& dir);
    private bool writeInkNames(TiffDirEntry& dir);
    private bool writeData(TiffDirEntry& dir, Byte[] buffer, int count);
    private bool writeData(TiffDirEntry& dir, Int16[] buffer, int count);
    private bool writeData(TiffDirEntry& dir, Int64[] buffer, int count);
    private bool writeData(TiffDirEntry& dir, Int32[] cp, int cc);
    private bool writeData(TiffDirEntry& dir, Single[] cp, int cc);
    private bool writeData(TiffDirEntry& dir, Double[] buffer, int count);
    private void resetPenultimateDirectoryOffset();
    private bool linkDirectory();
    private void Dispose(bool disposing);
    private bool WriteCustomDirectory(Int64& pdiroff);
    internal static void SwabUInt(UInt32& lp);
    internal static UInt64[] Realloc(UInt64[] buffer, int elementCount, int newElementCount);
    internal static TiffFieldInfo[] Realloc(TiffFieldInfo[] buffer, int elementCount, int newElementCount);
    internal static TiffTagValue[] Realloc(TiffTagValue[] buffer, int elementCount, int newElementCount);
    internal bool setCompressionScheme(Compression scheme);
    private void postDecode(Byte[] buffer, int offset, int count);
    private static bool checkJpegIsOJpeg(Int32& v, TiffDirEntry[] dir, ulong dircount);
    private void initOrder(int magic);
    private static int getMode(string mode, string module, FileMode& m, FileAccess& a);
    private static void printField(Stream fd, TiffFieldInfo fip, int value_count, object raw_data);
    private static bool prettyPrintField(Stream fd, TiffTag tag, int value_count, object raw_data);
    private static void printAscii(Stream fd, string cp);
    private int readFile(Byte[] buf, int offset, int size);
    private long seekFile(long off, SeekOrigin whence);
    private long getFileSize();
    private bool readOK(Byte[] buf, int size);
    private bool readShortOK(Int16& value);
    private bool readDirCountOK(UInt64& dircount, bool isBigTiff);
    private bool readUIntOK(UInt32& value);
    private bool readUlongOK(UInt64& value);
    private bool readLongOK(Int64& value);
    private bool readIntOK(Int32& value);
    private bool readDirEntryOk(TiffDirEntry[] dir, ulong dircount, bool isBigTiff);
    private static void readDirEntry(TiffDirEntry[] dir, ulong dircount, Byte[] bytes, int offset, bool isBigTiff);
    private bool readHeaderOkWithoutExceptions(TiffHeader& header);
    private bool readHeaderOk(TiffHeader& header);
    private bool seekOK(long off);
    private bool seek(int row, short sample);
    private int readRawStrip1(int strip, Byte[] buf, int offset, int size, string module);
    private int readRawTile1(int tile, Byte[] buf, int offset, int size, string module);
    private bool startStrip(int strip);
    private bool startTile(int tile);
    private bool checkRead(bool tiles);
    private static void swab16BitData(Byte[] buffer, int offset, int count);
    private static void swab24BitData(Byte[] buffer, int offset, int count);
    private static void swab32BitData(Byte[] buffer, int offset, int count);
    private static void swab64BitData(Byte[] buffer, int offset, int count);
    internal bool fillStrip(int strip);
    internal bool fillTile(int tile);
    private int summarize(int summand1, int summand2, string where);
    private int multiply(int nmemb, int elem_size, string where);
    internal int newScanlineSize();
    internal int oldScanlineSize();
    private bool writeCheckStrips(string module);
    private bool writeCheckTiles(string module);
    private void bufferCheck();
    private bool writeOK(Byte[] buffer, int offset, int count);
    private bool writeHeaderOK(TiffHeader header);
    private bool writeDirEntryOK(TiffDirEntry[] entries, long count, bool isBigTiff);
    private bool writeShortOK(short value);
    private bool writeDirCountOK(long value, bool isBigTiff);
    private bool writeDirOffOK(long value, bool isBigTiff);
    private bool writeIntOK(int value);
    private bool writelongOK(long value);
    private bool isUnspecified(int f);
    private bool growStrips(int delta);
    private bool appendToStrip(int strip, Byte[] buffer, int offset, long count);
    internal bool flushData1();
    public static string GetVersion();
    public static string get_AssemblyVersion();
    public static int GetR(int abgr);
    public static int GetG(int abgr);
    public static int GetB(int abgr);
    public static int GetA(int abgr);
    public TiffCodec FindCodec(Compression scheme);
    public void RegisterCodec(TiffCodec codec);
    public void UnRegisterCodec(TiffCodec codec);
    public bool IsCodecConfigured(Compression scheme);
    public TiffCodec[] GetConfiguredCodecs();
    public static Byte[] Realloc(Byte[] array, int size);
    public static Int32[] Realloc(Int32[] array, int size);
    public static int Compare(Int16[] first, Int16[] second, int elementCount);
    public static Tiff Open(string fileName, string mode);
    public static Tiff ClientOpen(string name, string mode, object clientData, TiffStream stream);
    public void Close();
    public sealed virtual void Dispose();
    public int GetTagListCount();
    public int GetTagListEntry(int index);
    public void MergeFieldInfo(TiffFieldInfo[] info, int count);
    public TiffFieldInfo FindFieldInfo(TiffTag tag, TiffType type);
    public TiffFieldInfo FindFieldInfoByName(string name, TiffType type);
    public TiffFieldInfo FieldWithTag(TiffTag tag);
    public TiffFieldInfo FieldWithName(string name);
    public TiffTagMethods GetTagMethods();
    public TiffTagMethods SetTagMethods(TiffTagMethods methods);
    public object GetClientInfo(string name);
    public void SetClientInfo(object data, string name);
    public bool Flush();
    public bool FlushData();
    public FieldValue[] GetField(TiffTag tag);
    public FieldValue[] GetFieldDefaulted(TiffTag tag);
    public bool ReadDirectory();
    public bool ReadCustomDirectory(long offset, TiffFieldInfo[] info, int count);
    public bool ReadEXIFDirectory(long offset);
    public int ScanlineSize();
    public int RasterScanlineSize();
    public int DefaultStripSize(int estimate);
    public int StripSize();
    public int VStripSize(int rowCount);
    public long RawStripSize(int strip);
    public int ComputeStrip(int row, short plane);
    public int NumberOfStrips();
    public void DefaultTileSize(Int32& width, Int32& height);
    public int TileSize();
    public int VTileSize(int rowCount);
    public long RawTileSize(int tile);
    public int TileRowSize();
    public int ComputeTile(int x, int y, int z, short plane);
    public bool CheckTile(int x, int y, int z, short plane);
    public int NumberOfTiles();
    public object Clientdata();
    public object SetClientdata(object data);
    public int GetMode();
    public int SetMode(int mode);
    public bool IsTiled();
    public bool IsByteSwapped();
    public bool IsUpSampled();
    public bool IsMSB2LSB();
    public bool IsBigEndian();
    public TiffStream GetStream();
    public int CurrentRow();
    public short CurrentDirectory();
    public short NumberOfDirectories();
    public long CurrentDirOffset();
    public int CurrentStrip();
    public int CurrentTile();
    public void ReadBufferSetup(Byte[] buffer, int size);
    public void WriteBufferSetup(Byte[] buffer, int size);
    public bool SetupStrips();
    public bool WriteCheck(bool tiles, string method);
    public void FreeDirectory();
    public void CreateDirectory();
    public bool LastDirectory();
    public bool SetDirectory(short number);
    public bool SetSubDirectory(long offset);
    public bool UnlinkDirectory(short number);
    public bool SetField(TiffTag tag, Object[] value);
    public bool WriteDirectory();
    public bool CheckpointDirectory();
    public bool RewriteDirectory();
    public void PrintDirectory(Stream stream);
    public void PrintDirectory(Stream stream, TiffPrintFlags flags);
    public bool ReadScanline(Byte[] buffer, int row);
    public bool ReadScanline(Byte[] buffer, int row, short plane);
    public bool ReadScanline(Byte[] buffer, int offset, int row, short plane);
    public bool WriteScanline(Byte[] buffer, int row);
    public bool WriteScanline(Byte[] buffer, int row, short plane);
    public bool WriteScanline(Byte[] buffer, int offset, int row, short plane);
    public bool ReadRGBAImage(int width, int height, Int32[] raster);
    public bool ReadRGBAImage(int width, int height, Int32[] raster, bool stopOnError);
    public bool ReadRGBAImageOriented(int width, int height, Int32[] raster, Orientation orientation);
    public bool ReadRGBAImageOriented(int width, int height, Int32[] raster, Orientation orientation, bool stopOnError);
    public bool ReadRGBAStrip(int row, Int32[] raster);
    public bool ReadRGBATile(int col, int row, Int32[] raster);
    public bool RGBAImageOK(String& errorMsg);
    public string FileName();
    public string SetFileName(string name);
    public static void Error(Tiff tif, string method, string format, Object[] args);
    public static void Error(string method, string format, Object[] args);
    public static void ErrorExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public static void ErrorExt(object clientData, string method, string format, Object[] args);
    public static void Warning(Tiff tif, string method, string format, Object[] args);
    public static void Warning(string method, string format, Object[] args);
    public static void WarningExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public static void WarningExt(object clientData, string method, string format, Object[] args);
    public static TiffErrorHandler SetErrorHandler(TiffErrorHandler errorHandler);
    public static TiffExtendProc SetTagExtender(TiffExtendProc extender);
    public int ReadTile(Byte[] buffer, int offset, int x, int y, int z, short plane);
    public int ReadEncodedTile(int tile, Byte[] buffer, int offset, int count);
    public int ReadRawTile(int tile, Byte[] buffer, int offset, int count);
    public int WriteTile(Byte[] buffer, int x, int y, int z, short plane);
    public int WriteTile(Byte[] buffer, int offset, int x, int y, int z, short plane);
    public int ReadEncodedStrip(int strip, Byte[] buffer, int offset, int count);
    public int ReadRawStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteEncodedStrip(int strip, Byte[] buffer, int count);
    public int WriteEncodedStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteRawStrip(int strip, Byte[] buffer, int count);
    public int WriteRawStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteEncodedTile(int tile, Byte[] buffer, int count);
    public int WriteEncodedTile(int tile, Byte[] buffer, int offset, int count);
    public int WriteRawTile(int tile, Byte[] buffer, int count);
    public int WriteRawTile(int tile, Byte[] buffer, int offset, int count);
    public void SetWriteOffset(long offset);
    public static int DataWidth(TiffType type);
    public static void SwabShort(Int16& value);
    public static void SwabLong(Int32& value);
    private static void SwabLong8(UInt64& value);
    private static void SwabBigTiffValue(UInt64& value, bool isBigTiff, bool isShort);
    public static void SwabDouble(Double& value);
    public static void SwabArrayOfShort(Int16[] array, int count);
    public static void SwabArrayOfShort(Int16[] array, int offset, int count);
    public static void SwabArrayOfTriples(Byte[] array, int count);
    public static void SwabArrayOfTriples(Byte[] array, int offset, int count);
    public static void SwabArrayOfLong(Int32[] array, int count);
    public static void SwabArrayOfLong8(Int64[] array, int count);
    public static void SwabArrayOfLong(Int32[] array, int offset, int count);
    public static void SwabArrayOfLong8(Int64[] array, int offset, int count);
    public static void SwabArrayOfDouble(Double[] array, int count);
    public static void SwabArrayOfDouble(Double[] array, int offset, int count);
    public static void ReverseBits(Byte[] buffer, int count);
    public static void ReverseBits(Byte[] buffer, int offset, int count);
    public static Byte[] GetBitRevTable(bool reversed);
    public static Int32[] ByteArrayToInts(Byte[] buffer, int offset, int count);
    public static Int64[] ByteArrayToLong8(Byte[] buffer, int offset, int count);
    public static void Long8ToByteArray(Int64[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    public static void IntsToByteArray(Int32[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    public static Int16[] ByteArrayToShorts(Byte[] buffer, int offset, int count);
    public static void ShortsToByteArray(Int16[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    private static Int64[] IntToLong(Int32[] inputArray);
    private static UInt32[] LongToInt(UInt64[] inputArray);
    private static Int32[] LongToInt(Int64[] inputArray);
}
public class BitMiracle.LibTiff.Classic.TiffCodec : object {
    protected Tiff m_tif;
    protected internal Compression m_scheme;
    protected internal string m_name;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public TiffCodec(Tiff tif, Compression scheme, string name);
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool Init();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Close();
    public virtual bool Seek(int row);
    public virtual void Cleanup();
    public virtual int DefStripSize(int size);
    public virtual void DefTileSize(Int32& width, Int32& height);
    private bool noEncode(string method);
    private bool noDecode(string method);
}
public class BitMiracle.LibTiff.Classic.TiffErrorHandler : object {
    public virtual void ErrorHandler(Tiff tif, string method, string format, Object[] args);
    public virtual void ErrorHandlerExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public virtual void WarningHandler(Tiff tif, string method, string format, Object[] args);
    public virtual void WarningHandlerExt(Tiff tif, object clientData, string method, string format, Object[] args);
}
public class BitMiracle.LibTiff.Classic.TiffFieldInfo : object {
    private TiffTag m_tag;
    private short m_readCount;
    private short m_writeCount;
    private TiffType m_type;
    private short m_bit;
    private bool m_okToChange;
    private bool m_passCount;
    private string m_name;
    public static short Variable;
    public static short Spp;
    public static short Variable2;
    public TiffTag Tag { get; }
    public short ReadCount { get; }
    public short WriteCount { get; }
    public TiffType Type { get; }
    public short Bit { get; }
    public bool OkToChange { get; }
    public bool PassCount { get; }
    public string Name { get; internal set; }
    public TiffFieldInfo(TiffTag tag, short readCount, short writeCount, TiffType type, short bit, bool okToChange, bool passCount, string name);
    public virtual string ToString();
    public TiffTag get_Tag();
    public short get_ReadCount();
    public short get_WriteCount();
    public TiffType get_Type();
    public short get_Bit();
    public bool get_OkToChange();
    public bool get_PassCount();
    public string get_Name();
    internal void set_Name(string value);
}
[FlagsAttribute]
public enum BitMiracle.LibTiff.Classic.TiffPrintFlags : Enum {
    public int value__;
    public static TiffPrintFlags NONE;
    public static TiffPrintFlags STRIPS;
    public static TiffPrintFlags CURVES;
    public static TiffPrintFlags COLORMAP;
    public static TiffPrintFlags JPEGQTABLES;
    public static TiffPrintFlags JPEGACTABLES;
    public static TiffPrintFlags JPEGDCTABLES;
}
public class BitMiracle.LibTiff.Classic.TiffRgbaImage : object {
    internal static string photoTag;
    private Tiff tif;
    private bool stoponerr;
    private bool isContig;
    private ExtraSample alpha;
    private int width;
    private int height;
    private short bitspersample;
    private short samplesperpixel;
    private Orientation orientation;
    private Orientation req_orientation;
    private Photometric photometric;
    private UInt16[] redcmap;
    private UInt16[] greencmap;
    private UInt16[] bluecmap;
    private GetDelegate get;
    private PutContigDelegate putContig;
    private PutSeparateDelegate putSeparate;
    private Byte[] Map;
    private Int32[][] BWmap;
    private Int32[][] PALmap;
    private TiffYCbCrToRGB ycbcr;
    private TiffCIELabToRGB cielab;
    private static TiffDisplay display_sRGB;
    private static int A1;
    private static int FLIP_VERTICALLY;
    private static int FLIP_HORIZONTALLY;
    internal int row_offset;
    internal int col_offset;
    public bool IsContig { get; }
    public ExtraSample Alpha { get; }
    public int Width { get; }
    public int Height { get; }
    public short BitsPerSample { get; }
    public short SamplesPerPixel { get; }
    public Orientation Orientation { get; }
    public Orientation ReqOrientation { get; public set; }
    public Photometric Photometric { get; }
    public GetDelegate Get { get; public set; }
    public PutContigDelegate PutContig { get; public set; }
    public PutSeparateDelegate PutSeparate { get; public set; }
    private static TiffRgbaImage();
    public static TiffRgbaImage Create(Tiff tif, bool stopOnError, String& errorMsg);
    public bool get_IsContig();
    public ExtraSample get_Alpha();
    public int get_Width();
    public int get_Height();
    public short get_BitsPerSample();
    public short get_SamplesPerPixel();
    public Orientation get_Orientation();
    public Orientation get_ReqOrientation();
    public void set_ReqOrientation(Orientation value);
    public Photometric get_Photometric();
    public GetDelegate get_Get();
    public void set_Get(GetDelegate value);
    public PutContigDelegate get_PutContig();
    public void set_PutContig(PutContigDelegate value);
    public PutSeparateDelegate get_PutSeparate();
    public void set_PutSeparate(PutSeparateDelegate value);
    public bool GetRaster(Int32[] raster, int offset, int width, int height);
    private static int PACK(int r, int g, int b);
    private static int PACK4(int r, int g, int b, int a);
    private static int PACK4(int rgb, int a);
    private static int W2B(short v);
    private static int PACKW(short r, short g, short b);
    private static int PACKW4(short r, short g, short b, short a);
    private void CMAP(int x, int i, Int32& j);
    private void GREY(int x, int i, Int32& j);
    private static bool gtTileContig(TiffRgbaImage img, Int32[] raster, int offset, int width, int height);
    private static bool gtTileSeparate(TiffRgbaImage img, Int32[] raster, int offset, int width, int height);
    private static bool gtStripContig(TiffRgbaImage img, Int32[] raster, int offset, int width, int height);
    private static bool gtStripSeparate(TiffRgbaImage img, Int32[] raster, int offset, int width, int height);
    private bool isCCITTCompression();
    private int setorientation();
    private bool pickContigCase();
    private bool pickSeparateCase();
    private bool initYCbCrConversion();
    private PutContigDelegate initCIELabConversion();
    private bool buildMap();
    private bool setupMap();
    private int checkcmap();
    private void cvtcmap();
    private bool makecmap();
    private bool makebwmap();
    private void YCbCrtoRGB(Int32& dst, int Y, int Cb, int Cr);
    private static void put8bitcmaptile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void put4bitcmaptile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void put2bitcmaptile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void put1bitcmaptile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putgreytile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putgreywithalphatile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void put16bitbwtile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void put1bitbwtile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void put2bitbwtile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void put4bitbwtile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putRGBcontig8bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putRGBAAcontig8bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putRGBUAcontig8bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putRGBcontig16bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putRGBAAcontig16bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putRGBUAcontig16bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putRGBAcontig8bitCMYKAtile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putRGBcontig8bitCMYKtile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putcontig8bitCIELab(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putcontig8bitYCbCr22tile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putcontig8bitYCbCr21tile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putcontig8bitYCbCr44tile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putcontig8bitYCbCr42tile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putcontig8bitYCbCr41tile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putcontig8bitYCbCr11tile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putcontig8bitYCbCr12tile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void putRGBseparate8bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void putRGBAAseparate8bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void putRGBUAseparate8bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void putRGBseparate16bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void putRGBAAseparate16bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void putRGBUAseparate16bittile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void putseparate8bitYCbCr11tile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void putRGBcontig8bitCMYKMaptile(TiffRgbaImage img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
}
public class BitMiracle.LibTiff.Classic.TiffStream : object {
    public virtual int Read(object clientData, Byte[] buffer, int offset, int count);
    public virtual void Write(object clientData, Byte[] buffer, int offset, int count);
    public virtual long Seek(object clientData, long offset, SeekOrigin origin);
    public virtual void Close(object clientData);
    public virtual long Size(object clientData);
}
public enum BitMiracle.LibTiff.Classic.TiffTag : Enum {
    public int value__;
    public static TiffTag IGNORE;
    public static TiffTag SUBFILETYPE;
    public static TiffTag OSUBFILETYPE;
    public static TiffTag IMAGEWIDTH;
    public static TiffTag IMAGELENGTH;
    public static TiffTag BITSPERSAMPLE;
    public static TiffTag COMPRESSION;
    public static TiffTag PHOTOMETRIC;
    public static TiffTag THRESHHOLDING;
    public static TiffTag CELLWIDTH;
    public static TiffTag CELLLENGTH;
    public static TiffTag FILLORDER;
    public static TiffTag DOCUMENTNAME;
    public static TiffTag IMAGEDESCRIPTION;
    public static TiffTag MAKE;
    public static TiffTag MODEL;
    public static TiffTag STRIPOFFSETS;
    public static TiffTag ORIENTATION;
    public static TiffTag SAMPLESPERPIXEL;
    public static TiffTag ROWSPERSTRIP;
    public static TiffTag STRIPBYTECOUNTS;
    public static TiffTag MINSAMPLEVALUE;
    public static TiffTag MAXSAMPLEVALUE;
    public static TiffTag XRESOLUTION;
    public static TiffTag YRESOLUTION;
    public static TiffTag PLANARCONFIG;
    public static TiffTag PAGENAME;
    public static TiffTag XPOSITION;
    public static TiffTag YPOSITION;
    public static TiffTag FREEOFFSETS;
    public static TiffTag FREEBYTECOUNTS;
    public static TiffTag GRAYRESPONSEUNIT;
    public static TiffTag GRAYRESPONSECURVE;
    public static TiffTag GROUP3OPTIONS;
    public static TiffTag T4OPTIONS;
    public static TiffTag GROUP4OPTIONS;
    public static TiffTag T6OPTIONS;
    public static TiffTag RESOLUTIONUNIT;
    public static TiffTag PAGENUMBER;
    public static TiffTag COLORRESPONSEUNIT;
    public static TiffTag TRANSFERFUNCTION;
    public static TiffTag SOFTWARE;
    public static TiffTag DATETIME;
    public static TiffTag ARTIST;
    public static TiffTag HOSTCOMPUTER;
    public static TiffTag PREDICTOR;
    public static TiffTag WHITEPOINT;
    public static TiffTag PRIMARYCHROMATICITIES;
    public static TiffTag COLORMAP;
    public static TiffTag HALFTONEHINTS;
    public static TiffTag TILEWIDTH;
    public static TiffTag TILELENGTH;
    public static TiffTag TILEOFFSETS;
    public static TiffTag TILEBYTECOUNTS;
    public static TiffTag BADFAXLINES;
    public static TiffTag CLEANFAXDATA;
    public static TiffTag CONSECUTIVEBADFAXLINES;
    public static TiffTag SUBIFD;
    public static TiffTag INKSET;
    public static TiffTag INKNAMES;
    public static TiffTag NUMBEROFINKS;
    public static TiffTag DOTRANGE;
    public static TiffTag TARGETPRINTER;
    public static TiffTag EXTRASAMPLES;
    public static TiffTag SAMPLEFORMAT;
    public static TiffTag SMINSAMPLEVALUE;
    public static TiffTag SMAXSAMPLEVALUE;
    public static TiffTag CLIPPATH;
    public static TiffTag XCLIPPATHUNITS;
    public static TiffTag YCLIPPATHUNITS;
    public static TiffTag INDEXED;
    public static TiffTag JPEGTABLES;
    public static TiffTag OPIPROXY;
    public static TiffTag JPEGPROC;
    public static TiffTag JPEGIFOFFSET;
    public static TiffTag JPEGIFBYTECOUNT;
    public static TiffTag JPEGRESTARTINTERVAL;
    public static TiffTag JPEGLOSSLESSPREDICTORS;
    public static TiffTag JPEGPOINTTRANSFORM;
    public static TiffTag JPEGQTABLES;
    public static TiffTag JPEGDCTABLES;
    public static TiffTag JPEGACTABLES;
    public static TiffTag YCBCRCOEFFICIENTS;
    public static TiffTag YCBCRSUBSAMPLING;
    public static TiffTag YCBCRPOSITIONING;
    public static TiffTag REFERENCEBLACKWHITE;
    public static TiffTag XMLPACKET;
    public static TiffTag OPIIMAGEID;
    public static TiffTag REFPTS;
    public static TiffTag REGIONTACKPOINT;
    public static TiffTag REGIONWARPCORNERS;
    public static TiffTag REGIONAFFINE;
    public static TiffTag MATTEING;
    public static TiffTag DATATYPE;
    public static TiffTag IMAGEDEPTH;
    public static TiffTag TILEDEPTH;
    public static TiffTag PIXAR_IMAGEFULLWIDTH;
    public static TiffTag PIXAR_IMAGEFULLLENGTH;
    public static TiffTag PIXAR_TEXTUREFORMAT;
    public static TiffTag PIXAR_WRAPMODES;
    public static TiffTag PIXAR_FOVCOT;
    public static TiffTag PIXAR_MATRIX_WORLDTOSCREEN;
    public static TiffTag PIXAR_MATRIX_WORLDTOCAMERA;
    public static TiffTag WRITERSERIALNUMBER;
    public static TiffTag COPYRIGHT;
    public static TiffTag RICHTIFFIPTC;
    public static TiffTag IT8SITE;
    public static TiffTag IT8COLORSEQUENCE;
    public static TiffTag IT8HEADER;
    public static TiffTag IT8RASTERPADDING;
    public static TiffTag IT8BITSPERRUNLENGTH;
    public static TiffTag IT8BITSPEREXTENDEDRUNLENGTH;
    public static TiffTag IT8COLORTABLE;
    public static TiffTag IT8IMAGECOLORINDICATOR;
    public static TiffTag IT8BKGCOLORINDICATOR;
    public static TiffTag IT8IMAGECOLORVALUE;
    public static TiffTag IT8BKGCOLORVALUE;
    public static TiffTag IT8PIXELINTENSITYRANGE;
    public static TiffTag IT8TRANSPARENCYINDICATOR;
    public static TiffTag IT8COLORCHARACTERIZATION;
    public static TiffTag IT8HCUSAGE;
    public static TiffTag IT8TRAPINDICATOR;
    public static TiffTag IT8CMYKEQUIVALENT;
    public static TiffTag FRAMECOUNT;
    public static TiffTag PHOTOSHOP;
    public static TiffTag EXIFIFD;
    public static TiffTag ICCPROFILE;
    public static TiffTag JBIGOPTIONS;
    public static TiffTag GPSIFD;
    public static TiffTag FAXRECVPARAMS;
    public static TiffTag FAXSUBADDRESS;
    public static TiffTag FAXRECVTIME;
    public static TiffTag FAXDCS;
    public static TiffTag STONITS;
    public static TiffTag FEDEX_EDR;
    public static TiffTag INTEROPERABILITYIFD;
    public static TiffTag DNGVERSION;
    public static TiffTag DNGBACKWARDVERSION;
    public static TiffTag UNIQUECAMERAMODEL;
    public static TiffTag LOCALIZEDCAMERAMODEL;
    public static TiffTag CFAPLANECOLOR;
    public static TiffTag CFALAYOUT;
    public static TiffTag LINEARIZATIONTABLE;
    public static TiffTag BLACKLEVELREPEATDIM;
    public static TiffTag BLACKLEVEL;
    public static TiffTag BLACKLEVELDELTAH;
    public static TiffTag BLACKLEVELDELTAV;
    public static TiffTag WHITELEVEL;
    public static TiffTag DEFAULTSCALE;
    public static TiffTag DEFAULTCROPORIGIN;
    public static TiffTag DEFAULTCROPSIZE;
    public static TiffTag COLORMATRIX1;
    public static TiffTag COLORMATRIX2;
    public static TiffTag CAMERACALIBRATION1;
    public static TiffTag CAMERACALIBRATION2;
    public static TiffTag REDUCTIONMATRIX1;
    public static TiffTag REDUCTIONMATRIX2;
    public static TiffTag ANALOGBALANCE;
    public static TiffTag ASSHOTNEUTRAL;
    public static TiffTag ASSHOTWHITEXY;
    public static TiffTag BASELINEEXPOSURE;
    public static TiffTag BASELINENOISE;
    public static TiffTag BASELINESHARPNESS;
    public static TiffTag BAYERGREENSPLIT;
    public static TiffTag LINEARRESPONSELIMIT;
    public static TiffTag CAMERASERIALNUMBER;
    public static TiffTag LENSINFO;
    public static TiffTag CHROMABLURRADIUS;
    public static TiffTag ANTIALIASSTRENGTH;
    public static TiffTag SHADOWSCALE;
    public static TiffTag DNGPRIVATEDATA;
    public static TiffTag MAKERNOTESAFETY;
    public static TiffTag CALIBRATIONILLUMINANT1;
    public static TiffTag CALIBRATIONILLUMINANT2;
    public static TiffTag BESTQUALITYSCALE;
    public static TiffTag RAWDATAUNIQUEID;
    public static TiffTag ORIGINALRAWFILENAME;
    public static TiffTag ORIGINALRAWFILEDATA;
    public static TiffTag ACTIVEAREA;
    public static TiffTag MASKEDAREAS;
    public static TiffTag ASSHOTICCPROFILE;
    public static TiffTag ASSHOTPREPROFILEMATRIX;
    public static TiffTag CURRENTICCPROFILE;
    public static TiffTag CURRENTPREPROFILEMATRIX;
    public static TiffTag DCSHUESHIFTVALUES;
    public static TiffTag FAXMODE;
    public static TiffTag JPEGQUALITY;
    public static TiffTag JPEGCOLORMODE;
    public static TiffTag JPEGTABLESMODE;
    public static TiffTag FAXFILLFUNC;
    public static TiffTag PIXARLOGDATAFMT;
    public static TiffTag DCSIMAGERTYPE;
    public static TiffTag DCSINTERPMODE;
    public static TiffTag DCSBALANCEARRAY;
    public static TiffTag DCSCORRECTMATRIX;
    public static TiffTag DCSGAMMA;
    public static TiffTag DCSTOESHOULDERPTS;
    public static TiffTag DCSCALIBRATIONFD;
    public static TiffTag ZIPQUALITY;
    public static TiffTag PIXARLOGQUALITY;
    public static TiffTag DCSCLIPRECTANGLE;
    public static TiffTag SGILOGDATAFMT;
    public static TiffTag SGILOGENCODE;
    public static TiffTag EXIF_EXPOSURETIME;
    public static TiffTag EXIF_FNUMBER;
    public static TiffTag EXIF_EXPOSUREPROGRAM;
    public static TiffTag EXIF_SPECTRALSENSITIVITY;
    public static TiffTag EXIF_ISOSPEEDRATINGS;
    public static TiffTag EXIF_OECF;
    public static TiffTag EXIF_EXIFVERSION;
    public static TiffTag EXIF_DATETIMEORIGINAL;
    public static TiffTag EXIF_DATETIMEDIGITIZED;
    public static TiffTag EXIF_COMPONENTSCONFIGURATION;
    public static TiffTag EXIF_COMPRESSEDBITSPERPIXEL;
    public static TiffTag EXIF_SHUTTERSPEEDVALUE;
    public static TiffTag EXIF_APERTUREVALUE;
    public static TiffTag EXIF_BRIGHTNESSVALUE;
    public static TiffTag EXIF_EXPOSUREBIASVALUE;
    public static TiffTag EXIF_MAXAPERTUREVALUE;
    public static TiffTag EXIF_SUBJECTDISTANCE;
    public static TiffTag EXIF_METERINGMODE;
    public static TiffTag EXIF_LIGHTSOURCE;
    public static TiffTag EXIF_FLASH;
    public static TiffTag EXIF_FOCALLENGTH;
    public static TiffTag EXIF_SUBJECTAREA;
    public static TiffTag EXIF_MAKERNOTE;
    public static TiffTag EXIF_USERCOMMENT;
    public static TiffTag EXIF_SUBSECTIME;
    public static TiffTag EXIF_SUBSECTIMEORIGINAL;
    public static TiffTag EXIF_SUBSECTIMEDIGITIZED;
    public static TiffTag EXIF_FLASHPIXVERSION;
    public static TiffTag EXIF_COLORSPACE;
    public static TiffTag EXIF_PIXELXDIMENSION;
    public static TiffTag EXIF_PIXELYDIMENSION;
    public static TiffTag EXIF_RELATEDSOUNDFILE;
    public static TiffTag EXIF_FLASHENERGY;
    public static TiffTag EXIF_SPATIALFREQUENCYRESPONSE;
    public static TiffTag EXIF_FOCALPLANEXRESOLUTION;
    public static TiffTag EXIF_FOCALPLANEYRESOLUTION;
    public static TiffTag EXIF_FOCALPLANERESOLUTIONUNIT;
    public static TiffTag EXIF_SUBJECTLOCATION;
    public static TiffTag EXIF_EXPOSUREINDEX;
    public static TiffTag EXIF_SENSINGMETHOD;
    public static TiffTag EXIF_FILESOURCE;
    public static TiffTag EXIF_SCENETYPE;
    public static TiffTag EXIF_CFAPATTERN;
    public static TiffTag EXIF_CUSTOMRENDERED;
    public static TiffTag EXIF_EXPOSUREMODE;
    public static TiffTag EXIF_WHITEBALANCE;
    public static TiffTag EXIF_DIGITALZOOMRATIO;
    public static TiffTag EXIF_FOCALLENGTHIN35MMFILM;
    public static TiffTag EXIF_SCENECAPTURETYPE;
    public static TiffTag EXIF_GAINCONTROL;
    public static TiffTag EXIF_CONTRAST;
    public static TiffTag EXIF_SATURATION;
    public static TiffTag EXIF_SHARPNESS;
    public static TiffTag EXIF_DEVICESETTINGDESCRIPTION;
    public static TiffTag EXIF_SUBJECTDISTANCERANGE;
    public static TiffTag EXIF_IMAGEUNIQUEID;
    public static TiffTag GEOTIFF_MODELPIXELSCALETAG;
    public static TiffTag GEOTIFF_MODELTIEPOINTTAG;
    public static TiffTag GEOTIFF_MODELTRANSFORMATIONTAG;
    public static TiffTag GEOTIFF_GEOKEYDIRECTORYTAG;
    public static TiffTag GEOTIFF_GEODOUBLEPARAMSTAG;
    public static TiffTag GEOTIFF_GEOASCIIPARAMSTAG;
}
public class BitMiracle.LibTiff.Classic.TiffTagMethods : object {
    private static short DATATYPE_VOID;
    private static short DATATYPE_INT;
    private static short DATATYPE_UINT;
    private static short DATATYPE_IEEEFP;
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] value);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream stream, TiffPrintFlags flags);
    private static bool setExtraSamples(TiffDirectory td, Int32& v, FieldValue[] ap);
    private static int checkInkNamesString(Tiff tif, int slen, string s);
    private static void setNString(String& cpp, string cp, int n);
}
public enum BitMiracle.LibTiff.Classic.TiffType : Enum {
    public short value__;
    public static TiffType NOTYPE;
    public static TiffType ANY;
    public static TiffType BYTE;
    public static TiffType ASCII;
    public static TiffType SHORT;
    public static TiffType LONG;
    public static TiffType RATIONAL;
    public static TiffType SBYTE;
    public static TiffType UNDEFINED;
    public static TiffType SSHORT;
    public static TiffType SLONG;
    public static TiffType SRATIONAL;
    public static TiffType FLOAT;
    public static TiffType DOUBLE;
    public static TiffType IFD;
    public static TiffType LONG8;
    public static TiffType SLONG8;
    public static TiffType IFD8;
}
public enum BitMiracle.LibTiff.Classic.YCbCrPosition : Enum {
    public int value__;
    public static YCbCrPosition CENTERED;
    public static YCbCrPosition COSITED;
}
internal class ComponentAce.Compression.Libs.zlib.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    internal long adler32(long adler, Byte[] buf, int index, int len);
}
internal class ComponentAce.Compression.Libs.zlib.Deflate : object {
    private static int MAX_MEM_LEVEL;
    private static int Z_DEFAULT_COMPRESSION;
    private static int MAX_WBITS;
    private static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static Config[] config_table;
    private static String[] z_errmsg;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_FILTERED;
    private static int Z_HUFFMAN_ONLY;
    private static int Z_DEFAULT_STRATEGY;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    internal ZStream strm;
    internal int status;
    internal Byte[] pending_buf;
    internal int pending_buf_size;
    internal int pending_out;
    internal int pending;
    internal int noheader;
    internal byte data_type;
    internal byte method;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal int max_chain_length;
    internal int max_lazy_match;
    internal int level;
    internal int strategy;
    internal int good_match;
    internal int nice_match;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree l_desc;
    internal Tree d_desc;
    internal Tree bl_desc;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    internal int l_buf;
    internal int lit_bufsize;
    internal int last_lit;
    internal int d_buf;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal short bi_buf;
    internal int bi_valid;
    private static Deflate();
    internal void lm_init();
    internal void tr_init();
    internal void init_block();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool smaller(Int16[] tree, int n, int m, Byte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    internal void put_byte(Byte[] p, int start, int len);
    internal void put_byte(byte c);
    internal void put_short(int w);
    internal void putShortMSB(int b);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int value_Renamed, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void compress_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal int deflate_stored(int flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    internal void fill_window();
    internal int deflate_fast(int flush);
    internal int deflate_slow(int flush);
    internal int longest_match(int cur_match);
    internal int deflateInit(ZStream strm, int level, int bits);
    internal int deflateInit(ZStream strm, int level);
    internal int deflateInit2(ZStream strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int deflateReset(ZStream strm);
    internal int deflateEnd();
    internal int deflateParams(ZStream strm, int _level, int _strategy);
    internal int deflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal int deflate(ZStream strm, int flush);
}
internal class ComponentAce.Compression.Libs.zlib.InfBlocks : object {
    private static int MANY;
    private static Int32[] inflate_mask;
    internal static Int32[] border;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int TYPE;
    private static int LENS;
    private static int STORED;
    private static int TABLE;
    private static int BTREE;
    private static int DTREE;
    private static int CODES;
    private static int DRY;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InfCodes codes;
    internal int last;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int read;
    internal int write;
    internal object checkfn;
    internal long check;
    internal InfBlocks(ZStream z, object checkfn, int w);
    private static InfBlocks();
    internal void reset(ZStream z, Int64[] c);
    internal int proc(ZStream z, int r);
    internal void free(ZStream z);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
    internal int inflate_flush(ZStream z, int r);
}
internal class ComponentAce.Compression.Libs.zlib.InfCodes : object {
    private static Int32[] inflate_mask;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    internal int mode;
    internal int len;
    internal Int32[] tree;
    internal int tree_index;
    internal int need;
    internal int lit;
    internal int get_Renamed;
    internal int dist;
    internal byte lbits;
    internal byte dbits;
    internal Int32[] ltree;
    internal int ltree_index;
    internal Int32[] dtree;
    internal int dtree_index;
    internal InfCodes(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, ZStream z);
    internal InfCodes(int bl, int bd, Int32[] tl, Int32[] td, ZStream z);
    private static InfCodes();
    internal int proc(InfBlocks s, ZStream z, int r);
    internal void free(ZStream z);
    internal int inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class ComponentAce.Compression.Libs.zlib.Inflate : object {
    private static int MAX_WBITS;
    private static int PRESET_DICT;
    internal static int Z_NO_FLUSH;
    internal static int Z_PARTIAL_FLUSH;
    internal static int Z_SYNC_FLUSH;
    internal static int Z_FULL_FLUSH;
    internal static int Z_FINISH;
    private static int Z_DEFLATED;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int METHOD;
    private static int FLAG;
    private static int DICT4;
    private static int DICT3;
    private static int DICT2;
    private static int DICT1;
    private static int DICT0;
    private static int BLOCKS;
    private static int CHECK4;
    private static int CHECK3;
    private static int CHECK2;
    private static int CHECK1;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int method;
    internal Int64[] was;
    internal long need;
    internal int marker;
    internal int nowrap;
    internal int wbits;
    internal InfBlocks blocks;
    private static Byte[] mark;
    private static Inflate();
    internal int inflateReset(ZStream z);
    internal int inflateEnd(ZStream z);
    internal int inflateInit(ZStream z, int w);
    internal int inflate(ZStream z, int f);
    internal int inflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal int inflateSync(ZStream z);
    internal int inflateSyncPoint(ZStream z);
}
internal class ComponentAce.Compression.Libs.zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    internal static int fixed_bl;
    internal static int fixed_bd;
    internal static Int32[] fixed_tl;
    internal static Int32[] fixed_td;
    internal static Int32[] cplens;
    internal static Int32[] cplext;
    internal static Int32[] cpdist;
    internal static Int32[] cpdext;
    internal static int BMAX;
    private static InfTree();
    internal static int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal static int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal static int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
}
internal class ComponentAce.Compression.Libs.zlib.StaticTree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    internal StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class ComponentAce.Compression.Libs.zlib.SupportClass : object {
    public static long Identity(long literal);
    public static ulong Identity(ulong literal);
    public static float Identity(float literal);
    public static double Identity(double literal);
    public static int URShift(int number, int bits);
    public static int URShift(int number, long bits);
    public static long URShift(long number, int bits);
    public static long URShift(long number, long bits);
    public static int ReadInput(Stream sourceStream, Byte[] target, int start, int count);
    public static int ReadInput(TextReader sourceTextReader, Byte[] target, int start, int count);
    public static Byte[] ToByteArray(string sourceString);
    public static Char[] ToCharArray(Byte[] byteArray);
}
internal class ComponentAce.Compression.Libs.zlib.Tree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree stat_desc;
    private static Tree();
    internal static int d_code(int dist);
    internal void gen_bitlen(Deflate s);
    internal void build_tree(Deflate s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
internal class ComponentAce.Compression.Libs.zlib.ZInputStream : BinaryReader {
    protected ZStream z;
    protected int bufsize;
    protected int flush;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    internal Stream in_Renamed;
    internal bool nomoreinput;
    public int FlushMode { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZInputStream(Stream in_Renamed);
    public ZInputStream(Stream in_Renamed, int level);
    internal void InitBlock();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public virtual int Read();
    public int read(Byte[] b, int off, int len);
    public long skip(long n);
    public virtual void Close();
}
internal class ComponentAce.Compression.Libs.zlib.zlibConst : object {
    private static string version_Renamed_Field;
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_NO_FLUSH;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_ERRNO;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_MEM_ERROR;
    public static int Z_BUF_ERROR;
    public static int Z_VERSION_ERROR;
    public static string version();
}
internal class ComponentAce.Compression.Libs.zlib.ZOutputStream : Stream {
    protected internal ZStream z;
    protected internal int bufsize;
    protected internal int flush_Renamed_Field;
    protected internal Byte[] buf;
    protected internal Byte[] buf1;
    protected internal bool compress;
    private Stream out_Renamed;
    public int FlushMode { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZOutputStream(Stream out_Renamed);
    public ZOutputStream(Stream out_Renamed, int level);
    private void InitBlock();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public void WriteByte(int b);
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] b1, int off, int len);
    public virtual void finish();
    public virtual void end();
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class ComponentAce.Compression.Libs.zlib.ZStream : object {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int MAX_MEM_LEVEL;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    public Byte[] next_in;
    public int next_in_index;
    public int avail_in;
    public long total_in;
    public Byte[] next_out;
    public int next_out_index;
    public int avail_out;
    public long total_out;
    public string msg;
    internal Deflate dstate;
    internal Inflate istate;
    internal int data_type;
    public long adler;
    internal Adler32 _adler;
    public int inflateInit();
    public int inflateReset();
    public int inflateInit(int w);
    public int inflate(int f);
    public int inflateEnd();
    public int inflateSync();
    public int inflateSetDictionary(Byte[] dictionary, int dictLength);
    public int deflateInit(int level);
    public int deflateInit(int level, int bits);
    public int deflate(int flush);
    public int deflateEnd();
    public int deflateParams(int level, int strategy);
    public int deflateSetDictionary(Byte[] dictionary, int dictLength);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
    public void free();
}
internal class ComponentAce.Compression.Libs.zlib.ZStreamException : IOException {
    public ZStreamException(string s);
}
