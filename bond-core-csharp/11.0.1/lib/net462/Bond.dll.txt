internal static class Bond.Audit : object {
    private static void FailArgNull(string paramName);
    private static void FailArgRule(string message);
    public static void ArgNotNull(object value, string paramName);
    public static void ArgRule(bool invariant, string message);
}
[ExtensionAttribute]
internal static class Bond.Blob : object {
    [ExtensionAttribute]
public static bool CompareData(ArraySegment`1<byte> lhs, ArraySegment`1<byte> rhs);
}
[NamespaceAttribute("bond")]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public enum Bond.BondDataType : Enum {
    public int value__;
    public static BondDataType BT_STOP;
    public static BondDataType BT_STOP_BASE;
    public static BondDataType BT_BOOL;
    public static BondDataType BT_UINT8;
    public static BondDataType BT_UINT16;
    public static BondDataType BT_UINT32;
    public static BondDataType BT_UINT64;
    public static BondDataType BT_FLOAT;
    public static BondDataType BT_DOUBLE;
    public static BondDataType BT_STRING;
    public static BondDataType BT_STRUCT;
    public static BondDataType BT_LIST;
    public static BondDataType BT_SET;
    public static BondDataType BT_MAP;
    public static BondDataType BT_INT8;
    public static BondDataType BT_INT16;
    public static BondDataType BT_INT32;
    public static BondDataType BT_INT64;
    public static BondDataType BT_WSTRING;
    public static BondDataType BT_UNAVAILABLE;
}
public class Bond.Bonded`1 : object {
    public static Bonded`1<T> Empty;
    private T instance;
    public Bonded`1(T instance);
    private static Bonded`1();
    private sealed virtual override T Bond.IBonded<T>.Deserialize();
    private sealed virtual override U Bond.IBonded.Deserialize();
    private sealed virtual override void Bond.IBonded.Serialize(W writer);
    private sealed virtual override IBonded`1<U> Bond.IBonded.Convert();
}
public class Bond.Bonded`2 : object {
    internal R reader;
    private RuntimeSchema schema;
    public Bonded`2(R reader);
    public Bonded`2(R reader, RuntimeSchema schema);
    private sealed virtual override T Bond.IBonded<T>.Deserialize();
    private sealed virtual override U Bond.IBonded.Deserialize();
    private sealed virtual override void Bond.IBonded.Serialize(W writer);
    private sealed virtual override IBonded`1<U> Bond.IBonded.Convert();
}
internal class Bond.BondedVoid`1 : object {
    private R reader;
    private RuntimeSchema schema;
    public BondedVoid`1(R reader);
    public BondedVoid`1(R reader, RuntimeSchema schema);
    private sealed virtual override U Bond.IBonded.Deserialize();
    private sealed virtual override void Bond.IBonded.Serialize(W writer);
    private sealed virtual override IBonded`1<U> Bond.IBonded.Convert();
}
public static class Bond.Box : object {
    public static Box`1<T> Create(T value);
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.Box`1 : object {
    [CompilerGeneratedAttribute]
private T <value>k__BackingField;
    [IdAttribute("0")]
[TypeAttribute("Bond.Tag.classT")]
public T value { get; public set; }
    protected Box`1(string fullName, string name);
    [CompilerGeneratedAttribute]
public T get_value();
    [CompilerGeneratedAttribute]
public void set_value(T value);
}
public static class Bond.Clone`1 : object {
    public static T From(SourceT source);
}
public class Bond.Cloner`1 : object {
    private Func`2[] clone;
    public Cloner`1(Type type);
    public Cloner`1(Type type, IParser parser);
    public Cloner`1(Type type, IFactory factory);
    public Cloner`1(Type type, IParser parser, IFactory factory);
    public Cloner`1(Type type, Factory factory);
    public Cloner`1(Type type, IParser parser, Factory factory);
    public T Clone(SourceT source);
    private static Func`2[] Generate(Type type, DeserializerTransform`1<object> transform, IParser parser);
}
public static class Bond.Comparer : object {
    public static bool Equal(T left, T right);
}
public static class Bond.Deserialize : object {
}
public static class Bond.Deserialize`1 : object {
    public static T From(R reader);
}
[ExtensionAttribute]
public static class Bond.Deserializer : object {
    [ExtensionAttribute]
public static T Deserialize(Deserializer`1<R> deserializer, IBonded`1<T> bonded);
}
public class Bond.Deserializer`1 : object {
    internal Func`2[] deserialize;
    public Deserializer`1(Type type, RuntimeSchema schema, IFactory factory, bool inlineNested);
    public Deserializer`1(Type type, RuntimeSchema schema, Factory factory, bool inlineNested);
    public Deserializer`1(Type type, RuntimeSchema schema, IFactory factory);
    public Deserializer`1(Type type, RuntimeSchema schema, Factory factory);
    public Deserializer`1(Type type, RuntimeSchema schema);
    public Deserializer`1(Type type, IFactory factory, bool inlineNested);
    public Deserializer`1(Type type, IParser parser, IFactory factory, bool inlineNested);
    public Deserializer`1(Type type, Factory factory, bool inlineNested);
    public Deserializer`1(Type type, IParser parser, Factory factory, bool inlineNested);
    public Deserializer`1(Type type, IFactory factory);
    public Deserializer`1(Type type, Factory factory);
    public Deserializer`1(Type type);
    public Deserializer`1(Assembly precompiledAssembly, Type type);
    private Deserializer`1(Type type, IParser parser, IFactory factory, Factory factory2, bool inlineNested);
    public T Deserialize(R reader);
    public object Deserialize(R reader);
    public Result TryDeserialize(R reader, T& dest);
    internal static string GetPrecompiledClassName(Type type, string suffix);
}
public class Bond.DeserializerControls : ValueType {
    private int maxPreallocatedContainerElements;
    private int maxPreallocatedBlobBytes;
    private int maxDepth;
    public static DeserializerControls Default;
    public static DeserializerControls Active;
    public int MaxPreallocatedContainerElements { get; public set; }
    public int MaxPreallocatedBlobBytes { get; public set; }
    public int MaxDepth { get; public set; }
    private static DeserializerControls();
    public int get_MaxPreallocatedContainerElements();
    public void set_MaxPreallocatedContainerElements(int value);
    public int get_MaxPreallocatedBlobBytes();
    public void set_MaxPreallocatedBlobBytes(int value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
}
internal class Bond.Expressions.BaseHandler : MulticastDelegate {
    public BaseHandler(object object, IntPtr method);
    public virtual Expression Invoke(IParser parser);
    public virtual IAsyncResult BeginInvoke(IParser parser, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
internal class Bond.Expressions.BeginHandler : MulticastDelegate {
    public BeginHandler(object object, IntPtr method);
    public virtual Expression Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public class Bond.Expressions.ContainerHandler : MulticastDelegate {
    public ContainerHandler(object object, IntPtr method);
    public virtual Expression Invoke(IParser valueParser, Expression valueType, Expression next, Expression count, ParameterExpression arraySegment);
    public virtual IAsyncResult BeginInvoke(IParser valueParser, Expression valueType, Expression next, Expression count, ParameterExpression arraySegment, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
internal static class Bond.Expressions.ControlExpression : object {
    public static Expression While(Expression whileCondition, Expression body);
    public static Expression While(Expression whileCondition, Expression body, LabelTarget breakLabel);
    public static Expression DoWhile(Expression body, Expression condition);
    public static Expression DoWhile(Expression body, Expression condition, LabelTarget breakLabel);
}
internal static class Bond.Expressions.DataExpression : object {
    public static MemberExpression PropertyOrField(Expression expression, string name);
}
internal class Bond.Expressions.DeferredSwitchCase : object {
    [CompilerGeneratedAttribute]
private Func`1<Expression> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Expression> <TestValues>k__BackingField;
    public SwitchCase SwitchCase { get; }
    public Func`1<Expression> Body { get; private set; }
    public IEnumerable`1<Expression> TestValues { get; private set; }
    public DeferredSwitchCase(Func`1<Expression> body, IEnumerable`1<Expression> testValues);
    public SwitchCase get_SwitchCase();
    [CompilerGeneratedAttribute]
public Func`1<Expression> get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(Func`1<Expression> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Expression> get_TestValues();
    [CompilerGeneratedAttribute]
private void set_TestValues(IEnumerable`1<Expression> value);
}
internal class Bond.Expressions.DeserializerTransform`1 : object {
    private Factory newObject;
    private Factory newBonded;
    private Factory newContainer;
    private bool inlineNested;
    private TypeAlias typeAlias;
    private Expression`1<Func`3<R, int, object>> deferredDeserialize;
    private List`1<Expression`1<Func`2<R, object>>> deserializeFuncs;
    private Dictionary`2<Type, int> deserializeIndex;
    private Stack`1<Type> inProgress;
    private static MethodInfo bondedConvert;
    private static MethodInfo bondedDeserialize;
    private static MethodInfo arrayResize;
    private static ConstructorInfo arraySegmentCtor;
    private static MethodInfo bufferBlockCopy;
    private static HashSet`1<string> immutableListSetTypeNames;
    private static HashSet`1<string> immutableMapTypeNames;
    private static HashSet`1<string> immutableCollectionTypeNames;
    public DeserializerTransform`1(Expression`1<Func`3<R, int, object>> deferredDeserialize, Factory factory, bool inlineNested);
    public DeserializerTransform`1(Expression`1<Func`3<R, int, object>> deferredDeserialize, bool inlineNested, Expression`1<Func`3<Type, Type, object>> createObject, Expression`1<Func`4<Type, Type, int, object>> createContainer);
    private static DeserializerTransform`1();
    public IEnumerable`1<Expression`1<Func`2<R, object>>> Generate(IParser parser, Type type);
    private Expression Deserialize(IParser parser, Expression var, Type objectType, Type schemaType, bool initialize);
    private Expression Struct(IParser parser, Expression var, Type schemaType, bool initialize);
    private Expression Nullable(IParser parser, Expression var, Type schemaType, bool initialize);
    private Expression Container(IParser parser, Expression container, Type schemaType, bool initialize);
    private Expression Map(IParser parser, Expression map, Type schemaType, bool initialize);
    private Expression ApplyCountCap(Expression originalCount, ParameterExpression cappedCount, int maxAllowedCount, Expression expression);
    private Expression FieldValue(IParser parser, Expression var, Expression valueType, Type schemaType, bool initialize);
    private Expression Value(IParser parser, Expression var, Expression valueType, Type schemaType, bool initialize);
    private static Expression New(Type type, Type schemaType, Expression[] arguments);
}
internal class Bond.Expressions.EndHandler : MulticastDelegate {
    public EndHandler(object object, IntPtr method);
    public virtual Expression Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
internal class Bond.Expressions.Field : object {
    private ushort id;
    private KnownFieldHandler value;
    private OmittedFieldHandler omitted;
    private ushort Bond.Expressions.IField.Id { get; }
    private Expression Bond.Expressions.IField.Omitted { get; }
    public Field(ushort Id, KnownFieldHandler Value, OmittedFieldHandler Omitted);
    private sealed virtual override ushort Bond.Expressions.IField.get_Id();
    private sealed virtual override Expression Bond.Expressions.IField.Value(IParser parser, Expression valueType);
    private sealed virtual override Expression Bond.Expressions.IField.get_Omitted();
}
public interface Bond.Expressions.IField {
    public ushort Id { get; }
    public Expression Omitted { get; }
    public abstract virtual ushort get_Id();
    public abstract virtual Expression Value(IParser parser, Expression valueType);
    public abstract virtual Expression get_Omitted();
}
public interface Bond.Expressions.IParser {
    public ParameterExpression ReaderParam { get; }
    public Expression ReaderValue { get; }
    public int HierarchyDepth { get; }
    public bool IsBonded { get; }
    public abstract virtual Expression Apply(ITransform transform);
    public abstract virtual Expression Container(Nullable`1<BondDataType> expectedType, ContainerHandler handler);
    public abstract virtual Expression Map(Nullable`1<BondDataType> expectedKeyType, Nullable`1<BondDataType> expectedValueType, MapHandler handler);
    public abstract virtual Expression Blob(Expression count);
    public abstract virtual Expression Scalar(Expression valueType, BondDataType expectedType, ValueHandler handler);
    public abstract virtual Expression Bonded(ValueHandler handler);
    public abstract virtual Expression Skip(Expression valueType);
    public abstract virtual ParameterExpression get_ReaderParam();
    public abstract virtual Expression get_ReaderValue();
    public abstract virtual int get_HierarchyDepth();
    public abstract virtual bool get_IsBonded();
}
public interface Bond.Expressions.ISerializerGenerator`2 {
    public abstract virtual IEnumerable`1<Expression`1<Action`2<R, W>>> Generate(IParser parser);
}
public interface Bond.Expressions.ITransform {
    public Expression Begin { get; }
    public IEnumerable`1<IField> Fields { get; }
    public Expression UnknownEnd { get; }
    public Expression End { get; }
    public abstract virtual Expression get_Begin();
    public abstract virtual Expression Base(IParser parser);
    public abstract virtual IEnumerable`1<IField> get_Fields();
    public abstract virtual Expression UnknownField(IParser parser, Expression fieldType, Expression fieldId);
    public abstract virtual Expression get_UnknownEnd();
    public abstract virtual Expression get_End();
}
internal class Bond.Expressions.KnownFieldHandler : MulticastDelegate {
    public KnownFieldHandler(object object, IntPtr method);
    public virtual Expression Invoke(IParser parser, Expression fieldType);
    public virtual IAsyncResult BeginInvoke(IParser parser, Expression fieldType, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public class Bond.Expressions.MapHandler : MulticastDelegate {
    public MapHandler(object object, IntPtr method);
    public virtual Expression Invoke(IParser keyParser, IParser valueParser, Expression keyType, Expression valueType, Expression nextKey, Expression nextValue, Expression count);
    public virtual IAsyncResult BeginInvoke(IParser keyParser, IParser valueParser, Expression keyType, Expression valueType, Expression nextKey, Expression nextValue, Expression count, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public class Bond.Expressions.ObjectBondedFactory : MulticastDelegate {
    public ObjectBondedFactory(object object, IntPtr method);
    public virtual Expression Invoke(Type objectType, Expression value);
    public virtual IAsyncResult BeginInvoke(Type objectType, Expression value, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public class Bond.Expressions.ObjectParser : object {
    private static MethodInfo moveNext;
    private static ConstructorInfo arraySegmentCtor;
    private ParameterExpression objParam;
    private TypeAlias typeAlias;
    private Expression value;
    private Type schemaType;
    private Type objectType;
    private int hierarchyDepth;
    private ObjectBondedFactory bondedFactory;
    public ParameterExpression ReaderParam { get; }
    public Expression ReaderValue { get; }
    public int HierarchyDepth { get; }
    public bool IsBonded { get; }
    public ObjectParser(Type type);
    public ObjectParser(Type type, ObjectBondedFactory bondedFactory);
    private ObjectParser(ObjectParser that, Expression value, Type schemaType);
    private static ObjectParser();
    public sealed virtual ParameterExpression get_ReaderParam();
    public sealed virtual Expression get_ReaderValue();
    public sealed virtual int get_HierarchyDepth();
    public sealed virtual bool get_IsBonded();
    public sealed virtual Expression Apply(ITransform transform);
    private Expression Field(ITransform transform, Expression structVar, ushort id, ISchemaField schemaField, IField field);
    public sealed virtual Expression Container(Nullable`1<BondDataType> expectedType, ContainerHandler handler);
    public sealed virtual Expression Map(Nullable`1<BondDataType> expectedKeyType, Nullable`1<BondDataType> expectedValueType, MapHandler handler);
    public sealed virtual Expression Scalar(Expression valueType, BondDataType expectedType, ValueHandler handler);
    public sealed virtual Expression Bonded(ValueHandler handler);
    public sealed virtual Expression Blob(Expression count);
    public sealed virtual Expression Skip(Expression valueType);
    public virtual bool Equals(object that);
    public virtual int GetHashCode();
    private static Expression NewBonded(Type objectType, Expression value);
    private static Expression ContainerCount(Expression container);
    private Expression EnumerableContainer(ContainerItemHandler handler);
    private Expression ListContainer(ContainerItemHandler handler);
    private Expression ArrayContainer(ContainerItemHandler handler);
    private Expression LinkedListContainer(ContainerItemHandler handler);
    private Expression Nullable(ContainerHandler handler);
    private Expression BlobContainer(ContainerHandler handler);
}
internal class Bond.Expressions.OmittedFieldHandler : MulticastDelegate {
    public OmittedFieldHandler(object object, IntPtr method);
    public virtual Expression Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public static class Bond.Expressions.ParserFactory`1 : object {
    public static IParser Create(S schema);
    public static IParser Create(S schema, PayloadBondedFactory bondedFactory);
}
public class Bond.Expressions.PayloadBondedFactory : MulticastDelegate {
    public PayloadBondedFactory(object object, IntPtr method);
    public virtual Expression Invoke(Expression reader, Expression schema);
    public virtual IAsyncResult BeginInvoke(Expression reader, Expression schema, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
internal class Bond.Expressions.ProtocolWriter`1 : object {
    private ParameterExpression writer;
    private static MethodInfo marshalBonded;
    private static MethodInfo serializeBonded;
    private static MethodInfo writeBytes;
    private static MethodInfo structBegin;
    private static MethodInfo baseBegin;
    private static MethodInfo structEnd;
    private static MethodInfo baseEnd;
    private static MethodInfo fieldBegin;
    private static MethodInfo fieldEnd;
    private static MethodInfo fieldOmitted;
    private static MethodInfo containerBegin;
    private static MethodInfo containerBegin2;
    private static MethodInfo containerEnd;
    private static MethodInfo itemBegin;
    private static MethodInfo itemEnd;
    private static bool untaggedProtocol;
    private static Dictionary`2<BondDataType, MethodInfo> write;
    public ParameterExpression Param { get; }
    private static ProtocolWriter`1();
    private static MethodInfo GetMethod(MethodInfo method);
    public ParameterExpression get_Param();
    public Expression WriteStructBegin(Expression metadata);
    public Expression WriteBaseBegin(Expression metadata);
    public Expression WriteStructEnd();
    public Expression WriteBaseEnd();
    public Expression WriteFieldBegin(Expression type, ushort id, Metadata metadata);
    public Expression WriteFieldBegin(Expression type, Expression id, Expression metadata);
    public Expression WriteFieldOmitted(BondDataType type, ushort id, Metadata metadata);
    public Expression WriteFieldEnd();
    public Expression WriteContainerBegin(Expression count, Expression valueType);
    public Expression WriteContainerBegin(Expression count, Expression keyType, Expression valueType);
    public Expression WriteContainerEnd();
    public Expression WriteItemBegin();
    public Expression WriteItemEnd();
    public Expression Write(Expression value, BondDataType type);
    public Expression WriteBytes(Expression data);
    public Expression WriteBonded(Expression value);
}
[ExtensionAttribute]
internal static class Bond.Expressions.PrunedExpression : object {
    public static Expression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
    public static Expression Switch(Expression switchValue, Expression defaultBody, IEnumerable`1<DeferredSwitchCase> switchCases);
    public static DeferredSwitchCase SwitchCase(Func`1<Expression> body, T[] testValues);
    [ExtensionAttribute]
private static bool IsEqual(Expression ex, T value);
    [ExtensionAttribute]
private static bool IsEqual(ConstantExpression ex, T value);
    [ExtensionAttribute]
private static bool IsEqual(BinaryExpression ex, T value);
    private static bool AreEqual(ConstantExpression left, Expression right);
    public static Expression Convert(Expression value, Type type);
}
internal class Bond.Expressions.Pull.FlatteningParser : object {
    private RuntimeSchema schema;
    private List`1<TransformSchemaPair> pairs;
    public IEnumerable`1<TransformSchemaPair> Transforms { get; }
    public ParameterExpression ReaderParam { get; }
    public Expression ReaderValue { get; }
    public int HierarchyDepth { get; }
    public bool IsBonded { get; }
    public FlatteningParser(RuntimeSchema rootSchema);
    public IEnumerable`1<TransformSchemaPair> get_Transforms();
    public sealed virtual Expression Apply(ITransform transform);
    public sealed virtual Expression Container(Nullable`1<BondDataType> expectedType, ContainerHandler handler);
    public sealed virtual Expression Map(Nullable`1<BondDataType> expectedKeyType, Nullable`1<BondDataType> expectedValueType, MapHandler handler);
    public sealed virtual Expression Blob(Expression count);
    public sealed virtual Expression Scalar(Expression valueType, BondDataType expectedType, ValueHandler handler);
    public sealed virtual Expression Bonded(ValueHandler handler);
    public sealed virtual Expression Skip(Expression valueType);
    public sealed virtual ParameterExpression get_ReaderParam();
    public sealed virtual Expression get_ReaderValue();
    public sealed virtual int get_HierarchyDepth();
    public sealed virtual bool get_IsBonded();
}
public interface Bond.Expressions.Pull.IStateMachine`1 {
    public byte InitialState { get; }
    public byte FinalState { get; }
    public IEnumerable`1<T> IgnoredTokens { get; }
    public IEnumerable`1<ITokenTransition`1<T>> TokenTransitions { get; }
    public abstract virtual byte get_InitialState();
    public abstract virtual byte get_FinalState();
    public abstract virtual IEnumerable`1<T> get_IgnoredTokens();
    public abstract virtual IEnumerable`1<ITokenTransition`1<T>> get_TokenTransitions();
    public abstract virtual Expression Default(Expression state);
}
public interface Bond.Expressions.Pull.IStateTransition {
    public byte State { get; }
    public abstract virtual byte get_State();
    public abstract virtual Expression Body(Expression state);
}
public interface Bond.Expressions.Pull.ITokenTransition`1 {
    public T Token { get; }
    public IEnumerable`1<IStateTransition> StateTransitions { get; }
    public abstract virtual T get_Token();
    public abstract virtual IEnumerable`1<IStateTransition> get_StateTransitions();
    public abstract virtual Expression Default(Expression state);
}
public abstract class Bond.Expressions.Pull.PullParser`1 : object {
    private RuntimeSchema schema;
    private bool flatten;
    protected RuntimeSchema Schema { get; }
    protected Expression EOF { get; }
    public ParameterExpression ReaderParam { get; }
    public Expression ReaderValue { get; }
    public int HierarchyDepth { get; }
    public bool IsBonded { get; }
    protected PullParser`1(RuntimeSchema schema, bool flatten);
    protected PullParser`1(PullParser`1<T> that, RuntimeSchema schema, bool flatten);
    protected RuntimeSchema get_Schema();
    protected abstract virtual Expression Read();
    protected abstract virtual Expression get_EOF();
    protected abstract virtual Expression Token();
    public virtual Expression Apply(ITransform transform);
    private IList`1<string> GetRequiredFieldNames();
    private static Expression VerifyRequiredFields(ParameterExpression fields, IList`1<string> names);
    public abstract virtual Expression Container(Nullable`1<BondDataType> expectedType, ContainerHandler handler);
    public abstract virtual Expression Map(Nullable`1<BondDataType> expectedKeyType, Nullable`1<BondDataType> expectedValueType, MapHandler handler);
    public abstract virtual Expression Blob(Expression count);
    public abstract virtual Expression Scalar(Expression valueType, BondDataType expectedType, ValueHandler handler);
    public virtual Expression Bonded(ValueHandler handler);
    public virtual Expression Skip(Expression valueType);
    public abstract virtual ParameterExpression get_ReaderParam();
    public abstract virtual Expression get_ReaderValue();
    public sealed virtual int get_HierarchyDepth();
    public sealed virtual bool get_IsBonded();
    public virtual bool Equals(object that);
    public virtual int GetHashCode();
    protected abstract virtual IStateMachine`1<T> CreateStateMachine(IEnumerable`1<TransformSchemaPair> transforms, ParameterExpression requiredFields);
    private Expression SwitchToken(IStateMachine`1<T> machine, Expression state);
    private static SwitchCase CaseForToken(ITokenTransition`1<T> tokenTransition, Expression state);
}
internal class Bond.Expressions.Pull.StateMachine`1 : object {
    [CompilerGeneratedAttribute]
private byte <InitialState>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <FinalState>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<T> <IgnoredTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITokenTransition`1<T>> <TokenTransitions>k__BackingField;
    [CompilerGeneratedAttribute]
private TransitionBody <Default>k__BackingField;
    public byte InitialState { get; public set; }
    public byte FinalState { get; public set; }
    public IEnumerable`1<T> IgnoredTokens { get; public set; }
    public IEnumerable`1<ITokenTransition`1<T>> TokenTransitions { get; public set; }
    private TransitionBody Default { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual byte get_InitialState();
    [CompilerGeneratedAttribute]
public void set_InitialState(byte value);
    [CompilerGeneratedAttribute]
public sealed virtual byte get_FinalState();
    [CompilerGeneratedAttribute]
public void set_FinalState(byte value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<T> get_IgnoredTokens();
    [CompilerGeneratedAttribute]
public void set_IgnoredTokens(IEnumerable`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ITokenTransition`1<T>> get_TokenTransitions();
    [CompilerGeneratedAttribute]
public void set_TokenTransitions(IEnumerable`1<ITokenTransition`1<T>> value);
    [CompilerGeneratedAttribute]
private TransitionBody get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(TransitionBody value);
    private sealed virtual override Expression Bond.Expressions.Pull.IStateMachine<T>.Default(Expression state);
}
internal class Bond.Expressions.Pull.StateTransition : object {
    [CompilerGeneratedAttribute]
private byte <State>k__BackingField;
    [CompilerGeneratedAttribute]
private TransitionBody <Body>k__BackingField;
    public byte State { get; private set; }
    private TransitionBody Body { get; private set; }
    public StateTransition(byte state, TransitionBody body);
    public StateTransition(byte currentState, byte nextState, TransitionBody body);
    [CompilerGeneratedAttribute]
public sealed virtual byte get_State();
    [CompilerGeneratedAttribute]
private void set_State(byte value);
    [CompilerGeneratedAttribute]
private TransitionBody get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(TransitionBody value);
    private sealed virtual override Expression Bond.Expressions.Pull.IStateTransition.Body(Expression state);
}
internal class Bond.Expressions.Pull.TokenTransition`1 : object {
    [CompilerGeneratedAttribute]
private T <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IStateTransition> <StateTransitions>k__BackingField;
    [CompilerGeneratedAttribute]
private TransitionBody <Default>k__BackingField;
    public T Token { get; public set; }
    public IEnumerable`1<IStateTransition> StateTransitions { get; public set; }
    private TransitionBody Default { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual T get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(T value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IStateTransition> get_StateTransitions();
    [CompilerGeneratedAttribute]
public void set_StateTransitions(IEnumerable`1<IStateTransition> value);
    [CompilerGeneratedAttribute]
private TransitionBody get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(TransitionBody value);
    private sealed virtual override Expression Bond.Expressions.Pull.ITokenTransition<T>.Default(Expression state);
}
public class Bond.Expressions.Pull.TransformSchemaPair : object {
    [CompilerGeneratedAttribute]
private ITransform <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeSchema <Schema>k__BackingField;
    public ITransform Transform { get; private set; }
    public RuntimeSchema Schema { get; private set; }
    public TransformSchemaPair(ITransform transform, RuntimeSchema schema);
    [CompilerGeneratedAttribute]
public ITransform get_Transform();
    [CompilerGeneratedAttribute]
private void set_Transform(ITransform value);
    [CompilerGeneratedAttribute]
public RuntimeSchema get_Schema();
    [CompilerGeneratedAttribute]
private void set_Schema(RuntimeSchema value);
}
internal class Bond.Expressions.Pull.TransitionBody : MulticastDelegate {
    public TransitionBody(object object, IntPtr method);
    public virtual Expression Invoke(Expression state);
    public virtual IAsyncResult BeginInvoke(Expression state, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
internal static class Bond.Expressions.RequiredFields : object {
    private static ConstructorInfo ctor;
    private static PropertyInfo isAnySet;
    private static PropertyInfo firstSet;
    private static MethodInfo reset;
    private static RequiredFields();
    public static ParameterExpression Variable(string name);
    public static Expression Init(ParameterExpression requiredFields, int count);
    public static Expression Mark(ParameterExpression requiredFields, int index);
    public static Expression IfMissingAny(ParameterExpression requiredFields, Expression then);
    public static Expression FirstMissing(Expression fields);
}
public abstract class Bond.Expressions.SerializerGenerator`2 : object {
    private Expression`1<Action`3<R, W, int>> deferredSerialize;
    private List`1<Expression`1<Action`2<R, W>>> serializeActions;
    private Dictionary`2<KeyValuePair`2<IParser, Serialize<R, W>>, int> serializeIndex;
    private Stack`1<KeyValuePair`2<IParser, Serialize<R, W>>> inProgress;
    protected IEnumerable`1<Expression`1<Action`2<R, W>>> SerializeActions { get; }
    protected SerializerGenerator`2(Expression`1<Action`3<R, W, int>> deferredSerialize);
    public abstract virtual IEnumerable`1<Expression`1<Action`2<R, W>>> Generate(IParser parser);
    protected IEnumerable`1<Expression`1<Action`2<R, W>>> get_SerializeActions();
    protected Expression GenerateSerialize(Serialize<R, W> serialize, IParser parser, ParameterExpression writer, bool inline);
}
internal static class Bond.Expressions.SerializerGeneratorFactory`2 : object {
    public static ISerializerGenerator`2<R, W> Create(Expression`1<Action`3<R, W, int>> deferredSerialize, S schema, bool inlineNested);
}
internal class Bond.Expressions.SerializerTransform`2 : SerializerGenerator`2<R, W> {
    private static Expression noMetadata;
    private RuntimeSchema runtimeSchema;
    private ProtocolWriter`1<W> writer;
    private Dictionary`2<RuntimeSchema, Serialize<R, W>> serializeDelegates;
    private bool inlineNested;
    private static bool untaggedWriter;
    private static bool binaryWriter;
    public SerializerTransform`2(Expression`1<Action`3<R, W, int>> deferredSerialize, RuntimeSchema schema, bool inlineNested);
    public SerializerTransform`2(Expression`1<Action`3<R, W, int>> deferredSerialize, Type type, bool inlineNested);
    private static SerializerTransform`2();
    public virtual IEnumerable`1<Expression`1<Action`2<R, W>>> Generate(IParser parser);
    private Expression GenerateSerialize(Serialize<R, W> serialize, IParser parser);
    private Expression GenerateSerialize(SerializeWithSchema<R, W> serializeWithSchema, IParser parser, RuntimeSchema schema);
    private Expression Struct(IParser parser);
    private Expression Struct(IParser parser, RuntimeSchema schema);
    private Expression Struct(IParser parser, RuntimeSchema schema, bool isBase);
    private Expression Container(IParser parser);
    private Expression Container(IParser parser, RuntimeSchema schema);
    private Expression Map(IParser parser);
    private Expression Map(IParser parser, RuntimeSchema schema);
    private Expression Value(IParser parser, Expression valueType);
    private Expression Value(IParser parser, Expression valueType, RuntimeSchema schema);
}
internal static class Bond.Expressions.StringExpression : object {
    private static Expression invariantCulture;
    private static MethodInfo equals;
    private static MethodInfo format;
    private static MethodInfo getHashCode;
    private static FieldInfo stringEmpty;
    private static IDictionary`2<BondDataType, MethodInfo> methods;
    private static StringExpression();
    public static Expression Convert(Expression valueAsString, BondDataType type);
    public static Expression Equals(Expression a, Expression b, StringComparison comparison);
    public static Expression Equals(Expression a, string b, StringComparison comparison);
    public static Expression GetHashCode(Expression s);
    public static Expression Format(string format, Expression[] argumentExpressions);
    public static Expression Empty();
}
public class Bond.Expressions.TaggedParser`1 : object {
    private TaggedReader`1<R> reader;
    private PayloadBondedFactory bondedFactory;
    private TaggedParser`1<R> baseParser;
    private TaggedParser`1<R> fieldParser;
    private bool isBase;
    public ParameterExpression ReaderParam { get; }
    public Expression ReaderValue { get; }
    public int HierarchyDepth { get; }
    public bool IsBonded { get; }
    public TaggedParser`1(RuntimeSchema schema);
    public TaggedParser`1(RuntimeSchema schema, PayloadBondedFactory bondedFactory);
    public TaggedParser`1(Type type);
    public TaggedParser`1(Type type, PayloadBondedFactory bondedFactory);
    private TaggedParser`1(PayloadBondedFactory bondedFactory);
    private TaggedParser`1(TaggedParser`1<R> that, bool isBase);
    public sealed virtual ParameterExpression get_ReaderParam();
    public sealed virtual Expression get_ReaderValue();
    public sealed virtual int get_HierarchyDepth();
    public sealed virtual bool get_IsBonded();
    public sealed virtual Expression Apply(ITransform transform);
    public sealed virtual Expression Container(Nullable`1<BondDataType> expectedType, ContainerHandler handler);
    public sealed virtual Expression Map(Nullable`1<BondDataType> expectedKeyType, Nullable`1<BondDataType> expectedValueType, MapHandler handler);
    public sealed virtual Expression Blob(Expression count);
    public sealed virtual Expression Scalar(Expression valueType, BondDataType expectedType, ValueHandler handler);
    public sealed virtual Expression Bonded(ValueHandler handler);
    public sealed virtual Expression Skip(Expression type);
    private static Expression NewBonded(Expression reader, Expression schema);
    private static Expression MatchOrCompatible(Expression valueType, Nullable`1<BondDataType> expectedType, TypeHandlerRuntime<R> handler);
    private static Expression MatchOrCompatible(Expression valueType, BondDataType expectedType, TypeHandlerCompiletime<R> handler);
    private static Expression MatchOrElse(Expression valueType, BondDataType expectedType, TypeHandlerCompiletime<R> handler, Expression orElse);
    private static Expression TryCompatible(Expression valueType, BondDataType expectedType, TypeHandlerCompiletime<R> handler);
    private static Expression InvalidType(BondDataType expectedType, Expression valueType);
}
internal class Bond.Expressions.TaggedReader`1 : object {
    private ParameterExpression reader;
    private static MethodInfo structBegin;
    private static MethodInfo baseBegin;
    private static MethodInfo structEnd;
    private static MethodInfo baseEnd;
    private static MethodInfo fieldBegin;
    private static MethodInfo fieldEnd;
    private static MethodInfo containerBegin;
    private static MethodInfo containerBegin2;
    private static MethodInfo containerEnd;
    private static MethodInfo readBytes;
    private static MethodInfo skip;
    private static Dictionary`2<BondDataType, MethodInfo> read;
    public ParameterExpression Param { get; }
    private static TaggedReader`1();
    private static MethodInfo GetMethod(MethodInfo method);
    private static MethodInfo GetMethod(string name, Type[] paramTypes);
    public ParameterExpression get_Param();
    public Expression ReadStructBegin();
    public Expression ReadBaseBegin();
    public Expression ReadStructEnd();
    public Expression ReadBaseEnd();
    public Expression ReadFieldBegin(Expression type, Expression id);
    public Expression ReadFieldEnd();
    public Expression ReadContainerBegin(Expression count, Expression type);
    public Expression ReadContainerBegin(Expression count, Expression keyType, Expression valueType);
    public Expression ReadContainerEnd();
    public Expression Read(BondDataType type);
    public Expression Skip(Expression type);
    public Expression ReadBytes(Expression count);
}
internal static class Bond.Expressions.ThrowExpression : object {
    private static Expression`1<Action`1<BondDataType>> throwInvalidTypeException;
    private static Expression`1<Action`2<BondDataType, BondDataType>> throwInvalidTypeException2;
    private static Expression`1<Action`1<string>> throwInvalidDataException;
    private static Expression`1<Action`2<string, string>> throwRequiredFieldMissingException;
    private static Expression`1<Action`2<List`1<string>, int>> throwRequiredFieldsMissingException;
    private static ThrowExpression();
    public static Expression InvalidTypeException(Expression actualType);
    public static Expression InvalidTypeException(Expression expectedType, Expression actualType);
    public static Expression InvalidDataException(string message);
    public static Expression InvalidDataException(Expression message);
    public static Expression RequiredFieldMissingException(string schema, Expression field);
    public static Expression RequiredFieldsMissingException(Expression fields, IEnumerable`1<string> names);
    private static void ThrowInvalidTypeException(BondDataType actualType);
    private static void ThrowInvalidTypeException(BondDataType expectedType, BondDataType actualType);
    private static void ThrowInvalidDataException(string message);
    private static void ThrowRequiredFieldMissingException(string schema, string field);
    private static void ThrowRequiredFieldsMissingException(List`1<string> names, int index);
}
internal class Bond.Expressions.Transform : object {
    private BeginHandler begin;
    private EndHandler end;
    private BaseHandler base_;
    private UnknownEndHandler unknownEnd;
    private IEnumerable`1<IField> fields;
    private UnknownFieldHandler unknownField;
    private Expression Bond.Expressions.ITransform.Begin { get; }
    private Expression Bond.Expressions.ITransform.End { get; }
    private Expression Bond.Expressions.ITransform.UnknownEnd { get; }
    private IEnumerable`1<IField> Bond.Expressions.ITransform.Fields { get; }
    public Transform(BeginHandler Begin, EndHandler End, IEnumerable`1<IField> Fields, UnknownFieldHandler UnknownField, BaseHandler Base, UnknownEndHandler UnknownEnd);
    private sealed virtual override Expression Bond.Expressions.ITransform.get_Begin();
    private sealed virtual override Expression Bond.Expressions.ITransform.get_End();
    private sealed virtual override Expression Bond.Expressions.ITransform.Base(IParser parser);
    private sealed virtual override Expression Bond.Expressions.ITransform.get_UnknownEnd();
    private sealed virtual override IEnumerable`1<IField> Bond.Expressions.ITransform.get_Fields();
    private sealed virtual override Expression Bond.Expressions.ITransform.UnknownField(IParser parser, Expression fieldType, Expression fieldId);
}
internal class Bond.Expressions.TypeAlias : object {
    private HashSet`1<Type> converters;
    public TypeAlias(Type type);
    public Expression Assign(Expression left, Expression right);
    public Expression Convert(Expression value, Type type);
    private static void GetSchemaTypes(Type type, HashSet`1<Type> schemaTypes);
    private static Type GetConverter(Type type);
}
internal class Bond.Expressions.UnknownEndHandler : MulticastDelegate {
    public UnknownEndHandler(object object, IntPtr method);
    public virtual Expression Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
internal class Bond.Expressions.UnknownFieldHandler : MulticastDelegate {
    public UnknownFieldHandler(object object, IntPtr method);
    public virtual Expression Invoke(IParser parser, Expression fieldType, Expression fieldId);
    public virtual IAsyncResult BeginInvoke(IParser parser, Expression fieldType, Expression fieldId, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public class Bond.Expressions.UntaggedParser`1 : object {
    private static ITransform skipStructTransform;
    private RuntimeSchema schema;
    private UntaggedReader`1<R> reader;
    private DeferredSkip<R> deferredSkip;
    private int hierarchyDepth;
    private PayloadBondedFactory bondedFactory;
    public ParameterExpression ReaderParam { get; }
    public Expression ReaderValue { get; }
    public int HierarchyDepth { get; }
    public bool IsBonded { get; }
    public UntaggedParser`1(RuntimeSchema schema);
    public UntaggedParser`1(RuntimeSchema schema, PayloadBondedFactory bondedFactory);
    public UntaggedParser`1(Type type);
    public UntaggedParser`1(Type type, PayloadBondedFactory bondedFactory);
    private UntaggedParser`1(UntaggedParser`1<R> that, RuntimeSchema schema);
    private UntaggedParser`1(UntaggedReader`1<R> reader, DeferredSkip<R> deferredSkip, RuntimeSchema schema, PayloadBondedFactory bondedFactory);
    private static UntaggedParser`1();
    public sealed virtual ParameterExpression get_ReaderParam();
    public sealed virtual Expression get_ReaderValue();
    public sealed virtual int get_HierarchyDepth();
    public sealed virtual bool get_IsBonded();
    public sealed virtual Expression Apply(ITransform transform);
    private Expression Field(ITransform transform, FieldDef fieldDef, IField field);
    public sealed virtual Expression Container(Nullable`1<BondDataType> expectedType, ContainerHandler handler);
    public sealed virtual Expression Map(Nullable`1<BondDataType> expectedKeyType, Nullable`1<BondDataType> expectedValueType, MapHandler handler);
    public sealed virtual Expression Blob(Expression count);
    public sealed virtual Expression Scalar(Expression valueType, BondDataType expectedType, ValueHandler handler);
    public sealed virtual Expression Bonded(ValueHandler handler);
    public sealed virtual Expression Skip(Expression valueType);
    private static Expression NewBonded(Expression reader, Expression schema);
    private Expression SkipSet();
    private Expression SkipList();
    private Expression SkipMap();
    private Expression SkipStruct();
    private Expression SkipStruct(Expression`1<Action`1<R>> skip);
    public virtual bool Equals(object that);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private Expression <SkipList>b__31_0(IParser valueParser, Expression elementType, Expression next, Expression count, ParameterExpression arraySegment);
}
internal class Bond.Expressions.UntaggedReader`1 : object {
    private static MethodInfo unmarshalBonded;
    private static MethodInfo fieldOmitted;
    private static MethodInfo containerBegin;
    private static MethodInfo containerEnd;
    private static MethodInfo readBytes;
    private static MethodInfo skipBytes;
    private static Dictionary`2<BondDataType, MethodInfo> read;
    private static Dictionary`2<BondDataType, MethodInfo> skip;
    private ParameterExpression reader;
    public ParameterExpression Param { get; }
    private static UntaggedReader`1();
    private static MethodInfo GetMethod(MethodInfo method);
    public ParameterExpression get_Param();
    public Expression ReadFieldOmitted();
    public Expression ReadContainerBegin();
    public Expression ReadContainerEnd();
    public Expression Read(BondDataType type);
    public Expression Skip(BondDataType type);
    public Expression ReadBytes(Expression count);
    public Expression SkipBytes(Expression count);
    public Expression ReadMarshaledBonded();
}
public class Bond.Expressions.ValueHandler : MulticastDelegate {
    public ValueHandler(object object, IntPtr method);
    public virtual Expression Invoke(Expression value);
    public virtual IAsyncResult BeginInvoke(Expression value, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public class Bond.Expressions.Xml.SimpleXmlParser`1 : XmlParser`1<R> {
    private static Expression`1<Action`4<byte, XmlNodeType, string, string>> parsingError;
    private static Expression`1<Action`1<XmlNodeType>> unexpectedNodeError;
    public SimpleXmlParser`1(RuntimeSchema schema);
    public SimpleXmlParser`1(Type type);
    private SimpleXmlParser`1(XmlParser`1<R> that, RuntimeSchema schema);
    private static SimpleXmlParser`1();
    protected virtual IStateMachine`1<XmlNodeType> CreateStateMachine(IEnumerable`1<TransformSchemaPair> transforms, ParameterExpression requiredFields);
    private Expression ProcessStructElement(Expression state);
    private Expression ProcessFieldElement(Expression state, ParameterExpression requiredFields, IEnumerable`1<TransformSchemaPair> transforms);
    public virtual Expression Apply(ITransform transform);
    public virtual Expression Blob(Expression count);
    public virtual Expression Scalar(Expression valueType, BondDataType expectedType, ValueHandler handler);
    public virtual Expression Container(Nullable`1<BondDataType> expectedType, ContainerHandler handler);
    public virtual Expression Map(Nullable`1<BondDataType> expectedKeyType, Nullable`1<BondDataType> expectedValueType, MapHandler handler);
    private Expression Items(ContainerItemHandler<R> handler);
    private Expression IfNotNodeType(XmlNodeType type, Expression then);
    private Expression NodeNameEquals(string localName, string namespaceUri);
    private static void UnexpectedNodeError(XmlNodeType type);
    private Expression ParsingError(Expression state);
    private Expression ParsingError();
    private static void ParsingError(byte state, XmlNodeType type, string name, string value);
}
public abstract class Bond.Expressions.Xml.XmlParser`1 : PullParser`1<XmlNodeType> {
    private XmlReader`1<R> reader;
    protected XmlReader`1<R> Reader { get; }
    public ParameterExpression ReaderParam { get; }
    public Expression ReaderValue { get; }
    protected Expression EOF { get; }
    protected XmlParser`1(RuntimeSchema schema, bool flatten);
    protected XmlParser`1(XmlParser`1<R> that, RuntimeSchema schema, bool flatten);
    protected XmlReader`1<R> get_Reader();
    public virtual ParameterExpression get_ReaderParam();
    public virtual Expression get_ReaderValue();
    protected virtual Expression Read();
    protected virtual Expression get_EOF();
    protected virtual Expression Token();
}
public class Bond.Expressions.Xml.XmlReader`1 : object {
    private static MethodInfo read;
    private static MethodInfo skip;
    private static PropertyInfo eof;
    private static PropertyInfo nodeType;
    private static PropertyInfo localName;
    private static PropertyInfo namespaceUri;
    private static PropertyInfo isEmptyElement;
    private static PropertyInfo value;
    private ParameterExpression reader;
    public ParameterExpression Param { get; }
    public Expression EOF { get; }
    public Expression NodeType { get; }
    public Expression LocalName { get; }
    public Expression NamespaceURI { get; }
    public Expression IsEmptyElement { get; }
    public Expression Value { get; }
    private static XmlReader`1();
    public ParameterExpression get_Param();
    public Expression get_EOF();
    public Expression get_NodeType();
    public Expression get_LocalName();
    public Expression get_NamespaceURI();
    public Expression Read();
    public Expression Skip();
    public Expression get_IsEmptyElement();
    public Expression get_Value();
}
public class Bond.Factory : MulticastDelegate {
    public Factory(object object, IntPtr method);
    public virtual Expression Invoke(Type type, Type schemaType, Expression[] arguments);
    public virtual IAsyncResult BeginInvoke(Type type, Type schemaType, Expression[] arguments, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
internal class Bond.Field : object {
    private FieldInfo fieldInfo;
    private ushort id;
    public ushort Id { get; }
    public string Name { get; }
    public Type MemberType { get; }
    public Type DeclaringType { get; }
    public MemberInfo MemberInfo { get; }
    public Field(FieldInfo fieldInfo, ushort id);
    public sealed virtual ushort get_Id();
    public sealed virtual string get_Name();
    public sealed virtual Type get_MemberType();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual MemberInfo get_MemberInfo();
    public sealed virtual object GetValue(object o);
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.FieldDef : object {
    [CompilerGeneratedAttribute]
private Metadata <metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <id>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDef <type>k__BackingField;
    [IdAttribute("0")]
public Metadata metadata { get; public set; }
    [IdAttribute("1")]
public ushort id { get; public set; }
    [IdAttribute("2")]
public TypeDef type { get; public set; }
    protected FieldDef(string fullName, string name);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Metadata get_metadata();
    [CompilerGeneratedAttribute]
public void set_metadata(Metadata value);
    [CompilerGeneratedAttribute]
public ushort get_id();
    [CompilerGeneratedAttribute]
public void set_id(ushort value);
    [CompilerGeneratedAttribute]
public TypeDef get_type();
    [CompilerGeneratedAttribute]
public void set_type(TypeDef value);
}
public static class Bond.GenericFactory : object {
    public static T Create();
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.GUID : object {
    [CompilerGeneratedAttribute]
private UInt32 <Data1>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Data2>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Data3>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Data4>k__BackingField;
    [IdAttribute("0")]
public UInt32 Data1 { get; public set; }
    [IdAttribute("1")]
public ushort Data2 { get; public set; }
    [IdAttribute("2")]
public ushort Data3 { get; public set; }
    [IdAttribute("3")]
public ulong Data4 { get; public set; }
    protected GUID(string fullName, string name);
    public static Guid op_Implicit(GUID bondGuid);
    public static GUID op_Implicit(Guid systemGuid);
    [CompilerGeneratedAttribute]
public UInt32 get_Data1();
    [CompilerGeneratedAttribute]
public void set_Data1(UInt32 value);
    [CompilerGeneratedAttribute]
public ushort get_Data2();
    [CompilerGeneratedAttribute]
public void set_Data2(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Data3();
    [CompilerGeneratedAttribute]
public void set_Data3(ushort value);
    [CompilerGeneratedAttribute]
public ulong get_Data4();
    [CompilerGeneratedAttribute]
public void set_Data4(ulong value);
}
public interface Bond.IBonded {
    public abstract virtual void Serialize(W writer);
    public abstract virtual U Deserialize();
    public abstract virtual IBonded`1<U> Convert();
}
public interface Bond.IBonded`1 {
    public abstract virtual T Deserialize();
}
public interface Bond.IFactory {
    public abstract virtual object CreateObject(Type type, Type schemaType);
    public abstract virtual object CreateContainer(Type type, Type schemaType, int count);
}
public interface Bond.IO.ICloneable`1 {
    public abstract virtual T Clone();
}
public interface Bond.IO.IInputStream {
    public long Length { get; }
    public long Position { get; public set; }
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public abstract virtual byte ReadUInt8();
    public abstract virtual ushort ReadUInt16();
    public abstract virtual UInt32 ReadUInt32();
    public abstract virtual ulong ReadUInt64();
    public abstract virtual float ReadFloat();
    public abstract virtual double ReadDouble();
    public abstract virtual ArraySegment`1<byte> ReadBytes(int count);
    public abstract virtual void SkipBytes(int count);
    public abstract virtual ushort ReadVarUInt16();
    public abstract virtual UInt32 ReadVarUInt32();
    public abstract virtual ulong ReadVarUInt64();
    public abstract virtual string ReadString(Encoding encoding, int size);
}
internal static class Bond.IO.IntegerHelper : object {
    public static int MaxBytesVarInt16;
    public static int MaxBytesVarInt32;
    public static int MaxBytesVarInt64;
    public static int GetVarUInt16Length(ushort value);
    public static int EncodeVarUInt16(Byte[] data, ushort value, int index);
    public static int GetVarUInt32Length(UInt32 value);
    public static int EncodeVarUInt32(Byte[] data, UInt32 value, int index);
    public static int GetVarUInt64Length(ulong value);
    public static int EncodeVarUInt64(Byte[] data, ulong value, int index);
    public static ushort DecodeVarUInt16(Byte[] data, Int32& index);
    public static UInt32 DecodeVarUInt32(Byte[] data, Int32& index);
    public static ulong DecodeVarUInt64(Byte[] data, Int32& index);
    public static ushort EncodeZigzag16(short value);
    public static UInt32 EncodeZigzag32(int value);
    public static ulong EncodeZigzag64(long value);
    public static short DecodeZigzag16(ushort value);
    public static int DecodeZigzag32(UInt32 value);
    public static long DecodeZigzag64(ulong value);
}
public interface Bond.IO.IOutputStream {
    public long Position { get; public set; }
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public abstract virtual void WriteUInt8(byte value);
    public abstract virtual void WriteUInt16(ushort value);
    public abstract virtual void WriteUInt32(UInt32 value);
    public abstract virtual void WriteUInt64(ulong value);
    public abstract virtual void WriteFloat(float value);
    public abstract virtual void WriteDouble(double value);
    public abstract virtual void WriteBytes(ArraySegment`1<byte> data);
    public abstract virtual void WriteVarUInt16(ushort value);
    public abstract virtual void WriteVarUInt32(UInt32 value);
    public abstract virtual void WriteVarUInt64(ulong value);
    public abstract virtual void WriteString(Encoding encoding, string value, int size);
}
public class Bond.IO.Safe.InputBuffer : object {
    private int offset;
    internal Byte[] buffer;
    internal int end;
    internal int position;
    public long Length { get; }
    public long Position { get; public set; }
    public InputBuffer(Byte[] data);
    public InputBuffer(Byte[] data, int length);
    public InputBuffer(ArraySegment`1<byte> seg);
    public InputBuffer(Byte[] data, int offset, int length);
    internal InputBuffer(InputBuffer that);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public sealed virtual InputBuffer Clone();
    public sealed virtual void SkipBytes(int count);
    public sealed virtual byte ReadUInt8();
    public virtual ushort ReadUInt16();
    public virtual UInt32 ReadUInt32();
    public virtual ulong ReadUInt64();
    public virtual float ReadFloat();
    public virtual double ReadDouble();
    public virtual ArraySegment`1<byte> ReadBytes(int count);
    public sealed virtual ushort ReadVarUInt16();
    public sealed virtual UInt32 ReadVarUInt32();
    public sealed virtual ulong ReadVarUInt64();
    public virtual string ReadString(Encoding encoding, int size);
    private ulong DecodeVarUInt64Checked();
    internal virtual void EndOfStream(int count);
}
public class Bond.IO.Safe.OutputBuffer : object {
    private static int BlockCopyMin;
    internal Byte[] buffer;
    internal int position;
    internal int length;
    public ArraySegment`1<byte> Data { get; }
    public long Position { get; public set; }
    public OutputBuffer(int length);
    public OutputBuffer(Byte[] buffer);
    public ArraySegment`1<byte> get_Data();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public sealed virtual void WriteUInt8(byte value);
    public sealed virtual void WriteUInt16(ushort value);
    public virtual void WriteUInt32(UInt32 value);
    public virtual void WriteUInt64(ulong value);
    public virtual void WriteFloat(float value);
    public virtual void WriteDouble(double value);
    public virtual void WriteBytes(ArraySegment`1<byte> data);
    public sealed virtual void WriteVarUInt16(ushort value);
    public sealed virtual void WriteVarUInt32(UInt32 value);
    public sealed virtual void WriteVarUInt64(ulong value);
    public virtual void WriteString(Encoding encoding, string value, int size);
    internal virtual void Grow(int count);
    protected virtual Byte[] ResizeBuffer(Byte[] buffer, int newSize);
}
public interface Bond.ISchemaField {
    public ushort Id { get; }
    public string Name { get; }
    public Type MemberType { get; }
    public Type DeclaringType { get; }
    public MemberInfo MemberInfo { get; }
    public abstract virtual ushort get_Id();
    public abstract virtual string get_Name();
    public abstract virtual Type get_MemberType();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual MemberInfo get_MemberInfo();
    public abstract virtual object GetValue(object o);
}
[NamespaceAttribute("bond")]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public enum Bond.ListSubType : Enum {
    public int value__;
    public static ListSubType NO_SUBTYPE;
    public static ListSubType NULLABLE_SUBTYPE;
    public static ListSubType BLOB_SUBTYPE;
}
public static class Bond.Marshal : object {
    public static void To(W writer, T obj);
}
[ExtensionAttribute]
public static class Bond.Marshaler : object {
    [ExtensionAttribute]
public static void Marshal(Serializer`1<W> serializer, object obj, W writer);
    internal static ArraySegment`1<byte> Marshal(IBonded bonded);
}
internal static class Bond.MaxDepthChecker : object {
    [ThreadStaticAttribute]
private static int t_depth;
    private static Expression s_depthThreadStaticField;
    private static Expression s_maxDepthProperty;
    private static MethodInfo s_validateDepthForIncrement;
    private static MethodInfo s_setDepth;
    private static MaxDepthChecker();
    public static Expression WithDepthCheck(Expression expression);
    public static int ValidateDepthForIncrement();
    public static void SetDepth(int depth);
    private static void ThrowTooDeepException();
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.Metadata : object {
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <qualified_name>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private Modifier <modifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Variant <default_value>k__BackingField;
    [IdAttribute("0")]
public string name { get; public set; }
    [IdAttribute("1")]
public string qualified_name { get; public set; }
    [IdAttribute("2")]
public Dictionary`2<string, string> attributes { get; public set; }
    [IdAttribute("3")]
public Modifier modifier { get; public set; }
    [IdAttribute("4")]
public Variant default_value { get; public set; }
    protected Metadata(string fullName, string name);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public string get_qualified_name();
    [CompilerGeneratedAttribute]
public void set_qualified_name(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_attributes();
    [CompilerGeneratedAttribute]
public void set_attributes(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Modifier get_modifier();
    [CompilerGeneratedAttribute]
public void set_modifier(Modifier value);
    [CompilerGeneratedAttribute]
public Variant get_default_value();
    [CompilerGeneratedAttribute]
public void set_default_value(Variant value);
}
[NamespaceAttribute("bond")]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public enum Bond.Modifier : Enum {
    public int value__;
    public static Modifier Optional;
    public static Modifier Required;
    public static Modifier RequiredOptional;
}
internal class Bond.Property : object {
    private PropertyInfo propertyInfo;
    private ushort id;
    public ushort Id { get; }
    public string Name { get; }
    public Type MemberType { get; }
    public Type DeclaringType { get; }
    public MemberInfo MemberInfo { get; }
    public Property(PropertyInfo propertyInfo, ushort id);
    public sealed virtual ushort get_Id();
    public sealed virtual string get_Name();
    public sealed virtual Type get_MemberType();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual MemberInfo get_MemberInfo();
    public sealed virtual object GetValue(object o);
}
[ReaderAttribute("Bond.Protocols.CompactBinaryReader`1")]
public class Bond.Protocols.CompactBinaryCounter : ValueType {
    private LinkedList`1<UInt32> lengths;
    private Stack`1<CounterStackFrame> counterStack;
    public CompactBinaryCounter(LinkedList`1<UInt32> lengthsOut);
    private CounterStackFrame GetCurrentStackFrame();
    private void AddBytes(int count);
    private void AddVarUInt16(ushort value);
    private void AddVarUInt32(UInt32 value);
    private void AddVarUInt64(ulong value);
    public sealed virtual void WriteVersion();
    public sealed virtual void WriteStructBegin(Metadata metadata);
    public sealed virtual void WriteStructEnd();
    public sealed virtual void WriteBaseBegin(Metadata metadata);
    public sealed virtual void WriteBaseEnd();
    public sealed virtual void WriteFieldBegin(BondDataType type, ushort id, Metadata metadata);
    public sealed virtual void WriteFieldOmitted(BondDataType dataType, ushort id, Metadata metadata);
    public sealed virtual void WriteFieldEnd();
    public sealed virtual void WriteContainerBegin(int count, BondDataType elementType);
    public sealed virtual void WriteContainerBegin(int count, BondDataType keyType, BondDataType valueType);
    public sealed virtual void WriteContainerEnd();
    public sealed virtual void WriteBytes(ArraySegment`1<byte> data);
    public sealed virtual void WriteUInt8(byte value);
    public sealed virtual void WriteUInt16(ushort value);
    public sealed virtual void WriteUInt32(UInt32 value);
    public sealed virtual void WriteUInt64(ulong value);
    public sealed virtual void WriteInt8(sbyte value);
    public sealed virtual void WriteInt16(short value);
    public sealed virtual void WriteInt32(int value);
    public sealed virtual void WriteInt64(long value);
    public sealed virtual void WriteFloat(float value);
    public sealed virtual void WriteDouble(double value);
    public sealed virtual void WriteBool(bool value);
    public sealed virtual void WriteString(string value);
    public sealed virtual void WriteWString(string value);
}
public class Bond.Protocols.CompactBinaryReader`1 : ValueType {
    private I input;
    private ushort version;
    public CompactBinaryReader`1(I input, ushort version);
    private sealed virtual override CompactBinaryReader`1<I> Bond.IO.ICloneable<Bond.Protocols.CompactBinaryReader<I>>.Clone();
    private sealed virtual override IClonableTaggedProtocolReader Bond.IO.ICloneable<Bond.Protocols.IClonableTaggedProtocolReader>.Clone();
    public sealed virtual void ReadStructBegin();
    public sealed virtual void ReadBaseBegin();
    public sealed virtual void ReadStructEnd();
    public sealed virtual void ReadBaseEnd();
    public sealed virtual void ReadFieldBegin(BondDataType& type, UInt16& id);
    public sealed virtual void ReadFieldEnd();
    public sealed virtual void ReadContainerBegin(Int32& count, BondDataType& elementType);
    public sealed virtual void ReadContainerBegin(Int32& count, BondDataType& keyType, BondDataType& valueType);
    public sealed virtual void ReadContainerEnd();
    public sealed virtual byte ReadUInt8();
    public sealed virtual ushort ReadUInt16();
    public sealed virtual UInt32 ReadUInt32();
    public sealed virtual ulong ReadUInt64();
    public sealed virtual sbyte ReadInt8();
    public sealed virtual short ReadInt16();
    public sealed virtual int ReadInt32();
    public sealed virtual long ReadInt64();
    public sealed virtual bool ReadBool();
    public sealed virtual float ReadFloat();
    public sealed virtual double ReadDouble();
    public sealed virtual string ReadString();
    public sealed virtual string ReadWString();
    public sealed virtual ArraySegment`1<byte> ReadBytes(int count);
    public sealed virtual void Skip(BondDataType type);
    private void SkipContainer();
    private void SkipMap();
    private void SkipStruct();
}
[ReaderAttribute("Bond.Protocols.CompactBinaryReader`1")]
[FirstPassWriterAttribute("Bond.Protocols.CompactBinaryCounter")]
public class Bond.Protocols.CompactBinaryWriter`1 : ValueType {
    private static ushort Magic;
    private O output;
    private ushort version;
    private Nullable`1<CompactBinaryCounter> firstPassWriter;
    private LinkedList`1<UInt32> lengths;
    private Stack`1<long> lengthCheck;
    public CompactBinaryWriter`1(O output, ushort version);
    public sealed virtual IProtocolWriter GetFirstPassWriter();
    public sealed virtual void WriteVersion();
    public sealed virtual void WriteStructBegin(Metadata metadata);
    public sealed virtual void WriteBaseBegin(Metadata metadata);
    public sealed virtual void WriteStructEnd();
    public sealed virtual void WriteBaseEnd();
    public sealed virtual void WriteFieldBegin(BondDataType type, ushort id, Metadata metadata);
    public sealed virtual void WriteFieldOmitted(BondDataType dataType, ushort id, Metadata metadata);
    public sealed virtual void WriteFieldEnd();
    public sealed virtual void WriteContainerBegin(int count, BondDataType elementType);
    public sealed virtual void WriteContainerBegin(int count, BondDataType keyType, BondDataType valueType);
    public sealed virtual void WriteContainerEnd();
    public sealed virtual void WriteBytes(ArraySegment`1<byte> data);
    public sealed virtual void WriteUInt8(byte value);
    public sealed virtual void WriteUInt16(ushort value);
    public sealed virtual void WriteUInt32(UInt32 value);
    public sealed virtual void WriteUInt64(ulong value);
    public sealed virtual void WriteInt8(sbyte value);
    public sealed virtual void WriteInt16(short value);
    public sealed virtual void WriteInt32(int value);
    public sealed virtual void WriteInt64(long value);
    public sealed virtual void WriteFloat(float value);
    public sealed virtual void WriteDouble(double value);
    public sealed virtual void WriteBool(bool value);
    public sealed virtual void WriteString(string value);
    public sealed virtual void WriteWString(string value);
    [ConditionalAttribute("DEBUG")]
private void InitLengthCheck();
    [ConditionalAttribute("DEBUG")]
private void PushLengthCheck(long position);
    [ConditionalAttribute("DEBUG")]
private void PopLengthCheck(long position);
}
public class Bond.Protocols.FastBinaryReader`1 : ValueType {
    private I input;
    public FastBinaryReader`1(I input, ushort version);
    private sealed virtual override FastBinaryReader`1<I> Bond.IO.ICloneable<Bond.Protocols.FastBinaryReader<I>>.Clone();
    private sealed virtual override IClonableTaggedProtocolReader Bond.IO.ICloneable<Bond.Protocols.IClonableTaggedProtocolReader>.Clone();
    public sealed virtual void ReadStructBegin();
    public sealed virtual void ReadBaseBegin();
    public sealed virtual void ReadStructEnd();
    public sealed virtual void ReadBaseEnd();
    public sealed virtual void ReadFieldBegin(BondDataType& type, UInt16& id);
    public sealed virtual void ReadFieldEnd();
    public sealed virtual void ReadContainerBegin(Int32& count, BondDataType& elementType);
    public sealed virtual void ReadContainerBegin(Int32& count, BondDataType& keyType, BondDataType& valueType);
    public sealed virtual void ReadContainerEnd();
    public sealed virtual byte ReadUInt8();
    public sealed virtual ushort ReadUInt16();
    public sealed virtual UInt32 ReadUInt32();
    public sealed virtual ulong ReadUInt64();
    public sealed virtual sbyte ReadInt8();
    public sealed virtual short ReadInt16();
    public sealed virtual int ReadInt32();
    public sealed virtual long ReadInt64();
    public sealed virtual bool ReadBool();
    public sealed virtual float ReadFloat();
    public sealed virtual double ReadDouble();
    public sealed virtual string ReadString();
    public sealed virtual string ReadWString();
    public sealed virtual ArraySegment`1<byte> ReadBytes(int count);
    public sealed virtual void Skip(BondDataType type);
    private void SkipContainer();
    private void SkipMap();
    private void SkipStruct();
}
[ReaderAttribute("Bond.Protocols.FastBinaryReader`1")]
public class Bond.Protocols.FastBinaryWriter`1 : ValueType {
    private static ushort Magic;
    private O output;
    private ushort version;
    public FastBinaryWriter`1(O output, ushort version);
    public sealed virtual void WriteVersion();
    public sealed virtual void WriteStructBegin(Metadata metadata);
    public sealed virtual void WriteBaseBegin(Metadata metadata);
    public sealed virtual void WriteStructEnd();
    public sealed virtual void WriteBaseEnd();
    public sealed virtual void WriteFieldBegin(BondDataType type, ushort id, Metadata metadata);
    public sealed virtual void WriteFieldOmitted(BondDataType dataType, ushort id, Metadata metadata);
    public sealed virtual void WriteFieldEnd();
    public sealed virtual void WriteContainerBegin(int count, BondDataType elementType);
    public sealed virtual void WriteContainerBegin(int count, BondDataType keyType, BondDataType valueType);
    public sealed virtual void WriteContainerEnd();
    public sealed virtual void WriteBytes(ArraySegment`1<byte> data);
    public sealed virtual void WriteUInt8(byte value);
    public sealed virtual void WriteUInt16(ushort value);
    public sealed virtual void WriteUInt32(UInt32 value);
    public sealed virtual void WriteUInt64(ulong value);
    public sealed virtual void WriteInt8(sbyte value);
    public sealed virtual void WriteInt16(short value);
    public sealed virtual void WriteInt32(int value);
    public sealed virtual void WriteInt64(long value);
    public sealed virtual void WriteFloat(float value);
    public sealed virtual void WriteDouble(double value);
    public sealed virtual void WriteBool(bool value);
    public sealed virtual void WriteString(string value);
    public sealed virtual void WriteWString(string value);
}
public interface Bond.Protocols.IClonableTaggedProtocolReader {
}
public interface Bond.Protocols.IClonableUntaggedProtocolReader {
}
public interface Bond.Protocols.IProtocolWriter {
    public abstract virtual void WriteVersion();
    public abstract virtual void WriteStructBegin(Metadata metadata);
    public abstract virtual void WriteBaseBegin(Metadata metadata);
    public abstract virtual void WriteStructEnd();
    public abstract virtual void WriteBaseEnd();
    public abstract virtual void WriteFieldBegin(BondDataType type, ushort id, Metadata metadata);
    public abstract virtual void WriteFieldEnd();
    public abstract virtual void WriteFieldOmitted(BondDataType type, ushort id, Metadata metadata);
    public abstract virtual void WriteContainerBegin(int count, BondDataType elementType);
    public abstract virtual void WriteContainerBegin(int count, BondDataType keyType, BondDataType valueType);
    public abstract virtual void WriteContainerEnd();
    public abstract virtual void WriteInt8(sbyte value);
    public abstract virtual void WriteInt16(short value);
    public abstract virtual void WriteInt32(int value);
    public abstract virtual void WriteInt64(long value);
    public abstract virtual void WriteUInt8(byte value);
    public abstract virtual void WriteUInt16(ushort value);
    public abstract virtual void WriteUInt32(UInt32 value);
    public abstract virtual void WriteUInt64(ulong value);
    public abstract virtual void WriteFloat(float value);
    public abstract virtual void WriteDouble(double value);
    public abstract virtual void WriteBytes(ArraySegment`1<byte> data);
    public abstract virtual void WriteBool(bool value);
    public abstract virtual void WriteString(string value);
    public abstract virtual void WriteWString(string value);
}
public interface Bond.Protocols.ITaggedProtocolReader {
    public abstract virtual void ReadStructBegin();
    public abstract virtual void ReadBaseBegin();
    public abstract virtual void ReadStructEnd();
    public abstract virtual void ReadBaseEnd();
    public abstract virtual void ReadFieldBegin(BondDataType& type, UInt16& id);
    public abstract virtual void ReadFieldEnd();
    public abstract virtual void ReadContainerBegin(Int32& count, BondDataType& elementType);
    public abstract virtual void ReadContainerBegin(Int32& count, BondDataType& keyType, BondDataType& valueType);
    public abstract virtual void ReadContainerEnd();
    public abstract virtual void Skip(BondDataType type);
    public abstract virtual sbyte ReadInt8();
    public abstract virtual short ReadInt16();
    public abstract virtual int ReadInt32();
    public abstract virtual long ReadInt64();
    public abstract virtual byte ReadUInt8();
    public abstract virtual ushort ReadUInt16();
    public abstract virtual UInt32 ReadUInt32();
    public abstract virtual ulong ReadUInt64();
    public abstract virtual float ReadFloat();
    public abstract virtual double ReadDouble();
    public abstract virtual ArraySegment`1<byte> ReadBytes(int count);
    public abstract virtual bool ReadBool();
    public abstract virtual string ReadString();
    public abstract virtual string ReadWString();
}
public interface Bond.Protocols.ITextProtocolWriter {
    public abstract virtual void WriteItemBegin();
    public abstract virtual void WriteItemEnd();
}
public interface Bond.Protocols.ITwoPassProtocolWriter {
    public abstract virtual IProtocolWriter GetFirstPassWriter();
}
public interface Bond.Protocols.IUntaggedProtocolReader {
    public abstract virtual bool ReadFieldOmitted();
    public abstract virtual int ReadContainerBegin();
    public abstract virtual void ReadContainerEnd();
    public abstract virtual sbyte ReadInt8();
    public abstract virtual void SkipInt8();
    public abstract virtual short ReadInt16();
    public abstract virtual void SkipInt16();
    public abstract virtual int ReadInt32();
    public abstract virtual void SkipInt32();
    public abstract virtual long ReadInt64();
    public abstract virtual void SkipInt64();
    public abstract virtual byte ReadUInt8();
    public abstract virtual void SkipUInt8();
    public abstract virtual ushort ReadUInt16();
    public abstract virtual void SkipUInt16();
    public abstract virtual UInt32 ReadUInt32();
    public abstract virtual void SkipUInt32();
    public abstract virtual ulong ReadUInt64();
    public abstract virtual void SkipUInt64();
    public abstract virtual float ReadFloat();
    public abstract virtual void SkipFloat();
    public abstract virtual double ReadDouble();
    public abstract virtual void SkipDouble();
    public abstract virtual ArraySegment`1<byte> ReadBytes(int count);
    public abstract virtual void SkipBytes(int count);
    public abstract virtual bool ReadBool();
    public abstract virtual void SkipBool();
    public abstract virtual string ReadString();
    public abstract virtual void SkipString();
    public abstract virtual string ReadWString();
    public abstract virtual void SkipWString();
}
public interface Bond.Protocols.IXmlReader {
    public bool EOF { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public bool IsEmptyElement { get; }
    public string Value { get; }
    public abstract virtual void Read();
    public abstract virtual void Skip();
    public abstract virtual bool get_EOF();
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    public abstract virtual string get_NamespaceURI();
    public abstract virtual bool get_IsEmptyElement();
    public abstract virtual string get_Value();
}
public class Bond.Protocols.SimpleBinaryReader`1 : ValueType {
    private I input;
    private ushort version;
    public SimpleBinaryReader`1(I reader, ushort version);
    private sealed virtual override SimpleBinaryReader`1<I> Bond.IO.ICloneable<Bond.Protocols.SimpleBinaryReader<I>>.Clone();
    private sealed virtual override IClonableUntaggedProtocolReader Bond.IO.ICloneable<Bond.Protocols.IClonableUntaggedProtocolReader>.Clone();
    public sealed virtual bool ReadFieldOmitted();
    public sealed virtual int ReadContainerBegin();
    public sealed virtual void ReadContainerEnd();
    public sealed virtual byte ReadUInt8();
    public sealed virtual void SkipUInt8();
    public sealed virtual ushort ReadUInt16();
    public sealed virtual void SkipUInt16();
    public sealed virtual UInt32 ReadUInt32();
    public sealed virtual void SkipUInt32();
    public sealed virtual ulong ReadUInt64();
    public sealed virtual void SkipUInt64();
    public sealed virtual sbyte ReadInt8();
    public sealed virtual void SkipInt8();
    public sealed virtual short ReadInt16();
    public sealed virtual void SkipInt16();
    public sealed virtual int ReadInt32();
    public sealed virtual void SkipInt32();
    public sealed virtual long ReadInt64();
    public sealed virtual void SkipInt64();
    public sealed virtual bool ReadBool();
    public sealed virtual void SkipBool();
    public sealed virtual float ReadFloat();
    public sealed virtual void SkipFloat();
    public sealed virtual double ReadDouble();
    public sealed virtual void SkipDouble();
    public sealed virtual string ReadString();
    public sealed virtual void SkipString();
    public sealed virtual string ReadWString();
    public sealed virtual void SkipWString();
    public sealed virtual ArraySegment`1<byte> ReadBytes(int count);
    public sealed virtual void SkipBytes(int count);
    private int ReadLength();
}
[ReaderAttribute("Bond.Protocols.SimpleBinaryReader`1")]
public class Bond.Protocols.SimpleBinaryWriter`1 : ValueType {
    private static ushort Magic;
    private O output;
    private ushort version;
    public SimpleBinaryWriter`1(O output, ushort version);
    public sealed virtual void WriteVersion();
    public sealed virtual void WriteFieldBegin(BondDataType type, ushort id, Metadata metadata);
    public sealed virtual void WriteFieldEnd();
    public sealed virtual void WriteStructBegin(Metadata metadata);
    public sealed virtual void WriteBaseBegin(Metadata metadata);
    public sealed virtual void WriteStructEnd();
    public sealed virtual void WriteBaseEnd();
    public sealed virtual void WriteFieldOmitted(BondDataType dataType, ushort id, Metadata metadata);
    public sealed virtual void WriteContainerBegin(int count, BondDataType elementType);
    public sealed virtual void WriteContainerBegin(int count, BondDataType keyType, BondDataType valueType);
    public sealed virtual void WriteContainerEnd();
    public sealed virtual void WriteUInt8(byte value);
    public sealed virtual void WriteUInt16(ushort value);
    public sealed virtual void WriteUInt32(UInt32 value);
    public sealed virtual void WriteUInt64(ulong value);
    public sealed virtual void WriteBytes(ArraySegment`1<byte> data);
    public sealed virtual void WriteInt8(sbyte value);
    public sealed virtual void WriteInt16(short value);
    public sealed virtual void WriteInt32(int value);
    public sealed virtual void WriteInt64(long value);
    public sealed virtual void WriteFloat(float value);
    public sealed virtual void WriteDouble(double value);
    public sealed virtual void WriteBool(bool value);
    public sealed virtual void WriteString(string value);
    public sealed virtual void WriteWString(string value);
    private void WriteLength(int value);
}
[ParserAttribute("Bond.Expressions.Xml.SimpleXmlParser`1")]
public class Bond.Protocols.SimpleXmlReader : ValueType {
    private XmlReader reader;
    public bool EOF { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public bool IsEmptyElement { get; }
    public string Value { get; }
    public SimpleXmlReader(XmlReader reader);
    public SimpleXmlReader(Stream stream);
    public SimpleXmlReader(TextReader textReader);
    public sealed virtual bool get_EOF();
    public sealed virtual XmlNodeType get_NodeType();
    public sealed virtual string get_LocalName();
    public sealed virtual string get_NamespaceURI();
    public sealed virtual void Read();
    public sealed virtual void Skip();
    public sealed virtual bool get_IsEmptyElement();
    public sealed virtual string get_Value();
}
[ReaderAttribute("Bond.Protocols.SimpleXmlReader")]
public class Bond.Protocols.SimpleXmlWriter : ValueType {
    private XmlWriter writer;
    private Stack`1<string> ns;
    private string Prefix { get; }
    public SimpleXmlWriter(XmlWriter writer);
    public SimpleXmlWriter(Stream stream);
    public SimpleXmlWriter(Stream stream, Settings settings);
    public SimpleXmlWriter(XmlWriter writer, Settings settings);
    public void Flush();
    public sealed virtual void WriteVersion();
    public sealed virtual void WriteStructBegin(Metadata metadata);
    public sealed virtual void WriteBaseBegin(Metadata metadata);
    public sealed virtual void WriteStructEnd();
    public sealed virtual void WriteBaseEnd();
    public sealed virtual void WriteFieldBegin(BondDataType dataType, ushort id, Metadata metadata);
    public sealed virtual void WriteFieldEnd();
    public sealed virtual void WriteFieldOmitted(BondDataType dataType, ushort id, Metadata metadata);
    public sealed virtual void WriteContainerBegin(int count, BondDataType elementType);
    public sealed virtual void WriteContainerBegin(int count, BondDataType keyType, BondDataType valueType);
    public sealed virtual void WriteContainerEnd();
    public sealed virtual void WriteItemBegin();
    public sealed virtual void WriteItemEnd();
    public sealed virtual void WriteInt8(sbyte value);
    public sealed virtual void WriteInt16(short value);
    public sealed virtual void WriteInt32(int value);
    public sealed virtual void WriteInt64(long value);
    public sealed virtual void WriteUInt8(byte value);
    public sealed virtual void WriteUInt16(ushort value);
    public sealed virtual void WriteUInt32(UInt32 value);
    public sealed virtual void WriteUInt64(ulong value);
    public sealed virtual void WriteFloat(float value);
    public sealed virtual void WriteDouble(double value);
    public sealed virtual void WriteBytes(ArraySegment`1<byte> data);
    public sealed virtual void WriteBool(bool value);
    public sealed virtual void WriteString(string value);
    public sealed virtual void WriteWString(string value);
    private void PushNamespace(Metadata metadata);
    private void PopNamespace();
    private string get_Prefix();
}
internal static class Bond.Protocols.Throw : object {
    public static void InvalidBondDataType(BondDataType type);
    public static void EndOfStreamException();
}
[ExtensionAttribute]
public static class Bond.Protocols.XmlMetadata : object {
    [ExtensionAttribute]
public static string GetXmlNamespace(Metadata metadata);
    [ExtensionAttribute]
public static string GetXmlName(Metadata metadata);
    [ExtensionAttribute]
public static string EncodeXmlName(string name);
}
[NamespaceAttribute("bond")]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public enum Bond.ProtocolType : Enum {
    public int value__;
    public static ProtocolType MARSHALED_PROTOCOL;
    public static ProtocolType FAST_PROTOCOL;
    public static ProtocolType COMPACT_PROTOCOL;
    public static ProtocolType SIMPLE_JSON_PROTOCOL;
    public static ProtocolType SIMPLE_PROTOCOL;
}
[ExtensionAttribute]
public static class Bond.Reflection : object {
    private static object Empty;
    private static Dictionary`2<BondDataType, string> bondTypeName;
    private static Reflection();
    [ExtensionAttribute]
public static IEnumerable`1<ISchemaField> GetSchemaFields(Type type);
    [ExtensionAttribute]
public static Type GetValueType(Type type);
    [ExtensionAttribute]
public static KeyValuePair`2<Type, Type> GetKeyValueType(Type type);
    [ExtensionAttribute]
public static bool IsBondStruct(Type type);
    [ExtensionAttribute]
public static bool IsBonded(Type type);
    [ExtensionAttribute]
public static bool IsBondNullable(Type type);
    [ExtensionAttribute]
public static bool IsBondString(Type type);
    [ExtensionAttribute]
public static bool IsBondBlob(Type type);
    [ExtensionAttribute]
public static bool IsBondList(Type type);
    [ExtensionAttribute]
public static bool IsBondMap(Type type);
    [ExtensionAttribute]
public static bool IsBondSet(Type type);
    [ExtensionAttribute]
public static bool IsBondContainer(Type type);
    [ExtensionAttribute]
public static BondDataType GetBondDataType(Type type);
    [ExtensionAttribute]
public static ListSubType GetBondListDataType(Type type);
    [ExtensionAttribute]
public static Type GetBaseSchemaType(Type type);
    [ExtensionAttribute]
public static Type GetSchemaType(ISchemaField schemaField);
    private static MemberInfo InfoOf(Expression`1<Func`2<T, TResult>> expression);
    internal static MethodInfo MethodInfoOf(Expression`1<Func`2<T, TResult>> expression);
    internal static MethodInfo GenericMethodInfoOf(Expression`1<Func`2<T, TResult>> expression);
    internal static PropertyInfo PropertyInfoOf(Expression`1<Func`2<T, TResult>> expression);
    internal static FieldInfo FieldInfoOf(Expression`1<Func`2<T, TResult>> expression);
    private static MemberInfo InfoOf(Expression`1<Func`1<TResult>> expression);
    internal static MethodInfo MethodInfoOf(Expression`1<Func`1<TResult>> expression);
    internal static MethodInfo GenericMethodInfoOf(Expression`1<Func`1<TResult>> expression);
    private static MemberInfo InfoOf(Expression`1<Action`1<T>> expression);
    internal static MethodInfo MethodInfoOf(Expression`1<Action`1<T>> expression);
    internal static MethodInfo GenericMethodInfoOf(Expression`1<Action`1<T>> expression);
    private static MemberInfo InfoOf(Expression expression);
    [ExtensionAttribute]
internal static Modifier GetModifier(ISchemaField schemaField);
    [ExtensionAttribute]
internal static int GetHierarchyDepth(RuntimeSchema schema);
    [ExtensionAttribute]
internal static int GetHierarchyDepth(Type type);
    [ExtensionAttribute]
internal static string GetSchemaName(Type type);
    [ExtensionAttribute]
internal static string GetSchemaFullName(Type type);
    [ExtensionAttribute]
private static string GetSchemaNamespace(Type type);
    [ExtensionAttribute]
private static T GetAttribute(MemberInfo type);
    [ExtensionAttribute]
internal static T GetAttribute(Type type);
    [ExtensionAttribute]
private static T GetAttribute(ISchemaField schemaField);
    private static Type ResolveTypeArgumentTags(Type memberType, Type schemaType);
    [ExtensionAttribute]
internal static Type GetObjectType(Type schemaType);
    [ExtensionAttribute]
internal static object GetDefaultValue(ISchemaField schemaField);
    private static void InvalidDefaultAttribute(ISchemaField schemaField, object value);
}
public class Bond.RuntimeSchema : ValueType {
    private SchemaDef schemaDef;
    private TypeDef typeDef;
    public static RuntimeSchema Empty;
    public SchemaDef SchemaDef { get; }
    public TypeDef TypeDef { get; }
    public StructDef StructDef { get; }
    public bool HasValue { get; }
    public bool IsStruct { get; }
    public bool IsBonded { get; }
    public bool IsBlob { get; }
    public bool IsContainer { get; }
    public bool IsMap { get; }
    public bool HasBase { get; }
    public RuntimeSchema(SchemaDef schema);
    private RuntimeSchema(SchemaDef schema, TypeDef type);
    private static RuntimeSchema();
    public SchemaDef get_SchemaDef();
    public TypeDef get_TypeDef();
    public StructDef get_StructDef();
    public bool get_HasValue();
    public bool get_IsStruct();
    public bool get_IsBonded();
    public bool get_IsBlob();
    public bool get_IsContainer();
    public bool get_IsMap();
    public bool get_HasBase();
    public RuntimeSchema GetBaseSchema();
    public RuntimeSchema GetElementSchema();
    public RuntimeSchema GetKeySchema();
    public RuntimeSchema GetFieldSchema(FieldDef field);
}
public static class Bond.Schema : object {
    public static RuntimeSchema GetRuntimeSchema(Type type);
}
public static class Bond.Schema`1 : object {
    private static Cache<T> instance;
    public static RuntimeSchema RuntimeSchema { get; }
    internal static Metadata Metadata { get; }
    internal static Metadata[] Fields { get; }
    private static Schema`1();
    public static RuntimeSchema get_RuntimeSchema();
    internal static Metadata get_Metadata();
    internal static Metadata[] get_Fields();
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.SchemaDef : object {
    [CompilerGeneratedAttribute]
private List`1<StructDef> <structs>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDef <root>k__BackingField;
    [IdAttribute("0")]
public List`1<StructDef> structs { get; public set; }
    [IdAttribute("1")]
public TypeDef root { get; public set; }
    protected SchemaDef(string fullName, string name);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public List`1<StructDef> get_structs();
    [CompilerGeneratedAttribute]
public void set_structs(List`1<StructDef> value);
    [CompilerGeneratedAttribute]
public TypeDef get_root();
    [CompilerGeneratedAttribute]
public void set_root(TypeDef value);
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.SerializableExceptionBase : object {
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    [IdAttribute("8189")]
public string message { get; public set; }
    protected SerializableExceptionBase(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
}
public static class Bond.Serialize : object {
    public static void To(W writer, T obj);
    public static void To(W writer, IBonded`1<T> bonded);
    public static void To(W writer, IBonded bonded);
}
public class Bond.Serializer`1 : object {
    private static Type helperType;
    private SerializerHelper<W> helper;
    private static Serializer`1();
    public Serializer`1(Type type);
    public Serializer`1(Type type, IParser parser);
    public Serializer`1(Type type, bool inlineNested);
    public Serializer`1(Type type, IParser parser, bool inlineNested);
    public void Serialize(object obj, W writer);
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.StructDef : object {
    [CompilerGeneratedAttribute]
private Metadata <metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDef <base_def>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FieldDef> <fields>k__BackingField;
    [IdAttribute("0")]
public Metadata metadata { get; public set; }
    [IdAttribute("1")]
[TypeAttribute("Bond.Tag.nullable`1<Bond.TypeDef>")]
public TypeDef base_def { get; public set; }
    [IdAttribute("2")]
public List`1<FieldDef> fields { get; public set; }
    protected StructDef(string fullName, string name);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Metadata get_metadata();
    [CompilerGeneratedAttribute]
public void set_metadata(Metadata value);
    [CompilerGeneratedAttribute]
public TypeDef get_base_def();
    [CompilerGeneratedAttribute]
public void set_base_def(TypeDef value);
    [CompilerGeneratedAttribute]
public List`1<FieldDef> get_fields();
    [CompilerGeneratedAttribute]
public void set_fields(List`1<FieldDef> value);
}
public static class Bond.Transcode : object {
    public static void FromTo(R reader, W writer);
}
public static class Bond.Transcode`1 : object {
    public static void FromTo(R reader, W writer);
}
public class Bond.Transcoder`2 : object {
    private static Type helperType;
    private TranscoderHelper<R, W> helper;
    private static Transcoder`2();
    public Transcoder`2(RuntimeSchema schema);
    public Transcoder`2(Type type);
    public Transcoder`2(RuntimeSchema schema, IParser parser);
    public Transcoder`2(Type type, IParser parser);
    public void Transcode(R reader, W writer);
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.TypeDef : object {
    [CompilerGeneratedAttribute]
private BondDataType <id>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <struct_def>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDef <element>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDef <key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <bonded_type>k__BackingField;
    [IdAttribute("0")]
public BondDataType id { get; public set; }
    [IdAttribute("1")]
public ushort struct_def { get; public set; }
    [IdAttribute("2")]
[TypeAttribute("Bond.Tag.nullable`1<Bond.TypeDef>")]
public TypeDef element { get; public set; }
    [IdAttribute("3")]
[TypeAttribute("Bond.Tag.nullable`1<Bond.TypeDef>")]
public TypeDef key { get; public set; }
    [IdAttribute("4")]
public bool bonded_type { get; public set; }
    protected TypeDef(string fullName, string name);
    [CompilerGeneratedAttribute]
public BondDataType get_id();
    [CompilerGeneratedAttribute]
public void set_id(BondDataType value);
    [CompilerGeneratedAttribute]
public ushort get_struct_def();
    [CompilerGeneratedAttribute]
public void set_struct_def(ushort value);
    [CompilerGeneratedAttribute]
public TypeDef get_element();
    [CompilerGeneratedAttribute]
public void set_element(TypeDef value);
    [CompilerGeneratedAttribute]
public TypeDef get_key();
    [CompilerGeneratedAttribute]
public void set_key(TypeDef value);
    [CompilerGeneratedAttribute]
public bool get_bonded_type();
    [CompilerGeneratedAttribute]
public void set_bonded_type(bool value);
}
internal class Bond.TypeDefComparer : object {
    public sealed virtual bool Equals(RuntimeSchema x, RuntimeSchema y);
    public sealed virtual int GetHashCode(RuntimeSchema x);
}
[ExtensionAttribute]
internal static class Bond.TypeDefExtensions : object {
    [ExtensionAttribute]
internal static int CalculateHashCode(TypeDef typeDef);
}
public static class Bond.Unmarshal : object {
    public static IBonded From(I input);
    public static IBonded From(I input, RuntimeSchema schema);
    public static IBonded From(ArraySegment`1<byte> data);
    public static IBonded From(ArraySegment`1<byte> data, RuntimeSchema schema);
}
public static class Bond.Unmarshal`1 : object {
    public static T From(I input);
    public static T From(ArraySegment`1<byte> data);
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.Variant : object {
    [CompilerGeneratedAttribute]
private ulong <uint_value>k__BackingField;
    [CompilerGeneratedAttribute]
private long <int_value>k__BackingField;
    [CompilerGeneratedAttribute]
private double <double_value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <string_value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wstring_value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <nothing>k__BackingField;
    [IdAttribute("0")]
public ulong uint_value { get; public set; }
    [IdAttribute("1")]
public long int_value { get; public set; }
    [IdAttribute("2")]
public double double_value { get; public set; }
    [IdAttribute("3")]
public string string_value { get; public set; }
    [IdAttribute("4")]
[TypeAttribute("Bond.Tag.wstring")]
public string wstring_value { get; public set; }
    [IdAttribute("5")]
public bool nothing { get; public set; }
    protected Variant(string fullName, string name);
    [CompilerGeneratedAttribute]
public ulong get_uint_value();
    [CompilerGeneratedAttribute]
public void set_uint_value(ulong value);
    [CompilerGeneratedAttribute]
public long get_int_value();
    [CompilerGeneratedAttribute]
public void set_int_value(long value);
    [CompilerGeneratedAttribute]
public double get_double_value();
    [CompilerGeneratedAttribute]
public void set_double_value(double value);
    [CompilerGeneratedAttribute]
public string get_string_value();
    [CompilerGeneratedAttribute]
public void set_string_value(string value);
    [CompilerGeneratedAttribute]
public string get_wstring_value();
    [CompilerGeneratedAttribute]
public void set_wstring_value(string value);
    [CompilerGeneratedAttribute]
public bool get_nothing();
    [CompilerGeneratedAttribute]
public void set_nothing(bool value);
}
[NamespaceAttribute("bond")]
[SchemaAttribute]
[GeneratedCodeAttribute("gbc", "0.13.0.0")]
public class Bond.Void : object {
}
