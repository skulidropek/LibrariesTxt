public static class Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves : object {
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, X9ECParametersHolder> curves;
    private static Dictionary`2<DerObjectIdentifier, string> names;
    public static IEnumerable`1<string> Names { get; }
    private static AnssiNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public class Org.BouncyCastle.Asn1.Anssi.AnssiObjectIdentifiers : object {
    public static DerObjectIdentifier FRP256v1;
    private static AnssiObjectIdentifiers();
}
public interface Org.BouncyCastle.Asn1.Asn1BitStringParser {
    public int PadBits { get; }
    public abstract virtual Stream GetBitStream();
    public abstract virtual Stream GetOctetStream();
    public abstract virtual int get_PadBits();
}
public abstract class Org.BouncyCastle.Asn1.Asn1Encodable : object {
    public static string Der;
    public static string Ber;
    public virtual void EncodeTo(Stream output);
    public virtual void EncodeTo(Stream output, string encoding);
    public Byte[] GetEncoded();
    public Byte[] GetEncoded(string encoding);
    public Byte[] GetDerEncoded();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    public abstract virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Asn1EncodableVector : object {
    internal static Asn1Encodable[] EmptyElements;
    private static int DefaultCapacity;
    private Asn1Encodable[] elements;
    private int elementCount;
    private bool copyOnWrite;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    public Asn1EncodableVector(int initialCapacity);
    public Asn1EncodableVector(Asn1Encodable element);
    public Asn1EncodableVector(Asn1Encodable element1, Asn1Encodable element2);
    public Asn1EncodableVector(Asn1Encodable[] v);
    private static Asn1EncodableVector();
    public static Asn1EncodableVector FromEnumerable(IEnumerable`1<Asn1Encodable> e);
    public void Add(Asn1Encodable element);
    public void Add(Asn1Encodable element1, Asn1Encodable element2);
    public void Add(Asn1Encodable[] objs);
    public void AddOptional(Asn1Encodable element);
    public void AddOptional(Asn1Encodable element1, Asn1Encodable element2);
    public void AddOptional(Asn1Encodable[] elements);
    public void AddOptionalTagged(bool isExplicit, int tagNo, Asn1Encodable obj);
    public void AddOptionalTagged(bool isExplicit, int tagClass, int tagNo, Asn1Encodable obj);
    public void AddAll(Asn1EncodableVector other);
    public Asn1Encodable get_Item(int index);
    public int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<Asn1Encodable> GetEnumerator();
    internal Asn1Encodable[] CopyElements();
    internal Asn1Encodable[] TakeElements();
    private void Reallocate(int minCapacity);
    internal static Asn1Encodable[] CloneElements(Asn1Encodable[] elements);
}
public class Org.BouncyCastle.Asn1.Asn1Exception : IOException {
    public Asn1Exception(string message);
    public Asn1Exception(string message, Exception innerException);
    protected Asn1Exception(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Asn1.Asn1GeneralizedTime : Asn1Object {
    private string m_timeString;
    private bool m_timeStringCanonical;
    private DateTime m_dateTime;
    public string TimeString { get; }
    public Asn1GeneralizedTime(string timeString);
    public Asn1GeneralizedTime(DateTime dateTime);
    internal Asn1GeneralizedTime(Byte[] contents);
    public static Asn1GeneralizedTime GetInstance(object obj);
    public static Asn1GeneralizedTime GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public string get_TimeString();
    public DateTime ToDateTime();
    internal Byte[] GetContents(int encoding);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal static Asn1GeneralizedTime CreatePrimitive(Byte[] contents);
    private static DateTime FromString(string s);
    private static int IndexOfSign(string s, int startIndex);
    private static DateTime ParseLocal(string s, string format);
    private static DateTime ParseTimeZone(string s, string format);
    private static DateTime ParseUtc(string s, string format);
    private static string ToStringCanonical(DateTime dateTime);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Generator : object {
    private Stream m_outStream;
    protected Stream OutStream { get; }
    protected Asn1Generator(Stream outStream);
    protected abstract virtual void Finish();
    protected Stream get_OutStream();
    public abstract virtual void AddObject(Asn1Encodable obj);
    public abstract virtual void AddObject(Asn1Object obj);
    public abstract virtual Stream GetRawOutputStream();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Org.BouncyCastle.Asn1.Asn1InputStream : FilterStream {
    private int limit;
    private bool m_leaveOpen;
    internal Byte[][] tmpBuffers;
    public Asn1InputStream(Byte[] input);
    public Asn1InputStream(Stream input);
    public Asn1InputStream(Stream input, int limit);
    public Asn1InputStream(Stream input, int limit, bool leaveOpen);
    internal Asn1InputStream(Stream input, int limit, bool leaveOpen, Byte[][] tmpBuffers);
    internal static int FindLimit(Stream input);
    protected virtual void Dispose(bool disposing);
    private Asn1Object BuildObject(int tagHdr, int tagNo, int length);
    internal Asn1Object ReadTaggedObjectDL(int tagClass, int tagNo, bool constructed, DefiniteLengthInputStream defIn);
    private Asn1EncodableVector ReadVector();
    private Asn1EncodableVector ReadVector(DefiniteLengthInputStream defIn);
    public Asn1Object ReadObject();
    private DerBitString BuildConstructedBitString(Asn1EncodableVector contentsElements);
    private Asn1OctetString BuildConstructedOctetString(Asn1EncodableVector contentsElements);
    internal static int ReadTagNumber(Stream s, int tagHdr);
    internal static int ReadLength(Stream s, int limit, bool isParsing);
    private static bool GetBuffer(DefiniteLengthInputStream defIn, Byte[][] tmpBuffers, Byte[]& contents);
    internal static Asn1Object CreatePrimitiveDerObject(int tagNo, DefiniteLengthInputStream defIn, Byte[][] tmpBuffers);
    private static DerBmpString CreateDerBmpString(DefiniteLengthInputStream defIn);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Null : Asn1Object {
    public static Asn1Null GetInstance(object obj);
    public static Asn1Null GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string ToString();
    internal static Asn1Null CreatePrimitive(Byte[] contents);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Object : Asn1Encodable {
    public virtual void EncodeTo(Stream output);
    public virtual void EncodeTo(Stream output, string encoding);
    internal virtual Byte[] InternalGetEncoded(string encoding);
    public bool Equals(Asn1Object other);
    public static Asn1Object FromByteArray(Byte[] data);
    public static Asn1Object FromStream(Stream inStr);
    public sealed virtual Asn1Object ToAsn1Object();
    internal abstract virtual IAsn1Encoding GetEncoding(int encoding);
    internal abstract virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal abstract virtual DerEncoding GetEncodingDer();
    internal abstract virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected abstract virtual bool Asn1Equals(Asn1Object asn1Object);
    protected abstract virtual int Asn1GetHashCode();
    internal bool CallAsn1Equals(Asn1Object obj);
    internal int CallAsn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.Asn1ObjectDescriptor : Asn1Object {
    private DerGraphicString m_baseGraphicString;
    public DerGraphicString BaseGraphicString { get; }
    public Asn1ObjectDescriptor(DerGraphicString baseGraphicString);
    public static Asn1ObjectDescriptor GetInstance(object obj);
    public static Asn1ObjectDescriptor GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public DerGraphicString get_BaseGraphicString();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    internal static Asn1ObjectDescriptor CreatePrimitive(Byte[] contents);
}
public abstract class Org.BouncyCastle.Asn1.Asn1OctetString : Asn1Object {
    internal static Byte[] EmptyOctets;
    internal Byte[] contents;
    public Asn1OctetStringParser Parser { get; }
    internal Asn1OctetString(Byte[] contents);
    private static Asn1OctetString();
    public static Asn1OctetString GetInstance(object obj);
    public static Asn1OctetString GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public sealed virtual Stream GetOctetStream();
    public Asn1OctetStringParser get_Parser();
    public virtual Byte[] GetOctets();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
    internal static Asn1OctetString CreatePrimitive(Byte[] contents);
}
public interface Org.BouncyCastle.Asn1.Asn1OctetStringParser {
    public abstract virtual Stream GetOctetStream();
}
public class Org.BouncyCastle.Asn1.Asn1OutputStream : FilterStream {
    internal static int EncodingBer;
    internal static int EncodingDer;
    private bool m_leaveOpen;
    internal int Encoding { get; }
    protected internal Asn1OutputStream(Stream output, bool leaveOpen);
    public static Asn1OutputStream Create(Stream output);
    public static Asn1OutputStream Create(Stream output, string encoding);
    public static Asn1OutputStream Create(Stream output, string encoding, bool leaveOpen);
    internal static int GetEncodingType(string encoding);
    protected virtual void Dispose(bool disposing);
    public virtual void WriteObject(Asn1Encodable asn1Encodable);
    public virtual void WriteObject(Asn1Object asn1Object);
    internal void EncodeContents(IAsn1Encoding[] contentsEncodings);
    internal virtual int get_Encoding();
    private void FlushInternal();
    internal void WriteDL(int dl);
    internal void WriteIdentifier(int flags, int tagNo);
    internal static IAsn1Encoding[] GetContentsEncodings(int encoding, Asn1Encodable[] elements);
    internal static DerEncoding[] GetContentsEncodingsDer(Asn1Encodable[] elements);
    internal static int GetLengthOfContents(IAsn1Encoding[] contentsEncodings);
    internal static int GetLengthOfDL(int dl);
    internal static int GetLengthOfEncodingDL(int tagNo, int contentsLength);
    internal static int GetLengthOfEncodingIL(int tagNo, IAsn1Encoding[] contentsEncodings);
    internal static int GetLengthOfIdentifier(int tagNo);
}
public class Org.BouncyCastle.Asn1.Asn1ParsingException : InvalidOperationException {
    public Asn1ParsingException(string message);
    public Asn1ParsingException(string message, Exception innerException);
    protected Asn1ParsingException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Asn1.Asn1RelativeOid : Asn1Object {
    private static long LongLimit;
    private string identifier;
    private Byte[] contents;
    public string Id { get; }
    public Asn1RelativeOid(string identifier);
    private Asn1RelativeOid(Asn1RelativeOid oid, string branchID);
    private Asn1RelativeOid(Byte[] contents, bool clone);
    public static Asn1RelativeOid FromContents(Byte[] contents);
    public static Asn1RelativeOid GetInstance(object obj);
    public static Asn1RelativeOid GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual Asn1RelativeOid Branch(string branchID);
    public string get_Id();
    public virtual string ToString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    private void DoOutput(MemoryStream bOut);
    private Byte[] GetContents();
    internal static Asn1RelativeOid CreatePrimitive(Byte[] contents, bool clone);
    internal static bool IsValidIdentifier(string identifier, int from);
    internal static void WriteField(Stream outputStream, long fieldValue);
    internal static void WriteField(Stream outputStream, BigInteger fieldValue);
    private static string ParseContents(Byte[] contents);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Asn1.Asn1Sequence : Asn1Object {
    internal Asn1Encodable[] elements;
    public Asn1SequenceParser Parser { get; }
    public Asn1Encodable Item { get; }
    public int Count { get; }
    protected internal Asn1Sequence(Asn1Encodable element);
    protected internal Asn1Sequence(Asn1Encodable element1, Asn1Encodable element2);
    protected internal Asn1Sequence(Asn1Encodable[] elements);
    internal Asn1Sequence(Asn1Encodable[] elements, bool clone);
    protected internal Asn1Sequence(Asn1EncodableVector elementVector);
    public static Asn1Sequence GetInstance(object obj);
    public static Asn1Sequence GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<Asn1Encodable> GetEnumerator();
    public virtual Asn1SequenceParser get_Parser();
    public virtual Asn1Encodable get_Item(int index);
    public virtual int get_Count();
    public virtual T[] MapElements(Func`2<Asn1Encodable, T> func);
    public virtual Asn1Encodable[] ToArray();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
    internal DerBitString[] GetConstructedBitStrings();
    internal Asn1OctetString[] GetConstructedOctetStrings();
    internal abstract virtual DerBitString ToAsn1BitString();
    internal abstract virtual DerExternal ToAsn1External();
    internal abstract virtual Asn1OctetString ToAsn1OctetString();
    internal abstract virtual Asn1Set ToAsn1Set();
}
public interface Org.BouncyCastle.Asn1.Asn1SequenceParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Asn1.Asn1Set : Asn1Object {
    internal Asn1Encodable[] m_elements;
    internal DerEncoding[] m_sortedDerEncodings;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    public Asn1SetParser Parser { get; }
    protected internal Asn1Set(Asn1Encodable element);
    protected internal Asn1Set(Asn1Encodable[] elements, bool doSort);
    protected internal Asn1Set(Asn1EncodableVector elementVector, bool doSort);
    protected internal Asn1Set(bool isSorted, Asn1Encodable[] elements);
    public static Asn1Set GetInstance(object obj);
    public static Asn1Set GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<Asn1Encodable> GetEnumerator();
    public virtual Asn1Encodable get_Item(int index);
    public virtual int get_Count();
    public virtual T[] MapElements(Func`2<Asn1Encodable, T> func);
    public virtual Asn1Encodable[] ToArray();
    public Asn1SetParser get_Parser();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
    private static DerEncoding[] SortElements(Asn1Encodable[] elements);
}
public interface Org.BouncyCastle.Asn1.Asn1SetParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
public class Org.BouncyCastle.Asn1.Asn1StreamParser : object {
    private Stream _in;
    private int _limit;
    private Byte[][] tmpBuffers;
    public Asn1StreamParser(Stream input);
    public Asn1StreamParser(Byte[] encoding);
    public Asn1StreamParser(Stream input, int limit);
    internal Asn1StreamParser(Stream input, int limit, Byte[][] tmpBuffers);
    public virtual IAsn1Convertible ReadObject();
    internal IAsn1Convertible ImplParseObject(int tagHdr);
    internal Asn1Object LoadTaggedDL(int tagClass, int tagNo, bool constructed);
    internal Asn1Object LoadTaggedIL(int tagClass, int tagNo);
    internal IAsn1Convertible ParseImplicitConstructedDL(int univTagNo);
    internal IAsn1Convertible ParseImplicitConstructedIL(int univTagNo);
    internal IAsn1Convertible ParseImplicitPrimitive(int univTagNo);
    internal IAsn1Convertible ParseImplicitPrimitive(int univTagNo, DefiniteLengthInputStream defIn);
    internal IAsn1Convertible ParseObject(int univTagNo);
    internal Asn1TaggedObjectParser ParseTaggedObject();
    internal Asn1EncodableVector ReadVector();
    private void Set00Check(bool enabled);
}
internal class Org.BouncyCastle.Asn1.Asn1Tag : object {
    private int m_tagClass;
    private int m_tagNo;
    internal int TagClass { get; }
    internal int TagNo { get; }
    private Asn1Tag(int tagClass, int tagNo);
    internal static Asn1Tag Create(int tagClass, int tagNo);
    internal int get_TagClass();
    internal int get_TagNo();
}
public abstract class Org.BouncyCastle.Asn1.Asn1TaggedObject : Asn1Object {
    private static int DeclaredExplicit;
    private static int DeclaredImplicit;
    private static int ParsedExplicit;
    private static int ParsedImplicit;
    internal int m_explicitness;
    internal int m_tagClass;
    internal int m_tagNo;
    internal Asn1Encodable m_object;
    public int TagClass { get; }
    public int TagNo { get; }
    internal string Asn1Encoding { get; }
    protected Asn1TaggedObject(bool isExplicit, int tagNo, Asn1Encodable obj);
    protected Asn1TaggedObject(bool isExplicit, int tagClass, int tagNo, Asn1Encodable obj);
    internal Asn1TaggedObject(int explicitness, int tagClass, int tagNo, Asn1Encodable obj);
    public static Asn1TaggedObject GetInstance(object obj);
    public static Asn1TaggedObject GetInstance(object obj, int tagClass);
    public static Asn1TaggedObject GetInstance(object obj, int tagClass, int tagNo);
    public static Asn1TaggedObject GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public static Asn1TaggedObject GetInstance(Asn1TaggedObject taggedObject, int tagClass, bool declaredExplicit);
    public static Asn1TaggedObject GetInstance(Asn1TaggedObject taggedObject, int tagClass, int tagNo, bool declaredExplicit);
    private static Asn1TaggedObject CheckInstance(object obj);
    private static Asn1TaggedObject CheckInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public sealed virtual int get_TagClass();
    public sealed virtual int get_TagNo();
    public bool HasContextTag();
    public sealed virtual bool HasContextTag(int tagNo);
    public sealed virtual bool HasTag(int tagClass, int tagNo);
    public bool HasTagClass(int tagClass);
    public bool IsExplicit();
    internal bool IsParsed();
    public Asn1Object GetObject();
    public Asn1Encodable GetBaseObject();
    public Asn1Encodable GetExplicitBaseObject();
    public Asn1TaggedObject GetExplicitBaseTagged();
    public Asn1TaggedObject GetImplicitBaseTagged(int baseTagClass, int baseTagNo);
    public Asn1Object GetBaseUniversal(bool declaredExplicit, int tagNo);
    internal Asn1Object GetBaseUniversal(bool declaredExplicit, Asn1UniversalType universalType);
    public sealed virtual IAsn1Convertible ParseBaseUniversal(bool declaredExplicit, int baseTagNo);
    public sealed virtual IAsn1Convertible ParseExplicitBaseObject();
    public sealed virtual Asn1TaggedObjectParser ParseExplicitBaseTagged();
    public sealed virtual Asn1TaggedObjectParser ParseImplicitBaseTagged(int baseTagClass, int baseTagNo);
    public virtual string ToString();
    internal abstract virtual string get_Asn1Encoding();
    internal abstract virtual Asn1Sequence RebuildConstructed(Asn1Object asn1Object);
    internal abstract virtual Asn1TaggedObject ReplaceTag(int tagClass, int tagNo);
    internal static Asn1Object CreateConstructedDL(int tagClass, int tagNo, Asn1EncodableVector contentsElements);
    internal static Asn1Object CreateConstructedIL(int tagClass, int tagNo, Asn1EncodableVector contentsElements);
    internal static Asn1Object CreatePrimitive(int tagClass, int tagNo, Byte[] contentsOctets);
    private static Asn1TaggedObject CheckedCast(Asn1Object asn1Object);
}
public interface Org.BouncyCastle.Asn1.Asn1TaggedObjectParser {
    public int TagClass { get; }
    public int TagNo { get; }
    public abstract virtual int get_TagClass();
    public abstract virtual int get_TagNo();
    public abstract virtual bool HasContextTag(int tagNo);
    public abstract virtual bool HasTag(int tagClass, int tagNo);
    public abstract virtual IAsn1Convertible ParseBaseUniversal(bool declaredExplicit, int baseTagNo);
    public abstract virtual IAsn1Convertible ParseExplicitBaseObject();
    public abstract virtual Asn1TaggedObjectParser ParseExplicitBaseTagged();
    public abstract virtual Asn1TaggedObjectParser ParseImplicitBaseTagged(int baseTagClass, int baseTagNo);
}
public class Org.BouncyCastle.Asn1.Asn1Tags : object {
    public static int Boolean;
    public static int Integer;
    public static int BitString;
    public static int OctetString;
    public static int Null;
    public static int ObjectIdentifier;
    public static int ObjectDescriptor;
    public static int External;
    public static int Real;
    public static int Enumerated;
    public static int EmbeddedPdv;
    public static int Utf8String;
    public static int RelativeOid;
    public static int Time;
    public static int Sequence;
    public static int SequenceOf;
    public static int Set;
    public static int SetOf;
    public static int NumericString;
    public static int PrintableString;
    public static int T61String;
    public static int VideotexString;
    public static int IA5String;
    public static int UtcTime;
    public static int GeneralizedTime;
    public static int GraphicString;
    public static int VisibleString;
    public static int GeneralString;
    public static int UniversalString;
    public static int UnrestrictedString;
    public static int BmpString;
    public static int Date;
    public static int TimeOfDay;
    public static int DateTime;
    public static int Duration;
    public static int ObjectIdentifierIri;
    public static int RelativeOidIri;
    public static int Constructed;
    public static int Universal;
    public static int Application;
    public static int ContextSpecific;
    public static int Private;
    public static int Flags;
}
internal abstract class Org.BouncyCastle.Asn1.Asn1Type : object {
    internal Type m_platformType;
    internal Type PlatformType { get; }
    internal Asn1Type(Type platformType);
    internal Type get_PlatformType();
    public sealed virtual bool Equals(object that);
    public sealed virtual int GetHashCode();
}
internal abstract class Org.BouncyCastle.Asn1.Asn1UniversalType : Asn1Type {
    internal Asn1Tag m_tag;
    internal Asn1Tag Tag { get; }
    internal Asn1UniversalType(Type platformType, int tagNo);
    internal Asn1Object CheckedCast(Asn1Object asn1Object);
    internal virtual Asn1Object FromImplicitPrimitive(DerOctetString octetString);
    internal virtual Asn1Object FromImplicitConstructed(Asn1Sequence sequence);
    internal Asn1Object FromByteArray(Byte[] bytes);
    internal Asn1Object GetContextInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    internal Asn1Tag get_Tag();
}
internal class Org.BouncyCastle.Asn1.Asn1UniversalTypes : object {
    internal static Asn1UniversalType Get(int tagNo);
}
public class Org.BouncyCastle.Asn1.Asn1UtcTime : Asn1Object {
    private string m_timeString;
    private DateTime m_dateTime;
    private bool m_dateTimeLocked;
    private int m_twoDigitYearMax;
    public string TimeString { get; }
    public int TwoDigitYearMax { get; }
    public Asn1UtcTime(string timeString);
    [ObsoleteAttribute("Use `Asn1UtcTime(DateTime, int)' instead")]
public Asn1UtcTime(DateTime dateTime);
    public Asn1UtcTime(DateTime dateTime, int twoDigitYearMax);
    internal Asn1UtcTime(Byte[] contents);
    public static Asn1UtcTime GetInstance(object obj);
    public static Asn1UtcTime GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public string get_TimeString();
    public DateTime ToDateTime();
    public DateTime ToDateTime(int twoDigitYearMax);
    public DateTime ToDateTime(Calendar calendar);
    [ObsoleteAttribute("Use 'ToDateTime(2049)' instead")]
public DateTime ToAdjustedDateTime();
    public int get_TwoDigitYearMax();
    internal Byte[] GetContents(int encoding);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
    internal static Asn1UtcTime CreatePrimitive(Byte[] contents);
    private static DateTime FromString(string s, Int32& twoDigitYearMax);
    private static bool InRange(DateTime dateTime, int twoDigitYearMax);
    private static string ToStringCanonical(DateTime dateTime, Int32& twoDigitYearMax);
    private static string ToStringCanonical(DateTime dateTime);
    private static void Validate(DateTime dateTime, int twoDigitYearMax);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Utilities : object {
    internal static Asn1TaggedObject CheckTagClass(Asn1TaggedObject taggedObject, int tagClass);
    internal static Asn1TaggedObjectParser CheckTagClass(Asn1TaggedObjectParser taggedObjectParser, int tagClass);
    internal static Asn1TaggedObject CheckTag(Asn1TaggedObject taggedObject, int tagClass, int tagNo);
    internal static Asn1TaggedObjectParser CheckTag(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo);
    internal static TChoice GetInstanceFromChoice(Asn1TaggedObject taggedObject, bool declaredExplicit, Func`2<object, TChoice> constructor);
    public static string GetTagClassText(int tagClass);
    public static string GetTagClassText(Asn1TaggedObject taggedObject);
    public static string GetTagClassText(Asn1TaggedObjectParser taggedObjectParser);
    internal static string GetTagText(Asn1Tag tag);
    public static string GetTagText(Asn1TaggedObject taggedObject);
    public static string GetTagText(Asn1TaggedObjectParser taggedObjectParser);
    public static string GetTagText(int tagClass, int tagNo);
    public static Asn1Encodable GetExplicitBaseObject(Asn1TaggedObject taggedObject, int tagClass, int tagNo);
    public static Asn1Encodable GetExplicitContextBaseObject(Asn1TaggedObject taggedObject, int tagNo);
    [ObsoleteAttribute("Will be removed")]
public static Asn1Encodable TryGetExplicitBaseObject(Asn1TaggedObject taggedObject, int tagClass, int tagNo);
    public static bool TryGetExplicitBaseObject(Asn1TaggedObject taggedObject, int tagClass, int tagNo, Asn1Encodable& baseObject);
    [ObsoleteAttribute("Will be removed")]
public static Asn1Encodable TryGetExplicitContextBaseObject(Asn1TaggedObject taggedObject, int tagNo);
    public static bool TryGetExplicitContextBaseObject(Asn1TaggedObject taggedObject, int tagNo, Asn1Encodable& baseObject);
    public static Asn1TaggedObject GetExplicitBaseTagged(Asn1TaggedObject taggedObject, int tagClass);
    public static Asn1TaggedObject GetExplicitBaseTagged(Asn1TaggedObject taggedObject, int tagClass, int tagNo);
    public static Asn1TaggedObject GetExplicitContextBaseTagged(Asn1TaggedObject taggedObject);
    public static Asn1TaggedObject GetExplicitContextBaseTagged(Asn1TaggedObject taggedObject, int tagNo);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObject TryGetExplicitBaseTagged(Asn1TaggedObject taggedObject, int tagClass);
    public static bool TryGetExplicitBaseTagged(Asn1TaggedObject taggedObject, int tagClass, Asn1TaggedObject& baseTagged);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObject TryGetExplicitBaseTagged(Asn1TaggedObject taggedObject, int tagClass, int tagNo);
    public static bool TryGetExplicitBaseTagged(Asn1TaggedObject taggedObject, int tagClass, int tagNo, Asn1TaggedObject& baseTagged);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObject TryGetExplicitContextBaseTagged(Asn1TaggedObject taggedObject);
    public static bool TryGetExplicitContextBaseTagged(Asn1TaggedObject taggedObject, Asn1TaggedObject& baseTagged);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObject TryGetExplicitContextBaseTagged(Asn1TaggedObject taggedObject, int tagNo);
    public static bool TryGetExplicitContextBaseTagged(Asn1TaggedObject taggedObject, int tagNo, Asn1TaggedObject& baseTagged);
    public static Asn1TaggedObject GetImplicitBaseTagged(Asn1TaggedObject taggedObject, int tagClass, int tagNo, int baseTagClass, int baseTagNo);
    public static Asn1TaggedObject GetImplicitContextBaseTagged(Asn1TaggedObject taggedObject, int tagNo, int baseTagClass, int baseTagNo);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObject TryGetImplicitBaseTagged(Asn1TaggedObject taggedObject, int tagClass, int tagNo, int baseTagClass, int baseTagNo);
    public static bool TryGetImplicitBaseTagged(Asn1TaggedObject taggedObject, int tagClass, int tagNo, int baseTagClass, int baseTagNo, Asn1TaggedObject& baseTagged);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObject TryGetImplicitContextBaseTagged(Asn1TaggedObject taggedObject, int tagNo, int baseTagClass, int baseTagNo);
    public static bool TryGetImplicitContextBaseTagged(Asn1TaggedObject taggedObject, int tagNo, int baseTagClass, int baseTagNo, Asn1TaggedObject& baseTagged);
    public static Asn1Object GetBaseUniversal(Asn1TaggedObject taggedObject, int tagClass, int tagNo, bool declaredExplicit, int baseTagNo);
    public static Asn1Object GetContextBaseUniversal(Asn1TaggedObject taggedObject, int tagNo, bool declaredExplicit, int baseTagNo);
    [ObsoleteAttribute("Will be removed")]
public static Asn1Object TryGetBaseUniversal(Asn1TaggedObject taggedObject, int tagClass, int tagNo, bool declaredExplicit, int baseTagNo);
    public static bool TryGetBaseUniversal(Asn1TaggedObject taggedObject, int tagClass, int tagNo, bool declaredExplicit, int baseTagNo, Asn1Object& baseUniversal);
    [ObsoleteAttribute("Will be removed")]
public static Asn1Object TryGetContextBaseUniversal(Asn1TaggedObject taggedObject, int tagNo, bool declaredExplicit, int baseTagNo);
    public static bool TryGetContextBaseUniversal(Asn1TaggedObject taggedObject, int tagNo, bool declaredExplicit, int baseTagNo, Asn1Object& baseUniversal);
    public static Asn1TaggedObjectParser ParseExplicitBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagClass);
    public static Asn1TaggedObjectParser ParseExplicitBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo);
    public static Asn1TaggedObjectParser ParseExplicitContextBaseTagged(Asn1TaggedObjectParser taggedObjectParser);
    public static Asn1TaggedObjectParser ParseExplicitContextBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagNo);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObjectParser TryParseExplicitBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagClass);
    public static bool TryParseExplicitBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagClass, Asn1TaggedObjectParser& baseTagged);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObjectParser TryParseExplicitBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo);
    public static bool TryParseExplicitBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo, Asn1TaggedObjectParser& baseTagged);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObjectParser TryParseExplicitContextBaseTagged(Asn1TaggedObjectParser taggedObjectParser);
    public static bool TryParseExplicitContextBaseTagged(Asn1TaggedObjectParser taggedObjectParser, Asn1TaggedObjectParser& baseTagged);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObjectParser TryParseExplicitContextBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagNo);
    public static bool TryParseExplicitContextBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagNo, Asn1TaggedObjectParser& baseTagged);
    public static Asn1TaggedObjectParser ParseImplicitBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo, int baseTagClass, int baseTagNo);
    public static Asn1TaggedObjectParser ParseImplicitContextBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagNo, int baseTagClass, int baseTagNo);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObjectParser TryParseImplicitBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo, int baseTagClass, int baseTagNo);
    public static bool TryParseImplicitBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo, int baseTagClass, int baseTagNo, Asn1TaggedObjectParser& baseTagged);
    [ObsoleteAttribute("Will be removed")]
public static Asn1TaggedObjectParser TryParseImplicitContextBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagNo, int baseTagClass, int baseTagNo);
    public static bool TryParseImplicitContextBaseTagged(Asn1TaggedObjectParser taggedObjectParser, int tagNo, int baseTagClass, int baseTagNo, Asn1TaggedObjectParser& baseTagged);
    public static IAsn1Convertible ParseBaseUniversal(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo, bool declaredExplicit, int baseTagNo);
    public static IAsn1Convertible ParseContextBaseUniversal(Asn1TaggedObjectParser taggedObjectParser, int tagNo, bool declaredExplicit, int baseTagNo);
    [ObsoleteAttribute("Will be removed")]
public static IAsn1Convertible TryParseBaseUniversal(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo, bool declaredExplicit, int baseTagNo);
    public static bool TryParseBaseUniversal(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo, bool declaredExplicit, int baseTagNo, IAsn1Convertible& baseUniversal);
    [ObsoleteAttribute("Will be removed")]
public static IAsn1Convertible TryParseContextBaseUniversal(Asn1TaggedObjectParser taggedObjectParser, int tagNo, bool declaredExplicit, int baseTagNo);
    public static bool TryParseContextBaseUniversal(Asn1TaggedObjectParser taggedObjectParser, int tagNo, bool declaredExplicit, int baseTagNo, IAsn1Convertible& baseUniversal);
    public static IAsn1Convertible ParseExplicitBaseObject(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo);
    public static IAsn1Convertible ParseExplicitContextBaseObject(Asn1TaggedObjectParser taggedObjectParser, int tagNo);
    [ObsoleteAttribute("Will be removed")]
public static IAsn1Convertible TryParseExplicitBaseObject(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo);
    public static bool TryParseExplicitBaseObject(Asn1TaggedObjectParser taggedObjectParser, int tagClass, int tagNo, IAsn1Convertible& baseObject);
    [ObsoleteAttribute("Will be removed")]
public static IAsn1Convertible TryParseExplicitContextBaseObject(Asn1TaggedObjectParser taggedObjectParser, int tagNo);
    public static bool TryParseExplicitContextBaseObject(Asn1TaggedObjectParser taggedObjectParser, int tagNo, IAsn1Convertible& baseObject);
}
public abstract class Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers : object {
    public static DerObjectIdentifier bc;
    public static DerObjectIdentifier bc_pbe;
    public static DerObjectIdentifier bc_pbe_sha1;
    public static DerObjectIdentifier bc_pbe_sha256;
    public static DerObjectIdentifier bc_pbe_sha384;
    public static DerObjectIdentifier bc_pbe_sha512;
    public static DerObjectIdentifier bc_pbe_sha224;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs5;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs5;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12_aes128_cbc;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12_aes192_cbc;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12_aes256_cbc;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12_aes128_cbc;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12_aes192_cbc;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12_aes256_cbc;
    public static DerObjectIdentifier bc_sig;
    public static DerObjectIdentifier sphincs256;
    public static DerObjectIdentifier sphincs256_with_BLAKE512;
    public static DerObjectIdentifier sphincs256_with_SHA512;
    public static DerObjectIdentifier sphincs256_with_SHA3_512;
    public static DerObjectIdentifier xmss;
    public static DerObjectIdentifier xmss_with_SHA256;
    public static DerObjectIdentifier xmss_with_SHA512;
    public static DerObjectIdentifier xmss_with_SHAKE128;
    public static DerObjectIdentifier xmss_with_SHAKE256;
    public static DerObjectIdentifier xmss_mt;
    public static DerObjectIdentifier xmss_mt_with_SHA256;
    public static DerObjectIdentifier xmss_mt_with_SHA512;
    public static DerObjectIdentifier xmss_mt_with_SHAKE128;
    public static DerObjectIdentifier xmss_mt_with_SHAKE256;
    public static DerObjectIdentifier sphincsPlus;
    public static DerObjectIdentifier sphincsPlus_shake_256;
    public static DerObjectIdentifier sphincsPlus_sha_256;
    public static DerObjectIdentifier sphincsPlus_sha_512;
    public static DerObjectIdentifier picnic;
    public static DerObjectIdentifier picnicl1fs;
    public static DerObjectIdentifier picnicl1ur;
    public static DerObjectIdentifier picnicl3fs;
    public static DerObjectIdentifier picnicl3ur;
    public static DerObjectIdentifier picnicl5fs;
    public static DerObjectIdentifier picnicl5ur;
    public static DerObjectIdentifier picnic3l1;
    public static DerObjectIdentifier picnic3l3;
    public static DerObjectIdentifier picnic3l5;
    public static DerObjectIdentifier picnicl1full;
    public static DerObjectIdentifier picnicl3full;
    public static DerObjectIdentifier picnicl5full;
    public static DerObjectIdentifier falcon;
    public static DerObjectIdentifier falcon_512;
    public static DerObjectIdentifier falcon_1024;
    public static DerObjectIdentifier dilithium;
    public static DerObjectIdentifier dilithium2;
    public static DerObjectIdentifier dilithium3;
    public static DerObjectIdentifier dilithium5;
    public static DerObjectIdentifier dilithium2_aes;
    public static DerObjectIdentifier dilithium3_aes;
    public static DerObjectIdentifier dilithium5_aes;
    public static DerObjectIdentifier bc_exch;
    public static DerObjectIdentifier newHope;
    public static DerObjectIdentifier bc_ext;
    public static DerObjectIdentifier linkedCertificate;
    public static DerObjectIdentifier bc_kem;
    public static DerObjectIdentifier pqc_kem_mceliece;
    public static DerObjectIdentifier mceliece348864_r3;
    public static DerObjectIdentifier mceliece348864f_r3;
    public static DerObjectIdentifier mceliece460896_r3;
    public static DerObjectIdentifier mceliece460896f_r3;
    public static DerObjectIdentifier mceliece6688128_r3;
    public static DerObjectIdentifier mceliece6688128f_r3;
    public static DerObjectIdentifier mceliece6960119_r3;
    public static DerObjectIdentifier mceliece6960119f_r3;
    public static DerObjectIdentifier mceliece8192128_r3;
    public static DerObjectIdentifier mceliece8192128f_r3;
    public static DerObjectIdentifier pqc_kem_saber;
    public static DerObjectIdentifier lightsaberkem128r3;
    public static DerObjectIdentifier saberkem128r3;
    public static DerObjectIdentifier firesaberkem128r3;
    public static DerObjectIdentifier lightsaberkem192r3;
    public static DerObjectIdentifier saberkem192r3;
    public static DerObjectIdentifier firesaberkem192r3;
    public static DerObjectIdentifier lightsaberkem256r3;
    public static DerObjectIdentifier saberkem256r3;
    public static DerObjectIdentifier firesaberkem256r3;
    public static DerObjectIdentifier ulightsaberkemr3;
    public static DerObjectIdentifier usaberkemr3;
    public static DerObjectIdentifier ufiresaberkemr3;
    public static DerObjectIdentifier lightsaberkem90sr3;
    public static DerObjectIdentifier saberkem90sr3;
    public static DerObjectIdentifier firesaberkem90sr3;
    public static DerObjectIdentifier ulightsaberkem90sr3;
    public static DerObjectIdentifier usaberkem90sr3;
    public static DerObjectIdentifier ufiresaberkem90sr3;
    public static DerObjectIdentifier pqc_kem_sike;
    public static DerObjectIdentifier sikep434;
    public static DerObjectIdentifier sikep503;
    public static DerObjectIdentifier sikep610;
    public static DerObjectIdentifier sikep751;
    public static DerObjectIdentifier sikep434_compressed;
    public static DerObjectIdentifier sikep503_compressed;
    public static DerObjectIdentifier sikep610_compressed;
    public static DerObjectIdentifier sikep751_compressed;
    public static DerObjectIdentifier pqc_kem_kyber;
    public static DerObjectIdentifier kyber512;
    public static DerObjectIdentifier kyber768;
    public static DerObjectIdentifier kyber1024;
    public static DerObjectIdentifier kyber512_aes;
    public static DerObjectIdentifier kyber768_aes;
    public static DerObjectIdentifier kyber1024_aes;
    public static DerObjectIdentifier pqc_kem_bike;
    public static DerObjectIdentifier bike128;
    public static DerObjectIdentifier bike192;
    public static DerObjectIdentifier bike256;
    public static DerObjectIdentifier pqc_kem_hqc;
    public static DerObjectIdentifier hqc128;
    public static DerObjectIdentifier hqc192;
    public static DerObjectIdentifier hqc256;
    private static BCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.BC.LinkedCertificate : Asn1Encodable {
    private DigestInfo mDigest;
    private GeneralName mCertLocation;
    private X509Name mCertIssuer;
    private GeneralNames mCACerts;
    public DigestInfo Digest { get; }
    public GeneralName CertLocation { get; }
    public X509Name CertIssuer { get; }
    public GeneralNames CACerts { get; }
    public LinkedCertificate(DigestInfo digest, GeneralName certLocation);
    public LinkedCertificate(DigestInfo digest, GeneralName certLocation, X509Name certIssuer, GeneralNames caCerts);
    private LinkedCertificate(Asn1Sequence seq);
    public static LinkedCertificate GetInstance(object obj);
    public virtual DigestInfo get_Digest();
    public virtual GeneralName get_CertLocation();
    public virtual X509Name get_CertIssuer();
    public virtual GeneralNames get_CACerts();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerBitString : DerBitString {
    private DerBitString[] elements;
    public BerBitString(byte data, int padBits);
    public BerBitString(Byte[] data);
    public BerBitString(Byte[] data, int padBits);
    [ObsoleteAttribute("Use version without segmentLimit (which is ignored anyway)")]
public BerBitString(Byte[] data, int padBits, int segmentLimit);
    public BerBitString(int namedBits);
    public BerBitString(Asn1Encodable obj);
    public BerBitString(DerBitString[] elements);
    [ObsoleteAttribute("Use version without segmentLimit (which is ignored anyway)")]
public BerBitString(DerBitString[] elements, int segmentLimit);
    internal BerBitString(Byte[] contents, bool check);
    public static BerBitString FromSequence(Asn1Sequence seq);
    internal static Byte[] FlattenBitStrings(DerBitString[] bitStrings);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
}
internal class Org.BouncyCastle.Asn1.BerBitStringParser : object {
    private Asn1StreamParser m_parser;
    private ConstructedBitStream m_bitStream;
    public int PadBits { get; }
    internal BerBitStringParser(Asn1StreamParser parser);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Stream GetBitStream();
    public sealed virtual int get_PadBits();
    public sealed virtual Asn1Object ToAsn1Object();
    internal static BerBitString Parse(Asn1StreamParser sp);
}
public abstract class Org.BouncyCastle.Asn1.BerGenerator : Asn1Generator {
    private bool _tagged;
    private bool _isExplicit;
    private int _tagNo;
    protected BerGenerator(Stream outStream);
    protected BerGenerator(Stream outStream, int tagNo, bool isExplicit);
    protected virtual void Finish();
    public virtual void AddObject(Asn1Encodable obj);
    public virtual void AddObject(Asn1Object obj);
    public virtual Stream GetRawOutputStream();
    private void WriteHdr(int tag);
    protected void WriteBerHeader(int tag);
    protected void WriteBerBody(Stream contentStream);
    protected void WriteBerEnd();
}
public class Org.BouncyCastle.Asn1.BerOctetString : DerOctetString {
    private Asn1OctetString[] elements;
    public BerOctetString(Byte[] contents);
    public BerOctetString(Asn1OctetString[] elements);
    [ObsoleteAttribute("Use version without segmentLimit (which is ignored anyway)")]
public BerOctetString(Byte[] contents, int segmentLimit);
    [ObsoleteAttribute("Use version without segmentLimit (which is ignored anyway)")]
public BerOctetString(Asn1OctetString[] elements, int segmentLimit);
    private BerOctetString(Byte[] contents, Asn1OctetString[] elements);
    public static BerOctetString FromSequence(Asn1Sequence seq);
    internal static Byte[] FlattenOctetStrings(Asn1OctetString[] octetStrings);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
}
public class Org.BouncyCastle.Asn1.BerOctetStringGenerator : BerGenerator {
    public BerOctetStringGenerator(Stream outStream);
    public BerOctetStringGenerator(Stream outStream, int tagNo, bool isExplicit);
    public Stream GetOctetOutputStream();
    public Stream GetOctetOutputStream(int bufSize);
    public Stream GetOctetOutputStream(Byte[] buf);
}
public class Org.BouncyCastle.Asn1.BerOctetStringParser : object {
    private Asn1StreamParser _parser;
    internal BerOctetStringParser(Asn1StreamParser parser);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1Object ToAsn1Object();
    internal static BerOctetString Parse(Asn1StreamParser sp);
}
public class Org.BouncyCastle.Asn1.BerSequence : DerSequence {
    public static BerSequence Empty;
    public BerSequence(Asn1Encodable element);
    public BerSequence(Asn1Encodable element1, Asn1Encodable element2);
    public BerSequence(Asn1Encodable[] elements);
    public BerSequence(Asn1EncodableVector elementVector);
    internal BerSequence(Asn1Encodable[] elements, bool clone);
    private static BerSequence();
    public static BerSequence FromVector(Asn1EncodableVector elementVector);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal virtual DerBitString ToAsn1BitString();
    internal virtual DerExternal ToAsn1External();
    internal virtual Asn1OctetString ToAsn1OctetString();
    internal virtual Asn1Set ToAsn1Set();
}
public class Org.BouncyCastle.Asn1.BerSequenceGenerator : BerGenerator {
    public BerSequenceGenerator(Stream outStream);
    public BerSequenceGenerator(Stream outStream, int tagNo, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.BerSequenceParser : object {
    private Asn1StreamParser _parser;
    internal BerSequenceParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
    internal static BerSequence Parse(Asn1StreamParser sp);
}
public class Org.BouncyCastle.Asn1.BerSet : DerSet {
    public static BerSet Empty;
    public BerSet(Asn1Encodable element);
    public BerSet(Asn1Encodable[] elements);
    public BerSet(Asn1EncodableVector elementVector);
    internal BerSet(bool isSorted, Asn1Encodable[] elements);
    private static BerSet();
    public static BerSet FromVector(Asn1EncodableVector elementVector);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
}
public class Org.BouncyCastle.Asn1.BerSetGenerator : BerGenerator {
    public BerSetGenerator(Stream outStream);
    public BerSetGenerator(Stream outStream, int tagNo, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.BerSetParser : object {
    private Asn1StreamParser _parser;
    internal BerSetParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
    internal static BerSet Parse(Asn1StreamParser sp);
}
public class Org.BouncyCastle.Asn1.BerTaggedObject : DerTaggedObject {
    internal string Asn1Encoding { get; }
    public BerTaggedObject(int tagNo, Asn1Encodable obj);
    public BerTaggedObject(int tagClass, int tagNo, Asn1Encodable obj);
    public BerTaggedObject(bool isExplicit, int tagNo, Asn1Encodable obj);
    public BerTaggedObject(bool isExplicit, int tagClass, int tagNo, Asn1Encodable obj);
    internal BerTaggedObject(int explicitness, int tagClass, int tagNo, Asn1Encodable obj);
    internal virtual string get_Asn1Encoding();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal virtual Asn1Sequence RebuildConstructed(Asn1Object asn1Object);
    internal virtual Asn1TaggedObject ReplaceTag(int tagClass, int tagNo);
}
internal class Org.BouncyCastle.Asn1.BerTaggedObjectParser : object {
    internal int m_tagClass;
    internal int m_tagNo;
    internal Asn1StreamParser m_parser;
    public bool IsConstructed { get; }
    public int TagClass { get; }
    public int TagNo { get; }
    internal BerTaggedObjectParser(int tagClass, int tagNo, Asn1StreamParser parser);
    public virtual bool get_IsConstructed();
    public sealed virtual int get_TagClass();
    public sealed virtual int get_TagNo();
    public bool HasContextTag();
    public sealed virtual bool HasContextTag(int tagNo);
    public sealed virtual bool HasTag(int tagClass, int tagNo);
    public bool HasTagClass(int tagClass);
    public virtual IAsn1Convertible ParseBaseUniversal(bool declaredExplicit, int baseTagNo);
    public virtual IAsn1Convertible ParseExplicitBaseObject();
    public virtual Asn1TaggedObjectParser ParseExplicitBaseTagged();
    public virtual Asn1TaggedObjectParser ParseImplicitBaseTagged(int baseTagClass, int baseTagNo);
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers : object {
    public static DerObjectIdentifier bsi_de;
    public static DerObjectIdentifier id_ecc;
    public static DerObjectIdentifier ecdsa_plain_signatures;
    public static DerObjectIdentifier ecdsa_plain_SHA1;
    public static DerObjectIdentifier ecdsa_plain_SHA224;
    public static DerObjectIdentifier ecdsa_plain_SHA256;
    public static DerObjectIdentifier ecdsa_plain_SHA384;
    public static DerObjectIdentifier ecdsa_plain_SHA512;
    public static DerObjectIdentifier ecdsa_plain_RIPEMD160;
    public static DerObjectIdentifier algorithm;
    public static DerObjectIdentifier ecka_eg;
    public static DerObjectIdentifier ecka_eg_X963kdf;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA1;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA224;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA256;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA384;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA512;
    public static DerObjectIdentifier ecka_eg_X963kdf_RIPEMD160;
    public static DerObjectIdentifier ecka_eg_SessionKDF;
    public static DerObjectIdentifier ecka_eg_SessionKDF_3DES;
    public static DerObjectIdentifier ecka_eg_SessionKDF_AES128;
    public static DerObjectIdentifier ecka_eg_SessionKDF_AES192;
    public static DerObjectIdentifier ecka_eg_SessionKDF_AES256;
    private static BsiObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Cmp.CAKeyUpdAnnContent : Asn1Encodable {
    private CmpCertificate m_oldWithNew;
    private CmpCertificate m_newWithOld;
    private CmpCertificate m_newWithNew;
    public CmpCertificate OldWithNew { get; }
    public CmpCertificate NewWithOld { get; }
    public CmpCertificate NewWithNew { get; }
    private CAKeyUpdAnnContent(Asn1Sequence seq);
    public static CAKeyUpdAnnContent GetInstance(object obj);
    public static CAKeyUpdAnnContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CmpCertificate get_OldWithNew();
    public virtual CmpCertificate get_NewWithOld();
    public virtual CmpCertificate get_NewWithNew();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertAnnContent : CmpCertificate {
    [ObsoleteAttribute("Use 'GetInstance' from tagged object instead")]
public CertAnnContent(int type, Asn1Object otherCert);
    internal CertAnnContent(Asn1TaggedObject taggedObject);
    internal CertAnnContent(CmpCertificate other);
    public CertAnnContent(X509CertificateStructure x509v3PKCert);
    public static CertAnnContent GetInstance(object obj);
    public static CertAnnContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
}
public class Org.BouncyCastle.Asn1.Cmp.CertConfirmContent : Asn1Encodable {
    private Asn1Sequence m_content;
    private CertConfirmContent(Asn1Sequence seq);
    public static CertConfirmContent GetInstance(object obj);
    public static CertConfirmContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CertStatus[] ToCertStatusArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertifiedKeyPair : Asn1Encodable {
    private CertOrEncCert m_certOrEncCert;
    private EncryptedKey m_privateKey;
    private PkiPublicationInfo m_publicationInfo;
    public CertOrEncCert CertOrEncCert { get; }
    public EncryptedKey PrivateKey { get; }
    public PkiPublicationInfo PublicationInfo { get; }
    private CertifiedKeyPair(Asn1Sequence seq);
    public CertifiedKeyPair(CertOrEncCert certOrEncCert);
    public CertifiedKeyPair(CertOrEncCert certOrEncCert, EncryptedValue privateKey, PkiPublicationInfo publicationInfo);
    public CertifiedKeyPair(CertOrEncCert certOrEncCert, EncryptedKey privateKey, PkiPublicationInfo publicationInfo);
    public static CertifiedKeyPair GetInstance(object obj);
    public static CertifiedKeyPair GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CertOrEncCert get_CertOrEncCert();
    public virtual EncryptedKey get_PrivateKey();
    public virtual PkiPublicationInfo get_PublicationInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertOrEncCert : Asn1Encodable {
    private CmpCertificate m_certificate;
    private EncryptedKey m_encryptedCert;
    public CmpCertificate Certificate { get; }
    public EncryptedKey EncryptedCert { get; }
    private CertOrEncCert(Asn1TaggedObject taggedObject);
    public CertOrEncCert(CmpCertificate certificate);
    public CertOrEncCert(EncryptedValue encryptedValue);
    public CertOrEncCert(EncryptedKey encryptedKey);
    public static CertOrEncCert GetInstance(object obj);
    public static CertOrEncCert GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CmpCertificate get_Certificate();
    public virtual EncryptedKey get_EncryptedCert();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertRepMessage : Asn1Encodable {
    private Asn1Sequence m_caPubs;
    private Asn1Sequence m_response;
    private CertRepMessage(Asn1Sequence seq);
    public CertRepMessage(CmpCertificate[] caPubs, CertResponse[] response);
    public static CertRepMessage GetInstance(object obj);
    public static CertRepMessage GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CmpCertificate[] GetCAPubs();
    public virtual CertResponse[] GetResponse();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertReqTemplateContent : Asn1Encodable {
    private CertTemplate m_certTemplate;
    private Asn1Sequence m_keySpec;
    public CertTemplate CertTemplate { get; }
    public Asn1Sequence KeySpec { get; }
    private CertReqTemplateContent(Asn1Sequence seq);
    public CertReqTemplateContent(CertTemplate certTemplate, Asn1Sequence keySpec);
    public static CertReqTemplateContent GetInstance(object obj);
    public static CertReqTemplateContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CertTemplate get_CertTemplate();
    public virtual Asn1Sequence get_KeySpec();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertResponse : Asn1Encodable {
    private DerInteger m_certReqId;
    private PkiStatusInfo m_status;
    private CertifiedKeyPair m_certifiedKeyPair;
    private Asn1OctetString m_rspInfo;
    public DerInteger CertReqID { get; }
    public PkiStatusInfo Status { get; }
    public CertifiedKeyPair CertifiedKeyPair { get; }
    private CertResponse(Asn1Sequence seq);
    public CertResponse(DerInteger certReqId, PkiStatusInfo status);
    public CertResponse(DerInteger certReqId, PkiStatusInfo status, CertifiedKeyPair certifiedKeyPair, Asn1OctetString rspInfo);
    public static CertResponse GetInstance(object obj);
    public static CertResponse GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual DerInteger get_CertReqID();
    public virtual PkiStatusInfo get_Status();
    public virtual CertifiedKeyPair get_CertifiedKeyPair();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertStatus : Asn1Encodable {
    private Asn1OctetString m_certHash;
    private DerInteger m_certReqID;
    private PkiStatusInfo m_statusInfo;
    private AlgorithmIdentifier m_hashAlg;
    public Asn1OctetString CertHash { get; }
    public DerInteger CertReqID { get; }
    public PkiStatusInfo StatusInfo { get; }
    public AlgorithmIdentifier HashAlg { get; }
    private CertStatus(Asn1Sequence seq);
    public CertStatus(Byte[] certHash, BigInteger certReqID);
    public CertStatus(Byte[] certHash, BigInteger certReqID, PkiStatusInfo statusInfo);
    public CertStatus(Byte[] certHash, BigInteger certReqID, PkiStatusInfo statusInfo, AlgorithmIdentifier hashAlg);
    public static CertStatus GetInstance(object obj);
    public static CertStatus GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual Asn1OctetString get_CertHash();
    public virtual DerInteger get_CertReqID();
    public virtual PkiStatusInfo get_StatusInfo();
    public virtual AlgorithmIdentifier get_HashAlg();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.Challenge : Asn1Encodable {
    private AlgorithmIdentifier m_owf;
    private Asn1OctetString m_witness;
    private Asn1OctetString m_challenge;
    public AlgorithmIdentifier Owf { get; }
    public Asn1OctetString Witness { get; }
    public Asn1OctetString ChallengeValue { get; }
    private Challenge(Asn1Sequence seq);
    public Challenge(Byte[] witness, Byte[] challenge);
    public Challenge(AlgorithmIdentifier owf, Byte[] witness, Byte[] challenge);
    public static Challenge GetInstance(object obj);
    public static Challenge GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual AlgorithmIdentifier get_Owf();
    public virtual Asn1OctetString get_Witness();
    public virtual Asn1OctetString get_ChallengeValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CmpCertificate : Asn1Encodable {
    private X509CertificateStructure m_x509v3PKCert;
    private int m_otherTag;
    private Asn1Encodable m_otherObject;
    public bool IsX509v3PKCert { get; }
    public X509CertificateStructure X509v3PKCert { get; }
    public int OtherCertTag { get; }
    public Asn1Encodable OtherCert { get; }
    [ObsoleteAttribute("Use 'GetInstance' from tagged object instead")]
public CmpCertificate(int type, Asn1Encodable otherCert);
    internal CmpCertificate(Asn1TaggedObject taggedObject);
    internal CmpCertificate(CmpCertificate other);
    public CmpCertificate(X509CertificateStructure x509v3PKCert);
    public static CmpCertificate GetInstance(object obj);
    public static CmpCertificate GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual bool get_IsX509v3PKCert();
    public virtual X509CertificateStructure get_X509v3PKCert();
    public virtual int get_OtherCertTag();
    public virtual Asn1Encodable get_OtherCert();
    public virtual Asn1Object ToAsn1Object();
}
public static class Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers : object {
    public static DerObjectIdentifier passwordBasedMac;
    public static DerObjectIdentifier dhBasedMac;
    public static DerObjectIdentifier it_caProtEncCert;
    public static DerObjectIdentifier it_signKeyPairTypes;
    public static DerObjectIdentifier it_encKeyPairTypes;
    public static DerObjectIdentifier it_preferredSymAlg;
    public static DerObjectIdentifier it_caKeyUpdateInfo;
    public static DerObjectIdentifier it_currentCRL;
    public static DerObjectIdentifier it_unsupportedOIDs;
    public static DerObjectIdentifier it_keyPairParamReq;
    public static DerObjectIdentifier it_keyPairParamRep;
    public static DerObjectIdentifier it_revPassphrase;
    public static DerObjectIdentifier it_implicitConfirm;
    public static DerObjectIdentifier it_confirmWaitTime;
    public static DerObjectIdentifier it_origPKIMessage;
    public static DerObjectIdentifier it_suppLangTags;
    public static DerObjectIdentifier id_it_caCerts;
    public static DerObjectIdentifier id_it_rootCaKeyUpdate;
    public static DerObjectIdentifier id_it_certReqTemplate;
    public static DerObjectIdentifier id_it_rootCaCert;
    public static DerObjectIdentifier id_it_certProfile;
    public static DerObjectIdentifier id_it_crlStatusList;
    public static DerObjectIdentifier id_it_crls;
    public static DerObjectIdentifier id_pkip;
    public static DerObjectIdentifier id_regCtrl;
    public static DerObjectIdentifier id_regInfo;
    public static DerObjectIdentifier regCtrl_regToken;
    public static DerObjectIdentifier regCtrl_authenticator;
    public static DerObjectIdentifier regCtrl_pkiPublicationInfo;
    public static DerObjectIdentifier regCtrl_pkiArchiveOptions;
    public static DerObjectIdentifier regCtrl_oldCertID;
    public static DerObjectIdentifier regCtrl_protocolEncrKey;
    public static DerObjectIdentifier regCtrl_altCertTemplate;
    public static DerObjectIdentifier regInfo_utf8Pairs;
    public static DerObjectIdentifier regInfo_certReq;
    public static DerObjectIdentifier ct_encKeyWithID;
    public static DerObjectIdentifier id_regCtrl_algId;
    public static DerObjectIdentifier id_regCtrl_rsaKeyLen;
    private static CmpObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Cmp.CrlAnnContent : Asn1Encodable {
    private Asn1Sequence m_content;
    private CrlAnnContent(Asn1Sequence seq);
    public CrlAnnContent(CertificateList crl);
    public static CrlAnnContent GetInstance(object obj);
    public static CrlAnnContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CertificateList[] ToCertificateListArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CrlSource : Asn1Encodable {
    private DistributionPointName m_dpn;
    private GeneralNames m_issuer;
    public DistributionPointName Dpn { get; }
    public GeneralNames Issuer { get; }
    private CrlSource(Asn1TaggedObject taggedObject);
    public CrlSource(DistributionPointName dpn, GeneralNames issuer);
    public static CrlSource GetInstance(object obj);
    public static CrlSource GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual DistributionPointName get_Dpn();
    public virtual GeneralNames get_Issuer();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CrlStatus : Asn1Encodable {
    private CrlSource m_source;
    private Time m_thisUpdate;
    public CrlSource Source { get; }
    public Time ThisUpdate { get; }
    private CrlStatus(Asn1Sequence sequence);
    public CrlStatus(CrlSource source, Time thisUpdate);
    public static CrlStatus GetInstance(object obj);
    public static CrlStatus GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CrlSource get_Source();
    public virtual Time get_ThisUpdate();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.DhbmParameter : Asn1Encodable {
    private AlgorithmIdentifier m_owf;
    private AlgorithmIdentifier m_mac;
    public AlgorithmIdentifier Owf { get; }
    public AlgorithmIdentifier Mac { get; }
    private DhbmParameter(Asn1Sequence sequence);
    public DhbmParameter(AlgorithmIdentifier owf, AlgorithmIdentifier mac);
    public static DhbmParameter GetInstance(object obj);
    public static DhbmParameter GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual AlgorithmIdentifier get_Owf();
    public virtual AlgorithmIdentifier get_Mac();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.ErrorMsgContent : Asn1Encodable {
    private PkiStatusInfo m_pkiStatusInfo;
    private DerInteger m_errorCode;
    private PkiFreeText m_errorDetails;
    public PkiStatusInfo PkiStatusInfo { get; }
    public DerInteger ErrorCode { get; }
    public PkiFreeText ErrorDetails { get; }
    private ErrorMsgContent(Asn1Sequence seq);
    public ErrorMsgContent(PkiStatusInfo pkiStatusInfo);
    public ErrorMsgContent(PkiStatusInfo pkiStatusInfo, DerInteger errorCode, PkiFreeText errorDetails);
    public static ErrorMsgContent GetInstance(object obj);
    public static ErrorMsgContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual PkiStatusInfo get_PkiStatusInfo();
    public virtual DerInteger get_ErrorCode();
    public virtual PkiFreeText get_ErrorDetails();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.GenMsgContent : Asn1Encodable {
    private Asn1Sequence m_content;
    private GenMsgContent(Asn1Sequence seq);
    public GenMsgContent(InfoTypeAndValue itv);
    public GenMsgContent(InfoTypeAndValue[] itvs);
    public static GenMsgContent GetInstance(object obj);
    public static GenMsgContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual InfoTypeAndValue[] ToInfoTypeAndValueArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.GenRepContent : Asn1Encodable {
    private Asn1Sequence m_content;
    private GenRepContent(Asn1Sequence seq);
    public GenRepContent(InfoTypeAndValue itv);
    public GenRepContent(InfoTypeAndValue[] itvs);
    public static GenRepContent GetInstance(object obj);
    public static GenRepContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual InfoTypeAndValue[] ToInfoTypeAndValueArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue : Asn1Encodable {
    private DerObjectIdentifier m_infoType;
    private Asn1Encodable m_infoValue;
    public DerObjectIdentifier InfoType { get; }
    public Asn1Encodable InfoValue { get; }
    private InfoTypeAndValue(Asn1Sequence seq);
    public InfoTypeAndValue(DerObjectIdentifier infoType);
    public InfoTypeAndValue(DerObjectIdentifier infoType, Asn1Encodable infoValue);
    public static InfoTypeAndValue GetInstance(object obj);
    public static InfoTypeAndValue GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual DerObjectIdentifier get_InfoType();
    public virtual Asn1Encodable get_InfoValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.KeyRecRepContent : Asn1Encodable {
    private PkiStatusInfo m_status;
    private CmpCertificate m_newSigCert;
    private Asn1Sequence m_caCerts;
    private Asn1Sequence m_keyPairHist;
    public PkiStatusInfo Status { get; }
    public CmpCertificate NewSigCert { get; }
    private KeyRecRepContent(Asn1Sequence seq);
    public static KeyRecRepContent GetInstance(object obj);
    public static KeyRecRepContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual PkiStatusInfo get_Status();
    public virtual CmpCertificate get_NewSigCert();
    public virtual CmpCertificate[] GetCACerts();
    public virtual CertifiedKeyPair[] GetKeyPairHist();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.NestedMessageContent : PkiMessages {
    public NestedMessageContent(PkiMessage msg);
    public NestedMessageContent(PkiMessage[] msgs);
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public NestedMessageContent(Asn1Sequence seq);
    internal NestedMessageContent(PkiMessages other);
    public static NestedMessageContent GetInstance(object obj);
    public static NestedMessageContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
}
public class Org.BouncyCastle.Asn1.Cmp.OobCert : CmpCertificate {
    [ObsoleteAttribute("Use constructor from Asn1TaggedObject instead")]
public OobCert(int type, Asn1Encodable otherCert);
    internal OobCert(Asn1TaggedObject taggedObject);
    internal OobCert(CmpCertificate other);
    public OobCert(X509CertificateStructure x509v3PKCert);
    public static OobCert GetInstance(object obj);
    public static OobCert GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
}
public class Org.BouncyCastle.Asn1.Cmp.OobCertHash : Asn1Encodable {
    private AlgorithmIdentifier m_hashAlg;
    private CertId m_certId;
    private DerBitString m_hashVal;
    public CertId CertID { get; }
    public AlgorithmIdentifier HashAlg { get; }
    public DerBitString HashVal { get; }
    private OobCertHash(Asn1Sequence seq);
    public static OobCertHash GetInstance(object obj);
    public static OobCertHash GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CertId get_CertID();
    public virtual AlgorithmIdentifier get_HashAlg();
    public virtual DerBitString get_HashVal();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PbmParameter : Asn1Encodable {
    private Asn1OctetString m_salt;
    private AlgorithmIdentifier m_owf;
    private DerInteger m_iterationCount;
    private AlgorithmIdentifier m_mac;
    public DerInteger IterationCount { get; }
    public AlgorithmIdentifier Mac { get; }
    public AlgorithmIdentifier Owf { get; }
    public Asn1OctetString Salt { get; }
    private PbmParameter(Asn1Sequence seq);
    public PbmParameter(Byte[] salt, AlgorithmIdentifier owf, int iterationCount, AlgorithmIdentifier mac);
    public PbmParameter(Asn1OctetString salt, AlgorithmIdentifier owf, DerInteger iterationCount, AlgorithmIdentifier mac);
    public static PbmParameter GetInstance(object obj);
    public static PbmParameter GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual DerInteger get_IterationCount();
    public virtual AlgorithmIdentifier get_Mac();
    public virtual AlgorithmIdentifier get_Owf();
    public virtual Asn1OctetString get_Salt();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiBody : Asn1Encodable {
    public static int TYPE_INIT_REQ;
    public static int TYPE_INIT_REP;
    public static int TYPE_CERT_REQ;
    public static int TYPE_CERT_REP;
    public static int TYPE_P10_CERT_REQ;
    public static int TYPE_POPO_CHALL;
    public static int TYPE_POPO_REP;
    public static int TYPE_KEY_UPDATE_REQ;
    public static int TYPE_KEY_UPDATE_REP;
    public static int TYPE_KEY_RECOVERY_REQ;
    public static int TYPE_KEY_RECOVERY_REP;
    public static int TYPE_REVOCATION_REQ;
    public static int TYPE_REVOCATION_REP;
    public static int TYPE_CROSS_CERT_REQ;
    public static int TYPE_CROSS_CERT_REP;
    public static int TYPE_CA_KEY_UPDATE_ANN;
    public static int TYPE_CERT_ANN;
    public static int TYPE_REVOCATION_ANN;
    public static int TYPE_CRL_ANN;
    public static int TYPE_CONFIRM;
    public static int TYPE_NESTED;
    public static int TYPE_GEN_MSG;
    public static int TYPE_GEN_REP;
    public static int TYPE_ERROR;
    public static int TYPE_CERT_CONFIRM;
    public static int TYPE_POLL_REQ;
    public static int TYPE_POLL_REP;
    private int m_tagNo;
    private Asn1Encodable m_body;
    public Asn1Encodable Content { get; }
    public int Type { get; }
    private PkiBody(Asn1TaggedObject taggedObject);
    public PkiBody(int type, Asn1Encodable content);
    public static PkiBody GetInstance(object obj);
    public static PkiBody GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    private static Asn1Encodable GetBodyForType(int type, Asn1Encodable o);
    public virtual Asn1Encodable get_Content();
    public virtual int get_Type();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiConfirmContent : Asn1Encodable {
    private Asn1Null m_val;
    private PkiConfirmContent(Asn1Null val);
    public static PkiConfirmContent GetInstance(object obj);
    public static PkiConfirmContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo : DerBitString {
    public static int BadAlg;
    public static int BadMessageCheck;
    public static int BadRequest;
    public static int BadTime;
    public static int BadCertId;
    public static int BadDataFormat;
    public static int WrongAuthority;
    public static int IncorrectData;
    public static int MissingTimeStamp;
    public static int BadPop;
    public static int CertRevoked;
    public static int CertConfirmed;
    public static int WrongIntegrity;
    public static int BadRecipientNonce;
    public static int TimeNotAvailable;
    public static int UnacceptedPolicy;
    public static int UnacceptedExtension;
    public static int AddInfoNotAvailable;
    public static int BadSenderNonce;
    public static int BadCertTemplate;
    public static int SignerNotTrusted;
    public static int TransactionIdInUse;
    public static int UnsupportedVersion;
    public static int NotAuthorized;
    public static int SystemUnavail;
    public static int SystemFailure;
    public static int DuplicateCertReq;
    public PkiFailureInfo(int info);
    public PkiFailureInfo(DerBitString info);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Cmp.PkiFreeText : Asn1Encodable {
    private Asn1Sequence m_strings;
    public int Count { get; }
    public DerUtf8String Item { get; }
    internal PkiFreeText(Asn1Sequence seq);
    public PkiFreeText(DerUtf8String p);
    public PkiFreeText(string p);
    public PkiFreeText(DerUtf8String[] strs);
    public PkiFreeText(String[] strs);
    public static PkiFreeText GetInstance(object obj);
    public static PkiFreeText GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual int get_Count();
    public DerUtf8String get_Item(int index);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiHeader : Asn1Encodable {
    public static GeneralName NULL_NAME;
    public static int CMP_1999;
    public static int CMP_2000;
    private DerInteger pvno;
    private GeneralName sender;
    private GeneralName recipient;
    private Asn1GeneralizedTime messageTime;
    private AlgorithmIdentifier protectionAlg;
    private Asn1OctetString senderKID;
    private Asn1OctetString recipKID;
    private Asn1OctetString transactionID;
    private Asn1OctetString senderNonce;
    private Asn1OctetString recipNonce;
    private PkiFreeText freeText;
    private Asn1Sequence generalInfo;
    public DerInteger Pvno { get; }
    public GeneralName Sender { get; }
    public GeneralName Recipient { get; }
    public Asn1GeneralizedTime MessageTime { get; }
    public AlgorithmIdentifier ProtectionAlg { get; }
    public Asn1OctetString SenderKID { get; }
    public Asn1OctetString RecipKID { get; }
    public Asn1OctetString TransactionID { get; }
    public Asn1OctetString SenderNonce { get; }
    public Asn1OctetString RecipNonce { get; }
    public PkiFreeText FreeText { get; }
    private PkiHeader(Asn1Sequence seq);
    public PkiHeader(int pvno, GeneralName sender, GeneralName recipient);
    private PkiHeader(DerInteger pvno, GeneralName sender, GeneralName recipient);
    private static PkiHeader();
    public static PkiHeader GetInstance(object obj);
    public static PkiHeader GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual DerInteger get_Pvno();
    public virtual GeneralName get_Sender();
    public virtual GeneralName get_Recipient();
    public virtual Asn1GeneralizedTime get_MessageTime();
    public virtual AlgorithmIdentifier get_ProtectionAlg();
    public virtual Asn1OctetString get_SenderKID();
    public virtual Asn1OctetString get_RecipKID();
    public virtual Asn1OctetString get_TransactionID();
    public virtual Asn1OctetString get_SenderNonce();
    public virtual Asn1OctetString get_RecipNonce();
    public virtual PkiFreeText get_FreeText();
    public virtual InfoTypeAndValue[] GetGeneralInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiHeaderBuilder : object {
    private DerInteger pvno;
    private GeneralName sender;
    private GeneralName recipient;
    private Asn1GeneralizedTime messageTime;
    private AlgorithmIdentifier protectionAlg;
    private Asn1OctetString senderKID;
    private Asn1OctetString recipKID;
    private Asn1OctetString transactionID;
    private Asn1OctetString senderNonce;
    private Asn1OctetString recipNonce;
    private PkiFreeText freeText;
    private Asn1Sequence generalInfo;
    public PkiHeaderBuilder(int pvno, GeneralName sender, GeneralName recipient);
    private PkiHeaderBuilder(DerInteger pvno, GeneralName sender, GeneralName recipient);
    public virtual PkiHeaderBuilder SetMessageTime(Asn1GeneralizedTime time);
    public virtual PkiHeaderBuilder SetProtectionAlg(AlgorithmIdentifier aid);
    public virtual PkiHeaderBuilder SetSenderKID(Byte[] kid);
    public virtual PkiHeaderBuilder SetSenderKID(Asn1OctetString kid);
    public virtual PkiHeaderBuilder SetRecipKID(Byte[] kid);
    public virtual PkiHeaderBuilder SetRecipKID(Asn1OctetString kid);
    public virtual PkiHeaderBuilder SetTransactionID(Byte[] tid);
    public virtual PkiHeaderBuilder SetTransactionID(Asn1OctetString tid);
    public virtual PkiHeaderBuilder SetSenderNonce(Byte[] nonce);
    public virtual PkiHeaderBuilder SetSenderNonce(Asn1OctetString nonce);
    public virtual PkiHeaderBuilder SetRecipNonce(Byte[] nonce);
    public virtual PkiHeaderBuilder SetRecipNonce(Asn1OctetString nonce);
    public virtual PkiHeaderBuilder SetFreeText(PkiFreeText text);
    public virtual PkiHeaderBuilder SetGeneralInfo(InfoTypeAndValue genInfo);
    public virtual PkiHeaderBuilder SetGeneralInfo(InfoTypeAndValue[] genInfos);
    public virtual PkiHeaderBuilder SetGeneralInfo(Asn1Sequence seqOfInfoTypeAndValue);
    private static Asn1Sequence MakeGeneralInfoSeq(InfoTypeAndValue generalInfo);
    private static Asn1Sequence MakeGeneralInfoSeq(InfoTypeAndValue[] generalInfos);
    public virtual PkiHeader Build();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiMessage : Asn1Encodable {
    private PkiHeader header;
    private PkiBody body;
    private DerBitString protection;
    private Asn1Sequence extraCerts;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    public DerBitString Protection { get; }
    private PkiMessage(Asn1Sequence seq);
    public PkiMessage(PkiHeader header, PkiBody body, DerBitString protection, CmpCertificate[] extraCerts);
    public PkiMessage(PkiHeader header, PkiBody body, DerBitString protection);
    public PkiMessage(PkiHeader header, PkiBody body);
    public static PkiMessage GetInstance(object obj);
    public static PkiMessage GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual PkiHeader get_Header();
    public virtual PkiBody get_Body();
    public virtual DerBitString get_Protection();
    public virtual CmpCertificate[] GetExtraCerts();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiMessages : Asn1Encodable {
    private Asn1Sequence m_content;
    internal PkiMessages(Asn1Sequence seq);
    internal PkiMessages(PkiMessages other);
    public PkiMessages(PkiMessage[] msgs);
    public static PkiMessages GetInstance(object obj);
    public static PkiMessages GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual PkiMessage[] ToPkiMessageArray();
    public virtual Asn1Object ToAsn1Object();
}
public enum Org.BouncyCastle.Asn1.Cmp.PkiStatus : Enum {
    public int value__;
    public static PkiStatus Granted;
    public static PkiStatus GrantedWithMods;
    public static PkiStatus Rejection;
    public static PkiStatus Waiting;
    public static PkiStatus RevocationWarning;
    public static PkiStatus RevocationNotification;
    public static PkiStatus KeyUpdateWarning;
}
public class Org.BouncyCastle.Asn1.Cmp.PkiStatusEncodable : Asn1Encodable {
    public static PkiStatusEncodable granted;
    public static PkiStatusEncodable grantedWithMods;
    public static PkiStatusEncodable rejection;
    public static PkiStatusEncodable waiting;
    public static PkiStatusEncodable revocationWarning;
    public static PkiStatusEncodable revocationNotification;
    public static PkiStatusEncodable keyUpdateWaiting;
    private DerInteger status;
    public BigInteger Value { get; }
    private PkiStatusEncodable(PkiStatus status);
    private PkiStatusEncodable(DerInteger status);
    private static PkiStatusEncodable();
    public static PkiStatusEncodable GetInstance(object obj);
    public static PkiStatusEncodable GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual BigInteger get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo : Asn1Encodable {
    private DerInteger status;
    private PkiFreeText statusString;
    private DerBitString failInfo;
    public BigInteger Status { get; }
    public PkiFreeText StatusString { get; }
    public DerBitString FailInfo { get; }
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public PkiStatusInfo(Asn1Sequence seq);
    public PkiStatusInfo(int status);
    public PkiStatusInfo(int status, PkiFreeText statusString);
    public PkiStatusInfo(int status, PkiFreeText statusString, PkiFailureInfo failInfo);
    public static PkiStatusInfo GetInstance(object obj);
    public static PkiStatusInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public BigInteger get_Status();
    public PkiFreeText get_StatusString();
    public DerBitString get_FailInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PollRepContent : Asn1Encodable {
    private DerInteger[] m_certReqID;
    private DerInteger[] m_checkAfter;
    private PkiFreeText[] m_reason;
    public int Count { get; }
    private PollRepContent(Asn1Sequence seq);
    public PollRepContent(DerInteger certReqID, DerInteger checkAfter);
    public PollRepContent(DerInteger certReqID, DerInteger checkAfter, PkiFreeText reason);
    public static PollRepContent GetInstance(object obj);
    public static PollRepContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual int get_Count();
    public virtual DerInteger GetCertReqID(int index);
    public virtual DerInteger GetCheckAfter(int index);
    public virtual PkiFreeText GetReason(int index);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PollReqContent : Asn1Encodable {
    private Asn1Sequence m_content;
    private PollReqContent(Asn1Sequence seq);
    public PollReqContent(DerInteger certReqId);
    public PollReqContent(DerInteger[] certReqIds);
    public PollReqContent(BigInteger certReqId);
    public PollReqContent(BigInteger[] certReqIds);
    public static PollReqContent GetInstance(object obj);
    public static PollReqContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual DerInteger[][] GetCertReqIDs();
    public virtual BigInteger[] GetCertReqIDValues();
    public virtual Asn1Object ToAsn1Object();
    private static DerSequence[] IntsToSequence(DerInteger[] ids);
    private static DerInteger[] IntsToAsn1(BigInteger[] ids);
}
public class Org.BouncyCastle.Asn1.Cmp.PopoDecKeyChallContent : Asn1Encodable {
    private Asn1Sequence m_content;
    private PopoDecKeyChallContent(Asn1Sequence seq);
    public static PopoDecKeyChallContent GetInstance(object obj);
    public static PopoDecKeyChallContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual Challenge[] ToChallengeArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PopoDecKeyRespContent : Asn1Encodable {
    private Asn1Sequence m_content;
    private PopoDecKeyRespContent(Asn1Sequence seq);
    public static PopoDecKeyRespContent GetInstance(object obj);
    public static PopoDecKeyRespContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual DerInteger[] ToIntegerArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.ProtectedPart : Asn1Encodable {
    private PkiHeader m_header;
    private PkiBody m_body;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    private ProtectedPart(Asn1Sequence seq);
    public ProtectedPart(PkiHeader header, PkiBody body);
    public static ProtectedPart GetInstance(object obj);
    public static ProtectedPart GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual PkiHeader get_Header();
    public virtual PkiBody get_Body();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevAnnContent : Asn1Encodable {
    private PkiStatusEncodable m_status;
    private CertId m_certID;
    private Asn1GeneralizedTime m_willBeRevokedAt;
    private Asn1GeneralizedTime m_badSinceDate;
    private X509Extensions m_crlDetails;
    public PkiStatusEncodable Status { get; }
    public CertId CertID { get; }
    public Asn1GeneralizedTime WillBeRevokedAt { get; }
    public Asn1GeneralizedTime BadSinceDate { get; }
    public X509Extensions CrlDetails { get; }
    public RevAnnContent(PkiStatusEncodable status, CertId certID, Asn1GeneralizedTime willBeRevokedAt, Asn1GeneralizedTime badSinceDate);
    public RevAnnContent(PkiStatusEncodable status, CertId certID, Asn1GeneralizedTime willBeRevokedAt, Asn1GeneralizedTime badSinceDate, X509Extensions crlDetails);
    private RevAnnContent(Asn1Sequence seq);
    public static RevAnnContent GetInstance(object obj);
    public static RevAnnContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual PkiStatusEncodable get_Status();
    public virtual CertId get_CertID();
    public virtual Asn1GeneralizedTime get_WillBeRevokedAt();
    public virtual Asn1GeneralizedTime get_BadSinceDate();
    public virtual X509Extensions get_CrlDetails();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevDetails : Asn1Encodable {
    private CertTemplate m_certDetails;
    private X509Extensions m_crlEntryDetails;
    public CertTemplate CertDetails { get; }
    public X509Extensions CrlEntryDetails { get; }
    private RevDetails(Asn1Sequence seq);
    public RevDetails(CertTemplate certDetails);
    public RevDetails(CertTemplate certDetails, X509Extensions crlEntryDetails);
    public static RevDetails GetInstance(object obj);
    public static RevDetails GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CertTemplate get_CertDetails();
    public virtual X509Extensions get_CrlEntryDetails();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevRepContent : Asn1Encodable {
    private Asn1Sequence m_status;
    private Asn1Sequence m_revCerts;
    private Asn1Sequence m_crls;
    private RevRepContent(Asn1Sequence seq);
    public static RevRepContent GetInstance(object obj);
    public static RevRepContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual PkiStatusInfo[] GetStatus();
    public virtual CertId[] GetRevCerts();
    public virtual CertificateList[] GetCrls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevRepContentBuilder : object {
    private Asn1EncodableVector m_status;
    private Asn1EncodableVector m_revCerts;
    private Asn1EncodableVector m_crls;
    public virtual RevRepContentBuilder Add(PkiStatusInfo status);
    public virtual RevRepContentBuilder Add(PkiStatusInfo status, CertId certId);
    public virtual RevRepContentBuilder AddCrl(CertificateList crl);
    public virtual RevRepContent Build();
}
public class Org.BouncyCastle.Asn1.Cmp.RevReqContent : Asn1Encodable {
    private Asn1Sequence m_content;
    private RevReqContent(Asn1Sequence seq);
    public RevReqContent(RevDetails revDetails);
    public RevReqContent(RevDetails[] revDetailsArray);
    public static RevReqContent GetInstance(object obj);
    public static RevReqContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual RevDetails[] ToRevDetailsArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RootCaKeyUpdateContent : Asn1Encodable {
    private CmpCertificate m_newWithNew;
    private CmpCertificate m_newWithOld;
    private CmpCertificate m_oldWithNew;
    public CmpCertificate NewWithNew { get; }
    public CmpCertificate NewWithOld { get; }
    public CmpCertificate OldWithNew { get; }
    public RootCaKeyUpdateContent(CmpCertificate newWithNew, CmpCertificate newWithOld, CmpCertificate oldWithNew);
    private RootCaKeyUpdateContent(Asn1Sequence seq);
    public static RootCaKeyUpdateContent GetInstance(object obj);
    public static RootCaKeyUpdateContent GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual CmpCertificate get_NewWithNew();
    public virtual CmpCertificate get_NewWithOld();
    public virtual CmpCertificate get_OldWithNew();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Attribute : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    public Attribute(Asn1Sequence seq);
    public Attribute(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static Attribute GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Attributes : Asn1Encodable {
    private Asn1Set attributes;
    private Attributes(Asn1Set attributes);
    public Attributes(Asn1EncodableVector v);
    public static Attributes GetInstance(object obj);
    public virtual Attribute[] GetAttributes();
    public virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Cms.AttributeTable : object {
    private Dictionary`2<DerObjectIdentifier, object> m_attributes;
    public Attribute Item { get; }
    public int Count { get; }
    public AttributeTable(IDictionary`2<DerObjectIdentifier, object> attrs);
    public AttributeTable(Asn1EncodableVector v);
    public AttributeTable(Asn1Set s);
    public AttributeTable(Attributes attrs);
    private void AddAttribute(Attribute a);
    public Attribute get_Item(DerObjectIdentifier oid);
    public Asn1EncodableVector GetAll(DerObjectIdentifier oid);
    public int get_Count();
    public IDictionary`2<DerObjectIdentifier, object> ToDictionary();
    public Asn1EncodableVector ToAsn1EncodableVector();
    public Attributes ToAttributes();
    public AttributeTable Add(Attribute[] attributes);
    public AttributeTable Add(DerObjectIdentifier attrType, Asn1Encodable attrValue);
    public AttributeTable Remove(DerObjectIdentifier attrType);
}
public class Org.BouncyCastle.Asn1.Cms.AuthenticatedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private AlgorithmIdentifier macAlgorithm;
    private AlgorithmIdentifier digestAlgorithm;
    private ContentInfo encapsulatedContentInfo;
    private Asn1Set authAttrs;
    private Asn1OctetString mac;
    private Asn1Set unauthAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public AlgorithmIdentifier MacAlgorithm { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public ContentInfo EncapsulatedContentInfo { get; }
    public Asn1Set AuthAttrs { get; }
    public Asn1OctetString Mac { get; }
    public Asn1Set UnauthAttrs { get; }
    public AuthenticatedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, AlgorithmIdentifier macAlgorithm, AlgorithmIdentifier digestAlgorithm, ContentInfo encapsulatedContent, Asn1Set authAttrs, Asn1OctetString mac, Asn1Set unauthAttrs);
    private AuthenticatedData(Asn1Sequence seq);
    public static AuthenticatedData GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AuthenticatedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public AlgorithmIdentifier get_MacAlgorithm();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public ContentInfo get_EncapsulatedContentInfo();
    public Asn1Set get_AuthAttrs();
    public Asn1OctetString get_Mac();
    public Asn1Set get_UnauthAttrs();
    public virtual Asn1Object ToAsn1Object();
    public static int CalculateVersion(OriginatorInfo origInfo);
}
public class Org.BouncyCastle.Asn1.Cms.AuthenticatedDataParser : object {
    private Asn1SequenceParser seq;
    private DerInteger version;
    private IAsn1Convertible nextObject;
    private bool originatorInfoCalled;
    public DerInteger Version { get; }
    public AuthenticatedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public AlgorithmIdentifier GetMacAlgorithm();
    public AlgorithmIdentifier GetDigestAlgorithm();
    public ContentInfoParser GetEnapsulatedContentInfo();
    public Asn1SetParser GetAuthAttrs();
    public Asn1OctetString GetMac();
    public Asn1SetParser GetUnauthAttrs();
}
public class Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private EncryptedContentInfo authEncryptedContentInfo;
    private Asn1Set authAttrs;
    private Asn1OctetString mac;
    private Asn1Set unauthAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public EncryptedContentInfo AuthEncryptedContentInfo { get; }
    public Asn1Set AuthAttrs { get; }
    public Asn1OctetString Mac { get; }
    public Asn1Set UnauthAttrs { get; }
    public AuthEnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo authEncryptedContentInfo, Asn1Set authAttrs, Asn1OctetString mac, Asn1Set unauthAttrs);
    private AuthEnvelopedData(Asn1Sequence seq);
    public static AuthEnvelopedData GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AuthEnvelopedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public EncryptedContentInfo get_AuthEncryptedContentInfo();
    public Asn1Set get_AuthAttrs();
    public Asn1OctetString get_Mac();
    public Asn1Set get_UnauthAttrs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.AuthEnvelopedDataParser : object {
    private Asn1SequenceParser seq;
    private DerInteger version;
    private IAsn1Convertible nextObject;
    private bool originatorInfoCalled;
    private bool isData;
    public DerInteger Version { get; }
    public AuthEnvelopedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public EncryptedContentInfoParser GetAuthEncryptedContentInfo();
    public Asn1SetParser GetAuthAttrs();
    public Asn1OctetString GetMac();
    public Asn1SetParser GetUnauthAttrs();
}
public class Org.BouncyCastle.Asn1.Cms.CcmParameters : Asn1Encodable {
    private static int DefaultIcvLen;
    private Byte[] m_nonce;
    private int m_icvLen;
    public int IcvLen { get; }
    private CcmParameters(Asn1Sequence seq);
    public CcmParameters(Byte[] nonce, int icvLen);
    public static CcmParameters GetInstance(object obj);
    public static CcmParameters GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public Byte[] GetNonce();
    public int get_IcvLen();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.CmsAlgorithmProtection : Asn1Encodable {
    public static int Signature;
    public static int Mac;
    private AlgorithmIdentifier digestAlgorithm;
    private AlgorithmIdentifier signatureAlgorithm;
    private AlgorithmIdentifier macAlgorithm;
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public AlgorithmIdentifier MacAlgorithm { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public CmsAlgorithmProtection(AlgorithmIdentifier digestAlgorithm, int type, AlgorithmIdentifier algorithmIdentifier);
    private CmsAlgorithmProtection(Asn1Sequence sequence);
    private static CmsAlgorithmProtection();
    public static CmsAlgorithmProtection GetInstance(object obj);
    public AlgorithmIdentifier get_DigestAlgorithm();
    public AlgorithmIdentifier get_MacAlgorithm();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Cms.CmsAttributes : object {
    public static DerObjectIdentifier ContentType;
    public static DerObjectIdentifier MessageDigest;
    public static DerObjectIdentifier SigningTime;
    public static DerObjectIdentifier CounterSignature;
    public static DerObjectIdentifier ContentHint;
    public static DerObjectIdentifier CmsAlgorithmProtect;
    private static CmsAttributes();
}
public abstract class Org.BouncyCastle.Asn1.Cms.CmsObjectIdentifiers : object {
    public static DerObjectIdentifier Data;
    public static DerObjectIdentifier SignedData;
    public static DerObjectIdentifier EnvelopedData;
    public static DerObjectIdentifier SignedAndEnvelopedData;
    public static DerObjectIdentifier DigestedData;
    public static DerObjectIdentifier EncryptedData;
    public static DerObjectIdentifier AuthenticatedData;
    public static DerObjectIdentifier CompressedData;
    public static DerObjectIdentifier AuthEnvelopedData;
    public static DerObjectIdentifier TimestampedData;
    public static DerObjectIdentifier ZlibCompress;
    public static DerObjectIdentifier id_ri;
    public static DerObjectIdentifier id_ri_ocsp_response;
    public static DerObjectIdentifier id_ri_scvp;
    private static CmsObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Cms.CompressedData : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier compressionAlgorithm;
    private ContentInfo encapContentInfo;
    public DerInteger Version { get; }
    public AlgorithmIdentifier CompressionAlgorithmIdentifier { get; }
    public ContentInfo EncapContentInfo { get; }
    public CompressedData(AlgorithmIdentifier compressionAlgorithm, ContentInfo encapContentInfo);
    public CompressedData(Asn1Sequence seq);
    public static CompressedData GetInstance(Asn1TaggedObject ato, bool explicitly);
    public static CompressedData GetInstance(object obj);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_CompressionAlgorithmIdentifier();
    public ContentInfo get_EncapContentInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.CompressedDataParser : object {
    private DerInteger _version;
    private AlgorithmIdentifier _compressionAlgorithm;
    private ContentInfoParser _encapContentInfo;
    public DerInteger Version { get; }
    public AlgorithmIdentifier CompressionAlgorithmIdentifier { get; }
    public CompressedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_CompressionAlgorithmIdentifier();
    public ContentInfoParser GetEncapContentInfo();
}
public class Org.BouncyCastle.Asn1.Cms.ContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private Asn1Encodable content;
    public DerObjectIdentifier ContentType { get; }
    public Asn1Encodable Content { get; }
    private ContentInfo(Asn1Sequence seq);
    public ContentInfo(DerObjectIdentifier contentType, Asn1Encodable content);
    public static ContentInfo GetInstance(object obj);
    public static ContentInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public DerObjectIdentifier get_ContentType();
    public Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.ContentInfoParser : object {
    private DerObjectIdentifier m_contentType;
    private Asn1TaggedObjectParser m_content;
    public DerObjectIdentifier ContentType { get; }
    public ContentInfoParser(Asn1SequenceParser seq);
    public DerObjectIdentifier get_ContentType();
    public IAsn1Convertible GetContent(int tag);
}
public class Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial : Asn1Encodable {
    private OriginatorPublicKey ephemeralPublicKey;
    private Asn1OctetString addedukm;
    public OriginatorPublicKey EphemeralPublicKey { get; }
    public Asn1OctetString AddedUkm { get; }
    public MQVuserKeyingMaterial(OriginatorPublicKey ephemeralPublicKey, Asn1OctetString addedukm);
    private MQVuserKeyingMaterial(Asn1Sequence seq);
    public static MQVuserKeyingMaterial GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static MQVuserKeyingMaterial GetInstance(object obj);
    public OriginatorPublicKey get_EphemeralPublicKey();
    public Asn1OctetString get_AddedUkm();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private AlgorithmIdentifier contentEncryptionAlgorithm;
    private Asn1OctetString encryptedContent;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedContent { get; }
    public EncryptedContentInfo(DerObjectIdentifier contentType, AlgorithmIdentifier contentEncryptionAlgorithm, Asn1OctetString encryptedContent);
    public EncryptedContentInfo(Asn1Sequence seq);
    public static EncryptedContentInfo GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedContent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedContentInfoParser : object {
    private DerObjectIdentifier m_contentType;
    private AlgorithmIdentifier m_contentEncryptionAlgorithm;
    private Asn1TaggedObjectParser m_encryptedContent;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
    public EncryptedContentInfoParser(Asn1SequenceParser seq);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    public IAsn1Convertible GetEncryptedContent(int tag);
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedData : Asn1Encodable {
    private DerInteger version;
    private EncryptedContentInfo encryptedContentInfo;
    private Asn1Set unprotectedAttrs;
    public DerInteger Version { get; }
    public EncryptedContentInfo EncryptedContentInfo { get; }
    public Asn1Set UnprotectedAttrs { get; }
    public EncryptedData(EncryptedContentInfo encInfo);
    public EncryptedData(EncryptedContentInfo encInfo, Asn1Set unprotectedAttrs);
    private EncryptedData(Asn1Sequence seq);
    public static EncryptedData GetInstance(object obj);
    public virtual DerInteger get_Version();
    public virtual EncryptedContentInfo get_EncryptedContentInfo();
    public virtual Asn1Set get_UnprotectedAttrs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EnvelopedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private EncryptedContentInfo encryptedContentInfo;
    private Asn1Set unprotectedAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public EncryptedContentInfo EncryptedContentInfo { get; }
    public Asn1Set UnprotectedAttrs { get; }
    public EnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo encryptedContentInfo, Asn1Set unprotectedAttrs);
    public EnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo encryptedContentInfo, Attributes unprotectedAttrs);
    private EnvelopedData(Asn1Sequence seq);
    public static EnvelopedData GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static EnvelopedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public EncryptedContentInfo get_EncryptedContentInfo();
    public Asn1Set get_UnprotectedAttrs();
    public virtual Asn1Object ToAsn1Object();
    public static int CalculateVersion(OriginatorInfo originatorInfo, Asn1Set recipientInfos, Asn1Set unprotectedAttrs);
}
public class Org.BouncyCastle.Asn1.Cms.EnvelopedDataParser : object {
    private Asn1SequenceParser _seq;
    private DerInteger _version;
    private IAsn1Convertible _nextObject;
    private bool _originatorInfoCalled;
    public DerInteger Version { get; }
    public EnvelopedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public EncryptedContentInfoParser GetEncryptedContentInfo();
    public Asn1SetParser GetUnprotectedAttrs();
}
public class Org.BouncyCastle.Asn1.Cms.Evidence : Asn1Encodable {
    private TimeStampTokenEvidence tstEvidence;
    private Asn1Sequence otherEvidence;
    public TimeStampTokenEvidence TstEvidence { get; }
    public Evidence(TimeStampTokenEvidence tstEvidence);
    private Evidence(Asn1TaggedObject tagged);
    public static Evidence GetInstance(object obj);
    public static Evidence GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual TimeStampTokenEvidence get_TstEvidence();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.GcmParameters : Asn1Encodable {
    private static int DefaultIcvLen;
    private Byte[] m_nonce;
    private int m_icvLen;
    public int IcvLen { get; }
    private GcmParameters(Asn1Sequence seq);
    public GcmParameters(Byte[] nonce, int icvLen);
    public static GcmParameters GetInstance(object obj);
    public static GcmParameters GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public Byte[] GetNonce();
    public int get_IcvLen();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.IssuerAndSerialNumber : Asn1Encodable {
    private X509Name name;
    private DerInteger serialNumber;
    public X509Name Name { get; }
    public DerInteger SerialNumber { get; }
    private IssuerAndSerialNumber(Asn1Sequence seq);
    public IssuerAndSerialNumber(X509Name name, BigInteger serialNumber);
    public IssuerAndSerialNumber(X509Name name, DerInteger serialNumber);
    public static IssuerAndSerialNumber GetInstance(object obj);
    public X509Name get_Name();
    public DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KekIdentifier : Asn1Encodable {
    private Asn1OctetString keyIdentifier;
    private Asn1GeneralizedTime date;
    private OtherKeyAttribute other;
    public Asn1OctetString KeyIdentifier { get; }
    public Asn1GeneralizedTime Date { get; }
    public OtherKeyAttribute Other { get; }
    public KekIdentifier(Byte[] keyIdentifier, Asn1GeneralizedTime date, OtherKeyAttribute other);
    public KekIdentifier(Asn1Sequence seq);
    public static KekIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KekIdentifier GetInstance(object obj);
    public Asn1OctetString get_KeyIdentifier();
    public Asn1GeneralizedTime get_Date();
    public OtherKeyAttribute get_Other();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KekRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private KekIdentifier kekID;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public KekIdentifier KekID { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public KekRecipientInfo(KekIdentifier kekID, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public KekRecipientInfo(Asn1Sequence seq);
    public static KekRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KekRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public KekIdentifier get_KekID();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier : Asn1Encodable {
    private IssuerAndSerialNumber issuerSerial;
    private RecipientKeyIdentifier rKeyID;
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public RecipientKeyIdentifier RKeyID { get; }
    public KeyAgreeRecipientIdentifier(IssuerAndSerialNumber issuerSerial);
    public KeyAgreeRecipientIdentifier(RecipientKeyIdentifier rKeyID);
    public static KeyAgreeRecipientIdentifier GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static KeyAgreeRecipientIdentifier GetInstance(object obj);
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public RecipientKeyIdentifier get_RKeyID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private OriginatorIdentifierOrKey originator;
    private Asn1OctetString ukm;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1Sequence recipientEncryptedKeys;
    public DerInteger Version { get; }
    public OriginatorIdentifierOrKey Originator { get; }
    public Asn1OctetString UserKeyingMaterial { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1Sequence RecipientEncryptedKeys { get; }
    public KeyAgreeRecipientInfo(OriginatorIdentifierOrKey originator, Asn1OctetString ukm, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1Sequence recipientEncryptedKeys);
    public KeyAgreeRecipientInfo(Asn1Sequence seq);
    public static KeyAgreeRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KeyAgreeRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorIdentifierOrKey get_Originator();
    public Asn1OctetString get_UserKeyingMaterial();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1Sequence get_RecipientEncryptedKeys();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private RecipientIdentifier rid;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public RecipientIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public KeyTransRecipientInfo(RecipientIdentifier rid, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public KeyTransRecipientInfo(Asn1Sequence seq);
    public static KeyTransRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public RecipientIdentifier get_RecipientIdentifier();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.MetaData : Asn1Encodable {
    private DerBoolean hashProtected;
    private DerUtf8String fileName;
    private DerIA5String mediaType;
    private Attributes otherMetaData;
    public bool IsHashProtected { get; }
    public DerUtf8String FileName { get; }
    public DerIA5String MediaType { get; }
    public Attributes OtherMetaData { get; }
    public MetaData(DerBoolean hashProtected, DerUtf8String fileName, DerIA5String mediaType, Attributes otherMetaData);
    private MetaData(Asn1Sequence seq);
    public static MetaData GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual bool get_IsHashProtected();
    public virtual DerUtf8String get_FileName();
    public virtual DerIA5String get_MediaType();
    public virtual Attributes get_OtherMetaData();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey : Asn1Encodable {
    private Asn1Encodable id;
    public Asn1Encodable ID { get; }
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public SubjectKeyIdentifier SubjectKeyIdentifier { get; }
    public OriginatorPublicKey OriginatorPublicKey { get; }
    public OriginatorIdentifierOrKey(IssuerAndSerialNumber id);
    public OriginatorIdentifierOrKey(SubjectKeyIdentifier id);
    public OriginatorIdentifierOrKey(OriginatorPublicKey id);
    private OriginatorIdentifierOrKey(Asn1TaggedObject id);
    public static OriginatorIdentifierOrKey GetInstance(Asn1TaggedObject o, bool explicitly);
    public static OriginatorIdentifierOrKey GetInstance(object o);
    public Asn1Encodable get_ID();
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public SubjectKeyIdentifier get_SubjectKeyIdentifier();
    public OriginatorPublicKey get_OriginatorPublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorInfo : Asn1Encodable {
    private Asn1Set certs;
    private Asn1Set crls;
    public Asn1Set Certificates { get; }
    public Asn1Set Crls { get; }
    public OriginatorInfo(Asn1Set certs, Asn1Set crls);
    public OriginatorInfo(Asn1Sequence seq);
    public static OriginatorInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OriginatorInfo GetInstance(object obj);
    public Asn1Set get_Certificates();
    public Asn1Set get_Crls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey : Asn1Encodable {
    private AlgorithmIdentifier mAlgorithm;
    private DerBitString mPublicKey;
    public AlgorithmIdentifier Algorithm { get; }
    public DerBitString PublicKey { get; }
    public OriginatorPublicKey(AlgorithmIdentifier algorithm, Byte[] publicKey);
    private OriginatorPublicKey(Asn1Sequence seq);
    public static OriginatorPublicKey GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OriginatorPublicKey GetInstance(object obj);
    public AlgorithmIdentifier get_Algorithm();
    public DerBitString get_PublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute : Asn1Encodable {
    private DerObjectIdentifier keyAttrId;
    private Asn1Encodable keyAttr;
    public DerObjectIdentifier KeyAttrId { get; }
    public Asn1Encodable KeyAttr { get; }
    public OtherKeyAttribute(Asn1Sequence seq);
    public OtherKeyAttribute(DerObjectIdentifier keyAttrId, Asn1Encodable keyAttr);
    public static OtherKeyAttribute GetInstance(object obj);
    public DerObjectIdentifier get_KeyAttrId();
    public Asn1Encodable get_KeyAttr();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo : Asn1Encodable {
    private DerObjectIdentifier oriType;
    private Asn1Encodable oriValue;
    public DerObjectIdentifier OriType { get; }
    public Asn1Encodable OriValue { get; }
    public OtherRecipientInfo(DerObjectIdentifier oriType, Asn1Encodable oriValue);
    private OtherRecipientInfo(Asn1Sequence seq);
    public static OtherRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OtherRecipientInfo GetInstance(object obj);
    public virtual DerObjectIdentifier get_OriType();
    public virtual Asn1Encodable get_OriValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat : Asn1Encodable {
    private DerObjectIdentifier otherRevInfoFormat;
    private Asn1Encodable otherRevInfo;
    public DerObjectIdentifier InfoFormat { get; }
    public Asn1Encodable Info { get; }
    public OtherRevocationInfoFormat(DerObjectIdentifier otherRevInfoFormat, Asn1Encodable otherRevInfo);
    private OtherRevocationInfoFormat(Asn1Sequence seq);
    public static OtherRevocationInfoFormat GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static OtherRevocationInfoFormat GetInstance(object obj);
    public virtual DerObjectIdentifier get_InfoFormat();
    public virtual Asn1Encodable get_Info();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier keyDerivationAlgorithm;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public AlgorithmIdentifier KeyDerivationAlgorithm { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public PasswordRecipientInfo(AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public PasswordRecipientInfo(AlgorithmIdentifier keyDerivationAlgorithm, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public PasswordRecipientInfo(Asn1Sequence seq);
    public static PasswordRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static PasswordRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_KeyDerivationAlgorithm();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey : Asn1Encodable {
    private KeyAgreeRecipientIdentifier identifier;
    private Asn1OctetString encryptedKey;
    public KeyAgreeRecipientIdentifier Identifier { get; }
    public Asn1OctetString EncryptedKey { get; }
    private RecipientEncryptedKey(Asn1Sequence seq);
    public RecipientEncryptedKey(KeyAgreeRecipientIdentifier id, Asn1OctetString encryptedKey);
    public static RecipientEncryptedKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static RecipientEncryptedKey GetInstance(object obj);
    public KeyAgreeRecipientIdentifier get_Identifier();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientIdentifier : Asn1Encodable {
    private Asn1Encodable id;
    public bool IsTagged { get; }
    public Asn1Encodable ID { get; }
    public RecipientIdentifier(IssuerAndSerialNumber id);
    public RecipientIdentifier(Asn1OctetString id);
    public RecipientIdentifier(Asn1Object id);
    public static RecipientIdentifier GetInstance(object o);
    public bool get_IsTagged();
    public Asn1Encodable get_ID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientInfo : Asn1Encodable {
    internal Asn1Encodable info;
    public DerInteger Version { get; }
    public bool IsTagged { get; }
    public Asn1Encodable Info { get; }
    public RecipientInfo(KeyTransRecipientInfo info);
    public RecipientInfo(KeyAgreeRecipientInfo info);
    public RecipientInfo(KekRecipientInfo info);
    public RecipientInfo(PasswordRecipientInfo info);
    public RecipientInfo(OtherRecipientInfo info);
    public RecipientInfo(Asn1Object info);
    public static RecipientInfo GetInstance(object o);
    public DerInteger get_Version();
    public bool get_IsTagged();
    public Asn1Encodable get_Info();
    private KekRecipientInfo GetKekInfo(Asn1TaggedObject o);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier : Asn1Encodable {
    private Asn1OctetString subjectKeyIdentifier;
    private Asn1GeneralizedTime date;
    private OtherKeyAttribute other;
    public Asn1OctetString SubjectKeyIdentifier { get; }
    public Asn1GeneralizedTime Date { get; }
    public OtherKeyAttribute OtherKeyAttribute { get; }
    public RecipientKeyIdentifier(Asn1OctetString subjectKeyIdentifier, Asn1GeneralizedTime date, OtherKeyAttribute other);
    public RecipientKeyIdentifier(Byte[] subjectKeyIdentifier);
    public RecipientKeyIdentifier(Byte[] subjectKeyIdentifier, Asn1GeneralizedTime date, OtherKeyAttribute other);
    public RecipientKeyIdentifier(Asn1Sequence seq);
    public static RecipientKeyIdentifier GetInstance(Asn1TaggedObject ato, bool explicitly);
    public static RecipientKeyIdentifier GetInstance(object obj);
    public Asn1OctetString get_SubjectKeyIdentifier();
    public Asn1GeneralizedTime get_Date();
    public OtherKeyAttribute get_OtherKeyAttribute();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.ScvpReqRes : Asn1Encodable {
    private ContentInfo request;
    private ContentInfo response;
    public ContentInfo Request { get; }
    public ContentInfo Response { get; }
    private ScvpReqRes(Asn1Sequence seq);
    public ScvpReqRes(ContentInfo response);
    public ScvpReqRes(ContentInfo request, ContentInfo response);
    public static ScvpReqRes GetInstance(object obj);
    public virtual ContentInfo get_Request();
    public virtual ContentInfo get_Response();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignedData : Asn1Encodable {
    private static DerInteger Version1;
    private static DerInteger Version3;
    private static DerInteger Version4;
    private static DerInteger Version5;
    private DerInteger version;
    private Asn1Set digestAlgorithms;
    private ContentInfo contentInfo;
    private Asn1Set certificates;
    private Asn1Set crls;
    private Asn1Set signerInfos;
    private bool certsBer;
    private bool crlsBer;
    public DerInteger Version { get; }
    public Asn1Set DigestAlgorithms { get; }
    public ContentInfo EncapContentInfo { get; }
    public Asn1Set Certificates { get; }
    public Asn1Set CRLs { get; }
    public Asn1Set SignerInfos { get; }
    public SignedData(Asn1Set digestAlgorithms, ContentInfo contentInfo, Asn1Set certificates, Asn1Set crls, Asn1Set signerInfos);
    private SignedData(Asn1Sequence seq);
    private static SignedData();
    public static SignedData GetInstance(object obj);
    private DerInteger CalculateVersion(DerObjectIdentifier contentOid, Asn1Set certs, Asn1Set crls, Asn1Set signerInfs);
    private bool CheckForVersion3(Asn1Set signerInfs);
    public DerInteger get_Version();
    public Asn1Set get_DigestAlgorithms();
    public ContentInfo get_EncapContentInfo();
    public Asn1Set get_Certificates();
    public Asn1Set get_CRLs();
    public Asn1Set get_SignerInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignedDataParser : object {
    private Asn1SequenceParser _seq;
    private DerInteger _version;
    private object _nextObject;
    private bool _certsCalled;
    private bool _crlsCalled;
    public DerInteger Version { get; }
    public SignedDataParser(Asn1SequenceParser seq);
    public static SignedDataParser GetInstance(object o);
    public DerInteger get_Version();
    public Asn1SetParser GetDigestAlgorithms();
    public ContentInfoParser GetEncapContentInfo();
    public Asn1SetParser GetCertificates();
    public Asn1SetParser GetCrls();
    public Asn1SetParser GetSignerInfos();
}
public class Org.BouncyCastle.Asn1.Cms.SignerIdentifier : Asn1Encodable {
    private Asn1Encodable id;
    public bool IsTagged { get; }
    public Asn1Encodable ID { get; }
    public SignerIdentifier(IssuerAndSerialNumber id);
    public SignerIdentifier(Asn1OctetString id);
    public SignerIdentifier(Asn1Object id);
    public static SignerIdentifier GetInstance(object o);
    public bool get_IsTagged();
    public Asn1Encodable get_ID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignerInfo : Asn1Encodable {
    private DerInteger version;
    private SignerIdentifier sid;
    private AlgorithmIdentifier digAlgorithm;
    private Asn1Set authenticatedAttributes;
    private AlgorithmIdentifier digEncryptionAlgorithm;
    private Asn1OctetString encryptedDigest;
    private Asn1Set unauthenticatedAttributes;
    public DerInteger Version { get; }
    public SignerIdentifier SignerID { get; }
    public Asn1Set AuthenticatedAttributes { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public Asn1OctetString EncryptedDigest { get; }
    public AlgorithmIdentifier DigestEncryptionAlgorithm { get; }
    public Asn1Set UnauthenticatedAttributes { get; }
    public SignerInfo(SignerIdentifier sid, AlgorithmIdentifier digAlgorithm, Asn1Set authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Asn1Set unauthenticatedAttributes);
    public SignerInfo(SignerIdentifier sid, AlgorithmIdentifier digAlgorithm, Attributes authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Attributes unauthenticatedAttributes);
    private SignerInfo(Asn1Sequence seq);
    public static SignerInfo GetInstance(object obj);
    public DerInteger get_Version();
    public SignerIdentifier get_SignerID();
    public Asn1Set get_AuthenticatedAttributes();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public Asn1OctetString get_EncryptedDigest();
    public AlgorithmIdentifier get_DigestEncryptionAlgorithm();
    public Asn1Set get_UnauthenticatedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Time : Asn1Encodable {
    private Asn1Object m_timeObject;
    [ObsoleteAttribute("Use 'ToDateTime' instead")]
public DateTime Date { get; }
    public Time(Asn1GeneralizedTime generalizedTime);
    public Time(Asn1UtcTime utcTime);
    public Time(DateTime date);
    public static Time GetInstance(object obj);
    public static Time GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public DateTime ToDateTime();
    public DateTime get_Date();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampAndCrl : Asn1Encodable {
    private ContentInfo timeStamp;
    private CertificateList crl;
    public ContentInfo TimeStampToken { get; }
    public CertificateList Crl { get; }
    public TimeStampAndCrl(ContentInfo timeStamp);
    private TimeStampAndCrl(Asn1Sequence seq);
    public static TimeStampAndCrl GetInstance(object obj);
    public virtual ContentInfo get_TimeStampToken();
    public virtual CertificateList get_Crl();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampedData : Asn1Encodable {
    private DerInteger version;
    private DerIA5String dataUri;
    private MetaData metaData;
    private Asn1OctetString content;
    private Evidence temporalEvidence;
    public DerIA5String DataUri { get; }
    public MetaData MetaData { get; }
    public Asn1OctetString Content { get; }
    public Evidence TemporalEvidence { get; }
    public TimeStampedData(DerIA5String dataUri, MetaData metaData, Asn1OctetString content, Evidence temporalEvidence);
    private TimeStampedData(Asn1Sequence seq);
    public static TimeStampedData GetInstance(object obj);
    public virtual DerIA5String get_DataUri();
    public MetaData get_MetaData();
    public Asn1OctetString get_Content();
    public Evidence get_TemporalEvidence();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampedDataParser : object {
    private DerInteger version;
    private DerIA5String dataUri;
    private MetaData metaData;
    private Asn1OctetStringParser content;
    private Evidence temporalEvidence;
    private Asn1SequenceParser parser;
    public DerIA5String DataUri { get; }
    public MetaData MetaData { get; }
    public Asn1OctetStringParser Content { get; }
    private TimeStampedDataParser(Asn1SequenceParser parser);
    public static TimeStampedDataParser GetInstance(object obj);
    public virtual DerIA5String get_DataUri();
    public virtual MetaData get_MetaData();
    public virtual Asn1OctetStringParser get_Content();
    public virtual Evidence GetTemporalEvidence();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampTokenEvidence : Asn1Encodable {
    private TimeStampAndCrl[] timeStampAndCrls;
    public TimeStampTokenEvidence(TimeStampAndCrl[] timeStampAndCrls);
    public TimeStampTokenEvidence(TimeStampAndCrl timeStampAndCrl);
    private TimeStampTokenEvidence(Asn1Sequence seq);
    public static TimeStampTokenEvidence GetInstance(Asn1TaggedObject tagged, bool isExplicit);
    public static TimeStampTokenEvidence GetInstance(object obj);
    public virtual TimeStampAndCrl[] ToTimeStampAndCrlArray();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.ConstructedBitStream : BaseInputStream {
    private Asn1StreamParser m_parser;
    private bool m_octetAligned;
    private bool m_first;
    private int m_padBits;
    private Asn1BitStringParser m_currentParser;
    private Stream m_currentStream;
    internal int PadBits { get; }
    internal ConstructedBitStream(Asn1StreamParser parser, bool octetAligned);
    internal int get_PadBits();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private Asn1BitStringParser GetNextParser();
}
internal class Org.BouncyCastle.Asn1.ConstructedDerEncoding : DerEncoding {
    private DerEncoding[] m_contentsElements;
    private int m_contentsLength;
    internal ConstructedDerEncoding(int tagClass, int tagNo, DerEncoding[] contentsElements);
    protected internal virtual int CompareLengthAndContents(DerEncoding other);
    public virtual void Encode(Asn1OutputStream asn1Out);
    public virtual int GetLength();
}
internal class Org.BouncyCastle.Asn1.ConstructedDLEncoding : object {
    private int m_tagClass;
    private int m_tagNo;
    private IAsn1Encoding[] m_contentsElements;
    private int m_contentsLength;
    internal ConstructedDLEncoding(int tagClass, int tagNo, IAsn1Encoding[] contentsElements);
    private sealed virtual override void Org.BouncyCastle.Asn1.IAsn1Encoding.Encode(Asn1OutputStream asn1Out);
    private sealed virtual override int Org.BouncyCastle.Asn1.IAsn1Encoding.GetLength();
}
internal class Org.BouncyCastle.Asn1.ConstructedILEncoding : object {
    private int m_tagClass;
    private int m_tagNo;
    private IAsn1Encoding[] m_contentsElements;
    internal ConstructedILEncoding(int tagClass, int tagNo, IAsn1Encoding[] contentsElements);
    private sealed virtual override void Org.BouncyCastle.Asn1.IAsn1Encoding.Encode(Asn1OutputStream asn1Out);
    private sealed virtual override int Org.BouncyCastle.Asn1.IAsn1Encoding.GetLength();
}
internal class Org.BouncyCastle.Asn1.ConstructedOctetStream : BaseInputStream {
    private Asn1StreamParser m_parser;
    private bool m_first;
    private Stream m_currentStream;
    internal ConstructedOctetStream(Asn1StreamParser parser);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private Asn1OctetStringParser GetNextParser();
}
public class Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue : Asn1Encodable {
    private DerObjectIdentifier type;
    private Asn1Encodable value;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    private AttributeTypeAndValue(Asn1Sequence seq);
    public AttributeTypeAndValue(string oid, Asn1Encodable value);
    public AttributeTypeAndValue(DerObjectIdentifier type, Asn1Encodable value);
    public static AttributeTypeAndValue GetInstance(object obj);
    public virtual DerObjectIdentifier get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertId : Asn1Encodable {
    private GeneralName issuer;
    private DerInteger serialNumber;
    public GeneralName Issuer { get; }
    public DerInteger SerialNumber { get; }
    private CertId(Asn1Sequence seq);
    public static CertId GetInstance(object obj);
    public static CertId GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual GeneralName get_Issuer();
    public virtual DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertReqMessages : Asn1Encodable {
    private Asn1Sequence content;
    private CertReqMessages(Asn1Sequence seq);
    public CertReqMessages(CertReqMsg[] msgs);
    public static CertReqMessages GetInstance(object obj);
    public virtual CertReqMsg[] ToCertReqMsgArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertReqMsg : Asn1Encodable {
    private CertRequest certReq;
    private ProofOfPossession popo;
    private Asn1Sequence regInfo;
    public CertRequest CertReq { get; }
    public ProofOfPossession Popo { get; }
    private CertReqMsg(Asn1Sequence seq);
    public CertReqMsg(CertRequest certReq, ProofOfPossession popo, AttributeTypeAndValue[] regInfo);
    public static CertReqMsg GetInstance(object obj);
    public static CertReqMsg GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual CertRequest get_CertReq();
    public virtual ProofOfPossession get_Popo();
    public virtual AttributeTypeAndValue[] GetRegInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertRequest : Asn1Encodable {
    private DerInteger certReqId;
    private CertTemplate certTemplate;
    private Controls controls;
    public DerInteger CertReqID { get; }
    public CertTemplate CertTemplate { get; }
    public Controls Controls { get; }
    private CertRequest(Asn1Sequence seq);
    public CertRequest(int certReqId, CertTemplate certTemplate, Controls controls);
    public CertRequest(DerInteger certReqId, CertTemplate certTemplate, Controls controls);
    public static CertRequest GetInstance(object obj);
    public virtual DerInteger get_CertReqID();
    public virtual CertTemplate get_CertTemplate();
    public virtual Controls get_Controls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertTemplate : Asn1Encodable {
    private Asn1Sequence seq;
    private DerInteger version;
    private DerInteger serialNumber;
    private AlgorithmIdentifier signingAlg;
    private X509Name issuer;
    private OptionalValidity validity;
    private X509Name subject;
    private SubjectPublicKeyInfo publicKey;
    private DerBitString issuerUID;
    private DerBitString subjectUID;
    private X509Extensions extensions;
    public int Version { get; }
    public DerInteger SerialNumber { get; }
    public AlgorithmIdentifier SigningAlg { get; }
    public X509Name Issuer { get; }
    public OptionalValidity Validity { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo PublicKey { get; }
    public DerBitString IssuerUID { get; }
    public DerBitString SubjectUID { get; }
    public X509Extensions Extensions { get; }
    private CertTemplate(Asn1Sequence seq);
    public static CertTemplate GetInstance(object obj);
    public virtual int get_Version();
    public virtual DerInteger get_SerialNumber();
    public virtual AlgorithmIdentifier get_SigningAlg();
    public virtual X509Name get_Issuer();
    public virtual OptionalValidity get_Validity();
    public virtual X509Name get_Subject();
    public virtual SubjectPublicKeyInfo get_PublicKey();
    public virtual DerBitString get_IssuerUID();
    public virtual DerBitString get_SubjectUID();
    public virtual X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder : object {
    private DerInteger version;
    private DerInteger serialNumber;
    private AlgorithmIdentifier signingAlg;
    private X509Name issuer;
    private OptionalValidity validity;
    private X509Name subject;
    private SubjectPublicKeyInfo publicKey;
    private DerBitString issuerUID;
    private DerBitString subjectUID;
    private X509Extensions extensions;
    public virtual CertTemplateBuilder SetVersion(int ver);
    public virtual CertTemplateBuilder SetSerialNumber(DerInteger ser);
    public virtual CertTemplateBuilder SetSigningAlg(AlgorithmIdentifier aid);
    public virtual CertTemplateBuilder SetIssuer(X509Name name);
    public virtual CertTemplateBuilder SetValidity(OptionalValidity v);
    public virtual CertTemplateBuilder SetSubject(X509Name name);
    public virtual CertTemplateBuilder SetPublicKey(SubjectPublicKeyInfo spki);
    public virtual CertTemplateBuilder SetIssuerUID(DerBitString uid);
    public virtual CertTemplateBuilder SetSubjectUID(DerBitString uid);
    public virtual CertTemplateBuilder SetExtensions(X509Extensions extens);
    public virtual CertTemplate Build();
}
public class Org.BouncyCastle.Asn1.Crmf.Controls : Asn1Encodable {
    private Asn1Sequence content;
    private Controls(Asn1Sequence seq);
    public Controls(AttributeTypeAndValue[] atvs);
    public static Controls GetInstance(object obj);
    public virtual AttributeTypeAndValue[] ToAttributeTypeAndValueArray();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Crmf.CrmfObjectIdentifiers : object {
    public static DerObjectIdentifier id_pkix;
    public static DerObjectIdentifier id_pkip;
    public static DerObjectIdentifier id_regCtrl;
    public static DerObjectIdentifier id_regCtrl_regToken;
    public static DerObjectIdentifier id_regCtrl_authenticator;
    public static DerObjectIdentifier id_regCtrl_pkiPublicationInfo;
    public static DerObjectIdentifier id_regCtrl_pkiArchiveOptions;
    public static DerObjectIdentifier id_ct_encKeyWithID;
    private static CrmfObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Crmf.EncKeyWithID : Asn1Encodable {
    private PrivateKeyInfo privKeyInfo;
    private Asn1Encodable identifier;
    public PrivateKeyInfo PrivateKey { get; }
    public bool HasIdentifier { get; }
    public bool IsIdentifierUtf8String { get; }
    public Asn1Encodable Identifier { get; }
    private EncKeyWithID(Asn1Sequence seq);
    public EncKeyWithID(PrivateKeyInfo privKeyInfo);
    public EncKeyWithID(PrivateKeyInfo privKeyInfo, DerUtf8String str);
    public EncKeyWithID(PrivateKeyInfo privKeyInfo, GeneralName generalName);
    public static EncKeyWithID GetInstance(object obj);
    public virtual PrivateKeyInfo get_PrivateKey();
    public virtual bool get_HasIdentifier();
    public virtual bool get_IsIdentifierUtf8String();
    public virtual Asn1Encodable get_Identifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.EncryptedKey : Asn1Encodable {
    private EnvelopedData m_envelopedData;
    private EncryptedValue m_encryptedValue;
    public bool IsEncryptedValue { get; }
    public Asn1Encodable Value { get; }
    public EncryptedKey(EnvelopedData envelopedData);
    public EncryptedKey(EncryptedValue encryptedValue);
    public static EncryptedKey GetInstance(object obj);
    public virtual bool get_IsEncryptedValue();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.EncryptedValue : Asn1Encodable {
    private AlgorithmIdentifier m_intendedAlg;
    private AlgorithmIdentifier m_symmAlg;
    private DerBitString m_encSymmKey;
    private AlgorithmIdentifier m_keyAlg;
    private Asn1OctetString m_valueHint;
    private DerBitString m_encValue;
    public AlgorithmIdentifier IntendedAlg { get; }
    public AlgorithmIdentifier SymmAlg { get; }
    public DerBitString EncSymmKey { get; }
    public AlgorithmIdentifier KeyAlg { get; }
    public Asn1OctetString ValueHint { get; }
    public DerBitString EncValue { get; }
    private EncryptedValue(Asn1Sequence seq);
    public EncryptedValue(AlgorithmIdentifier intendedAlg, AlgorithmIdentifier symmAlg, DerBitString encSymmKey, AlgorithmIdentifier keyAlg, Asn1OctetString valueHint, DerBitString encValue);
    public static EncryptedValue GetInstance(object obj);
    public virtual AlgorithmIdentifier get_IntendedAlg();
    public virtual AlgorithmIdentifier get_SymmAlg();
    public virtual DerBitString get_EncSymmKey();
    public virtual AlgorithmIdentifier get_KeyAlg();
    public virtual Asn1OctetString get_ValueHint();
    public virtual DerBitString get_EncValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.OptionalValidity : Asn1Encodable {
    private Time notBefore;
    private Time notAfter;
    public Time NotBefore { get; }
    public Time NotAfter { get; }
    private OptionalValidity(Asn1Sequence seq);
    public OptionalValidity(Time notBefore, Time notAfter);
    public static OptionalValidity GetInstance(object obj);
    public virtual Time get_NotBefore();
    public virtual Time get_NotAfter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PkiArchiveOptions : Asn1Encodable {
    public static int encryptedPrivKey;
    public static int keyGenParameters;
    public static int archiveRemGenPrivKey;
    private Asn1Encodable value;
    public int Type { get; }
    public Asn1Encodable Value { get; }
    private PkiArchiveOptions(Asn1TaggedObject tagged);
    public PkiArchiveOptions(EncryptedKey encKey);
    public PkiArchiveOptions(Asn1OctetString keyGenParameters);
    public PkiArchiveOptions(bool archiveRemGenPrivKey);
    public static PkiArchiveOptions GetInstance(object obj);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo : Asn1Encodable {
    public static DerInteger DontPublish;
    public static DerInteger PleasePublish;
    private DerInteger m_action;
    private Asn1Sequence m_pubInfos;
    public DerInteger Action { get; }
    private PkiPublicationInfo(Asn1Sequence seq);
    public PkiPublicationInfo(BigInteger action);
    public PkiPublicationInfo(DerInteger action);
    public PkiPublicationInfo(SinglePubInfo pubInfo);
    public PkiPublicationInfo(SinglePubInfo[] pubInfos);
    private static PkiPublicationInfo();
    public static PkiPublicationInfo GetInstance(object obj);
    public virtual DerInteger get_Action();
    public virtual SinglePubInfo[] GetPubInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PKMacValue : Asn1Encodable {
    private AlgorithmIdentifier algID;
    private DerBitString macValue;
    public AlgorithmIdentifier AlgID { get; }
    public DerBitString MacValue { get; }
    private PKMacValue(Asn1Sequence seq);
    public PKMacValue(PbmParameter pbmParams, DerBitString macValue);
    public PKMacValue(AlgorithmIdentifier algID, DerBitString macValue);
    public static PKMacValue GetInstance(object obj);
    public static PKMacValue GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual AlgorithmIdentifier get_AlgID();
    public virtual DerBitString get_MacValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PopoPrivKey : Asn1Encodable {
    public static int thisMessage;
    public static int subsequentMessage;
    public static int dhMAC;
    public static int agreeMAC;
    public static int encryptedKey;
    private int tagNo;
    private Asn1Encodable obj;
    public int Type { get; }
    public Asn1Encodable Value { get; }
    private PopoPrivKey(Asn1TaggedObject obj);
    public PopoPrivKey(PKMacValue pkMacValue);
    public PopoPrivKey(SubsequentMessage msg);
    public static PopoPrivKey GetInstance(object obj);
    public static PopoPrivKey GetInstance(Asn1TaggedObject tagged, bool isExplicit);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PopoSigningKey : Asn1Encodable {
    private PopoSigningKeyInput poposkInput;
    private AlgorithmIdentifier algorithmIdentifier;
    private DerBitString signature;
    public PopoSigningKeyInput PoposkInput { get; }
    public AlgorithmIdentifier AlgorithmIdentifier { get; }
    public DerBitString Signature { get; }
    private PopoSigningKey(Asn1Sequence seq);
    public PopoSigningKey(PopoSigningKeyInput poposkIn, AlgorithmIdentifier aid, DerBitString signature);
    public static PopoSigningKey GetInstance(object obj);
    public static PopoSigningKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual PopoSigningKeyInput get_PoposkInput();
    public virtual AlgorithmIdentifier get_AlgorithmIdentifier();
    public virtual DerBitString get_Signature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput : Asn1Encodable {
    private GeneralName sender;
    private PKMacValue publicKeyMac;
    private SubjectPublicKeyInfo publicKey;
    public GeneralName Sender { get; }
    public PKMacValue PublicKeyMac { get; }
    public SubjectPublicKeyInfo PublicKey { get; }
    private PopoSigningKeyInput(Asn1Sequence seq);
    public PopoSigningKeyInput(GeneralName sender, SubjectPublicKeyInfo spki);
    public PopoSigningKeyInput(PKMacValue pkmac, SubjectPublicKeyInfo spki);
    public static PopoSigningKeyInput GetInstance(object obj);
    public virtual GeneralName get_Sender();
    public virtual PKMacValue get_PublicKeyMac();
    public virtual SubjectPublicKeyInfo get_PublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.ProofOfPossession : Asn1Encodable {
    public static int TYPE_RA_VERIFIED;
    public static int TYPE_SIGNING_KEY;
    public static int TYPE_KEY_ENCIPHERMENT;
    public static int TYPE_KEY_AGREEMENT;
    private int tagNo;
    private Asn1Encodable obj;
    public int Type { get; }
    public Asn1Encodable Object { get; }
    private ProofOfPossession(Asn1TaggedObject tagged);
    public ProofOfPossession(PopoSigningKey Poposk);
    public ProofOfPossession(int type, PopoPrivKey privkey);
    public static ProofOfPossession GetInstance(object obj);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Object();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.SinglePubInfo : Asn1Encodable {
    private DerInteger pubMethod;
    private GeneralName pubLocation;
    public GeneralName PubLocation { get; }
    private SinglePubInfo(Asn1Sequence seq);
    public static SinglePubInfo GetInstance(object obj);
    public virtual GeneralName get_PubLocation();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.SubsequentMessage : DerInteger {
    public static SubsequentMessage encrCert;
    public static SubsequentMessage challengeResp;
    private SubsequentMessage(int value);
    private static SubsequentMessage();
    public static SubsequentMessage ValueOf(int value);
}
internal class Org.BouncyCastle.Asn1.Cryptlib.CryptlibObjectIdentifiers : object {
    internal static DerObjectIdentifier cryptlib;
    internal static DerObjectIdentifier ecc;
    internal static DerObjectIdentifier curvey25519;
    private static CryptlibObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.CryptoPro.CryptoProObjectIdentifiers : object {
    public static string GostID;
    public static DerObjectIdentifier GostR3411;
    public static DerObjectIdentifier GostR3411Hmac;
    public static DerObjectIdentifier GostR28147Gcfb;
    [ObsoleteAttribute("Use 'GostR28147Gcfb' instead")]
public static DerObjectIdentifier GostR28147Cbc;
    public static DerObjectIdentifier ID_Gost28147_89_CryptoPro_A_ParamSet;
    public static DerObjectIdentifier GostR3410x94;
    public static DerObjectIdentifier GostR3410x2001;
    public static DerObjectIdentifier GostR3411x94WithGostR3410x94;
    public static DerObjectIdentifier GostR3411x94WithGostR3410x2001;
    public static DerObjectIdentifier GostR3411x94CryptoProParamSet;
    public static DerObjectIdentifier GostR3410x94CryptoProA;
    public static DerObjectIdentifier GostR3410x94CryptoProB;
    public static DerObjectIdentifier GostR3410x94CryptoProC;
    public static DerObjectIdentifier GostR3410x94CryptoProD;
    public static DerObjectIdentifier GostR3410x94CryptoProXchA;
    public static DerObjectIdentifier GostR3410x94CryptoProXchB;
    public static DerObjectIdentifier GostR3410x94CryptoProXchC;
    public static DerObjectIdentifier GostR3410x2001CryptoProA;
    public static DerObjectIdentifier GostR3410x2001CryptoProB;
    public static DerObjectIdentifier GostR3410x2001CryptoProC;
    public static DerObjectIdentifier GostR3410x2001CryptoProXchA;
    public static DerObjectIdentifier GostR3410x2001CryptoProXchB;
    public static DerObjectIdentifier GostElSgDH3410Default;
    public static DerObjectIdentifier GostElSgDH3410x1;
    public static DerObjectIdentifier GostR3410x2001CryptoProESDH;
    public static DerObjectIdentifier GostR3410x2001DH;
    private static CryptoProObjectIdentifiers();
}
public static class Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves : object {
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, X9ECParametersHolder> curves;
    private static Dictionary`2<DerObjectIdentifier, string> names;
    public static IEnumerable`1<string> Names { get; }
    private static ECGost3410NamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, BigInteger x, BigInteger y);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public class Org.BouncyCastle.Asn1.CryptoPro.ECGost3410ParamSetParameters : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger q;
    internal DerInteger a;
    internal DerInteger b;
    internal DerInteger x;
    internal DerInteger y;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public ECGost3410ParamSetParameters(BigInteger a, BigInteger b, BigInteger p, BigInteger q, int x, BigInteger y);
    public ECGost3410ParamSetParameters(Asn1Sequence seq);
    public static ECGost3410ParamSetParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ECGost3410ParamSetParameters GetInstance(object obj);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost28147Parameters : Asn1Encodable {
    private Asn1OctetString iv;
    private DerObjectIdentifier paramSet;
    private Gost28147Parameters(Asn1Sequence seq);
    public static Gost28147Parameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost28147Parameters GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public static class Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters : object {
    private static Gost3410ParamSetParameters cryptoProA;
    private static Gost3410ParamSetParameters cryptoProB;
    private static Gost3410ParamSetParameters cryptoProXchA;
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, Gost3410ParamSetParameters> parameters;
    public static IEnumerable`1<string> Names { get; }
    private static Gost3410NamedParameters();
    private static void DefineParameters(string name, DerObjectIdentifier oid, Gost3410ParamSetParameters parameterSet);
    public static Gost3410ParamSetParameters GetByName(string name);
    public static Gost3410ParamSetParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410ParamSetParameters : Asn1Encodable {
    private int keySize;
    private DerInteger p;
    private DerInteger q;
    private DerInteger a;
    public int KeySize { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public Gost3410ParamSetParameters(int keySize, BigInteger p, BigInteger q, BigInteger a);
    private Gost3410ParamSetParameters(Asn1Sequence seq);
    public static Gost3410ParamSetParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost3410ParamSetParameters GetInstance(object obj);
    public int get_KeySize();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410PublicKeyAlgParameters : Asn1Encodable {
    private DerObjectIdentifier publicKeyParamSet;
    private DerObjectIdentifier digestParamSet;
    private DerObjectIdentifier encryptionParamSet;
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public DerObjectIdentifier DigestParamSet { get; }
    public DerObjectIdentifier EncryptionParamSet { get; }
    public Gost3410PublicKeyAlgParameters(DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet);
    public Gost3410PublicKeyAlgParameters(DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet, DerObjectIdentifier encryptionParamSet);
    private Gost3410PublicKeyAlgParameters(Asn1Sequence seq);
    public static Gost3410PublicKeyAlgParameters GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public static Gost3410PublicKeyAlgParameters GetInstance(object obj);
    public DerObjectIdentifier get_PublicKeyParamSet();
    public DerObjectIdentifier get_DigestParamSet();
    public DerObjectIdentifier get_EncryptionParamSet();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.DefiniteLengthInputStream : LimitedInputStream {
    private static Byte[] EmptyBytes;
    private int _originalLength;
    private int _remaining;
    internal int Remaining { get; }
    internal DefiniteLengthInputStream(Stream inStream, int length, int limit);
    private static DefiniteLengthInputStream();
    internal int get_Remaining();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buf, int off, int len);
    internal void ReadAllIntoByteArray(Byte[] buf);
    internal Byte[] ToArray();
}
public class Org.BouncyCastle.Asn1.DerBitString : DerStringBase {
    private static Char[] table;
    internal Byte[] contents;
    public int PadBits { get; }
    public int IntValue { get; }
    public Asn1BitStringParser Parser { get; }
    public DerBitString(byte data, int padBits);
    public DerBitString(Byte[] data);
    public DerBitString(Byte[] data, int padBits);
    public DerBitString(int namedBits);
    public DerBitString(Asn1Encodable obj);
    internal DerBitString(Byte[] contents, bool check);
    private static DerBitString();
    public static DerBitString GetInstance(object obj);
    public static DerBitString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual Byte[] GetOctets();
    public virtual Byte[] GetBytes();
    public virtual int get_PadBits();
    public virtual int get_IntValue();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public sealed virtual Stream GetBitStream();
    public sealed virtual Stream GetOctetStream();
    public Asn1BitStringParser get_Parser();
    public virtual string GetString();
    internal static DerBitString CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerBmpString : DerStringBase {
    private string m_str;
    internal DerBmpString(Byte[] contents);
    internal DerBmpString(Char[] str);
    public DerBmpString(string str);
    public static DerBmpString GetInstance(object obj);
    public static DerBmpString GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    private Byte[] GetContents();
    internal static DerBmpString CreatePrimitive(Byte[] contents);
    internal static DerBmpString CreatePrimitive(Char[] str);
}
public class Org.BouncyCastle.Asn1.DerBoolean : Asn1Object {
    public static DerBoolean False;
    public static DerBoolean True;
    private byte value;
    public bool IsTrue { get; }
    public DerBoolean(Byte[] val);
    private DerBoolean(bool value);
    private static DerBoolean();
    public static DerBoolean GetInstance(object obj);
    public static DerBoolean GetInstance(bool value);
    public static DerBoolean GetInstance(int value);
    public static DerBoolean GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public bool get_IsTrue();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
    internal static DerBoolean CreatePrimitive(Byte[] contents);
    private Byte[] GetContents(int encoding);
}
internal abstract class Org.BouncyCastle.Asn1.DerEncoding : object {
    protected internal int m_tagClass;
    protected internal int m_tagNo;
    protected internal DerEncoding(int tagClass, int tagNo);
    protected internal abstract virtual int CompareLengthAndContents(DerEncoding other);
    public sealed virtual int CompareTo(DerEncoding other);
    public abstract virtual void Encode(Asn1OutputStream asn1Out);
    public abstract virtual int GetLength();
}
public class Org.BouncyCastle.Asn1.DerEnumerated : Asn1Object {
    private Byte[] contents;
    private int start;
    private static DerEnumerated[] cache;
    public BigInteger Value { get; }
    public int IntValueExact { get; }
    public DerEnumerated(int val);
    public DerEnumerated(long val);
    public DerEnumerated(BigInteger val);
    public DerEnumerated(Byte[] contents);
    internal DerEnumerated(Byte[] contents, bool clone);
    private static DerEnumerated();
    public static DerEnumerated GetInstance(object obj);
    public static DerEnumerated GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public BigInteger get_Value();
    public bool HasValue(int x);
    public bool HasValue(BigInteger x);
    public int get_IntValueExact();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal static DerEnumerated CreatePrimitive(Byte[] contents, bool clone);
}
public class Org.BouncyCastle.Asn1.DerExternal : Asn1Object {
    internal DerObjectIdentifier directReference;
    internal DerInteger indirectReference;
    internal Asn1ObjectDescriptor dataValueDescriptor;
    internal int encoding;
    internal Asn1Object externalContent;
    public Asn1ObjectDescriptor DataValueDescriptor { get; }
    public DerObjectIdentifier DirectReference { get; }
    public int Encoding { get; }
    public Asn1Object ExternalContent { get; }
    public DerInteger IndirectReference { get; }
    public DerExternal(Asn1EncodableVector vector);
    public DerExternal(Asn1Sequence sequence);
    [ObsoleteAttribute("Pass 'externalData' at type Asn1TaggedObject")]
public DerExternal(DerObjectIdentifier directReference, DerInteger indirectReference, Asn1ObjectDescriptor dataValueDescriptor, DerTaggedObject externalData);
    public DerExternal(DerObjectIdentifier directReference, DerInteger indirectReference, Asn1ObjectDescriptor dataValueDescriptor, Asn1TaggedObject externalData);
    public DerExternal(DerObjectIdentifier directReference, DerInteger indirectReference, Asn1ObjectDescriptor dataValueDescriptor, int encoding, Asn1Object externalData);
    public static DerExternal GetInstance(object obj);
    public static DerExternal GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    internal virtual Asn1Sequence BuildSequence();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public Asn1ObjectDescriptor get_DataValueDescriptor();
    public DerObjectIdentifier get_DirectReference();
    public int get_Encoding();
    public Asn1Object get_ExternalContent();
    public DerInteger get_IndirectReference();
    private static Asn1ObjectDescriptor CheckDataValueDescriptor(Asn1Object dataValueDescriptor);
    private static int CheckEncoding(int encoding);
    private static Asn1Object CheckExternalContent(int tagNo, Asn1Object externalContent);
    private static Asn1Object GetExternalContent(Asn1TaggedObject encoding);
    private static Asn1Object GetObjFromSequence(Asn1Sequence sequence, int index);
}
public class Org.BouncyCastle.Asn1.DerExternalParser : Asn1Encodable {
    private Asn1StreamParser m_parser;
    internal DerExternalParser(Asn1StreamParser parser);
    public IAsn1Convertible ReadObject();
    public virtual Asn1Object ToAsn1Object();
    internal static DerExternal Parse(Asn1StreamParser sp);
}
public class Org.BouncyCastle.Asn1.DerGeneralizedTime : Asn1GeneralizedTime {
    public DerGeneralizedTime(string timeString);
    public DerGeneralizedTime(DateTime dateTime);
    internal DerGeneralizedTime(Byte[] contents);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
}
public class Org.BouncyCastle.Asn1.DerGeneralString : DerStringBase {
    private Byte[] m_contents;
    public DerGeneralString(string str);
    public DerGeneralString(Byte[] contents);
    internal DerGeneralString(Byte[] contents, bool clone);
    public static DerGeneralString GetInstance(object obj);
    public static DerGeneralString GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal static DerGeneralString CreatePrimitive(Byte[] contents);
}
public abstract class Org.BouncyCastle.Asn1.DerGenerator : Asn1Generator {
    private bool _tagged;
    private bool _isExplicit;
    private int _tagNo;
    protected DerGenerator(Stream outStream);
    protected DerGenerator(Stream outStream, int tagNo, bool isExplicit);
    internal void WriteDerEncoded(int tag, Byte[] bytes);
    internal static void WriteDerEncoded(Stream outStream, int tag, Byte[] bytes);
    internal static void WriteDerEncoded(Stream outStream, int tag, Stream inStream);
    private static void WriteLength(Stream outStream, int length);
}
public class Org.BouncyCastle.Asn1.DerGraphicString : DerStringBase {
    private Byte[] m_contents;
    public DerGraphicString(Byte[] contents);
    internal DerGraphicString(Byte[] contents, bool clone);
    public static DerGraphicString GetInstance(object obj);
    public static DerGraphicString GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    internal static DerGraphicString CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerIA5String : DerStringBase {
    private Byte[] m_contents;
    public DerIA5String(string str);
    public DerIA5String(string str, bool validate);
    public DerIA5String(Byte[] contents);
    internal DerIA5String(Byte[] contents, bool clone);
    public static DerIA5String GetInstance(object obj);
    public static DerIA5String GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public static bool IsIA5String(string str);
    internal static DerIA5String CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerInteger : Asn1Object {
    public static string AllowUnsafeProperty;
    internal static int SignExtSigned;
    internal static int SignExtUnsigned;
    private Byte[] bytes;
    private int start;
    public BigInteger PositiveValue { get; }
    public BigInteger Value { get; }
    public int IntPositiveValueExact { get; }
    public int IntValueExact { get; }
    public long LongValueExact { get; }
    public DerInteger(int value);
    public DerInteger(long value);
    public DerInteger(BigInteger value);
    public DerInteger(Byte[] bytes);
    internal DerInteger(Byte[] bytes, bool clone);
    internal static bool AllowUnsafe();
    public static DerInteger GetInstance(object obj);
    public static DerInteger GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public BigInteger get_PositiveValue();
    public BigInteger get_Value();
    public bool HasValue(int x);
    public bool HasValue(long x);
    public bool HasValue(BigInteger x);
    public int get_IntPositiveValueExact();
    public int get_IntValueExact();
    public long get_LongValueExact();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
    internal static DerInteger CreatePrimitive(Byte[] contents);
    internal static int GetEncodingLength(BigInteger x);
    internal static int IntValue(Byte[] bytes, int start, int signExt);
    internal static long LongValue(Byte[] bytes, int start, int signExt);
    internal static bool IsMalformed(Byte[] bytes);
    internal static int SignBytesToSkip(Byte[] bytes);
}
public class Org.BouncyCastle.Asn1.DerNull : Asn1Null {
    public static DerNull Instance;
    private static Byte[] ZeroBytes;
    private static DerNull();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerNumericString : DerStringBase {
    private Byte[] m_contents;
    public DerNumericString(string str);
    public DerNumericString(string str, bool validate);
    public DerNumericString(Byte[] contents);
    internal DerNumericString(Byte[] contents, bool clone);
    public static DerNumericString GetInstance(object obj);
    public static DerNumericString GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public static bool IsNumericString(string str);
    internal static bool IsNumericString(Byte[] contents);
    internal static DerNumericString CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerObjectIdentifier : Asn1Object {
    private static long LongLimit;
    private static DerObjectIdentifier[] Cache;
    private string identifier;
    private Byte[] contents;
    public string Id { get; }
    public DerObjectIdentifier(string identifier);
    private DerObjectIdentifier(DerObjectIdentifier oid, string branchID);
    private DerObjectIdentifier(Byte[] contents, bool clone);
    private static DerObjectIdentifier();
    public static DerObjectIdentifier FromContents(Byte[] contents);
    public static DerObjectIdentifier GetInstance(object obj);
    public static DerObjectIdentifier GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual DerObjectIdentifier Branch(string branchID);
    public string get_Id();
    public virtual bool On(DerObjectIdentifier stem);
    public virtual string ToString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    private void DoOutput(MemoryStream bOut);
    private Byte[] GetContents();
    internal static DerObjectIdentifier CreatePrimitive(Byte[] contents, bool clone);
    private static bool IsValidIdentifier(string identifier);
    private static string ParseContents(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerOctetString : Asn1OctetString {
    public DerOctetString(Byte[] contents);
    public DerOctetString(IAsn1Convertible obj);
    public DerOctetString(Asn1Encodable obj);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    internal static void Encode(Asn1OutputStream asn1Out, Byte[] buf, int off, int len);
}
public class Org.BouncyCastle.Asn1.DerOctetStringParser : object {
    private DefiniteLengthInputStream stream;
    internal DerOctetStringParser(DefiniteLengthInputStream stream);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.DerOutputStream : Asn1OutputStream {
    internal int Encoding { get; }
    internal DerOutputStream(Stream os, bool leaveOpen);
    internal virtual int get_Encoding();
}
public class Org.BouncyCastle.Asn1.DerPrintableString : DerStringBase {
    private Byte[] m_contents;
    public DerPrintableString(string str);
    public DerPrintableString(string str, bool validate);
    public DerPrintableString(Byte[] contents);
    internal DerPrintableString(Byte[] contents, bool clone);
    public static DerPrintableString GetInstance(object obj);
    public static DerPrintableString GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public static bool IsPrintableString(string str);
    internal static DerPrintableString CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerSequence : Asn1Sequence {
    public static DerSequence Empty;
    public DerSequence(Asn1Encodable element);
    public DerSequence(Asn1Encodable element1, Asn1Encodable element2);
    public DerSequence(Asn1Encodable[] elements);
    public DerSequence(Asn1EncodableVector elementVector);
    internal DerSequence(Asn1Encodable[] elements, bool clone);
    private static DerSequence();
    public static DerSequence FromVector(Asn1EncodableVector elementVector);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    internal virtual DerBitString ToAsn1BitString();
    internal virtual DerExternal ToAsn1External();
    internal virtual Asn1OctetString ToAsn1OctetString();
    internal virtual Asn1Set ToAsn1Set();
    internal static int GetEncodingLength(int contentsLength);
}
public class Org.BouncyCastle.Asn1.DerSequenceGenerator : DerGenerator {
    private MemoryStream _bOut;
    public DerSequenceGenerator(Stream outStream);
    public DerSequenceGenerator(Stream outStream, int tagNo, bool isExplicit);
    protected virtual void Finish();
    public virtual void AddObject(Asn1Encodable obj);
    public virtual void AddObject(Asn1Object obj);
    public virtual Stream GetRawOutputStream();
}
public class Org.BouncyCastle.Asn1.DerSequenceParser : object {
    private Asn1StreamParser m_parser;
    internal DerSequenceParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.DerSet : Asn1Set {
    public static DerSet Empty;
    public DerSet(Asn1Encodable element);
    public DerSet(Asn1Encodable[] elements);
    internal DerSet(Asn1Encodable[] elements, bool doSort);
    public DerSet(Asn1EncodableVector elementVector);
    internal DerSet(Asn1EncodableVector elementVector, bool doSort);
    internal DerSet(bool isSorted, Asn1Encodable[] elements);
    private static DerSet();
    public static DerSet FromVector(Asn1EncodableVector elementVector);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    private DerEncoding[] GetSortedDerEncodings();
    private static DerEncoding[] CreateSortedDerEncodings(Asn1Encodable[] elements);
}
public class Org.BouncyCastle.Asn1.DerSetGenerator : DerGenerator {
    private MemoryStream _bOut;
    public DerSetGenerator(Stream outStream);
    public DerSetGenerator(Stream outStream, int tagNo, bool isExplicit);
    protected virtual void Finish();
    public virtual void AddObject(Asn1Encodable obj);
    public virtual void AddObject(Asn1Object obj);
    public virtual Stream GetRawOutputStream();
}
public class Org.BouncyCastle.Asn1.DerSetParser : object {
    private Asn1StreamParser m_parser;
    internal DerSetParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.DerStringBase : Asn1Object {
    public abstract virtual string GetString();
    public virtual string ToString();
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerT61String : DerStringBase {
    private Byte[] m_contents;
    public DerT61String(string str);
    public DerT61String(Byte[] contents);
    internal DerT61String(Byte[] contents, bool clone);
    public static DerT61String GetInstance(object obj);
    public static DerT61String GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    public Byte[] GetOctets();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal static DerT61String CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerTaggedObject : Asn1TaggedObject {
    internal string Asn1Encoding { get; }
    public DerTaggedObject(int tagNo, Asn1Encodable obj);
    public DerTaggedObject(int tagClass, int tagNo, Asn1Encodable obj);
    public DerTaggedObject(bool isExplicit, int tagNo, Asn1Encodable obj);
    public DerTaggedObject(bool isExplicit, int tagClass, int tagNo, Asn1Encodable obj);
    internal DerTaggedObject(int explicitness, int tagClass, int tagNo, Asn1Encodable obj);
    internal virtual string get_Asn1Encoding();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    internal virtual Asn1Sequence RebuildConstructed(Asn1Object asn1Object);
    internal virtual Asn1TaggedObject ReplaceTag(int tagClass, int tagNo);
}
public class Org.BouncyCastle.Asn1.DerUniversalString : DerStringBase {
    private static Char[] table;
    private Byte[] m_contents;
    public DerUniversalString(Byte[] contents);
    internal DerUniversalString(Byte[] contents, bool clone);
    private static DerUniversalString();
    public static DerUniversalString GetInstance(object obj);
    public static DerUniversalString GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal static DerUniversalString CreatePrimitive(Byte[] contents);
    private static void EncodeHexByte(StringBuilder buf, int i);
    private static void EncodeHexDL(StringBuilder buf, int dl);
}
public class Org.BouncyCastle.Asn1.DerUtcTime : Asn1UtcTime {
    public DerUtcTime(string timeString);
    [ObsoleteAttribute("Use `DerUtcTime(DateTime, int)' instead")]
public DerUtcTime(DateTime dateTime);
    public DerUtcTime(DateTime dateTime, int twoDigitYearMax);
    internal DerUtcTime(Byte[] contents);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
}
public class Org.BouncyCastle.Asn1.DerUtf8String : DerStringBase {
    private Byte[] m_contents;
    public DerUtf8String(string str);
    public DerUtf8String(Byte[] contents);
    internal DerUtf8String(Byte[] contents, bool clone);
    public static DerUtf8String GetInstance(object obj);
    public static DerUtf8String GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    internal static DerUtf8String CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerVideotexString : DerStringBase {
    private Byte[] m_contents;
    public DerVideotexString(Byte[] contents);
    internal DerVideotexString(Byte[] contents, bool clone);
    public static DerVideotexString GetInstance(object obj);
    public static DerVideotexString GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal static DerVideotexString CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerVisibleString : DerStringBase {
    private Byte[] m_contents;
    public DerVisibleString(string str);
    public DerVisibleString(Byte[] contents);
    internal DerVisibleString(Byte[] contents, bool clone);
    public static DerVisibleString GetInstance(object obj);
    public static DerVisibleString GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal static DerVisibleString CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DLBitString : DerBitString {
    public DLBitString(byte data, int padBits);
    public DLBitString(Byte[] data);
    public DLBitString(Byte[] data, int padBits);
    public DLBitString(int namedBits);
    public DLBitString(Asn1Encodable obj);
    internal DLBitString(Byte[] contents, bool check);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
}
internal class Org.BouncyCastle.Asn1.DLBitStringParser : object {
    private DefiniteLengthInputStream m_stream;
    private int m_padBits;
    public int PadBits { get; }
    internal DLBitStringParser(DefiniteLengthInputStream stream);
    public sealed virtual Stream GetBitStream();
    public sealed virtual Stream GetOctetStream();
    public sealed virtual int get_PadBits();
    public sealed virtual Asn1Object ToAsn1Object();
    private Stream GetBitStream(bool octetAligned);
}
internal class Org.BouncyCastle.Asn1.DLExternal : DerExternal {
    internal DLExternal(Asn1EncodableVector vector);
    internal DLExternal(Asn1Sequence sequence);
    internal DLExternal(DerObjectIdentifier directReference, DerInteger indirectReference, Asn1ObjectDescriptor dataValueDescriptor, Asn1TaggedObject externalData);
    internal DLExternal(DerObjectIdentifier directReference, DerInteger indirectReference, Asn1ObjectDescriptor dataValueDescriptor, int encoding, Asn1Object externalData);
    internal virtual Asn1Sequence BuildSequence();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
}
internal class Org.BouncyCastle.Asn1.DLSequence : DerSequence {
    internal static DLSequence Empty;
    internal DLSequence(Asn1Encodable element);
    public DLSequence(Asn1Encodable element1, Asn1Encodable element2);
    internal DLSequence(Asn1Encodable[] elements);
    internal DLSequence(Asn1EncodableVector elementVector);
    internal DLSequence(Asn1Encodable[] elements, bool clone);
    private static DLSequence();
    internal static DLSequence FromVector(Asn1EncodableVector elementVector);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal virtual DerBitString ToAsn1BitString();
    internal virtual DerExternal ToAsn1External();
    internal virtual Asn1Set ToAsn1Set();
}
internal class Org.BouncyCastle.Asn1.DLSet : DerSet {
    internal static DLSet Empty;
    internal DLSet(Asn1Encodable element);
    internal DLSet(Asn1Encodable[] elements);
    internal DLSet(Asn1EncodableVector elementVector);
    internal DLSet(bool isSorted, Asn1Encodable[] elements);
    private static DLSet();
    internal static DLSet FromVector(Asn1EncodableVector elementVector);
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
}
internal class Org.BouncyCastle.Asn1.DLTaggedObject : DerTaggedObject {
    internal string Asn1Encoding { get; }
    internal DLTaggedObject(int tagNo, Asn1Encodable obj);
    internal DLTaggedObject(int tagClass, int tagNo, Asn1Encodable obj);
    internal DLTaggedObject(bool isExplicit, int tagNo, Asn1Encodable obj);
    internal DLTaggedObject(bool isExplicit, int tagClass, int tagNo, Asn1Encodable obj);
    internal DLTaggedObject(int explicitness, int tagClass, int tagNo, Asn1Encodable obj);
    internal virtual string get_Asn1Encoding();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal virtual Asn1Sequence RebuildConstructed(Asn1Object asn1Object);
    internal virtual Asn1TaggedObject ReplaceTag(int tagClass, int tagNo);
}
internal class Org.BouncyCastle.Asn1.DLTaggedObjectParser : BerTaggedObjectParser {
    private bool m_constructed;
    public bool IsConstructed { get; }
    internal DLTaggedObjectParser(int tagClass, int tagNo, bool constructed, Asn1StreamParser parser);
    public virtual bool get_IsConstructed();
    public virtual IAsn1Convertible ParseBaseUniversal(bool declaredExplicit, int baseTagNo);
    public virtual IAsn1Convertible ParseExplicitBaseObject();
    public virtual Asn1TaggedObjectParser ParseExplicitBaseTagged();
    public virtual Asn1TaggedObjectParser ParseImplicitBaseTagged(int baseTagClass, int baseTagNo);
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Eac.EacObjectIdentifiers : object {
    public static DerObjectIdentifier bsi_de;
    public static DerObjectIdentifier id_PK;
    public static DerObjectIdentifier id_PK_DH;
    public static DerObjectIdentifier id_PK_ECDH;
    public static DerObjectIdentifier id_CA;
    public static DerObjectIdentifier id_CA_DH;
    public static DerObjectIdentifier id_CA_DH_3DES_CBC_CBC;
    public static DerObjectIdentifier id_CA_ECDH;
    public static DerObjectIdentifier id_CA_ECDH_3DES_CBC_CBC;
    public static DerObjectIdentifier id_TA;
    public static DerObjectIdentifier id_TA_RSA;
    public static DerObjectIdentifier id_TA_RSA_v1_5_SHA_1;
    public static DerObjectIdentifier id_TA_RSA_v1_5_SHA_256;
    public static DerObjectIdentifier id_TA_RSA_PSS_SHA_1;
    public static DerObjectIdentifier id_TA_RSA_PSS_SHA_256;
    public static DerObjectIdentifier id_TA_ECDSA;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_1;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_224;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_256;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_384;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_512;
    private static EacObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.EdEC.EdECObjectIdentifiers : object {
    public static DerObjectIdentifier id_edwards_curve_algs;
    public static DerObjectIdentifier id_X25519;
    public static DerObjectIdentifier id_X448;
    public static DerObjectIdentifier id_Ed25519;
    public static DerObjectIdentifier id_Ed448;
    private static EdECObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Esf.CertificateValues : Asn1Encodable {
    private Asn1Sequence m_certificates;
    private CertificateValues(Asn1Sequence seq);
    public CertificateValues(X509CertificateStructure[] certificates);
    public CertificateValues(IEnumerable`1<X509CertificateStructure> certificates);
    public static CertificateValues GetInstance(object obj);
    public static CertificateValues GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public X509CertificateStructure[] GetCertificates();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Esf.CommitmentTypeIdentifier : object {
    public static DerObjectIdentifier ProofOfOrigin;
    public static DerObjectIdentifier ProofOfReceipt;
    public static DerObjectIdentifier ProofOfDelivery;
    public static DerObjectIdentifier ProofOfSender;
    public static DerObjectIdentifier ProofOfApproval;
    public static DerObjectIdentifier ProofOfCreation;
    private static CommitmentTypeIdentifier();
}
public class Org.BouncyCastle.Asn1.Esf.CommitmentTypeIndication : Asn1Encodable {
    private DerObjectIdentifier commitmentTypeId;
    private Asn1Sequence commitmentTypeQualifier;
    public DerObjectIdentifier CommitmentTypeID { get; }
    public Asn1Sequence CommitmentTypeQualifier { get; }
    public CommitmentTypeIndication(Asn1Sequence seq);
    public CommitmentTypeIndication(DerObjectIdentifier commitmentTypeId);
    public CommitmentTypeIndication(DerObjectIdentifier commitmentTypeId, Asn1Sequence commitmentTypeQualifier);
    public static CommitmentTypeIndication GetInstance(object obj);
    public DerObjectIdentifier get_CommitmentTypeID();
    public Asn1Sequence get_CommitmentTypeQualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier : Asn1Encodable {
    private DerObjectIdentifier commitmentTypeIdentifier;
    private Asn1Object qualifier;
    public DerObjectIdentifier CommitmentTypeIdentifier { get; }
    public Asn1Object Qualifier { get; }
    public CommitmentTypeQualifier(DerObjectIdentifier commitmentTypeIdentifier);
    public CommitmentTypeQualifier(DerObjectIdentifier commitmentTypeIdentifier, Asn1Encodable qualifier);
    public CommitmentTypeQualifier(Asn1Sequence seq);
    public static CommitmentTypeQualifier GetInstance(object obj);
    public DerObjectIdentifier get_CommitmentTypeIdentifier();
    public Asn1Object get_Qualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CompleteCertificateRefs : Asn1Encodable {
    private Asn1Sequence m_otherCertIDs;
    private CompleteCertificateRefs(Asn1Sequence seq);
    public CompleteCertificateRefs(OtherCertID[] otherCertIDs);
    public CompleteCertificateRefs(IEnumerable`1<OtherCertID> otherCertIDs);
    public static CompleteCertificateRefs GetInstance(object obj);
    public OtherCertID[] GetOtherCertIDs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CompleteRevocationRefs : Asn1Encodable {
    private Asn1Sequence m_crlOcspRefs;
    private CompleteRevocationRefs(Asn1Sequence seq);
    public CompleteRevocationRefs(CrlOcspRef[] crlOcspRefs);
    public CompleteRevocationRefs(IEnumerable`1<CrlOcspRef> crlOcspRefs);
    public static CompleteRevocationRefs GetInstance(object obj);
    public CrlOcspRef[] GetCrlOcspRefs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlIdentifier : Asn1Encodable {
    private X509Name m_crlIssuer;
    private Asn1UtcTime m_crlIssuedTime;
    private DerInteger m_crlNumber;
    public X509Name CrlIssuer { get; }
    public DateTime CrlIssuedTime { get; }
    public BigInteger CrlNumber { get; }
    private CrlIdentifier(Asn1Sequence seq);
    public CrlIdentifier(X509Name crlIssuer, DateTime crlIssuedTime);
    public CrlIdentifier(X509Name crlIssuer, DateTime crlIssuedTime, BigInteger crlNumber);
    public CrlIdentifier(X509Name crlIssuer, Asn1UtcTime crlIssuedTime);
    public CrlIdentifier(X509Name crlIssuer, Asn1UtcTime crlIssuedTime, BigInteger crlNumber);
    public static CrlIdentifier GetInstance(object obj);
    public static CrlIdentifier GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public X509Name get_CrlIssuer();
    public DateTime get_CrlIssuedTime();
    public BigInteger get_CrlNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlListID : Asn1Encodable {
    private Asn1Sequence m_crls;
    private CrlListID(Asn1Sequence seq);
    public CrlListID(CrlValidatedID[] crls);
    public CrlListID(IEnumerable`1<CrlValidatedID> crls);
    public static CrlListID GetInstance(object obj);
    public CrlValidatedID[] GetCrls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlOcspRef : Asn1Encodable {
    private CrlListID crlids;
    private OcspListID ocspids;
    private OtherRevRefs otherRev;
    public CrlListID CrlIDs { get; }
    public OcspListID OcspIDs { get; }
    public OtherRevRefs OtherRev { get; }
    private CrlOcspRef(Asn1Sequence seq);
    public CrlOcspRef(CrlListID crlids, OcspListID ocspids, OtherRevRefs otherRev);
    public static CrlOcspRef GetInstance(object obj);
    public CrlListID get_CrlIDs();
    public OcspListID get_OcspIDs();
    public OtherRevRefs get_OtherRev();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlValidatedID : Asn1Encodable {
    private OtherHash crlHash;
    private CrlIdentifier crlIdentifier;
    public OtherHash CrlHash { get; }
    public CrlIdentifier CrlIdentifier { get; }
    private CrlValidatedID(Asn1Sequence seq);
    public CrlValidatedID(OtherHash crlHash);
    public CrlValidatedID(OtherHash crlHash, CrlIdentifier crlIdentifier);
    public static CrlValidatedID GetInstance(object obj);
    public OtherHash get_CrlHash();
    public CrlIdentifier get_CrlIdentifier();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Esf.EsfAttributes : object {
    public static DerObjectIdentifier SigPolicyId;
    public static DerObjectIdentifier CommitmentType;
    public static DerObjectIdentifier SignerLocation;
    public static DerObjectIdentifier SignerAttr;
    public static DerObjectIdentifier OtherSigCert;
    public static DerObjectIdentifier ContentTimestamp;
    public static DerObjectIdentifier CertificateRefs;
    public static DerObjectIdentifier RevocationRefs;
    public static DerObjectIdentifier CertValues;
    public static DerObjectIdentifier RevocationValues;
    public static DerObjectIdentifier EscTimeStamp;
    public static DerObjectIdentifier CertCrlTimestamp;
    public static DerObjectIdentifier ArchiveTimestamp;
    public static DerObjectIdentifier ArchiveTimestampV2;
    private static EsfAttributes();
}
public class Org.BouncyCastle.Asn1.Esf.OcspIdentifier : Asn1Encodable {
    private ResponderID ocspResponderID;
    private Asn1GeneralizedTime producedAt;
    public ResponderID OcspResponderID { get; }
    public DateTime ProducedAt { get; }
    private OcspIdentifier(Asn1Sequence seq);
    public OcspIdentifier(ResponderID ocspResponderID, DateTime producedAt);
    public OcspIdentifier(ResponderID ocspResponderID, Asn1GeneralizedTime producedAt);
    public static OcspIdentifier GetInstance(object obj);
    public ResponderID get_OcspResponderID();
    public DateTime get_ProducedAt();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OcspListID : Asn1Encodable {
    private Asn1Sequence m_ocspResponses;
    private OcspListID(Asn1Sequence seq);
    public OcspListID(OcspResponsesID[] ocspResponses);
    public OcspListID(IEnumerable`1<OcspResponsesID> ocspResponses);
    public static OcspListID GetInstance(object obj);
    public OcspResponsesID[] GetOcspResponses();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OcspResponsesID : Asn1Encodable {
    private OcspIdentifier ocspIdentifier;
    private OtherHash ocspRepHash;
    public OcspIdentifier OcspIdentifier { get; }
    public OtherHash OcspRepHash { get; }
    private OcspResponsesID(Asn1Sequence seq);
    public OcspResponsesID(OcspIdentifier ocspIdentifier);
    public OcspResponsesID(OcspIdentifier ocspIdentifier, OtherHash ocspRepHash);
    public static OcspResponsesID GetInstance(object obj);
    public OcspIdentifier get_OcspIdentifier();
    public OtherHash get_OcspRepHash();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherCertID : Asn1Encodable {
    private OtherHash otherCertHash;
    private IssuerSerial issuerSerial;
    public OtherHash OtherCertHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private OtherCertID(Asn1Sequence seq);
    public OtherCertID(OtherHash otherCertHash);
    public OtherCertID(OtherHash otherCertHash, IssuerSerial issuerSerial);
    public static OtherCertID GetInstance(object obj);
    public OtherHash get_OtherCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherHash : Asn1Encodable {
    private Asn1OctetString sha1Hash;
    private OtherHashAlgAndValue otherHash;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public OtherHash(Byte[] sha1Hash);
    public OtherHash(Asn1OctetString sha1Hash);
    public OtherHash(OtherHashAlgAndValue otherHash);
    public static OtherHash GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherHashAlgAndValue : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString hashValue;
    public AlgorithmIdentifier HashAlgorithm { get; }
    private OtherHashAlgAndValue(Asn1Sequence seq);
    public OtherHashAlgAndValue(AlgorithmIdentifier hashAlgorithm, Byte[] hashValue);
    public OtherHashAlgAndValue(AlgorithmIdentifier hashAlgorithm, Asn1OctetString hashValue);
    public static OtherHashAlgAndValue GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherRevRefs : Asn1Encodable {
    private DerObjectIdentifier otherRevRefType;
    private Asn1Object otherRevRefs;
    public DerObjectIdentifier OtherRevRefType { get; }
    public Asn1Object OtherRevRefsObject { get; }
    private OtherRevRefs(Asn1Sequence seq);
    public OtherRevRefs(DerObjectIdentifier otherRevRefType, Asn1Encodable otherRevRefs);
    public static OtherRevRefs GetInstance(object obj);
    public DerObjectIdentifier get_OtherRevRefType();
    public Asn1Object get_OtherRevRefsObject();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherRevVals : Asn1Encodable {
    private DerObjectIdentifier otherRevValType;
    private Asn1Object otherRevVals;
    public DerObjectIdentifier OtherRevValType { get; }
    public Asn1Object OtherRevValsObject { get; }
    private OtherRevVals(Asn1Sequence seq);
    public OtherRevVals(DerObjectIdentifier otherRevValType, Asn1Encodable otherRevVals);
    public static OtherRevVals GetInstance(object obj);
    public DerObjectIdentifier get_OtherRevValType();
    public Asn1Object get_OtherRevValsObject();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherSigningCertificate : Asn1Encodable {
    private Asn1Sequence m_certs;
    private Asn1Sequence m_policies;
    private OtherSigningCertificate(Asn1Sequence seq);
    public OtherSigningCertificate(OtherCertID[] certs);
    public OtherSigningCertificate(OtherCertID[] certs, PolicyInformation[] policies);
    public OtherSigningCertificate(IEnumerable`1<OtherCertID> certs);
    public OtherSigningCertificate(IEnumerable`1<OtherCertID> certs, IEnumerable`1<PolicyInformation> policies);
    public static OtherSigningCertificate GetInstance(object obj);
    public OtherCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.RevocationValues : Asn1Encodable {
    private Asn1Sequence m_crlVals;
    private Asn1Sequence m_ocspVals;
    private OtherRevVals m_otherRevVals;
    public OtherRevVals OtherRevVals { get; }
    private RevocationValues(Asn1Sequence seq);
    public RevocationValues(CertificateList[] crlVals, BasicOcspResponse[] ocspVals, OtherRevVals otherRevVals);
    public RevocationValues(IEnumerable`1<CertificateList> crlVals, IEnumerable`1<BasicOcspResponse> ocspVals, OtherRevVals otherRevVals);
    public static RevocationValues GetInstance(object obj);
    public CertificateList[] GetCrlVals();
    public BasicOcspResponse[] GetOcspVals();
    public OtherRevVals get_OtherRevVals();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignaturePolicyId : Asn1Encodable {
    private DerObjectIdentifier m_sigPolicyIdentifier;
    private OtherHashAlgAndValue m_sigPolicyHash;
    private Asn1Sequence m_sigPolicyQualifiers;
    public DerObjectIdentifier SigPolicyIdentifier { get; }
    public OtherHashAlgAndValue SigPolicyHash { get; }
    private SignaturePolicyId(Asn1Sequence seq);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash, SigPolicyQualifierInfo[] sigPolicyQualifiers);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash, IEnumerable`1<SigPolicyQualifierInfo> sigPolicyQualifiers);
    public static SignaturePolicyId GetInstance(object obj);
    public DerObjectIdentifier get_SigPolicyIdentifier();
    public OtherHashAlgAndValue get_SigPolicyHash();
    public SigPolicyQualifierInfo[] GetSigPolicyQualifiers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignaturePolicyIdentifier : Asn1Encodable {
    private SignaturePolicyId sigPolicy;
    public SignaturePolicyId SignaturePolicyId { get; }
    public SignaturePolicyIdentifier(SignaturePolicyId signaturePolicyId);
    public static SignaturePolicyIdentifier GetInstance(object obj);
    public SignaturePolicyId get_SignaturePolicyId();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignerAttribute : Asn1Encodable {
    private Asn1Sequence claimedAttributes;
    private AttributeCertificate certifiedAttributes;
    public Asn1Sequence ClaimedAttributes { get; }
    public AttributeCertificate CertifiedAttributes { get; }
    private SignerAttribute(object obj);
    public SignerAttribute(Asn1Sequence claimedAttributes);
    public SignerAttribute(AttributeCertificate certifiedAttributes);
    public static SignerAttribute GetInstance(object obj);
    public virtual Asn1Sequence get_ClaimedAttributes();
    public virtual AttributeCertificate get_CertifiedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignerLocation : Asn1Encodable {
    private DirectoryString countryName;
    private DirectoryString localityName;
    private Asn1Sequence postalAddress;
    public DirectoryString Country { get; }
    public DirectoryString Locality { get; }
    public Asn1Sequence PostalAddress { get; }
    public SignerLocation(Asn1Sequence seq);
    private SignerLocation(DirectoryString countryName, DirectoryString localityName, Asn1Sequence postalAddress);
    public SignerLocation(DirectoryString countryName, DirectoryString localityName, DirectoryString[] postalAddress);
    public SignerLocation(DerUtf8String countryName, DerUtf8String localityName, Asn1Sequence postalAddress);
    public static SignerLocation GetInstance(object obj);
    public DirectoryString get_Country();
    public DirectoryString get_Locality();
    public DirectoryString[] GetPostal();
    public Asn1Sequence get_PostalAddress();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SigPolicyQualifierInfo : Asn1Encodable {
    private DerObjectIdentifier sigPolicyQualifierId;
    private Asn1Object sigQualifier;
    public DerObjectIdentifier SigPolicyQualifierId { get; }
    public Asn1Object SigQualifier { get; }
    private SigPolicyQualifierInfo(Asn1Sequence seq);
    public SigPolicyQualifierInfo(DerObjectIdentifier sigPolicyQualifierId, Asn1Encodable sigQualifier);
    public static SigPolicyQualifierInfo GetInstance(object obj);
    public DerObjectIdentifier get_SigPolicyQualifierId();
    public Asn1Object get_SigQualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.ContentHints : Asn1Encodable {
    private DerUtf8String contentDescription;
    private DerObjectIdentifier contentType;
    public DerObjectIdentifier ContentType { get; }
    public DerUtf8String ContentDescription { get; }
    private ContentHints(Asn1Sequence seq);
    public ContentHints(DerObjectIdentifier contentType);
    public ContentHints(DerObjectIdentifier contentType, DerUtf8String contentDescription);
    public static ContentHints GetInstance(object o);
    public DerObjectIdentifier get_ContentType();
    public DerUtf8String get_ContentDescription();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.ContentIdentifier : Asn1Encodable {
    private Asn1OctetString value;
    public Asn1OctetString Value { get; }
    public ContentIdentifier(Asn1OctetString value);
    public ContentIdentifier(Byte[] value);
    public static ContentIdentifier GetInstance(object o);
    public Asn1OctetString get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.EssCertID : Asn1Encodable {
    private Asn1OctetString certHash;
    private IssuerSerial issuerSerial;
    public IssuerSerial IssuerSerial { get; }
    public EssCertID(Asn1Sequence seq);
    public EssCertID(Byte[] hash);
    public EssCertID(Byte[] hash, IssuerSerial issuerSerial);
    public static EssCertID GetInstance(object o);
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.EssCertIDv2 : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] certHash;
    private IssuerSerial issuerSerial;
    private static AlgorithmIdentifier DefaultAlgID;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertIDv2(Asn1Sequence seq);
    public EssCertIDv2(Byte[] certHash);
    public EssCertIDv2(AlgorithmIdentifier algId, Byte[] certHash);
    public EssCertIDv2(Byte[] certHash, IssuerSerial issuerSerial);
    public EssCertIDv2(AlgorithmIdentifier algId, Byte[] certHash, IssuerSerial issuerSerial);
    private static EssCertIDv2();
    public static EssCertIDv2 GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.SigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    public SigningCertificate(Asn1Sequence seq);
    public SigningCertificate(EssCertID essCertID);
    public static SigningCertificate GetInstance(object o);
    public EssCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.SigningCertificateV2 : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    private SigningCertificateV2(Asn1Sequence seq);
    public SigningCertificateV2(EssCertIDv2 cert);
    public SigningCertificateV2(EssCertIDv2[] certs);
    public SigningCertificateV2(EssCertIDv2[] certs, PolicyInformation[] policies);
    public static SigningCertificateV2 GetInstance(object o);
    public EssCertIDv2[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public static class Org.BouncyCastle.Asn1.GM.GMNamedCurves : object {
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, X9ECParametersHolder> curves;
    private static Dictionary`2<DerObjectIdentifier, string> names;
    public static IEnumerable`1<string> Names { get; }
    private static GMNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public abstract class Org.BouncyCastle.Asn1.GM.GMObjectIdentifiers : object {
    public static DerObjectIdentifier sm_scheme;
    public static DerObjectIdentifier sm6_ecb;
    public static DerObjectIdentifier sm6_cbc;
    public static DerObjectIdentifier sm6_ofb128;
    public static DerObjectIdentifier sm6_cfb128;
    public static DerObjectIdentifier sm1_ecb;
    public static DerObjectIdentifier sm1_cbc;
    public static DerObjectIdentifier sm1_ofb128;
    public static DerObjectIdentifier sm1_cfb128;
    public static DerObjectIdentifier sm1_cfb1;
    public static DerObjectIdentifier sm1_cfb8;
    public static DerObjectIdentifier ssf33_ecb;
    public static DerObjectIdentifier ssf33_cbc;
    public static DerObjectIdentifier ssf33_ofb128;
    public static DerObjectIdentifier ssf33_cfb128;
    public static DerObjectIdentifier ssf33_cfb1;
    public static DerObjectIdentifier ssf33_cfb8;
    public static DerObjectIdentifier sms4_ecb;
    public static DerObjectIdentifier sms4_cbc;
    public static DerObjectIdentifier sms4_ofb128;
    public static DerObjectIdentifier sms4_cfb128;
    public static DerObjectIdentifier sms4_cfb1;
    public static DerObjectIdentifier sms4_cfb8;
    public static DerObjectIdentifier sms4_ctr;
    public static DerObjectIdentifier sms4_gcm;
    public static DerObjectIdentifier sms4_ccm;
    public static DerObjectIdentifier sms4_xts;
    public static DerObjectIdentifier sms4_wrap;
    public static DerObjectIdentifier sms4_wrap_pad;
    public static DerObjectIdentifier sms4_ocb;
    public static DerObjectIdentifier sm5;
    public static DerObjectIdentifier sm2p256v1;
    public static DerObjectIdentifier sm2sign;
    public static DerObjectIdentifier sm2exchange;
    public static DerObjectIdentifier sm2encrypt;
    public static DerObjectIdentifier wapip192v1;
    public static DerObjectIdentifier sm2encrypt_recommendedParameters;
    public static DerObjectIdentifier sm2encrypt_specifiedParameters;
    public static DerObjectIdentifier sm2encrypt_with_sm3;
    public static DerObjectIdentifier sm2encrypt_with_sha1;
    public static DerObjectIdentifier sm2encrypt_with_sha224;
    public static DerObjectIdentifier sm2encrypt_with_sha256;
    public static DerObjectIdentifier sm2encrypt_with_sha384;
    public static DerObjectIdentifier sm2encrypt_with_sha512;
    public static DerObjectIdentifier sm2encrypt_with_rmd160;
    public static DerObjectIdentifier sm2encrypt_with_whirlpool;
    public static DerObjectIdentifier sm2encrypt_with_blake2b512;
    public static DerObjectIdentifier sm2encrypt_with_blake2s256;
    public static DerObjectIdentifier sm2encrypt_with_md5;
    public static DerObjectIdentifier id_sm9PublicKey;
    public static DerObjectIdentifier sm9sign;
    public static DerObjectIdentifier sm9keyagreement;
    public static DerObjectIdentifier sm9encrypt;
    public static DerObjectIdentifier sm3;
    public static DerObjectIdentifier hmac_sm3;
    public static DerObjectIdentifier sm2sign_with_sm3;
    public static DerObjectIdentifier sm2sign_with_sha1;
    public static DerObjectIdentifier sm2sign_with_sha256;
    public static DerObjectIdentifier sm2sign_with_sha512;
    public static DerObjectIdentifier sm2sign_with_sha224;
    public static DerObjectIdentifier sm2sign_with_sha384;
    public static DerObjectIdentifier sm2sign_with_rmd160;
    public static DerObjectIdentifier sm2sign_with_whirlpool;
    public static DerObjectIdentifier sm2sign_with_blake2b512;
    public static DerObjectIdentifier sm2sign_with_blake2s256;
    private static GMObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Gnu.GnuObjectIdentifiers : object {
    public static DerObjectIdentifier Gnu;
    public static DerObjectIdentifier GnuPG;
    public static DerObjectIdentifier Notation;
    public static DerObjectIdentifier PkaAddress;
    public static DerObjectIdentifier GnuRadar;
    public static DerObjectIdentifier DigestAlgorithm;
    public static DerObjectIdentifier Tiger192;
    public static DerObjectIdentifier EncryptionAlgorithm;
    public static DerObjectIdentifier Serpent;
    public static DerObjectIdentifier Serpent128Ecb;
    public static DerObjectIdentifier Serpent128Cbc;
    public static DerObjectIdentifier Serpent128Ofb;
    public static DerObjectIdentifier Serpent128Cfb;
    public static DerObjectIdentifier Serpent192Ecb;
    public static DerObjectIdentifier Serpent192Cbc;
    public static DerObjectIdentifier Serpent192Ofb;
    public static DerObjectIdentifier Serpent192Cfb;
    public static DerObjectIdentifier Serpent256Ecb;
    public static DerObjectIdentifier Serpent256Cbc;
    public static DerObjectIdentifier Serpent256Ofb;
    public static DerObjectIdentifier Serpent256Cfb;
    public static DerObjectIdentifier Crc;
    public static DerObjectIdentifier Crc32;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier Ed25519;
    private static GnuObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Iana.IanaObjectIdentifiers : object {
    public static DerObjectIdentifier IsakmpOakley;
    public static DerObjectIdentifier HmacMD5;
    public static DerObjectIdentifier HmacSha1;
    public static DerObjectIdentifier HmacTiger;
    public static DerObjectIdentifier HmacRipeMD160;
    private static IanaObjectIdentifiers();
}
public interface Org.BouncyCastle.Asn1.IAsn1Choice {
}
public interface Org.BouncyCastle.Asn1.IAsn1Convertible {
    public abstract virtual Asn1Object ToAsn1Object();
}
internal interface Org.BouncyCastle.Asn1.IAsn1Encoding {
    public abstract virtual void Encode(Asn1OutputStream asn1Out);
    public abstract virtual int GetLength();
}
public interface Org.BouncyCastle.Asn1.IAsn1String {
    public abstract virtual string GetString();
}
public class Org.BouncyCastle.Asn1.Icao.CscaMasterList : Asn1Encodable {
    private DerInteger version;
    private X509CertificateStructure[] certList;
    public int Version { get; }
    private CscaMasterList(Asn1Sequence seq);
    public CscaMasterList(X509CertificateStructure[] certStructs);
    public static CscaMasterList GetInstance(object obj);
    public virtual int get_Version();
    public X509CertificateStructure[] GetCertStructs();
    private static X509CertificateStructure[] CopyCertList(X509CertificateStructure[] orig);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Icao.DataGroupHash : Asn1Encodable {
    private DerInteger dataGroupNumber;
    private Asn1OctetString dataGroupHashValue;
    public int DataGroupNumber { get; }
    public Asn1OctetString DataGroupHashValue { get; }
    private DataGroupHash(Asn1Sequence seq);
    public DataGroupHash(int dataGroupNumber, Asn1OctetString dataGroupHashValue);
    public static DataGroupHash GetInstance(object obj);
    public int get_DataGroupNumber();
    public Asn1OctetString get_DataGroupHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Icao.IcaoObjectIdentifiers : object {
    public static DerObjectIdentifier IdIcao;
    public static DerObjectIdentifier IdIcaoMrtd;
    public static DerObjectIdentifier IdIcaoMrtdSecurity;
    public static DerObjectIdentifier IdIcaoLdsSecurityObject;
    public static DerObjectIdentifier IdIcaoCscaMasterList;
    public static DerObjectIdentifier IdIcaoCscaMasterListSigningKey;
    public static DerObjectIdentifier IdIcaoDocumentTypeList;
    public static DerObjectIdentifier IdIcaoAAProtocolObject;
    public static DerObjectIdentifier IdIcaoExtensions;
    public static DerObjectIdentifier IdIcaoExtensionsNamechangekeyrollover;
    private static IcaoObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Icao.LdsSecurityObject : Asn1Encodable {
    public static int UBDataGroups;
    private DerInteger version;
    private AlgorithmIdentifier digestAlgorithmIdentifier;
    private DataGroupHash[] datagroupHash;
    private LdsVersionInfo versionInfo;
    public BigInteger Version { get; }
    public AlgorithmIdentifier DigestAlgorithmIdentifier { get; }
    public LdsVersionInfo VersionInfo { get; }
    private LdsSecurityObject(Asn1Sequence seq);
    public LdsSecurityObject(AlgorithmIdentifier digestAlgorithmIdentifier, DataGroupHash[] datagroupHash);
    public LdsSecurityObject(AlgorithmIdentifier digestAlgorithmIdentifier, DataGroupHash[] datagroupHash, LdsVersionInfo versionInfo);
    public static LdsSecurityObject GetInstance(object obj);
    private void CheckDatagroupHashSeqSize(int size);
    public BigInteger get_Version();
    public AlgorithmIdentifier get_DigestAlgorithmIdentifier();
    public DataGroupHash[] GetDatagroupHash();
    public LdsVersionInfo get_VersionInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Icao.LdsVersionInfo : Asn1Encodable {
    private DerPrintableString ldsVersion;
    private DerPrintableString unicodeVersion;
    public LdsVersionInfo(string ldsVersion, string unicodeVersion);
    private LdsVersionInfo(Asn1Sequence seq);
    public static LdsVersionInfo GetInstance(object obj);
    public virtual string GetLdsVersion();
    public virtual string GetUnicodeVersion();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.IndefiniteLengthInputStream : LimitedInputStream {
    private int _lookAhead;
    private bool _eofOn00;
    internal IndefiniteLengthInputStream(Stream inStream, int limit);
    internal void SetEofOn00(bool eofOn00);
    private void CheckEndOfContents();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private int RequireByte();
}
public abstract class Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers : object {
    public static DerObjectIdentifier IdIsisMtt;
    public static DerObjectIdentifier IdIsisMttCP;
    public static DerObjectIdentifier IdIsisMttCPAccredited;
    public static DerObjectIdentifier IdIsisMttAT;
    public static DerObjectIdentifier IdIsisMttATDateOfCertGen;
    public static DerObjectIdentifier IdIsisMttATProcuration;
    public static DerObjectIdentifier IdIsisMttATAdmission;
    public static DerObjectIdentifier IdIsisMttATMonetaryLimit;
    public static DerObjectIdentifier IdIsisMttATDeclarationOfMajority;
    public static DerObjectIdentifier IdIsisMttATIccsn;
    public static DerObjectIdentifier IdIsisMttATPKReference;
    public static DerObjectIdentifier IdIsisMttATRestriction;
    public static DerObjectIdentifier IdIsisMttATRetrieveIfAllowed;
    public static DerObjectIdentifier IdIsisMttATRequestedCertificate;
    public static DerObjectIdentifier IdIsisMttATNamingAuthorities;
    public static DerObjectIdentifier IdIsisMttATCertInDirSince;
    public static DerObjectIdentifier IdIsisMttATCertHash;
    public static DerObjectIdentifier IdIsisMttATNameAtBirth;
    public static DerObjectIdentifier IdIsisMttATAdditionalInformation;
    public static DerObjectIdentifier IdIsisMttATLiabilityLimitationFlag;
    private static IsisMttObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] certificateHash;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] CertificateHash { get; }
    private CertHash(Asn1Sequence seq);
    public CertHash(AlgorithmIdentifier hashAlgorithm, Byte[] certificateHash);
    public static CertHash GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] get_CertificateHash();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate : Asn1Encodable {
    private X509CertificateStructure cert;
    private Byte[] publicKeyCert;
    private Byte[] attributeCert;
    public Choice Type { get; }
    private RequestedCertificate(Asn1TaggedObject tagged);
    public RequestedCertificate(X509CertificateStructure certificate);
    public RequestedCertificate(Choice type, Byte[] certificateOctets);
    public static RequestedCertificate GetInstance(object obj);
    public static RequestedCertificate GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public Choice get_Type();
    public Byte[] GetCertificateBytes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax : Asn1Encodable {
    private DirectoryString information;
    public DirectoryString Information { get; }
    private AdditionalInformationSyntax(DirectoryString information);
    public AdditionalInformationSyntax(string information);
    public static AdditionalInformationSyntax GetInstance(object obj);
    public virtual DirectoryString get_Information();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions : Asn1Encodable {
    private GeneralName admissionAuthority;
    private NamingAuthority namingAuthority;
    private Asn1Sequence professionInfos;
    public GeneralName AdmissionAuthority { get; }
    public NamingAuthority NamingAuthority { get; }
    private Admissions(Asn1Sequence seq);
    public Admissions(GeneralName admissionAuthority, NamingAuthority namingAuthority, ProfessionInfo[] professionInfos);
    public static Admissions GetInstance(object obj);
    public virtual GeneralName get_AdmissionAuthority();
    public virtual NamingAuthority get_NamingAuthority();
    public ProfessionInfo[] GetProfessionInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax : Asn1Encodable {
    private GeneralName admissionAuthority;
    private Asn1Sequence contentsOfAdmissions;
    public GeneralName AdmissionAuthority { get; }
    private AdmissionSyntax(Asn1Sequence seq);
    public AdmissionSyntax(GeneralName admissionAuthority, Asn1Sequence contentsOfAdmissions);
    public static AdmissionSyntax GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual GeneralName get_AdmissionAuthority();
    public virtual Admissions[] GetContentsOfAdmissions();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority : Asn1Encodable {
    private Asn1TaggedObject m_declaration;
    public Choice Type { get; }
    public int NotYoungerThan { get; }
    public Asn1Sequence FullAgeAtCountry { get; }
    public Asn1GeneralizedTime DateOfBirth { get; }
    public DeclarationOfMajority(int notYoungerThan);
    public DeclarationOfMajority(bool fullAge, string country);
    public DeclarationOfMajority(Asn1GeneralizedTime dateOfBirth);
    private DeclarationOfMajority(Asn1TaggedObject o);
    public static DeclarationOfMajority GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public Choice get_Type();
    public virtual int get_NotYoungerThan();
    public virtual Asn1Sequence get_FullAgeAtCountry();
    public virtual Asn1GeneralizedTime get_DateOfBirth();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit : Asn1Encodable {
    private DerPrintableString currency;
    private DerInteger amount;
    private DerInteger exponent;
    public string Currency { get; }
    public BigInteger Amount { get; }
    public BigInteger Exponent { get; }
    private MonetaryLimit(Asn1Sequence seq);
    public MonetaryLimit(string currency, int amount, int exponent);
    public static MonetaryLimit GetInstance(object obj);
    public virtual string get_Currency();
    public virtual BigInteger get_Amount();
    public virtual BigInteger get_Exponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority : Asn1Encodable {
    public static DerObjectIdentifier IdIsisMttATNamingAuthoritiesRechtWirtschaftSteuern;
    private DerObjectIdentifier namingAuthorityID;
    private string namingAuthorityUrl;
    private DirectoryString namingAuthorityText;
    public DerObjectIdentifier NamingAuthorityID { get; }
    public DirectoryString NamingAuthorityText { get; }
    public string NamingAuthorityUrl { get; }
    private NamingAuthority(Asn1Sequence seq);
    public NamingAuthority(DerObjectIdentifier namingAuthorityID, string namingAuthorityUrl, DirectoryString namingAuthorityText);
    private static NamingAuthority();
    public static NamingAuthority GetInstance(object obj);
    public static NamingAuthority GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual DerObjectIdentifier get_NamingAuthorityID();
    public virtual DirectoryString get_NamingAuthorityText();
    public virtual string get_NamingAuthorityUrl();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax : Asn1Encodable {
    private string country;
    private DirectoryString typeOfSubstitution;
    private GeneralName thirdPerson;
    private IssuerSerial certRef;
    public string Country { get; }
    public DirectoryString TypeOfSubstitution { get; }
    public GeneralName ThirdPerson { get; }
    public IssuerSerial CertRef { get; }
    private ProcurationSyntax(Asn1Sequence seq);
    public ProcurationSyntax(string country, DirectoryString typeOfSubstitution, IssuerSerial certRef);
    public ProcurationSyntax(string country, DirectoryString typeOfSubstitution, GeneralName thirdPerson);
    public static ProcurationSyntax GetInstance(object obj);
    public virtual string get_Country();
    public virtual DirectoryString get_TypeOfSubstitution();
    public virtual GeneralName get_ThirdPerson();
    public virtual IssuerSerial get_CertRef();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo : Asn1Encodable {
    public static DerObjectIdentifier Rechtsanwltin;
    public static DerObjectIdentifier Rechtsanwalt;
    public static DerObjectIdentifier Rechtsbeistand;
    public static DerObjectIdentifier Steuerberaterin;
    public static DerObjectIdentifier Steuerberater;
    public static DerObjectIdentifier Steuerbevollmchtigte;
    public static DerObjectIdentifier Steuerbevollmchtigter;
    public static DerObjectIdentifier Notarin;
    public static DerObjectIdentifier Notar;
    public static DerObjectIdentifier Notarvertreterin;
    public static DerObjectIdentifier Notarvertreter;
    public static DerObjectIdentifier Notariatsverwalterin;
    public static DerObjectIdentifier Notariatsverwalter;
    public static DerObjectIdentifier Wirtschaftsprferin;
    public static DerObjectIdentifier Wirtschaftsprfer;
    public static DerObjectIdentifier VereidigteBuchprferin;
    public static DerObjectIdentifier VereidigterBuchprfer;
    public static DerObjectIdentifier Patentanwltin;
    public static DerObjectIdentifier Patentanwalt;
    private NamingAuthority namingAuthority;
    private Asn1Sequence professionItems;
    private Asn1Sequence professionOids;
    private string registrationNumber;
    private Asn1OctetString addProfessionInfo;
    public Asn1OctetString AddProfessionInfo { get; }
    public NamingAuthority NamingAuthority { get; }
    public string RegistrationNumber { get; }
    private ProfessionInfo(Asn1Sequence seq);
    public ProfessionInfo(NamingAuthority namingAuthority, DirectoryString[] professionItems, DerObjectIdentifier[] professionOids, string registrationNumber, Asn1OctetString addProfessionInfo);
    private static ProfessionInfo();
    public static ProfessionInfo GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual Asn1OctetString get_AddProfessionInfo();
    public virtual NamingAuthority get_NamingAuthority();
    public virtual DirectoryString[] GetProfessionItems();
    public virtual DerObjectIdentifier[] GetProfessionOids();
    public virtual string get_RegistrationNumber();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction : Asn1Encodable {
    private DirectoryString restriction;
    public DirectoryString RestrictionString { get; }
    private Restriction(DirectoryString restriction);
    public Restriction(string restriction);
    public static Restriction GetInstance(object obj);
    public virtual DirectoryString get_RestrictionString();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Kisa.KisaObjectIdentifiers : object {
    public static DerObjectIdentifier IdSeedCbc;
    public static DerObjectIdentifier IdNpkiAppCmsSeedWrap;
    private static KisaObjectIdentifiers();
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Asn1.LazyAsn1InputStream : Asn1InputStream {
    public LazyAsn1InputStream(Byte[] input);
    public LazyAsn1InputStream(Stream inputStream);
    public LazyAsn1InputStream(Stream input, int limit);
    public LazyAsn1InputStream(Stream input, int limit, bool leaveOpen);
}
internal abstract class Org.BouncyCastle.Asn1.LimitedInputStream : BaseInputStream {
    protected Stream _in;
    private int _limit;
    internal int Limit { get; }
    internal LimitedInputStream(Stream inStream, int limit);
    internal virtual int get_Limit();
    protected void SetParentEofDetect();
}
public abstract class Org.BouncyCastle.Asn1.Microsoft.MicrosoftObjectIdentifiers : object {
    public static DerObjectIdentifier Microsoft;
    public static DerObjectIdentifier MicrosoftCertTemplateV1;
    public static DerObjectIdentifier MicrosoftCAVersion;
    public static DerObjectIdentifier MicrosoftPrevCACertHash;
    public static DerObjectIdentifier MicrosoftCrlNextPublish;
    public static DerObjectIdentifier MicrosoftCertTemplateV2;
    public static DerObjectIdentifier MicrosoftAppPolicies;
    private static MicrosoftObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Misc.Cast5CbcParameters : Asn1Encodable {
    private DerInteger keyLength;
    private Asn1OctetString iv;
    public int KeyLength { get; }
    public Cast5CbcParameters(Byte[] iv, int keyLength);
    private Cast5CbcParameters(Asn1Sequence seq);
    public static Cast5CbcParameters GetInstance(object o);
    public Byte[] GetIV();
    public int get_KeyLength();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Misc.IdeaCbcPar : Asn1Encodable {
    internal Asn1OctetString iv;
    public IdeaCbcPar(Byte[] iv);
    private IdeaCbcPar(Asn1Sequence seq);
    public static IdeaCbcPar GetInstance(object o);
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Misc.MiscObjectIdentifiers : object {
    public static DerObjectIdentifier Netscape;
    public static DerObjectIdentifier NetscapeCertType;
    public static DerObjectIdentifier NetscapeBaseUrl;
    public static DerObjectIdentifier NetscapeRevocationUrl;
    public static DerObjectIdentifier NetscapeCARevocationUrl;
    public static DerObjectIdentifier NetscapeRenewalUrl;
    public static DerObjectIdentifier NetscapeCAPolicyUrl;
    public static DerObjectIdentifier NetscapeSslServerName;
    public static DerObjectIdentifier NetscapeCertComment;
    public static DerObjectIdentifier Verisign;
    public static DerObjectIdentifier VerisignCzagExtension;
    public static DerObjectIdentifier VerisignPrivate_6_9;
    public static DerObjectIdentifier VerisignOnSiteJurisdictionHash;
    public static DerObjectIdentifier VerisignBitString_6_13;
    public static DerObjectIdentifier VerisignDnbDunsNumber;
    public static DerObjectIdentifier VerisignIssStrongCrypto;
    public static DerObjectIdentifier Novell;
    public static DerObjectIdentifier NovellSecurityAttribs;
    public static DerObjectIdentifier Entrust;
    public static DerObjectIdentifier EntrustVersionExtension;
    public static DerObjectIdentifier cast5CBC;
    public static DerObjectIdentifier HMAC_SHA1;
    public static DerObjectIdentifier as_sys_sec_alg_ideaCBC;
    public static DerObjectIdentifier cryptlib;
    public static DerObjectIdentifier cryptlib_algorithm;
    public static DerObjectIdentifier cryptlib_algorithm_blowfish_ECB;
    public static DerObjectIdentifier cryptlib_algorithm_blowfish_CBC;
    public static DerObjectIdentifier cryptlib_algorithm_blowfish_CFB;
    public static DerObjectIdentifier cryptlib_algorithm_blowfish_OFB;
    public static DerObjectIdentifier blake2;
    public static DerObjectIdentifier id_blake2b160;
    public static DerObjectIdentifier id_blake2b256;
    public static DerObjectIdentifier id_blake2b384;
    public static DerObjectIdentifier id_blake2b512;
    public static DerObjectIdentifier id_blake2s128;
    public static DerObjectIdentifier id_blake2s160;
    public static DerObjectIdentifier id_blake2s224;
    public static DerObjectIdentifier id_blake2s256;
    public static DerObjectIdentifier blake3;
    public static DerObjectIdentifier blake3_256;
    public static DerObjectIdentifier id_scrypt;
    public static DerObjectIdentifier id_alg_composite;
    public static DerObjectIdentifier id_composite_key;
    public static DerObjectIdentifier id_oracle_pkcs12_trusted_key_usage;
    private static MiscObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Misc.NetscapeCertType : DerBitString {
    public static int SslClient;
    public static int SslServer;
    public static int Smime;
    public static int ObjectSigning;
    public static int Reserved;
    public static int SslCA;
    public static int SmimeCA;
    public static int ObjectSigningCA;
    public NetscapeCertType(int usage);
    public NetscapeCertType(DerBitString usage);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Misc.NetscapeRevocationUrl : DerIA5String {
    public NetscapeRevocationUrl(DerIA5String str);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Misc.VerisignCzagExtension : DerIA5String {
    public VerisignCzagExtension(DerIA5String str);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Mozilla.PublicKeyAndChallenge : Asn1Encodable {
    private Asn1Sequence pkacSeq;
    private SubjectPublicKeyInfo spki;
    private DerIA5String challenge;
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public DerIA5String Challenge { get; }
    public PublicKeyAndChallenge(Asn1Sequence seq);
    public static PublicKeyAndChallenge GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public DerIA5String get_Challenge();
}
public class Org.BouncyCastle.Asn1.Nist.KMacWithShake128Params : Asn1Encodable {
    private static Byte[] EMPTY_STRING;
    private static int DEF_LENGTH;
    private int outputLength;
    private Byte[] customizationString;
    public int OutputLength { get; }
    public Byte[] CustomizationString { get; }
    public KMacWithShake128Params(int outputLength);
    public KMacWithShake128Params(int outputLength, Byte[] customizationString);
    private KMacWithShake128Params(Asn1Sequence seq);
    private static KMacWithShake128Params();
    public static KMacWithShake128Params GetInstance(object o);
    public int get_OutputLength();
    public Byte[] get_CustomizationString();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Nist.KMacWithShake256Params : Asn1Encodable {
    private static Byte[] EMPTY_STRING;
    private static int DEF_LENGTH;
    private int outputLength;
    private Byte[] customizationString;
    public int OutputLength { get; }
    public Byte[] CustomizationString { get; }
    public KMacWithShake256Params(int outputLength);
    public KMacWithShake256Params(int outputLength, Byte[] customizationString);
    private KMacWithShake256Params(Asn1Sequence seq);
    private static KMacWithShake256Params();
    public static KMacWithShake256Params GetInstance(object o);
    public int get_OutputLength();
    public Byte[] get_CustomizationString();
    public virtual Asn1Object ToAsn1Object();
}
public static class Org.BouncyCastle.Asn1.Nist.NistNamedCurves : object {
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, string> names;
    public static IEnumerable`1<string> Names { get; }
    private static NistNamedCurves();
    private static void DefineCurveAlias(string name, DerObjectIdentifier oid);
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public class Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers : object {
    public static DerObjectIdentifier NistAlgorithm;
    public static DerObjectIdentifier HashAlgs;
    public static DerObjectIdentifier IdSha256;
    public static DerObjectIdentifier IdSha384;
    public static DerObjectIdentifier IdSha512;
    public static DerObjectIdentifier IdSha224;
    public static DerObjectIdentifier IdSha512_224;
    public static DerObjectIdentifier IdSha512_256;
    public static DerObjectIdentifier IdSha3_224;
    public static DerObjectIdentifier IdSha3_256;
    public static DerObjectIdentifier IdSha3_384;
    public static DerObjectIdentifier IdSha3_512;
    public static DerObjectIdentifier IdShake128;
    public static DerObjectIdentifier IdShake256;
    public static DerObjectIdentifier IdHMacWithSha3_224;
    public static DerObjectIdentifier IdHMacWithSha3_256;
    public static DerObjectIdentifier IdHMacWithSha3_384;
    public static DerObjectIdentifier IdHMacWithSha3_512;
    public static DerObjectIdentifier IdShake128Len;
    public static DerObjectIdentifier IdShake256Len;
    public static DerObjectIdentifier IdKmacWithShake128;
    public static DerObjectIdentifier IdKmacWithShake256;
    public static DerObjectIdentifier Aes;
    public static DerObjectIdentifier IdAes128Ecb;
    public static DerObjectIdentifier IdAes128Cbc;
    public static DerObjectIdentifier IdAes128Ofb;
    public static DerObjectIdentifier IdAes128Cfb;
    public static DerObjectIdentifier IdAes128Wrap;
    public static DerObjectIdentifier IdAes128Gcm;
    public static DerObjectIdentifier IdAes128Ccm;
    public static DerObjectIdentifier IdAes192Ecb;
    public static DerObjectIdentifier IdAes192Cbc;
    public static DerObjectIdentifier IdAes192Ofb;
    public static DerObjectIdentifier IdAes192Cfb;
    public static DerObjectIdentifier IdAes192Wrap;
    public static DerObjectIdentifier IdAes192Gcm;
    public static DerObjectIdentifier IdAes192Ccm;
    public static DerObjectIdentifier IdAes256Ecb;
    public static DerObjectIdentifier IdAes256Cbc;
    public static DerObjectIdentifier IdAes256Ofb;
    public static DerObjectIdentifier IdAes256Cfb;
    public static DerObjectIdentifier IdAes256Wrap;
    public static DerObjectIdentifier IdAes256Gcm;
    public static DerObjectIdentifier IdAes256Ccm;
    public static DerObjectIdentifier IdDsaWithSha2;
    public static DerObjectIdentifier DsaWithSha224;
    public static DerObjectIdentifier DsaWithSha256;
    public static DerObjectIdentifier DsaWithSha384;
    public static DerObjectIdentifier DsaWithSha512;
    public static DerObjectIdentifier IdDsaWithSha3_224;
    public static DerObjectIdentifier IdDsaWithSha3_256;
    public static DerObjectIdentifier IdDsaWithSha3_384;
    public static DerObjectIdentifier IdDsaWithSha3_512;
    public static DerObjectIdentifier IdEcdsaWithSha3_224;
    public static DerObjectIdentifier IdEcdsaWithSha3_256;
    public static DerObjectIdentifier IdEcdsaWithSha3_384;
    public static DerObjectIdentifier IdEcdsaWithSha3_512;
    public static DerObjectIdentifier IdRsassaPkcs1V15WithSha3_224;
    public static DerObjectIdentifier IdRsassaPkcs1V15WithSha3_256;
    public static DerObjectIdentifier IdRsassaPkcs1V15WithSha3_384;
    public static DerObjectIdentifier IdRsassaPkcs1V15WithSha3_512;
    private static NistObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Nsri.NsriObjectIdentifiers : object {
    public static DerObjectIdentifier nsri;
    public static DerObjectIdentifier id_algorithm;
    public static DerObjectIdentifier id_sea;
    public static DerObjectIdentifier id_pad;
    public static DerObjectIdentifier id_pad_null;
    public static DerObjectIdentifier id_pad_1;
    public static DerObjectIdentifier id_aria128_ecb;
    public static DerObjectIdentifier id_aria128_cbc;
    public static DerObjectIdentifier id_aria128_cfb;
    public static DerObjectIdentifier id_aria128_ofb;
    public static DerObjectIdentifier id_aria128_ctr;
    public static DerObjectIdentifier id_aria192_ecb;
    public static DerObjectIdentifier id_aria192_cbc;
    public static DerObjectIdentifier id_aria192_cfb;
    public static DerObjectIdentifier id_aria192_ofb;
    public static DerObjectIdentifier id_aria192_ctr;
    public static DerObjectIdentifier id_aria256_ecb;
    public static DerObjectIdentifier id_aria256_cbc;
    public static DerObjectIdentifier id_aria256_cfb;
    public static DerObjectIdentifier id_aria256_ofb;
    public static DerObjectIdentifier id_aria256_ctr;
    public static DerObjectIdentifier id_aria128_cmac;
    public static DerObjectIdentifier id_aria192_cmac;
    public static DerObjectIdentifier id_aria256_cmac;
    public static DerObjectIdentifier id_aria128_ocb2;
    public static DerObjectIdentifier id_aria192_ocb2;
    public static DerObjectIdentifier id_aria256_ocb2;
    public static DerObjectIdentifier id_aria128_gcm;
    public static DerObjectIdentifier id_aria192_gcm;
    public static DerObjectIdentifier id_aria256_gcm;
    public static DerObjectIdentifier id_aria128_ccm;
    public static DerObjectIdentifier id_aria192_ccm;
    public static DerObjectIdentifier id_aria256_ccm;
    public static DerObjectIdentifier id_aria128_kw;
    public static DerObjectIdentifier id_aria192_kw;
    public static DerObjectIdentifier id_aria256_kw;
    public static DerObjectIdentifier id_aria128_kwp;
    public static DerObjectIdentifier id_aria192_kwp;
    public static DerObjectIdentifier id_aria256_kwp;
    private static NsriObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Ntt.NttObjectIdentifiers : object {
    public static DerObjectIdentifier IdCamellia128Cbc;
    public static DerObjectIdentifier IdCamellia192Cbc;
    public static DerObjectIdentifier IdCamellia256Cbc;
    public static DerObjectIdentifier IdCamellia128Wrap;
    public static DerObjectIdentifier IdCamellia192Wrap;
    public static DerObjectIdentifier IdCamellia256Wrap;
    private static NttObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Ocsp.BasicOcspResponse : Asn1Encodable {
    private ResponseData tbsResponseData;
    private AlgorithmIdentifier signatureAlgorithm;
    private DerBitString signature;
    private Asn1Sequence certs;
    public ResponseData TbsResponseData { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public Asn1Sequence Certs { get; }
    public BasicOcspResponse(ResponseData tbsResponseData, AlgorithmIdentifier signatureAlgorithm, DerBitString signature, Asn1Sequence certs);
    private BasicOcspResponse(Asn1Sequence seq);
    public static BasicOcspResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static BasicOcspResponse GetInstance(object obj);
    public ResponseData get_TbsResponseData();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public Byte[] GetSignatureOctets();
    public Asn1Sequence get_Certs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CertID : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString issuerNameHash;
    private Asn1OctetString issuerKeyHash;
    private DerInteger serialNumber;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Asn1OctetString IssuerNameHash { get; }
    public Asn1OctetString IssuerKeyHash { get; }
    public DerInteger SerialNumber { get; }
    public CertID(AlgorithmIdentifier hashAlgorithm, Asn1OctetString issuerNameHash, Asn1OctetString issuerKeyHash, DerInteger serialNumber);
    private CertID(Asn1Sequence seq);
    public static CertID GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CertID GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Asn1OctetString get_IssuerNameHash();
    public Asn1OctetString get_IssuerKeyHash();
    public DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CertStatus : Asn1Encodable {
    private int tagNo;
    private Asn1Encodable value;
    public int TagNo { get; }
    public Asn1Encodable Status { get; }
    public CertStatus(RevokedInfo info);
    public CertStatus(int tagNo, Asn1Encodable value);
    public CertStatus(Asn1TaggedObject choice);
    public static CertStatus GetInstance(object obj);
    public int get_TagNo();
    public Asn1Encodable get_Status();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CrlID : Asn1Encodable {
    private DerIA5String crlUrl;
    private DerInteger crlNum;
    private Asn1GeneralizedTime crlTime;
    public DerIA5String CrlUrl { get; }
    public DerInteger CrlNum { get; }
    public Asn1GeneralizedTime CrlTime { get; }
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public CrlID(Asn1Sequence seq);
    public static CrlID GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public static CrlID GetInstance(object obj);
    public DerIA5String get_CrlUrl();
    public DerInteger get_CrlNum();
    public Asn1GeneralizedTime get_CrlTime();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Ocsp.OcspObjectIdentifiers : object {
    internal static string PkixOcspId;
    public static DerObjectIdentifier PkixOcsp;
    public static DerObjectIdentifier PkixOcspBasic;
    public static DerObjectIdentifier PkixOcspNonce;
    public static DerObjectIdentifier PkixOcspCrl;
    public static DerObjectIdentifier PkixOcspResponse;
    public static DerObjectIdentifier PkixOcspNocheck;
    public static DerObjectIdentifier PkixOcspArchiveCutoff;
    public static DerObjectIdentifier PkixOcspServiceLocator;
    private static OcspObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspRequest : Asn1Encodable {
    private TbsRequest tbsRequest;
    private Signature optionalSignature;
    public TbsRequest TbsRequest { get; }
    public Signature OptionalSignature { get; }
    public OcspRequest(TbsRequest tbsRequest, Signature optionalSignature);
    private OcspRequest(Asn1Sequence seq);
    public static OcspRequest GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OcspRequest GetInstance(object obj);
    public TbsRequest get_TbsRequest();
    public Signature get_OptionalSignature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspResponse : Asn1Encodable {
    private OcspResponseStatus responseStatus;
    private ResponseBytes responseBytes;
    public OcspResponseStatus ResponseStatus { get; }
    public ResponseBytes ResponseBytes { get; }
    public OcspResponse(OcspResponseStatus responseStatus, ResponseBytes responseBytes);
    private OcspResponse(Asn1Sequence seq);
    public static OcspResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OcspResponse GetInstance(object obj);
    public OcspResponseStatus get_ResponseStatus();
    public ResponseBytes get_ResponseBytes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspResponseStatus : DerEnumerated {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SignatureRequired;
    public static int Unauthorized;
    public OcspResponseStatus(int value);
    public OcspResponseStatus(DerEnumerated value);
}
public class Org.BouncyCastle.Asn1.Ocsp.Request : Asn1Encodable {
    private CertID reqCert;
    private X509Extensions singleRequestExtensions;
    public CertID ReqCert { get; }
    public X509Extensions SingleRequestExtensions { get; }
    public Request(CertID reqCert, X509Extensions singleRequestExtensions);
    private Request(Asn1Sequence seq);
    public static Request GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Request GetInstance(object obj);
    public CertID get_ReqCert();
    public X509Extensions get_SingleRequestExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponderID : Asn1Encodable {
    private Asn1Encodable id;
    public X509Name Name { get; }
    public ResponderID(Asn1OctetString id);
    public ResponderID(X509Name id);
    public static ResponderID GetInstance(object obj);
    public static ResponderID GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual Byte[] GetKeyHash();
    public virtual X509Name get_Name();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponseBytes : Asn1Encodable {
    private DerObjectIdentifier responseType;
    private Asn1OctetString response;
    public DerObjectIdentifier ResponseType { get; }
    public Asn1OctetString Response { get; }
    public ResponseBytes(DerObjectIdentifier responseType, Asn1OctetString response);
    private ResponseBytes(Asn1Sequence seq);
    public static ResponseBytes GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ResponseBytes GetInstance(object obj);
    public DerObjectIdentifier get_ResponseType();
    public Asn1OctetString get_Response();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponseData : Asn1Encodable {
    private static DerInteger V1;
    private bool versionPresent;
    private DerInteger version;
    private ResponderID responderID;
    private Asn1GeneralizedTime producedAt;
    private Asn1Sequence responses;
    private X509Extensions responseExtensions;
    public DerInteger Version { get; }
    public ResponderID ResponderID { get; }
    public Asn1GeneralizedTime ProducedAt { get; }
    public Asn1Sequence Responses { get; }
    public X509Extensions ResponseExtensions { get; }
    public ResponseData(DerInteger version, ResponderID responderID, Asn1GeneralizedTime producedAt, Asn1Sequence responses, X509Extensions responseExtensions);
    public ResponseData(ResponderID responderID, Asn1GeneralizedTime producedAt, Asn1Sequence responses, X509Extensions responseExtensions);
    private ResponseData(Asn1Sequence seq);
    private static ResponseData();
    public static ResponseData GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ResponseData GetInstance(object obj);
    public DerInteger get_Version();
    public ResponderID get_ResponderID();
    public Asn1GeneralizedTime get_ProducedAt();
    public Asn1Sequence get_Responses();
    public X509Extensions get_ResponseExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.RevokedInfo : Asn1Encodable {
    private Asn1GeneralizedTime revocationTime;
    private CrlReason revocationReason;
    public Asn1GeneralizedTime RevocationTime { get; }
    public CrlReason RevocationReason { get; }
    public RevokedInfo(Asn1GeneralizedTime revocationTime);
    public RevokedInfo(Asn1GeneralizedTime revocationTime, CrlReason revocationReason);
    private RevokedInfo(Asn1Sequence seq);
    public static RevokedInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static RevokedInfo GetInstance(object obj);
    public Asn1GeneralizedTime get_RevocationTime();
    public CrlReason get_RevocationReason();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ServiceLocator : Asn1Encodable {
    private X509Name issuer;
    private Asn1Object locator;
    public X509Name Issuer { get; }
    public Asn1Object Locator { get; }
    public ServiceLocator(X509Name issuer);
    public ServiceLocator(X509Name issuer, Asn1Object locator);
    private ServiceLocator(Asn1Sequence seq);
    public static ServiceLocator GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ServiceLocator GetInstance(object obj);
    public X509Name get_Issuer();
    public Asn1Object get_Locator();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.Signature : Asn1Encodable {
    internal AlgorithmIdentifier signatureAlgorithm;
    internal DerBitString signatureValue;
    internal Asn1Sequence certs;
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString SignatureValue { get; }
    public Asn1Sequence Certs { get; }
    public Signature(AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue);
    public Signature(AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue, Asn1Sequence certs);
    private Signature(Asn1Sequence seq);
    public static Signature GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Signature GetInstance(object obj);
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_SignatureValue();
    public Byte[] GetSignatureOctets();
    public Asn1Sequence get_Certs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.SingleResponse : Asn1Encodable {
    private CertID certID;
    private CertStatus certStatus;
    private Asn1GeneralizedTime thisUpdate;
    private Asn1GeneralizedTime nextUpdate;
    private X509Extensions singleExtensions;
    public CertID CertId { get; }
    public CertStatus CertStatus { get; }
    public Asn1GeneralizedTime ThisUpdate { get; }
    public Asn1GeneralizedTime NextUpdate { get; }
    public X509Extensions SingleExtensions { get; }
    public SingleResponse(CertID certID, CertStatus certStatus, Asn1GeneralizedTime thisUpdate, Asn1GeneralizedTime nextUpdate, X509Extensions singleExtensions);
    public SingleResponse(Asn1Sequence seq);
    public static SingleResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SingleResponse GetInstance(object obj);
    public CertID get_CertId();
    public CertStatus get_CertStatus();
    public Asn1GeneralizedTime get_ThisUpdate();
    public Asn1GeneralizedTime get_NextUpdate();
    public X509Extensions get_SingleExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.TbsRequest : Asn1Encodable {
    private static DerInteger V1;
    private DerInteger version;
    private GeneralName requestorName;
    private Asn1Sequence requestList;
    private X509Extensions requestExtensions;
    private bool versionSet;
    public DerInteger Version { get; }
    public GeneralName RequestorName { get; }
    public Asn1Sequence RequestList { get; }
    public X509Extensions RequestExtensions { get; }
    public TbsRequest(GeneralName requestorName, Asn1Sequence requestList, X509Extensions requestExtensions);
    private TbsRequest(Asn1Sequence seq);
    private static TbsRequest();
    public static TbsRequest GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsRequest GetInstance(object obj);
    public DerInteger get_Version();
    public GeneralName get_RequestorName();
    public Asn1Sequence get_RequestList();
    public X509Extensions get_RequestExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.OidTokenizer : object {
    private string oid;
    private int index;
    public bool HasMoreTokens { get; }
    public OidTokenizer(string oid);
    public bool get_HasMoreTokens();
    public string NextToken();
}
public class Org.BouncyCastle.Asn1.Oiw.ElGamalParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger g;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public ElGamalParameter(BigInteger p, BigInteger g);
    public ElGamalParameter(Asn1Sequence seq);
    public BigInteger get_P();
    public BigInteger get_G();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Oiw.OiwObjectIdentifiers : object {
    public static DerObjectIdentifier MD4WithRsa;
    public static DerObjectIdentifier MD5WithRsa;
    public static DerObjectIdentifier MD4WithRsaEncryption;
    public static DerObjectIdentifier DesEcb;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesOfb;
    public static DerObjectIdentifier DesCfb;
    public static DerObjectIdentifier DesEde;
    public static DerObjectIdentifier IdSha1;
    public static DerObjectIdentifier DsaWithSha1;
    public static DerObjectIdentifier Sha1WithRsa;
    public static DerObjectIdentifier ElGamalAlgorithm;
    private static OiwObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Pkcs.AttributePkcs : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    private AttributePkcs(Asn1Sequence seq);
    public AttributePkcs(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static AttributePkcs GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.AuthenticatedSafe : Asn1Encodable {
    private ContentInfo[] info;
    private bool isBer;
    private AuthenticatedSafe(Asn1Sequence seq);
    public AuthenticatedSafe(ContentInfo[] info);
    private static ContentInfo[] Copy(ContentInfo[] info);
    public static AuthenticatedSafe GetInstance(object obj);
    public ContentInfo[] GetContentInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertBag : Asn1Encodable {
    private DerObjectIdentifier m_certID;
    private Asn1Object m_certValue;
    public DerObjectIdentifier CertID { get; }
    public Asn1Object CertValue { get; }
    private CertBag(Asn1Sequence seq);
    public CertBag(DerObjectIdentifier certID, Asn1Object certValue);
    public static CertBag GetInstance(object obj);
    public virtual DerObjectIdentifier get_CertID();
    public virtual Asn1Object get_CertValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertificationRequest : Asn1Encodable {
    protected CertificationRequestInfo reqInfo;
    protected AlgorithmIdentifier sigAlgId;
    protected DerBitString sigBits;
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public CertificationRequest(CertificationRequestInfo requestInfo, AlgorithmIdentifier algorithm, DerBitString signature);
    internal CertificationRequest(Asn1Sequence seq);
    public static CertificationRequest GetInstance(object obj);
    public CertificationRequestInfo GetCertificationRequestInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public Byte[] GetSignatureOctets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertificationRequestInfo : Asn1Encodable {
    internal DerInteger version;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPKInfo;
    internal Asn1Set attributes;
    public DerInteger Version { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public Asn1Set Attributes { get; }
    public CertificationRequestInfo(X509Name subject, SubjectPublicKeyInfo pkInfo, Asn1Set attributes);
    private CertificationRequestInfo(Asn1Sequence seq);
    public static CertificationRequestInfo GetInstance(object obj);
    public DerInteger get_Version();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public Asn1Set get_Attributes();
    public virtual Asn1Object ToAsn1Object();
    private static void ValidateAttributes(Asn1Set attributes);
}
public class Org.BouncyCastle.Asn1.Pkcs.ContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private Asn1Encodable content;
    public DerObjectIdentifier ContentType { get; }
    public Asn1Encodable Content { get; }
    private ContentInfo(Asn1Sequence seq);
    public ContentInfo(DerObjectIdentifier contentType, Asn1Encodable content);
    public static ContentInfo GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CrlBag : Asn1Encodable {
    private DerObjectIdentifier m_crlID;
    private Asn1Encodable m_crlValue;
    public DerObjectIdentifier CrlID { get; }
    public Asn1Encodable CrlValue { get; }
    private CrlBag(Asn1Sequence seq);
    public CrlBag(DerObjectIdentifier crlID, Asn1Encodable crlValue);
    public static CrlBag GetInstance(object obj);
    public virtual DerObjectIdentifier get_CrlID();
    public virtual Asn1Encodable get_CrlValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.DHParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger g;
    internal DerInteger l;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger L { get; }
    public DHParameter(BigInteger p, BigInteger g, int l);
    public DHParameter(Asn1Sequence seq);
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_L();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptedData : Asn1Encodable {
    private Asn1Sequence data;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier EncryptionAlgorithm { get; }
    public Asn1OctetString Content { get; }
    private EncryptedData(Asn1Sequence seq);
    public EncryptedData(DerObjectIdentifier contentType, AlgorithmIdentifier encryptionAlgorithm, Asn1Encodable content);
    public static EncryptedData GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_EncryptionAlgorithm();
    public Asn1OctetString get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo : Asn1Encodable {
    private AlgorithmIdentifier algId;
    private Asn1OctetString data;
    public AlgorithmIdentifier EncryptionAlgorithm { get; }
    private EncryptedPrivateKeyInfo(Asn1Sequence seq);
    public EncryptedPrivateKeyInfo(AlgorithmIdentifier algId, Byte[] encoding);
    public static EncryptedPrivateKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_EncryptionAlgorithm();
    public Byte[] GetEncryptedData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptionScheme : AlgorithmIdentifier {
    public Asn1Object Asn1Object { get; }
    public EncryptionScheme(DerObjectIdentifier objectID);
    public EncryptionScheme(DerObjectIdentifier objectID, Asn1Encodable parameters);
    internal EncryptionScheme(Asn1Sequence seq);
    public static EncryptionScheme GetInstance(object obj);
    public Asn1Object get_Asn1Object();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.IssuerAndSerialNumber : Asn1Encodable {
    private X509Name name;
    private DerInteger certSerialNumber;
    public X509Name Name { get; }
    public DerInteger CertificateSerialNumber { get; }
    private IssuerAndSerialNumber(Asn1Sequence seq);
    public IssuerAndSerialNumber(X509Name name, BigInteger certSerialNumber);
    public IssuerAndSerialNumber(X509Name name, DerInteger certSerialNumber);
    public static IssuerAndSerialNumber GetInstance(object obj);
    public X509Name get_Name();
    public DerInteger get_CertificateSerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.KeyDerivationFunc : AlgorithmIdentifier {
    internal KeyDerivationFunc(Asn1Sequence seq);
    public KeyDerivationFunc(DerObjectIdentifier id, Asn1Encodable parameters);
}
public class Org.BouncyCastle.Asn1.Pkcs.MacData : Asn1Encodable {
    internal DigestInfo digInfo;
    internal Byte[] salt;
    internal BigInteger iterationCount;
    public DigestInfo Mac { get; }
    public BigInteger IterationCount { get; }
    private MacData(Asn1Sequence seq);
    public MacData(DigestInfo digInfo, Byte[] salt, int iterationCount);
    public static MacData GetInstance(object obj);
    public DigestInfo get_Mac();
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.PbeParameter : Asn1Encodable {
    private Asn1OctetString salt;
    private DerInteger iterationCount;
    public BigInteger IterationCount { get; }
    private PbeParameter(Asn1Sequence seq);
    public PbeParameter(Byte[] salt, int iterationCount);
    public static PbeParameter GetInstance(object obj);
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.PbeS2Parameters : Asn1Encodable {
    private KeyDerivationFunc func;
    private EncryptionScheme scheme;
    public KeyDerivationFunc KeyDerivationFunc { get; }
    public EncryptionScheme EncryptionScheme { get; }
    public PbeS2Parameters(KeyDerivationFunc keyDevFunc, EncryptionScheme encScheme);
    private PbeS2Parameters(Asn1Sequence seq);
    public static PbeS2Parameters GetInstance(object obj);
    public KeyDerivationFunc get_KeyDerivationFunc();
    public EncryptionScheme get_EncryptionScheme();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pbkdf2Params : Asn1Encodable {
    private static AlgorithmIdentifier algid_hmacWithSHA1;
    private Asn1OctetString octStr;
    private DerInteger iterationCount;
    private DerInteger keyLength;
    private AlgorithmIdentifier prf;
    public BigInteger IterationCount { get; }
    public BigInteger KeyLength { get; }
    public bool IsDefaultPrf { get; }
    public AlgorithmIdentifier Prf { get; }
    public Pbkdf2Params(Asn1Sequence seq);
    public Pbkdf2Params(Byte[] salt, int iterationCount);
    public Pbkdf2Params(Byte[] salt, int iterationCount, int keyLength);
    public Pbkdf2Params(Byte[] salt, int iterationCount, int keyLength, AlgorithmIdentifier prf);
    public Pbkdf2Params(Byte[] salt, int iterationCount, AlgorithmIdentifier prf);
    private static Pbkdf2Params();
    public static Pbkdf2Params GetInstance(object obj);
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public BigInteger get_KeyLength();
    public bool get_IsDefaultPrf();
    public AlgorithmIdentifier get_Prf();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pfx : Asn1Encodable {
    private ContentInfo contentInfo;
    private MacData macData;
    public ContentInfo AuthSafe { get; }
    public MacData MacData { get; }
    private Pfx(Asn1Sequence seq);
    public Pfx(ContentInfo contentInfo, MacData macData);
    public static Pfx GetInstance(object obj);
    public ContentInfo get_AuthSafe();
    public MacData get_MacData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pkcs12PbeParams : Asn1Encodable {
    private DerInteger iterations;
    private Asn1OctetString iv;
    public BigInteger Iterations { get; }
    public Pkcs12PbeParams(Byte[] salt, int iterations);
    private Pkcs12PbeParams(Asn1Sequence seq);
    public static Pkcs12PbeParams GetInstance(object obj);
    public BigInteger get_Iterations();
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers : object {
    public static string Pkcs1;
    internal static DerObjectIdentifier Pkcs1Oid;
    public static DerObjectIdentifier RsaEncryption;
    public static DerObjectIdentifier MD2WithRsaEncryption;
    public static DerObjectIdentifier MD4WithRsaEncryption;
    public static DerObjectIdentifier MD5WithRsaEncryption;
    public static DerObjectIdentifier Sha1WithRsaEncryption;
    public static DerObjectIdentifier SrsaOaepEncryptionSet;
    public static DerObjectIdentifier IdRsaesOaep;
    public static DerObjectIdentifier IdMgf1;
    public static DerObjectIdentifier IdPSpecified;
    public static DerObjectIdentifier IdRsassaPss;
    public static DerObjectIdentifier Sha256WithRsaEncryption;
    public static DerObjectIdentifier Sha384WithRsaEncryption;
    public static DerObjectIdentifier Sha512WithRsaEncryption;
    public static DerObjectIdentifier Sha224WithRsaEncryption;
    public static DerObjectIdentifier Sha512_224WithRSAEncryption;
    public static DerObjectIdentifier Sha512_256WithRSAEncryption;
    public static string Pkcs3;
    public static DerObjectIdentifier DhKeyAgreement;
    public static string Pkcs5;
    public static DerObjectIdentifier PbeWithMD2AndDesCbc;
    public static DerObjectIdentifier PbeWithMD2AndRC2Cbc;
    public static DerObjectIdentifier PbeWithMD5AndDesCbc;
    public static DerObjectIdentifier PbeWithMD5AndRC2Cbc;
    public static DerObjectIdentifier PbeWithSha1AndDesCbc;
    public static DerObjectIdentifier PbeWithSha1AndRC2Cbc;
    public static DerObjectIdentifier IdPbeS2;
    public static DerObjectIdentifier IdPbkdf2;
    public static string EncryptionAlgorithm;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    public static DerObjectIdentifier rc4;
    public static string DigestAlgorithm;
    public static DerObjectIdentifier MD2;
    public static DerObjectIdentifier MD4;
    public static DerObjectIdentifier MD5;
    public static DerObjectIdentifier IdHmacWithSha1;
    public static DerObjectIdentifier IdHmacWithSha224;
    public static DerObjectIdentifier IdHmacWithSha256;
    public static DerObjectIdentifier IdHmacWithSha384;
    public static DerObjectIdentifier IdHmacWithSha512;
    public static string Pkcs7;
    public static DerObjectIdentifier Data;
    public static DerObjectIdentifier SignedData;
    public static DerObjectIdentifier EnvelopedData;
    public static DerObjectIdentifier SignedAndEnvelopedData;
    public static DerObjectIdentifier DigestedData;
    public static DerObjectIdentifier EncryptedData;
    public static string Pkcs9;
    public static DerObjectIdentifier Pkcs9AtEmailAddress;
    public static DerObjectIdentifier Pkcs9AtUnstructuredName;
    public static DerObjectIdentifier Pkcs9AtContentType;
    public static DerObjectIdentifier Pkcs9AtMessageDigest;
    public static DerObjectIdentifier Pkcs9AtSigningTime;
    public static DerObjectIdentifier Pkcs9AtCounterSignature;
    public static DerObjectIdentifier Pkcs9AtChallengePassword;
    public static DerObjectIdentifier Pkcs9AtUnstructuredAddress;
    public static DerObjectIdentifier Pkcs9AtExtendedCertificateAttributes;
    public static DerObjectIdentifier Pkcs9AtSigningDescription;
    public static DerObjectIdentifier Pkcs9AtExtensionRequest;
    public static DerObjectIdentifier Pkcs9AtSmimeCapabilities;
    public static DerObjectIdentifier IdSmime;
    public static DerObjectIdentifier Pkcs9AtFriendlyName;
    public static DerObjectIdentifier Pkcs9AtLocalKeyID;
    public static string CertTypes;
    public static DerObjectIdentifier X509Certificate;
    public static DerObjectIdentifier SdsiCertificate;
    public static string CrlTypes;
    public static DerObjectIdentifier X509Crl;
    public static DerObjectIdentifier IdAlg;
    public static DerObjectIdentifier IdAlgEsdh;
    public static DerObjectIdentifier IdAlgCms3DesWrap;
    public static DerObjectIdentifier IdAlgCmsRC2Wrap;
    public static DerObjectIdentifier IdAlgZlibCompress;
    public static DerObjectIdentifier IdAlgPwriKek;
    public static DerObjectIdentifier IdAlgSsdh;
    public static DerObjectIdentifier id_aa_cmsAlgorithmProtect;
    public static DerObjectIdentifier IdRsaKem;
    public static DerObjectIdentifier IdAlgAeadChaCha20Poly1305;
    public static DerObjectIdentifier IdAlgHssLmsHashsig;
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitiesVersions;
    public static DerObjectIdentifier IdAAReceiptRequest;
    public static string IdCT;
    public static DerObjectIdentifier IdCTAuthData;
    public static DerObjectIdentifier IdCTTstInfo;
    public static DerObjectIdentifier IdCTCompressedData;
    public static DerObjectIdentifier IdCTAuthEnvelopedData;
    public static DerObjectIdentifier IdCTTimestampedData;
    public static string IdCti;
    public static DerObjectIdentifier IdCtiEtsProofOfOrigin;
    public static DerObjectIdentifier IdCtiEtsProofOfReceipt;
    public static DerObjectIdentifier IdCtiEtsProofOfDelivery;
    public static DerObjectIdentifier IdCtiEtsProofOfSender;
    public static DerObjectIdentifier IdCtiEtsProofOfApproval;
    public static DerObjectIdentifier IdCtiEtsProofOfCreation;
    public static string IdAA;
    public static DerObjectIdentifier IdAAOid;
    public static DerObjectIdentifier IdAAContentHint;
    public static DerObjectIdentifier IdAAMsgSigDigest;
    public static DerObjectIdentifier IdAAContentReference;
    public static DerObjectIdentifier IdAAEncrypKeyPref;
    public static DerObjectIdentifier IdAASigningCertificate;
    public static DerObjectIdentifier IdAASigningCertificateV2;
    public static DerObjectIdentifier IdAAContentIdentifier;
    public static DerObjectIdentifier IdAASignatureTimeStampToken;
    public static DerObjectIdentifier IdAAEtsSigPolicyID;
    public static DerObjectIdentifier IdAAEtsCommitmentType;
    public static DerObjectIdentifier IdAAEtsSignerLocation;
    public static DerObjectIdentifier IdAAEtsSignerAttr;
    public static DerObjectIdentifier IdAAEtsOtherSigCert;
    public static DerObjectIdentifier IdAAEtsContentTimestamp;
    public static DerObjectIdentifier IdAAEtsCertificateRefs;
    public static DerObjectIdentifier IdAAEtsRevocationRefs;
    public static DerObjectIdentifier IdAAEtsCertValues;
    public static DerObjectIdentifier IdAAEtsRevocationValues;
    public static DerObjectIdentifier IdAAEtsEscTimeStamp;
    public static DerObjectIdentifier IdAAEtsCertCrlTimestamp;
    public static DerObjectIdentifier IdAAEtsArchiveTimestamp;
    public static DerObjectIdentifier IdAADecryptKeyID;
    public static DerObjectIdentifier IdAAImplCryptoAlgs;
    public static DerObjectIdentifier IdAAAsymmDecryptKeyID;
    public static DerObjectIdentifier IdAAImplCompressAlgs;
    public static DerObjectIdentifier IdAACommunityIdentifiers;
    public static string IdSpq;
    public static DerObjectIdentifier IdSpqEtsUri;
    public static DerObjectIdentifier IdSpqEtsUNotice;
    public static string Pkcs12;
    public static string BagTypes;
    public static DerObjectIdentifier KeyBag;
    public static DerObjectIdentifier Pkcs8ShroudedKeyBag;
    public static DerObjectIdentifier CertBag;
    public static DerObjectIdentifier CrlBag;
    public static DerObjectIdentifier SecretBag;
    public static DerObjectIdentifier SafeContentsBag;
    public static string Pkcs12PbeIds;
    public static DerObjectIdentifier PbeWithShaAnd128BitRC4;
    public static DerObjectIdentifier PbeWithShaAnd40BitRC4;
    public static DerObjectIdentifier PbeWithShaAnd3KeyTripleDesCbc;
    public static DerObjectIdentifier PbeWithShaAnd2KeyTripleDesCbc;
    public static DerObjectIdentifier PbeWithShaAnd128BitRC2Cbc;
    public static DerObjectIdentifier PbewithShaAnd40BitRC2Cbc;
    private static PkcsObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier privateKeyAlgorithm;
    private Asn1OctetString privateKey;
    private Asn1Set attributes;
    private DerBitString publicKey;
    public DerInteger Version { get; }
    public Asn1Set Attributes { get; }
    public bool HasPublicKey { get; }
    public AlgorithmIdentifier PrivateKeyAlgorithm { get; }
    public Asn1OctetString PrivateKeyData { get; }
    public DerBitString PublicKeyData { get; }
    public PrivateKeyInfo(AlgorithmIdentifier privateKeyAlgorithm, Asn1Encodable privateKey);
    public PrivateKeyInfo(AlgorithmIdentifier privateKeyAlgorithm, Asn1Encodable privateKey, Asn1Set attributes);
    public PrivateKeyInfo(AlgorithmIdentifier privateKeyAlgorithm, Asn1Encodable privateKey, Asn1Set attributes, Byte[] publicKey);
    private PrivateKeyInfo(Asn1Sequence seq);
    public static PrivateKeyInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static PrivateKeyInfo GetInstance(object obj);
    private static int GetVersionValue(DerInteger version);
    public virtual DerInteger get_Version();
    public virtual Asn1Set get_Attributes();
    public virtual bool get_HasPublicKey();
    public virtual AlgorithmIdentifier get_PrivateKeyAlgorithm();
    public virtual Asn1OctetString get_PrivateKeyData();
    public virtual Asn1Object ParsePrivateKey();
    public virtual Asn1Object ParsePublicKey();
    public virtual DerBitString get_PublicKeyData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RC2CbcParameter : Asn1Encodable {
    internal DerInteger version;
    internal Asn1OctetString iv;
    public BigInteger RC2ParameterVersion { get; }
    public RC2CbcParameter(Byte[] iv);
    public RC2CbcParameter(int parameterVersion, Byte[] iv);
    private RC2CbcParameter(Asn1Sequence seq);
    public static RC2CbcParameter GetInstance(object obj);
    public BigInteger get_RC2ParameterVersion();
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private AlgorithmIdentifier maskGenAlgorithm;
    private AlgorithmIdentifier pSourceAlgorithm;
    public static AlgorithmIdentifier DefaultHashAlgorithm;
    public static AlgorithmIdentifier DefaultMaskGenFunction;
    public static AlgorithmIdentifier DefaultPSourceAlgorithm;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public AlgorithmIdentifier MaskGenAlgorithm { get; }
    public AlgorithmIdentifier PSourceAlgorithm { get; }
    public RsaesOaepParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm);
    public RsaesOaepParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm, AlgorithmIdentifier pSourceAlgorithm);
    public RsaesOaepParameters(Asn1Sequence seq);
    private static RsaesOaepParameters();
    public static RsaesOaepParameters GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public AlgorithmIdentifier get_MaskGenAlgorithm();
    public AlgorithmIdentifier get_PSourceAlgorithm();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure : Asn1Encodable {
    private BigInteger modulus;
    private BigInteger publicExponent;
    private BigInteger privateExponent;
    private BigInteger prime1;
    private BigInteger prime2;
    private BigInteger exponent1;
    private BigInteger exponent2;
    private BigInteger coefficient;
    public BigInteger Modulus { get; }
    public BigInteger PublicExponent { get; }
    public BigInteger PrivateExponent { get; }
    public BigInteger Prime1 { get; }
    public BigInteger Prime2 { get; }
    public BigInteger Exponent1 { get; }
    public BigInteger Exponent2 { get; }
    public BigInteger Coefficient { get; }
    public RsaPrivateKeyStructure(BigInteger modulus, BigInteger publicExponent, BigInteger privateExponent, BigInteger prime1, BigInteger prime2, BigInteger exponent1, BigInteger exponent2, BigInteger coefficient);
    private RsaPrivateKeyStructure(Asn1Sequence seq);
    public static RsaPrivateKeyStructure GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static RsaPrivateKeyStructure GetInstance(object obj);
    public BigInteger get_Modulus();
    public BigInteger get_PublicExponent();
    public BigInteger get_PrivateExponent();
    public BigInteger get_Prime1();
    public BigInteger get_Prime2();
    public BigInteger get_Exponent1();
    public BigInteger get_Exponent2();
    public BigInteger get_Coefficient();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private AlgorithmIdentifier maskGenAlgorithm;
    private DerInteger saltLength;
    private DerInteger trailerField;
    public static AlgorithmIdentifier DefaultHashAlgorithm;
    public static AlgorithmIdentifier DefaultMaskGenFunction;
    public static DerInteger DefaultSaltLength;
    public static DerInteger DefaultTrailerField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public AlgorithmIdentifier MaskGenAlgorithm { get; }
    public DerInteger SaltLength { get; }
    public DerInteger TrailerField { get; }
    public RsassaPssParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm, DerInteger saltLength, DerInteger trailerField);
    public RsassaPssParameters(Asn1Sequence seq);
    private static RsassaPssParameters();
    public static RsassaPssParameters GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public AlgorithmIdentifier get_MaskGenAlgorithm();
    public DerInteger get_SaltLength();
    public DerInteger get_TrailerField();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SafeBag : Asn1Encodable {
    private DerObjectIdentifier bagID;
    private Asn1Object bagValue;
    private Asn1Set bagAttributes;
    public DerObjectIdentifier BagID { get; }
    public Asn1Object BagValue { get; }
    public Asn1Set BagAttributes { get; }
    public SafeBag(DerObjectIdentifier oid, Asn1Object obj);
    public SafeBag(DerObjectIdentifier oid, Asn1Object obj, Asn1Set bagAttributes);
    private SafeBag(Asn1Sequence seq);
    public static SafeBag GetInstance(object obj);
    public DerObjectIdentifier get_BagID();
    public Asn1Object get_BagValue();
    public Asn1Set get_BagAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SignedData : Asn1Encodable {
    private DerInteger version;
    private Asn1Set digestAlgorithms;
    private ContentInfo contentInfo;
    private Asn1Set certificates;
    private Asn1Set crls;
    private Asn1Set signerInfos;
    public DerInteger Version { get; }
    public Asn1Set DigestAlgorithms { get; }
    public ContentInfo ContentInfo { get; }
    public Asn1Set Certificates { get; }
    public Asn1Set Crls { get; }
    public Asn1Set SignerInfos { get; }
    public SignedData(DerInteger _version, Asn1Set _digestAlgorithms, ContentInfo _contentInfo, Asn1Set _certificates, Asn1Set _crls, Asn1Set _signerInfos);
    private SignedData(Asn1Sequence seq);
    public static SignedData GetInstance(object obj);
    public DerInteger get_Version();
    public Asn1Set get_DigestAlgorithms();
    public ContentInfo get_ContentInfo();
    public Asn1Set get_Certificates();
    public Asn1Set get_Crls();
    public Asn1Set get_SignerInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SignerInfo : Asn1Encodable {
    private DerInteger version;
    private IssuerAndSerialNumber issuerAndSerialNumber;
    private AlgorithmIdentifier digAlgorithm;
    private Asn1Set authenticatedAttributes;
    private AlgorithmIdentifier digEncryptionAlgorithm;
    private Asn1OctetString encryptedDigest;
    private Asn1Set unauthenticatedAttributes;
    public DerInteger Version { get; }
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public Asn1Set AuthenticatedAttributes { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public Asn1OctetString EncryptedDigest { get; }
    public AlgorithmIdentifier DigestEncryptionAlgorithm { get; }
    public Asn1Set UnauthenticatedAttributes { get; }
    public SignerInfo(DerInteger version, IssuerAndSerialNumber issuerAndSerialNumber, AlgorithmIdentifier digAlgorithm, Asn1Set authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Asn1Set unauthenticatedAttributes);
    public SignerInfo(Asn1Sequence seq);
    public static SignerInfo GetInstance(object obj);
    public DerInteger get_Version();
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public Asn1Set get_AuthenticatedAttributes();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public Asn1OctetString get_EncryptedDigest();
    public AlgorithmIdentifier get_DigestEncryptionAlgorithm();
    public Asn1Set get_UnauthenticatedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.PrimitiveDerEncoding : DerEncoding {
    internal Byte[] m_contentsOctets;
    internal PrimitiveDerEncoding(int tagClass, int tagNo, Byte[] contentsOctets);
    protected internal virtual int CompareLengthAndContents(DerEncoding other);
    public virtual void Encode(Asn1OutputStream asn1Out);
    public virtual int GetLength();
}
internal class Org.BouncyCastle.Asn1.PrimitiveDerEncodingSuffixed : DerEncoding {
    private Byte[] m_contentsOctets;
    private byte m_contentsSuffix;
    internal PrimitiveDerEncodingSuffixed(int tagClass, int tagNo, Byte[] contentsOctets, byte contentsSuffix);
    protected internal virtual int CompareLengthAndContents(DerEncoding other);
    public virtual void Encode(Asn1OutputStream asn1Out);
    public virtual int GetLength();
    private static int CompareSuffixed(Byte[] octetsA, byte suffixA, Byte[] octetsB, byte suffixB);
}
internal class Org.BouncyCastle.Asn1.PrimitiveEncoding : object {
    private int m_tagClass;
    private int m_tagNo;
    private Byte[] m_contentsOctets;
    internal PrimitiveEncoding(int tagClass, int tagNo, Byte[] contentsOctets);
    private sealed virtual override void Org.BouncyCastle.Asn1.IAsn1Encoding.Encode(Asn1OutputStream asn1Out);
    private sealed virtual override int Org.BouncyCastle.Asn1.IAsn1Encoding.GetLength();
}
internal class Org.BouncyCastle.Asn1.PrimitiveEncodingSuffixed : object {
    private int m_tagClass;
    private int m_tagNo;
    private Byte[] m_contentsOctets;
    private byte m_contentsSuffix;
    internal PrimitiveEncodingSuffixed(int tagClass, int tagNo, Byte[] contentsOctets, byte contentsSuffix);
    private sealed virtual override void Org.BouncyCastle.Asn1.IAsn1Encoding.Encode(Asn1OutputStream asn1Out);
    private sealed virtual override int Org.BouncyCastle.Asn1.IAsn1Encoding.GetLength();
}
public abstract class Org.BouncyCastle.Asn1.Rosstandart.RosstandartObjectIdentifiers : object {
    public static DerObjectIdentifier rosstandart;
    public static DerObjectIdentifier id_tc26;
    public static DerObjectIdentifier id_tc26_gost_3411_12_256;
    public static DerObjectIdentifier id_tc26_gost_3411_12_512;
    public static DerObjectIdentifier id_tc26_hmac_gost_3411_12_256;
    public static DerObjectIdentifier id_tc26_hmac_gost_3411_12_512;
    public static DerObjectIdentifier id_tc26_gost_3410_12_256;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512;
    public static DerObjectIdentifier id_tc26_signwithdigest_gost_3410_12_256;
    public static DerObjectIdentifier id_tc26_signwithdigest_gost_3410_12_512;
    public static DerObjectIdentifier id_tc26_agreement;
    public static DerObjectIdentifier id_tc26_agreement_gost_3410_12_256;
    public static DerObjectIdentifier id_tc26_agreement_gost_3410_12_512;
    public static DerObjectIdentifier id_tc26_gost_3410_12_256_paramSet;
    public static DerObjectIdentifier id_tc26_gost_3410_12_256_paramSetA;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512_paramSet;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512_paramSetA;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512_paramSetB;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512_paramSetC;
    public static DerObjectIdentifier id_tc26_gost_28147_param_Z;
    private static RosstandartObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure : Asn1Encodable {
    private Asn1Sequence m_seq;
    private ECPrivateKeyStructure(Asn1Sequence seq);
    public ECPrivateKeyStructure(int orderBitLength, BigInteger key);
    public ECPrivateKeyStructure(int orderBitLength, BigInteger key, Asn1Encodable parameters);
    public ECPrivateKeyStructure(int orderBitLength, BigInteger key, DerBitString publicKey, Asn1Encodable parameters);
    public static ECPrivateKeyStructure GetInstance(object obj);
    public virtual BigInteger GetKey();
    public virtual DerBitString GetPublicKey();
    public virtual Asn1Object GetParameters();
    private Asn1Object GetObjectInTag(int tagNo, int baseTagNo);
    public virtual Asn1Object ToAsn1Object();
}
public static class Org.BouncyCastle.Asn1.Sec.SecNamedCurves : object {
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, X9ECParametersHolder> curves;
    private static Dictionary`2<DerObjectIdentifier, string> names;
    public static IEnumerable`1<string> Names { get; }
    private static SecNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static ECCurve ConfigureCurveGlv(ECCurve c, GlvTypeBParameters p);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public abstract class Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers : object {
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier SecT163k1;
    public static DerObjectIdentifier SecT163r1;
    public static DerObjectIdentifier SecT239k1;
    public static DerObjectIdentifier SecT113r1;
    public static DerObjectIdentifier SecT113r2;
    public static DerObjectIdentifier SecP112r1;
    public static DerObjectIdentifier SecP112r2;
    public static DerObjectIdentifier SecP160r1;
    public static DerObjectIdentifier SecP160k1;
    public static DerObjectIdentifier SecP256k1;
    public static DerObjectIdentifier SecT163r2;
    public static DerObjectIdentifier SecT283k1;
    public static DerObjectIdentifier SecT283r1;
    public static DerObjectIdentifier SecT131r1;
    public static DerObjectIdentifier SecT131r2;
    public static DerObjectIdentifier SecT193r1;
    public static DerObjectIdentifier SecT193r2;
    public static DerObjectIdentifier SecT233k1;
    public static DerObjectIdentifier SecT233r1;
    public static DerObjectIdentifier SecP128r1;
    public static DerObjectIdentifier SecP128r2;
    public static DerObjectIdentifier SecP160r2;
    public static DerObjectIdentifier SecP192k1;
    public static DerObjectIdentifier SecP224k1;
    public static DerObjectIdentifier SecP224r1;
    public static DerObjectIdentifier SecP384r1;
    public static DerObjectIdentifier SecP521r1;
    public static DerObjectIdentifier SecT409k1;
    public static DerObjectIdentifier SecT409r1;
    public static DerObjectIdentifier SecT571k1;
    public static DerObjectIdentifier SecT571r1;
    public static DerObjectIdentifier SecP192r1;
    public static DerObjectIdentifier SecP256r1;
    private static SecObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Smime.SmimeAttributes : object {
    public static DerObjectIdentifier SmimeCapabilities;
    public static DerObjectIdentifier EncrypKeyPref;
    private static SmimeAttributes();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilities : Asn1Encodable {
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitesVersions;
    public static DerObjectIdentifier Aes256Cbc;
    public static DerObjectIdentifier Aes192Cbc;
    public static DerObjectIdentifier Aes128Cbc;
    public static DerObjectIdentifier IdeaCbc;
    public static DerObjectIdentifier Cast5Cbc;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    private Asn1Sequence capabilities;
    public SmimeCapabilities(Asn1Sequence seq);
    private static SmimeCapabilities();
    public static SmimeCapabilities GetInstance(object obj);
    public IList`1<SmimeCapability> GetCapabilitiesForOid(DerObjectIdentifier capability);
    private void DoGetCapabilitiesForOid(DerObjectIdentifier capability, IList`1<SmimeCapability> list);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilitiesAttribute : AttributeX509 {
    public SmimeCapabilitiesAttribute(SmimeCapabilityVector capabilities);
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapability : Asn1Encodable {
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitiesVersions;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    private DerObjectIdentifier capabilityID;
    private Asn1Object parameters;
    public DerObjectIdentifier CapabilityID { get; }
    public Asn1Object Parameters { get; }
    public SmimeCapability(Asn1Sequence seq);
    public SmimeCapability(DerObjectIdentifier capabilityID, Asn1Encodable parameters);
    private static SmimeCapability();
    public static SmimeCapability GetInstance(object obj);
    public DerObjectIdentifier get_CapabilityID();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilityVector : object {
    private Asn1EncodableVector capabilities;
    public void AddCapability(DerObjectIdentifier capability);
    public void AddCapability(DerObjectIdentifier capability, int value);
    public void AddCapability(DerObjectIdentifier capability, Asn1Encodable parameters);
    public Asn1EncodableVector ToAsn1EncodableVector();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute : AttributeX509 {
    public SmimeEncryptionKeyPreferenceAttribute(IssuerAndSerialNumber issAndSer);
    public SmimeEncryptionKeyPreferenceAttribute(RecipientKeyIdentifier rKeyID);
    public SmimeEncryptionKeyPreferenceAttribute(Asn1OctetString sKeyID);
}
public static class Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves : object {
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, X9ECParametersHolder> curves;
    private static Dictionary`2<DerObjectIdentifier, string> names;
    public static IEnumerable`1<string> Names { get; }
    private static TeleTrusTNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public class Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTObjectIdentifiers : object {
    public static DerObjectIdentifier TeleTrusTAlgorithm;
    public static DerObjectIdentifier RipeMD160;
    public static DerObjectIdentifier RipeMD128;
    public static DerObjectIdentifier RipeMD256;
    public static DerObjectIdentifier TeleTrusTRsaSignatureAlgorithm;
    public static DerObjectIdentifier RsaSignatureWithRipeMD160;
    public static DerObjectIdentifier RsaSignatureWithRipeMD128;
    public static DerObjectIdentifier RsaSignatureWithRipeMD256;
    public static DerObjectIdentifier ECSign;
    public static DerObjectIdentifier ECSignWithSha1;
    public static DerObjectIdentifier ECSignWithRipeMD160;
    public static DerObjectIdentifier EccBrainpool;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier VersionOne;
    public static DerObjectIdentifier BrainpoolP160R1;
    public static DerObjectIdentifier BrainpoolP160T1;
    public static DerObjectIdentifier BrainpoolP192R1;
    public static DerObjectIdentifier BrainpoolP192T1;
    public static DerObjectIdentifier BrainpoolP224R1;
    public static DerObjectIdentifier BrainpoolP224T1;
    public static DerObjectIdentifier BrainpoolP256R1;
    public static DerObjectIdentifier BrainpoolP256T1;
    public static DerObjectIdentifier BrainpoolP320R1;
    public static DerObjectIdentifier BrainpoolP320T1;
    public static DerObjectIdentifier BrainpoolP384R1;
    public static DerObjectIdentifier BrainpoolP384T1;
    public static DerObjectIdentifier BrainpoolP512R1;
    public static DerObjectIdentifier BrainpoolP512T1;
    private static TeleTrusTObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Tsp.Accuracy : Asn1Encodable {
    private DerInteger seconds;
    private DerInteger millis;
    private DerInteger micros;
    protected static int MinMillis;
    protected static int MaxMillis;
    protected static int MinMicros;
    protected static int MaxMicros;
    public DerInteger Seconds { get; }
    public DerInteger Millis { get; }
    public DerInteger Micros { get; }
    public Accuracy(DerInteger seconds, DerInteger millis, DerInteger micros);
    private Accuracy(Asn1Sequence seq);
    public static Accuracy GetInstance(object obj);
    public DerInteger get_Seconds();
    public DerInteger get_Millis();
    public DerInteger get_Micros();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.MessageImprint : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] hashedMessage;
    public AlgorithmIdentifier HashAlgorithm { get; }
    private MessageImprint(Asn1Sequence seq);
    public MessageImprint(AlgorithmIdentifier hashAlgorithm, Byte[] hashedMessage);
    public static MessageImprint GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashedMessage();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TimeStampReq : Asn1Encodable {
    private DerInteger version;
    private MessageImprint messageImprint;
    private DerObjectIdentifier tsaPolicy;
    private DerInteger nonce;
    private DerBoolean certReq;
    private X509Extensions extensions;
    public DerInteger Version { get; }
    public MessageImprint MessageImprint { get; }
    public DerObjectIdentifier ReqPolicy { get; }
    public DerInteger Nonce { get; }
    public DerBoolean CertReq { get; }
    public X509Extensions Extensions { get; }
    private TimeStampReq(Asn1Sequence seq);
    public TimeStampReq(MessageImprint messageImprint, DerObjectIdentifier tsaPolicy, DerInteger nonce, DerBoolean certReq, X509Extensions extensions);
    public static TimeStampReq GetInstance(object obj);
    public DerInteger get_Version();
    public MessageImprint get_MessageImprint();
    public DerObjectIdentifier get_ReqPolicy();
    public DerInteger get_Nonce();
    public DerBoolean get_CertReq();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TimeStampResp : Asn1Encodable {
    private PkiStatusInfo pkiStatusInfo;
    private ContentInfo timeStampToken;
    public PkiStatusInfo Status { get; }
    public ContentInfo TimeStampToken { get; }
    private TimeStampResp(Asn1Sequence seq);
    public TimeStampResp(PkiStatusInfo pkiStatusInfo, ContentInfo timeStampToken);
    public static TimeStampResp GetInstance(object obj);
    public PkiStatusInfo get_Status();
    public ContentInfo get_TimeStampToken();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TstInfo : Asn1Encodable {
    private DerInteger version;
    private DerObjectIdentifier tsaPolicyId;
    private MessageImprint messageImprint;
    private DerInteger serialNumber;
    private Asn1GeneralizedTime genTime;
    private Accuracy accuracy;
    private DerBoolean ordering;
    private DerInteger nonce;
    private GeneralName tsa;
    private X509Extensions extensions;
    public DerInteger Version { get; }
    public MessageImprint MessageImprint { get; }
    public DerObjectIdentifier Policy { get; }
    public DerInteger SerialNumber { get; }
    public Accuracy Accuracy { get; }
    public Asn1GeneralizedTime GenTime { get; }
    public DerBoolean Ordering { get; }
    public DerInteger Nonce { get; }
    public GeneralName Tsa { get; }
    public X509Extensions Extensions { get; }
    private TstInfo(Asn1Sequence seq);
    public TstInfo(DerObjectIdentifier tsaPolicyId, MessageImprint messageImprint, DerInteger serialNumber, Asn1GeneralizedTime genTime, Accuracy accuracy, DerBoolean ordering, DerInteger nonce, GeneralName tsa, X509Extensions extensions);
    public static TstInfo GetInstance(object obj);
    public DerInteger get_Version();
    public MessageImprint get_MessageImprint();
    public DerObjectIdentifier get_Policy();
    public DerInteger get_SerialNumber();
    public Accuracy get_Accuracy();
    public Asn1GeneralizedTime get_GenTime();
    public DerBoolean get_Ordering();
    public DerInteger get_Nonce();
    public GeneralName get_Tsa();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers : object {
    public static DerObjectIdentifier UaOid;
    public static DerObjectIdentifier dstu4145le;
    public static DerObjectIdentifier dstu4145be;
    public static DerObjectIdentifier dstu7564digest_256;
    public static DerObjectIdentifier dstu7564digest_384;
    public static DerObjectIdentifier dstu7564digest_512;
    public static DerObjectIdentifier dstu7564mac_256;
    public static DerObjectIdentifier dstu7564mac_384;
    public static DerObjectIdentifier dstu7564mac_512;
    public static DerObjectIdentifier dstu7624ecb_128;
    public static DerObjectIdentifier dstu7624ecb_256;
    public static DerObjectIdentifier dstu7624ecb_512;
    public static DerObjectIdentifier dstu7624ctr_128;
    public static DerObjectIdentifier dstu7624ctr_256;
    public static DerObjectIdentifier dstu7624ctr_512;
    public static DerObjectIdentifier dstu7624cfb_128;
    public static DerObjectIdentifier dstu7624cfb_256;
    public static DerObjectIdentifier dstu7624cfb_512;
    public static DerObjectIdentifier dstu7624cmac_128;
    public static DerObjectIdentifier dstu7624cmac_256;
    public static DerObjectIdentifier dstu7624cmac_512;
    public static DerObjectIdentifier dstu7624cbc_128;
    public static DerObjectIdentifier dstu7624cbc_256;
    public static DerObjectIdentifier dstu7624cbc_512;
    public static DerObjectIdentifier dstu7624ofb_128;
    public static DerObjectIdentifier dstu7624ofb_256;
    public static DerObjectIdentifier dstu7624ofb_512;
    public static DerObjectIdentifier dstu7624gmac_128;
    public static DerObjectIdentifier dstu7624gmac_256;
    public static DerObjectIdentifier dstu7624gmac_512;
    public static DerObjectIdentifier dstu7624ccm_128;
    public static DerObjectIdentifier dstu7624ccm_256;
    public static DerObjectIdentifier dstu7624ccm_512;
    public static DerObjectIdentifier dstu7624xts_128;
    public static DerObjectIdentifier dstu7624xts_256;
    public static DerObjectIdentifier dstu7624xts_512;
    public static DerObjectIdentifier dstu7624kw_128;
    public static DerObjectIdentifier dstu7624kw_256;
    public static DerObjectIdentifier dstu7624kw_512;
    private static UAObjectIdentifiers();
}
public static class Org.BouncyCastle.Asn1.Utilities.Asn1Dump : object {
    private static string Tab;
    private static int SampleSize;
    private static void AsString(string indent, bool verbose, Asn1Object obj, StringBuilder buf);
    public static void Dump(Stream input, TextWriter output);
    public static string DumpAsString(Asn1Encodable obj);
    public static string DumpAsString(Asn1Encodable obj, bool verbose);
    private static void DumpBinaryDataAsString(StringBuilder buf, string indent, Byte[] bytes);
    private static void AppendAscString(StringBuilder buf, Byte[] bytes, int off, int len);
}
public class Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue : Asn1Encodable {
    private DerObjectIdentifier type;
    private Asn1Encodable value;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    private AttributeTypeAndValue(Asn1Sequence seq);
    public AttributeTypeAndValue(DerObjectIdentifier type, Asn1Encodable value);
    public static AttributeTypeAndValue GetInstance(object obj);
    public virtual DerObjectIdentifier get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X500.DirectoryString : Asn1Encodable {
    private DerStringBase str;
    private DirectoryString(DerStringBase str);
    public DirectoryString(string str);
    public static DirectoryString GetInstance(object obj);
    public static DirectoryString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public sealed virtual string GetString();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X500.Rdn : Asn1Encodable {
    private Asn1Set values;
    public bool IsMultiValued { get; }
    public int Count { get; }
    private Rdn(Asn1Set values);
    public Rdn(DerObjectIdentifier oid, Asn1Encodable value);
    public Rdn(AttributeTypeAndValue attrTAndV);
    public Rdn(AttributeTypeAndValue[] aAndVs);
    public static Rdn GetInstance(object obj);
    public virtual bool get_IsMultiValued();
    public virtual int get_Count();
    public virtual AttributeTypeAndValue GetFirst();
    public virtual AttributeTypeAndValue[] GetTypesAndValues();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X500.Style.IetfUtilities : object {
    public static string ValueToString(Asn1Encodable value);
    public static string Canonicalize(string s);
    public static string CanonicalString(Asn1Encodable value);
    private static Asn1Object DecodeObject(string oValue);
    public static string StripInternalSpaces(string str);
    public static bool RdnAreEqual(Rdn rdn1, Rdn rdn2);
    private static bool AtvAreEqual(AttributeTypeAndValue atv1, AttributeTypeAndValue atv2);
}
public class Org.BouncyCastle.Asn1.X509.AccessDescription : Asn1Encodable {
    public static DerObjectIdentifier IdADCAIssuers;
    public static DerObjectIdentifier IdADOcsp;
    private DerObjectIdentifier accessMethod;
    private GeneralName accessLocation;
    public DerObjectIdentifier AccessMethod { get; }
    public GeneralName AccessLocation { get; }
    private AccessDescription(Asn1Sequence seq);
    public AccessDescription(DerObjectIdentifier oid, GeneralName location);
    private static AccessDescription();
    public static AccessDescription GetInstance(object obj);
    public DerObjectIdentifier get_AccessMethod();
    public GeneralName get_AccessLocation();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier : Asn1Encodable {
    private DerObjectIdentifier algorithm;
    private Asn1Encodable parameters;
    public DerObjectIdentifier Algorithm { get; }
    public Asn1Encodable Parameters { get; }
    public AlgorithmIdentifier(DerObjectIdentifier algorithm);
    public AlgorithmIdentifier(DerObjectIdentifier algorithm, Asn1Encodable parameters);
    internal AlgorithmIdentifier(Asn1Sequence seq);
    public static AlgorithmIdentifier GetInstance(object obj);
    public static AlgorithmIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual DerObjectIdentifier get_Algorithm();
    public virtual Asn1Encodable get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AltSignatureAlgorithm : Asn1Encodable {
    private AlgorithmIdentifier m_algorithm;
    public AlgorithmIdentifier Algorithm { get; }
    public AltSignatureAlgorithm(AlgorithmIdentifier algorithm);
    public AltSignatureAlgorithm(DerObjectIdentifier algorithm);
    public AltSignatureAlgorithm(DerObjectIdentifier algorithm, Asn1Encodable parameters);
    public static AltSignatureAlgorithm GetInstance(object obj);
    public static AltSignatureAlgorithm GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public static AltSignatureAlgorithm FromExtensions(X509Extensions extensions);
    public AlgorithmIdentifier get_Algorithm();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AltSignatureValue : Asn1Encodable {
    private DerBitString m_signature;
    public DerBitString Signature { get; }
    private AltSignatureValue(DerBitString signature);
    public AltSignatureValue(Byte[] signature);
    public static AltSignatureValue GetInstance(object obj);
    public static AltSignatureValue GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public static AltSignatureValue FromExtensions(X509Extensions extensions);
    public DerBitString get_Signature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttCertIssuer : Asn1Encodable {
    internal Asn1Encodable obj;
    internal Asn1Object choiceObj;
    public Asn1Encodable Issuer { get; }
    public AttCertIssuer(GeneralNames names);
    public AttCertIssuer(V2Form v2Form);
    public static AttCertIssuer GetInstance(object obj);
    public static AttCertIssuer GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public Asn1Encodable get_Issuer();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttCertValidityPeriod : Asn1Encodable {
    private Asn1GeneralizedTime notBeforeTime;
    private Asn1GeneralizedTime notAfterTime;
    public Asn1GeneralizedTime NotBeforeTime { get; }
    public Asn1GeneralizedTime NotAfterTime { get; }
    private AttCertValidityPeriod(Asn1Sequence seq);
    public AttCertValidityPeriod(Asn1GeneralizedTime notBeforeTime, Asn1GeneralizedTime notAfterTime);
    public static AttCertValidityPeriod GetInstance(object obj);
    public static AttCertValidityPeriod GetInstance(Asn1TaggedObject obj, bool explicitly);
    public Asn1GeneralizedTime get_NotBeforeTime();
    public Asn1GeneralizedTime get_NotAfterTime();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeCertificate : Asn1Encodable {
    private AttributeCertificateInfo acinfo;
    private AlgorithmIdentifier signatureAlgorithm;
    private DerBitString signatureValue;
    public AttributeCertificateInfo ACInfo { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString SignatureValue { get; }
    public AttributeCertificate(AttributeCertificateInfo acinfo, AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue);
    private AttributeCertificate(Asn1Sequence seq);
    public static AttributeCertificate GetInstance(object obj);
    public static AttributeCertificate GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public AttributeCertificateInfo get_ACInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_SignatureValue();
    public Byte[] GetSignatureOctets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeCertificateInfo : Asn1Encodable {
    internal DerInteger version;
    internal Holder holder;
    internal AttCertIssuer issuer;
    internal AlgorithmIdentifier signature;
    internal DerInteger serialNumber;
    internal AttCertValidityPeriod attrCertValidityPeriod;
    internal Asn1Sequence attributes;
    internal DerBitString issuerUniqueID;
    internal X509Extensions extensions;
    public DerInteger Version { get; }
    public Holder Holder { get; }
    public AttCertIssuer Issuer { get; }
    public AlgorithmIdentifier Signature { get; }
    public DerInteger SerialNumber { get; }
    public AttCertValidityPeriod AttrCertValidityPeriod { get; }
    public Asn1Sequence Attributes { get; }
    public DerBitString IssuerUniqueID { get; }
    public X509Extensions Extensions { get; }
    private AttributeCertificateInfo(Asn1Sequence seq);
    public static AttributeCertificateInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AttributeCertificateInfo GetInstance(object obj);
    public DerInteger get_Version();
    public Holder get_Holder();
    public AttCertIssuer get_Issuer();
    public AlgorithmIdentifier get_Signature();
    public DerInteger get_SerialNumber();
    public AttCertValidityPeriod get_AttrCertValidityPeriod();
    public Asn1Sequence get_Attributes();
    public DerBitString get_IssuerUniqueID();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeTable : object {
    private IDictionary`2<DerObjectIdentifier, AttributeX509> m_attributes;
    public AttributeTable(IDictionary`2<DerObjectIdentifier, AttributeX509> attrs);
    public AttributeTable(Asn1EncodableVector v);
    public AttributeTable(Asn1Set s);
    public AttributeX509 Get(DerObjectIdentifier oid);
    public IDictionary`2<DerObjectIdentifier, AttributeX509> ToDictionary();
}
public class Org.BouncyCastle.Asn1.X509.AttributeX509 : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    private AttributeX509(Asn1Sequence seq);
    public AttributeX509(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static AttributeX509 GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Encodable[] GetAttributeValues();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess : Asn1Encodable {
    private AccessDescription[] descriptions;
    private AuthorityInformationAccess(Asn1Sequence seq);
    public AuthorityInformationAccess(AccessDescription description);
    public AuthorityInformationAccess(AccessDescription[] descriptions);
    public AuthorityInformationAccess(DerObjectIdentifier oid, GeneralName location);
    private static AccessDescription[] Copy(AccessDescription[] descriptions);
    public static AuthorityInformationAccess GetInstance(object obj);
    public static AuthorityInformationAccess FromExtensions(X509Extensions extensions);
    public AccessDescription[] GetAccessDescriptions();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier : Asn1Encodable {
    private Asn1OctetString keyidentifier;
    private GeneralNames certissuer;
    private DerInteger certserno;
    public GeneralNames AuthorityCertIssuer { get; }
    public BigInteger AuthorityCertSerialNumber { get; }
    protected internal AuthorityKeyIdentifier(Asn1Sequence seq);
    public AuthorityKeyIdentifier(SubjectPublicKeyInfo spki);
    public AuthorityKeyIdentifier(SubjectPublicKeyInfo spki, GeneralNames name, BigInteger serialNumber);
    public AuthorityKeyIdentifier(GeneralNames name, BigInteger serialNumber);
    public AuthorityKeyIdentifier(Byte[] keyIdentifier);
    public AuthorityKeyIdentifier(Byte[] keyIdentifier, GeneralNames name, BigInteger serialNumber);
    public static AuthorityKeyIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static AuthorityKeyIdentifier GetInstance(object obj);
    public static AuthorityKeyIdentifier FromExtensions(X509Extensions extensions);
    public Byte[] GetKeyIdentifier();
    public GeneralNames get_AuthorityCertIssuer();
    public BigInteger get_AuthorityCertSerialNumber();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.BasicConstraints : Asn1Encodable {
    private DerBoolean cA;
    private DerInteger pathLenConstraint;
    public BigInteger PathLenConstraint { get; }
    private BasicConstraints(Asn1Sequence seq);
    public BasicConstraints(bool cA);
    public BasicConstraints(int pathLenConstraint);
    public static BasicConstraints GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static BasicConstraints GetInstance(object obj);
    public static BasicConstraints FromExtensions(X509Extensions extensions);
    public bool IsCA();
    public BigInteger get_PathLenConstraint();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CertificateList : Asn1Encodable {
    private TbsCertificateList tbsCertList;
    private AlgorithmIdentifier sigAlgID;
    private DerBitString sig;
    public TbsCertificateList TbsCertList { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public int Version { get; }
    public X509Name Issuer { get; }
    public Time ThisUpdate { get; }
    public Time NextUpdate { get; }
    private CertificateList(Asn1Sequence seq);
    public static CertificateList GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CertificateList GetInstance(object obj);
    public TbsCertificateList get_TbsCertList();
    public CrlEntry[] GetRevokedCertificates();
    public IEnumerable`1<CrlEntry> GetRevokedCertificateEnumeration();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public Byte[] GetSignatureOctets();
    public int get_Version();
    public X509Name get_Issuer();
    public Time get_ThisUpdate();
    public Time get_NextUpdate();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.CertificatePair : Asn1Encodable {
    private X509CertificateStructure forward;
    private X509CertificateStructure reverse;
    public X509CertificateStructure Forward { get; }
    public X509CertificateStructure Reverse { get; }
    private CertificatePair(Asn1Sequence seq);
    public CertificatePair(X509CertificateStructure forward, X509CertificateStructure reverse);
    public static CertificatePair GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public X509CertificateStructure get_Forward();
    public X509CertificateStructure get_Reverse();
}
public class Org.BouncyCastle.Asn1.X509.CertificatePolicies : Asn1Encodable {
    private PolicyInformation[] policyInformation;
    public CertificatePolicies(PolicyInformation name);
    public CertificatePolicies(PolicyInformation[] policyInformation);
    private CertificatePolicies(Asn1Sequence seq);
    private static PolicyInformation[] Copy(PolicyInformation[] policyInfo);
    public static CertificatePolicies GetInstance(object obj);
    public static CertificatePolicies GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static CertificatePolicies FromExtensions(X509Extensions extensions);
    public virtual PolicyInformation[] GetPolicyInformation();
    public virtual PolicyInformation GetPolicyInformation(DerObjectIdentifier policyIdentifier);
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CertPolicyID : DerObjectIdentifier {
    public CertPolicyID(string id);
}
public class Org.BouncyCastle.Asn1.X509.CrlDistPoint : Asn1Encodable {
    internal Asn1Sequence seq;
    private CrlDistPoint(Asn1Sequence seq);
    public CrlDistPoint(DistributionPoint[] points);
    public static CrlDistPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CrlDistPoint GetInstance(object obj);
    public static CrlDistPoint FromExtensions(X509Extensions extensions);
    public DistributionPoint[] GetDistributionPoints();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CrlEntry : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger userCertificate;
    internal Time revocationDate;
    internal X509Extensions crlEntryExtensions;
    public DerInteger UserCertificate { get; }
    public Time RevocationDate { get; }
    public X509Extensions Extensions { get; }
    public CrlEntry(Asn1Sequence seq);
    public DerInteger get_UserCertificate();
    public Time get_RevocationDate();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.CrlNumber : DerInteger {
    public BigInteger Number { get; }
    public CrlNumber(BigInteger number);
    public BigInteger get_Number();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CrlReason : DerEnumerated {
    public static int Unspecified;
    public static int KeyCompromise;
    public static int CACompromise;
    public static int AffiliationChanged;
    public static int Superseded;
    public static int CessationOfOperation;
    public static int CertificateHold;
    public static int RemoveFromCrl;
    public static int PrivilegeWithdrawn;
    public static int AACompromise;
    private static String[] ReasonString;
    public CrlReason(int reason);
    public CrlReason(DerEnumerated reason);
    private static CrlReason();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.DigestInfo : Asn1Encodable {
    private Byte[] digest;
    private AlgorithmIdentifier algID;
    public AlgorithmIdentifier AlgorithmID { get; }
    public DigestInfo(AlgorithmIdentifier algID, Byte[] digest);
    private DigestInfo(Asn1Sequence seq);
    public static DigestInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DigestInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Byte[] GetDigest();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.DisplayText : Asn1Encodable {
    public static int ContentTypeIA5String;
    public static int ContentTypeBmpString;
    public static int ContentTypeUtf8String;
    public static int ContentTypeVisibleString;
    public static int DisplayTextMaximumSize;
    internal int contentType;
    internal IAsn1String contents;
    public DisplayText(int type, string text);
    public DisplayText(string text);
    public DisplayText(IAsn1String contents);
    public static DisplayText GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public string GetString();
}
public class Org.BouncyCastle.Asn1.X509.DistributionPoint : Asn1Encodable {
    private DistributionPointName m_distributionPoint;
    private ReasonFlags m_reasons;
    private GeneralNames m_crlIssuer;
    public DistributionPointName DistributionPointName { get; }
    public ReasonFlags Reasons { get; }
    public GeneralNames CrlIssuer { get; }
    private DistributionPoint(Asn1Sequence seq);
    public DistributionPoint(DistributionPointName distributionPointName, ReasonFlags reasons, GeneralNames crlIssuer);
    public static DistributionPoint GetInstance(object obj);
    public static DistributionPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public DistributionPointName get_DistributionPointName();
    public ReasonFlags get_Reasons();
    public GeneralNames get_CrlIssuer();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void AppendObject(StringBuilder buf, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.DistributionPointName : Asn1Encodable {
    public static int FullName;
    public static int NameRelativeToCrlIssuer;
    private int m_type;
    private Asn1Encodable m_name;
    [ObsoleteAttribute("Use 'Type' instead")]
public int PointType { get; }
    public Asn1Encodable Name { get; }
    public int Type { get; }
    public DistributionPointName(GeneralNames name);
    public DistributionPointName(int type, Asn1Encodable name);
    public DistributionPointName(Asn1TaggedObject obj);
    public static DistributionPointName GetInstance(object obj);
    public static DistributionPointName GetInstance(Asn1TaggedObject obj, bool explicitly);
    public int get_PointType();
    public Asn1Encodable get_Name();
    public int get_Type();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void AppendObject(StringBuilder buf, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.DsaParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger q;
    internal DerInteger g;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public DsaParameter(BigInteger p, BigInteger q, BigInteger g);
    private DsaParameter(Asn1Sequence seq);
    public static DsaParameter GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DsaParameter GetInstance(object obj);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_G();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage : Asn1Encodable {
    internal HashSet`1<DerObjectIdentifier> m_usageTable;
    internal Asn1Sequence seq;
    public int Count { get; }
    private ExtendedKeyUsage(Asn1Sequence seq);
    public ExtendedKeyUsage(KeyPurposeID[] usages);
    public ExtendedKeyUsage(IEnumerable`1<DerObjectIdentifier> usages);
    public static ExtendedKeyUsage GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ExtendedKeyUsage GetInstance(object obj);
    public static ExtendedKeyUsage FromExtensions(X509Extensions extensions);
    public bool HasKeyPurposeId(KeyPurposeID keyPurposeId);
    public IList`1<DerObjectIdentifier> GetAllUsages();
    public int get_Count();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.GeneralName : Asn1Encodable {
    public static int OtherName;
    public static int Rfc822Name;
    public static int DnsName;
    public static int X400Address;
    public static int DirectoryName;
    public static int EdiPartyName;
    public static int UniformResourceIdentifier;
    public static int IPAddress;
    public static int RegisteredID;
    private int m_tag;
    private Asn1Encodable m_object;
    public int TagNo { get; }
    public Asn1Encodable Name { get; }
    public GeneralName(X509Name directoryName);
    public GeneralName(Asn1Object name, int tag);
    public GeneralName(int tag, Asn1Encodable name);
    public GeneralName(int tag, string name);
    public static GeneralName GetInstance(object obj);
    public static GeneralName GetInstance(Asn1TaggedObject tagObj, bool explicitly);
    private static GeneralName GetInstanceSelection(Asn1TaggedObject taggedObject);
    public int get_TagNo();
    public Asn1Encodable get_Name();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private Byte[] ToGeneralNameEncoding(string ip);
    private static void CopyInts(Int32[] parsedIp, Byte[] addr, int offSet);
    private static void ParseIPv4(string ip, Byte[] addr, int offset);
    private static void ParseIPv4Mask(string mask, Byte[] addr, int offset);
    private static Int32[] ParseIPv6(string ip);
    private static Int32[] ParseIPv6Mask(string mask);
}
public class Org.BouncyCastle.Asn1.X509.GeneralNames : Asn1Encodable {
    private GeneralName[] m_names;
    public GeneralNames(GeneralName name);
    public GeneralNames(GeneralName[] names);
    private GeneralNames(Asn1Sequence seq);
    public static GeneralNames GetInstance(object obj);
    public static GeneralNames GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static GeneralNames FromExtensions(X509Extensions extensions, DerObjectIdentifier extOid);
    private static GeneralName[] Copy(GeneralName[] names);
    public GeneralName[] GetNames();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.GeneralSubtree : Asn1Encodable {
    private GeneralName baseName;
    private DerInteger minimum;
    private DerInteger maximum;
    public GeneralName Base { get; }
    public BigInteger Minimum { get; }
    public BigInteger Maximum { get; }
    private GeneralSubtree(Asn1Sequence seq);
    public GeneralSubtree(GeneralName baseName, BigInteger minimum, BigInteger maximum);
    public GeneralSubtree(GeneralName baseName);
    public static GeneralSubtree GetInstance(Asn1TaggedObject o, bool isExplicit);
    public static GeneralSubtree GetInstance(object obj);
    public GeneralName get_Base();
    public BigInteger get_Minimum();
    public BigInteger get_Maximum();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Holder : Asn1Encodable {
    internal IssuerSerial baseCertificateID;
    internal GeneralNames entityName;
    internal ObjectDigestInfo objectDigestInfo;
    private int version;
    public int Version { get; }
    public IssuerSerial BaseCertificateID { get; }
    public GeneralNames EntityName { get; }
    public ObjectDigestInfo ObjectDigestInfo { get; }
    public Holder(Asn1TaggedObject tagObj);
    private Holder(Asn1Sequence seq);
    public Holder(IssuerSerial baseCertificateID);
    public Holder(IssuerSerial baseCertificateID, int version);
    public Holder(GeneralNames entityName);
    public Holder(GeneralNames entityName, int version);
    public Holder(ObjectDigestInfo objectDigestInfo);
    public static Holder GetInstance(object obj);
    public int get_Version();
    public IssuerSerial get_BaseCertificateID();
    public GeneralNames get_EntityName();
    public ObjectDigestInfo get_ObjectDigestInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IetfAttrSyntax : Asn1Encodable {
    public static int ValueOctets;
    public static int ValueOid;
    public static int ValueUtf8;
    internal GeneralNames policyAuthority;
    internal Asn1EncodableVector values;
    internal int valueChoice;
    public GeneralNames PolicyAuthority { get; }
    public int ValueType { get; }
    public IetfAttrSyntax(Asn1Sequence seq);
    public GeneralNames get_PolicyAuthority();
    public int get_ValueType();
    public Object[] GetValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IssuerSerial : Asn1Encodable {
    internal GeneralNames issuer;
    internal DerInteger serial;
    internal DerBitString issuerUid;
    public GeneralNames Issuer { get; }
    public DerInteger Serial { get; }
    public DerBitString IssuerUid { get; }
    private IssuerSerial(Asn1Sequence seq);
    public IssuerSerial(GeneralNames issuer, DerInteger serial);
    public static IssuerSerial GetInstance(object obj);
    public static IssuerSerial GetInstance(Asn1TaggedObject obj, bool explicitly);
    public GeneralNames get_Issuer();
    public DerInteger get_Serial();
    public DerBitString get_IssuerUid();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint : Asn1Encodable {
    private DistributionPointName _distributionPoint;
    private bool _onlyContainsUserCerts;
    private bool _onlyContainsCACerts;
    private ReasonFlags _onlySomeReasons;
    private bool _indirectCRL;
    private bool _onlyContainsAttributeCerts;
    private Asn1Sequence seq;
    public bool OnlyContainsUserCerts { get; }
    public bool OnlyContainsCACerts { get; }
    public bool IsIndirectCrl { get; }
    public bool OnlyContainsAttributeCerts { get; }
    public DistributionPointName DistributionPoint { get; }
    public ReasonFlags OnlySomeReasons { get; }
    public IssuingDistributionPoint(DistributionPointName distributionPoint, bool onlyContainsUserCerts, bool onlyContainsCACerts, ReasonFlags onlySomeReasons, bool indirectCRL, bool onlyContainsAttributeCerts);
    private IssuingDistributionPoint(Asn1Sequence seq);
    public static IssuingDistributionPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static IssuingDistributionPoint GetInstance(object obj);
    public bool get_OnlyContainsUserCerts();
    public bool get_OnlyContainsCACerts();
    public bool get_IsIndirectCrl();
    public bool get_OnlyContainsAttributeCerts();
    public DistributionPointName get_DistributionPoint();
    public ReasonFlags get_OnlySomeReasons();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void AppendObject(StringBuilder buf, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.KeyPurposeID : DerObjectIdentifier {
    private static string id_kp;
    public static KeyPurposeID AnyExtendedKeyUsage;
    public static KeyPurposeID id_kp_serverAuth;
    public static KeyPurposeID id_kp_clientAuth;
    public static KeyPurposeID id_kp_codeSigning;
    public static KeyPurposeID id_kp_emailProtection;
    public static KeyPurposeID id_kp_ipsecEndSystem;
    public static KeyPurposeID id_kp_ipsecTunnel;
    public static KeyPurposeID id_kp_ipsecUser;
    public static KeyPurposeID id_kp_timeStamping;
    public static KeyPurposeID id_kp_OCSPSigning;
    public static KeyPurposeID id_kp_dvcs;
    public static KeyPurposeID id_kp_sbgpCertAAServerAuth;
    public static KeyPurposeID id_kp_scvp_responder;
    public static KeyPurposeID id_kp_eapOverPPP;
    public static KeyPurposeID id_kp_eapOverLAN;
    public static KeyPurposeID id_kp_scvpServer;
    public static KeyPurposeID id_kp_scvpClient;
    public static KeyPurposeID id_kp_ipsecIKE;
    public static KeyPurposeID id_kp_capwapAC;
    public static KeyPurposeID id_kp_capwapWTP;
    public static KeyPurposeID id_kp_cmcCA;
    public static KeyPurposeID id_kp_cmcRA;
    public static KeyPurposeID id_kp_cmKGA;
    public static KeyPurposeID id_kp_smartcardlogon;
    public static KeyPurposeID id_kp_macAddress;
    public static KeyPurposeID id_kp_msSGC;
    private static string id_pkinit;
    public static KeyPurposeID scSysNodeNumber;
    public static KeyPurposeID id_pkinit_authData;
    public static KeyPurposeID id_pkinit_DHKeyData;
    public static KeyPurposeID id_pkinit_rkeyData;
    public static KeyPurposeID keyPurposeClientAuth;
    public static KeyPurposeID keyPurposeKdc;
    public static KeyPurposeID id_kp_nsSGC;
    [ObsoleteAttribute("Use 'id_kp_serverAuth' instead")]
public static KeyPurposeID IdKPServerAuth;
    [ObsoleteAttribute("Use 'id_kp_clientAuth' instead")]
public static KeyPurposeID IdKPClientAuth;
    [ObsoleteAttribute("Use 'id_kp_codeSigning' instead")]
public static KeyPurposeID IdKPCodeSigning;
    [ObsoleteAttribute("Use 'id_kp_emailProtection' instead")]
public static KeyPurposeID IdKPEmailProtection;
    [ObsoleteAttribute("Use 'id_kp_ipsecEndSystem' instead")]
public static KeyPurposeID IdKPIpsecEndSystem;
    [ObsoleteAttribute("Use 'id_kp_ipsecTunnel' instead")]
public static KeyPurposeID IdKPIpsecTunnel;
    [ObsoleteAttribute("Use 'id_kp_ipsecUser' instead")]
public static KeyPurposeID IdKPIpsecUser;
    [ObsoleteAttribute("Use 'id_kp_timeStamping' instead")]
public static KeyPurposeID IdKPTimeStamping;
    [ObsoleteAttribute("Use 'id_kp_OCSPSigning' instead")]
public static KeyPurposeID IdKPOcspSigning;
    [ObsoleteAttribute("Use 'id_kp_smartcardlogon' instead")]
public static KeyPurposeID IdKPSmartCardLogon;
    [ObsoleteAttribute("Use 'id_kp_macAddress' instead")]
public static KeyPurposeID IdKPMacAddress;
    private KeyPurposeID(string id);
    private static KeyPurposeID();
}
public class Org.BouncyCastle.Asn1.X509.KeyUsage : DerBitString {
    public static int DigitalSignature;
    public static int NonRepudiation;
    public static int KeyEncipherment;
    public static int DataEncipherment;
    public static int KeyAgreement;
    public static int KeyCertSign;
    public static int CrlSign;
    public static int EncipherOnly;
    public static int DecipherOnly;
    public KeyUsage(int usage);
    private KeyUsage(DerBitString usage);
    public static KeyUsage GetInstance(object obj);
    public static KeyUsage FromExtensions(X509Extensions extensions);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.NameConstraints : Asn1Encodable {
    private Asn1Sequence m_permitted;
    private Asn1Sequence m_excluded;
    public Asn1Sequence PermittedSubtrees { get; }
    public Asn1Sequence ExcludedSubtrees { get; }
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public NameConstraints(Asn1Sequence seq);
    public NameConstraints(IList`1<GeneralSubtree> permitted, IList`1<GeneralSubtree> excluded);
    public static NameConstraints GetInstance(object obj);
    public static NameConstraints GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    private DerSequence CreateSequence(IList`1<GeneralSubtree> subtrees);
    public Asn1Sequence get_PermittedSubtrees();
    public Asn1Sequence get_ExcludedSubtrees();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.NoticeReference : Asn1Encodable {
    private DisplayText organization;
    private Asn1Sequence noticeNumbers;
    public DisplayText Organization { get; }
    public NoticeReference(string organization, IList`1<object> numbers);
    public NoticeReference(string organization, Asn1EncodableVector noticeNumbers);
    public NoticeReference(DisplayText organization, Asn1EncodableVector noticeNumbers);
    private NoticeReference(Asn1Sequence seq);
    private static Asn1EncodableVector ConvertVector(IList`1<object> numbers);
    public static NoticeReference GetInstance(object obj);
    public virtual DisplayText get_Organization();
    public virtual DerInteger[] GetNoticeNumbers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ObjectDigestInfo : Asn1Encodable {
    public static int PublicKey;
    public static int PublicKeyCert;
    public static int OtherObjectDigest;
    internal DerEnumerated digestedObjectType;
    internal DerObjectIdentifier otherObjectTypeID;
    internal AlgorithmIdentifier digestAlgorithm;
    internal DerBitString objectDigest;
    public DerEnumerated DigestedObjectType { get; }
    public DerObjectIdentifier OtherObjectTypeID { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public DerBitString ObjectDigest { get; }
    public ObjectDigestInfo(int digestedObjectType, string otherObjectTypeID, AlgorithmIdentifier digestAlgorithm, Byte[] objectDigest);
    private ObjectDigestInfo(Asn1Sequence seq);
    public static ObjectDigestInfo GetInstance(object obj);
    public static ObjectDigestInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public DerEnumerated get_DigestedObjectType();
    public DerObjectIdentifier get_OtherObjectTypeID();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public DerBitString get_ObjectDigest();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.OtherName : Asn1Encodable {
    private DerObjectIdentifier typeID;
    private Asn1Encodable value;
    public DerObjectIdentifier TypeID { get; }
    public Asn1Encodable Value { get; }
    public OtherName(DerObjectIdentifier typeID, Asn1Encodable value);
    private OtherName(Asn1Sequence seq);
    public static OtherName GetInstance(object obj);
    public static OtherName GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public virtual DerObjectIdentifier get_TypeID();
    public Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyInformation : Asn1Encodable {
    private DerObjectIdentifier policyIdentifier;
    private Asn1Sequence policyQualifiers;
    public DerObjectIdentifier PolicyIdentifier { get; }
    public Asn1Sequence PolicyQualifiers { get; }
    private PolicyInformation(Asn1Sequence seq);
    public PolicyInformation(DerObjectIdentifier policyIdentifier);
    public PolicyInformation(DerObjectIdentifier policyIdentifier, Asn1Sequence policyQualifiers);
    public static PolicyInformation GetInstance(object obj);
    public DerObjectIdentifier get_PolicyIdentifier();
    public Asn1Sequence get_PolicyQualifiers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyMappings : Asn1Encodable {
    private Asn1Sequence seq;
    public PolicyMappings(Asn1Sequence seq);
    public PolicyMappings(IDictionary`2<string, string> mappings);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyQualifierID : DerObjectIdentifier {
    private static string IdQt;
    public static PolicyQualifierID IdQtCps;
    public static PolicyQualifierID IdQtUnotice;
    private PolicyQualifierID(string id);
    private static PolicyQualifierID();
}
public class Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo : Asn1Encodable {
    private DerObjectIdentifier policyQualifierId;
    private Asn1Encodable qualifier;
    public DerObjectIdentifier PolicyQualifierId { get; }
    public Asn1Encodable Qualifier { get; }
    public PolicyQualifierInfo(DerObjectIdentifier policyQualifierId, Asn1Encodable qualifier);
    public PolicyQualifierInfo(string cps);
    private PolicyQualifierInfo(Asn1Sequence seq);
    public static PolicyQualifierInfo GetInstance(object obj);
    public virtual DerObjectIdentifier get_PolicyQualifierId();
    public virtual Asn1Encodable get_Qualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PrivateKeyUsagePeriod : Asn1Encodable {
    private Asn1GeneralizedTime _notBefore;
    private Asn1GeneralizedTime _notAfter;
    public Asn1GeneralizedTime NotBefore { get; }
    public Asn1GeneralizedTime NotAfter { get; }
    private PrivateKeyUsagePeriod(Asn1Sequence seq);
    public static PrivateKeyUsagePeriod GetInstance(object obj);
    public Asn1GeneralizedTime get_NotBefore();
    public Asn1GeneralizedTime get_NotAfter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.BiometricData : Asn1Encodable {
    private TypeOfBiometricData typeOfBiometricData;
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString biometricDataHash;
    private DerIA5String sourceDataUri;
    public TypeOfBiometricData TypeOfBiometricData { get; }
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Asn1OctetString BiometricDataHash { get; }
    public DerIA5String SourceDataUri { get; }
    private BiometricData(Asn1Sequence seq);
    public BiometricData(TypeOfBiometricData typeOfBiometricData, AlgorithmIdentifier hashAlgorithm, Asn1OctetString biometricDataHash, DerIA5String sourceDataUri);
    public BiometricData(TypeOfBiometricData typeOfBiometricData, AlgorithmIdentifier hashAlgorithm, Asn1OctetString biometricDataHash);
    public static BiometricData GetInstance(object obj);
    public TypeOfBiometricData get_TypeOfBiometricData();
    public AlgorithmIdentifier get_HashAlgorithm();
    public Asn1OctetString get_BiometricDataHash();
    public DerIA5String get_SourceDataUri();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X509.Qualified.EtsiQCObjectIdentifiers : object {
    public static DerObjectIdentifier IdEtsiQcs;
    public static DerObjectIdentifier IdEtsiQcsQcCompliance;
    public static DerObjectIdentifier IdEtsiQcsLimitValue;
    public static DerObjectIdentifier IdEtsiQcsRetentionPeriod;
    public static DerObjectIdentifier IdEtsiQcsQcSscd;
    private static EtsiQCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.Iso4217CurrencyCode : Asn1Encodable {
    internal static int AlphabeticMaxSize;
    internal static int NumericMinSize;
    internal static int NumericMaxSize;
    internal Asn1Encodable obj;
    public bool IsAlphabetic { get; }
    public string Alphabetic { get; }
    public int Numeric { get; }
    public Iso4217CurrencyCode(int numeric);
    public Iso4217CurrencyCode(string alphabetic);
    public static Iso4217CurrencyCode GetInstance(object obj);
    public bool get_IsAlphabetic();
    public string get_Alphabetic();
    public int get_Numeric();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.MonetaryValue : Asn1Encodable {
    internal Iso4217CurrencyCode currency;
    internal DerInteger amount;
    internal DerInteger exponent;
    public Iso4217CurrencyCode Currency { get; }
    public BigInteger Amount { get; }
    public BigInteger Exponent { get; }
    private MonetaryValue(Asn1Sequence seq);
    public MonetaryValue(Iso4217CurrencyCode currency, int amount, int exponent);
    public static MonetaryValue GetInstance(object obj);
    public Iso4217CurrencyCode get_Currency();
    public BigInteger get_Amount();
    public BigInteger get_Exponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.QCStatement : Asn1Encodable {
    private DerObjectIdentifier qcStatementId;
    private Asn1Encodable qcStatementInfo;
    public DerObjectIdentifier StatementId { get; }
    public Asn1Encodable StatementInfo { get; }
    private QCStatement(Asn1Sequence seq);
    public QCStatement(DerObjectIdentifier qcStatementId);
    public QCStatement(DerObjectIdentifier qcStatementId, Asn1Encodable qcStatementInfo);
    public static QCStatement GetInstance(object obj);
    public DerObjectIdentifier get_StatementId();
    public Asn1Encodable get_StatementInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.Rfc3739QCObjectIdentifiers : object {
    public static DerObjectIdentifier IdQcs;
    public static DerObjectIdentifier IdQcsPkixQCSyntaxV1;
    public static DerObjectIdentifier IdQcsPkixQCSyntaxV2;
    private static Rfc3739QCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.SemanticsInformation : Asn1Encodable {
    private DerObjectIdentifier semanticsIdentifier;
    private GeneralName[] nameRegistrationAuthorities;
    public DerObjectIdentifier SemanticsIdentifier { get; }
    public SemanticsInformation(Asn1Sequence seq);
    public SemanticsInformation(DerObjectIdentifier semanticsIdentifier, GeneralName[] generalNames);
    public SemanticsInformation(DerObjectIdentifier semanticsIdentifier);
    public SemanticsInformation(GeneralName[] generalNames);
    public static SemanticsInformation GetInstance(object obj);
    public DerObjectIdentifier get_SemanticsIdentifier();
    public GeneralName[] GetNameRegistrationAuthorities();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.TypeOfBiometricData : Asn1Encodable {
    public static int Picture;
    public static int HandwrittenSignature;
    internal Asn1Encodable obj;
    public bool IsPredefined { get; }
    public int PredefinedBiometricType { get; }
    public DerObjectIdentifier BiometricDataOid { get; }
    public TypeOfBiometricData(int predefinedBiometricType);
    public TypeOfBiometricData(DerObjectIdentifier biometricDataOid);
    public static TypeOfBiometricData GetInstance(object obj);
    public bool get_IsPredefined();
    public int get_PredefinedBiometricType();
    public DerObjectIdentifier get_BiometricDataOid();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ReasonFlags : DerBitString {
    public static int Unused;
    public static int KeyCompromise;
    public static int CACompromise;
    public static int AffiliationChanged;
    public static int Superseded;
    public static int CessationOfOperation;
    public static int CertificateHold;
    public static int PrivilegeWithdrawn;
    public static int AACompromise;
    public ReasonFlags(int reasons);
    public ReasonFlags(DerBitString reasons);
}
public class Org.BouncyCastle.Asn1.X509.RoleSyntax : Asn1Encodable {
    private GeneralNames roleAuthority;
    private GeneralName roleName;
    public GeneralNames RoleAuthority { get; }
    public GeneralName RoleName { get; }
    public RoleSyntax(GeneralNames roleAuthority, GeneralName roleName);
    public RoleSyntax(GeneralName roleName);
    public RoleSyntax(string roleName);
    private RoleSyntax(Asn1Sequence seq);
    public static RoleSyntax GetInstance(object obj);
    public GeneralNames get_RoleAuthority();
    public GeneralName get_RoleName();
    public string GetRoleNameAsString();
    public String[] GetRoleAuthorityAsString();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure : Asn1Encodable {
    private BigInteger modulus;
    private BigInteger publicExponent;
    public BigInteger Modulus { get; }
    public BigInteger PublicExponent { get; }
    public RsaPublicKeyStructure(BigInteger modulus, BigInteger publicExponent);
    private RsaPublicKeyStructure(Asn1Sequence seq);
    public static RsaPublicKeyStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static RsaPublicKeyStructure GetInstance(object obj);
    public BigInteger get_Modulus();
    public BigInteger get_PublicExponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym : Asn1Encodable {
    private DirectoryString pseudonym;
    private DirectoryString surname;
    private Asn1Sequence givenName;
    public DirectoryString Pseudonym { get; }
    public DirectoryString Surname { get; }
    public NameOrPseudonym(DirectoryString pseudonym);
    private NameOrPseudonym(Asn1Sequence seq);
    public NameOrPseudonym(string pseudonym);
    public NameOrPseudonym(DirectoryString surname, Asn1Sequence givenName);
    public static NameOrPseudonym GetInstance(object obj);
    public DirectoryString get_Pseudonym();
    public DirectoryString get_Surname();
    public DirectoryString[] GetGivenName();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.PersonalData : Asn1Encodable {
    private NameOrPseudonym nameOrPseudonym;
    private BigInteger nameDistinguisher;
    private Asn1GeneralizedTime dateOfBirth;
    private DirectoryString placeOfBirth;
    private string gender;
    private DirectoryString postalAddress;
    public NameOrPseudonym NameOrPseudonym { get; }
    public BigInteger NameDistinguisher { get; }
    public Asn1GeneralizedTime DateOfBirth { get; }
    public DirectoryString PlaceOfBirth { get; }
    public string Gender { get; }
    public DirectoryString PostalAddress { get; }
    private PersonalData(Asn1Sequence seq);
    public PersonalData(NameOrPseudonym nameOrPseudonym, BigInteger nameDistinguisher, Asn1GeneralizedTime dateOfBirth, DirectoryString placeOfBirth, string gender, DirectoryString postalAddress);
    public static PersonalData GetInstance(object obj);
    public NameOrPseudonym get_NameOrPseudonym();
    public BigInteger get_NameDistinguisher();
    public Asn1GeneralizedTime get_DateOfBirth();
    public DirectoryString get_PlaceOfBirth();
    public string get_Gender();
    public DirectoryString get_PostalAddress();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers : object {
    public static DerObjectIdentifier IdSigI;
    public static DerObjectIdentifier IdSigIKP;
    public static DerObjectIdentifier IdSigICP;
    public static DerObjectIdentifier IdSigION;
    public static DerObjectIdentifier IdSigIKPDirectoryService;
    public static DerObjectIdentifier IdSigIONPersonalData;
    public static DerObjectIdentifier IdSigICPSigConform;
    private static SigIObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.SubjectAltPublicKeyInfo : Asn1Encodable {
    private AlgorithmIdentifier m_algorithm;
    private DerBitString m_subjectAltPublicKey;
    public AlgorithmIdentifier Algorithm { get; }
    public DerBitString SubjectAltPublicKey { get; }
    private SubjectAltPublicKeyInfo(Asn1Sequence seq);
    public SubjectAltPublicKeyInfo(AlgorithmIdentifier algorithm, DerBitString subjectAltPublicKey);
    public SubjectAltPublicKeyInfo(SubjectPublicKeyInfo subjectPublicKeyInfo);
    public static SubjectAltPublicKeyInfo GetInstance(object obj);
    public static SubjectAltPublicKeyInfo GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public static SubjectAltPublicKeyInfo FromExtensions(X509Extensions extensions);
    public AlgorithmIdentifier get_Algorithm();
    public DerBitString get_SubjectAltPublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes : Asn1Encodable {
    private List`1<AttributeX509> m_attributes;
    public IEnumerable`1<AttributeX509> Attributes { get; }
    private SubjectDirectoryAttributes(Asn1Sequence seq);
    public SubjectDirectoryAttributes(IList`1<AttributeX509> attributes);
    public static SubjectDirectoryAttributes GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public IEnumerable`1<AttributeX509> get_Attributes();
}
public class Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier : Asn1Encodable {
    private Byte[] keyIdentifier;
    public SubjectKeyIdentifier(Byte[] keyID);
    public SubjectKeyIdentifier(Asn1OctetString keyID);
    public SubjectKeyIdentifier(SubjectPublicKeyInfo spki);
    public static SubjectKeyIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SubjectKeyIdentifier GetInstance(object obj);
    public static SubjectKeyIdentifier FromExtensions(X509Extensions extensions);
    public Byte[] GetKeyIdentifier();
    public virtual Asn1Object ToAsn1Object();
    public static SubjectKeyIdentifier CreateSha1KeyIdentifier(SubjectPublicKeyInfo keyInfo);
    public static SubjectKeyIdentifier CreateTruncatedSha1KeyIdentifier(SubjectPublicKeyInfo keyInfo);
    private static Byte[] GetDigest(SubjectPublicKeyInfo spki);
}
public class Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo : Asn1Encodable {
    private AlgorithmIdentifier algID;
    private DerBitString keyData;
    public AlgorithmIdentifier AlgorithmID { get; }
    public DerBitString PublicKeyData { get; }
    public SubjectPublicKeyInfo(AlgorithmIdentifier algID, Asn1Encodable publicKey);
    public SubjectPublicKeyInfo(AlgorithmIdentifier algID, Byte[] publicKey);
    private SubjectPublicKeyInfo(Asn1Sequence seq);
    public static SubjectPublicKeyInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SubjectPublicKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Asn1Object ParsePublicKey();
    public DerBitString get_PublicKeyData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Target : Asn1Encodable {
    private GeneralName targetName;
    private GeneralName targetGroup;
    public GeneralName TargetGroup { get; }
    public GeneralName TargetName { get; }
    private Target(Asn1TaggedObject tagObj);
    public Target(Choice type, GeneralName name);
    public static Target GetInstance(object obj);
    public virtual GeneralName get_TargetGroup();
    public virtual GeneralName get_TargetName();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TargetInformation : Asn1Encodable {
    private Asn1Sequence targets;
    private TargetInformation(Asn1Sequence targets);
    public TargetInformation(Targets targets);
    public TargetInformation(Target[] targets);
    public static TargetInformation GetInstance(object obj);
    public virtual Targets[] GetTargetsObjects();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Targets : Asn1Encodable {
    private Asn1Sequence targets;
    private Targets(Asn1Sequence targets);
    public Targets(Target[] targets);
    public static Targets GetInstance(object obj);
    public virtual Target[] GetTargets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TbsCertificateList : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger version;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time thisUpdate;
    internal Time nextUpdate;
    internal Asn1Sequence revokedCertificates;
    internal X509Extensions crlExtensions;
    public int Version { get; }
    public DerInteger VersionNumber { get; }
    public AlgorithmIdentifier Signature { get; }
    public X509Name Issuer { get; }
    public Time ThisUpdate { get; }
    public Time NextUpdate { get; }
    public X509Extensions Extensions { get; }
    private TbsCertificateList(Asn1Sequence seq);
    public static TbsCertificateList GetInstance(object obj);
    public static TbsCertificateList GetInstance(Asn1TaggedObject obj, bool explicitly);
    public int get_Version();
    public DerInteger get_VersionNumber();
    public AlgorithmIdentifier get_Signature();
    public X509Name get_Issuer();
    public Time get_ThisUpdate();
    public Time get_NextUpdate();
    public CrlEntry[] GetRevokedCertificates();
    public IEnumerable`1<CrlEntry> GetRevokedCertificateEnumeration();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TbsCertificateStructure : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    internal DerBitString issuerUniqueID;
    internal DerBitString subjectUniqueID;
    internal X509Extensions extensions;
    public int Version { get; }
    public DerInteger VersionNumber { get; }
    public DerInteger SerialNumber { get; }
    public AlgorithmIdentifier Signature { get; }
    public X509Name Issuer { get; }
    public Time StartDate { get; }
    public Time EndDate { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public DerBitString IssuerUniqueID { get; }
    public DerBitString SubjectUniqueID { get; }
    public X509Extensions Extensions { get; }
    private TbsCertificateStructure(Asn1Sequence seq);
    public static TbsCertificateStructure GetInstance(object obj);
    public static TbsCertificateStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public int get_Version();
    public DerInteger get_VersionNumber();
    public DerInteger get_SerialNumber();
    public AlgorithmIdentifier get_Signature();
    public X509Name get_Issuer();
    public Time get_StartDate();
    public Time get_EndDate();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public DerBitString get_IssuerUniqueID();
    public DerBitString get_SubjectUniqueID();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Time : Asn1Encodable {
    private Asn1Object m_timeObject;
    public Time(Asn1GeneralizedTime generalizedTime);
    public Time(Asn1UtcTime utcTime);
    public Time(DateTime date);
    public static Time GetInstance(object obj);
    public static Time GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public DateTime ToDateTime();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.UserNotice : Asn1Encodable {
    private NoticeReference noticeRef;
    private DisplayText explicitText;
    public NoticeReference NoticeRef { get; }
    public DisplayText ExplicitText { get; }
    public UserNotice(NoticeReference noticeRef, DisplayText explicitText);
    public UserNotice(NoticeReference noticeRef, string str);
    private UserNotice(Asn1Sequence seq);
    public static UserNotice GetInstance(object obj);
    public virtual NoticeReference get_NoticeRef();
    public virtual DisplayText get_ExplicitText();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.V1TbsCertificateGenerator : object {
    internal DerTaggedObject version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetStartDate(Time startDate);
    public void SetStartDate(Asn1UtcTime startDate);
    public void SetEndDate(Time endDate);
    public void SetEndDate(Asn1UtcTime endDate);
    public void SetSubject(X509Name subject);
    public void SetSubjectPublicKeyInfo(SubjectPublicKeyInfo pubKeyInfo);
    public TbsCertificateStructure GenerateTbsCertificate();
}
public class Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator : object {
    internal DerInteger version;
    internal Holder holder;
    internal AttCertIssuer issuer;
    internal AlgorithmIdentifier signature;
    internal DerInteger serialNumber;
    internal Asn1EncodableVector attributes;
    internal DerBitString issuerUniqueID;
    internal X509Extensions extensions;
    internal Asn1GeneralizedTime startDate;
    internal Asn1GeneralizedTime endDate;
    public void SetHolder(Holder holder);
    public void AddAttribute(string oid, Asn1Encodable value);
    public void AddAttribute(AttributeX509 attribute);
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(AttCertIssuer issuer);
    public void SetStartDate(Asn1GeneralizedTime startDate);
    public void SetEndDate(Asn1GeneralizedTime endDate);
    public void SetIssuerUniqueID(DerBitString issuerUniqueID);
    public void SetExtensions(X509Extensions extensions);
    public AttributeCertificateInfo GenerateAttributeCertificateInfo();
}
public class Org.BouncyCastle.Asn1.X509.V2Form : Asn1Encodable {
    internal GeneralNames issuerName;
    internal IssuerSerial baseCertificateID;
    internal ObjectDigestInfo objectDigestInfo;
    public GeneralNames IssuerName { get; }
    public IssuerSerial BaseCertificateID { get; }
    public ObjectDigestInfo ObjectDigestInfo { get; }
    public V2Form(GeneralNames issuerName);
    public V2Form(GeneralNames issuerName, IssuerSerial baseCertificateID);
    public V2Form(GeneralNames issuerName, ObjectDigestInfo objectDigestInfo);
    public V2Form(GeneralNames issuerName, IssuerSerial baseCertificateID, ObjectDigestInfo objectDigestInfo);
    private V2Form(Asn1Sequence seq);
    public static V2Form GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static V2Form GetInstance(object obj);
    public GeneralNames get_IssuerName();
    public IssuerSerial get_BaseCertificateID();
    public ObjectDigestInfo get_ObjectDigestInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.V2TbsCertListGenerator : object {
    private DerInteger version;
    private AlgorithmIdentifier signature;
    private X509Name issuer;
    private Time thisUpdate;
    private Time nextUpdate;
    private X509Extensions extensions;
    private List`1<Asn1Sequence> crlEntries;
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetThisUpdate(Asn1UtcTime thisUpdate);
    public void SetNextUpdate(Asn1UtcTime nextUpdate);
    public void SetThisUpdate(Time thisUpdate);
    public void SetNextUpdate(Time nextUpdate);
    public void AddCrlEntry(Asn1Sequence crlEntry);
    public void AddCrlEntry(DerInteger userCertificate, Asn1UtcTime revocationDate, int reason);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, int reason);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, int reason, Asn1GeneralizedTime invalidityDate);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, X509Extensions extensions);
    public void SetExtensions(X509Extensions extensions);
    public Asn1Sequence GeneratePreTbsCertList();
    public TbsCertificateList GenerateTbsCertList();
    private Asn1Sequence GenerateTbsCertificateStructure();
}
public class Org.BouncyCastle.Asn1.X509.V3TbsCertificateGenerator : object {
    internal DerTaggedObject version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    internal X509Extensions extensions;
    private bool altNamePresentAndCritical;
    private DerBitString issuerUniqueID;
    private DerBitString subjectUniqueID;
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetStartDate(Asn1UtcTime startDate);
    public void SetStartDate(Time startDate);
    public void SetEndDate(Asn1UtcTime endDate);
    public void SetEndDate(Time endDate);
    public void SetSubject(X509Name subject);
    public void SetIssuerUniqueID(DerBitString uniqueID);
    public void SetSubjectUniqueID(DerBitString uniqueID);
    public void SetSubjectPublicKeyInfo(SubjectPublicKeyInfo pubKeyInfo);
    public void SetExtensions(X509Extensions extensions);
    public Asn1Sequence GeneratePreTbsCertificate();
    public TbsCertificateStructure GenerateTbsCertificate();
    private Asn1Sequence GenerateTbsStructure();
}
public class Org.BouncyCastle.Asn1.X509.X509Attributes : object {
    public static DerObjectIdentifier RoleSyntax;
    private static X509Attributes();
}
public class Org.BouncyCastle.Asn1.X509.X509CertificateStructure : Asn1Encodable {
    private TbsCertificateStructure tbsCert;
    private AlgorithmIdentifier sigAlgID;
    private DerBitString sig;
    public TbsCertificateStructure TbsCertificate { get; }
    public int Version { get; }
    public DerInteger SerialNumber { get; }
    public X509Name Issuer { get; }
    public Time StartDate { get; }
    public Time EndDate { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public X509CertificateStructure(TbsCertificateStructure tbsCert, AlgorithmIdentifier sigAlgID, DerBitString sig);
    private X509CertificateStructure(Asn1Sequence seq);
    public static X509CertificateStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509CertificateStructure GetInstance(object obj);
    public TbsCertificateStructure get_TbsCertificate();
    public int get_Version();
    public DerInteger get_SerialNumber();
    public X509Name get_Issuer();
    public Time get_StartDate();
    public Time get_EndDate();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public Byte[] GetSignatureOctets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter : X509NameEntryConverter {
    public virtual Asn1Object GetConvertedValue(DerObjectIdentifier oid, string value);
}
public class Org.BouncyCastle.Asn1.X509.X509Extension : object {
    internal bool critical;
    internal Asn1OctetString value;
    public bool IsCritical { get; }
    public Asn1OctetString Value { get; }
    public X509Extension(DerBoolean critical, Asn1OctetString value);
    public X509Extension(bool critical, Asn1OctetString value);
    public bool get_IsCritical();
    public Asn1OctetString get_Value();
    public Asn1Encodable GetParsedValue();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static Asn1Object ConvertValueToObject(X509Extension ext);
}
public class Org.BouncyCastle.Asn1.X509.X509Extensions : Asn1Encodable {
    public static DerObjectIdentifier SubjectDirectoryAttributes;
    public static DerObjectIdentifier SubjectKeyIdentifier;
    public static DerObjectIdentifier KeyUsage;
    public static DerObjectIdentifier PrivateKeyUsagePeriod;
    public static DerObjectIdentifier SubjectAlternativeName;
    public static DerObjectIdentifier IssuerAlternativeName;
    public static DerObjectIdentifier BasicConstraints;
    public static DerObjectIdentifier CrlNumber;
    public static DerObjectIdentifier ReasonCode;
    public static DerObjectIdentifier InstructionCode;
    public static DerObjectIdentifier InvalidityDate;
    public static DerObjectIdentifier DeltaCrlIndicator;
    public static DerObjectIdentifier IssuingDistributionPoint;
    public static DerObjectIdentifier CertificateIssuer;
    public static DerObjectIdentifier NameConstraints;
    public static DerObjectIdentifier CrlDistributionPoints;
    public static DerObjectIdentifier CertificatePolicies;
    public static DerObjectIdentifier PolicyMappings;
    public static DerObjectIdentifier AuthorityKeyIdentifier;
    public static DerObjectIdentifier PolicyConstraints;
    public static DerObjectIdentifier ExtendedKeyUsage;
    public static DerObjectIdentifier FreshestCrl;
    public static DerObjectIdentifier InhibitAnyPolicy;
    public static DerObjectIdentifier AuthorityInfoAccess;
    public static DerObjectIdentifier SubjectInfoAccess;
    public static DerObjectIdentifier LogoType;
    public static DerObjectIdentifier BiometricInfo;
    public static DerObjectIdentifier QCStatements;
    public static DerObjectIdentifier AuditIdentity;
    public static DerObjectIdentifier NoRevAvail;
    public static DerObjectIdentifier TargetInformation;
    public static DerObjectIdentifier ExpiredCertsOnCrl;
    public static DerObjectIdentifier SubjectAltPublicKeyInfo;
    public static DerObjectIdentifier AltSignatureAlgorithm;
    public static DerObjectIdentifier AltSignatureValue;
    private Dictionary`2<DerObjectIdentifier, X509Extension> m_extensions;
    private List`1<DerObjectIdentifier> m_ordering;
    public IEnumerable`1<DerObjectIdentifier> ExtensionOids { get; }
    private X509Extensions(Asn1Sequence seq);
    public X509Extensions(IDictionary`2<DerObjectIdentifier, X509Extension> extensions);
    public X509Extensions(IList`1<DerObjectIdentifier> ordering, IDictionary`2<DerObjectIdentifier, X509Extension> extensions);
    public X509Extensions(IList`1<DerObjectIdentifier> oids, IList`1<X509Extension> values);
    private static X509Extensions();
    public static X509Extension GetExtension(X509Extensions extensions, DerObjectIdentifier oid);
    public static Asn1Encodable GetExtensionParsedValue(X509Extensions extensions, DerObjectIdentifier oid);
    public static X509Extensions GetInstance(Asn1TaggedObject taggedObject, bool declaredExplicit);
    public static X509Extensions GetInstance(object obj);
    public IEnumerable`1<DerObjectIdentifier> get_ExtensionOids();
    public X509Extension GetExtension(DerObjectIdentifier oid);
    public Asn1Encodable GetExtensionParsedValue(DerObjectIdentifier oid);
    public virtual Asn1Object ToAsn1Object();
    public bool Equivalent(X509Extensions other);
    public DerObjectIdentifier[] GetExtensionOids();
    public DerObjectIdentifier[] GetNonCriticalExtensionOids();
    public DerObjectIdentifier[] GetCriticalExtensionOids();
    private DerObjectIdentifier[] GetExtensionOids(bool isCritical);
}
public class Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator : object {
    private Dictionary`2<DerObjectIdentifier, X509Extension> m_extensions;
    private List`1<DerObjectIdentifier> m_ordering;
    private static HashSet`1<DerObjectIdentifier> m_dupsAllowed;
    public bool IsEmpty { get; }
    private static X509ExtensionsGenerator();
    public void Reset();
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extValue);
    public void AddExtensions(X509Extensions extensions);
    public bool get_IsEmpty();
    public X509Extensions Generate();
    internal void AddExtension(DerObjectIdentifier oid, X509Extension x509Extension);
}
public class Org.BouncyCastle.Asn1.X509.X509Name : Asn1Encodable {
    public static DerObjectIdentifier C;
    public static DerObjectIdentifier O;
    public static DerObjectIdentifier OU;
    public static DerObjectIdentifier T;
    public static DerObjectIdentifier CN;
    public static DerObjectIdentifier Street;
    public static DerObjectIdentifier SerialNumber;
    public static DerObjectIdentifier L;
    public static DerObjectIdentifier ST;
    public static DerObjectIdentifier Surname;
    public static DerObjectIdentifier GivenName;
    public static DerObjectIdentifier Initials;
    public static DerObjectIdentifier Generation;
    public static DerObjectIdentifier UniqueIdentifier;
    public static DerObjectIdentifier BusinessCategory;
    public static DerObjectIdentifier PostalCode;
    public static DerObjectIdentifier DnQualifier;
    public static DerObjectIdentifier Pseudonym;
    public static DerObjectIdentifier DateOfBirth;
    public static DerObjectIdentifier PlaceOfBirth;
    public static DerObjectIdentifier Gender;
    public static DerObjectIdentifier CountryOfCitizenship;
    public static DerObjectIdentifier CountryOfResidence;
    public static DerObjectIdentifier NameAtBirth;
    public static DerObjectIdentifier PostalAddress;
    public static DerObjectIdentifier DmdName;
    public static DerObjectIdentifier TelephoneNumber;
    public static DerObjectIdentifier OrganizationIdentifier;
    public static DerObjectIdentifier Name;
    public static DerObjectIdentifier EmailAddress;
    public static DerObjectIdentifier UnstructuredName;
    public static DerObjectIdentifier UnstructuredAddress;
    public static DerObjectIdentifier E;
    public static DerObjectIdentifier DC;
    public static DerObjectIdentifier UID;
    private static Boolean[] defaultReverse;
    private static IDictionary`2<DerObjectIdentifier, string> DefaultSymbolsInternal;
    public static IDictionary`2<DerObjectIdentifier, string> DefaultSymbols;
    private static IDictionary`2<DerObjectIdentifier, string> RFC2253SymbolsInternal;
    public static IDictionary`2<DerObjectIdentifier, string> RFC2253Symbols;
    private static IDictionary`2<DerObjectIdentifier, string> RFC1779SymbolsInternal;
    public static IDictionary`2<DerObjectIdentifier, string> RFC1779Symbols;
    private static IDictionary`2<string, DerObjectIdentifier> DefaultLookupInternal;
    public static IDictionary`2<string, DerObjectIdentifier> DefaultLookup;
    private List`1<DerObjectIdentifier> ordering;
    private X509NameEntryConverter converter;
    private IList`1<string> values;
    private IList`1<bool> added;
    private Asn1Sequence seq;
    public static bool DefaultReverse { get; public set; }
    private static X509Name();
    protected X509Name(Asn1Sequence seq);
    public X509Name(IList`1<DerObjectIdentifier> ordering, IDictionary`2<DerObjectIdentifier, string> attributes);
    public X509Name(IList`1<DerObjectIdentifier> ordering, IDictionary`2<DerObjectIdentifier, string> attributes, X509NameEntryConverter converter);
    public X509Name(IList`1<DerObjectIdentifier> oids, IList`1<string> values);
    public X509Name(IList`1<DerObjectIdentifier> oids, IList`1<string> values, X509NameEntryConverter converter);
    public X509Name(string dirName);
    public X509Name(string dirName, X509NameEntryConverter converter);
    public X509Name(bool reverse, string dirName);
    public X509Name(bool reverse, string dirName, X509NameEntryConverter converter);
    public X509Name(bool reverse, IDictionary`2<string, DerObjectIdentifier> lookup, string dirName);
    public X509Name(bool reverse, IDictionary`2<string, DerObjectIdentifier> lookup, string dirName, X509NameEntryConverter converter);
    public static bool get_DefaultReverse();
    public static void set_DefaultReverse(bool value);
    public static X509Name GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509Name GetInstance(object obj);
    private DerObjectIdentifier DecodeOid(string name, IDictionary`2<string, DerObjectIdentifier> lookup);
    public IList`1<DerObjectIdentifier> GetOidList();
    public IList`1<string> GetValueList();
    public IList`1<string> GetValueList(DerObjectIdentifier oid);
    public virtual Asn1Object ToAsn1Object();
    public bool Equivalent(X509Name other, bool inOrder);
    public bool Equivalent(X509Name other);
    private static bool EquivalentStrings(string s1, string s2);
    private static string Canonicalize(string s);
    private static Asn1Object DecodeObject(string v);
    private static string StripInternalSpaces(string str);
    private void AppendValue(StringBuilder buf, IDictionary`2<DerObjectIdentifier, string> oidSymbols, DerObjectIdentifier oid, string val);
    public string ToString(bool reverse, IDictionary`2<DerObjectIdentifier, string> oidSymbols);
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Asn1.X509.X509NameEntryConverter : object {
    protected Asn1Object ConvertHexEncoded(string hexString, int offset);
    protected bool CanBePrintable(string str);
    public abstract virtual Asn1Object GetConvertedValue(DerObjectIdentifier oid, string value);
}
public class Org.BouncyCastle.Asn1.X509.X509NameTokenizer : object {
    private string value;
    private int index;
    private char separator;
    private StringBuilder buffer;
    public X509NameTokenizer(string oid);
    public X509NameTokenizer(string oid, char separator);
    public bool HasMoreTokens();
    public string NextToken();
}
public abstract class Org.BouncyCastle.Asn1.X509.X509ObjectIdentifiers : object {
    internal static string ID;
    public static DerObjectIdentifier CommonName;
    public static DerObjectIdentifier CountryName;
    public static DerObjectIdentifier LocalityName;
    public static DerObjectIdentifier StateOrProvinceName;
    public static DerObjectIdentifier Organization;
    public static DerObjectIdentifier OrganizationalUnitName;
    public static DerObjectIdentifier id_at_telephoneNumber;
    public static DerObjectIdentifier id_at_name;
    public static DerObjectIdentifier id_at_organizationIdentifier;
    public static DerObjectIdentifier IdSha1;
    public static DerObjectIdentifier RipeMD160;
    public static DerObjectIdentifier RipeMD160WithRsaEncryption;
    public static DerObjectIdentifier IdEARsa;
    public static DerObjectIdentifier IdPkix;
    public static DerObjectIdentifier IdPE;
    public static DerObjectIdentifier IdAD;
    public static DerObjectIdentifier IdADCAIssuers;
    public static DerObjectIdentifier IdADOcsp;
    public static DerObjectIdentifier OcspAccessMethod;
    public static DerObjectIdentifier CrlAccessMethod;
    private static X509ObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X9.DHDomainParameters : Asn1Encodable {
    private DerInteger p;
    private DerInteger g;
    private DerInteger q;
    private DerInteger j;
    private DHValidationParms validationParms;
    public DerInteger P { get; }
    public DerInteger G { get; }
    public DerInteger Q { get; }
    public DerInteger J { get; }
    public DHValidationParms ValidationParms { get; }
    public DHDomainParameters(DerInteger p, DerInteger g, DerInteger q, DerInteger j, DHValidationParms validationParms);
    private DHDomainParameters(Asn1Sequence seq);
    public static DHDomainParameters GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static DHDomainParameters GetInstance(object obj);
    private static Asn1Encodable GetNext(IEnumerator`1<Asn1Encodable> e);
    public DerInteger get_P();
    public DerInteger get_G();
    public DerInteger get_Q();
    public DerInteger get_J();
    public DHValidationParms get_ValidationParms();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.DHPublicKey : Asn1Encodable {
    private DerInteger y;
    public DerInteger Y { get; }
    public DHPublicKey(DerInteger y);
    public static DHPublicKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static DHPublicKey GetInstance(object obj);
    public DerInteger get_Y();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.DHValidationParms : Asn1Encodable {
    private DerBitString seed;
    private DerInteger pgenCounter;
    public DerBitString Seed { get; }
    public DerInteger PgenCounter { get; }
    public DHValidationParms(DerBitString seed, DerInteger pgenCounter);
    private DHValidationParms(Asn1Sequence seq);
    public static DHValidationParms GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static DHValidationParms GetInstance(object obj);
    public DerBitString get_Seed();
    public DerInteger get_PgenCounter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.ECNamedCurveTable : object {
    public static IEnumerable`1<string> Names { get; }
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public class Org.BouncyCastle.Asn1.X9.KeySpecificInfo : Asn1Encodable {
    private DerObjectIdentifier algorithm;
    private Asn1OctetString counter;
    public DerObjectIdentifier Algorithm { get; }
    public Asn1OctetString Counter { get; }
    public KeySpecificInfo(DerObjectIdentifier algorithm, Asn1OctetString counter);
    public KeySpecificInfo(Asn1Sequence seq);
    public DerObjectIdentifier get_Algorithm();
    public Asn1OctetString get_Counter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.OtherInfo : Asn1Encodable {
    private KeySpecificInfo keyInfo;
    private Asn1OctetString partyAInfo;
    private Asn1OctetString suppPubInfo;
    public KeySpecificInfo KeyInfo { get; }
    public Asn1OctetString PartyAInfo { get; }
    public Asn1OctetString SuppPubInfo { get; }
    public OtherInfo(KeySpecificInfo keyInfo, Asn1OctetString partyAInfo, Asn1OctetString suppPubInfo);
    public OtherInfo(Asn1Sequence seq);
    public KeySpecificInfo get_KeyInfo();
    public Asn1OctetString get_PartyAInfo();
    public Asn1OctetString get_SuppPubInfo();
    public virtual Asn1Object ToAsn1Object();
}
public static class Org.BouncyCastle.Asn1.X9.X962NamedCurves : object {
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, X9ECParametersHolder> curves;
    private static Dictionary`2<DerObjectIdentifier, string> names;
    public static IEnumerable`1<string> Names { get; }
    private static X962NamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public class Org.BouncyCastle.Asn1.X9.X962Parameters : Asn1Encodable {
    private Asn1Object _params;
    public bool IsNamedCurve { get; }
    public bool IsImplicitlyCA { get; }
    public Asn1Object Parameters { get; }
    public X962Parameters(X9ECParameters ecParameters);
    public X962Parameters(DerObjectIdentifier namedCurve);
    public X962Parameters(Asn1Null obj);
    private X962Parameters(Asn1Object obj);
    public static X962Parameters GetInstance(object obj);
    public bool get_IsNamedCurve();
    public bool get_IsImplicitlyCA();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9Curve : Asn1Encodable {
    private ECCurve curve;
    private Byte[] seed;
    private DerObjectIdentifier fieldIdentifier;
    public ECCurve Curve { get; }
    public X9Curve(ECCurve curve);
    public X9Curve(ECCurve curve, Byte[] seed);
    public X9Curve(X9FieldID fieldID, BigInteger order, BigInteger cofactor, Asn1Sequence seq);
    public ECCurve get_Curve();
    public Byte[] GetSeed();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9ECParameters : Asn1Encodable {
    private X9FieldID fieldID;
    private ECCurve curve;
    private X9ECPoint g;
    private BigInteger n;
    private BigInteger h;
    private Byte[] seed;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public X9Curve CurveEntry { get; }
    public X9FieldID FieldIDEntry { get; }
    public X9ECPoint BaseEntry { get; }
    public X9ECParameters(Asn1Sequence seq);
    public X9ECParameters(ECCurve curve, X9ECPoint g, BigInteger n);
    public X9ECParameters(ECCurve curve, X9ECPoint g, BigInteger n, BigInteger h);
    public X9ECParameters(ECCurve curve, X9ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public static X9ECParameters GetInstance(object obj);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public Byte[] GetSeed();
    public X9Curve get_CurveEntry();
    public X9FieldID get_FieldIDEntry();
    public X9ECPoint get_BaseEntry();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X9.X9ECParametersHolder : object {
    private ECCurve m_curve;
    private X9ECParameters m_parameters;
    public ECCurve Curve { get; }
    public X9ECParameters Parameters { get; }
    public ECCurve get_Curve();
    public X9ECParameters get_Parameters();
    protected virtual ECCurve CreateCurve();
    protected abstract virtual X9ECParameters CreateParameters();
}
public class Org.BouncyCastle.Asn1.X9.X9ECPoint : Asn1Encodable {
    private Asn1OctetString encoding;
    private ECCurve c;
    private ECPoint p;
    public ECPoint Point { get; }
    public bool IsPointCompressed { get; }
    public X9ECPoint(ECPoint p, bool compressed);
    public X9ECPoint(ECCurve c, Byte[] encoding);
    public X9ECPoint(ECCurve c, Asn1OctetString s);
    public Byte[] GetPointEncoding();
    public ECPoint get_Point();
    public bool get_IsPointCompressed();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9FieldElement : Asn1Encodable {
    private ECFieldElement f;
    public ECFieldElement Value { get; }
    public X9FieldElement(ECFieldElement f);
    public ECFieldElement get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9FieldID : Asn1Encodable {
    private DerObjectIdentifier id;
    private Asn1Object parameters;
    public DerObjectIdentifier Identifier { get; }
    public Asn1Object Parameters { get; }
    public X9FieldID(BigInteger primeP);
    public X9FieldID(int m, int k1);
    public X9FieldID(int m, int k1, int k2, int k3);
    private X9FieldID(Asn1Sequence seq);
    public static X9FieldID GetInstance(object obj);
    public DerObjectIdentifier get_Identifier();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X9.X9IntegerConverter : object {
    public static int GetByteLength(ECFieldElement fe);
    public static int GetByteLength(ECCurve c);
    public static Byte[] IntegerToBytes(BigInteger s, int qLength);
}
public abstract class Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers : object {
    public static DerObjectIdentifier ansi_X9_62;
    public static DerObjectIdentifier IdFieldType;
    public static DerObjectIdentifier PrimeField;
    public static DerObjectIdentifier CharacteristicTwoField;
    public static DerObjectIdentifier GNBasis;
    public static DerObjectIdentifier TPBasis;
    public static DerObjectIdentifier PPBasis;
    public static DerObjectIdentifier id_ecSigType;
    public static DerObjectIdentifier ECDsaWithSha1;
    public static DerObjectIdentifier id_publicKeyType;
    public static DerObjectIdentifier IdECPublicKey;
    public static DerObjectIdentifier ECDsaWithSha2;
    public static DerObjectIdentifier ECDsaWithSha224;
    public static DerObjectIdentifier ECDsaWithSha256;
    public static DerObjectIdentifier ECDsaWithSha384;
    public static DerObjectIdentifier ECDsaWithSha512;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier CTwoCurve;
    public static DerObjectIdentifier C2Pnb163v1;
    public static DerObjectIdentifier C2Pnb163v2;
    public static DerObjectIdentifier C2Pnb163v3;
    public static DerObjectIdentifier C2Pnb176w1;
    public static DerObjectIdentifier C2Tnb191v1;
    public static DerObjectIdentifier C2Tnb191v2;
    public static DerObjectIdentifier C2Tnb191v3;
    public static DerObjectIdentifier C2Onb191v4;
    public static DerObjectIdentifier C2Onb191v5;
    public static DerObjectIdentifier C2Pnb208w1;
    public static DerObjectIdentifier C2Tnb239v1;
    public static DerObjectIdentifier C2Tnb239v2;
    public static DerObjectIdentifier C2Tnb239v3;
    public static DerObjectIdentifier C2Onb239v4;
    public static DerObjectIdentifier C2Onb239v5;
    public static DerObjectIdentifier C2Pnb272w1;
    public static DerObjectIdentifier C2Pnb304w1;
    public static DerObjectIdentifier C2Tnb359v1;
    public static DerObjectIdentifier C2Pnb368w1;
    public static DerObjectIdentifier C2Tnb431r1;
    public static DerObjectIdentifier PrimeCurve;
    public static DerObjectIdentifier Prime192v1;
    public static DerObjectIdentifier Prime192v2;
    public static DerObjectIdentifier Prime192v3;
    public static DerObjectIdentifier Prime239v1;
    public static DerObjectIdentifier Prime239v2;
    public static DerObjectIdentifier Prime239v3;
    public static DerObjectIdentifier Prime256v1;
    public static DerObjectIdentifier IdDsa;
    public static DerObjectIdentifier IdDsaWithSha1;
    public static DerObjectIdentifier X9x63Scheme;
    public static DerObjectIdentifier DHSinglePassStdDHSha1KdfScheme;
    public static DerObjectIdentifier DHSinglePassCofactorDHSha1KdfScheme;
    public static DerObjectIdentifier MqvSinglePassSha1KdfScheme;
    public static DerObjectIdentifier ansi_x9_42;
    public static DerObjectIdentifier DHPublicNumber;
    public static DerObjectIdentifier X9x42Schemes;
    public static DerObjectIdentifier DHStatic;
    public static DerObjectIdentifier DHEphem;
    public static DerObjectIdentifier DHOneFlow;
    public static DerObjectIdentifier DHHybrid1;
    public static DerObjectIdentifier DHHybrid2;
    public static DerObjectIdentifier DHHybridOneFlow;
    public static DerObjectIdentifier Mqv2;
    public static DerObjectIdentifier Mqv1;
    private static X9ObjectIdentifiers();
}
public enum Org.BouncyCastle.Bcpg.AeadAlgorithmTag : Enum {
    public byte value__;
    public static AeadAlgorithmTag Eax;
    public static AeadAlgorithmTag Ocb;
    public static AeadAlgorithmTag Gcm;
}
public class Org.BouncyCastle.Bcpg.AeadEncDataPacket : InputStreamPacket {
    private byte m_version;
    private SymmetricKeyAlgorithmTag m_algorithm;
    private AeadAlgorithmTag m_aeadAlgorithm;
    private byte m_chunkSize;
    private Byte[] m_iv;
    public byte Version { get; }
    public SymmetricKeyAlgorithmTag Algorithm { get; }
    public AeadAlgorithmTag AeadAlgorithm { get; }
    public int ChunkSize { get; }
    public AeadEncDataPacket(BcpgInputStream bcpgIn);
    public AeadEncDataPacket(SymmetricKeyAlgorithmTag algorithm, AeadAlgorithmTag aeadAlgorithm, int chunkSize, Byte[] iv);
    public byte get_Version();
    public SymmetricKeyAlgorithmTag get_Algorithm();
    public AeadAlgorithmTag get_AeadAlgorithm();
    public int get_ChunkSize();
    public Byte[] GetIV();
    public static int GetIVLength(AeadAlgorithmTag aeadAlgorithm);
}
public class Org.BouncyCastle.Bcpg.ArmoredInputStream : BaseInputStream {
    private static Byte[] decodingTable;
    private bool detectMissingChecksum;
    private Stream input;
    private bool start;
    private Byte[] outBuf;
    private int bufPtr;
    private Crc24 crc;
    private bool crcFound;
    private bool hasHeaders;
    private string header;
    private bool newLineFound;
    private bool clearText;
    private bool restart;
    private IList`1<string> headerList;
    private int lastC;
    private bool isEndOfStream;
    private static ArmoredInputStream();
    public ArmoredInputStream(Stream input);
    public ArmoredInputStream(Stream input, bool hasHeaders);
    private static int Decode(int in0, int in1, int in2, int in3, Byte[] result);
    private bool ParseHeaders();
    public bool IsClearText();
    public bool IsEndOfStream();
    public string GetArmorHeaderLine();
    public String[] GetArmorHeaders();
    private int ReadIgnoreSpace();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    protected virtual void Dispose(bool disposing);
    public virtual void SetDetectMissingCrc(bool detectMissing);
}
public class Org.BouncyCastle.Bcpg.ArmoredOutputStream : BaseOutputStream {
    public static string HeaderVersion;
    private static Byte[] encodingTable;
    private Stream outStream;
    private Byte[] buf;
    private int bufPtr;
    private Crc24 crc;
    private int chunkCount;
    private int lastb;
    private bool start;
    private bool clearText;
    private bool newLine;
    private string type;
    private static string NewLine;
    private static string headerStart;
    private static string headerTail;
    private static string footerStart;
    private static string footerTail;
    private static string Version;
    private IDictionary`2<string, IList`1<string>> m_headers;
    public ArmoredOutputStream(Stream outStream);
    public ArmoredOutputStream(Stream outStream, IDictionary`2<string, string> headers);
    private static ArmoredOutputStream();
    private static void Encode(Stream outStream, Byte[] data, int len);
    private static void Encode3(Stream outStream, Byte[] data);
    private static string CreateVersion();
    public void SetHeader(string name, string val);
    public void AddHeader(string name, string val);
    public void ResetHeaders();
    public void BeginClearText(HashAlgorithmTag hashAlgorithm);
    public void EndClearText();
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    private void DoClose();
    private void WriteHeaderEntry(string name, string v);
    private void DoWrite(string s);
}
public class Org.BouncyCastle.Bcpg.Attr.ImageAttrib : UserAttributeSubpacket {
    private static Byte[] Zeroes;
    private int hdrLength;
    private int _version;
    private int _encoding;
    private Byte[] imageData;
    public int Version { get; }
    public int Encoding { get; }
    public ImageAttrib(Byte[] data);
    public ImageAttrib(bool forceLongLength, Byte[] data);
    public ImageAttrib(Format imageType, Byte[] imageData);
    private static ImageAttrib();
    private static Byte[] ToByteArray(Format imageType, Byte[] imageData);
    public virtual int get_Version();
    public virtual int get_Encoding();
    public virtual Byte[] GetImageData();
}
public class Org.BouncyCastle.Bcpg.BcpgInputStream : BaseInputStream {
    private Stream m_in;
    private bool next;
    private int nextB;
    private BcpgInputStream(Stream inputStream);
    internal static BcpgInputStream Wrap(Stream inStr);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public Byte[] ReadAll();
    public void ReadFully(Byte[] buffer, int offset, int count);
    public void ReadFully(Byte[] buffer);
    public PacketTag NextPacketTag();
    public Packet ReadPacket();
    public PacketTag SkipMarkerPackets();
    protected virtual void Dispose(bool disposing);
}
public abstract class Org.BouncyCastle.Bcpg.BcpgObject : object {
    public virtual Byte[] GetEncoded();
    public abstract virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.BcpgOutputStream : BaseOutputStream {
    private Stream outStr;
    private bool useOldFormat;
    private Byte[] partialBuffer;
    private int partialBufferLength;
    private int partialPower;
    private int partialOffset;
    private static int BufferSizePower;
    public BcpgOutputStream(Stream outStr);
    public BcpgOutputStream(Stream outStr, bool newFormatOnly);
    public BcpgOutputStream(Stream outStr, PacketTag tag);
    public BcpgOutputStream(Stream outStr, PacketTag tag, long length, bool oldFormat);
    public BcpgOutputStream(Stream outStr, PacketTag tag, long length);
    public BcpgOutputStream(Stream outStr, PacketTag tag, Byte[] buffer);
    internal static BcpgOutputStream Wrap(Stream outStr);
    private void WriteNewPacketLength(long bodyLen);
    private void WriteHeader(PacketTag packetTag, bool oldPackets, bool partial, long bodyLen);
    private void PartialFlush();
    private void PartialFlushLast();
    private void PartialWrite(Byte[] buffer, int offset, int count);
    private void PartialWriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    internal virtual void WriteShort(short n);
    internal virtual void WriteInt(int n);
    internal virtual void WriteLong(long n);
    public void WritePacket(ContainedPacket p);
    internal void WritePacket(PacketTag tag, Byte[] body);
    internal void WritePacket(PacketTag tag, Byte[] body, bool oldFormat);
    public void WriteObject(BcpgObject bcpgObject);
    public void WriteObjects(BcpgObject[] v);
    public virtual void Flush();
    public void Finish();
    protected virtual void Dispose(bool disposing);
}
public class Org.BouncyCastle.Bcpg.CompressedDataPacket : InputStreamPacket {
    private CompressionAlgorithmTag algorithm;
    public CompressionAlgorithmTag Algorithm { get; }
    internal CompressedDataPacket(BcpgInputStream bcpgIn);
    public CompressionAlgorithmTag get_Algorithm();
}
public enum Org.BouncyCastle.Bcpg.CompressionAlgorithmTag : Enum {
    public int value__;
    public static CompressionAlgorithmTag Uncompressed;
    public static CompressionAlgorithmTag Zip;
    public static CompressionAlgorithmTag ZLib;
    public static CompressionAlgorithmTag BZip2;
}
public abstract class Org.BouncyCastle.Bcpg.ContainedPacket : Packet {
    public Byte[] GetEncoded();
    public abstract virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.Crc24 : object {
    private static int Crc24Init;
    private static int Crc24Poly;
    private static Int32[] Table0;
    private static Int32[] Table8;
    private static Int32[] Table16;
    private int m_crc;
    public int Value { get; }
    private static Crc24();
    public void Update(byte b);
    public void Update3(Byte[] buf, int off);
    public int get_Value();
    public void Reset();
}
public class Org.BouncyCastle.Bcpg.DsaPublicBcpgKey : BcpgObject {
    private MPInteger p;
    private MPInteger q;
    private MPInteger g;
    private MPInteger y;
    public string Format { get; }
    public BigInteger G { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger Y { get; }
    public DsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public DsaPublicBcpgKey(BigInteger p, BigInteger q, BigInteger g, BigInteger y);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public BigInteger get_G();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_Y();
}
public class Org.BouncyCastle.Bcpg.DsaSecretBcpgKey : BcpgObject {
    internal MPInteger x;
    public string Format { get; }
    public BigInteger X { get; }
    public DsaSecretBcpgKey(BcpgInputStream bcpgIn);
    public DsaSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public BigInteger get_X();
}
public class Org.BouncyCastle.Bcpg.ECDHPublicBcpgKey : ECPublicBcpgKey {
    private byte reserved;
    private HashAlgorithmTag hashFunctionId;
    private SymmetricKeyAlgorithmTag symAlgorithmId;
    public byte Reserved { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public SymmetricKeyAlgorithmTag SymmetricKeyAlgorithm { get; }
    public ECDHPublicBcpgKey(BcpgInputStream bcpgIn);
    public ECDHPublicBcpgKey(DerObjectIdentifier oid, ECPoint point, HashAlgorithmTag hashAlgorithm, SymmetricKeyAlgorithmTag symmetricKeyAlgorithm);
    public ECDHPublicBcpgKey(DerObjectIdentifier oid, BigInteger point, HashAlgorithmTag hashAlgorithm, SymmetricKeyAlgorithmTag symmetricKeyAlgorithm);
    public virtual byte get_Reserved();
    public virtual HashAlgorithmTag get_HashAlgorithm();
    public virtual SymmetricKeyAlgorithmTag get_SymmetricKeyAlgorithm();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    private void VerifyHashAlgorithm();
    private void VerifySymmetricKeyAlgorithm();
}
public class Org.BouncyCastle.Bcpg.ECDsaPublicBcpgKey : ECPublicBcpgKey {
    protected internal ECDsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public ECDsaPublicBcpgKey(DerObjectIdentifier oid, ECPoint point);
    public ECDsaPublicBcpgKey(DerObjectIdentifier oid, BigInteger encodedPoint);
}
public abstract class Org.BouncyCastle.Bcpg.ECPublicBcpgKey : BcpgObject {
    internal DerObjectIdentifier oid;
    internal BigInteger point;
    public string Format { get; }
    public BigInteger EncodedPoint { get; }
    public DerObjectIdentifier CurveOid { get; }
    protected ECPublicBcpgKey(BcpgInputStream bcpgIn);
    protected ECPublicBcpgKey(DerObjectIdentifier oid, ECPoint point);
    protected ECPublicBcpgKey(DerObjectIdentifier oid, BigInteger encodedPoint);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public virtual BigInteger get_EncodedPoint();
    public virtual DerObjectIdentifier get_CurveOid();
    protected static Byte[] ReadBytesOfEncodedLength(BcpgInputStream bcpgIn);
}
public class Org.BouncyCastle.Bcpg.ECSecretBcpgKey : BcpgObject {
    internal MPInteger m_x;
    public string Format { get; }
    public BigInteger X { get; }
    public ECSecretBcpgKey(BcpgInputStream bcpgIn);
    public ECSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public virtual BigInteger get_X();
}
public class Org.BouncyCastle.Bcpg.EdDsaPublicBcpgKey : ECPublicBcpgKey {
    internal EdDsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public EdDsaPublicBcpgKey(DerObjectIdentifier oid, ECPoint point);
    public EdDsaPublicBcpgKey(DerObjectIdentifier oid, BigInteger encodedPoint);
}
public class Org.BouncyCastle.Bcpg.EdSecretBcpgKey : BcpgObject {
    internal MPInteger m_x;
    public string Format { get; }
    public BigInteger X { get; }
    public EdSecretBcpgKey(BcpgInputStream bcpgIn);
    public EdSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public BigInteger get_X();
}
public class Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey : BcpgObject {
    internal MPInteger p;
    internal MPInteger g;
    internal MPInteger y;
    public string Format { get; }
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger Y { get; }
    public ElGamalPublicBcpgKey(BcpgInputStream bcpgIn);
    public ElGamalPublicBcpgKey(BigInteger p, BigInteger g, BigInteger y);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_Y();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey : BcpgObject {
    internal MPInteger x;
    public string Format { get; }
    public BigInteger X { get; }
    public ElGamalSecretBcpgKey(BcpgInputStream bcpgIn);
    public ElGamalSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public BigInteger get_X();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ExperimentalPacket : ContainedPacket {
    private PacketTag m_tag;
    private Byte[] m_contents;
    public PacketTag Tag { get; }
    internal ExperimentalPacket(PacketTag tag, BcpgInputStream bcpgIn);
    public PacketTag get_Tag();
    public Byte[] GetContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public enum Org.BouncyCastle.Bcpg.HashAlgorithmTag : Enum {
    public int value__;
    public static HashAlgorithmTag MD5;
    public static HashAlgorithmTag Sha1;
    public static HashAlgorithmTag RipeMD160;
    public static HashAlgorithmTag DoubleSha;
    public static HashAlgorithmTag MD2;
    public static HashAlgorithmTag Tiger192;
    public static HashAlgorithmTag Haval5pass160;
    public static HashAlgorithmTag Sha256;
    public static HashAlgorithmTag Sha384;
    public static HashAlgorithmTag Sha512;
    public static HashAlgorithmTag Sha224;
    public static HashAlgorithmTag Sha3_256;
    public static HashAlgorithmTag Sha3_512;
    public static HashAlgorithmTag MD4;
    public static HashAlgorithmTag Sha3_224;
    public static HashAlgorithmTag Sha3_256_Old;
    public static HashAlgorithmTag Sha3_384;
    public static HashAlgorithmTag Sha3_512_Old;
    public static HashAlgorithmTag SM3;
}
public interface Org.BouncyCastle.Bcpg.IBcpgKey {
    public string Format { get; }
    public abstract virtual string get_Format();
}
public class Org.BouncyCastle.Bcpg.InputStreamPacket : Packet {
    private BcpgInputStream bcpgIn;
    public InputStreamPacket(BcpgInputStream bcpgIn);
    public BcpgInputStream GetInputStream();
}
public interface Org.BouncyCastle.Bcpg.IUserDataPacket {
}
public class Org.BouncyCastle.Bcpg.LiteralDataPacket : InputStreamPacket {
    private int format;
    private Byte[] fileName;
    private long modDate;
    public int Format { get; }
    public long ModificationTime { get; }
    public string FileName { get; }
    internal LiteralDataPacket(BcpgInputStream bcpgIn);
    public int get_Format();
    public long get_ModificationTime();
    public string get_FileName();
    public Byte[] GetRawFileName();
}
public class Org.BouncyCastle.Bcpg.MarkerPacket : ContainedPacket {
    private Byte[] marker;
    public MarkerPacket(BcpgInputStream bcpgIn);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ModDetectionCodePacket : ContainedPacket {
    private Byte[] digest;
    internal ModDetectionCodePacket(BcpgInputStream bcpgIn);
    public ModDetectionCodePacket(Byte[] digest);
    public Byte[] GetDigest();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.MPInteger : BcpgObject {
    private BigInteger m_val;
    public BigInteger Value { get; }
    public MPInteger(BcpgInputStream bcpgIn);
    public MPInteger(BigInteger val);
    public BigInteger get_Value();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    internal static BigInteger ToMpiBigInteger(ECPoint point);
}
public class Org.BouncyCastle.Bcpg.OnePassSignaturePacket : ContainedPacket {
    private int version;
    private int sigType;
    private HashAlgorithmTag hashAlgorithm;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private long keyId;
    private int nested;
    public int SignatureType { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long KeyId { get; }
    internal OnePassSignaturePacket(BcpgInputStream bcpgIn);
    public OnePassSignaturePacket(int sigType, HashAlgorithmTag hashAlgorithm, PublicKeyAlgorithmTag keyAlgorithm, long keyId, bool isNested);
    public int get_SignatureType();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public long get_KeyId();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
internal class Org.BouncyCastle.Bcpg.OpenPgp.EdDsaSigner : object {
    private ISigner m_signer;
    private IDigest m_digest;
    public string AlgorithmName { get; }
    internal EdDsaSigner(ISigner signer, IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters cipherParameters);
    public sealed virtual void Update(byte b);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public sealed virtual int GetMaxSignatureSize();
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
    private void FinalizeDigest();
}
public interface Org.BouncyCastle.Bcpg.OpenPgp.IStreamGenerator {
    [ObsoleteAttribute("Dispose any opened Stream directly")]
public abstract virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData : PgpObject {
    private CompressedDataPacket data;
    public CompressionAlgorithmTag Algorithm { get; }
    public PgpCompressedData(BcpgInputStream bcpgInput);
    public CompressionAlgorithmTag get_Algorithm();
    public Stream GetInputStream();
    public Stream GetDataStream();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator : object {
    private CompressionAlgorithmTag algorithm;
    private int compression;
    private Stream dOut;
    private BcpgOutputStream pkOut;
    public PgpCompressedDataGenerator(CompressionAlgorithmTag algorithm);
    public PgpCompressedDataGenerator(CompressionAlgorithmTag algorithm, int compression);
    public Stream Open(Stream outStr);
    public Stream Open(Stream outStr, Byte[] buffer);
    private void DoOpen();
    [ObsoleteAttribute("Dispose any opened Stream directly")]
public sealed virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpDataValidationException : PgpException {
    public PgpDataValidationException(string message);
    public PgpDataValidationException(string message, Exception innerException);
    protected PgpDataValidationException(SerializationInfo info, StreamingContext context);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData : object {
    internal InputStreamPacket encData;
    internal Stream encStream;
    internal TruncatedStream truncStream;
    internal PgpEncryptedData(InputStreamPacket encData);
    public virtual Stream GetInputStream();
    public bool IsIntegrityProtected();
    public bool Verify();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator : object {
    private BcpgOutputStream pOut;
    private CipherStream cOut;
    private IBufferedCipher c;
    private bool withIntegrityPacket;
    private bool oldFormat;
    private DigestStream digestOut;
    private List`1<EncMethod> methods;
    private SymmetricKeyAlgorithmTag defAlgorithm;
    private SecureRandom rand;
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, bool withIntegrityPacket);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, SecureRandom random);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, bool withIntegrityPacket, SecureRandom random);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, SecureRandom random, bool oldFormat);
    public void AddMethod(Char[] passPhrase, HashAlgorithmTag s2kDigest);
    public void AddMethodUtf8(Char[] passPhrase, HashAlgorithmTag s2kDigest);
    public void AddMethodRaw(Byte[] rawPassPhrase, HashAlgorithmTag s2kDigest);
    internal void DoAddMethod(Byte[] rawPassPhrase, bool clearPassPhrase, HashAlgorithmTag s2kDigest);
    public void AddMethod(PgpPublicKey key);
    public void AddMethod(PgpPublicKey key, bool sessionKeyObfuscation);
    private void AddCheckSum(Byte[] sessionInfo);
    private Byte[] CreateSessionInfo(SymmetricKeyAlgorithmTag algorithm, KeyParameter key);
    private Stream Open(Stream outStr, long length, Byte[] buffer);
    public Stream Open(Stream outStr, long length);
    public Stream Open(Stream outStr, Byte[] buffer);
    [ObsoleteAttribute("Dispose any opened Stream directly")]
public sealed virtual void Close();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataList : PgpObject {
    private List`1<PgpEncryptedData> m_list;
    private InputStreamPacket m_data;
    public PgpEncryptedData Item { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpEncryptedDataList(BcpgInputStream bcpgInput);
    public PgpEncryptedData get_Item(int index);
    public int get_Count();
    public bool get_IsEmpty();
    public IEnumerable`1<PgpEncryptedData> GetEncryptedDataObjects();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpException : Exception {
    public PgpException(string message);
    public PgpException(string message, Exception innerException);
    protected PgpException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpExperimental : PgpObject {
    private ExperimentalPacket p;
    public PgpExperimental(BcpgInputStream bcpgIn);
}
internal class Org.BouncyCastle.Bcpg.OpenPgp.PgpKdfParameters : object {
    private HashAlgorithmTag m_hashAlgorithm;
    private SymmetricKeyAlgorithmTag m_symmetricWrapAlgorithm;
    public HashAlgorithmTag HashAlgorithm { get; }
    public SymmetricKeyAlgorithmTag SymmetricWrapAlgorithm { get; }
    public PgpKdfParameters(HashAlgorithmTag hashAlgorithm, SymmetricKeyAlgorithmTag symmetricWrapAlgorithm);
    public HashAlgorithmTag get_HashAlgorithm();
    public SymmetricKeyAlgorithmTag get_SymmetricWrapAlgorithm();
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyFlags : object {
    public static int CanCertify;
    public static int CanSign;
    public static int CanEncryptCommunications;
    public static int CanEncryptStorage;
    public static int MaybeSplit;
    public static int MaybeShared;
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair : object {
    private PgpPublicKey pub;
    private PgpPrivateKey priv;
    public long KeyId { get; }
    public PgpPublicKey PublicKey { get; }
    public PgpPrivateKey PrivateKey { get; }
    public PgpKeyPair(PublicKeyAlgorithmTag algorithm, AsymmetricCipherKeyPair keyPair, DateTime time);
    public PgpKeyPair(PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time);
    public PgpKeyPair(PgpPublicKey pub, PgpPrivateKey priv);
    public long get_KeyId();
    public PgpPublicKey get_PublicKey();
    public PgpPrivateKey get_PrivateKey();
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRing : PgpObject {
    internal static TrustPacket ReadOptionalTrustPacket(BcpgInputStream pIn);
    internal static IList`1<PgpSignature> ReadSignaturesAndTrust(BcpgInputStream pIn);
    internal static void ReadUserIDs(BcpgInputStream pIn, IList`1& ids, IList`1& idTrusts, IList`1& idSigs);
    private static bool IsUserTag(PacketTag tag);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator : object {
    private IList`1<PgpSecretKey> keys;
    private string id;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private int certificationLevel;
    private Byte[] rawPassPhrase;
    private bool useSha1;
    private PgpKeyPair masterKey;
    private PgpSignatureSubpacketVector hashedPacketVector;
    private PgpSignatureSubpacketVector unhashedPacketVector;
    private SecureRandom rand;
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, bool utf8PassPhrase, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, bool utf8PassPhrase, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Byte[] rawPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public void AddSubKey(PgpKeyPair keyPair);
    public void AddSubKey(PgpKeyPair keyPair, HashAlgorithmTag hashAlgorithm);
    public void AddSubKey(PgpKeyPair keyPair, HashAlgorithmTag hashAlgorithm, HashAlgorithmTag primaryKeyBindingHashAlgorithm);
    public void AddSubKey(PgpKeyPair keyPair, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets);
    public void AddSubKey(PgpKeyPair keyPair, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, HashAlgorithmTag hashAlgorithm);
    public void AddSubKey(PgpKeyPair keyPair, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, HashAlgorithmTag hashAlgorithm, HashAlgorithmTag primaryKeyBindingHashAlgorithm);
    public PgpSecretKeyRing GenerateSecretKeyRing();
    public PgpPublicKeyRing GeneratePublicKeyRing();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyValidationException : PgpException {
    public PgpKeyValidationException(string message);
    public PgpKeyValidationException(string message, Exception innerException);
    protected PgpKeyValidationException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData : PgpObject {
    public static char Binary;
    public static char Text;
    public static char Utf8;
    public static string Console;
    private LiteralDataPacket data;
    public int Format { get; }
    public string FileName { get; }
    public DateTime ModificationTime { get; }
    public PgpLiteralData(BcpgInputStream bcpgInput);
    public int get_Format();
    public string get_FileName();
    public Byte[] GetRawFileName();
    public DateTime get_ModificationTime();
    public Stream GetInputStream();
    public Stream GetDataStream();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator : object {
    public static char Binary;
    public static char Text;
    public static char Utf8;
    public static string Console;
    private BcpgOutputStream pkOut;
    private bool oldFormat;
    public PgpLiteralDataGenerator(bool oldFormat);
    private void WriteHeader(BcpgOutputStream outStr, char format, Byte[] encName, long modificationTime);
    public Stream Open(Stream outStr, char format, string name, long length, DateTime modificationTime);
    public Stream Open(Stream outStr, char format, string name, DateTime modificationTime, Byte[] buffer);
    public Stream Open(Stream outStr, char format, FileInfo file);
    [ObsoleteAttribute("Dispose any opened Stream directly")]
public sealed virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpMarker : PgpObject {
    private MarkerPacket data;
    public PgpMarker(BcpgInputStream bcpgInput);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpObject : object {
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory : object {
    private BcpgInputStream bcpgIn;
    public PgpObjectFactory(Stream inputStream);
    public PgpObjectFactory(Byte[] bytes);
    public PgpObject NextPgpObject();
    public IList`1<PgpObject> AllPgpObjects();
    public IList`1<T> FilterPgpObjects();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature : object {
    private OnePassSignaturePacket sigPack;
    private int signatureType;
    private ISigner sig;
    private byte lastb;
    public long KeyId { get; }
    public int SignatureType { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    internal PgpOnePassSignature(BcpgInputStream bcpgInput);
    internal PgpOnePassSignature(OnePassSignaturePacket sigPack);
    private static OnePassSignaturePacket Cast(Packet packet);
    public void InitVerify(PgpPublicKey pubKey);
    public void Update(byte b);
    private void DoCanonicalUpdateByte(byte b);
    private void DoUpdateCRLF();
    public void Update(Byte[] bytes);
    public void Update(Byte[] bytes, int off, int length);
    public bool Verify(PgpSignature pgpSig);
    public long get_KeyId();
    public int get_SignatureType();
    public HashAlgorithmTag get_HashAlgorithm();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignatureList : PgpObject {
    private PgpOnePassSignature[] sigs;
    public PgpOnePassSignature Item { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpOnePassSignatureList(PgpOnePassSignature[] sigs);
    public PgpOnePassSignatureList(PgpOnePassSignature sig);
    public PgpOnePassSignature get_Item(int index);
    public int get_Count();
    public bool get_IsEmpty();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPad : object {
    public static Byte[] PadSessionData(Byte[] sessionInfo);
    public static Byte[] PadSessionData(Byte[] sessionInfo, bool obfuscate);
    public static Byte[] UnpadSessionData(Byte[] encoded);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData : PgpEncryptedData {
    private SymmetricKeyEncSessionPacket keyData;
    internal PgpPbeEncryptedData(SymmetricKeyEncSessionPacket keyData, InputStreamPacket encData);
    public virtual Stream GetInputStream();
    public Stream GetDataStream(Char[] passPhrase);
    public Stream GetDataStreamUtf8(Char[] passPhrase);
    public Stream GetDataStreamRaw(Byte[] rawPassPhrase);
    internal Stream DoGetDataStream(Byte[] rawPassPhrase, bool clearPassPhrase);
    private IBufferedCipher CreateStreamCipher(SymmetricKeyAlgorithmTag keyAlgorithm);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey : object {
    private long keyID;
    private PublicKeyPacket publicKeyPacket;
    private AsymmetricKeyParameter privateKey;
    public long KeyId { get; }
    public PublicKeyPacket PublicKeyPacket { get; }
    public AsymmetricKeyParameter Key { get; }
    public PgpPrivateKey(long keyID, PublicKeyPacket publicKeyPacket, AsymmetricKeyParameter privateKey);
    public long get_KeyId();
    public PublicKeyPacket get_PublicKeyPacket();
    public AsymmetricKeyParameter get_Key();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey : PgpObject {
    private static PgpKdfParameters DefaultKdfParameters;
    private static Int32[] MasterKeyCertificationTypes;
    internal PublicKeyPacket publicPk;
    internal TrustPacket trustPk;
    internal IList`1<PgpSignature> keySigs;
    internal IList`1<IUserDataPacket> ids;
    internal IList`1<TrustPacket> idTrusts;
    internal IList`1<IList`1<PgpSignature>> idSigs;
    internal IList`1<PgpSignature> subSigs;
    private long keyId;
    private Byte[] fingerprint;
    private int keyStrength;
    public int Version { get; }
    public DateTime CreationTime { get; }
    public long KeyId { get; }
    public bool IsEncryptionKey { get; }
    public bool IsMasterKey { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public int BitStrength { get; }
    public PublicKeyPacket PublicKeyPacket { get; }
    public PgpPublicKey(PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, DateTime time);
    public PgpPublicKey(PublicKeyPacket publicPk);
    internal PgpPublicKey(PublicKeyPacket publicPk, TrustPacket trustPk, IList`1<PgpSignature> sigs);
    internal PgpPublicKey(PgpPublicKey key, TrustPacket trust, IList`1<PgpSignature> subSigs);
    internal PgpPublicKey(PgpPublicKey pubKey);
    internal PgpPublicKey(PublicKeyPacket publicPk, TrustPacket trustPk, IList`1<PgpSignature> keySigs, IList`1<IUserDataPacket> ids, IList`1<TrustPacket> idTrusts, IList`1<IList`1<PgpSignature>> idSigs);
    internal PgpPublicKey(PublicKeyPacket publicPk, IList`1<IUserDataPacket> ids, IList`1<IList`1<PgpSignature>> idSigs);
    internal PgpPublicKey(PgpPublicKey original, TrustPacket trustPk, List`1<PgpSignature> keySigs, List`1<IUserDataPacket> ids, List`1<TrustPacket> idTrusts, IList`1<IList`1<PgpSignature>> idSigs);
    private static PgpPublicKey();
    public static Byte[] CalculateFingerprint(PublicKeyPacket publicPk);
    private static void UpdateDigest(IDigest d, BigInteger b);
    private void Init();
    public int get_Version();
    public DateTime get_CreationTime();
    public Byte[] GetTrustData();
    public long GetValidSeconds();
    private long GetExpirationTimeFromSig(bool selfSigned, int signatureType);
    public long get_KeyId();
    public Byte[] GetFingerprint();
    public bool get_IsEncryptionKey();
    public bool get_IsMasterKey();
    public PublicKeyAlgorithmTag get_Algorithm();
    public int get_BitStrength();
    public AsymmetricKeyParameter GetKey();
    private ECPublicKeyParameters GetECKey(string algorithm, ECPublicBcpgKey ecK);
    public IEnumerable`1<string> GetUserIds();
    public IEnumerable`1<Byte[]> GetRawUserIds();
    public IEnumerable`1<PgpUserAttributeSubpacketVector> GetUserAttributes();
    public IEnumerable`1<PgpSignature> GetSignaturesForId(string id);
    public IEnumerable`1<PgpSignature> GetSignaturesForId(Byte[] rawId);
    private IEnumerable`1<PgpSignature> GetSignaturesForId(UserIdPacket id);
    public IEnumerable`1<PgpSignature> GetSignaturesForKeyID(long keyID);
    public IEnumerable`1<PgpSignature> GetSignaturesForUserAttribute(PgpUserAttributeSubpacketVector userAttributes);
    public IEnumerable`1<PgpSignature> GetSignaturesOfType(int signatureType);
    public IEnumerable`1<PgpSignature> GetSignatures();
    public IEnumerable`1<PgpSignature> GetKeySignatures();
    public PublicKeyPacket get_PublicKeyPacket();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public void Encode(Stream outStr, bool forTransfer);
    public bool IsRevoked();
    public static PgpPublicKey AddCertification(PgpPublicKey key, string id, PgpSignature certification);
    public static PgpPublicKey AddCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes, PgpSignature certification);
    private static PgpPublicKey AddCert(PgpPublicKey key, IUserDataPacket id, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, string id);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, Byte[] rawId);
    private static PgpPublicKey RemoveCert(PgpPublicKey key, IUserDataPacket id);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, Byte[] id, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, string id, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes, PgpSignature certification);
    private static PgpPublicKey RemoveCert(PgpPublicKey key, IUserDataPacket id, PgpSignature certification);
    public static PgpPublicKey AddCertification(PgpPublicKey key, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpSignature certification);
    public static PgpPublicKey Join(PgpPublicKey key, PgpPublicKey copy, bool joinTrustPackets, bool allowSubkeySigsOnNonSubkey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData : PgpEncryptedData {
    private PublicKeyEncSessionPacket keyData;
    public long KeyId { get; }
    internal PgpPublicKeyEncryptedData(PublicKeyEncSessionPacket keyData, InputStreamPacket encData);
    private static IBufferedCipher GetKeyCipher(PublicKeyAlgorithmTag algorithm);
    private bool ConfirmCheckSum(Byte[] sessionInfo);
    public long get_KeyId();
    public SymmetricKeyAlgorithmTag GetSymmetricAlgorithm(PgpPrivateKey privKey);
    public Stream GetDataStream(PgpPrivateKey privKey);
    private Byte[] RecoverSessionData(PgpPrivateKey privKey);
    private static void ProcessEncodedMpi(IBufferedCipher cipher, int size, Byte[] mpiEnc);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing : PgpKeyRing {
    private IList`1<PgpPublicKey> keys;
    public PgpPublicKeyRing(Byte[] encoding);
    internal PgpPublicKeyRing(IList`1<PgpPublicKey> pubKeys);
    public PgpPublicKeyRing(Stream inputStream);
    public virtual PgpPublicKey GetPublicKey();
    public virtual PgpPublicKey GetPublicKey(long keyId);
    public virtual IEnumerable`1<PgpPublicKey> GetPublicKeys();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(Stream outStr);
    public static PgpPublicKeyRing InsertPublicKey(PgpPublicKeyRing pubRing, PgpPublicKey pubKey);
    public static PgpPublicKeyRing RemovePublicKey(PgpPublicKeyRing pubRing, PgpPublicKey pubKey);
    internal static PublicKeyPacket ReadPublicKeyPacket(BcpgInputStream bcpgInput);
    internal static PgpPublicKey ReadSubkey(BcpgInputStream bcpgInput);
    public static PgpPublicKeyRing Join(PgpPublicKeyRing first, PgpPublicKeyRing second);
    public static PgpPublicKeyRing Join(PgpPublicKeyRing first, PgpPublicKeyRing second, bool joinTrustPackets, bool allowSubkeySigsOnNonSubkey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle : object {
    private IDictionary`2<long, PgpPublicKeyRing> m_pubRings;
    private IList`1<long> m_order;
    public int Count { get; }
    private PgpPublicKeyRingBundle(IDictionary`2<long, PgpPublicKeyRing> pubRings, IList`1<long> order);
    public PgpPublicKeyRingBundle(Byte[] encoding);
    public PgpPublicKeyRingBundle(Stream inputStream);
    public PgpPublicKeyRingBundle(IEnumerable`1<PgpObject> e);
    public int get_Count();
    public IEnumerable`1<PgpPublicKeyRing> GetKeyRings();
    public IEnumerable`1<PgpPublicKeyRing> GetKeyRings(string userId);
    public IEnumerable`1<PgpPublicKeyRing> GetKeyRings(string userId, bool matchPartial);
    [IteratorStateMachineAttribute("Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle/<GetKeyRings>d__11")]
public IEnumerable`1<PgpPublicKeyRing> GetKeyRings(string userID, bool matchPartial, bool ignoreCase);
    public PgpPublicKey GetPublicKey(long keyId);
    public PgpPublicKeyRing GetPublicKeyRing(long keyId);
    public bool Contains(long keyID);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpPublicKeyRingBundle AddPublicKeyRing(PgpPublicKeyRingBundle bundle, PgpPublicKeyRing publicKeyRing);
    public static PgpPublicKeyRingBundle RemovePublicKeyRing(PgpPublicKeyRingBundle bundle, PgpPublicKeyRing publicKeyRing);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey : PgpObject {
    private SecretKeyPacket secret;
    private PgpPublicKey pub;
    public bool IsSigningKey { get; }
    public bool IsMasterKey { get; }
    public bool IsPrivateKeyEmpty { get; }
    public SymmetricKeyAlgorithmTag KeyEncryptionAlgorithm { get; }
    public long KeyId { get; }
    public int S2kUsage { get; }
    public S2k S2k { get; }
    public PgpPublicKey PublicKey { get; }
    public IEnumerable`1<string> UserIds { get; }
    public IEnumerable`1<PgpUserAttributeSubpacketVector> UserAttributes { get; }
    internal PgpSecretKey(SecretKeyPacket secret, PgpPublicKey pub);
    internal PgpSecretKey(PgpPrivateKey privKey, PgpPublicKey pubKey, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, bool useSha1, SecureRandom rand, bool isMasterKey);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, bool utf8PassPhrase, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    internal PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, bool utf8PassPhrase, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Byte[] rawPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    internal PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    private static PgpPublicKey CertifiedPublicKey(int certificationLevel, PgpKeyPair keyPair, string id, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets);
    private static PgpPublicKey CertifiedPublicKey(int certificationLevel, PgpKeyPair keyPair, string id, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, HashAlgorithmTag hashAlgorithm);
    public bool get_IsSigningKey();
    public bool get_IsMasterKey();
    public bool get_IsPrivateKeyEmpty();
    public SymmetricKeyAlgorithmTag get_KeyEncryptionAlgorithm();
    public long get_KeyId();
    public Byte[] GetFingerprint();
    public int get_S2kUsage();
    public S2k get_S2k();
    public PgpPublicKey get_PublicKey();
    public IEnumerable`1<string> get_UserIds();
    public IEnumerable`1<PgpUserAttributeSubpacketVector> get_UserAttributes();
    private Byte[] ExtractKeyData(Byte[] rawPassPhrase, bool clearPassPhrase);
    private static Byte[] RecoverKeyData(SymmetricKeyAlgorithmTag encAlgorithm, string modeAndPadding, KeyParameter key, Byte[] iv, Byte[] keyData, int keyOff, int keyLen);
    public PgpPrivateKey ExtractPrivateKey(Char[] passPhrase);
    public PgpPrivateKey ExtractPrivateKeyUtf8(Char[] passPhrase);
    public PgpPrivateKey ExtractPrivateKeyRaw(Byte[] rawPassPhrase);
    internal PgpPrivateKey DoExtractPrivateKey(Byte[] rawPassPhrase, bool clearPassPhrase);
    private static Byte[] Checksum(bool useSha1, Byte[] bytes, int length);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKey CopyWithNewPassword(PgpSecretKey key, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKey CopyWithNewPasswordUtf8(PgpSecretKey key, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKey CopyWithNewPasswordRaw(PgpSecretKey key, Byte[] rawOldPassPhrase, Byte[] rawNewPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    internal static PgpSecretKey DoCopyWithNewPassword(PgpSecretKey key, Byte[] rawOldPassPhrase, Byte[] rawNewPassPhrase, bool clearPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKey ReplacePublicKey(PgpSecretKey secretKey, PgpPublicKey publicKey);
    private static Byte[] EncryptKeyDataV3(Byte[] rawKeyData, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, SecureRandom random, S2k& s2k, Byte[]& iv);
    private static Byte[] EncryptKeyDataV4(Byte[] rawKeyData, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, SecureRandom random, S2k& s2k, Byte[]& iv);
    private static Byte[] EncryptData(SymmetricKeyAlgorithmTag encAlgorithm, KeyParameter key, Byte[] data, int dataOff, int dataLen, SecureRandom random, Byte[]& iv);
    public static PgpSecretKey ParseSecretKeyFromSExpr(Stream inputStream, Char[] passPhrase, PgpPublicKey pubKey);
    public static PgpSecretKey ParseSecretKeyFromSExprUtf8(Stream inputStream, Char[] passPhrase, PgpPublicKey pubKey);
    public static PgpSecretKey ParseSecretKeyFromSExprRaw(Stream inputStream, Byte[] rawPassPhrase, PgpPublicKey pubKey);
    internal static PgpSecretKey DoParseSecretKeyFromSExpr(Stream inputStream, Byte[] rawPassPhrase, bool clearPassPhrase, PgpPublicKey pubKey);
    public static PgpSecretKey ParseSecretKeyFromSExpr(Stream inputStream, Char[] passPhrase);
    public static PgpSecretKey ParseSecretKeyFromSExprUtf8(Stream inputStream, Char[] passPhrase);
    public static PgpSecretKey ParseSecretKeyFromSExprRaw(Stream inputStream, Byte[] rawPassPhrase);
    internal static PgpSecretKey DoParseSecretKeyFromSExpr(Stream inputStream, Byte[] rawPassPhrase, bool clearPassPhrase);
    private static Byte[] GetDValue(Stream inputStream, Byte[] rawPassPhrase, bool clearPassPhrase, string curveName);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing : PgpKeyRing {
    private IList`1<PgpSecretKey> keys;
    private IList`1<PgpPublicKey> extraPubKeys;
    internal PgpSecretKeyRing(IList`1<PgpSecretKey> keys);
    private PgpSecretKeyRing(IList`1<PgpSecretKey> keys, IList`1<PgpPublicKey> extraPubKeys);
    public PgpSecretKeyRing(Byte[] encoding);
    public PgpSecretKeyRing(Stream inputStream);
    public PgpPublicKey GetPublicKey();
    public IEnumerable`1<PgpPublicKey> GetKeysWithSignaturesBy(long keyID);
    public IEnumerable`1<PgpPublicKey> GetPublicKeys();
    public PgpSecretKey GetSecretKey();
    public IEnumerable`1<PgpSecretKey> GetSecretKeys();
    public PgpSecretKey GetSecretKey(long keyId);
    public IEnumerable`1<PgpPublicKey> GetExtraPublicKeys();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKeyRing ReplacePublicKeys(PgpSecretKeyRing secretRing, PgpPublicKeyRing publicRing);
    public static PgpSecretKeyRing CopyWithNewPassword(PgpSecretKeyRing ring, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKeyRing InsertSecretKey(PgpSecretKeyRing secRing, PgpSecretKey secKey);
    public static PgpSecretKeyRing RemoveSecretKey(PgpSecretKeyRing secRing, PgpSecretKey secKey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle : object {
    private IDictionary`2<long, PgpSecretKeyRing> m_secretRings;
    private IList`1<long> m_order;
    public int Count { get; }
    private PgpSecretKeyRingBundle(IDictionary`2<long, PgpSecretKeyRing> secretRings, IList`1<long> order);
    public PgpSecretKeyRingBundle(Byte[] encoding);
    public PgpSecretKeyRingBundle(Stream inputStream);
    public PgpSecretKeyRingBundle(IEnumerable`1<PgpObject> e);
    public int get_Count();
    public IEnumerable`1<PgpSecretKeyRing> GetKeyRings();
    public IEnumerable`1<PgpSecretKeyRing> GetKeyRings(string userId);
    public IEnumerable`1<PgpSecretKeyRing> GetKeyRings(string userId, bool matchPartial);
    [IteratorStateMachineAttribute("Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle/<GetKeyRings>d__11")]
public IEnumerable`1<PgpSecretKeyRing> GetKeyRings(string userID, bool matchPartial, bool ignoreCase);
    public PgpSecretKey GetSecretKey(long keyId);
    public PgpSecretKeyRing GetSecretKeyRing(long keyId);
    public bool Contains(long keyID);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKeyRingBundle AddSecretKeyRing(PgpSecretKeyRingBundle bundle, PgpSecretKeyRing secretKeyRing);
    public static PgpSecretKeyRingBundle RemoveSecretKeyRing(PgpSecretKeyRingBundle bundle, PgpSecretKeyRing secretKeyRing);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature : object {
    public static int BinaryDocument;
    public static int CanonicalTextDocument;
    public static int StandAlone;
    public static int DefaultCertification;
    public static int NoCertification;
    public static int CasualCertification;
    public static int PositiveCertification;
    public static int SubkeyBinding;
    public static int PrimaryKeyBinding;
    public static int DirectKey;
    public static int KeyRevocation;
    public static int SubkeyRevocation;
    public static int CertificationRevocation;
    public static int Timestamp;
    public static int ThirdPartyConfirmation;
    private SignaturePacket sigPck;
    private int signatureType;
    private TrustPacket trustPck;
    private ISigner sig;
    private byte lastb;
    public int Version { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public int SignatureType { get; }
    public long KeyId { get; }
    public DateTime CreationTime { get; }
    public bool HasSubpackets { get; }
    internal PgpSignature(BcpgInputStream bcpgInput);
    internal PgpSignature(SignaturePacket sigPacket);
    internal PgpSignature(SignaturePacket sigPacket, TrustPacket trustPacket);
    private static SignaturePacket Cast(Packet packet);
    public int get_Version();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public Byte[] GetDigestPrefix();
    public bool IsCertification();
    public void InitVerify(PgpPublicKey pubKey);
    public void Update(byte b);
    private void DoCanonicalUpdateByte(byte b);
    private void DoUpdateCRLF();
    public void Update(Byte[] bytes);
    public void Update(Byte[] bytes, int off, int length);
    public bool Verify();
    private void UpdateWithIdData(int header, Byte[] idBytes);
    private void UpdateWithPublicKey(PgpPublicKey key);
    public bool VerifyCertification(PgpUserAttributeSubpacketVector userAttributes, PgpPublicKey key);
    public bool VerifyCertification(string id, PgpPublicKey key);
    public bool VerifyCertification(PgpPublicKey masterKey, PgpPublicKey pubKey);
    public bool VerifyCertification(PgpPublicKey pubKey);
    public int get_SignatureType();
    public long get_KeyId();
    public DateTime get_CreationTime();
    public Byte[] GetSignatureTrailer();
    public bool get_HasSubpackets();
    public PgpSignatureSubpacketVector GetHashedSubPackets();
    public PgpSignatureSubpacketVector GetUnhashedSubPackets();
    private static PgpSignatureSubpacketVector CreateSubpacketVector(SignatureSubpacket[] pcks);
    public Byte[] GetSignature();
    public Byte[] GetEncoded();
    public void Encode(Stream outStream);
    public void Encode(Stream outStream, bool forTransfer);
    private static Byte[] GetEncodedPublicKey(PgpPublicKey pubKey);
    public static bool IsCertification(int signatureType);
    public static bool IsSignatureEncodingEqual(PgpSignature sig1, PgpSignature sig2);
    public static PgpSignature Join(PgpSignature sig1, PgpSignature sig2);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator : object {
    private static SignatureSubpacket[] EmptySignatureSubpackets;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private PgpPrivateKey privKey;
    private ISigner sig;
    private IDigest dig;
    private int signatureType;
    private byte lastb;
    private SignatureSubpacket[] unhashed;
    private SignatureSubpacket[] hashed;
    public PgpSignatureGenerator(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    private static PgpSignatureGenerator();
    public void InitSign(int sigType, PgpPrivateKey privKey);
    public void InitSign(int sigType, PgpPrivateKey privKey, SecureRandom random);
    public void Update(byte b);
    private void DoCanonicalUpdateByte(byte b);
    private void DoUpdateCRLF();
    private void DoUpdateByte(byte b);
    public void Update(Byte[] b);
    public void Update(Byte[] b, int off, int len);
    public void SetHashedSubpackets(PgpSignatureSubpacketVector hashedPackets);
    public void SetUnhashedSubpackets(PgpSignatureSubpacketVector unhashedPackets);
    public PgpOnePassSignature GenerateOnePassVersion(bool isNested);
    public PgpSignature Generate();
    public PgpSignature GenerateCertification(string id, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpUserAttributeSubpacketVector userAttributes, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpPublicKey masterKey, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpPublicKey pubKey);
    private static Byte[] GetEncodedPublicKey(PgpPublicKey pubKey);
    private static bool IsPacketPresent(SignatureSubpacket[] packets, SignatureSubpacketTag type);
    private static SignatureSubpacket[] InsertSubpacket(SignatureSubpacket[] packets, SignatureSubpacket subpacket);
    private void UpdateWithIdData(int header, Byte[] idBytes);
    private void UpdateWithPublicKey(PgpPublicKey key);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureList : PgpObject {
    private PgpSignature[] sigs;
    public PgpSignature Item { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpSignatureList(PgpSignature[] sigs);
    public PgpSignatureList(PgpSignature sig);
    public PgpSignature get_Item(int index);
    public int get_Count();
    public bool get_IsEmpty();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator : object {
    private List`1<SignatureSubpacket> list;
    public PgpSignatureSubpacketGenerator(PgpSignatureSubpacketVector sigSubV);
    public void SetRevocable(bool isCritical, bool isRevocable);
    public void SetExportable(bool isCritical, bool isExportable);
    public void SetFeature(bool isCritical, byte feature);
    public void SetTrust(bool isCritical, int depth, int trustAmount);
    public void SetKeyExpirationTime(bool isCritical, long seconds);
    public void SetSignatureExpirationTime(bool isCritical, long seconds);
    public void SetSignatureCreationTime(bool isCritical, DateTime date);
    public void SetPreferredHashAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetPreferredSymmetricAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetPreferredCompressionAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetPreferredAeadAlgorithms(bool isCritical, Int32[] algorithms);
    public void AddPolicyUrl(bool isCritical, string policyUrl);
    public void SetKeyFlags(bool isCritical, int flags);
    [ObsoleteAttribute("Use 'AddSignerUserId' instead")]
public void SetSignerUserId(bool isCritical, string userId);
    public void AddSignerUserId(bool isCritical, string userId);
    public void SetSignerUserId(bool isCritical, Byte[] rawUserId);
    [ObsoleteAttribute("Use 'AddEmbeddedSignature' instead")]
public void SetEmbeddedSignature(bool isCritical, PgpSignature pgpSignature);
    public void AddEmbeddedSignature(bool isCritical, PgpSignature pgpSignature);
    public void SetPrimaryUserId(bool isCritical, bool isPrimaryUserId);
    [ObsoleteAttribute("Use 'AddNotationData' instead")]
public void SetNotationData(bool isCritical, bool isHumanReadable, string notationName, string notationValue);
    public void AddNotationData(bool isCritical, bool isHumanReadable, string notationName, string notationValue);
    public void SetRevocationReason(bool isCritical, RevocationReasonTag reason, string description);
    [ObsoleteAttribute("Use 'AddRevocationKey' instead")]
public void SetRevocationKey(bool isCritical, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    public void AddRevocationKey(bool isCritical, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    public void SetIssuerKeyID(bool isCritical, long keyID);
    public void SetSignatureTarget(bool isCritical, int publicKeyAlgorithm, int hashAlgorithm, Byte[] hashData);
    public void SetIssuerFingerprint(bool isCritical, PgpSecretKey secretKey);
    public void SetIssuerFingerprint(bool isCritical, PgpPublicKey publicKey);
    public void AddIntendedRecipientFingerprint(bool isCritical, PgpPublicKey publicKey);
    public void AddCustomSubpacket(SignatureSubpacket subpacket);
    public bool RemovePacket(SignatureSubpacket packet);
    public bool HasSubpacket(SignatureSubpacketTag type);
    public SignatureSubpacket[] GetSubpackets(SignatureSubpacketTag type);
    public PgpSignatureSubpacketVector Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector : object {
    private SignatureSubpacket[] packets;
    public int Count { get; }
    internal PgpSignatureSubpacketVector(SignatureSubpacket[] packets);
    public static PgpSignatureSubpacketVector FromSubpackets(SignatureSubpacket[] packets);
    public SignatureSubpacket GetSubpacket(SignatureSubpacketTag type);
    public bool HasSubpacket(SignatureSubpacketTag type);
    public SignatureSubpacket[] GetSubpackets(SignatureSubpacketTag type);
    public PgpSignatureList GetEmbeddedSignatures();
    public NotationData[] GetNotationDataOccurrences();
    public NotationData[] GetNotationDataOccurrences(string notationName);
    public long GetIssuerKeyId();
    public bool HasSignatureCreationTime();
    public DateTime GetSignatureCreationTime();
    public bool HasSignatureExpirationTime();
    public long GetSignatureExpirationTime();
    public long GetKeyExpirationTime();
    public Int32[] GetPreferredHashAlgorithms();
    public Int32[] GetPreferredSymmetricAlgorithms();
    public Int32[] GetPreferredCompressionAlgorithms();
    public Int32[] GetPreferredAeadAlgorithms();
    public int GetKeyFlags();
    public string GetSignerUserId();
    public bool IsPrimaryUserId();
    public SignatureSubpacketTag[] GetCriticalTags();
    public SignatureTarget GetSignatureTarget();
    public Features GetFeatures();
    public IssuerFingerprint GetIssuerFingerprint();
    public IntendedRecipientFingerprint GetIntendedRecipientFingerprint();
    public IntendedRecipientFingerprint[] GetIntendedRecipientFingerprints();
    public Exportable GetExportable();
    public bool IsExportable();
    public PolicyUrl GetPolicyUrl();
    public PolicyUrl[] GetPolicyUrls();
    public RegularExpression GetRegularExpression();
    public RegularExpression[] GetRegularExpressions();
    public Revocable GetRevocable();
    public bool IsRevocable();
    public RevocationKey[] GetRevocationKeys();
    public RevocationReason GetRevocationReason();
    public TrustSignature GetTrust();
    public int get_Count();
    internal SignatureSubpacket[] ToSubpacketArray();
    public SignatureSubpacket[] ToArray();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector : object {
    private UserAttributeSubpacket[] packets;
    internal PgpUserAttributeSubpacketVector(UserAttributeSubpacket[] packets);
    public static PgpUserAttributeSubpacketVector FromSubpackets(UserAttributeSubpacket[] packets);
    public UserAttributeSubpacket GetSubpacket(UserAttributeSubpacketTag type);
    public ImageAttrib GetImageAttribute();
    internal UserAttributeSubpacket[] ToSubpacketArray();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVectorGenerator : object {
    private List`1<UserAttributeSubpacket> list;
    public virtual void SetImageAttribute(Format imageType, Byte[] imageData);
    public virtual PgpUserAttributeSubpacketVector Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities : object {
    private static IDictionary`2<string, HashAlgorithmTag> NameToHashID;
    private static IDictionary`2<DerObjectIdentifier, string> OidToName;
    private static int ReadAhead;
    private static PgpUtilities();
    private static IDictionary`2<string, HashAlgorithmTag> CreateNameToHashID();
    private static IDictionary`2<DerObjectIdentifier, string> CreateOidToName();
    public static MPInteger[] DsaSigToMpi(Byte[] encoding);
    public static MPInteger[] RsaSigToMpi(Byte[] encoding);
    public static string GetDigestName(HashAlgorithmTag hashAlgorithm);
    public static int GetDigestIDForName(string name);
    public static string GetCurveName(DerObjectIdentifier oid);
    public static string GetSignatureName(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    public static string GetSymmetricCipherName(SymmetricKeyAlgorithmTag algorithm);
    public static int GetKeySize(SymmetricKeyAlgorithmTag algorithm);
    public static KeyParameter MakeKey(SymmetricKeyAlgorithmTag algorithm, Byte[] keyBytes);
    public static KeyParameter MakeRandomKey(SymmetricKeyAlgorithmTag algorithm, SecureRandom random);
    internal static Byte[] EncodePassPhrase(Char[] passPhrase, bool utf8);
    public static KeyParameter MakeKeyFromPassPhrase(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Char[] passPhrase);
    public static KeyParameter MakeKeyFromPassPhraseUtf8(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Char[] passPhrase);
    public static KeyParameter MakeKeyFromPassPhraseRaw(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Byte[] rawPassPhrase);
    internal static KeyParameter DoMakeKeyFromPassPhrase(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Byte[] rawPassPhrase, bool clearPassPhrase);
    public static void WriteFileToLiteralData(Stream output, char fileType, FileInfo file);
    public static void WriteFileToLiteralData(Stream output, char fileType, FileInfo file, Byte[] buffer);
    private static void PipeFileContents(FileInfo file, Stream pOut);
    private static void PipeFileContents(FileInfo file, Stream pOut, int bufferSize);
    private static bool IsPossiblyBase64(int ch);
    public static Stream GetDecoderStream(Stream inputStream);
    internal static IDigest CreateDigest(HashAlgorithmTag hashAlgorithm);
    internal static ISigner CreateSigner(PublicKeyAlgorithmTag publicKeyAlgorithm, HashAlgorithmTag hashAlgorithm, AsymmetricKeyParameter key);
    internal static IWrapper CreateWrapper(SymmetricKeyAlgorithmTag encAlgorithm);
    internal static Byte[] GenerateIV(int length, SecureRandom random);
    internal static S2k GenerateS2k(HashAlgorithmTag hashAlgorithm, int s2kCount, SecureRandom random);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator : object {
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private PgpPrivateKey privKey;
    private ISigner sig;
    private IDigest dig;
    private int signatureType;
    private byte lastb;
    public PgpV3SignatureGenerator(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    public void InitSign(int sigType, PgpPrivateKey privKey);
    public void InitSign(int sigType, PgpPrivateKey privKey, SecureRandom random);
    public void Update(byte b);
    private void DoCanonicalUpdateByte(byte b);
    private void DoUpdateCRLF();
    private void DoUpdateByte(byte b);
    public void Update(Byte[] b);
    public void Update(Byte[] b, int off, int len);
    public PgpOnePassSignature GenerateOnePassVersion(bool isNested);
    public PgpSignature Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.Rfc6637Utilities : object {
    private static Byte[] ANONYMOUS_SENDER;
    private static Rfc6637Utilities();
    public static string GetAgreementAlgorithm(PublicKeyPacket pubKeyData);
    public static DerObjectIdentifier GetKeyEncryptionOID(SymmetricKeyAlgorithmTag algID);
    public static int GetKeyLength(SymmetricKeyAlgorithmTag algID);
    public static Byte[] CreateKey(PublicKeyPacket pubKeyData, ECPoint s);
    public static Byte[] CreateKey(PublicKeyPacket pubKeyData, Byte[] secret);
    public static Byte[] CreateUserKeyingMaterial(PublicKeyPacket pubKeyData);
    private static Byte[] Kdf(HashAlgorithmTag digestAlg, Byte[] ZB, int keyLen, Byte[] parameters);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.SXprUtilities : object {
    private static int ReadLength(Stream input, int ch);
    internal static string ReadString(Stream input, int ch);
    internal static Byte[] ReadBytes(Stream input, int ch);
    internal static S2k ParseS2k(Stream input);
    internal static void SkipOpenParenthesis(Stream input);
    internal static void SkipCloseParenthesis(Stream input);
}
internal class Org.BouncyCastle.Bcpg.OpenPgp.WrappedGeneratorStream : FilterStream {
    private IStreamGenerator m_generator;
    internal WrappedGeneratorStream(IStreamGenerator generator, Stream s);
    protected virtual void Dispose(bool disposing);
}
public class Org.BouncyCastle.Bcpg.Packet : object {
}
public enum Org.BouncyCastle.Bcpg.PacketTag : Enum {
    public int value__;
    public static PacketTag Reserved;
    public static PacketTag PublicKeyEncryptedSession;
    public static PacketTag Signature;
    public static PacketTag SymmetricKeyEncryptedSessionKey;
    public static PacketTag OnePassSignature;
    public static PacketTag SecretKey;
    public static PacketTag PublicKey;
    public static PacketTag SecretSubkey;
    public static PacketTag CompressedData;
    public static PacketTag SymmetricKeyEncrypted;
    public static PacketTag Marker;
    public static PacketTag LiteralData;
    public static PacketTag Trust;
    public static PacketTag UserId;
    public static PacketTag PublicSubkey;
    public static PacketTag UserAttribute;
    public static PacketTag SymmetricEncryptedIntegrityProtected;
    public static PacketTag ModificationDetectionCode;
    public static PacketTag Experimental1;
    public static PacketTag Experimental2;
    public static PacketTag Experimental3;
    public static PacketTag Experimental4;
}
public enum Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag : Enum {
    public int value__;
    public static PublicKeyAlgorithmTag RsaGeneral;
    public static PublicKeyAlgorithmTag RsaEncrypt;
    public static PublicKeyAlgorithmTag RsaSign;
    public static PublicKeyAlgorithmTag ElGamalEncrypt;
    public static PublicKeyAlgorithmTag Dsa;
    public static PublicKeyAlgorithmTag ECDH;
    public static PublicKeyAlgorithmTag ECDsa;
    public static PublicKeyAlgorithmTag ElGamalGeneral;
    public static PublicKeyAlgorithmTag DiffieHellman;
    public static PublicKeyAlgorithmTag EdDsa;
    public static PublicKeyAlgorithmTag EdDsa_Legacy;
    public static PublicKeyAlgorithmTag Experimental_1;
    public static PublicKeyAlgorithmTag Experimental_2;
    public static PublicKeyAlgorithmTag Experimental_3;
    public static PublicKeyAlgorithmTag Experimental_4;
    public static PublicKeyAlgorithmTag Experimental_5;
    public static PublicKeyAlgorithmTag Experimental_6;
    public static PublicKeyAlgorithmTag Experimental_7;
    public static PublicKeyAlgorithmTag Experimental_8;
    public static PublicKeyAlgorithmTag Experimental_9;
    public static PublicKeyAlgorithmTag Experimental_10;
    public static PublicKeyAlgorithmTag Experimental_11;
}
public class Org.BouncyCastle.Bcpg.PublicKeyEncSessionPacket : ContainedPacket {
    private int version;
    private long keyId;
    private PublicKeyAlgorithmTag algorithm;
    private Byte[][] data;
    public int Version { get; }
    public long KeyId { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    internal PublicKeyEncSessionPacket(BcpgInputStream bcpgIn);
    public PublicKeyEncSessionPacket(long keyId, PublicKeyAlgorithmTag algorithm, Byte[][] data);
    public int get_Version();
    public long get_KeyId();
    public PublicKeyAlgorithmTag get_Algorithm();
    public Byte[][] GetEncSessionKey();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.PublicKeyPacket : ContainedPacket {
    private int version;
    private long time;
    private int validDays;
    private PublicKeyAlgorithmTag algorithm;
    private IBcpgKey key;
    public int Version { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public int ValidDays { get; }
    public IBcpgKey Key { get; }
    internal PublicKeyPacket(BcpgInputStream bcpgIn);
    public PublicKeyPacket(PublicKeyAlgorithmTag algorithm, DateTime time, IBcpgKey key);
    public virtual int get_Version();
    public virtual PublicKeyAlgorithmTag get_Algorithm();
    public virtual int get_ValidDays();
    public virtual DateTime GetTime();
    public virtual IBcpgKey get_Key();
    public virtual Byte[] GetEncodedContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.PublicSubkeyPacket : PublicKeyPacket {
    internal PublicSubkeyPacket(BcpgInputStream bcpgIn);
    public PublicSubkeyPacket(PublicKeyAlgorithmTag algorithm, DateTime time, IBcpgKey key);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.RevocationKey : SignatureSubpacket {
    public RevocationKeyTag SignatureClass { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public RevocationKey(bool isCritical, bool isLongLength, Byte[] data);
    public RevocationKey(bool isCritical, RevocationKeyTag signatureClass, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    private static Byte[] CreateData(RevocationKeyTag signatureClass, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    public virtual RevocationKeyTag get_SignatureClass();
    public virtual PublicKeyAlgorithmTag get_Algorithm();
    public virtual Byte[] GetFingerprint();
}
public enum Org.BouncyCastle.Bcpg.RevocationKeyTag : Enum {
    public byte value__;
    public static RevocationKeyTag ClassDefault;
    public static RevocationKeyTag ClassSensitive;
}
public class Org.BouncyCastle.Bcpg.RevocationReason : SignatureSubpacket {
    public RevocationReason(bool isCritical, bool isLongLength, Byte[] data);
    public RevocationReason(bool isCritical, RevocationReasonTag reason, string description);
    private static Byte[] CreateData(RevocationReasonTag reason, string description);
    public virtual RevocationReasonTag GetRevocationReason();
    public virtual string GetRevocationDescription();
}
public enum Org.BouncyCastle.Bcpg.RevocationReasonTag : Enum {
    public byte value__;
    public static RevocationReasonTag NoReason;
    public static RevocationReasonTag KeySuperseded;
    public static RevocationReasonTag KeyCompromised;
    public static RevocationReasonTag KeyRetired;
    public static RevocationReasonTag UserNoLongerValid;
}
public class Org.BouncyCastle.Bcpg.RsaPublicBcpgKey : BcpgObject {
    private MPInteger n;
    private MPInteger e;
    public BigInteger PublicExponent { get; }
    public BigInteger Modulus { get; }
    public string Format { get; }
    public RsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public RsaPublicBcpgKey(BigInteger n, BigInteger e);
    public BigInteger get_PublicExponent();
    public BigInteger get_Modulus();
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.RsaSecretBcpgKey : BcpgObject {
    private MPInteger d;
    private MPInteger p;
    private MPInteger q;
    private MPInteger u;
    private BigInteger expP;
    private BigInteger expQ;
    private BigInteger crt;
    public BigInteger Modulus { get; }
    public BigInteger PrivateExponent { get; }
    public BigInteger PrimeP { get; }
    public BigInteger PrimeQ { get; }
    public BigInteger PrimeExponentP { get; }
    public BigInteger PrimeExponentQ { get; }
    public BigInteger CrtCoefficient { get; }
    public string Format { get; }
    public RsaSecretBcpgKey(BcpgInputStream bcpgIn);
    public RsaSecretBcpgKey(BigInteger d, BigInteger p, BigInteger q);
    public BigInteger get_Modulus();
    public BigInteger get_PrivateExponent();
    public BigInteger get_PrimeP();
    public BigInteger get_PrimeQ();
    public BigInteger get_PrimeExponentP();
    public BigInteger get_PrimeExponentQ();
    public BigInteger get_CrtCoefficient();
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.S2k : BcpgObject {
    private static int ExpBias;
    public static int Simple;
    public static int Salted;
    public static int SaltedAndIterated;
    public static int GnuDummyS2K;
    public static int GnuProtectionModeNoPrivateKey;
    public static int GnuProtectionModeDivertToCard;
    internal int type;
    internal HashAlgorithmTag algorithm;
    internal Byte[] iv;
    internal int itCount;
    internal int protectionMode;
    public int Type { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long IterationCount { get; }
    public int ProtectionMode { get; }
    internal S2k(Stream inStr);
    public S2k(HashAlgorithmTag algorithm);
    public S2k(HashAlgorithmTag algorithm, Byte[] iv);
    public S2k(HashAlgorithmTag algorithm, Byte[] iv, int itCount);
    public virtual int get_Type();
    public virtual HashAlgorithmTag get_HashAlgorithm();
    public virtual Byte[] GetIV();
    public virtual long get_IterationCount();
    public virtual int get_ProtectionMode();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.SecretKeyPacket : ContainedPacket {
    public static int UsageNone;
    public static int UsageChecksum;
    public static int UsageSha1;
    private PublicKeyPacket pubKeyPacket;
    private Byte[] secKeyData;
    private int s2kUsage;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private S2k s2k;
    private Byte[] iv;
    public SymmetricKeyAlgorithmTag EncAlgorithm { get; }
    public int S2kUsage { get; }
    public S2k S2k { get; }
    public PublicKeyPacket PublicKeyPacket { get; }
    internal SecretKeyPacket(BcpgInputStream bcpgIn);
    public SecretKeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SecretKeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, int s2kUsage, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SymmetricKeyAlgorithmTag get_EncAlgorithm();
    public int get_S2kUsage();
    public Byte[] GetIV();
    public S2k get_S2k();
    public PublicKeyPacket get_PublicKeyPacket();
    public Byte[] GetSecretKeyData();
    public Byte[] GetEncodedContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.SecretSubkeyPacket : SecretKeyPacket {
    internal SecretSubkeyPacket(BcpgInputStream bcpgIn);
    public SecretSubkeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SecretSubkeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, int s2kUsage, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.Sig.EmbeddedSignature : SignatureSubpacket {
    public EmbeddedSignature(bool critical, bool isLongLength, Byte[] data);
}
public class Org.BouncyCastle.Bcpg.Sig.Exportable : SignatureSubpacket {
    public Exportable(bool critical, bool isLongLength, Byte[] data);
    public Exportable(bool critical, bool isExportable);
    private static Byte[] BooleanToByteArray(bool val);
    public bool IsExportable();
}
public class Org.BouncyCastle.Bcpg.Sig.Features : SignatureSubpacket {
    public static byte FEATURE_MODIFICATION_DETECTION;
    public static byte FEATURE_AEAD_ENCRYPTED_DATA;
    public static byte FEATURE_VERSION_5_PUBLIC_KEY;
    public bool SupportsModificationDetection { get; }
    public Features(bool critical, bool isLongLength, Byte[] data);
    public Features(bool critical, byte features);
    public Features(bool critical, int features);
    private static Features();
    private static Byte[] FeatureToByteArray(byte feature);
    public bool get_SupportsModificationDetection();
    public bool SupportsFeature(byte feature);
}
public class Org.BouncyCastle.Bcpg.Sig.IntendedRecipientFingerprint : SignatureSubpacket {
    public int KeyVersion { get; }
    public IntendedRecipientFingerprint(bool critical, bool isLongLength, Byte[] data);
    public IntendedRecipientFingerprint(bool critical, int keyVersion, Byte[] fingerprint);
    public int get_KeyVersion();
    public Byte[] GetFingerprint();
}
public class Org.BouncyCastle.Bcpg.Sig.IssuerFingerprint : SignatureSubpacket {
    public int KeyVersion { get; }
    public IssuerFingerprint(bool critical, bool isLongLength, Byte[] data);
    public IssuerFingerprint(bool critical, int keyVersion, Byte[] fingerprint);
    public int get_KeyVersion();
    public Byte[] GetFingerprint();
}
public class Org.BouncyCastle.Bcpg.Sig.IssuerKeyId : SignatureSubpacket {
    public long KeyId { get; }
    public IssuerKeyId(bool critical, bool isLongLength, Byte[] data);
    public IssuerKeyId(bool critical, long keyId);
    protected static Byte[] KeyIdToBytes(long keyId);
    public long get_KeyId();
}
public class Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime : SignatureSubpacket {
    public long Time { get; }
    public KeyExpirationTime(bool critical, bool isLongLength, Byte[] data);
    public KeyExpirationTime(bool critical, long seconds);
    protected static Byte[] TimeToBytes(long t);
    public long get_Time();
}
public class Org.BouncyCastle.Bcpg.Sig.KeyFlags : SignatureSubpacket {
    public static int CertifyOther;
    public static int SignData;
    public static int EncryptComms;
    public static int EncryptStorage;
    public static int Split;
    public static int Authentication;
    public static int Shared;
    public int Flags { get; }
    public KeyFlags(bool critical, bool isLongLength, Byte[] data);
    public KeyFlags(bool critical, int flags);
    private static Byte[] IntToByteArray(int v);
    public int get_Flags();
}
public class Org.BouncyCastle.Bcpg.Sig.NotationData : SignatureSubpacket {
    public static int HeaderFlagLength;
    public static int HeaderNameLength;
    public static int HeaderValueLength;
    public bool IsHumanReadable { get; }
    public NotationData(bool critical, bool isLongLength, Byte[] data);
    public NotationData(bool critical, bool humanReadable, string notationName, string notationValue);
    private static Byte[] CreateData(bool humanReadable, string notationName, string notationValue);
    public bool get_IsHumanReadable();
    public string GetNotationName();
    public string GetNotationValue();
    public Byte[] GetNotationValueBytes();
}
public class Org.BouncyCastle.Bcpg.Sig.PolicyUrl : SignatureSubpacket {
    public string Url { get; }
    public PolicyUrl(bool critical, string url);
    public PolicyUrl(bool critical, bool isLongLength, Byte[] data);
    public string get_Url();
    public Byte[] GetRawUrl();
}
public class Org.BouncyCastle.Bcpg.Sig.PreferredAlgorithms : SignatureSubpacket {
    public PreferredAlgorithms(SignatureSubpacketTag type, bool critical, bool isLongLength, Byte[] data);
    public PreferredAlgorithms(SignatureSubpacketTag type, bool critical, Int32[] preferences);
    private static Byte[] IntToByteArray(Int32[] v);
    public Int32[] GetPreferences();
}
public class Org.BouncyCastle.Bcpg.Sig.PrimaryUserId : SignatureSubpacket {
    public PrimaryUserId(bool critical, bool isLongLength, Byte[] data);
    public PrimaryUserId(bool critical, bool isPrimaryUserId);
    private static Byte[] BooleanToByteArray(bool val);
    public bool IsPrimaryUserId();
}
public class Org.BouncyCastle.Bcpg.Sig.RegularExpression : SignatureSubpacket {
    public string Regex { get; }
    public RegularExpression(bool critical, bool isLongLength, Byte[] data);
    public RegularExpression(bool critical, string regex);
    public string get_Regex();
    public Byte[] GetRawRegex();
    private static Byte[] ToNullTerminatedUtf8ByteArray(string str);
}
public class Org.BouncyCastle.Bcpg.Sig.Revocable : SignatureSubpacket {
    public Revocable(bool critical, bool isLongLength, Byte[] data);
    public Revocable(bool critical, bool isRevocable);
    private static Byte[] BooleanToByteArray(bool value);
    public bool IsRevocable();
}
public class Org.BouncyCastle.Bcpg.Sig.SignatureCreationTime : SignatureSubpacket {
    public SignatureCreationTime(bool critical, bool isLongLength, Byte[] data);
    public SignatureCreationTime(bool critical, DateTime date);
    protected static Byte[] TimeToBytes(DateTime time);
    public DateTime GetTime();
}
public class Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime : SignatureSubpacket {
    public long Time { get; }
    public SignatureExpirationTime(bool critical, bool isLongLength, Byte[] data);
    public SignatureExpirationTime(bool critical, long seconds);
    protected static Byte[] TimeToBytes(long t);
    public long get_Time();
}
public class Org.BouncyCastle.Bcpg.Sig.SignatureTarget : SignatureSubpacket {
    public int PublicKeyAlgorithm { get; }
    public int HashAlgorithm { get; }
    public SignatureTarget(bool critical, bool isLongLength, Byte[] data);
    public SignatureTarget(bool critical, int publicKeyAlgorithm, int hashAlgorithm, Byte[] hashData);
    public int get_PublicKeyAlgorithm();
    public int get_HashAlgorithm();
    public Byte[] GetHashData();
}
public class Org.BouncyCastle.Bcpg.Sig.SignerUserId : SignatureSubpacket {
    public SignerUserId(bool critical, bool isLongLength, Byte[] data);
    public SignerUserId(bool critical, string userId);
    public string GetId();
    public Byte[] GetRawId();
}
public class Org.BouncyCastle.Bcpg.Sig.TrustSignature : SignatureSubpacket {
    public int Depth { get; }
    public int TrustAmount { get; }
    public TrustSignature(bool critical, bool isLongLength, Byte[] data);
    public TrustSignature(bool critical, int depth, int trustAmount);
    private static Byte[] IntToByteArray(int v1, int v2);
    public int get_Depth();
    public int get_TrustAmount();
}
public class Org.BouncyCastle.Bcpg.SignaturePacket : ContainedPacket {
    private int version;
    private int signatureType;
    private long creationTime;
    private long keyId;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private MPInteger[] signature;
    private Byte[] fingerprint;
    private SignatureSubpacket[] hashedData;
    private SignatureSubpacket[] unhashedData;
    private Byte[] signatureEncoding;
    public int Version { get; }
    public int SignatureType { get; }
    public long KeyId { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long CreationTime { get; }
    internal SignaturePacket(BcpgInputStream bcpgIn);
    public SignaturePacket(int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, SignatureSubpacket[] hashedData, SignatureSubpacket[] unhashedData, Byte[] fingerprint, MPInteger[] signature);
    public SignaturePacket(int version, int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, long creationTime, Byte[] fingerprint, MPInteger[] signature);
    public SignaturePacket(int version, int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, SignatureSubpacket[] hashedData, SignatureSubpacket[] unhashedData, Byte[] fingerprint, MPInteger[] signature);
    public int get_Version();
    public int get_SignatureType();
    public long get_KeyId();
    public Byte[] GetFingerprint();
    public Byte[] GetSignatureTrailer();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public MPInteger[] GetSignature();
    public Byte[] GetSignatureBytes();
    public SignatureSubpacket[] GetHashedSubPackets();
    public SignatureSubpacket[] GetUnhashedSubPackets();
    public long get_CreationTime();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    private static void EncodeLengthAndData(BcpgOutputStream pOut, Byte[] data);
    private static Byte[] GetEncodedSubpackets(SignatureSubpacket[] ps);
    private void SetCreationTime();
    public static SignaturePacket FromByteArray(Byte[] data);
}
public class Org.BouncyCastle.Bcpg.SignatureSubpacket : object {
    private SignatureSubpacketTag type;
    private bool critical;
    private bool isLongLength;
    internal Byte[] data;
    public SignatureSubpacketTag SubpacketType { get; }
    protected internal SignatureSubpacket(SignatureSubpacketTag type, bool critical, bool isLongLength, Byte[] data);
    public SignatureSubpacketTag get_SubpacketType();
    public bool IsCritical();
    public bool IsLongLength();
    public Byte[] GetData();
    public void Encode(Stream os);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Org.BouncyCastle.Bcpg.SignatureSubpacketsParser : object {
    private Stream input;
    public SignatureSubpacketsParser(Stream input);
    public SignatureSubpacket ReadPacket();
    private Byte[] CheckData(Byte[] data, int expected, int bytesRead, string name);
}
public enum Org.BouncyCastle.Bcpg.SignatureSubpacketTag : Enum {
    public int value__;
    public static SignatureSubpacketTag CreationTime;
    public static SignatureSubpacketTag ExpireTime;
    public static SignatureSubpacketTag Exportable;
    public static SignatureSubpacketTag TrustSig;
    public static SignatureSubpacketTag RegExp;
    public static SignatureSubpacketTag Revocable;
    public static SignatureSubpacketTag KeyExpireTime;
    public static SignatureSubpacketTag Placeholder;
    public static SignatureSubpacketTag PreferredSymmetricAlgorithms;
    public static SignatureSubpacketTag RevocationKey;
    public static SignatureSubpacketTag IssuerKeyId;
    public static SignatureSubpacketTag NotationData;
    public static SignatureSubpacketTag PreferredHashAlgorithms;
    public static SignatureSubpacketTag PreferredCompressionAlgorithms;
    public static SignatureSubpacketTag KeyServerPreferences;
    public static SignatureSubpacketTag PreferredKeyServer;
    public static SignatureSubpacketTag PrimaryUserId;
    public static SignatureSubpacketTag PolicyUrl;
    public static SignatureSubpacketTag KeyFlags;
    public static SignatureSubpacketTag SignerUserId;
    public static SignatureSubpacketTag RevocationReason;
    public static SignatureSubpacketTag Features;
    public static SignatureSubpacketTag SignatureTarget;
    public static SignatureSubpacketTag EmbeddedSignature;
    public static SignatureSubpacketTag IssuerFingerprint;
    public static SignatureSubpacketTag IntendedRecipientFingerprint;
    public static SignatureSubpacketTag AttestedCertifications;
    public static SignatureSubpacketTag KeyBlock;
    public static SignatureSubpacketTag PreferredAeadAlgorithms;
}
public class Org.BouncyCastle.Bcpg.SymmetricEncDataPacket : InputStreamPacket {
    public SymmetricEncDataPacket(BcpgInputStream bcpgIn);
}
public class Org.BouncyCastle.Bcpg.SymmetricEncIntegrityPacket : InputStreamPacket {
    internal int version;
    internal SymmetricEncIntegrityPacket(BcpgInputStream bcpgIn);
}
public enum Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag : Enum {
    public int value__;
    public static SymmetricKeyAlgorithmTag Null;
    public static SymmetricKeyAlgorithmTag Idea;
    public static SymmetricKeyAlgorithmTag TripleDes;
    public static SymmetricKeyAlgorithmTag Cast5;
    public static SymmetricKeyAlgorithmTag Blowfish;
    public static SymmetricKeyAlgorithmTag Safer;
    public static SymmetricKeyAlgorithmTag Des;
    public static SymmetricKeyAlgorithmTag Aes128;
    public static SymmetricKeyAlgorithmTag Aes192;
    public static SymmetricKeyAlgorithmTag Aes256;
    public static SymmetricKeyAlgorithmTag Twofish;
    public static SymmetricKeyAlgorithmTag Camellia128;
    public static SymmetricKeyAlgorithmTag Camellia192;
    public static SymmetricKeyAlgorithmTag Camellia256;
}
public class Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket : ContainedPacket {
    private int version;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private S2k s2k;
    private Byte[] secKeyData;
    public SymmetricKeyAlgorithmTag EncAlgorithm { get; }
    public S2k S2k { get; }
    public int Version { get; }
    public SymmetricKeyEncSessionPacket(BcpgInputStream bcpgIn);
    public SymmetricKeyEncSessionPacket(SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] secKeyData);
    public SymmetricKeyAlgorithmTag get_EncAlgorithm();
    public S2k get_S2k();
    public Byte[] GetSecKeyData();
    public int get_Version();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.TrustPacket : ContainedPacket {
    private Byte[] levelAndTrustAmount;
    public TrustPacket(BcpgInputStream bcpgIn);
    public TrustPacket(int trustCode);
    public Byte[] GetLevelAndTrustAmount();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.UnsupportedPacketVersionException : Exception {
    public UnsupportedPacketVersionException(string message);
    public UnsupportedPacketVersionException(string message, Exception innerException);
    protected UnsupportedPacketVersionException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Bcpg.UserAttributePacket : ContainedPacket {
    private UserAttributeSubpacket[] subpackets;
    public UserAttributePacket(BcpgInputStream bcpgIn);
    public UserAttributePacket(UserAttributeSubpacket[] subpackets);
    public UserAttributeSubpacket[] GetSubpackets();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.UserAttributeSubpacket : object {
    internal UserAttributeSubpacketTag type;
    private bool longLength;
    protected Byte[] data;
    public UserAttributeSubpacketTag SubpacketType { get; }
    protected internal UserAttributeSubpacket(UserAttributeSubpacketTag type, Byte[] data);
    protected internal UserAttributeSubpacket(UserAttributeSubpacketTag type, bool forceLongLength, Byte[] data);
    public virtual UserAttributeSubpacketTag get_SubpacketType();
    public virtual Byte[] GetData();
    public virtual void Encode(Stream os);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Bcpg.UserAttributeSubpacketsParser : object {
    private Stream input;
    public UserAttributeSubpacketsParser(Stream input);
    public virtual UserAttributeSubpacket ReadPacket();
}
public enum Org.BouncyCastle.Bcpg.UserAttributeSubpacketTag : Enum {
    public int value__;
    public static UserAttributeSubpacketTag ImageAttribute;
}
public class Org.BouncyCastle.Bcpg.UserIdPacket : ContainedPacket {
    private Byte[] idData;
    public UserIdPacket(BcpgInputStream bcpgIn);
    public UserIdPacket(string id);
    public UserIdPacket(Byte[] rawId);
    public string GetId();
    public Byte[] GetRawId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Cmp.CertificateConfirmationContent : object {
    private DefaultDigestAlgorithmIdentifierFinder m_digestAlgFinder;
    private CertConfirmContent m_content;
    public CertificateConfirmationContent(CertConfirmContent content);
    public CertificateConfirmationContent(CertConfirmContent content, DefaultDigestAlgorithmIdentifierFinder digestAlgFinder);
    public CertConfirmContent ToAsn1Structure();
    public CertificateStatus[] GetStatusMessages();
}
public class Org.BouncyCastle.Cmp.CertificateConfirmationContentBuilder : object {
    private static DefaultSignatureAlgorithmIdentifierFinder SigAlgFinder;
    private DefaultDigestAlgorithmIdentifierFinder m_digestAlgFinder;
    private IList`1<X509Certificate> m_acceptedCerts;
    private IList`1<BigInteger> m_acceptedReqIDs;
    public CertificateConfirmationContentBuilder(DefaultDigestAlgorithmIdentifierFinder digestAlgFinder);
    private static CertificateConfirmationContentBuilder();
    public CertificateConfirmationContentBuilder AddAcceptedCertificate(X509Certificate certHolder, BigInteger certReqId);
    public CertificateConfirmationContent Build();
}
public class Org.BouncyCastle.Cmp.CertificateStatus : object {
    private static DefaultSignatureAlgorithmIdentifierFinder sigAlgFinder;
    private DefaultDigestAlgorithmIdentifierFinder digestAlgFinder;
    private CertStatus certStatus;
    public PkiStatusInfo StatusInfo { get; }
    public BigInteger CertRequestID { get; }
    public CertificateStatus(DefaultDigestAlgorithmIdentifierFinder digestAlgFinder, CertStatus certStatus);
    private static CertificateStatus();
    public virtual PkiStatusInfo get_StatusInfo();
    public virtual BigInteger get_CertRequestID();
    public virtual bool IsVerified(X509Certificate cert);
}
public class Org.BouncyCastle.Cmp.CmpException : Exception {
    public CmpException(string message);
    public CmpException(string message, Exception innerException);
    protected CmpException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Cmp.GeneralPkiMessage : object {
    private PkiMessage m_pkiMessage;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    public bool HasProtection { get; }
    public GeneralPkiMessage(PkiMessage pkiMessage);
    public GeneralPkiMessage(Byte[] encoding);
    private static PkiMessage ParseBytes(Byte[] encoding);
    public virtual PkiHeader get_Header();
    public virtual PkiBody get_Body();
    public virtual bool get_HasProtection();
    public virtual PkiMessage ToAsn1Structure();
}
public class Org.BouncyCastle.Cmp.ProtectedPkiMessage : object {
    private PkiMessage m_pkiMessage;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    public bool HasPasswordBasedMacProtected { get; }
    public ProtectedPkiMessage(GeneralPkiMessage pkiMessage);
    public ProtectedPkiMessage(PkiMessage pkiMessage);
    public virtual PkiHeader get_Header();
    public virtual PkiBody get_Body();
    public virtual PkiMessage ToAsn1Message();
    public virtual bool get_HasPasswordBasedMacProtected();
    public virtual X509Certificate[] GetCertificates();
    public virtual bool Verify(IVerifierFactory verifierFactory);
    public virtual bool Verify(PKMacBuilder pkMacBuilder, Char[] password);
    private TResult Process(IStreamCalculator`1<TResult> streamCalculator);
}
public class Org.BouncyCastle.Cmp.ProtectedPkiMessageBuilder : object {
    private PkiHeaderBuilder m_hdrBuilder;
    private PkiBody body;
    private List`1<InfoTypeAndValue> generalInfos;
    private List`1<X509Certificate> extraCerts;
    public ProtectedPkiMessageBuilder(GeneralName sender, GeneralName recipient);
    public ProtectedPkiMessageBuilder(int pvno, GeneralName sender, GeneralName recipient);
    public ProtectedPkiMessageBuilder SetTransactionId(Byte[] tid);
    public ProtectedPkiMessageBuilder SetFreeText(PkiFreeText freeText);
    public ProtectedPkiMessageBuilder AddGeneralInfo(InfoTypeAndValue genInfo);
    public ProtectedPkiMessageBuilder SetMessageTime(DateTime time);
    public ProtectedPkiMessageBuilder SetMessageTime(Asn1GeneralizedTime generalizedTime);
    public ProtectedPkiMessageBuilder SetRecipKID(Byte[] id);
    public ProtectedPkiMessageBuilder SetRecipNonce(Byte[] nonce);
    public ProtectedPkiMessageBuilder SetSenderKID(Byte[] id);
    public ProtectedPkiMessageBuilder SetSenderNonce(Byte[] nonce);
    public ProtectedPkiMessageBuilder SetBody(PkiBody body);
    public ProtectedPkiMessageBuilder AddCmpCertificate(X509Certificate certificate);
    public ProtectedPkiMessage Build(ISignatureFactory signatureFactory);
    public ProtectedPkiMessage Build(IMacFactory macFactory);
    private void FinalizeHeader(AlgorithmIdentifier algorithmIdentifier);
    private ProtectedPkiMessage FinalizeMessage(PkiHeader header, DerBitString protection);
}
public class Org.BouncyCastle.Cmp.RevocationDetails : ValueType {
    private RevDetails m_revDetails;
    public X509Name Subject { get; }
    public X509Name Issuer { get; }
    public BigInteger SerialNumber { get; }
    public RevocationDetails(RevDetails revDetails);
    public X509Name get_Subject();
    public X509Name get_Issuer();
    public BigInteger get_SerialNumber();
    public RevDetails ToASN1Structure();
}
public class Org.BouncyCastle.Cmp.RevocationDetailsBuilder : object {
    private CertTemplateBuilder m_templateBuilder;
    public RevocationDetailsBuilder SetPublicKey(SubjectPublicKeyInfo publicKey);
    public RevocationDetailsBuilder SetIssuer(X509Name issuer);
    public RevocationDetailsBuilder SetSerialNumber(BigInteger serialNumber);
    public RevocationDetailsBuilder SetSubject(X509Name subject);
    public RevocationDetails Build();
}
public class Org.BouncyCastle.Cms.CmsAttributeTableGenerationException : CmsException {
    public CmsAttributeTableGenerationException(string message);
    public CmsAttributeTableGenerationException(string message, Exception innerException);
    protected CmsAttributeTableGenerationException(SerializationInfo info, StreamingContext context);
}
public interface Org.BouncyCastle.Cms.CmsAttributeTableGenerator {
    public abstract virtual AttributeTable GetAttributes(IDictionary`2<CmsAttributeTableParameter, object> parameters);
}
public enum Org.BouncyCastle.Cms.CmsAttributeTableParameter : Enum {
    public int value__;
    public static CmsAttributeTableParameter ContentType;
    public static CmsAttributeTableParameter Digest;
    public static CmsAttributeTableParameter Signature;
    public static CmsAttributeTableParameter DigestAlgorithmIdentifier;
    public static CmsAttributeTableParameter SignatureAlgorithmIdentifier;
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private AlgorithmIdentifier macAlg;
    private Asn1Set authAttrs;
    private Asn1Set unauthAttrs;
    private Byte[] mac;
    public AlgorithmIdentifier MacAlgorithmID { get; }
    public string MacAlgOid { get; }
    public ContentInfo ContentInfo { get; }
    public CmsAuthenticatedData(Byte[] authData);
    public CmsAuthenticatedData(Stream authData);
    public CmsAuthenticatedData(ContentInfo contentInfo);
    public Byte[] GetMac();
    public AlgorithmIdentifier get_MacAlgorithmID();
    public string get_MacAlgOid();
    public RecipientInformationStore GetRecipientInfos();
    public ContentInfo get_ContentInfo();
    public AttributeTable GetAuthAttrs();
    public AttributeTable GetUnauthAttrs();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator : CmsAuthenticatedGenerator {
    public CmsAuthenticatedDataGenerator(SecureRandom random);
    private CmsAuthenticatedData Generate(CmsProcessable content, string macOid, CipherKeyGenerator keyGen);
    public CmsAuthenticatedData Generate(CmsProcessable content, string encryptionOid);
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedDataParser : CmsContentInfoParser {
    internal RecipientInformationStore _recipientInfoStore;
    internal AuthenticatedDataParser authData;
    private AlgorithmIdentifier macAlg;
    private Byte[] mac;
    private AttributeTable authAttrs;
    private AttributeTable unauthAttrs;
    private bool authAttrNotRead;
    private bool unauthAttrNotRead;
    public AlgorithmIdentifier MacAlgorithmID { get; }
    public string MacAlgOid { get; }
    public Asn1Object MacAlgParams { get; }
    public CmsAuthenticatedDataParser(Byte[] envelopedData);
    public CmsAuthenticatedDataParser(Stream envelopedData);
    public AlgorithmIdentifier get_MacAlgorithmID();
    public string get_MacAlgOid();
    public Asn1Object get_MacAlgParams();
    public RecipientInformationStore GetRecipientInfos();
    public Byte[] GetMac();
    public AttributeTable GetAuthAttrs();
    public AttributeTable GetUnauthAttrs();
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator : CmsAuthenticatedGenerator {
    private int _bufferSize;
    private bool _berEncodeRecipientSet;
    public CmsAuthenticatedDataStreamGenerator(SecureRandom random);
    public void SetBufferSize(int bufferSize);
    public void SetBerEncodeRecipients(bool berEncodeRecipientSet);
    private Stream Open(Stream outStr, string macOid, CipherKeyGenerator keyGen);
    protected Stream Open(Stream outStr, AlgorithmIdentifier macAlgId, ICipherParameters cipherParameters, Asn1EncodableVector recipientInfos);
    public Stream Open(Stream outStr, string encryptionOid);
    public Stream Open(Stream outStr, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedGenerator : CmsEnvelopedGenerator {
    public CmsAuthenticatedGenerator(SecureRandom random);
}
internal class Org.BouncyCastle.Cms.CmsAuthEnvelopedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private OriginatorInfo originator;
    private AlgorithmIdentifier authEncAlg;
    private Asn1Set authAttrs;
    private Byte[] mac;
    private Asn1Set unauthAttrs;
    public CmsAuthEnvelopedData(Byte[] authEnvData);
    public CmsAuthEnvelopedData(Stream authEnvData);
    public CmsAuthEnvelopedData(ContentInfo contentInfo);
}
internal class Org.BouncyCastle.Cms.CmsAuthEnvelopedGenerator : object {
    public static string Aes128Ccm;
    public static string Aes192Ccm;
    public static string Aes256Ccm;
    public static string Aes128Gcm;
    public static string Aes192Gcm;
    public static string Aes256Gcm;
    private static CmsAuthEnvelopedGenerator();
}
public class Org.BouncyCastle.Cms.CmsCompressedData : object {
    internal ContentInfo contentInfo;
    public ContentInfo ContentInfo { get; }
    public CmsCompressedData(Byte[] compressedData);
    public CmsCompressedData(Stream compressedDataStream);
    public CmsCompressedData(ContentInfo contentInfo);
    public Byte[] GetContent();
    public Byte[] GetContent(int limit);
    public ContentInfo get_ContentInfo();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsCompressedDataGenerator : object {
    public static string ZLib;
    private static CmsCompressedDataGenerator();
    public CmsCompressedData Generate(CmsProcessable content, string compressionOid);
}
public class Org.BouncyCastle.Cms.CmsCompressedDataParser : CmsContentInfoParser {
    public CmsCompressedDataParser(Byte[] compressedData);
    public CmsCompressedDataParser(Stream compressedData);
    public CmsTypedStream GetContent();
}
public class Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator : object {
    public static string ZLib;
    private int _bufferSize;
    private static CmsCompressedDataStreamGenerator();
    public void SetBufferSize(int bufferSize);
    public Stream Open(Stream outStream);
    public Stream Open(Stream outStream, string compressionOid);
    public Stream Open(Stream outStream, string contentOid, string compressionOid);
}
public class Org.BouncyCastle.Cms.CmsContentInfoParser : object {
    protected ContentInfoParser contentInfo;
    protected Stream data;
    protected CmsContentInfoParser(Stream data);
    [ObsoleteAttribute("Dispose instead")]
public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Org.BouncyCastle.Cms.CmsEnvelopedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private AlgorithmIdentifier encAlg;
    private Asn1Set unprotectedAttributes;
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public ContentInfo ContentInfo { get; }
    public CmsEnvelopedData(Byte[] envelopedData);
    public CmsEnvelopedData(Stream envelopedData);
    public CmsEnvelopedData(ContentInfo contentInfo);
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public RecipientInformationStore GetRecipientInfos();
    public ContentInfo get_ContentInfo();
    public AttributeTable GetUnprotectedAttributes();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator : CmsEnvelopedGenerator {
    public CmsEnvelopedDataGenerator(SecureRandom random);
    private CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid, CipherKeyGenerator keyGen);
    public CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid);
    public CmsEnvelopedData Generate(CmsProcessable content, ICipherBuilderWithKey cipherBuilder);
    public CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataParser : CmsContentInfoParser {
    internal RecipientInformationStore recipientInfoStore;
    internal EnvelopedDataParser envelopedData;
    private AlgorithmIdentifier _encAlg;
    private AttributeTable _unprotectedAttributes;
    private bool _attrNotRead;
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public Asn1Object EncryptionAlgParams { get; }
    public CmsEnvelopedDataParser(Byte[] envelopedData);
    public CmsEnvelopedDataParser(Stream envelopedData);
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public Asn1Object get_EncryptionAlgParams();
    public RecipientInformationStore GetRecipientInfos();
    public AttributeTable GetUnprotectedAttributes();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator : CmsEnvelopedGenerator {
    private object _originatorInfo;
    private object _unprotectedAttributes;
    private int _bufferSize;
    private bool _berEncodeRecipientSet;
    private DerInteger Version { get; }
    public CmsEnvelopedDataStreamGenerator(SecureRandom random);
    public void SetBufferSize(int bufferSize);
    public void SetBerEncodeRecipients(bool berEncodeRecipientSet);
    private DerInteger get_Version();
    private Stream Open(Stream outStream, string encryptionOid, CipherKeyGenerator keyGen);
    private Stream Open(Stream outStream, AlgorithmIdentifier encAlgID, ICipherParameters cipherParameters, Asn1EncodableVector recipientInfos);
    public Stream Open(Stream outStream, string encryptionOid);
    public Stream Open(Stream outStream, string encryptionOid, int keySize);
}
public abstract class Org.BouncyCastle.Cms.CmsEnvelopedGenerator : object {
    internal static Int16[] rc2Table;
    public static string DesCbc;
    public static string DesEde3Cbc;
    public static string RC2Cbc;
    public static string IdeaCbc;
    public static string Cast5Cbc;
    public static string Aes128Cbc;
    public static string Aes192Cbc;
    public static string Aes256Cbc;
    public static string Aes128Ccm;
    public static string Aes192Ccm;
    public static string Aes256Ccm;
    public static string Aes128Gcm;
    public static string Aes192Gcm;
    public static string Aes256Gcm;
    public static string Camellia128Cbc;
    public static string Camellia192Cbc;
    public static string Camellia256Cbc;
    public static string SeedCbc;
    public static string DesEde3Wrap;
    public static string Aes128Wrap;
    public static string Aes192Wrap;
    public static string Aes256Wrap;
    public static string Camellia128Wrap;
    public static string Camellia192Wrap;
    public static string Camellia256Wrap;
    public static string SeedWrap;
    public static string ECDHSha1Kdf;
    public static string ECMqvSha1Kdf;
    internal IList`1<RecipientInfoGenerator> recipientInfoGenerators;
    internal SecureRandom m_random;
    internal CmsAttributeTableGenerator unprotectedAttributeGenerator;
    public CmsAttributeTableGenerator UnprotectedAttributeGenerator { get; public set; }
    protected CmsEnvelopedGenerator(SecureRandom random);
    private static CmsEnvelopedGenerator();
    public CmsAttributeTableGenerator get_UnprotectedAttributeGenerator();
    public void set_UnprotectedAttributeGenerator(CmsAttributeTableGenerator value);
    public void AddKeyTransRecipient(X509Certificate cert);
    public void AddKeyTransRecipient(AsymmetricKeyParameter pubKey, Byte[] subKeyId);
    public void AddKekRecipient(string keyAlgorithm, KeyParameter key, Byte[] keyIdentifier);
    public void AddKekRecipient(string keyAlgorithm, KeyParameter key, KekIdentifier kekIdentifier);
    public void AddPasswordRecipient(CmsPbeKey pbeKey, string kekAlgorithmOid);
    public void AddKeyAgreementRecipient(string agreementAlgorithm, AsymmetricKeyParameter senderPrivateKey, AsymmetricKeyParameter senderPublicKey, X509Certificate recipientCert, string cekWrapAlgorithm);
    public void AddKeyAgreementRecipients(string agreementAlgorithm, AsymmetricKeyParameter senderPrivateKey, AsymmetricKeyParameter senderPublicKey, IEnumerable`1<X509Certificate> recipientCerts, string cekWrapAlgorithm);
    public void AddKeyAgreementRecipient(string agreementAlgorithm, AsymmetricKeyParameter senderPrivateKey, AsymmetricKeyParameter senderPublicKey, Byte[] recipientKeyID, AsymmetricKeyParameter recipientPublicKey, string cekWrapAlgorithm);
    public void AddRecipientInfoGenerator(RecipientInfoGenerator recipientInfoGenerator);
    protected internal virtual AlgorithmIdentifier GetAlgorithmIdentifier(string encryptionOid, KeyParameter encKey, Asn1Encodable asn1Params, ICipherParameters& cipherParameters);
    protected internal virtual Asn1Encodable GenerateAsn1Parameters(string encryptionOid, Byte[] encKeyBytes);
}
internal class Org.BouncyCastle.Cms.CmsEnvelopedHelper : object {
    internal static CmsEnvelopedHelper Instance;
    private static Dictionary`2<string, int> KeySizes;
    private static Dictionary`2<string, string> Rfc3211WrapperNames;
    private static CmsEnvelopedHelper();
    internal static RecipientInformationStore BuildRecipientInformationStore(Asn1Set recipientInfos, CmsSecureReadable secureReadable);
    internal int GetKeySize(string oid);
    internal string GetRfc3211WrapperName(string oid);
    private static void ReadRecipientInfo(IList`1<RecipientInformation> infos, RecipientInfo info, CmsSecureReadable secureReadable);
}
public class Org.BouncyCastle.Cms.CmsException : Exception {
    public CmsException(string message);
    public CmsException(string message, Exception innerException);
    protected CmsException(SerializationInfo info, StreamingContext context);
}
public abstract class Org.BouncyCastle.Cms.CmsPbeKey : object {
    internal Char[] password;
    internal Byte[] salt;
    internal int iterationCount;
    public Byte[] Salt { get; }
    public int IterationCount { get; }
    public string Algorithm { get; }
    public string Format { get; }
    public CmsPbeKey(Char[] password, Byte[] salt, int iterationCount);
    public CmsPbeKey(Char[] password, AlgorithmIdentifier keyDerivationAlgorithm);
    protected virtual override void Finalize();
    public Byte[] get_Salt();
    public int get_IterationCount();
    public string get_Algorithm();
    public string get_Format();
    public Byte[] GetEncoded();
    internal abstract virtual KeyParameter GetEncoded(string algorithmOid);
}
public interface Org.BouncyCastle.Cms.CmsProcessable {
    public abstract virtual void Write(Stream outStream);
}
public class Org.BouncyCastle.Cms.CmsProcessableByteArray : object {
    private DerObjectIdentifier type;
    private Byte[] bytes;
    public DerObjectIdentifier Type { get; }
    public CmsProcessableByteArray(Byte[] bytes);
    public CmsProcessableByteArray(DerObjectIdentifier type, Byte[] bytes);
    public DerObjectIdentifier get_Type();
    public virtual Stream GetInputStream();
    public virtual void Write(Stream zOut);
}
public class Org.BouncyCastle.Cms.CmsProcessableFile : object {
    private static int DefaultBufSize;
    private FileInfo _file;
    private int _bufSize;
    public CmsProcessableFile(FileInfo file);
    public CmsProcessableFile(FileInfo file, int bufSize);
    public virtual Stream GetInputStream();
    public virtual void Write(Stream zOut);
}
public class Org.BouncyCastle.Cms.CmsProcessableInputStream : object {
    private Stream input;
    private bool used;
    public CmsProcessableInputStream(Stream input);
    public virtual Stream GetInputStream();
    public virtual void Write(Stream output);
    protected virtual void CheckSingleUsage();
}
public interface Org.BouncyCastle.Cms.CmsReadable {
    public abstract virtual Stream GetInputStream();
}
internal interface Org.BouncyCastle.Cms.CmsSecureReadable {
    public AlgorithmIdentifier Algorithm { get; }
    public object CryptoObject { get; }
    public abstract virtual AlgorithmIdentifier get_Algorithm();
    public abstract virtual object get_CryptoObject();
    public abstract virtual CmsReadable GetReadable(KeyParameter key);
}
public class Org.BouncyCastle.Cms.CmsSignedData : object {
    private static CmsSignedHelper Helper;
    private CmsProcessable signedContent;
    private SignedData signedData;
    private ContentInfo contentInfo;
    private SignerInformationStore signerInfoStore;
    private IDictionary`2<string, Byte[]> m_hashes;
    public int Version { get; }
    public DerObjectIdentifier SignedContentType { get; }
    public CmsProcessable SignedContent { get; }
    public ContentInfo ContentInfo { get; }
    private CmsSignedData(CmsSignedData c);
    public CmsSignedData(Byte[] sigBlock);
    public CmsSignedData(CmsProcessable signedContent, Byte[] sigBlock);
    public CmsSignedData(IDictionary`2<string, Byte[]> hashes, Byte[] sigBlock);
    public CmsSignedData(CmsProcessable signedContent, Stream sigData);
    public CmsSignedData(Stream sigData);
    public CmsSignedData(CmsProcessable signedContent, ContentInfo sigData);
    public CmsSignedData(IDictionary`2<string, Byte[]> hashes, ContentInfo sigData);
    public CmsSignedData(ContentInfo sigData);
    private static CmsSignedData();
    public int get_Version();
    public SignerInformationStore GetSignerInfos();
    public IStore`1<X509V2AttributeCertificate> GetAttributeCertificates();
    public IStore`1<X509Certificate> GetCertificates();
    public IStore`1<X509Crl> GetCrls();
    public IStore`1<Asn1Encodable> GetOtherRevInfos(DerObjectIdentifier otherRevInfoFormat);
    public DerObjectIdentifier get_SignedContentType();
    public CmsProcessable get_SignedContent();
    public ContentInfo get_ContentInfo();
    public Byte[] GetEncoded();
    public Byte[] GetEncoded(string encoding);
    public static CmsSignedData ReplaceSigners(CmsSignedData signedData, SignerInformationStore signerInformationStore);
    public static CmsSignedData ReplaceCertificatesAndCrls(CmsSignedData signedData, IStore`1<X509Certificate> x509Certs, IStore`1<X509Crl> x509Crls);
    public static CmsSignedData ReplaceCertificatesAndCrls(CmsSignedData signedData, IStore`1<X509Certificate> x509Certs, IStore`1<X509Crl> x509Crls, IStore`1<X509V2AttributeCertificate> x509AttrCerts);
    public static CmsSignedData ReplaceCertificatesAndRevocations(CmsSignedData signedData, IStore`1<X509Certificate> x509Certs, IStore`1<X509Crl> x509Crls, IStore`1<X509V2AttributeCertificate> x509AttrCerts, IStore`1<OtherRevocationInfoFormat> otherRevocationInfos);
}
public class Org.BouncyCastle.Cms.CmsSignedDataGenerator : CmsSignedGenerator {
    private static CmsSignedHelper Helper;
    private IList`1<SignerInf> signerInfs;
    public CmsSignedDataGenerator(SecureRandom random);
    private static CmsSignedDataGenerator();
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSignerInfoGenerator(SignerInfoGenerator signerInfoGenerator);
    private void doAddSigner(AsymmetricKeyParameter privateKey, SignerIdentifier signerIdentifier, string encryptionOID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen, AttributeTable baseSignedTable);
    public CmsSignedData Generate(CmsProcessable content);
    public CmsSignedData Generate(string signedContentType, CmsProcessable content, bool encapsulate);
    public CmsSignedData Generate(CmsProcessable content, bool encapsulate);
    public SignerInformationStore GenerateCounterSigners(SignerInformation signer);
}
public class Org.BouncyCastle.Cms.CmsSignedDataParser : CmsContentInfoParser {
    private static CmsSignedHelper Helper;
    private SignedDataParser _signedData;
    private DerObjectIdentifier _signedContentType;
    private CmsTypedStream _signedContent;
    private IDictionary`2<string, IDigest> m_digests;
    private HashSet`1<string> _digestOids;
    private SignerInformationStore _signerInfoStore;
    private Asn1Set _certSet;
    private Asn1Set _crlSet;
    private bool _isCertCrlParsed;
    public int Version { get; }
    public ISet`1<string> DigestOids { get; }
    public DerObjectIdentifier SignedContentType { get; }
    public CmsSignedDataParser(Byte[] sigBlock);
    public CmsSignedDataParser(CmsTypedStream signedContent, Byte[] sigBlock);
    public CmsSignedDataParser(Stream sigData);
    public CmsSignedDataParser(CmsTypedStream signedContent, Stream sigData);
    private static CmsSignedDataParser();
    public int get_Version();
    public ISet`1<string> get_DigestOids();
    public SignerInformationStore GetSignerInfos();
    public IStore`1<X509V2AttributeCertificate> GetAttributeCertificates();
    public IStore`1<X509Certificate> GetCertificates();
    public IStore`1<X509Crl> GetCrls();
    public IStore`1<Asn1Encodable> GetOtherRevInfos(DerObjectIdentifier otherRevInfoFormat);
    private void PopulateCertCrlSets();
    public DerObjectIdentifier get_SignedContentType();
    public CmsTypedStream GetSignedContent();
    public static Stream ReplaceSigners(Stream original, SignerInformationStore signerInformationStore, Stream outStr);
    public static Stream ReplaceCertificatesAndCrls(Stream original, IStore`1<X509Certificate> x509Certs, IStore`1<X509Crl> x509Crls, IStore`1<X509V2AttributeCertificate> x509AttrCerts, Stream outStr);
    private static Asn1Set GetAsn1Set(Asn1SetParser asn1SetParser);
}
public class Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator : CmsSignedGenerator {
    private static CmsSignedHelper Helper;
    private IList`1<DigestAndSignerInfoGeneratorHolder> _signerInfs;
    private HashSet`1<string> _messageDigestOids;
    private IDictionary`2<string, IDigest> m_messageDigests;
    private IDictionary`2<string, Byte[]> m_messageHashes;
    private bool _messageDigestsLocked;
    private int _bufferSize;
    public CmsSignedDataStreamGenerator(SecureRandom random);
    private static CmsSignedDataStreamGenerator();
    public void SetBufferSize(int bufferSize);
    public void AddDigests(String[] digestOids);
    public void AddDigests(IEnumerable`1<string> digestOids);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOid, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOid, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOid, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOid, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOid, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    private void DoAddSigner(AsymmetricKeyParameter privateKey, SignerIdentifier signerIdentifier, string encryptionOid, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    internal virtual void AddSignerCallback(SignerInformation si);
    public Stream Open(Stream outStream);
    public Stream Open(Stream outStream, bool encapsulate);
    public Stream Open(Stream outStream, bool encapsulate, Stream dataOutputStream);
    public Stream Open(Stream outStream, string signedContentType, bool encapsulate);
    public Stream Open(Stream outStream, string signedContentType, bool encapsulate, Stream dataOutputStream);
    private void RegisterDigestOid(string digestOid);
    private void ConfigureDigest(string digestOid);
    internal void Generate(Stream outStream, string eContentType, bool encapsulate, Stream dataOutputStream, CmsProcessable content);
    private DerInteger CalculateVersion(DerObjectIdentifier contentOid);
    private bool CheckForVersion3(IList`1<SignerInformation> signerInfos);
    private static Stream AttachDigestsToOutputStream(IEnumerable`1<IDigest> digests, Stream s);
    private static Stream GetSafeOutputStream(Stream s);
    private static Stream GetSafeTeeOutputStream(Stream s1, Stream s2);
}
public abstract class Org.BouncyCastle.Cms.CmsSignedGenerator : object {
    public static string Data;
    public static string DigestSha1;
    public static string DigestSha224;
    public static string DigestSha256;
    public static string DigestSha384;
    public static string DigestSha512;
    public static string DigestSha512_224;
    public static string DigestSha512_256;
    public static string DigestMD5;
    public static string DigestGost3411;
    public static string DigestRipeMD128;
    public static string DigestRipeMD160;
    public static string DigestRipeMD256;
    public static string EncryptionRsa;
    public static string EncryptionDsa;
    public static string EncryptionECDsa;
    public static string EncryptionRsaPss;
    public static string EncryptionGost3410;
    public static string EncryptionECGost3410;
    public static string EncryptionECGost3410_2012_256;
    public static string EncryptionECGost3410_2012_512;
    internal List`1<Asn1Encodable> _certs;
    internal List`1<Asn1Encodable> _crls;
    internal IList`1<SignerInformation> _signers;
    internal IDictionary`2<string, Byte[]> m_digests;
    internal bool _useDerForCerts;
    internal bool _useDerForCrls;
    protected SecureRandom m_random;
    public bool UseDerForCerts { get; public set; }
    public bool UseDerForCrls { get; public set; }
    protected CmsSignedGenerator(SecureRandom random);
    private static CmsSignedGenerator();
    protected internal virtual IDictionary`2<CmsAttributeTableParameter, object> GetBaseParameters(DerObjectIdentifier contentType, AlgorithmIdentifier digAlgId, Byte[] hash);
    protected internal virtual Asn1Set GetAttributeSet(AttributeTable attr);
    public void AddAttributeCertificate(X509V2AttributeCertificate attrCert);
    public void AddAttributeCertificates(IStore`1<X509V2AttributeCertificate> attrCertStore);
    public void AddCertificate(X509Certificate cert);
    public void AddCertificates(IStore`1<X509Certificate> certStore);
    public void AddCrl(X509Crl crl);
    public void AddCrls(IStore`1<X509Crl> crlStore);
    public void AddOtherRevocationInfo(OtherRevocationInfoFormat otherRevocationInfo);
    public void AddOtherRevocationInfos(IStore`1<OtherRevocationInfoFormat> otherRevocationInfoStore);
    public void AddOtherRevocationInfos(DerObjectIdentifier otherRevInfoFormat, IStore`1<Asn1Encodable> otherRevInfoStore);
    public void AddSigners(SignerInformationStore signerStore);
    public IDictionary`2<string, Byte[]> GetGeneratedDigests();
    public bool get_UseDerForCerts();
    public void set_UseDerForCerts(bool value);
    public bool get_UseDerForCrls();
    public void set_UseDerForCrls(bool value);
    internal virtual void AddSignerCallback(SignerInformation si);
    internal static SignerIdentifier GetSignerIdentifier(X509Certificate cert);
    internal static SignerIdentifier GetSignerIdentifier(Byte[] subjectKeyIdentifier);
}
internal class Org.BouncyCastle.Cms.CmsSignedHelper : object {
    internal static CmsSignedHelper Instance;
    private static string EncryptionECDsaWithSha1;
    private static string EncryptionECDsaWithSha224;
    private static string EncryptionECDsaWithSha256;
    private static string EncryptionECDsaWithSha384;
    private static string EncryptionECDsaWithSha512;
    private static IDictionary`2<string, string> m_encryptionAlgs;
    private static IDictionary`2<string, string> m_digestAlgs;
    private static IDictionary`2<string, String[]> m_digestAliases;
    private static HashSet`1<string> m_noParams;
    private static IDictionary`2<string, string> m_ecAlgorithms;
    private static CmsSignedHelper();
    private static void AddEntries(DerObjectIdentifier oid, string digest, string encryption);
    internal string GetDigestAlgName(string digestAlgOid);
    internal AlgorithmIdentifier GetEncAlgorithmIdentifier(DerObjectIdentifier encOid, Asn1Encodable sigX509Parameters);
    internal String[] GetDigestAliases(string algName);
    internal string GetEncryptionAlgName(string encryptionAlgOid);
    internal IDigest GetDigestInstance(string algorithm);
    internal ISigner GetSignatureInstance(string algorithm);
    internal AlgorithmIdentifier FixAlgID(AlgorithmIdentifier algId);
    internal string GetEncOid(AsymmetricKeyParameter key, string digestOID);
    internal IStore`1<X509V2AttributeCertificate> GetAttributeCertificates(Asn1Set attrCertSet);
    internal IStore`1<X509Certificate> GetCertificates(Asn1Set certSet);
    internal IStore`1<X509Crl> GetCrls(Asn1Set crlSet);
    internal IStore`1<Asn1Encodable> GetOtherRevInfos(Asn1Set crlSet, DerObjectIdentifier otherRevInfoFormat);
}
public class Org.BouncyCastle.Cms.CmsStreamException : IOException {
    public CmsStreamException(string message);
    public CmsStreamException(string message, Exception innerException);
    protected CmsStreamException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Cms.CmsTypedStream : object {
    private string m_oid;
    private Stream m_in;
    public string ContentType { get; }
    public Stream ContentStream { get; }
    public CmsTypedStream(Stream inStream);
    public CmsTypedStream(string oid, Stream inStream);
    public CmsTypedStream(string oid, Stream inStream, int bufSize);
    public string get_ContentType();
    public Stream get_ContentStream();
    public void Drain();
}
internal static class Org.BouncyCastle.Cms.CmsUtilities : object {
    internal static int MaximumMemory { get; }
    internal static int get_MaximumMemory();
    internal static ContentInfo ReadContentInfo(Byte[] input);
    internal static ContentInfo ReadContentInfo(Stream input);
    private static ContentInfo ReadContentInfo(Asn1InputStream asn1In);
    internal static Byte[] StreamToByteArray(Stream inStream);
    internal static Byte[] StreamToByteArray(Stream inStream, int limit);
    internal static List`1<Asn1TaggedObject> GetAttributeCertificatesFromStore(IStore`1<X509V2AttributeCertificate> attrCertStore);
    internal static List`1<X509CertificateStructure> GetCertificatesFromStore(IStore`1<X509Certificate> certStore);
    internal static List`1<CertificateList> GetCrlsFromStore(IStore`1<X509Crl> crlStore);
    internal static List`1<Asn1TaggedObject> GetOtherRevocationInfosFromStore(IStore`1<OtherRevocationInfoFormat> otherRevocationInfoStore);
    internal static List`1<DerTaggedObject> GetOtherRevocationInfosFromStore(IStore`1<Asn1Encodable> otherRevInfoStore, DerObjectIdentifier otherRevInfoFormat);
    internal static Asn1Set CreateBerSetFromList(IEnumerable`1<Asn1Encodable> elements);
    internal static Asn1Set CreateDerSetFromList(IEnumerable`1<Asn1Encodable> elements);
    internal static TbsCertificateStructure GetTbsCertificateStructure(X509Certificate cert);
    internal static IssuerAndSerialNumber GetIssuerAndSerialNumber(X509Certificate cert);
    internal static AttributeTable ParseAttributeTable(Asn1SetParser parser);
    internal static void ValidateOtherRevocationInfo(OtherRevocationInfoFormat otherRevocationInfo);
}
public class Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator : object {
    private IDictionary`2<DerObjectIdentifier, object> m_table;
    public DefaultAuthenticatedAttributeTableGenerator(AttributeTable attributeTable);
    protected virtual IDictionary`2<DerObjectIdentifier, object> CreateStandardAttributeTable(IDictionary`2<CmsAttributeTableParameter, object> parameters);
    public virtual AttributeTable GetAttributes(IDictionary`2<CmsAttributeTableParameter, object> parameters);
}
public class Org.BouncyCastle.Cms.DefaultDigestAlgorithmIdentifierFinder : object {
    private static IDictionary`2<DerObjectIdentifier, DerObjectIdentifier> m_digestOids;
    private static IDictionary`2<string, DerObjectIdentifier> m_digestNameToOids;
    private static DefaultDigestAlgorithmIdentifierFinder();
    public AlgorithmIdentifier Find(AlgorithmIdentifier sigAlgId);
    public AlgorithmIdentifier Find(string digAlgName);
}
public class Org.BouncyCastle.Cms.DefaultSignatureAlgorithmIdentifierFinder : object {
    private static IDictionary`2<string, DerObjectIdentifier> m_algorithms;
    private static HashSet`1<DerObjectIdentifier> noParams;
    private static IDictionary`2<string, Asn1Encodable> m_params;
    private static HashSet`1<DerObjectIdentifier> pkcs15RsaEncryption;
    private static IDictionary`2<DerObjectIdentifier, DerObjectIdentifier> m_digestOids;
    private static DefaultSignatureAlgorithmIdentifierFinder();
    private static AlgorithmIdentifier Generate(string signatureAlgorithm);
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    public AlgorithmIdentifier Find(string sigAlgName);
}
public class Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator : object {
    private IDictionary`2<DerObjectIdentifier, object> m_table;
    public DefaultSignedAttributeTableGenerator(AttributeTable attributeTable);
    protected virtual IDictionary`2<DerObjectIdentifier, object> CreateStandardAttributeTable(IDictionary`2<CmsAttributeTableParameter, object> parameters);
    private void DoCreateStandardAttributeTable(IDictionary`2<CmsAttributeTableParameter, object> parameters, IDictionary`2<DerObjectIdentifier, object> std);
    public virtual AttributeTable GetAttributes(IDictionary`2<CmsAttributeTableParameter, object> parameters);
}
internal class Org.BouncyCastle.Cms.EnvelopedDataHelper : object {
    public static object CreateContentCipher(bool forEncryption, ICipherParameters encKey, AlgorithmIdentifier encryptionAlgID);
    public AlgorithmIdentifier GenerateEncryptionAlgID(DerObjectIdentifier encryptionOID, KeyParameter encKey, SecureRandom random);
    public CipherKeyGenerator CreateKeyGenerator(DerObjectIdentifier algorithm, SecureRandom random);
}
internal interface Org.BouncyCastle.Cms.ISignerInfoGenerator {
    public abstract virtual SignerInfo Generate(DerObjectIdentifier contentType, AlgorithmIdentifier digestAlgorithm, Byte[] calculatedDigest);
}
internal class Org.BouncyCastle.Cms.KekRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private KeyParameter keyEncryptionKey;
    private string keyEncryptionKeyOID;
    private KekIdentifier kekIdentifier;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    unknown KekIdentifier KekIdentifier {internal set; }
    unknown KeyParameter KeyEncryptionKey {internal set; }
    unknown string KeyEncryptionKeyOID {internal set; }
    private static KekRecipientInfoGenerator();
    internal void set_KekIdentifier(KekIdentifier value);
    internal void set_KeyEncryptionKey(KeyParameter value);
    internal void set_KeyEncryptionKeyOID(string value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
    private static AlgorithmIdentifier DetermineKeyEncAlg(string algorithm, KeyParameter key);
}
public class Org.BouncyCastle.Cms.KekRecipientInformation : RecipientInformation {
    private KekRecipientInfo info;
    internal KekRecipientInformation(KekRecipientInfo info, CmsSecureReadable secureReadable);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
internal class Org.BouncyCastle.Cms.KeyAgreeRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private List`1<KeyAgreeRecipientIdentifier> m_recipientIDs;
    private List`1<AsymmetricKeyParameter> m_recipientKeys;
    private DerObjectIdentifier m_keyAgreementOid;
    private DerObjectIdentifier m_keyEncryptionOid;
    private AsymmetricCipherKeyPair m_senderKeyPair;
    unknown DerObjectIdentifier KeyAgreementOid {internal set; }
    unknown DerObjectIdentifier KeyEncryptionOid {internal set; }
    unknown AsymmetricCipherKeyPair SenderKeyPair {internal set; }
    internal KeyAgreeRecipientInfoGenerator(IEnumerable`1<X509Certificate> recipientCerts);
    internal KeyAgreeRecipientInfoGenerator(Byte[] subjectKeyID, AsymmetricKeyParameter publicKey);
    private static KeyAgreeRecipientInfoGenerator();
    internal void set_KeyAgreementOid(DerObjectIdentifier value);
    internal void set_KeyEncryptionOid(DerObjectIdentifier value);
    internal void set_SenderKeyPair(AsymmetricCipherKeyPair value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
    private static OriginatorPublicKey CreateOriginatorPublicKey(AsymmetricKeyParameter publicKey);
}
public class Org.BouncyCastle.Cms.KeyAgreeRecipientInformation : RecipientInformation {
    private KeyAgreeRecipientInfo info;
    private Asn1OctetString encryptedKey;
    internal KeyAgreeRecipientInformation(KeyAgreeRecipientInfo info, RecipientID rid, Asn1OctetString encryptedKey, CmsSecureReadable secureReadable);
    internal static void ReadRecipientInfo(IList`1<RecipientInformation> infos, KeyAgreeRecipientInfo info, CmsSecureReadable secureReadable);
    private AsymmetricKeyParameter GetSenderPublicKey(AsymmetricKeyParameter receiverPrivateKey, OriginatorIdentifierOrKey originator);
    private AsymmetricKeyParameter GetPublicKeyFromOriginatorPublicKey(AsymmetricKeyParameter receiverPrivateKey, OriginatorPublicKey originatorPublicKey);
    private AsymmetricKeyParameter GetPublicKeyFromOriginatorID(OriginatorID origID);
    private KeyParameter CalculateAgreedWrapKey(string wrapAlg, AsymmetricKeyParameter senderPublicKey, AsymmetricKeyParameter receiverPrivateKey);
    private KeyParameter UnwrapSessionKey(string wrapAlg, KeyParameter agreedKey);
    internal KeyParameter GetSessionKey(AsymmetricKeyParameter receiverPrivateKey);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.KeyTransRecipientInfoGenerator : object {
    private IKeyWrapper m_keyWrapper;
    private IssuerAndSerialNumber m_issuerAndSerialNumber;
    private Asn1OctetString m_subjectKeyIdentifier;
    protected AlgorithmIdentifier AlgorithmDetails { get; }
    public KeyTransRecipientInfoGenerator(X509Certificate recipCert, IKeyWrapper keyWrapper);
    public KeyTransRecipientInfoGenerator(IssuerAndSerialNumber issuerAndSerial, IKeyWrapper keyWrapper);
    public KeyTransRecipientInfoGenerator(Byte[] subjectKeyID, IKeyWrapper keyWrapper);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
    protected virtual AlgorithmIdentifier get_AlgorithmDetails();
    protected virtual Byte[] GenerateWrappedKey(KeyParameter contentEncryptionKey);
}
public class Org.BouncyCastle.Cms.KeyTransRecipientInformation : RecipientInformation {
    private KeyTransRecipientInfo info;
    internal KeyTransRecipientInformation(KeyTransRecipientInfo info, CmsSecureReadable secureReadable);
    private string GetExchangeEncryptionAlgorithmName(AlgorithmIdentifier algo);
    internal KeyParameter UnwrapKey(ICipherParameters key);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.OriginatorID : X509CertStoreSelector {
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Org.BouncyCastle.Cms.OriginatorInfoGenerator : object {
    private List`1<Asn1Encodable> origCerts;
    private List`1<Asn1Encodable> origCrls;
    public OriginatorInfoGenerator(X509Certificate origCert);
    public OriginatorInfoGenerator(IStore`1<X509Certificate> x509Certs);
    public OriginatorInfoGenerator(IStore`1<X509Certificate> x509Certs, IStore`1<X509Crl> x509Crls);
    public OriginatorInfoGenerator(IStore`1<X509Certificate> x509Certs, IStore`1<X509Crl> x509Crls, IStore`1<X509V2AttributeCertificate> x509AttrCerts, IStore`1<OtherRevocationInfoFormat> otherRevocationInfos);
    public virtual OriginatorInfo Generate();
}
public class Org.BouncyCastle.Cms.OriginatorInformation : object {
    private OriginatorInfo originatorInfo;
    public OriginatorInformation(OriginatorInfo originatorInfo);
    public virtual IStore`1<X509Certificate> GetCertificates();
    public virtual IStore`1<X509Crl> GetCrls();
    public virtual OriginatorInfo ToAsn1Structure();
}
internal class Org.BouncyCastle.Cms.PasswordRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private AlgorithmIdentifier keyDerivationAlgorithm;
    private KeyParameter keyEncryptionKey;
    private string keyEncryptionKeyOID;
    unknown AlgorithmIdentifier KeyDerivationAlgorithm {internal set; }
    unknown KeyParameter KeyEncryptionKey {internal set; }
    unknown string KeyEncryptionKeyOID {internal set; }
    private static PasswordRecipientInfoGenerator();
    internal void set_KeyDerivationAlgorithm(AlgorithmIdentifier value);
    internal void set_KeyEncryptionKey(KeyParameter value);
    internal void set_KeyEncryptionKeyOID(string value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
}
public class Org.BouncyCastle.Cms.PasswordRecipientInformation : RecipientInformation {
    private PasswordRecipientInfo info;
    public AlgorithmIdentifier KeyDerivationAlgorithm { get; }
    internal PasswordRecipientInformation(PasswordRecipientInfo info, CmsSecureReadable secureReadable);
    public virtual AlgorithmIdentifier get_KeyDerivationAlgorithm();
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.Pkcs5Scheme2PbeKey : CmsPbeKey {
    public Pkcs5Scheme2PbeKey(Char[] password, Byte[] salt, int iterationCount);
    public Pkcs5Scheme2PbeKey(Char[] password, AlgorithmIdentifier keyDerivationAlgorithm);
    internal virtual KeyParameter GetEncoded(string algorithmOid);
}
public class Org.BouncyCastle.Cms.Pkcs5Scheme2Utf8PbeKey : CmsPbeKey {
    public Pkcs5Scheme2Utf8PbeKey(Char[] password, Byte[] salt, int iterationCount);
    public Pkcs5Scheme2Utf8PbeKey(Char[] password, AlgorithmIdentifier keyDerivationAlgorithm);
    internal virtual KeyParameter GetEncoded(string algorithmOid);
}
public class Org.BouncyCastle.Cms.RecipientID : X509CertStoreSelector {
    private Byte[] keyIdentifier;
    public Byte[] KeyIdentifier { get; public set; }
    public Byte[] get_KeyIdentifier();
    public void set_KeyIdentifier(Byte[] value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public interface Org.BouncyCastle.Cms.RecipientInfoGenerator {
    public abstract virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
}
public abstract class Org.BouncyCastle.Cms.RecipientInformation : object {
    internal RecipientID rid;
    internal AlgorithmIdentifier keyEncAlg;
    internal CmsSecureReadable secureReadable;
    private Byte[] resultMac;
    public RecipientID RecipientID { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithmID { get; }
    public string KeyEncryptionAlgOid { get; }
    public Asn1Object KeyEncryptionAlgParams { get; }
    internal RecipientInformation(AlgorithmIdentifier keyEncAlg, CmsSecureReadable secureReadable);
    internal string GetContentAlgorithmName();
    public RecipientID get_RecipientID();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithmID();
    public string get_KeyEncryptionAlgOid();
    public Asn1Object get_KeyEncryptionAlgParams();
    internal CmsTypedStream GetContentFromSessionKey(KeyParameter sKey);
    public Byte[] GetContent(ICipherParameters key);
    public Byte[] GetMac();
    public abstract virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Cms.RecipientInformationStore : object {
    private IList`1<RecipientInformation> m_all;
    private IDictionary`2<RecipientID, IList`1<RecipientInformation>> m_table;
    public RecipientInformation Item { get; }
    public int Count { get; }
    public RecipientInformationStore(IEnumerable`1<RecipientInformation> recipientInfos);
    public RecipientInformation get_Item(RecipientID selector);
    public RecipientInformation GetFirstRecipient(RecipientID selector);
    public int get_Count();
    public IList`1<RecipientInformation> GetRecipients();
    public IList`1<RecipientInformation> GetRecipients(RecipientID selector);
}
public class Org.BouncyCastle.Cms.SignerID : X509CertStoreSelector {
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Org.BouncyCastle.Cms.SignerInfoGenerator : object {
    internal X509Certificate certificate;
    internal ISignatureFactory contentSigner;
    internal SignerIdentifier sigId;
    internal CmsAttributeTableGenerator signedGen;
    internal CmsAttributeTableGenerator unsignedGen;
    private bool isDirectSignature;
    internal SignerInfoGenerator(SignerIdentifier sigId, ISignatureFactory signerFactory);
    internal SignerInfoGenerator(SignerIdentifier sigId, ISignatureFactory signerFactory, bool isDirectSignature);
    internal SignerInfoGenerator(SignerIdentifier sigId, ISignatureFactory contentSigner, CmsAttributeTableGenerator signedGen, CmsAttributeTableGenerator unsignedGen);
    internal void SetAssociatedCertificate(X509Certificate certificate);
    public SignerInfoGeneratorBuilder NewBuilder();
}
public class Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder : object {
    private bool directSignature;
    private CmsAttributeTableGenerator signedGen;
    private CmsAttributeTableGenerator unsignedGen;
    public SignerInfoGeneratorBuilder SetDirectSignature(bool hasNoSignedAttributes);
    public SignerInfoGeneratorBuilder WithSignedAttributeGenerator(CmsAttributeTableGenerator signedGen);
    public SignerInfoGeneratorBuilder WithUnsignedAttributeGenerator(CmsAttributeTableGenerator unsignedGen);
    public SignerInfoGenerator Build(ISignatureFactory contentSigner, X509Certificate certificate);
    public SignerInfoGenerator Build(ISignatureFactory signerFactory, Byte[] subjectKeyIdentifier);
    private SignerInfoGenerator CreateGenerator(ISignatureFactory contentSigner, SignerIdentifier sigId);
}
public class Org.BouncyCastle.Cms.SignerInformation : object {
    private static CmsSignedHelper Helper;
    private SignerID sid;
    private CmsProcessable content;
    private Byte[] signature;
    private DerObjectIdentifier contentType;
    private Byte[] calculatedDigest;
    private Byte[] resultDigest;
    private AttributeTable signedAttributeTable;
    private AttributeTable unsignedAttributeTable;
    private bool isCounterSignature;
    protected SignerInfo info;
    protected AlgorithmIdentifier digestAlgorithm;
    protected AlgorithmIdentifier encryptionAlgorithm;
    protected Asn1Set signedAttributeSet;
    protected Asn1Set unsignedAttributeSet;
    public bool IsCounterSignature { get; }
    public DerObjectIdentifier ContentType { get; }
    public SignerID SignerID { get; }
    public int Version { get; }
    public AlgorithmIdentifier DigestAlgorithmID { get; }
    public string DigestAlgOid { get; }
    public Asn1Object DigestAlgParams { get; }
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public Asn1Object EncryptionAlgParams { get; }
    public AttributeTable SignedAttributes { get; }
    public AttributeTable UnsignedAttributes { get; }
    internal SignerInformation(SignerInfo info, DerObjectIdentifier contentType, CmsProcessable content, Byte[] calculatedDigest);
    protected SignerInformation(SignerInformation baseInfo);
    private static SignerInformation();
    public bool get_IsCounterSignature();
    public DerObjectIdentifier get_ContentType();
    public SignerID get_SignerID();
    public int get_Version();
    public AlgorithmIdentifier get_DigestAlgorithmID();
    public string get_DigestAlgOid();
    public Asn1Object get_DigestAlgParams();
    public Byte[] GetContentDigest();
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public Asn1Object get_EncryptionAlgParams();
    public AttributeTable get_SignedAttributes();
    public AttributeTable get_UnsignedAttributes();
    public Byte[] GetSignature();
    public SignerInformationStore GetCounterSignatures();
    public virtual Byte[] GetEncodedSignedAttributes();
    private bool DoVerify(AsymmetricKeyParameter key);
    private bool IsNull(Asn1Encodable o);
    private DigestInfo DerDecode(Byte[] encoding);
    private bool VerifyDigest(Byte[] digest, AsymmetricKeyParameter key, Byte[] signature);
    public bool Verify(AsymmetricKeyParameter pubKey);
    public bool Verify(X509Certificate cert);
    public SignerInfo ToSignerInfo();
    private Asn1Object GetSingleValuedSignedAttribute(DerObjectIdentifier attrOID, string printableName);
    private Time GetSigningTime();
    public static SignerInformation ReplaceUnsignedAttributes(SignerInformation signerInformation, AttributeTable unsignedAttributes);
    public static SignerInformation AddCounterSigners(SignerInformation signerInformation, SignerInformationStore counterSigners);
}
public class Org.BouncyCastle.Cms.SignerInformationStore : object {
    private IList`1<SignerInformation> m_all;
    private IDictionary`2<SignerID, IList`1<SignerInformation>> m_table;
    public int Count { get; }
    public SignerInformationStore(SignerInformation signerInfo);
    public SignerInformationStore(IEnumerable`1<SignerInformation> signerInfos);
    public SignerInformation GetFirstSigner(SignerID selector);
    public int get_Count();
    public IList`1<SignerInformation> GetSigners();
    public IList`1<SignerInformation> GetSigners(SignerID selector);
}
public class Org.BouncyCastle.Cms.SimpleAttributeTableGenerator : object {
    private AttributeTable attributes;
    public SimpleAttributeTableGenerator(AttributeTable attributes);
    public virtual AttributeTable GetAttributes(IDictionary`2<CmsAttributeTableParameter, object> parameters);
}
public class Org.BouncyCastle.Crmf.AuthenticatorControl : object {
    private static DerObjectIdentifier type;
    private DerUtf8String token;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    public AuthenticatorControl(DerUtf8String token);
    public AuthenticatorControl(string token);
    private static AuthenticatorControl();
    public sealed virtual DerObjectIdentifier get_Type();
    public sealed virtual Asn1Encodable get_Value();
}
public class Org.BouncyCastle.Crmf.CertificateRequestMessage : object {
    public static int popRaVerified;
    public static int popSigningKey;
    public static int popKeyEncipherment;
    public static int popKeyAgreement;
    private CertReqMsg certReqMsg;
    private Controls controls;
    public bool HasControls { get; }
    public bool HasProofOfPossession { get; }
    public int ProofOfPossession { get; }
    public bool HasSigningKeyProofOfPossessionWithPkMac { get; }
    public CertificateRequestMessage(Byte[] encoded);
    public CertificateRequestMessage(CertReqMsg certReqMsg);
    private static CertificateRequestMessage();
    private static CertReqMsg ParseBytes(Byte[] encoding);
    public CertReqMsg ToAsn1Structure();
    public CertTemplate GetCertTemplate();
    public bool get_HasControls();
    public bool HasControl(DerObjectIdentifier objectIdentifier);
    public IControl GetControl(DerObjectIdentifier type);
    public AttributeTypeAndValue FindControl(DerObjectIdentifier type);
    public bool get_HasProofOfPossession();
    public int get_ProofOfPossession();
    public bool get_HasSigningKeyProofOfPossessionWithPkMac();
    public bool IsValidSigningKeyPop(IVerifierFactoryProvider verifierProvider);
    private bool VerifySignature(IVerifierFactoryProvider verifierFactoryProvider, PopoSigningKey signKey);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Crmf.CertificateRequestMessageBuilder : object {
    private BigInteger _certReqId;
    private X509ExtensionsGenerator _extGenerator;
    private CertTemplateBuilder _templateBuilder;
    private IList`1<IControl> m_controls;
    private ISignatureFactory _popSigner;
    private PKMacBuilder _pkMacBuilder;
    private Char[] _password;
    private GeneralName _sender;
    private int _popoType;
    private PopoPrivKey _popoPrivKey;
    private Asn1Null _popRaVerified;
    private PKMacValue _agreeMac;
    public CertificateRequestMessageBuilder(BigInteger certReqId);
    public CertificateRequestMessageBuilder SetPublicKey(SubjectPublicKeyInfo publicKeyInfo);
    public CertificateRequestMessageBuilder SetIssuer(X509Name issuer);
    public CertificateRequestMessageBuilder SetSubject(X509Name subject);
    public CertificateRequestMessageBuilder SetSerialNumber(BigInteger serialNumber);
    public CertificateRequestMessageBuilder SetValidity(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> notAfter);
    public CertificateRequestMessageBuilder AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable value);
    public CertificateRequestMessageBuilder AddExtension(DerObjectIdentifier oid, bool critical, Byte[] value);
    public CertificateRequestMessageBuilder AddControl(IControl control);
    public CertificateRequestMessageBuilder SetProofOfPossessionSignKeySigner(ISignatureFactory popoSignatureFactory);
    public CertificateRequestMessageBuilder SetProofOfPossessionSubsequentMessage(SubsequentMessage msg);
    public CertificateRequestMessageBuilder SetProofOfPossessionSubsequentMessage(int type, SubsequentMessage msg);
    public CertificateRequestMessageBuilder SetProofOfPossessionAgreeMac(PKMacValue macValue);
    public CertificateRequestMessageBuilder SetProofOfPossessionRaVerified();
    [ObsoleteAttribute("Use 'SetAuthInfoPKMacBuilder' instead")]
public CertificateRequestMessageBuilder SetAuthInfoPKMAC(PKMacBuilder pkmacFactory, Char[] password);
    public CertificateRequestMessageBuilder SetAuthInfoPKMacBuilder(PKMacBuilder pkmacFactory, Char[] password);
    public CertificateRequestMessageBuilder SetAuthInfoSender(X509Name sender);
    public CertificateRequestMessageBuilder SetAuthInfoSender(GeneralName sender);
    public CertificateRequestMessage Build();
    private static Time CreateTime(Nullable`1<DateTime> dateTime);
}
public class Org.BouncyCastle.Crmf.CrmfException : Exception {
    public CrmfException(string message);
    public CrmfException(string message, Exception innerException);
    protected CrmfException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Crmf.DefaultPKMacPrimitivesProvider : object {
    public sealed virtual IDigest CreateDigest(AlgorithmIdentifier digestAlg);
    public sealed virtual IMac CreateMac(AlgorithmIdentifier macAlg);
}
internal class Org.BouncyCastle.Crmf.DefaultPKMacResult : object {
    private IMac mac;
    public DefaultPKMacResult(IMac mac);
    public sealed virtual Byte[] Collect();
    public sealed virtual int Collect(Byte[] buf, int off);
    public sealed virtual int GetMaxResultLength();
}
public class Org.BouncyCastle.Crmf.EncryptedValueBuilder : object {
    private IKeyWrapper wrapper;
    private ICipherBuilderWithKey encryptor;
    private IEncryptedValuePadder padder;
    public EncryptedValueBuilder(IKeyWrapper wrapper, ICipherBuilderWithKey encryptor);
    public EncryptedValueBuilder(IKeyWrapper wrapper, ICipherBuilderWithKey encryptor, IEncryptedValuePadder padder);
    public EncryptedValue Build(Char[] revocationPassphrase);
    public EncryptedValue Build(X509Certificate holder);
    public EncryptedValue Build(PrivateKeyInfo privateKeyInfo);
    private EncryptedValue EncryptData(Byte[] data);
    private Byte[] PadData(Byte[] data);
}
public interface Org.BouncyCastle.Crmf.IControl {
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    public abstract virtual DerObjectIdentifier get_Type();
    public abstract virtual Asn1Encodable get_Value();
}
public interface Org.BouncyCastle.Crmf.IEncryptedValuePadder {
    public abstract virtual Byte[] GetPaddedData(Byte[] data);
    public abstract virtual Byte[] GetUnpaddedData(Byte[] paddedData);
}
public interface Org.BouncyCastle.Crmf.IPKMacPrimitivesProvider {
    public abstract virtual IDigest CreateDigest(AlgorithmIdentifier digestAlg);
    public abstract virtual IMac CreateMac(AlgorithmIdentifier macAlg);
}
public class Org.BouncyCastle.Crmf.PkiArchiveControl : object {
    public static int encryptedPrivKey;
    public static int keyGenParameters;
    public static int archiveRemGenPrivKey;
    private static DerObjectIdentifier type;
    private PkiArchiveOptions pkiArchiveOptions;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    public int ArchiveType { get; }
    public bool EnvelopedData { get; }
    public PkiArchiveControl(PkiArchiveOptions pkiArchiveOptions);
    private static PkiArchiveControl();
    public sealed virtual DerObjectIdentifier get_Type();
    public sealed virtual Asn1Encodable get_Value();
    public int get_ArchiveType();
    public bool get_EnvelopedData();
    public CmsEnvelopedData GetEnvelopedData();
}
public class Org.BouncyCastle.Crmf.PkiArchiveControlBuilder : object {
    private CmsEnvelopedDataGenerator envGen;
    private CmsProcessableByteArray keyContent;
    public PkiArchiveControlBuilder(PrivateKeyInfo privateKeyInfo, GeneralName generalName);
    public PkiArchiveControlBuilder AddRecipientGenerator(RecipientInfoGenerator recipientGen);
    public PkiArchiveControl Build(ICipherBuilderWithKey contentEncryptor);
}
public class Org.BouncyCastle.Crmf.PKMacBuilder : object {
    private AlgorithmIdentifier owf;
    private AlgorithmIdentifier mac;
    private IPKMacPrimitivesProvider provider;
    private SecureRandom random;
    private PbmParameter parameters;
    private int iterationCount;
    private int saltLength;
    private int maxIterations;
    public PKMacBuilder(IPKMacPrimitivesProvider provider);
    public PKMacBuilder(IPKMacPrimitivesProvider provider, AlgorithmIdentifier digestAlgorithmIdentifier, AlgorithmIdentifier macAlgorithmIdentifier);
    public PKMacBuilder(IPKMacPrimitivesProvider provider, int maxIterations);
    private PKMacBuilder(AlgorithmIdentifier digestAlgorithmIdentifier, int iterationCount, AlgorithmIdentifier macAlgorithmIdentifier, IPKMacPrimitivesProvider provider);
    public PKMacBuilder SetSaltLength(int saltLength);
    public PKMacBuilder SetIterationCount(int iterationCount);
    public PKMacBuilder SetParameters(PbmParameter parameters);
    public PKMacBuilder SetSecureRandom(SecureRandom random);
    public IMacFactory Build(Char[] password);
    private void CheckIterationCountCeiling(int iterationCount);
    private IMacFactory GenCalculator(PbmParameter parameters, Char[] password);
    private IMacFactory GenCalculator(PbmParameter parameters, Byte[] pw);
    private PbmParameter GenParameters();
}
internal class Org.BouncyCastle.Crmf.PKMacFactory : object {
    protected PbmParameter parameters;
    private Byte[] key;
    public object AlgorithmDetails { get; }
    public PKMacFactory(Byte[] key, PbmParameter parameters);
    public virtual object get_AlgorithmDetails();
    public virtual IStreamCalculator`1<IBlockResult> CreateCalculator();
}
internal class Org.BouncyCastle.Crmf.PKMacStreamCalculator : object {
    private MacSink _stream;
    public Stream Stream { get; }
    public PKMacStreamCalculator(IMac mac);
    public sealed virtual Stream get_Stream();
    public sealed virtual DefaultPKMacResult GetResult();
}
public class Org.BouncyCastle.Crmf.ProofOfPossessionSigningKeyBuilder : object {
    private CertRequest _certRequest;
    private SubjectPublicKeyInfo _pubKeyInfo;
    private GeneralName _name;
    private PKMacValue _publicKeyMAC;
    public ProofOfPossessionSigningKeyBuilder(CertRequest certRequest);
    public ProofOfPossessionSigningKeyBuilder(SubjectPublicKeyInfo pubKeyInfo);
    public ProofOfPossessionSigningKeyBuilder SetSender(GeneralName name);
    public ProofOfPossessionSigningKeyBuilder SetPublicKeyMac(PKMacBuilder generator, Char[] password);
    public PopoSigningKey Build(ISignatureFactory signer);
    private ProofOfPossessionSigningKeyBuilder ImplSetPublicKeyMac(IMacFactory macFactory);
}
public class Org.BouncyCastle.Crmf.RegTokenControl : object {
    private static DerObjectIdentifier type;
    private DerUtf8String token;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    public RegTokenControl(DerUtf8String token);
    public RegTokenControl(string token);
    private static RegTokenControl();
    public sealed virtual DerObjectIdentifier get_Type();
    public sealed virtual Asn1Encodable get_Value();
}
public static class Org.BouncyCastle.Crypto.AesUtilities : object {
    public static bool IsHardwareAccelerated { get; }
    public static IBlockCipher CreateEngine();
    public static bool get_IsHardwareAccelerated();
}
public class Org.BouncyCastle.Crypto.Agreement.DHAgreement : object {
    private DHPrivateKeyParameters key;
    private DHParameters dhParams;
    private BigInteger privateValue;
    private SecureRandom random;
    public void Init(ICipherParameters parameters);
    public BigInteger CalculateMessage();
    public BigInteger CalculateAgreement(DHPublicKeyParameters pub, BigInteger message);
}
public class Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement : object {
    private DHPrivateKeyParameters key;
    private DHParameters dhParams;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.DHStandardGroups : object {
    private static BigInteger Two;
    private static string rfc2409_768_p;
    public static DHParameters rfc2409_768;
    private static string rfc2409_1024_p;
    public static DHParameters rfc2409_1024;
    private static string rfc3526_1536_p;
    private static int rfc3526_1536_l;
    public static DHParameters rfc3526_1536;
    private static string rfc3526_2048_p;
    private static int rfc3526_2048_l;
    public static DHParameters rfc3526_2048;
    private static string rfc3526_3072_p;
    private static int rfc3526_3072_l;
    public static DHParameters rfc3526_3072;
    private static string rfc3526_4096_p;
    private static int rfc3526_4096_l;
    public static DHParameters rfc3526_4096;
    private static string rfc3526_6144_p;
    private static int rfc3526_6144_l;
    public static DHParameters rfc3526_6144;
    private static string rfc3526_8192_p;
    private static int rfc3526_8192_l;
    public static DHParameters rfc3526_8192;
    public static DHParameters rfc4306_768;
    public static DHParameters rfc4306_1024;
    public static DHParameters rfc5996_768;
    public static DHParameters rfc5996_1024;
    private static string rfc7919_ffdhe2048_p;
    private static int rfc7919_ffdhe2048_l;
    public static DHParameters rfc7919_ffdhe2048;
    private static string rfc7919_ffdhe3072_p;
    private static int rfc7919_ffdhe3072_l;
    public static DHParameters rfc7919_ffdhe3072;
    private static string rfc7919_ffdhe4096_p;
    private static int rfc7919_ffdhe4096_l;
    public static DHParameters rfc7919_ffdhe4096;
    private static string rfc7919_ffdhe6144_p;
    private static int rfc7919_ffdhe6144_l;
    public static DHParameters rfc7919_ffdhe6144;
    private static string rfc7919_ffdhe8192_p;
    private static int rfc7919_ffdhe8192_l;
    public static DHParameters rfc7919_ffdhe8192;
    private static DHStandardGroups();
    private static BigInteger FromHex(string hex);
    private static DHParameters FromPG(string hexP, string hexG);
    private static DHParameters SafePrimeGen2(string hexP);
    private static DHParameters SafePrimeGen2(string hexP, int l);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHBasicAgreement : object {
    protected internal ECPrivateKeyParameters privKey;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHCBasicAgreement : object {
    private ECPrivateKeyParameters privKey;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHWithKdfBasicAgreement : ECDHBasicAgreement {
    private string algorithm;
    private IDerivationFunction kdf;
    public ECDHWithKdfBasicAgreement(string algorithm, IDerivationFunction kdf);
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
    private Byte[] BigIntToBytes(BigInteger r);
}
public class Org.BouncyCastle.Crypto.Agreement.ECMqvBasicAgreement : object {
    protected internal MqvPrivateParameters privParams;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
    private static ECPoint CalculateMqvAgreement(ECDomainParameters parameters, ECPrivateKeyParameters d1U, ECPrivateKeyParameters d2U, ECPublicKeyParameters Q2U, ECPublicKeyParameters Q1V, ECPublicKeyParameters Q2V);
}
public class Org.BouncyCastle.Crypto.Agreement.ECMqvWithKdfBasicAgreement : ECMqvBasicAgreement {
    private string algorithm;
    private IDerivationFunction kdf;
    public ECMqvWithKdfBasicAgreement(string algorithm, IDerivationFunction kdf);
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
    private Byte[] BigIntToBytes(BigInteger r);
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant : object {
    public static int STATE_INITIALIZED;
    public static int STATE_ROUND_1_CREATED;
    public static int STATE_ROUND_1_VALIDATED;
    public static int STATE_ROUND_2_CREATED;
    public static int STATE_ROUND_2_VALIDATED;
    public static int STATE_KEY_CALCULATED;
    public static int STATE_ROUND_3_CREATED;
    public static int STATE_ROUND_3_VALIDATED;
    private string participantId;
    private Char[] password;
    private IDigest digest;
    private SecureRandom random;
    private BigInteger p;
    private BigInteger q;
    private BigInteger g;
    private string partnerParticipantId;
    private BigInteger x1;
    private BigInteger x2;
    private BigInteger gx1;
    private BigInteger gx2;
    private BigInteger gx3;
    private BigInteger gx4;
    private BigInteger b;
    private int state;
    public int State { get; }
    public JPakeParticipant(string participantId, Char[] password);
    public JPakeParticipant(string participantId, Char[] password, JPakePrimeOrderGroup group);
    public JPakeParticipant(string participantId, Char[] password, JPakePrimeOrderGroup group, IDigest digest, SecureRandom random);
    private static JPakeParticipant();
    public virtual int get_State();
    public virtual JPakeRound1Payload CreateRound1PayloadToSend();
    public virtual void ValidateRound1PayloadReceived(JPakeRound1Payload round1PayloadReceived);
    public virtual JPakeRound2Payload CreateRound2PayloadToSend();
    public virtual void ValidateRound2PayloadReceived(JPakeRound2Payload round2PayloadReceived);
    public virtual BigInteger CalculateKeyingMaterial();
    public virtual JPakeRound3Payload CreateRound3PayloadToSend(BigInteger keyingMaterial);
    public virtual void ValidateRound3PayloadReceived(JPakeRound3Payload round3PayloadReceived, BigInteger keyingMaterial);
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger g;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public JPakePrimeOrderGroup(BigInteger p, BigInteger q, BigInteger g);
    public JPakePrimeOrderGroup(BigInteger p, BigInteger q, BigInteger g, bool skipChecks);
    public virtual BigInteger get_P();
    public virtual BigInteger get_Q();
    public virtual BigInteger get_G();
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups : object {
    public static JPakePrimeOrderGroup SUN_JCE_1024;
    public static JPakePrimeOrderGroup NIST_2048;
    public static JPakePrimeOrderGroup NIST_3072;
    private static JPakePrimeOrderGroups();
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload : object {
    private string participantId;
    private BigInteger gx1;
    private BigInteger gx2;
    private BigInteger[] knowledgeProofForX1;
    private BigInteger[] knowledgeProofForX2;
    public string ParticipantId { get; }
    public BigInteger Gx1 { get; }
    public BigInteger Gx2 { get; }
    public BigInteger[] KnowledgeProofForX1 { get; }
    public BigInteger[] KnowledgeProofForX2 { get; }
    public JPakeRound1Payload(string participantId, BigInteger gx1, BigInteger gx2, BigInteger[] knowledgeProofForX1, BigInteger[] knowledgeProofForX2);
    public virtual string get_ParticipantId();
    public virtual BigInteger get_Gx1();
    public virtual BigInteger get_Gx2();
    public virtual BigInteger[] get_KnowledgeProofForX1();
    public virtual BigInteger[] get_KnowledgeProofForX2();
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload : object {
    private string participantId;
    private BigInteger a;
    private BigInteger[] knowledgeProofForX2s;
    public string ParticipantId { get; }
    public BigInteger A { get; }
    public BigInteger[] KnowledgeProofForX2s { get; }
    public JPakeRound2Payload(string participantId, BigInteger a, BigInteger[] knowledgeProofForX2s);
    public virtual string get_ParticipantId();
    public virtual BigInteger get_A();
    public virtual BigInteger[] get_KnowledgeProofForX2s();
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload : object {
    private string participantId;
    private BigInteger macTag;
    public string ParticipantId { get; }
    public BigInteger MacTag { get; }
    public JPakeRound3Payload(string participantId, BigInteger magTag);
    public virtual string get_ParticipantId();
    public virtual BigInteger get_MacTag();
}
public abstract class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities : object {
    public static BigInteger Zero;
    public static BigInteger One;
    private static JPakeUtilities();
    public static BigInteger GenerateX1(BigInteger q, SecureRandom random);
    public static BigInteger GenerateX2(BigInteger q, SecureRandom random);
    [ObsoleteAttribute("Use version including the modulus instead")]
public static BigInteger CalculateS(Char[] password);
    public static BigInteger CalculateS(BigInteger q, Byte[] password);
    public static BigInteger CalculateS(BigInteger q, Char[] password);
    public static BigInteger CalculateGx(BigInteger p, BigInteger g, BigInteger x);
    public static BigInteger CalculateGA(BigInteger p, BigInteger gx1, BigInteger gx3, BigInteger gx4);
    public static BigInteger CalculateX2s(BigInteger q, BigInteger x2, BigInteger s);
    public static BigInteger CalculateA(BigInteger p, BigInteger q, BigInteger gA, BigInteger x2s);
    public static BigInteger[] CalculateZeroKnowledgeProof(BigInteger p, BigInteger q, BigInteger g, BigInteger gx, BigInteger x, string participantId, IDigest digest, SecureRandom random);
    private static BigInteger CalculateHashForZeroKnowledgeProof(BigInteger g, BigInteger gr, BigInteger gx, string participantId, IDigest digest);
    public static void ValidateGx4(BigInteger gx4);
    public static void ValidateGa(BigInteger ga);
    public static void ValidateZeroKnowledgeProof(BigInteger p, BigInteger q, BigInteger g, BigInteger gx, BigInteger[] zeroKnowledgeProof, string participantId, IDigest digest);
    public static BigInteger CalculateKeyingMaterial(BigInteger p, BigInteger q, BigInteger gx4, BigInteger x2, BigInteger s, BigInteger B);
    public static void ValidateParticipantIdsDiffer(string participantId1, string participantId2);
    public static void ValidateParticipantIdsEqual(string expectedParticipantId, string actualParticipantId);
    public static void ValidateNotNull(object obj, string description);
    public static BigInteger CalculateMacTag(string participantId, string partnerParticipantId, BigInteger gx1, BigInteger gx2, BigInteger gx3, BigInteger gx4, BigInteger keyingMaterial, IDigest digest);
    private static Byte[] CalculateMacKey(BigInteger keyingMaterial, IDigest digest);
    public static void ValidateMacTag(string participantId, string partnerParticipantId, BigInteger gx1, BigInteger gx2, BigInteger gx3, BigInteger gx4, BigInteger keyingMaterial, IDigest digest, BigInteger partnerMacTag);
    private static void UpdateDigest(IDigest digest, BigInteger bigInteger);
    private static void UpdateDigest(IDigest digest, string str);
    private static void UpdateDigest(IDigest digest, Byte[] bytes);
    private static void UpdateDigestIncludingSize(IDigest digest, BigInteger bigInteger);
    private static void UpdateDigestIncludingSize(IDigest digest, string str);
    private static void UpdateDigestIncludingSize(IDigest digest, Byte[] bytes);
    private static void UpdateMac(IMac mac, BigInteger bigInteger);
    private static void UpdateMac(IMac mac, string str);
    private static void UpdateMac(IMac mac, Byte[] bytes);
    private static Byte[] IntToByteArray(int value);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.ConcatenationKdfGenerator : object {
    private IDigest m_digest;
    private int m_hLen;
    private Byte[] m_buffer;
    public IDigest Digest { get; }
    public ConcatenationKdfGenerator(IDigest digest);
    public sealed virtual void Init(IDerivationParameters param);
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.DHKdfParameters : object {
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    private Byte[] extraInfo;
    public DerObjectIdentifier Algorithm { get; }
    public int KeySize { get; }
    public DHKdfParameters(DerObjectIdentifier algorithm, int keySize, Byte[] z);
    public DHKdfParameters(DerObjectIdentifier algorithm, int keySize, Byte[] z, Byte[] extraInfo);
    public DerObjectIdentifier get_Algorithm();
    public int get_KeySize();
    public Byte[] GetZ();
    public Byte[] GetExtraInfo();
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.DHKekGenerator : object {
    private IDigest m_digest;
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    private Byte[] partyAInfo;
    public IDigest Digest { get; }
    public DHKekGenerator(IDigest digest);
    public sealed virtual void Init(IDerivationParameters param);
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] outBytes, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.ECDHKekGenerator : object {
    private IDerivationFunction m_kdf;
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    public IDigest Digest { get; }
    public ECDHKekGenerator(IDigest digest);
    public sealed virtual void Init(IDerivationParameters param);
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] outBytes, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Agreement.SM2KeyExchange : object {
    private IDigest mDigest;
    private Byte[] mUserID;
    private ECPrivateKeyParameters mStaticKey;
    private ECPoint mStaticPubPoint;
    private ECPoint mEphemeralPubPoint;
    private ECDomainParameters mECParams;
    private int mW;
    private ECPrivateKeyParameters mEphemeralKey;
    private bool mInitiator;
    public SM2KeyExchange(IDigest digest);
    public virtual void Init(ICipherParameters privParam);
    public virtual Byte[] CalculateKey(int kLen, ICipherParameters pubParam);
    public virtual Byte[][] CalculateKeyWithConfirmation(int kLen, Byte[] confirmationTag, ICipherParameters pubParam);
    protected virtual ECPoint CalculateU(SM2KeyExchangePublicParameters otherPub);
    protected virtual Byte[] Kdf(ECPoint u, Byte[] za, Byte[] zb, int klen);
    private BigInteger Reduce(BigInteger x);
    private Byte[] S1(IDigest digest, ECPoint u, Byte[] inner);
    private Byte[] CalculateInnerHash(IDigest digest, ECPoint u, Byte[] za, Byte[] zb, ECPoint p1, ECPoint p2);
    private Byte[] S2(IDigest digest, ECPoint u, Byte[] inner);
    private Byte[] GetZ(IDigest digest, Byte[] userID, ECPoint pubPoint);
    private void AddUserID(IDigest digest, Byte[] userID);
    private void AddFieldElement(IDigest digest, ECFieldElement v);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client : object {
    protected BigInteger N;
    protected BigInteger g;
    protected BigInteger privA;
    protected BigInteger pubA;
    protected BigInteger B;
    protected BigInteger x;
    protected BigInteger u;
    protected BigInteger S;
    protected BigInteger M1;
    protected BigInteger M2;
    protected BigInteger Key;
    protected IDigest digest;
    protected SecureRandom random;
    public virtual void Init(BigInteger N, BigInteger g, IDigest digest, SecureRandom random);
    public virtual void Init(Srp6GroupParameters group, IDigest digest, SecureRandom random);
    public virtual BigInteger GenerateClientCredentials(Byte[] salt, Byte[] identity, Byte[] password);
    public virtual BigInteger CalculateSecret(BigInteger serverB);
    protected virtual BigInteger SelectPrivateValue();
    private BigInteger CalculateS();
    public virtual BigInteger CalculateClientEvidenceMessage();
    public virtual bool VerifyServerEvidenceMessage(BigInteger serverM2);
    public virtual BigInteger CalculateSessionKey();
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server : object {
    protected BigInteger N;
    protected BigInteger g;
    protected BigInteger v;
    protected SecureRandom random;
    protected IDigest digest;
    protected BigInteger A;
    protected BigInteger privB;
    protected BigInteger pubB;
    protected BigInteger u;
    protected BigInteger S;
    protected BigInteger M1;
    protected BigInteger M2;
    protected BigInteger Key;
    public virtual void Init(BigInteger N, BigInteger g, BigInteger v, IDigest digest, SecureRandom random);
    public virtual void Init(Srp6GroupParameters group, BigInteger v, IDigest digest, SecureRandom random);
    public virtual BigInteger GenerateServerCredentials();
    public virtual BigInteger CalculateSecret(BigInteger clientA);
    protected virtual BigInteger SelectPrivateValue();
    private BigInteger CalculateS();
    public virtual bool VerifyClientEvidenceMessage(BigInteger clientM1);
    public virtual BigInteger CalculateServerEvidenceMessage();
    public virtual BigInteger CalculateSessionKey();
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6StandardGroups : object {
    private static string rfc5054_1024_N;
    private static string rfc5054_1024_g;
    public static Srp6GroupParameters rfc5054_1024;
    private static string rfc5054_1536_N;
    private static string rfc5054_1536_g;
    public static Srp6GroupParameters rfc5054_1536;
    private static string rfc5054_2048_N;
    private static string rfc5054_2048_g;
    public static Srp6GroupParameters rfc5054_2048;
    private static string rfc5054_3072_N;
    private static string rfc5054_3072_g;
    public static Srp6GroupParameters rfc5054_3072;
    private static string rfc5054_4096_N;
    private static string rfc5054_4096_g;
    public static Srp6GroupParameters rfc5054_4096;
    private static string rfc5054_6144_N;
    private static string rfc5054_6144_g;
    public static Srp6GroupParameters rfc5054_6144;
    private static string rfc5054_8192_N;
    private static string rfc5054_8192_g;
    public static Srp6GroupParameters rfc5054_8192;
    private static Srp6StandardGroups();
    private static BigInteger FromHex(string hex);
    private static Srp6GroupParameters FromNG(string hexN, string hexG);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities : object {
    public static BigInteger CalculateK(IDigest digest, BigInteger N, BigInteger g);
    public static BigInteger CalculateU(IDigest digest, BigInteger N, BigInteger A, BigInteger B);
    public static BigInteger CalculateX(IDigest digest, BigInteger N, Byte[] salt, Byte[] identity, Byte[] password);
    public static BigInteger GeneratePrivateValue(IDigest digest, BigInteger N, BigInteger g, SecureRandom random);
    public static BigInteger ValidatePublicValue(BigInteger N, BigInteger val);
    public static BigInteger CalculateM1(IDigest digest, BigInteger N, BigInteger A, BigInteger B, BigInteger S);
    public static BigInteger CalculateM2(IDigest digest, BigInteger N, BigInteger A, BigInteger M1, BigInteger S);
    public static BigInteger CalculateKey(IDigest digest, BigInteger N, BigInteger S);
    private static BigInteger HashPaddedTriplet(IDigest digest, BigInteger N, BigInteger n1, BigInteger n2, BigInteger n3);
    private static BigInteger HashPaddedPair(IDigest digest, BigInteger N, BigInteger n1, BigInteger n2);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator : object {
    protected BigInteger N;
    protected BigInteger g;
    protected IDigest digest;
    public virtual void Init(BigInteger N, BigInteger g, IDigest digest);
    public virtual void Init(Srp6GroupParameters group, IDigest digest);
    public virtual BigInteger GenerateVerifier(Byte[] salt, Byte[] identity, Byte[] password);
}
public class Org.BouncyCastle.Crypto.Agreement.X25519Agreement : object {
    private X25519PrivateKeyParameters m_privateKey;
    public int AgreementSize { get; }
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int get_AgreementSize();
    public sealed virtual void CalculateAgreement(ICipherParameters publicKey, Byte[] buf, int off);
}
public class Org.BouncyCastle.Crypto.Agreement.X448Agreement : object {
    private X448PrivateKeyParameters m_privateKey;
    public int AgreementSize { get; }
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int get_AgreementSize();
    public sealed virtual void CalculateAgreement(ICipherParameters publicKey, Byte[] buf, int off);
}
public class Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair : object {
    private AsymmetricKeyParameter publicParameter;
    private AsymmetricKeyParameter privateParameter;
    public AsymmetricKeyParameter Public { get; }
    public AsymmetricKeyParameter Private { get; }
    public AsymmetricCipherKeyPair(AsymmetricKeyParameter publicParameter, AsymmetricKeyParameter privateParameter);
    public AsymmetricKeyParameter get_Public();
    public AsymmetricKeyParameter get_Private();
}
public abstract class Org.BouncyCastle.Crypto.AsymmetricKeyParameter : object {
    private bool privateKey;
    public bool IsPrivate { get; }
    protected AsymmetricKeyParameter(bool privateKey);
    public bool get_IsPrivate();
    public virtual bool Equals(object obj);
    protected bool Equals(AsymmetricKeyParameter other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.BufferedAeadBlockCipher : BufferedCipherBase {
    private IAeadBlockCipher cipher;
    public string AlgorithmName { get; }
    public BufferedAeadBlockCipher(IAeadBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedAeadCipher : BufferedCipherBase {
    private IAeadCipher cipher;
    public string AlgorithmName { get; }
    public BufferedAeadCipher(IAeadCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher : BufferedCipherBase {
    private IAsymmetricBlockCipher cipher;
    private Byte[] buffer;
    private int bufOff;
    public string AlgorithmName { get; }
    public BufferedAsymmetricBlockCipher(IAsymmetricBlockCipher cipher);
    internal int GetBufferPosition();
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedBlockCipher : BufferedCipherBase {
    internal Byte[] buf;
    internal int bufOff;
    internal bool forEncryption;
    internal IBlockCipherMode m_cipherMode;
    public string AlgorithmName { get; }
    public BufferedBlockCipher(IBlockCipher cipher);
    public BufferedBlockCipher(IBlockCipherMode cipherMode);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public abstract class Org.BouncyCastle.Crypto.BufferedCipherBase : object {
    protected static Byte[] EmptyBuffer;
    public string AlgorithmName { get; }
    private static BufferedCipherBase();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedIesCipher : BufferedCipherBase {
    private IesEngine engine;
    private bool forEncryption;
    private MemoryStream buffer;
    public string AlgorithmName { get; }
    public BufferedIesCipher(IesEngine engine);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int inputLen);
    public virtual int GetUpdateOutputSize(int inputLen);
    public virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedStreamCipher : BufferedCipherBase {
    private IStreamCipher m_cipher;
    public string AlgorithmName { get; }
    public BufferedStreamCipher(IStreamCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int inputLen);
    public virtual int GetUpdateOutputSize(int inputLen);
    public virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
internal static class Org.BouncyCastle.Crypto.Check : object {
    internal static void DataLength(bool condition, string message);
    internal static void DataLength(Byte[] buf, int off, int len, string message);
    internal static void OutputLength(bool condition, string message);
    internal static void OutputLength(Byte[] buf, int off, int len, string message);
    internal static void ThrowDataLengthException(string message);
    internal static void ThrowOutputLengthException(string message);
}
public class Org.BouncyCastle.Crypto.CipherKeyGenerator : object {
    protected internal SecureRandom random;
    protected internal int strength;
    private bool uninitialised;
    private int defaultStrength;
    public int DefaultStrength { get; }
    internal CipherKeyGenerator(int defaultStrength);
    public int get_DefaultStrength();
    public void Init(KeyGenerationParameters parameters);
    protected virtual void EngineInit(KeyGenerationParameters parameters);
    public Byte[] GenerateKey();
    public KeyParameter GenerateKeyParameter();
    protected virtual Byte[] EngineGenerateKey();
    protected virtual KeyParameter EngineGenerateKeyParameter();
    protected virtual void EnsureInitialized();
}
public class Org.BouncyCastle.Crypto.CryptoException : Exception {
    public CryptoException(string message);
    public CryptoException(string message, Exception innerException);
    protected CryptoException(SerializationInfo info, StreamingContext context);
}
public static class Org.BouncyCastle.Crypto.CryptoServicesRegistrar : object {
    public static SecureRandom GetSecureRandom();
    public static SecureRandom GetSecureRandom(SecureRandom secureRandom);
}
public class Org.BouncyCastle.Crypto.DataLengthException : CryptoException {
    public DataLengthException(string message);
    public DataLengthException(string message, Exception innerException);
    protected DataLengthException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Crypto.Digests.AsconDigest : object {
    private AsconParameters m_asconParameters;
    private int ASCON_PB_ROUNDS;
    private ulong x0;
    private ulong x1;
    private ulong x2;
    private ulong x3;
    private ulong x4;
    private Byte[] m_buf;
    private int m_bufPos;
    public string AlgorithmName { get; }
    public AsconDigest(AsconParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void FinishAbsorbing();
    private void P(int nr);
    private void ROUND(ulong c);
}
public class Org.BouncyCastle.Crypto.Digests.AsconXof : object {
    private AsconParameters m_asconParameters;
    private int ASCON_PB_ROUNDS;
    private ulong x0;
    private ulong x1;
    private ulong x2;
    private ulong x3;
    private ulong x4;
    private Byte[] m_buf;
    private int m_bufPos;
    private bool m_squeezing;
    public string AlgorithmName { get; }
    public AsconXof(AsconParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual int OutputFinal(Byte[] output, int outOff, int outLen);
    public sealed virtual int Output(Byte[] output, int outOff, int outLen);
    public sealed virtual void Reset();
    private void FinishAbsorbing();
    private void P(int nr);
    private void ROUND(ulong c);
}
public class Org.BouncyCastle.Crypto.Digests.Blake2bDigest : object {
    private static UInt64[] blake2b_IV;
    private static Byte[0...,0...] blake2b_sigma;
    private static int ROUNDS;
    private static int BLOCK_LENGTH_BYTES;
    private int digestLength;
    private int keyLength;
    private Byte[] salt;
    private Byte[] personalization;
    private Byte[] key;
    private Byte[] buffer;
    private int bufferPos;
    private UInt64[] internalState;
    private UInt64[] chainValue;
    private ulong t0;
    private ulong t1;
    private ulong f0;
    public string AlgorithmName { get; }
    public Blake2bDigest(Blake2bDigest digest);
    public Blake2bDigest(int digestSize);
    public Blake2bDigest(Byte[] key);
    public Blake2bDigest(Byte[] key, int digestLength, Byte[] salt, Byte[] personalization);
    private static Blake2bDigest();
    private void Init();
    private void InitializeInternalState();
    public sealed virtual void Update(byte b);
    public sealed virtual void BlockUpdate(Byte[] message, int offset, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOffset);
    public sealed virtual void Reset();
    private void Compress(Byte[] message, int messagePos);
    private void G(ulong m1, ulong m2, int posA, int posB, int posC, int posD);
    private static ulong Rotr64(ulong x, int rot);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public void ClearKey();
    public void ClearSalt();
}
public class Org.BouncyCastle.Crypto.Digests.Blake2sDigest : object {
    private static UInt32[] blake2s_IV;
    private static Byte[0...,0...] blake2s_sigma;
    private static int ROUNDS;
    private static int BLOCK_LENGTH_BYTES;
    private int digestLength;
    private int keyLength;
    private Byte[] salt;
    private Byte[] personalization;
    private Byte[] key;
    private int fanout;
    private int depth;
    private int leafLength;
    private long nodeOffset;
    private int nodeDepth;
    private int innerHashLength;
    private Byte[] buffer;
    private int bufferPos;
    private UInt32[] internalState;
    private UInt32[] chainValue;
    private UInt32 t0;
    private UInt32 t1;
    private UInt32 f0;
    public string AlgorithmName { get; }
    public Blake2sDigest(Blake2sDigest digest);
    public Blake2sDigest(int digestBits);
    public Blake2sDigest(Byte[] key);
    public Blake2sDigest(Byte[] key, int digestBytes, Byte[] salt, Byte[] personalization);
    internal Blake2sDigest(int digestBytes, Byte[] key, Byte[] salt, Byte[] personalization, long offset);
    internal Blake2sDigest(int digestBytes, int hashLength, long offset);
    private static Blake2sDigest();
    private void Init(Byte[] salt, Byte[] personalization, Byte[] key);
    private void InitializeInternalState();
    public sealed virtual void Update(byte b);
    public sealed virtual void BlockUpdate(Byte[] message, int offset, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOffset);
    public sealed virtual void Reset();
    private void Compress(Byte[] message, int messagePos);
    private void G(UInt32 m1, UInt32 m2, int posA, int posB, int posC, int posD);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public void ClearKey();
    public void ClearSalt();
}
public class Org.BouncyCastle.Crypto.Digests.Blake2xsDigest : object {
    public static int UnknownDigestLength;
    private static int DigestLength;
    private static long MaxNumberBlocks;
    private int digestLength;
    private Blake2sDigest hash;
    private Byte[] h0;
    private Byte[] buf;
    private int bufPos;
    private int digestPos;
    private long blockPos;
    private long nodeOffset;
    public string AlgorithmName { get; }
    public Blake2xsDigest(int digestBytes);
    public Blake2xsDigest(int digestBytes, Byte[] key);
    public Blake2xsDigest(int digestBytes, Byte[] key, Byte[] salt, Byte[] personalization);
    public Blake2xsDigest(Blake2xsDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public long GetUnknownMaxLength();
    public sealed virtual void Update(byte b);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public sealed virtual void Reset();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual int OutputFinal(Byte[] output, int outOff, int outLen);
    public sealed virtual int Output(Byte[] output, int outOff, int outLen);
    private int ComputeStepLength();
    private long ComputeNodeOffset();
}
public class Org.BouncyCastle.Crypto.Digests.Blake3Digest : object {
    private static string ERR_OUTPUTTING;
    private static int NUMWORDS;
    private static int ROUNDS;
    private static int BLOCKLEN;
    private static int CHUNKLEN;
    private static int CHUNKSTART;
    private static int CHUNKEND;
    private static int PARENT;
    private static int ROOT;
    private static int KEYEDHASH;
    private static int DERIVECONTEXT;
    private static int DERIVEKEY;
    private static int CHAINING0;
    private static int CHAINING1;
    private static int CHAINING2;
    private static int CHAINING3;
    private static int CHAINING4;
    private static int CHAINING5;
    private static int CHAINING6;
    private static int CHAINING7;
    private static int IV0;
    private static int IV1;
    private static int IV2;
    private static int IV3;
    private static int COUNT0;
    private static int COUNT1;
    private static int DATALEN;
    private static int FLAGS;
    private static Byte[] SIGMA;
    private static UInt32[] IV;
    private Byte[] m_theBuffer;
    private UInt32[] m_theK;
    private UInt32[] m_theChaining;
    private UInt32[] m_theV;
    private UInt32[] m_theM;
    private Byte[] m_theIndices;
    private List`1<UInt32[]> m_theStack;
    private int m_theDigestLen;
    private bool m_outputting;
    private long m_outputAvailable;
    private int m_theMode;
    private int m_theOutputMode;
    private int m_theOutputDataLen;
    private long m_theCounter;
    private int m_theCurrBytes;
    private int m_thePos;
    public string AlgorithmName { get; }
    public Blake3Digest(int pDigestSize);
    public Blake3Digest(Blake3Digest pSource);
    private static Blake3Digest();
    public sealed virtual int GetByteLength();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public void Init(Blake3Parameters pParams);
    public sealed virtual void Update(byte b);
    public sealed virtual void BlockUpdate(Byte[] pMessage, int pOffset, int pLen);
    public sealed virtual int DoFinal(Byte[] pOutput, int pOutOffset);
    public sealed virtual int OutputFinal(Byte[] pOut, int pOutOffset, int pOutLen);
    public sealed virtual int Output(Byte[] pOut, int pOutOffset, int pOutLen);
    public sealed virtual void Reset();
    public sealed virtual void Reset(IMemoable pSource);
    public sealed virtual IMemoable Copy();
    private void CompressBlock(Byte[] pMessage, int pMsgPos);
    private void InitM(Byte[] pMessage, int pMsgPos);
    private void AdjustStack();
    private void CompressFinalBlock(int pDataLen);
    private void ProcessStack();
    private void Compress();
    private void PerformRound();
    private void AdjustChaining();
    private void MixG(int msgIdx, int posA, int posB, int posC, int posD);
    private void InitIndices();
    private void PermuteIndices();
    private void InitNullKey();
    private void InitKey(Byte[] pKey);
    private void InitKeyFromContext();
    private void InitChunkBlock(int pDataLen, bool pFinal);
    private void InitParentBlock();
    private void NextOutputBlock();
    private void IncrementBlockCount();
    private void ResetBlockCount();
    private void SetRoot();
}
public class Org.BouncyCastle.Crypto.Digests.CShakeDigest : ShakeDigest {
    private static Byte[] padding;
    private Byte[] diff;
    public string AlgorithmName { get; }
    public CShakeDigest(int bitLength, Byte[] N, Byte[] S);
    public CShakeDigest(CShakeDigest source);
    private static CShakeDigest();
    private static Byte[] EncodeString(Byte[] str);
    private void DiffPadAndAbsorb();
    public virtual string get_AlgorithmName();
    public virtual int Output(Byte[] output, int outOff, int outLen);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.Dstu7564Digest : object {
    private static int NB_512;
    private static int NB_1024;
    private static int NR_512;
    private static int NR_1024;
    private int hashSize;
    private int blockSize;
    private int columns;
    private int rounds;
    private UInt64[] state;
    private UInt64[] tempState1;
    private UInt64[] tempState2;
    private ulong inputBlocks;
    private int bufOff;
    private Byte[] buf;
    private static Byte[] S0;
    private static Byte[] S1;
    private static Byte[] S2;
    private static Byte[] S3;
    public string AlgorithmName { get; }
    public Dstu7564Digest(Dstu7564Digest digest);
    public Dstu7564Digest(int hashSizeBits);
    private static Dstu7564Digest();
    private void CopyIn(Dstu7564Digest digest);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int GetByteLength();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void ProcessBlock(Byte[] input, int inOff);
    private void P(UInt64[] s);
    private void Q(UInt64[] s);
    private static ulong MixColumn(ulong c);
    private void MixColumns(UInt64[] s);
    private static ulong Rotate(int n, ulong x);
    private void ShiftRows(UInt64[] s);
    private void SubBytes(UInt64[] s);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public abstract class Org.BouncyCastle.Crypto.Digests.GeneralDigest : object {
    private static int BYTE_LENGTH;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount;
    public string AlgorithmName { get; }
    internal GeneralDigest(GeneralDigest t);
    protected void CopyIn(GeneralDigest t);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    public sealed virtual int GetByteLength();
    internal abstract virtual void ProcessWord(Byte[] input, int inOff);
    internal abstract virtual void ProcessLength(long bitLength);
    internal abstract virtual void ProcessBlock();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual IMemoable Copy();
    public abstract virtual void Reset(IMemoable t);
}
public class Org.BouncyCastle.Crypto.Digests.Gost3411_2012_256Digest : Gost3411_2012Digest {
    private static Byte[] IV;
    public string AlgorithmName { get; }
    public Gost3411_2012_256Digest(Gost3411_2012_256Digest other);
    private static Gost3411_2012_256Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual IMemoable Copy();
}
public class Org.BouncyCastle.Crypto.Digests.Gost3411_2012_512Digest : Gost3411_2012Digest {
    private static Byte[] IV;
    public string AlgorithmName { get; }
    public Gost3411_2012_512Digest(Gost3411_2012_512Digest other);
    private static Gost3411_2012_512Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual IMemoable Copy();
}
public abstract class Org.BouncyCastle.Crypto.Digests.Gost3411_2012Digest : object {
    private Byte[] IV;
    private Byte[] N;
    private Byte[] Sigma;
    private Byte[] Ki;
    private Byte[] m;
    private Byte[] h;
    private Byte[] tmp;
    private Byte[] block;
    private int bOff;
    private static Byte[][] C;
    private static Byte[] Zero;
    private static UInt64[][] T;
    public string AlgorithmName { get; }
    protected Gost3411_2012Digest(Byte[] IV);
    private static Gost3411_2012Digest();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual IMemoable Copy();
    public virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual int GetByteLength();
    public abstract virtual int GetDigestSize();
    public sealed virtual void Reset();
    public sealed virtual void Reset(IMemoable other);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    private void F(Byte[] V);
    private void xor512(Byte[] A, Byte[] B);
    private void E(Byte[] K, Byte[] m);
    private void g_N(Byte[] h, Byte[] N, Byte[] m);
    private void addMod512(Byte[] A, int num);
    private void addMod512(Byte[] A, Byte[] B);
    private void reverse(Byte[] src, Byte[] dst);
}
public class Org.BouncyCastle.Crypto.Digests.Gost3411Digest : object {
    private static int DIGEST_LENGTH;
    private Byte[] H;
    private Byte[] L;
    private Byte[] M;
    private Byte[] Sum;
    private Byte[][] C;
    private Byte[] xBuf;
    private int xBufOff;
    private ulong byteCount;
    private IBlockCipher cipher;
    private Byte[] sBox;
    private Byte[] K;
    private Byte[] a;
    internal Int16[] wS;
    internal Int16[] w_S;
    internal Byte[] S;
    internal Byte[] U;
    internal Byte[] V;
    internal Byte[] W;
    private static Byte[] C2;
    public string AlgorithmName { get; }
    public Gost3411Digest(Byte[] sBoxParam);
    public Gost3411Digest(Gost3411Digest t);
    private static Gost3411Digest();
    private static Byte[][] MakeC();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private Byte[] P(Byte[] input);
    private Byte[] A(Byte[] input);
    private void E(Byte[] key, Byte[] s, int sOff, Byte[] input, int inOff);
    private void fw(Byte[] input);
    private void processBlock(Byte[] input, int inOff);
    private void Finish();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void sumByteArray(Byte[] input);
    private static void cpyBytesToShort(Byte[] S, Int16[] wS);
    private static void cpyShortToBytes(Int16[] wS, Byte[] S);
    public sealed virtual int GetByteLength();
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Haraka256Digest : HarakaBase {
    private Byte[] m_buf;
    private int m_bufPos;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetByteLength();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static int Haraka256256(Byte[] msg, Byte[] output, int outOff);
    private static void Mix256(Byte[][] s1, Byte[][] s2);
}
public class Org.BouncyCastle.Crypto.Digests.Haraka512Digest : HarakaBase {
    private Byte[] m_buf;
    private int m_bufPos;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetByteLength();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static int Haraka512256(Byte[] msg, Byte[] output, int outOff);
    private static void Mix512(Byte[][] s1, Byte[][] s2);
}
public abstract class Org.BouncyCastle.Crypto.Digests.HarakaBase : object {
    internal static int DIGEST_SIZE;
    internal static Byte[][] RC;
    private static Byte[0...,0...] S;
    public string AlgorithmName { get; }
    private static HarakaBase();
    private static byte SBox(byte x);
    private static Byte[] SubBytes(Byte[] s);
    private static Byte[] ShiftRows(Byte[] s);
    internal static Byte[] AesEnc(Byte[] s, Byte[] rk);
    private static byte MulX(byte p);
    internal static Byte[] Xor(Byte[] x, Byte[] y, int yStart);
    private static void XorTo(Byte[] x, Byte[] z);
    private static Byte[] MixColumns(Byte[] s);
    public abstract virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public abstract virtual int GetByteLength();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.IsapDigest : object {
    private MemoryStream buffer;
    private ulong x0;
    private ulong x1;
    private ulong x2;
    private ulong x3;
    private ulong x4;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void P12();
    private void ROUND(ulong C);
}
public class Org.BouncyCastle.Crypto.Digests.KeccakDigest : object {
    private static UInt64[] KeccakRoundConstants;
    private UInt64[] state;
    protected Byte[] dataQueue;
    protected int rate;
    protected int bitsInQueue;
    protected internal int fixedOutputLength;
    protected bool squeezing;
    public string AlgorithmName { get; }
    public KeccakDigest(int bitLength);
    public KeccakDigest(KeccakDigest source);
    private static KeccakDigest();
    private void CopyIn(KeccakDigest source);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
    public virtual void Reset();
    public virtual int GetByteLength();
    private void Init(int bitLength);
    private void InitSponge(int rate);
    protected void Absorb(byte data);
    protected void Absorb(Byte[] data, int off, int len);
    protected void AbsorbBits(int data, int bits);
    private void PadAndSwitchToSqueezingPhase();
    protected void Squeeze(Byte[] output, int offset, long outputLength);
    private void KeccakAbsorb(Byte[] data, int off);
    private void KeccakExtract();
    internal static void KeccakPermutation(UInt64[] A);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public abstract class Org.BouncyCastle.Crypto.Digests.LongDigest : object {
    private static int MyByteLength;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount1;
    private long byteCount2;
    internal ulong H1;
    internal ulong H2;
    internal ulong H3;
    internal ulong H4;
    internal ulong H5;
    internal ulong H6;
    internal ulong H7;
    internal ulong H8;
    private UInt64[] W;
    private int wOff;
    internal static UInt64[] K;
    public string AlgorithmName { get; }
    internal LongDigest(LongDigest t);
    private static LongDigest();
    protected void CopyIn(LongDigest t);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    internal void ProcessWord(Byte[] input, int inOff);
    private void AdjustByteCounts();
    internal void ProcessLength(long lowW, long hiW);
    internal void ProcessBlock();
    private static ulong Ch(ulong x, ulong y, ulong z);
    private static ulong Maj(ulong x, ulong y, ulong z);
    private static ulong Sum0(ulong x);
    private static ulong Sum1(ulong x);
    private static ulong Sigma0(ulong x);
    private static ulong Sigma1(ulong x);
    public sealed virtual int GetByteLength();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual IMemoable Copy();
    public abstract virtual void Reset(IMemoable t);
}
public class Org.BouncyCastle.Crypto.Digests.MD2Digest : object {
    private static int DigestLength;
    private static int BYTE_LENGTH;
    private Byte[] X;
    private int xOff;
    private Byte[] M;
    private int mOff;
    private Byte[] C;
    private int COff;
    private static Byte[] S;
    public string AlgorithmName { get; }
    public MD2Digest(MD2Digest t);
    private static MD2Digest();
    private void CopyIn(MD2Digest t);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    internal void ProcessChecksum(Byte[] m);
    internal void ProcessBlock(Byte[] m);
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.MD4Digest : GeneralDigest {
    private static int DigestLength;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    public string AlgorithmName { get; }
    public MD4Digest(MD4Digest t);
    private void CopyIn(MD4Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int F(int u, int v, int w);
    private int G(int u, int v, int w);
    private int H(int u, int v, int w);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.MD5Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32[] X;
    private int xOff;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    private static int S41;
    private static int S42;
    private static int S43;
    private static int S44;
    public string AlgorithmName { get; }
    public MD5Digest(MD5Digest t);
    private static MD5Digest();
    private void CopyIn(MD5Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static UInt32 F(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 G(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 H(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 K(UInt32 u, UInt32 v, UInt32 w);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.NonMemoableDigest : object {
    protected IDigest mBaseDigest;
    public string AlgorithmName { get; }
    public NonMemoableDigest(IDigest baseDigest);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    public virtual int GetByteLength();
}
public class Org.BouncyCastle.Crypto.Digests.NullDigest : object {
    private MemoryStream bOut;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetByteLength();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte b);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.ParallelHash : object {
    private static Byte[] N_PARALLEL_HASH;
    private CShakeDigest cshake;
    private CShakeDigest compressor;
    private int bitLength;
    private int outputLength;
    private int B;
    private Byte[] buffer;
    private Byte[] compressorBuffer;
    private bool firstOutput;
    private int nCount;
    private int bufOff;
    public string AlgorithmName { get; }
    public ParallelHash(int bitLength, Byte[] S, int B);
    public ParallelHash(int bitLength, Byte[] S, int B, int outputSize);
    public ParallelHash(ParallelHash source);
    private static ParallelHash();
    public virtual string get_AlgorithmName();
    public virtual int GetByteLength();
    public virtual int GetDigestSize();
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] inBuf, int inOff, int len);
    private void Compress();
    private void Compress(Byte[] buf, int offSet, int len);
    private void WrapUp(int outputSize);
    public virtual int DoFinal(Byte[] outBuf, int outOff);
    public virtual int OutputFinal(Byte[] outBuf, int outOff, int outLen);
    public virtual int Output(Byte[] outBuf, int outOff, int outLen);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.PhotonBeetleDigest : object {
    private Byte[] state;
    private Byte[][] state_2d;
    private MemoryStream buffer;
    private static int INITIAL_RATE_INBYTES;
    private int RATE_INBYTES;
    private int SQUEEZE_RATE_INBYTES;
    private int STATE_INBYTES;
    private int TAG_INBYTES;
    private int LAST_THREE_BITS_OFFSET;
    private int ROUND;
    private int D;
    private int Dq;
    private int Dr;
    private int DSquare;
    private int S;
    private int S_1;
    private Byte[][] RC;
    private Byte[][] MixColMatrix;
    private Byte[] sbox;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void PHOTON_Permutation();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD128Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD128Digest(RipeMD128Digest t);
    private void CopyIn(RipeMD128Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F1(int a, int b, int c, int d, int x, int s);
    private int F2(int a, int b, int c, int d, int x, int s);
    private int F3(int a, int b, int c, int d, int x, int s);
    private int F4(int a, int b, int c, int d, int x, int s);
    private int FF1(int a, int b, int c, int d, int x, int s);
    private int FF2(int a, int b, int c, int d, int x, int s);
    private int FF3(int a, int b, int c, int d, int x, int s);
    private int FF4(int a, int b, int c, int d, int x, int s);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD160Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD160Digest(RipeMD160Digest t);
    private void CopyIn(RipeMD160Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD256Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private int H6;
    private int H7;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD256Digest(RipeMD256Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    private void CopyIn(RipeMD256Digest t);
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F1(int a, int b, int c, int d, int x, int s);
    private int F2(int a, int b, int c, int d, int x, int s);
    private int F3(int a, int b, int c, int d, int x, int s);
    private int F4(int a, int b, int c, int d, int x, int s);
    private int FF1(int a, int b, int c, int d, int x, int s);
    private int FF2(int a, int b, int c, int d, int x, int s);
    private int FF3(int a, int b, int c, int d, int x, int s);
    private int FF4(int a, int b, int c, int d, int x, int s);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD320Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private int H6;
    private int H7;
    private int H8;
    private int H9;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD320Digest(RipeMD320Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    private void CopyIn(RipeMD320Digest t);
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha1Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32[] X;
    private int xOff;
    private static UInt32 Y1;
    private static UInt32 Y2;
    private static UInt32 Y3;
    private static UInt32 Y4;
    public string AlgorithmName { get; }
    public Sha1Digest(Sha1Digest t);
    private void CopyIn(Sha1Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static UInt32 F(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 H(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 G(UInt32 u, UInt32 v, UInt32 w);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha224Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    internal static UInt32[] K;
    public string AlgorithmName { get; }
    public Sha224Digest(Sha224Digest t);
    private static Sha224Digest();
    private void CopyIn(Sha224Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    internal virtual void ProcessBlock();
    private static UInt32 Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0(UInt32 x);
    private static UInt32 Sum1(UInt32 x);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha256Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    private static UInt32[] K;
    public string AlgorithmName { get; }
    public Sha256Digest(Sha256Digest t);
    private static Sha256Digest();
    private void CopyIn(Sha256Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void initHs();
    internal virtual void ProcessBlock();
    private static UInt32 Sum1Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha384Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha384Digest(Sha384Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha3Digest : KeccakDigest {
    public string AlgorithmName { get; }
    public Sha3Digest(int bitLength);
    public Sha3Digest(Sha3Digest source);
    internal static void CalculateDigest(UInt64[] input, int inputOffset, int inputLengthBits, Byte[] output, int outputOffset, int outputLengthBits);
    private static int CheckBitLength(int bitLength);
    public virtual string get_AlgorithmName();
    public virtual int DoFinal(Byte[] output, int outOff);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
    public virtual IMemoable Copy();
}
public class Org.BouncyCastle.Crypto.Digests.Sha512Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha512Digest(Sha512Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha512tDigest : LongDigest {
    private static ulong A5;
    private int digestLength;
    private ulong H1t;
    private ulong H2t;
    private ulong H3t;
    private ulong H4t;
    private ulong H5t;
    private ulong H6t;
    private ulong H7t;
    private ulong H8t;
    public string AlgorithmName { get; }
    public Sha512tDigest(int bitLength);
    public Sha512tDigest(Sha512tDigest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void tIvGenerate(int bitLength);
    private static void UInt64_To_BE(ulong n, Byte[] bs, int off, int max);
    private static void UInt32_To_BE(UInt32 n, Byte[] bs, int off, int max);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.ShakeDigest : KeccakDigest {
    public string AlgorithmName { get; }
    public ShakeDigest(int bitLength);
    public ShakeDigest(ShakeDigest source);
    private static int CheckBitLength(int bitLength);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual int OutputFinal(Byte[] output, int outOff, int outLen);
    public virtual int Output(Byte[] output, int outOff, int outLen);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
    protected virtual int OutputFinal(Byte[] output, int outOff, int outLen, byte partialByte, int partialBits);
    public virtual IMemoable Copy();
}
public class Org.BouncyCastle.Crypto.Digests.ShortenedDigest : object {
    private IDigest baseDigest;
    private int length;
    public string AlgorithmName { get; }
    public ShortenedDigest(IDigest baseDigest, int length);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetByteLength();
}
public class Org.BouncyCastle.Crypto.Digests.SkeinDigest : object {
    public static int SKEIN_256;
    public static int SKEIN_512;
    public static int SKEIN_1024;
    private SkeinEngine engine;
    public string AlgorithmName { get; }
    public SkeinDigest(int stateSizeBits, int digestSizeBits);
    public SkeinDigest(SkeinDigest digest);
    public sealed virtual void Reset(IMemoable other);
    public sealed virtual IMemoable Copy();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public void Init(SkeinParameters parameters);
    public sealed virtual void Reset();
    public sealed virtual void Update(byte inByte);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Digests.SkeinEngine : object {
    public static int SKEIN_256;
    public static int SKEIN_512;
    public static int SKEIN_1024;
    private static int PARAM_TYPE_KEY;
    private static int PARAM_TYPE_CONFIG;
    private static int PARAM_TYPE_MESSAGE;
    private static int PARAM_TYPE_OUTPUT;
    private static IDictionary`2<int, UInt64[]> InitialStates;
    private ThreefishEngine threefish;
    private int outputSizeBytes;
    private UInt64[] chain;
    private UInt64[] initialState;
    private Byte[] key;
    private Parameter[] preMessageParameters;
    private Parameter[] postMessageParameters;
    private UBI ubi;
    private Byte[] singleByte;
    public int OutputSize { get; }
    public int BlockSize { get; }
    private static SkeinEngine();
    public SkeinEngine(int blockSizeBits, int outputSizeBits);
    public SkeinEngine(SkeinEngine engine);
    private static void InitialState(int blockSize, int outputSize, UInt64[] state);
    private static int VariantIdentifier(int blockSizeBytes, int outputSizeBytes);
    private void CopyIn(SkeinEngine engine);
    private static Parameter[] Clone(Parameter[] data, Parameter[] existing);
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
    public int get_OutputSize();
    public int get_BlockSize();
    public void Init(SkeinParameters parameters);
    private void InitParams(IDictionary`2<int, Byte[]> parameters);
    private void CreateInitialState();
    public void Reset();
    private void UbiComplete(int type, Byte[] value);
    private void UbiInit(int type);
    private void UbiFinal();
    private void CheckInitialised();
    public void Update(byte inByte);
    public void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public int DoFinal(Byte[] outBytes, int outOff);
    private void Output(ulong outputSequence, Byte[] outBytes, int outOff, int outputBytes);
}
public class Org.BouncyCastle.Crypto.Digests.SM3Digest : GeneralDigest {
    private static int DIGEST_LENGTH;
    private static int BLOCK_SIZE;
    private UInt32[] V;
    private UInt32[] inwords;
    private int xOff;
    private UInt32[] W;
    private static UInt32[] T;
    public string AlgorithmName { get; }
    private static SM3Digest();
    public SM3Digest(SM3Digest t);
    private void CopyIn(SM3Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
    public virtual void Reset();
    public virtual int DoFinal(Byte[] output, int outOff);
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private UInt32 P0(UInt32 x);
    private UInt32 P1(UInt32 x);
    private UInt32 FF0(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 FF1(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 GG0(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 GG1(UInt32 x, UInt32 y, UInt32 z);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.SparkleDigest : object {
    private static UInt32[] RCON;
    private string algorithmName;
    private UInt32[] state;
    private MemoryStream message;
    private int DIGEST_BYTES;
    private int SPARKLE_STEPS_SLIM;
    private int SPARKLE_STEPS_BIG;
    private int STATE_BRANS;
    private int STATE_WORDS;
    private int RATE_WORDS;
    private int RATE_BYTES;
    public string AlgorithmName { get; }
    public SparkleDigest(SparkleParameters sparkleParameters);
    private static SparkleDigest();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void sparkle_opt(UInt32[] state, int brans, int steps);
    private static UInt32 ELL(UInt32 x);
}
public class Org.BouncyCastle.Crypto.Digests.TigerDigest : object {
    private static int MyByteLength;
    private static Int64[] t1;
    private static Int64[] t2;
    private static Int64[] t3;
    private static Int64[] t4;
    private static int DigestLength;
    private long a;
    private long b;
    private long c;
    private long byteCount;
    private Byte[] m_buffer;
    private int bOff;
    private Int64[] x;
    private int xOff;
    public string AlgorithmName { get; }
    public TigerDigest(TigerDigest t);
    private static TigerDigest();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    private void ProcessWord(Byte[] b, int off);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private void RoundABC(long x, long mul);
    private void RoundBCA(long x, long mul);
    private void RoundCAB(long x, long mul);
    private void KeySchedule();
    private void ProcessBlock();
    private void ProcessLength(long bitLength);
    private void Finish();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.TupleHash : object {
    private static Byte[] N_TUPLE_HASH;
    private CShakeDigest cshake;
    private int bitLength;
    private int outputLength;
    private bool firstOutput;
    public string AlgorithmName { get; }
    public TupleHash(int bitLength, Byte[] S);
    public TupleHash(int bitLength, Byte[] S, int outputSize);
    public TupleHash(TupleHash original);
    private static TupleHash();
    public virtual string get_AlgorithmName();
    public virtual int GetByteLength();
    public virtual int GetDigestSize();
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] inBuf, int inOff, int len);
    private void WrapUp(int outputSize);
    public virtual int DoFinal(Byte[] outBuf, int outOff);
    public virtual int OutputFinal(Byte[] outBuf, int outOff, int outLen);
    public virtual int Output(Byte[] outBuf, int outOff, int outLen);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest : object {
    private static int BITCOUNT_ARRAY_SIZE;
    private static int BYTE_LENGTH;
    private static int DIGEST_LENGTH_BYTES;
    private static int REDUCTION_POLYNOMIAL;
    private static int ROUNDS;
    private static Int32[] SBOX;
    private static UInt64[] C0;
    private static UInt64[] C1;
    private static UInt64[] C2;
    private static UInt64[] C3;
    private static UInt64[] C4;
    private static UInt64[] C5;
    private static UInt64[] C6;
    private static UInt64[] C7;
    private static Int16[] EIGHT;
    private UInt64[] _rc;
    private Byte[] _buffer;
    private int _bufferPos;
    private Int16[] _bitCount;
    private UInt64[] _hash;
    private UInt64[] _K;
    private UInt64[] _L;
    private UInt64[] _block;
    private UInt64[] _state;
    public string AlgorithmName { get; }
    private static WhirlpoolDigest();
    public WhirlpoolDigest(WhirlpoolDigest originalDigest);
    private static int MulX(int input);
    private static ulong PackIntoUInt64(int b7, int b6, int b5, int b4, int b3, int b2, int b1, int b0);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void ProcessFilledBuffer();
    private void ProcessBlock();
    public sealed virtual void Update(byte input);
    private void Increment();
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private void Finish();
    private Byte[] CopyBitLength();
    public sealed virtual int GetByteLength();
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
}
internal class Org.BouncyCastle.Crypto.Digests.XofUtilities : object {
    internal static Byte[] LeftEncode(long strLen);
    internal static Byte[] RightEncode(long strLen);
    internal static Byte[] Encode(byte X);
    internal static Byte[] Encode(Byte[] inBuf, int inOff, int len);
}
public class Org.BouncyCastle.Crypto.Digests.XoodyakDigest : object {
    private static int Rkin;
    private static UInt32[] RC;
    private Byte[] state;
    private int phase;
    private MODE mode;
    private int Rabsorb;
    private static int f_bPrime;
    private static int Rkout;
    private static int PhaseDown;
    private static int PhaseUp;
    private static int NLANES;
    private static int NROWS;
    private static int NCOLUMNS;
    private static int MAXROUNDS;
    private static int TAGLEN;
    private static int Rhash;
    private MemoryStream buffer;
    public string AlgorithmName { get; }
    private static XoodyakDigest();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void Up(Byte[] Yi, int YiOff, int YiLen, UInt32 Cu);
    private void Down(Byte[] Xi, int XiOff, int XiLen, UInt32 Cd);
    private UInt32 index(UInt32 x, UInt32 y);
}
public static class Org.BouncyCastle.Crypto.EC.CustomNamedCurves : object {
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, X9ECParametersHolder> curves;
    private static Dictionary`2<DerObjectIdentifier, string> names;
    public static IEnumerable`1<string> Names { get; }
    private static CustomNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static ECCurve ConfigureCurveGlv(ECCurve c, GlvTypeBParameters p);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    private static void DefineCurveAlias(string name, DerObjectIdentifier oid);
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public class Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding : object {
    private static BigInteger Sixteen;
    private static BigInteger Six;
    private static Byte[] shadows;
    private static Byte[] inverse;
    private IAsymmetricBlockCipher engine;
    private bool forEncryption;
    private int bitSize;
    private int padBits;
    private BigInteger modulus;
    public string AlgorithmName { get; }
    public IAsymmetricBlockCipher UnderlyingCipher { get; }
    public ISO9796d1Encoding(IAsymmetricBlockCipher cipher);
    private static ISO9796d1Encoding();
    public sealed virtual string get_AlgorithmName();
    public IAsymmetricBlockCipher get_UnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public void SetPadBits(int padBits);
    public int GetPadBits();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
    private Byte[] EncodeBlock(Byte[] input, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Encodings.OaepEncoding : object {
    private Byte[] defHash;
    private IDigest mgf1Hash;
    private IAsymmetricBlockCipher engine;
    private SecureRandom random;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public IAsymmetricBlockCipher UnderlyingCipher { get; }
    public OaepEncoding(IAsymmetricBlockCipher cipher);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash, Byte[] encodingParams);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash, IDigest mgf1Hash, Byte[] encodingParams);
    public sealed virtual string get_AlgorithmName();
    public IAsymmetricBlockCipher get_UnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] EncodeBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] MaskGeneratorFunction(Byte[] Z, int zOff, int zLen, int length);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding : object {
    public static string StrictLengthEnabledProperty;
    private static int HeaderLength;
    private static Boolean[] strictLengthEnabled;
    private SecureRandom random;
    private IAsymmetricBlockCipher engine;
    private bool forEncryption;
    private bool forPrivateKey;
    private bool useStrictLength;
    private int pLen;
    private Byte[] fallback;
    private Byte[] blockBuffer;
    public static bool StrictLengthEnabled { get; public set; }
    public string AlgorithmName { get; }
    public IAsymmetricBlockCipher UnderlyingCipher { get; }
    private static Pkcs1Encoding();
    public Pkcs1Encoding(IAsymmetricBlockCipher cipher);
    public Pkcs1Encoding(IAsymmetricBlockCipher cipher, int pLen);
    public Pkcs1Encoding(IAsymmetricBlockCipher cipher, Byte[] fallback);
    public static bool get_StrictLengthEnabled();
    public static void set_StrictLengthEnabled(bool value);
    public sealed virtual string get_AlgorithmName();
    public IAsymmetricBlockCipher get_UnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
    private Byte[] EncodeBlock(Byte[] input, int inOff, int inLen);
    private static int CheckPkcs1Encoding(Byte[] encoded, int pLen);
    private Byte[] DecodeBlockOrRandom(Byte[] input, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] input, int inOff, int inLen);
    private int FindStart(byte type, Byte[] block);
}
public class Org.BouncyCastle.Crypto.Engines.AesEngine : object {
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32[] T0;
    private static UInt32[] Tinv0;
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static UInt32 m4;
    private static UInt32 m5;
    private int ROUNDS;
    private UInt32[][] WorkingKey;
    private bool forEncryption;
    private Byte[] s;
    private static int BLOCK_SIZE;
    public string AlgorithmName { get; }
    private static AesEngine();
    private static UInt32 Shift(UInt32 r, int shift);
    private static UInt32 FFmulX(UInt32 x);
    private static UInt32 FFmulX2(UInt32 x);
    private static UInt32 Inv_Mcol(UInt32 x);
    private static UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateWorkingKey(KeyParameter keyParameter, bool forEncryption);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
}
public class Org.BouncyCastle.Crypto.Engines.AesLightEngine : object {
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static UInt32 m4;
    private static UInt32 m5;
    private int ROUNDS;
    private UInt32[][] WorkingKey;
    private bool forEncryption;
    private static int BLOCK_SIZE;
    public string AlgorithmName { get; }
    private static AesLightEngine();
    private static UInt32 Shift(UInt32 r, int shift);
    private static UInt32 FFmulX(UInt32 x);
    private static UInt32 FFmulX2(UInt32 x);
    private static UInt32 Mcol(UInt32 x);
    private static UInt32 Inv_Mcol(UInt32 x);
    private static UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateWorkingKey(KeyParameter keyParameter, bool forEncryption);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
}
public class Org.BouncyCastle.Crypto.Engines.AesWrapEngine : Rfc3394WrapEngine {
    public AesWrapEngine(bool useReverseDirection);
}
public class Org.BouncyCastle.Crypto.Engines.AriaEngine : object {
    private static Byte[][] C;
    private static Byte[] SB1_sbox;
    private static Byte[] SB2_sbox;
    private static Byte[] SB3_sbox;
    private static Byte[] SB4_sbox;
    protected static int BlockSize;
    private Byte[][] m_roundKeys;
    public string AlgorithmName { get; }
    private static AriaEngine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    protected static void A(Byte[] z);
    protected static void FE(Byte[] D, Byte[] RK);
    protected static void FO(Byte[] D, Byte[] RK);
    protected static Byte[][] KeySchedule(bool forEncryption, Byte[] K);
    protected static Byte[] KeyScheduleRound(Byte[] w, Byte[] wr, int n);
    protected static void ReverseKeys(Byte[][] keys);
    protected static byte SB1(byte x);
    protected static byte SB2(byte x);
    protected static byte SB3(byte x);
    protected static byte SB4(byte x);
    protected static void SL1(Byte[] z);
    protected static void SL2(Byte[] z);
    protected static void Xor(Byte[] z, Byte[] x);
}
public class Org.BouncyCastle.Crypto.Engines.AriaWrapEngine : Rfc3394WrapEngine {
    public AriaWrapEngine(bool useReverseDirection);
}
public class Org.BouncyCastle.Crypto.Engines.AsconEngine : object {
    private AsconParameters asconParameters;
    private int CRYPTO_KEYBYTES;
    private int CRYPTO_ABYTES;
    private int ASCON_AEAD_RATE;
    private int nr;
    private Byte[] mac;
    private ulong K0;
    private ulong K1;
    private ulong K2;
    private ulong N0;
    private ulong N1;
    private ulong ASCON_IV;
    private ulong x0;
    private ulong x1;
    private ulong x2;
    private ulong x3;
    private ulong x4;
    private string algorithmName;
    private State m_state;
    private Byte[] initialAssociatedText;
    private int m_bufferSizeDecrypt;
    private Byte[] m_buf;
    private int m_bufPos;
    public string AlgorithmName { get; }
    public AsconEngine(AsconParameters asconParameters);
    public int GetKeyBytesSize();
    public int GetIVBytesSize();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual void ProcessAadByte(byte input);
    public sealed virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public sealed virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public sealed virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
    public sealed virtual Byte[] GetMac();
    public sealed virtual int GetUpdateOutputSize(int len);
    public sealed virtual int GetOutputSize(int len);
    public sealed virtual void Reset();
    private void CheckAad();
    private bool CheckData();
    private void FinishAad(State nextState);
    private void FinishData(State nextState);
    private void P(int nr);
    private void ROUND(ulong c);
    private void ascon_aeadinit();
    private void ProcessBufferAad(Byte[] buffer, int bufOff);
    private void ProcessBufferDecrypt(Byte[] buffer, int bufOff, Byte[] output, int outOff);
    private void ProcessBufferEncrypt(Byte[] buffer, int bufOff, Byte[] output, int outOff);
    private void ProcessFinalDecrypt(Byte[] input, int inOff, int inLen, Byte[] output, int outOff);
    private void ProcessFinalEncrypt(Byte[] input, int inOff, int inLen, Byte[] output, int outOff);
    private void Reset(bool clearMac);
    private static ulong PAD(int i);
}
public class Org.BouncyCastle.Crypto.Engines.BlowfishEngine : object {
    private static UInt32[] KP;
    private static UInt32[] KS0;
    private static UInt32[] KS1;
    private static UInt32[] KS2;
    private static UInt32[] KS3;
    private static int ROUNDS;
    private static int BLOCK_SIZE;
    private static int SBOX_SK;
    private static int P_SZ;
    private UInt32[] S0;
    private UInt32[] S1;
    private UInt32[] S2;
    private UInt32[] S3;
    private UInt32[] P;
    private bool encrypting;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    private static BlowfishEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual int GetBlockSize();
    private UInt32 F(UInt32 x);
    private void ProcessTable(UInt32 xl, UInt32 xr, UInt32[] table);
    private void SetKey(Byte[] key);
    private void EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaEngine : object {
    private bool initialised;
    private bool _keyIs128;
    private static int BLOCK_SIZE;
    private UInt32[] subkey;
    private UInt32[] kw;
    private UInt32[] ke;
    private static UInt32[] SIGMA;
    private static UInt32[] SBOX1_1110;
    private static UInt32[] SBOX4_4404;
    private static UInt32[] SBOX2_0222;
    private static UInt32[] SBOX3_3033;
    public string AlgorithmName { get; }
    private static CamelliaEngine();
    private static UInt32 rightRotate(UInt32 x, int s);
    private static UInt32 leftRotate(UInt32 x, int s);
    private static void roldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void roldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void camelliaF2(UInt32[] s, UInt32[] skey, int keyoff);
    private static void camelliaFLs(UInt32[] s, UInt32[] fkey, int keyoff);
    private void setKey(bool forEncryption, Byte[] key);
    private int ProcessBlock128(Byte[] input, int inOff, Byte[] output, int outOff);
    private int ProcessBlock192or256(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaLightEngine : object {
    private static int BLOCK_SIZE;
    private bool initialised;
    private bool _keyis128;
    private UInt32[] subkey;
    private UInt32[] kw;
    private UInt32[] ke;
    private static UInt32[] SIGMA;
    private static Byte[] SBOX1;
    public string AlgorithmName { get; }
    private static CamelliaLightEngine();
    private static UInt32 rightRotate(UInt32 x, int s);
    private static UInt32 leftRotate(UInt32 x, int s);
    private static void roldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void roldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private byte lRot8(byte v, int rot);
    private UInt32 sbox2(int x);
    private UInt32 sbox3(int x);
    private UInt32 sbox4(int x);
    private void camelliaF2(UInt32[] s, UInt32[] skey, int keyoff);
    private void camelliaFLs(UInt32[] s, UInt32[] fkey, int keyoff);
    private void setKey(bool forEncryption, Byte[] key);
    private int ProcessBlock128(Byte[] input, int inOff, Byte[] output, int outOff);
    private int ProcessBlock192or256(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.Cast5Engine : object {
    private static UInt32[] S1;
    private static UInt32[] S2;
    private static UInt32[] S3;
    private static UInt32[] S4;
    private static UInt32[] S5;
    private static UInt32[] S6;
    private static UInt32[] S7;
    private static UInt32[] S8;
    internal static int MAX_ROUNDS;
    internal static int RED_ROUNDS;
    private static int BLOCK_SIZE;
    private Int32[] _Kr;
    private UInt32[] _Km;
    private bool _encrypting;
    private Byte[] _workingKey;
    private int _rounds;
    public string AlgorithmName { get; }
    private static Cast5Engine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] key);
    internal virtual int EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal virtual int DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal static UInt32 F1(UInt32 D, UInt32 Kmi, int Kri);
    internal static UInt32 F2(UInt32 D, UInt32 Kmi, int Kri);
    internal static UInt32 F3(UInt32 D, UInt32 Kmi, int Kri);
    internal void CAST_Encipher(UInt32 L0, UInt32 R0, UInt32[] result);
    internal void CAST_Decipher(UInt32 L16, UInt32 R16, UInt32[] result);
    internal static void Bits32ToInts(UInt32 inData, Int32[] b, int offset);
    internal static UInt32 IntsTo32bits(Int32[] b, int i);
}
public class Org.BouncyCastle.Crypto.Engines.Cast6Engine : Cast5Engine {
    private static int ROUNDS;
    private static int BLOCK_SIZE;
    private Int32[] _Kr;
    private UInt32[] _Km;
    private Int32[] _Tr;
    private UInt32[] _Tm;
    private UInt32[] _workingKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] key);
    internal virtual int EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal virtual int DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void CAST_Encipher(UInt32 A, UInt32 B, UInt32 C, UInt32 D, UInt32[] result);
    private void CAST_Decipher(UInt32 A, UInt32 B, UInt32 C, UInt32 D, UInt32[] result);
}
public class Org.BouncyCastle.Crypto.Engines.ChaCha7539Engine : Salsa20Engine {
    public string AlgorithmName { get; }
    protected int NonceSize { get; }
    public virtual string get_AlgorithmName();
    protected virtual int get_NonceSize();
    protected virtual void AdvanceCounter();
    protected virtual void ResetCounter();
    protected virtual void SetKey(Byte[] keyBytes, Byte[] ivBytes);
    protected virtual void GenerateKeyStream(Byte[] output);
    internal void DoFinal(Byte[] inBuf, int inOff, int inLen, Byte[] outBuf, int outOff);
    internal void ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    internal void ProcessBlocks2(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    internal void ImplProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.ChaChaEngine : Salsa20Engine {
    public string AlgorithmName { get; }
    public ChaChaEngine(int rounds);
    public virtual string get_AlgorithmName();
    protected virtual void AdvanceCounter();
    protected virtual void ResetCounter();
    protected virtual void SetKey(Byte[] keyBytes, Byte[] ivBytes);
    protected virtual void GenerateKeyStream(Byte[] output);
    internal static void ChachaCore(int rounds, UInt32[] input, Byte[] output);
}
public class Org.BouncyCastle.Crypto.Engines.DesEdeEngine : DesEngine {
    private Int32[] workingKey1;
    private Int32[] workingKey2;
    private Int32[] workingKey3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine : object {
    private CbcBlockCipher engine;
    private KeyParameter param;
    private ParametersWithIV paramPlusIV;
    private Byte[] iv;
    private bool forWrapping;
    private static Byte[] IV2;
    private IDigest sha1;
    private Byte[] digest;
    public string AlgorithmName { get; }
    private static DesEdeWrapEngine();
    public virtual void Init(bool forWrapping, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
    private Byte[] CalculateCmsKeyChecksum(Byte[] key);
    private bool CheckCmsKeyChecksum(Byte[] key, Byte[] checksum);
}
public class Org.BouncyCastle.Crypto.Engines.DesEngine : object {
    internal static int BLOCK_SIZE;
    private Int32[] workingKey;
    private static Int16[] bytebit;
    private static Int32[] bigbyte;
    private static Byte[] pc1;
    private static Byte[] totrot;
    private static Byte[] pc2;
    private static UInt32[] SP1;
    private static UInt32[] SP2;
    private static UInt32[] SP3;
    private static UInt32[] SP4;
    private static UInt32[] SP5;
    private static UInt32[] SP6;
    private static UInt32[] SP7;
    private static UInt32[] SP8;
    public string AlgorithmName { get; }
    private static DesEngine();
    public virtual Int32[] GetWorkingKey();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    protected static Int32[] GenerateWorkingKey(bool encrypting, Byte[] key);
    internal static void DesFunc(Int32[] wKey, UInt32& hi32, UInt32& lo32);
}
public class Org.BouncyCastle.Crypto.Engines.Dstu7624Engine : object {
    private UInt64[] internalState;
    private UInt64[] workingKey;
    private UInt64[][] roundKeys;
    private int wordsInBlock;
    private int wordsInKey;
    private static int ROUNDS_128;
    private static int ROUNDS_256;
    private static int ROUNDS_512;
    private int roundsAmount;
    private bool forEncryption;
    private static ulong mdsMatrix;
    private static ulong mdsInvMatrix;
    private static Byte[] S0;
    private static Byte[] S1;
    private static Byte[] S2;
    private static Byte[] S3;
    private static Byte[] T0;
    private static Byte[] T1;
    private static Byte[] T2;
    private static Byte[] T3;
    public string AlgorithmName { get; }
    public Dstu7624Engine(int blockSizeBits);
    private static Dstu7624Engine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private void WorkingKeyExpandKT(UInt64[] workingKey, UInt64[] tempKeys);
    private void WorkingKeyExpandEven(UInt64[] workingKey, UInt64[] tempKey);
    private void WorkingKeyExpandOdd();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void EncryptionRound();
    private void DecryptionRound();
    private void DecryptBlock_128(Byte[] input, int inOff, Byte[] output, int outOff);
    private void EncryptBlock_128(Byte[] input, int inOff, Byte[] output, int outOff);
    private void SubBytes();
    private void InvSubBytes();
    private void ShiftRows();
    private void InvShiftRows();
    private void AddRoundKey(int round);
    private void SubRoundKey(int round);
    private void XorRoundKey(int round);
    private static ulong MixColumn(ulong c);
    private void MixColumns();
    private static ulong MixColumnInv(ulong c);
    private void MixColumnsInv();
    private static ulong MulX(ulong n);
    private static ulong MulX2(ulong n);
    private static ulong Rotate(int n, ulong x);
    private void RotateLeft(UInt64[] x, UInt64[] z);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
}
public class Org.BouncyCastle.Crypto.Engines.Dstu7624WrapEngine : object {
    private KeyParameter param;
    private Dstu7624Engine engine;
    private bool forWrapping;
    private int blockSize;
    public string AlgorithmName { get; }
    public Dstu7624WrapEngine(int blockSizeBits);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forWrapping, ICipherParameters parameters);
    public sealed virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Crypto.Engines.ElGamalEngine : object {
    private ElGamalKeyParameters key;
    private SecureRandom random;
    private bool forEncryption;
    private int bitSize;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Crypto.Engines.Gost28147Engine : object {
    private static int BlockSize;
    private Int32[] workingKey;
    private bool forEncryption;
    private Byte[] S;
    private static Byte[] Sbox_Default;
    private static Byte[] ESbox_Test;
    private static Byte[] ESbox_A;
    private static Byte[] ESbox_B;
    private static Byte[] ESbox_C;
    private static Byte[] ESbox_D;
    private static Byte[] DSbox_Test;
    private static Byte[] DSbox_A;
    private static Dictionary`2<string, Byte[]> m_sBoxes;
    public string AlgorithmName { get; }
    private static Gost28147Engine();
    private static void AddSBox(string sBoxName, Byte[] sBox);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private Int32[] GenerateWorkingKey(bool forEncryption, Byte[] userKey);
    private int Gost28147_mainStep(int n1, int key);
    private void Gost28147Func(Int32[] workingKey, Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    public static Byte[] GetSBox(string sBoxName);
    public static string GetSBoxName(Byte[] sBox);
}
public class Org.BouncyCastle.Crypto.Engines.Grain128AeadEngine : object {
    private static int STATE_SIZE;
    private Byte[] workingKey;
    private Byte[] workingIV;
    private UInt32[] lfsr;
    private UInt32[] nfsr;
    private UInt32[] authAcc;
    private UInt32[] authSr;
    private bool initialised;
    private bool aadFinished;
    private MemoryStream aadData;
    private Byte[] mac;
    public string AlgorithmName { get; }
    private static Grain128AeadEngine();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters param);
    private void InitGrain();
    private UInt32 GetOutputNFSR();
    private UInt32 GetOutputLFSR();
    private UInt32 GetOutput();
    private UInt32[] Shift(UInt32[] array, UInt32 val);
    private void SetKey(Byte[] keyBytes, Byte[] ivBytes);
    public sealed virtual int ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void Reset(bool clearMac);
    private void GetKeyStream(Byte[] input, int inOff, int len, Byte[] ciphertext, int outOff);
    public byte ReturnByte(byte input);
    public sealed virtual void ProcessAadByte(byte input);
    public sealed virtual void ProcessAadBytes(Byte[] input, int inOff, int len);
    private void Accumulate();
    private void AuthShift(UInt32 val);
    public sealed virtual int ProcessByte(byte input, Byte[] output, int outOff);
    private void DoProcessAADBytes(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual Byte[] GetMac();
    public sealed virtual int GetUpdateOutputSize(int len);
    public sealed virtual int GetOutputSize(int len);
    private static int LenLength(int v);
}
public class Org.BouncyCastle.Crypto.Engines.HC128Engine : object {
    private UInt32[] p;
    private UInt32[] q;
    private UInt32 cnt;
    private Byte[] key;
    private Byte[] iv;
    private bool initialised;
    private Byte[] buf;
    private int idx;
    public string AlgorithmName { get; }
    private static UInt32 F1(UInt32 x);
    private static UInt32 F2(UInt32 x);
    private UInt32 G1(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 G2(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 RotateLeft(UInt32 x, int bits);
    private static UInt32 RotateRight(UInt32 x, int bits);
    private UInt32 H1(UInt32 x);
    private UInt32 H2(UInt32 x);
    private static UInt32 Mod1024(UInt32 x);
    private static UInt32 Mod512(UInt32 x);
    private static UInt32 Dim(UInt32 x, UInt32 y);
    private UInt32 Step();
    private void Init();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte GetByte();
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual byte ReturnByte(byte input);
}
public class Org.BouncyCastle.Crypto.Engines.HC256Engine : object {
    private UInt32[] p;
    private UInt32[] q;
    private UInt32 cnt;
    private Byte[] key;
    private Byte[] iv;
    private bool initialised;
    private Byte[] buf;
    private int idx;
    public string AlgorithmName { get; }
    private UInt32 Step();
    private void Init();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte GetByte();
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual byte ReturnByte(byte input);
    private static UInt32 RotateRight(UInt32 x, int bits);
}
public class Org.BouncyCastle.Crypto.Engines.IdeaEngine : object {
    private static int BLOCK_SIZE;
    private Int32[] workingKey;
    private static int MASK;
    private static int BASE;
    public string AlgorithmName { get; }
    private static IdeaEngine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int BytesToWord(Byte[] input, int inOff);
    private void WordToBytes(int word, Byte[] outBytes, int outOff);
    private int Mul(int x, int y);
    private void IdeaFunc(Int32[] workingKey, Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private Int32[] ExpandKey(Byte[] uKey);
    private int MulInv(int x);
    private int AddInv(int x);
    private Int32[] InvertKey(Int32[] inKey);
    private Int32[] GenerateWorkingKey(bool forEncryption, Byte[] userKey);
}
public class Org.BouncyCastle.Crypto.Engines.IesEngine : object {
    private IBasicAgreement agree;
    private IDerivationFunction kdf;
    private IMac mac;
    private BufferedBlockCipher cipher;
    private Byte[] macBuf;
    private bool forEncryption;
    private ICipherParameters privParam;
    private ICipherParameters pubParam;
    private IesParameters param;
    public IesEngine(IBasicAgreement agree, IDerivationFunction kdf, IMac mac);
    public IesEngine(IBasicAgreement agree, IDerivationFunction kdf, IMac mac, BufferedBlockCipher cipher);
    public virtual void Init(bool forEncryption, ICipherParameters privParameters, ICipherParameters pubParameters, ICipherParameters iesParameters);
    private Byte[] DecryptBlock(Byte[] in_enc, int inOff, int inLen, Byte[] z);
    private Byte[] EncryptBlock(Byte[] input, int inOff, int inLen, Byte[] z);
    private Byte[] GenerateKdfBytes(KdfParameters kParam, int length);
    public virtual Byte[] ProcessBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.IsaacEngine : object {
    private static int sizeL;
    private static int stateArraySize;
    private UInt32[] engineState;
    private UInt32[] results;
    private UInt32 a;
    private UInt32 b;
    private UInt32 c;
    private int index;
    private Byte[] keyStream;
    private Byte[] workingKey;
    private bool initialised;
    public string AlgorithmName { get; }
    private static IsaacEngine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual byte ReturnByte(byte input);
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual string get_AlgorithmName();
    public virtual void Reset();
    private void setKey(Byte[] keyBytes);
    private void isaac();
    private void mix(UInt32[] x);
}
public class Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine : object {
    private bool forEncryption;
    private NaccacheSternKeyParameters key;
    private IList`1[] lookup;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] inBytes, int inOff, int length);
    public virtual Byte[] Encrypt(BigInteger plain);
    public virtual Byte[] AddCryptedBlocks(Byte[] block1, Byte[] block2);
    public virtual Byte[] ProcessData(Byte[] data);
    private static BigInteger ChineseRemainder(IList`1<BigInteger> congruences, IList`1<BigInteger> primes);
}
public class Org.BouncyCastle.Crypto.Engines.NoekeonEngine : object {
    private static int Size;
    private static Byte[] RoundConstants;
    private UInt32[] k;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    private static NoekeonEngine();
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC2Engine : object {
    private static Byte[] piTable;
    private static int BLOCK_SIZE;
    private Int32[] workingKey;
    private bool encrypting;
    public string AlgorithmName { get; }
    private static RC2Engine();
    private Int32[] GenerateWorkingKey(Byte[] key, int bits);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private static int RotateWordLeft(int x, int y);
    private void EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC2WrapEngine : object {
    private CbcBlockCipher engine;
    private ICipherParameters parameters;
    private ParametersWithIV paramPlusIV;
    private Byte[] iv;
    private bool forWrapping;
    private SecureRandom sr;
    private static Byte[] IV2;
    private IDigest sha1;
    private Byte[] digest;
    public string AlgorithmName { get; }
    private static RC2WrapEngine();
    public virtual void Init(bool forWrapping, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
    private void CalculateCmsKeyChecksum(Byte[] key, int keyOff, int keyLen, Byte[] cks, int cksOff);
    private bool CheckCmsKeyChecksum(Byte[] key, int keyOff, int keyLen, Byte[] cks, int cksOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC4Engine : object {
    private static int STATE_LENGTH;
    private Byte[] engineState;
    private int x;
    private int y;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    private static RC4Engine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual byte ReturnByte(byte input);
    public virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual void Reset();
    private void SetKey(Byte[] keyBytes);
}
public class Org.BouncyCastle.Crypto.Engines.RC532Engine : object {
    private int _noRounds;
    private Int32[] _S;
    private static int P32;
    private static int Q32;
    private bool forEncryption;
    public string AlgorithmName { get; }
    private static RC532Engine();
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC564Engine : object {
    private int _noRounds;
    private Int64[] _S;
    private static long P64;
    private static long Q64;
    private bool forEncryption;
    public string AlgorithmName { get; }
    private static RC564Engine();
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC6Engine : object {
    private static int _noRounds;
    private Int32[] _S;
    private static int P32;
    private static int Q32;
    private static int LGW;
    private bool forEncryption;
    public string AlgorithmName { get; }
    private static RC6Engine();
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.Rfc3211WrapEngine : object {
    private CbcBlockCipher engine;
    private ParametersWithIV param;
    private bool forWrapping;
    private SecureRandom rand;
    public string AlgorithmName { get; }
    public Rfc3211WrapEngine(IBlockCipher engine);
    public virtual void Init(bool forWrapping, ICipherParameters param);
    public virtual string get_AlgorithmName();
    public virtual Byte[] Wrap(Byte[] inBytes, int inOff, int inLen);
    public virtual Byte[] Unwrap(Byte[] inBytes, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.Rfc3394WrapEngine : object {
    private IBlockCipher engine;
    private bool wrapCipherMode;
    private KeyParameter param;
    private bool forWrapping;
    private Byte[] iv;
    public string AlgorithmName { get; }
    public Rfc3394WrapEngine(IBlockCipher engine);
    public Rfc3394WrapEngine(IBlockCipher engine, bool useReverseDirection);
    public virtual void Init(bool forWrapping, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual Byte[] Wrap(Byte[] input, int inOff, int inLen);
    public virtual Byte[] Unwrap(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.RijndaelEngine : object {
    private static int MAXROUNDS;
    private static int MAXKC;
    private static Byte[] Logtable;
    private static Byte[] Alogtable;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static Byte[][] shifts0;
    private static Byte[][] shifts1;
    private int BC;
    private long BC_MASK;
    private int ROUNDS;
    private int blockBits;
    private Int64[][] workingKey;
    private long A0;
    private long A1;
    private long A2;
    private long A3;
    private bool forEncryption;
    private Byte[] shifts0SC;
    private Byte[] shifts1SC;
    public string AlgorithmName { get; }
    public RijndaelEngine(int blockBits);
    private static RijndaelEngine();
    private byte Mul0x2(int b);
    private byte Mul0x3(int b);
    private byte Mul0x9(int b);
    private byte Mul0xb(int b);
    private byte Mul0xd(int b);
    private byte Mul0xe(int b);
    private void KeyAddition(Int64[] rk);
    private long Shift(long r, int shift);
    private void ShiftRow(Byte[] shiftsSC);
    private long ApplyS(long r, Byte[] box);
    private void Substitution(Byte[] box);
    private void MixColumn();
    private void InvMixColumn();
    private Int64[][] GenerateWorkingKey(KeyParameter keyParameter);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock(Int64[][] rk);
    private void DecryptBlock(Int64[][] rk);
}
public class Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine : object {
    private IRsa core;
    private RsaKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public RsaBlindedEngine(IRsa rsa);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters param);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine : object {
    private IRsa core;
    private RsaKeyParameters key;
    private BigInteger blindingFactor;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public RsaBlindingEngine(IRsa rsa);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters param);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
    private BigInteger BlindMessage(BigInteger msg);
    private BigInteger UnblindMessage(BigInteger blindedMsg);
}
public class Org.BouncyCastle.Crypto.Engines.RsaCoreEngine : object {
    private RsaKeyParameters key;
    private bool forEncryption;
    private int bitSize;
    private void CheckInitialised();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual BigInteger ConvertInput(Byte[] inBuf, int inOff, int inLen);
    public virtual Byte[] ConvertOutput(BigInteger result);
    public virtual BigInteger ProcessBlock(BigInteger input);
}
public class Org.BouncyCastle.Crypto.Engines.RsaEngine : object {
    private IRsa core;
    public string AlgorithmName { get; }
    public RsaEngine(IRsa rsa);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.Salsa20Engine : object {
    public static int DEFAULT_ROUNDS;
    private static int StateSize;
    private static UInt32[] TAU_SIGMA;
    protected int rounds;
    internal int index;
    internal UInt32[] engineState;
    internal UInt32[] x;
    internal Byte[] keyStream;
    internal bool initialised;
    private UInt32 cW0;
    private UInt32 cW1;
    private UInt32 cW2;
    protected int NonceSize { get; }
    public string AlgorithmName { get; }
    public Salsa20Engine(int rounds);
    private static Salsa20Engine();
    internal static void PackTauOrSigma(int keyLength, UInt32[] state, int stateOffset);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual int get_NonceSize();
    public virtual string get_AlgorithmName();
    public virtual byte ReturnByte(byte input);
    protected virtual void AdvanceCounter();
    public virtual void ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public virtual void Reset();
    protected virtual void ResetCounter();
    protected virtual void SetKey(Byte[] keyBytes, Byte[] ivBytes);
    protected virtual void GenerateKeyStream(Byte[] output);
    internal static void SalsaCore(int rounds, UInt32[] input, UInt32[] output);
    internal void ResetLimitCounter();
    internal bool LimitExceeded();
    internal bool LimitExceeded(UInt32 len);
    private static void QuarterRound(UInt32& a, UInt32& b, UInt32& c, UInt32& d);
}
public class Org.BouncyCastle.Crypto.Engines.SeedEngine : object {
    private static int BlockSize;
    private static UInt32[] SS0;
    private static UInt32[] SS1;
    private static UInt32[] SS2;
    private static UInt32[] SS3;
    private static UInt32[] KC;
    private Int32[] wKey;
    private bool forEncryption;
    public string AlgorithmName { get; }
    private static SeedEngine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    private Int32[] CreateWorkingKey(Byte[] inKey);
    private int extractW1(long lVal);
    private int extractW0(long lVal);
    private long rotateLeft8(long x);
    private long rotateRight8(long x);
    private int G(int x);
    private long F(int ki0, int ki1, long r);
    private int phaseCalc1(int r0, int ki0, int r1, int ki1);
    private int phaseCalc2(int r0, int ki0, int r1, int ki1);
}
public class Org.BouncyCastle.Crypto.Engines.SeedWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.SerpentEngine : SerpentEngineBase {
    internal virtual Int32[] MakeWorkingKey(Byte[] key);
    internal virtual void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    internal virtual void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public abstract class Org.BouncyCastle.Crypto.Engines.SerpentEngineBase : object {
    protected static int BlockSize;
    internal static int ROUNDS;
    internal static int PHI;
    protected bool encrypting;
    protected Int32[] wKey;
    protected int X0;
    protected int X1;
    protected int X2;
    protected int X3;
    public string AlgorithmName { get; }
    private static SerpentEngineBase();
    public virtual void Init(bool encrypting, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    protected void Sb0(int a, int b, int c, int d);
    protected void Ib0(int a, int b, int c, int d);
    protected void Sb1(int a, int b, int c, int d);
    protected void Ib1(int a, int b, int c, int d);
    protected void Sb2(int a, int b, int c, int d);
    protected void Ib2(int a, int b, int c, int d);
    protected void Sb3(int a, int b, int c, int d);
    protected void Ib3(int a, int b, int c, int d);
    protected void Sb4(int a, int b, int c, int d);
    protected void Ib4(int a, int b, int c, int d);
    protected void Sb5(int a, int b, int c, int d);
    protected void Ib5(int a, int b, int c, int d);
    protected void Sb6(int a, int b, int c, int d);
    protected void Ib6(int a, int b, int c, int d);
    protected void Sb7(int a, int b, int c, int d);
    protected void Ib7(int a, int b, int c, int d);
    protected void LT();
    protected void InverseLT();
    internal abstract virtual Int32[] MakeWorkingKey(Byte[] key);
    internal abstract virtual void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    internal abstract virtual void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.SkipjackEngine : object {
    private static int BLOCK_SIZE;
    private static Int16[] ftable;
    private Int32[] key0;
    private Int32[] key1;
    private Int32[] key2;
    private Int32[] key3;
    private bool encrypting;
    public string AlgorithmName { get; }
    private static SkipjackEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int G(int k, int w);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int H(int k, int w);
}
public class Org.BouncyCastle.Crypto.Engines.SM2Engine : object {
    private IDigest mDigest;
    private Mode mMode;
    private bool mForEncryption;
    private ECKeyParameters mECKey;
    private ECDomainParameters mECParams;
    private int mCurveLength;
    private SecureRandom mRandom;
    public SM2Engine(Mode mode);
    public SM2Engine(IDigest digest);
    public SM2Engine(IDigest digest, Mode mode);
    public virtual void Init(bool forEncryption, ICipherParameters param);
    public virtual Byte[] ProcessBlock(Byte[] input, int inOff, int inLen);
    protected virtual ECMultiplier CreateBasePointMultiplier();
    private Byte[] Encrypt(Byte[] input, int inOff, int inLen);
    private Byte[] Decrypt(Byte[] input, int inOff, int inLen);
    private bool NotEncrypted(Byte[] encData, Byte[] input, int inOff);
    private void Kdf(IDigest digest, ECPoint c1, Byte[] encData);
    private void Xor(Byte[] data, Byte[] kdfOut, int dOff, int dRemaining);
    private BigInteger NextK();
    private void AddFieldElement(IDigest digest, ECFieldElement v);
}
public class Org.BouncyCastle.Crypto.Engines.SM4Engine : object {
    private static int BlockSize;
    private static Byte[] Sbox;
    private static UInt32[] CK;
    private static UInt32[] FK;
    private UInt32[] rk;
    public string AlgorithmName { get; }
    private static SM4Engine();
    private static UInt32 tau(UInt32 A);
    private static UInt32 L_ap(UInt32 B);
    private UInt32 T_ap(UInt32 Z);
    private void ExpandKey(bool forEncryption, Byte[] key);
    private static UInt32 L(UInt32 B);
    private static UInt32 T(UInt32 Z);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.TeaEngine : object {
    private static int rounds;
    private static int block_size;
    private static UInt32 delta;
    private static UInt32 d_sum;
    private UInt32 _a;
    private UInt32 _b;
    private UInt32 _c;
    private UInt32 _d;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.ThreefishEngine : object {
    public static int BLOCKSIZE_256;
    public static int BLOCKSIZE_512;
    public static int BLOCKSIZE_1024;
    private static int TWEAK_SIZE_BYTES;
    private static int TWEAK_SIZE_WORDS;
    private static int ROUNDS_256;
    private static int ROUNDS_512;
    private static int ROUNDS_1024;
    private static int MAX_ROUNDS;
    private static ulong C_240;
    private static Int32[] MOD9;
    private static Int32[] MOD17;
    private static Int32[] MOD5;
    private static Int32[] MOD3;
    private int blocksizeBytes;
    private int blocksizeWords;
    private UInt64[] currentBlock;
    private UInt64[] t;
    private UInt64[] kw;
    private ThreefishCipher cipher;
    private bool forEncryption;
    public string AlgorithmName { get; }
    private static ThreefishEngine();
    public ThreefishEngine(int blocksizeBits);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    internal void Init(bool forEncryption, UInt64[] key, UInt64[] tweak);
    private void SetKey(UInt64[] key);
    private void SetTweak(UInt64[] tweak);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    internal int ProcessBlock(UInt64[] inWords, UInt64[] outWords);
    private static ulong RotlXor(ulong x, int n, ulong xor);
    private static ulong XorRotr(ulong x, int n, ulong xor);
}
public class Org.BouncyCastle.Crypto.Engines.TnepresEngine : SerpentEngineBase {
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    internal virtual Int32[] MakeWorkingKey(Byte[] key);
    internal virtual void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    internal virtual void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.TwofishEngine : object {
    private static Byte[0...,0...] P;
    private static int P_00;
    private static int P_01;
    private static int P_02;
    private static int P_03;
    private static int P_04;
    private static int P_10;
    private static int P_11;
    private static int P_12;
    private static int P_13;
    private static int P_14;
    private static int P_20;
    private static int P_21;
    private static int P_22;
    private static int P_23;
    private static int P_24;
    private static int P_30;
    private static int P_31;
    private static int P_32;
    private static int P_33;
    private static int P_34;
    private static int GF256_FDBK;
    private static int GF256_FDBK_2;
    private static int GF256_FDBK_4;
    private static int RS_GF_FDBK;
    private static int ROUNDS;
    private static int MAX_ROUNDS;
    private static int BLOCK_SIZE;
    private static int MAX_KEY_BITS;
    private static int INPUT_WHITEN;
    private static int OUTPUT_WHITEN;
    private static int ROUND_SUBKEYS;
    private static int TOTAL_SUBKEYS;
    private static int SK_STEP;
    private static int SK_BUMP;
    private static int SK_ROTL;
    private bool encrypting;
    private Int32[] gMDS0;
    private Int32[] gMDS1;
    private Int32[] gMDS2;
    private Int32[] gMDS3;
    private Int32[] gSubKeys;
    private Int32[] gSBox;
    private int k64Cnt;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    private static TwofishEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual int GetBlockSize();
    private void SetKey(Byte[] key);
    private void EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private int F32(int x, Int32[] k32);
    private int RS_MDS_Encode(int k0, int k1);
    private int RS_rem(int x);
    private int LFSR1(int x);
    private int LFSR2(int x);
    private int Mx_X(int x);
    private int Mx_Y(int x);
    private int M_b0(int x);
    private int M_b1(int x);
    private int M_b2(int x);
    private int M_b3(int x);
    private int Fe32_0(int x);
    private int Fe32_3(int x);
}
public class Org.BouncyCastle.Crypto.Engines.VmpcEngine : object {
    protected byte n;
    protected Byte[] P;
    protected byte s;
    protected Byte[] workingIV;
    protected Byte[] workingKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual void InitKey(Byte[] keyBytes, Byte[] ivBytes);
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual byte ReturnByte(byte input);
    internal static void KsaRound(Byte[] P, Byte& S, Byte[] input);
}
public class Org.BouncyCastle.Crypto.Engines.VmpcKsa3Engine : VmpcEngine {
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    protected virtual void InitKey(Byte[] keyBytes, Byte[] ivBytes);
}
public class Org.BouncyCastle.Crypto.Engines.XSalsa20Engine : Salsa20Engine {
    public string AlgorithmName { get; }
    protected int NonceSize { get; }
    public virtual string get_AlgorithmName();
    protected virtual int get_NonceSize();
    protected virtual void SetKey(Byte[] keyBytes, Byte[] ivBytes);
}
public class Org.BouncyCastle.Crypto.Engines.XteaEngine : object {
    private static int rounds;
    private static int block_size;
    private static int delta;
    private UInt32[] _S;
    private UInt32[] _sum0;
    private UInt32[] _sum1;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private void setKey(Byte[] key);
    private int EncryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
}
public abstract class Org.BouncyCastle.Crypto.Fpe.FpeEngine : object {
    protected IBlockCipher baseCipher;
    protected bool forEncryption;
    protected FpeParameters fpeParameters;
    protected FpeEngine(IBlockCipher baseCipher);
    public virtual int ProcessBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
    protected static bool IsOverrideSet(string propName);
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected abstract virtual int EncryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
    protected abstract virtual int DecryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
}
public class Org.BouncyCastle.Crypto.Fpe.FpeFf1Engine : FpeEngine {
    public FpeFf1Engine(IBlockCipher baseCipher);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual int EncryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
    protected virtual int DecryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
}
public class Org.BouncyCastle.Crypto.Fpe.FpeFf3_1Engine : FpeEngine {
    public FpeFf3_1Engine(IBlockCipher baseCipher);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual int EncryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
    protected virtual int DecryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
    private static KeyParameter ReverseKey(KeyParameter key);
}
internal static class Org.BouncyCastle.Crypto.Fpe.SP80038G : object {
    internal static string FPE_DISABLED;
    internal static string FF1_DISABLED;
    private static int BLOCK_SIZE;
    private static double LOG2;
    private static double TWO_TO_96;
    private static SP80038G();
    public static Byte[] DecryptFF1(IBlockCipher cipher, int radix, Byte[] tweak, Byte[] buf, int off, int len);
    public static UInt16[] DecryptFF1w(IBlockCipher cipher, int radix, Byte[] tweak, UInt16[] buf, int off, int len);
    private static UInt16[] DecFF1(IBlockCipher cipher, int radix, Byte[] T, int n, int u, int v, UInt16[] A, UInt16[] B);
    public static Byte[] DecryptFF3(IBlockCipher cipher, int radix, Byte[] tweak64, Byte[] buf, int off, int len);
    public static Byte[] DecryptFF3_1(IBlockCipher cipher, int radix, Byte[] tweak56, Byte[] buf, int off, int len);
    public static UInt16[] DecryptFF3_1w(IBlockCipher cipher, int radix, Byte[] tweak56, UInt16[] buf, int off, int len);
    public static Byte[] EncryptFF1(IBlockCipher cipher, int radix, Byte[] tweak, Byte[] buf, int off, int len);
    public static UInt16[] EncryptFF1w(IBlockCipher cipher, int radix, Byte[] tweak, UInt16[] buf, int off, int len);
    private static UInt16[] EncFF1(IBlockCipher cipher, int radix, Byte[] T, int n, int u, int v, UInt16[] A, UInt16[] B);
    public static Byte[] EncryptFF3(IBlockCipher cipher, int radix, Byte[] tweak64, Byte[] buf, int off, int len);
    public static UInt16[] EncryptFF3w(IBlockCipher cipher, int radix, Byte[] tweak64, UInt16[] buf, int off, int len);
    public static UInt16[] EncryptFF3_1w(IBlockCipher cipher, int radix, Byte[] tweak56, UInt16[] buf, int off, int len);
    public static Byte[] EncryptFF3_1(IBlockCipher cipher, int radix, Byte[] tweak56, Byte[] buf, int off, int len);
    private static int CalculateB_FF1(int radix, int v);
    private static BigInteger[] CalculateModUV(BigInteger bigRadix, int u, int v);
    private static Byte[] CalculateP_FF1(int radix, byte uLow, int n, int t);
    private static Byte[] CalculateTweak64_FF3_1(Byte[] tweak56);
    private static BigInteger CalculateY_FF1(IBlockCipher cipher, BigInteger bigRadix, Byte[] T, int b, int d, int round, Byte[] P, UInt16[] AB);
    private static BigInteger CalculateY_FF3(IBlockCipher cipher, BigInteger bigRadix, Byte[] T, int wOff, UInt32 round, UInt16[] AB);
    private static void CheckArgs(IBlockCipher cipher, bool isFF1, int radix, UInt16[] buf, int off, int len);
    private static void CheckArgs(IBlockCipher cipher, bool isFF1, int radix, Byte[] buf, int off, int len);
    private static void CheckCipher(IBlockCipher cipher);
    private static void CheckData(bool isFF1, int radix, UInt16[] buf, int off, int len);
    private static void CheckData(bool isFF1, int radix, Byte[] buf, int off, int len);
    private static void CheckLength(bool isFF1, int radix, int len);
    private static Byte[] ImplDecryptFF3(IBlockCipher cipher, int radix, Byte[] tweak64, Byte[] buf, int off, int len);
    private static UInt16[] ImplDecryptFF3w(IBlockCipher cipher, int radix, Byte[] tweak64, UInt16[] buf, int off, int len);
    private static UInt16[] DecFF3_1(IBlockCipher cipher, int radix, Byte[] T, int n, int v, int u, UInt16[] A, UInt16[] B);
    private static Byte[] ImplEncryptFF3(IBlockCipher cipher, int radix, Byte[] tweak64, Byte[] buf, int off, int len);
    private static UInt16[] ImplEncryptFF3w(IBlockCipher cipher, int radix, Byte[] tweak64, UInt16[] buf, int off, int len);
    private static UInt16[] EncFF3_1(IBlockCipher cipher, int radix, Byte[] t, int n, int v, int u, UInt16[] a, UInt16[] b);
    private static BigInteger Num(BigInteger R, UInt16[] x);
    private static Byte[] Prf(IBlockCipher c, Byte[] x);
    private static void Str(BigInteger R, BigInteger x, int m, UInt16[] output, int off);
    private static Byte[] ToByte(UInt16[] buf);
    private static UInt16[] ToShort(Byte[] buf, int off, int len);
}
public abstract class Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator : object {
    private int counterStart;
    private IDigest digest;
    private Byte[] shared;
    private Byte[] iv;
    public IDigest Digest { get; }
    protected BaseKdfBytesGenerator(int counterStart, IDigest digest);
    public sealed virtual void Init(IDerivationParameters parameters);
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Generators.BCrypt : object {
    private static UInt32[] MAGIC_STRING;
    internal static int MAGIC_STRING_LENGTH;
    private static UInt32[] KP;
    private static UInt32[] KS0;
    private static UInt32[] KS1;
    private static UInt32[] KS2;
    private static UInt32[] KS3;
    private static int ROUNDS;
    private static int SBOX_SK;
    private static int SBOX_SK2;
    private static int SBOX_SK3;
    private static int P_SZ;
    private UInt32[] S;
    private UInt32[] P;
    internal static int SALT_SIZE_BYTES;
    internal static int MIN_COST;
    internal static int MAX_COST;
    internal static int MAX_PASSWORD_BYTES;
    private static BCrypt();
    private UInt32 F(UInt32 x);
    private void ProcessTable(UInt32 xl, UInt32 xr, UInt32[] table);
    private void InitState();
    private void CyclicXorKey(Byte[] key);
    private Byte[] EncryptMagicString();
    private void ProcessTableWithSalt(UInt32[] table, UInt32[] salt32Bit, UInt32 iv1, UInt32 iv2);
    private Byte[] DeriveRawKey(int cost, Byte[] salt, Byte[] psw);
    public static Byte[] PasswordToByteArray(Char[] password);
    public static Byte[] Generate(Byte[] password, Byte[] salt, int cost);
}
public class Org.BouncyCastle.Crypto.Generators.DesEdeKeyGenerator : DesKeyGenerator {
    internal DesEdeKeyGenerator(int defaultStrength);
    protected virtual void EngineInit(KeyGenerationParameters parameters);
    protected virtual Byte[] EngineGenerateKey();
}
public class Org.BouncyCastle.Crypto.Generators.DesKeyGenerator : CipherKeyGenerator {
    internal DesKeyGenerator(int defaultStrength);
    protected virtual void EngineInit(KeyGenerationParameters parameters);
    protected virtual Byte[] EngineGenerateKey();
}
public class Org.BouncyCastle.Crypto.Generators.DHBasicKeyPairGenerator : object {
    private DHKeyGenerationParameters param;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
internal class Org.BouncyCastle.Crypto.Generators.DHKeyGeneratorHelper : object {
    internal static DHKeyGeneratorHelper Instance;
    private static DHKeyGeneratorHelper();
    internal BigInteger CalculatePrivate(DHParameters dhParams, SecureRandom random);
    internal BigInteger CalculatePublic(DHParameters dhParams, BigInteger x);
}
public class Org.BouncyCastle.Crypto.Generators.DHKeyPairGenerator : object {
    private DHKeyGenerationParameters param;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.DHParametersGenerator : object {
    private int size;
    private int certainty;
    private SecureRandom random;
    public virtual void Init(int size, int certainty, SecureRandom random);
    public virtual DHParameters GenerateParameters();
}
internal class Org.BouncyCastle.Crypto.Generators.DHParametersHelper : object {
    private static BigInteger Six;
    private static Int32[][] primeLists;
    private static Int32[] primeProducts;
    private static BigInteger[] BigPrimeProducts;
    private static DHParametersHelper();
    private static BigInteger[] ConstructBigPrimeProducts(Int32[] primeProducts);
    internal static BigInteger[] GenerateSafePrimes(int size, int certainty, SecureRandom random);
    internal static BigInteger SelectGenerator(BigInteger p, BigInteger q, SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Generators.DsaKeyPairGenerator : object {
    private static BigInteger One;
    private DsaKeyGenerationParameters param;
    private static DsaKeyPairGenerator();
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    private static BigInteger GeneratePrivateKey(BigInteger q, SecureRandom random);
    private static BigInteger CalculatePublicKey(BigInteger p, BigInteger g, BigInteger x);
}
public class Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator : object {
    private IDigest digest;
    private int L;
    private int N;
    private int certainty;
    private SecureRandom random;
    private bool use186_3;
    private int usageIndex;
    public DsaParametersGenerator(IDigest digest);
    public virtual void Init(int size, int certainty, SecureRandom random);
    public virtual void Init(DsaParameterGenerationParameters parameters);
    public virtual DsaParameters GenerateParameters();
    protected virtual DsaParameters GenerateParameters_FIPS186_2();
    protected virtual BigInteger CalculateGenerator_FIPS186_2(BigInteger p, BigInteger q, SecureRandom r);
    protected virtual DsaParameters GenerateParameters_FIPS186_3();
    protected virtual BigInteger CalculateGenerator_FIPS186_3_Unverifiable(BigInteger p, BigInteger q, SecureRandom r);
    protected virtual BigInteger CalculateGenerator_FIPS186_3_Verifiable(IDigest d, BigInteger p, BigInteger q, Byte[] seed, int index);
    private static bool IsValidDsaStrength(int strength);
    protected static void Hash(IDigest d, Byte[] input, Byte[] output);
    private static int GetDefaultN(int L);
    protected static void Inc(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Generators.ECKeyPairGenerator : object {
    private string algorithm;
    private ECDomainParameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    private SecureRandom random;
    public ECKeyPairGenerator(string algorithm);
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    protected virtual ECMultiplier CreateBasePointMultiplier();
    internal static X9ECParameters FindECCurveByName(string name);
    internal static X9ECParametersHolder FindECCurveByNameLazy(string name);
    internal static X9ECParameters FindECCurveByOid(DerObjectIdentifier oid);
    internal static X9ECParametersHolder FindECCurveByOidLazy(DerObjectIdentifier oid);
    internal static ECPublicKeyParameters GetCorrespondingPublicKey(ECPrivateKeyParameters privKey);
}
public class Org.BouncyCastle.Crypto.Generators.Ed25519KeyPairGenerator : object {
    private SecureRandom random;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.Ed448KeyPairGenerator : object {
    private SecureRandom random;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.ElGamalKeyPairGenerator : object {
    private ElGamalKeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.ElGamalParametersGenerator : object {
    private int size;
    private int certainty;
    private SecureRandom random;
    public void Init(int size, int certainty, SecureRandom random);
    public ElGamalParameters GenerateParameters();
}
public class Org.BouncyCastle.Crypto.Generators.Gost3410KeyPairGenerator : object {
    private Gost3410KeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator : object {
    private int size;
    private int typeproc;
    private SecureRandom init_random;
    public void Init(int size, int typeProcedure, SecureRandom random);
    private int procedure_A(int x0, int c, BigInteger[] pq, int size);
    private long procedure_Aa(long x0, long c, BigInteger[] pq, int size);
    private void procedure_B(int x0, int c, BigInteger[] pq);
    private void procedure_Bb(long x0, long c, BigInteger[] pq);
    private BigInteger procedure_C(BigInteger p, BigInteger q);
    public Gost3410Parameters GenerateParameters();
}
public class Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator : object {
    private HMac hMacHash;
    private int hashLen;
    private Byte[] info;
    private Byte[] currentT;
    private int generatedBytes;
    public IDigest Digest { get; }
    public HkdfBytesGenerator(IDigest hash);
    public sealed virtual void Init(IDerivationParameters parameters);
    private KeyParameter Extract(Byte[] salt, Byte[] ikm);
    private void ExpandNext();
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator : BaseKdfBytesGenerator {
    public Kdf1BytesGenerator(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator : BaseKdfBytesGenerator {
    public Kdf2BytesGenerator(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Generators.KdfCounterBytesGenerator : object {
    private IMac prf;
    private int h;
    private Byte[] fixedInputDataCtrPrefix;
    private Byte[] fixedInputData_afterCtr;
    private int maxSizeExcl;
    private Byte[] ios;
    private int generatedBytes;
    private Byte[] k;
    public IMac Mac { get; }
    public IDigest Digest { get; }
    public KdfCounterBytesGenerator(IMac prf);
    public sealed virtual void Init(IDerivationParameters param);
    public sealed virtual IMac get_Mac();
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
    private void GenerateNext();
}
public class Org.BouncyCastle.Crypto.Generators.KdfDoublePipelineIterationBytesGenerator : object {
    private IMac prf;
    private int h;
    private Byte[] fixedInputData;
    private int maxSizeExcl;
    private Byte[] ios;
    private bool useCounter;
    private int generatedBytes;
    private Byte[] a;
    private Byte[] k;
    public IMac Mac { get; }
    public IDigest Digest { get; }
    public KdfDoublePipelineIterationBytesGenerator(IMac prf);
    public sealed virtual void Init(IDerivationParameters parameters);
    public sealed virtual IMac get_Mac();
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
    private void GenerateNext();
}
public class Org.BouncyCastle.Crypto.Generators.KdfFeedbackBytesGenerator : object {
    private IMac prf;
    private int h;
    private Byte[] fixedInputData;
    private int maxSizeExcl;
    private Byte[] ios;
    private Byte[] iv;
    private bool useCounter;
    private int generatedBytes;
    private Byte[] k;
    public IMac Mac { get; }
    public IDigest Digest { get; }
    public KdfFeedbackBytesGenerator(IMac prf);
    public sealed virtual void Init(IDerivationParameters parameters);
    public sealed virtual IMac get_Mac();
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
    private void GenerateNext();
}
public class Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator : object {
    private IDigest m_digest;
    private int m_hLen;
    private Byte[] m_buffer;
    public IDigest Digest { get; }
    public Mgf1BytesGenerator(IDigest digest);
    public sealed virtual void Init(IDerivationParameters parameters);
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator : object {
    private static Int32[] smallPrimes;
    private NaccacheSternKeyGenerationParameters param;
    private static NaccacheSternKeyPairGenerator();
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    private static BigInteger GeneratePrime(int bitLength, int certainty, SecureRandom rand);
    private static IList`1<T> PermuteList(IList`1<T> arr, SecureRandom rand);
    private static IList`1<BigInteger> FindFirstPrimes(int count);
}
public class Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt : object {
    private static Byte[] EncodingTable;
    private static Byte[] DecodingTable;
    private static string DefaultVersion;
    private static HashSet`1<string> AllowedVersions;
    private static OpenBsdBCrypt();
    private static string CreateBcryptString(string version, Byte[] password, Byte[] salt, int cost);
    public static string Generate(Char[] password, Byte[] salt, int cost);
    public static string Generate(string version, Char[] password, Byte[] salt, int cost);
    public static bool CheckPassword(string bcryptString, Char[] password);
    private static string EncodeData(Byte[] data);
    private static Byte[] DecodeSaltString(string saltString);
}
public class Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator : PbeParametersGenerator {
    private IDigest digest;
    public OpenSslPbeParametersGenerator(IDigest digest);
    public virtual void Init(Byte[] password, Byte[] salt, int iterationCount);
    public virtual void Init(Byte[] password, Byte[] salt);
    private Byte[] GenerateDerivedKey(int bytesNeeded);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator : PbeParametersGenerator {
    public static int KeyMaterial;
    public static int IVMaterial;
    public static int MacMaterial;
    private IDigest digest;
    private int u;
    private int v;
    public Pkcs12ParametersGenerator(IDigest digest);
    private void Adjust(Byte[] a, int aOff, Byte[] b);
    private Byte[] GenerateDerivedKey(int idByte, int n);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator : PbeParametersGenerator {
    private IDigest digest;
    public Pkcs5S1ParametersGenerator(IDigest digest);
    private Byte[] GenerateDerivedKey();
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator : PbeParametersGenerator {
    private IMac hMac;
    private Byte[] state;
    public Pkcs5S2ParametersGenerator(IDigest digest);
    private void F(Byte[] S, int c, Byte[] iBuf, Byte[] outBytes, int outOff);
    private Byte[] GenerateDerivedKey(int dkLen);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator : CipherKeyGenerator {
    private static byte R_MASK_LOW_2;
    private static byte R_MASK_HIGH_4;
    protected virtual void EngineInit(KeyGenerationParameters param);
    protected virtual Byte[] EngineGenerateKey();
    public static void Clamp(Byte[] key);
    public static void CheckKey(Byte[] key);
    private static void CheckMask(byte b, byte mask);
}
public class Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator : object {
    private RsaKeyParameters key;
    private SecureRandom random;
    public void Init(ICipherParameters param);
    public BigInteger GenerateBlindingFactor();
}
public class Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator : object {
    private static Int32[] SPECIAL_E_VALUES;
    private static int SPECIAL_E_HIGHEST;
    private static int SPECIAL_E_BITS;
    protected static BigInteger One;
    protected static BigInteger DefaultPublicExponent;
    protected static int DefaultTests;
    protected RsaKeyGenerationParameters parameters;
    private static RsaKeyPairGenerator();
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
    protected virtual BigInteger ChooseRandomPrime(int bitlength, BigInteger e);
}
public class Org.BouncyCastle.Crypto.Generators.SCrypt : object {
    public static Byte[] Generate(Byte[] P, Byte[] S, int N, int r, int p, int dkLen);
    private static Byte[] MFcrypt(Byte[] P, Byte[] S, int N, int r, int p, int dkLen);
    private static Byte[] SingleIterationPBKDF2(Byte[] P, Byte[] S, int dkLen);
    private static void SMix(UInt32[] B, int BOff, int N, int d, int r);
    private static void BlockMix(UInt32[] B, UInt32[] X1, UInt32[] Y, int r);
    private static void Clear(Array array);
    private static void ClearAll(Array[] arrays);
    private static bool IsPowerOf2(int x);
}
public class Org.BouncyCastle.Crypto.Generators.X25519KeyPairGenerator : object {
    private SecureRandom random;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.X448KeyPairGenerator : object {
    private SecureRandom random;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public interface Org.BouncyCastle.Crypto.IAlphabetMapper {
    public int Radix { get; }
    public abstract virtual int get_Radix();
    public abstract virtual Byte[] ConvertToIndexes(Char[] input);
    public abstract virtual Char[] ConvertToChars(Byte[] input);
}
public interface Org.BouncyCastle.Crypto.IAsymmetricBlockCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetInputBlockSize();
    public abstract virtual int GetOutputBlockSize();
    public abstract virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public interface Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator {
    public abstract virtual void Init(KeyGenerationParameters parameters);
    public abstract virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public interface Org.BouncyCastle.Crypto.IBasicAgreement {
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual int GetFieldSize();
    public abstract virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public interface Org.BouncyCastle.Crypto.IBlockCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
}
public interface Org.BouncyCastle.Crypto.IBlockResult {
    public abstract virtual Byte[] Collect();
    public abstract virtual int Collect(Byte[] buf, int off);
    public abstract virtual int GetMaxResultLength();
}
public interface Org.BouncyCastle.Crypto.IBufferedCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public abstract virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public abstract virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public abstract virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public abstract virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.ICipher {
    public Stream Stream { get; }
    public abstract virtual int GetMaxOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Stream get_Stream();
}
public interface Org.BouncyCastle.Crypto.ICipherBuilder {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual int GetMaxOutputSize(int inputLen);
    public abstract virtual ICipher BuildCipher(Stream stream);
}
public interface Org.BouncyCastle.Crypto.ICipherBuilderWithKey {
    public ICipherParameters Key { get; }
    public abstract virtual ICipherParameters get_Key();
}
public interface Org.BouncyCastle.Crypto.ICipherParameters {
}
public interface Org.BouncyCastle.Crypto.IDecryptorBuilderProvider {
    public abstract virtual ICipherBuilder CreateDecryptorBuilder(object algorithmDetails);
}
public interface Org.BouncyCastle.Crypto.IDerivationFunction {
    public IDigest Digest { get; }
    public abstract virtual void Init(IDerivationParameters parameters);
    public abstract virtual IDigest get_Digest();
    public abstract virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public interface Org.BouncyCastle.Crypto.IDerivationParameters {
}
public interface Org.BouncyCastle.Crypto.IDigest {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int GetByteLength();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IDigestFactory {
    public object AlgorithmDetails { get; }
    public int DigestLength { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual int get_DigestLength();
    public abstract virtual IStreamCalculator`1<IBlockResult> CreateCalculator();
}
public interface Org.BouncyCastle.Crypto.IDsa {
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual BigInteger[] GenerateSignature(Byte[] message);
    public abstract virtual BigInteger get_Order();
    public abstract virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public interface Org.BouncyCastle.Crypto.IEncapsulatedSecretExtractor {
    public int EncapsulationLength { get; }
    public abstract virtual Byte[] ExtractSecret(Byte[] encapsulation);
    public abstract virtual int get_EncapsulationLength();
}
public interface Org.BouncyCastle.Crypto.IEncapsulatedSecretGenerator {
    public abstract virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
}
public interface Org.BouncyCastle.Crypto.IEntropySource {
    public bool IsPredictionResistant { get; }
    public int EntropySize { get; }
    public abstract virtual bool get_IsPredictionResistant();
    public abstract virtual Byte[] GetEntropy();
    public abstract virtual int get_EntropySize();
}
public interface Org.BouncyCastle.Crypto.IEntropySourceProvider {
    public abstract virtual IEntropySource Get(int bitsRequired);
}
public interface Org.BouncyCastle.Crypto.IKeyUnwrapper {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IBlockResult Unwrap(Byte[] cipherText, int offset, int length);
}
public interface Org.BouncyCastle.Crypto.IKeyWrapper {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IBlockResult Wrap(Byte[] keyData);
}
public interface Org.BouncyCastle.Crypto.IMac {
    public string AlgorithmName { get; }
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetMacSize();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IMacDerivationFunction {
    public IMac Mac { get; }
    public abstract virtual IMac get_Mac();
}
public interface Org.BouncyCastle.Crypto.IMacFactory {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IStreamCalculator`1<IBlockResult> CreateCalculator();
}
public class Org.BouncyCastle.Crypto.InvalidCipherTextException : CryptoException {
    public InvalidCipherTextException(string message);
    public InvalidCipherTextException(string message, Exception innerException);
    protected InvalidCipherTextException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Crypto.IO.CipherStream : Stream {
    private Stream m_stream;
    private IBufferedCipher m_readCipher;
    private IBufferedCipher m_writeCipher;
    private Byte[] m_readBuf;
    private int m_readBufPos;
    private bool m_readEnded;
    public IBufferedCipher ReadCipher { get; }
    public IBufferedCipher WriteCipher { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private Stream ReadSource { get; }
    private Stream WriteDestination { get; }
    public CipherStream(Stream stream, IBufferedCipher readCipher, IBufferedCipher writeCipher);
    public IBufferedCipher get_ReadCipher();
    public IBufferedCipher get_WriteCipher();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    private bool FillInBuf();
    private Byte[] ReadAndProcessBlock();
    private Stream get_ReadSource();
    private Stream get_WriteDestination();
}
public class Org.BouncyCastle.Crypto.IO.DigestSink : BaseOutputStream {
    private IDigest m_digest;
    public IDigest Digest { get; }
    public DigestSink(IDigest digest);
    public IDigest get_Digest();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class Org.BouncyCastle.Crypto.IO.DigestStream : Stream {
    private Stream m_stream;
    private IDigest m_readDigest;
    private IDigest m_writeDigest;
    public IDigest ReadDigest { get; }
    public IDigest WriteDigest { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private Stream ReadSource { get; }
    private Stream WriteDestination { get; }
    public DigestStream(Stream stream, IDigest readDigest, IDigest writeDigest);
    public IDigest get_ReadDigest();
    public IDigest get_WriteDigest();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    private Stream get_ReadSource();
    private Stream get_WriteDestination();
}
public class Org.BouncyCastle.Crypto.IO.MacSink : BaseOutputStream {
    private IMac m_mac;
    public IMac Mac { get; }
    public MacSink(IMac mac);
    public IMac get_Mac();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class Org.BouncyCastle.Crypto.IO.MacStream : Stream {
    private Stream m_stream;
    private IMac m_readMac;
    private IMac m_writeMac;
    public IMac ReadMac { get; }
    public IMac WriteMac { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private Stream ReadSource { get; }
    private Stream WriteDestination { get; }
    public MacStream(Stream stream, IMac readMac, IMac writeMac);
    public IMac get_ReadMac();
    public IMac get_WriteMac();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    private Stream get_ReadSource();
    private Stream get_WriteDestination();
}
public class Org.BouncyCastle.Crypto.IO.SignerSink : BaseOutputStream {
    private ISigner m_signer;
    public ISigner Signer { get; }
    public SignerSink(ISigner signer);
    public ISigner get_Signer();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class Org.BouncyCastle.Crypto.IO.SignerStream : Stream {
    private Stream m_stream;
    private ISigner m_readSigner;
    private ISigner m_writeSigner;
    public ISigner ReadSigner { get; }
    public ISigner WriteSigner { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private Stream ReadSource { get; }
    private Stream WriteDestination { get; }
    public SignerStream(Stream stream, ISigner readSigner, ISigner writeSigner);
    public ISigner get_ReadSigner();
    public ISigner get_WriteSigner();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    private Stream get_ReadSource();
    private Stream get_WriteDestination();
}
public interface Org.BouncyCastle.Crypto.IRawAgreement {
    public int AgreementSize { get; }
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual int get_AgreementSize();
    public abstract virtual void CalculateAgreement(ICipherParameters publicKey, Byte[] buf, int off);
}
public interface Org.BouncyCastle.Crypto.IRsa {
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetInputBlockSize();
    public abstract virtual int GetOutputBlockSize();
    public abstract virtual BigInteger ConvertInput(Byte[] buf, int off, int len);
    public abstract virtual BigInteger ProcessBlock(BigInteger input);
    public abstract virtual Byte[] ConvertOutput(BigInteger result);
}
public interface Org.BouncyCastle.Crypto.ISecretWithEncapsulation {
    public abstract virtual Byte[] GetSecret();
    public abstract virtual Byte[] GetEncapsulation();
}
public interface Org.BouncyCastle.Crypto.ISignatureFactory {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IStreamCalculator`1<IBlockResult> CreateCalculator();
}
public interface Org.BouncyCastle.Crypto.ISigner {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public abstract virtual int GetMaxSignatureSize();
    public abstract virtual Byte[] GenerateSignature();
    public abstract virtual bool VerifySignature(Byte[] signature);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.ISignerWithRecovery {
    public abstract virtual bool HasFullMessage();
    public abstract virtual Byte[] GetRecoveredMessage();
    public abstract virtual void UpdateWithRecoveredMessage(Byte[] signature);
}
public interface Org.BouncyCastle.Crypto.IStreamCalculator`1 {
    public Stream Stream { get; }
    public abstract virtual Stream get_Stream();
    public abstract virtual TResult GetResult();
}
public interface Org.BouncyCastle.Crypto.IStreamCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual byte ReturnByte(byte input);
    public abstract virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IVerifier {
    public abstract virtual bool IsVerified(Byte[] data);
    public abstract virtual bool IsVerified(Byte[] source, int off, int length);
}
public interface Org.BouncyCastle.Crypto.IVerifierFactory {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IStreamCalculator`1<IVerifier> CreateCalculator();
}
public interface Org.BouncyCastle.Crypto.IVerifierFactoryProvider {
    public abstract virtual IVerifierFactory CreateVerifierFactory(object algorithmDetails);
}
public interface Org.BouncyCastle.Crypto.IWrapper {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forWrapping, ICipherParameters parameters);
    public abstract virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
}
public interface Org.BouncyCastle.Crypto.IXof {
    public abstract virtual int OutputFinal(Byte[] output, int outOff, int outLen);
    public abstract virtual int Output(Byte[] output, int outOff, int outLen);
}
public class Org.BouncyCastle.Crypto.KeyGenerationParameters : object {
    private SecureRandom random;
    private int strength;
    public SecureRandom Random { get; }
    public int Strength { get; }
    public KeyGenerationParameters(SecureRandom random, int strength);
    public SecureRandom get_Random();
    public int get_Strength();
}
public class Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac : object {
    private Byte[] buf;
    private int bufOff;
    private IBlockCipherMode m_cipherMode;
    private IBlockCipherPadding padding;
    private int macSize;
    public string AlgorithmName { get; }
    public CbcBlockCipherMac(IBlockCipher cipher);
    public CbcBlockCipherMac(IBlockCipher cipher, IBlockCipherPadding padding);
    public CbcBlockCipherMac(IBlockCipher cipher, int macSizeInBits);
    public CbcBlockCipherMac(IBlockCipher cipher, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac : object {
    private Byte[] mac;
    private Byte[] Buffer;
    private int bufOff;
    private MacCfbBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    public string AlgorithmName { get; }
    public CfbBlockCipherMac(IBlockCipher cipher);
    public CfbBlockCipherMac(IBlockCipher cipher, IBlockCipherPadding padding);
    public CfbBlockCipherMac(IBlockCipher cipher, int cfbBitSize, int macSizeInBits);
    public CfbBlockCipherMac(IBlockCipher cipher, int cfbBitSize, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.CMac : object {
    private static byte CONSTANT_128;
    private static byte CONSTANT_64;
    private Byte[] ZEROES;
    private Byte[] mac;
    private Byte[] buf;
    private int bufOff;
    private IBlockCipherMode m_cipherMode;
    private int macSize;
    private Byte[] L;
    private Byte[] Lu;
    private Byte[] Lu2;
    public string AlgorithmName { get; }
    public CMac(IBlockCipher cipher);
    public CMac(IBlockCipher cipher, int macSizeInBits);
    public sealed virtual string get_AlgorithmName();
    private static int ShiftLeft(Byte[] block, Byte[] output);
    private static Byte[] DoubleLu(Byte[] input);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.Dstu7564Mac : object {
    private Dstu7564Digest engine;
    private int macSize;
    private ulong inputLength;
    private Byte[] paddedKey;
    private Byte[] invertedKey;
    public string AlgorithmName { get; }
    public Dstu7564Mac(int macSizeBits);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual void Update(byte input);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void Pad();
    private Byte[] PadKey(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Macs.Dstu7624Mac : object {
    private int macSize;
    private Dstu7624Engine engine;
    private int blockSize;
    private Byte[] c;
    private Byte[] cTemp;
    private Byte[] kDelta;
    private Byte[] buf;
    private int bufOff;
    public string AlgorithmName { get; }
    public Dstu7624Mac(int blockSizeBits, int q);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    private void ProcessBlock(Byte[] input, int inOff);
    private void Xor(Byte[] c, int cOff, Byte[] input, int inOff, Byte[] xorResult);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.GMac : object {
    private GcmBlockCipher cipher;
    private int macSizeBits;
    public string AlgorithmName { get; }
    public GMac(GcmBlockCipher cipher);
    public GMac(GcmBlockCipher cipher, int macSizeBits);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.Gost28147Mac : object {
    private static int BlockSize;
    private static int MacSize;
    private int bufOff;
    private Byte[] buf;
    private Byte[] mac;
    private bool firstStep;
    private Int32[] workingKey;
    private Byte[] macIV;
    private Byte[] S;
    public string AlgorithmName { get; }
    private static Int32[] GenerateWorkingKey(Byte[] userKey);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    private int Gost28147_mainStep(int n1, int key);
    private void Gost28147MacFunc(Int32[] workingKey, Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private static void Cm5Func(Byte[] buf, int bufOff, Byte[] mac, Byte[] sum);
}
public class Org.BouncyCastle.Crypto.Macs.HMac : object {
    private static byte IPAD;
    private static byte OPAD;
    private IDigest digest;
    private int digestSize;
    private int blockLength;
    private IMemoable ipadState;
    private IMemoable opadState;
    private Byte[] inputPad;
    private Byte[] outputBuf;
    public string AlgorithmName { get; }
    public HMac(IDigest digest);
    public HMac(IDigest digest, int blockLength);
    public virtual string get_AlgorithmName();
    public virtual IDigest GetUnderlyingDigest();
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetMacSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static void XorPad(Byte[] pad, int len, byte n);
}
public class Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac : object {
    private Byte[] mac;
    private Byte[] buf;
    private int bufOff;
    private IBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    private KeyParameter lastKey2;
    private KeyParameter lastKey3;
    public string AlgorithmName { get; }
    public ISO9797Alg3Mac(IBlockCipher cipher);
    public ISO9797Alg3Mac(IBlockCipher cipher, IBlockCipherPadding padding);
    public ISO9797Alg3Mac(IBlockCipher cipher, int macSizeInBits);
    public ISO9797Alg3Mac(IBlockCipher cipher, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.KMac : object {
    private static Byte[] padding;
    private CShakeDigest cshake;
    private int bitLength;
    private int outputLength;
    private Byte[] key;
    private bool initialised;
    private bool firstOutput;
    public string AlgorithmName { get; }
    public KMac(int bitLength, Byte[] S);
    private static KMac();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual int OutputFinal(Byte[] output, int outOff, int outLen);
    public sealed virtual int Output(Byte[] output, int outOff, int outLen);
    public sealed virtual int GetByteLength();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetMacSize();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual void Reset();
    private void bytePad(Byte[] X, int w);
    private static Byte[] encode(Byte[] X);
    public sealed virtual void Update(byte input);
}
internal class Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] cfbV;
    private Byte[] cfbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public IBlockCipher UnderlyingCipher { get; }
    public bool IsPartialBlockOkay { get; }
    public MacCfbBlockCipher(IBlockCipher cipher, int bitBlockSize);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    public void GetMacBlock(Byte[] mac);
}
public class Org.BouncyCastle.Crypto.Macs.Poly1305 : object {
    private static int BlockSize;
    private IBlockCipher cipher;
    private UInt32 r0;
    private UInt32 r1;
    private UInt32 r2;
    private UInt32 r3;
    private UInt32 r4;
    private UInt32 s1;
    private UInt32 s2;
    private UInt32 s3;
    private UInt32 s4;
    private UInt32 k0;
    private UInt32 k1;
    private UInt32 k2;
    private UInt32 k3;
    private Byte[] currentBlock;
    private int currentBlockOffset;
    private UInt32 h0;
    private UInt32 h1;
    private UInt32 h2;
    private UInt32 h3;
    private UInt32 h4;
    public string AlgorithmName { get; }
    public Poly1305(IBlockCipher cipher);
    public sealed virtual void Init(ICipherParameters parameters);
    private void SetKey(KeyParameter keyParameter, Byte[] nonce);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    private void ProcessBlock(Byte[] buf, int off);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.SipHash : object {
    protected int c;
    protected int d;
    protected long k0;
    protected long k1;
    protected long v0;
    protected long v1;
    protected long v2;
    protected long v3;
    protected long m;
    protected int wordPos;
    protected int wordCount;
    public string AlgorithmName { get; }
    public SipHash(int c, int d);
    public virtual string get_AlgorithmName();
    public virtual int GetMacSize();
    public virtual void Init(ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int offset, int length);
    public virtual long DoFinal();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void ProcessMessageWord();
    protected virtual void ApplySipRounds(int n);
    protected static long RotateLeft(long x, int n);
}
public class Org.BouncyCastle.Crypto.Macs.SkeinMac : object {
    public static int SKEIN_256;
    public static int SKEIN_512;
    public static int SKEIN_1024;
    private SkeinEngine engine;
    public string AlgorithmName { get; }
    public SkeinMac(int stateSizeBits, int digestSizeBits);
    public SkeinMac(SkeinMac mac);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Reset();
    public sealed virtual void Update(byte inByte);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Macs.VmpcMac : object {
    private byte g;
    private byte n;
    private Byte[] P;
    private byte s;
    private Byte[] T;
    private Byte[] workingIV;
    private Byte[] workingKey;
    private byte x1;
    private byte x2;
    private byte x3;
    private byte x4;
    public string AlgorithmName { get; }
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual string get_AlgorithmName();
    public virtual int GetMacSize();
    public virtual void Init(ICipherParameters parameters);
    private void InitKey(Byte[] keyBytes, Byte[] ivBytes);
    public virtual void Reset();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.MaxBytesExceededException : CryptoException {
    public MaxBytesExceededException(string message);
    public MaxBytesExceededException(string message, Exception innerException);
    protected MaxBytesExceededException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Crypto.Modes.CbcBlockCipher : object {
    private Byte[] IV;
    private Byte[] cbcV;
    private Byte[] cbcNextV;
    private int blockSize;
    private IBlockCipher cipher;
    private bool encrypting;
    public IBlockCipher UnderlyingCipher { get; }
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public CbcBlockCipher(IBlockCipher cipher);
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.CcmBlockCipher : object {
    private static int BlockSize;
    private IBlockCipher cipher;
    private Byte[] macBlock;
    private bool forEncryption;
    private Byte[] nonce;
    private Byte[] initialAssociatedText;
    private int macSize;
    private ICipherParameters keyParam;
    private MemoryStream associatedText;
    private MemoryStream data;
    public IBlockCipher UnderlyingCipher { get; }
    public string AlgorithmName { get; }
    public CcmBlockCipher(IBlockCipher cipher);
    private static CcmBlockCipher();
    public virtual IBlockCipher get_UnderlyingCipher();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int inLen, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual void Reset();
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public virtual int GetOutputSize(int len);
    public virtual Byte[] ProcessPacket(Byte[] input, int inOff, int inLen);
    public virtual int ProcessPacket(Byte[] input, int inOff, int inLen, Byte[] output, int outOff);
    private int CalculateMac(Byte[] data, int dataOff, int dataLen, Byte[] macBlock);
    private int GetMacSize(bool forEncryption, int requestedMacBits);
    private int GetAssociatedTextLength();
    private bool HasAssociatedText();
}
public class Org.BouncyCastle.Crypto.Modes.CfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] cfbV;
    private Byte[] cfbOutV;
    private bool encrypting;
    private int blockSize;
    private IBlockCipher cipher;
    public IBlockCipher UnderlyingCipher { get; }
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public CfbBlockCipher(IBlockCipher cipher, int bitBlockSize);
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.ChaCha20Poly1305 : object {
    private static int BufSize;
    private static int KeySize;
    private static int NonceSize;
    private static int MacSize;
    private static Byte[] Zeroes;
    private static ulong AadLimit;
    private static ulong DataLimit;
    private ChaCha7539Engine mChacha20;
    private IMac mPoly1305;
    private Byte[] mKey;
    private Byte[] mNonce;
    private Byte[] mBuf;
    private Byte[] mMac;
    private Byte[] mInitialAad;
    private ulong mAadCount;
    private ulong mDataCount;
    private State mState;
    private int mBufPos;
    public string AlgorithmName { get; }
    public ChaCha20Poly1305(IMac poly1305);
    private static ChaCha20Poly1305();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetOutputSize(int len);
    public virtual int GetUpdateOutputSize(int len);
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual Byte[] GetMac();
    public virtual void Reset();
    private void CheckAad();
    private void CheckData();
    private void FinishAad(State nextState);
    private void FinishData(State nextState);
    private ulong IncrementCount(ulong count, UInt32 increment, ulong limit);
    private void InitMac();
    private void PadMac(ulong count);
    private void ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private void ProcessBlocks2(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private void ProcessData(Byte[] inBytes, int inOff, int inLen, Byte[] outBytes, int outOff);
    private void Reset(bool clearMac, bool resetCipher);
}
public class Org.BouncyCastle.Crypto.Modes.CtsBlockCipher : BufferedBlockCipher {
    private int blockSize;
    public CtsBlockCipher(IBlockCipher cipher);
    public CtsBlockCipher(IBlockCipherMode cipherMode);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.EaxBlockCipher : object {
    private SicBlockCipher cipher;
    private bool forEncryption;
    private int blockSize;
    private IMac mac;
    private Byte[] nonceMac;
    private Byte[] associatedTextMac;
    private Byte[] macBlock;
    private int macSize;
    private Byte[] bufBlock;
    private int bufOff;
    private bool cipherInitialized;
    private Byte[] initialAssociatedText;
    public string AlgorithmName { get; }
    public IBlockCipher UnderlyingCipher { get; }
    public EaxBlockCipher(IBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual IBlockCipher get_UnderlyingCipher();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private void InitCipher();
    private void CalculateMac();
    public virtual void Reset();
    private void Reset(bool clearMac);
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public virtual int GetOutputSize(int len);
    private int Process(byte b, Byte[] outBytes, int outOff);
    private bool VerifyMac(Byte[] mac, int off);
}
public class Org.BouncyCastle.Crypto.Modes.EcbBlockCipher : object {
    private IBlockCipher m_cipher;
    public bool IsPartialBlockOkay { get; }
    public string AlgorithmName { get; }
    public IBlockCipher UnderlyingCipher { get; }
    public EcbBlockCipher(IBlockCipher cipher);
    internal static IBlockCipherMode GetBlockCipherMode(IBlockCipher blockCipher);
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetBlockSize();
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    public sealed virtual void Reset();
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Crypto.Modes.Gcm.BasicGcmExponentiator : object {
    private FieldElement x;
    public sealed virtual void Init(Byte[] x);
    public sealed virtual void ExponentiateX(long pow, Byte[] output);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Crypto.Modes.Gcm.BasicGcmMultiplier : object {
    private FieldElement H;
    internal static bool IsHardwareAccelerated { get; }
    internal static bool get_IsHardwareAccelerated();
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
internal static class Org.BouncyCastle.Crypto.Modes.Gcm.GcmUtilities : object {
    private static UInt32 E1;
    private static ulong E1UL;
    internal static void One(FieldElement& x);
    internal static void AsBytes(ulong x0, ulong x1, Byte[] z);
    internal static void AsBytes(FieldElement& x, Byte[] z);
    internal static void AsFieldElement(Byte[] x, FieldElement& z);
    internal static void DivideP(FieldElement& x, FieldElement& z);
    internal static void Multiply(Byte[] x, Byte[] y);
    internal static void Multiply(FieldElement& x, FieldElement& y);
    internal static void MultiplyP7(FieldElement& x);
    internal static void MultiplyP8(FieldElement& x);
    internal static void MultiplyP8(FieldElement& x, FieldElement& y);
    internal static void MultiplyP16(FieldElement& x);
    internal static void Square(FieldElement& x);
    internal static void Xor(Byte[] x, Byte[] y);
    internal static void Xor(Byte[] x, Byte[] y, int yOff);
    internal static void Xor(Byte[] x, Byte[] y, int yOff, int yLen);
    internal static void Xor(Byte[] x, int xOff, Byte[] y, int yOff, int len);
    internal static void Xor(FieldElement& x, FieldElement& y);
    internal static void Xor(FieldElement& x, FieldElement& y, FieldElement& z);
    private static ulong ImplMul64(ulong x, ulong y);
}
[ObsoleteAttribute("Will be removed")]
public interface Org.BouncyCastle.Crypto.Modes.Gcm.IGcmExponentiator {
    public abstract virtual void Init(Byte[] x);
    public abstract virtual void ExponentiateX(long pow, Byte[] output);
}
[ObsoleteAttribute("Will be removed")]
public interface Org.BouncyCastle.Crypto.Modes.Gcm.IGcmMultiplier {
    public abstract virtual void Init(Byte[] H);
    public abstract virtual void MultiplyH(Byte[] x);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables1kGcmExponentiator : object {
    private IList`1<FieldElement> lookupPowX2;
    public sealed virtual void Init(Byte[] x);
    public sealed virtual void ExponentiateX(long pow, Byte[] output);
    private void EnsureAvailable(int bit);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables4kGcmMultiplier : object {
    private Byte[] H;
    private FieldElement[] T;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables64kGcmMultiplier : object {
    private Byte[] H;
    private FieldElement[][] T;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables8kGcmMultiplier : object {
    private Byte[] H;
    private FieldElement[][] T;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
public class Org.BouncyCastle.Crypto.Modes.GcmBlockCipher : object {
    private static int BlockSize;
    private IBlockCipher cipher;
    private IGcmMultiplier multiplier;
    private IGcmExponentiator exp;
    private bool forEncryption;
    private bool initialised;
    private int macSize;
    private Byte[] lastKey;
    private Byte[] nonce;
    private Byte[] initialAssociatedText;
    private Byte[] H;
    private Byte[] J0;
    private Byte[] bufBlock;
    private Byte[] macBlock;
    private Byte[] S;
    private Byte[] S_at;
    private Byte[] S_atPre;
    private Byte[] counter;
    private UInt32 counter32;
    private UInt32 blocksRemaining;
    private int bufOff;
    private ulong totalLength;
    private Byte[] atBlock;
    private int atBlockPos;
    private ulong atLength;
    private ulong atLengthPre;
    public string AlgorithmName { get; }
    public IBlockCipher UnderlyingCipher { get; }
    public GcmBlockCipher(IBlockCipher c);
    [ObsoleteAttribute("Will be removed")]
public GcmBlockCipher(IBlockCipher c, IGcmMultiplier m);
    internal static IGcmMultiplier CreateGcmMultiplier();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual Byte[] GetMac();
    public sealed virtual int GetOutputSize(int len);
    public sealed virtual int GetUpdateOutputSize(int len);
    public sealed virtual void ProcessAadByte(byte input);
    public sealed virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    private void InitCipher();
    public sealed virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public sealed virtual int ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void Reset(bool clearMac);
    private void DecryptBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    private void DecryptBlocks2(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    private void EncryptBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    private void EncryptBlocks2(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    private void GetNextCtrBlock(Byte[] block);
    private void ProcessPartial(Byte[] buf, int off, int len, Byte[] output, int outOff);
    private void gHASH(Byte[] Y, Byte[] b, int len);
    private void gHASHBlock(Byte[] Y, Byte[] b);
    private void gHASHBlock(Byte[] Y, Byte[] b, int off);
    private void gHASHPartial(Byte[] Y, Byte[] b, int off, int len);
    private void CheckStatus();
}
public class Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher : object {
    private static int BUFLEN;
    private static int HALFBUFLEN;
    private static int NONCELEN;
    private static int MAX_DATALEN;
    private static byte MASK;
    private static byte ADD;
    private static int INIT;
    private static int AEAD_COMPLETE;
    private IBlockCipher theCipher;
    private IGcmMultiplier theMultiplier;
    internal Byte[] theGHash;
    internal Byte[] theReverse;
    private GcmSivHasher theAEADHasher;
    private GcmSivHasher theDataHasher;
    private GcmSivCache thePlain;
    private GcmSivCache theEncData;
    private bool forEncryption;
    private Byte[] theInitialAEAD;
    private Byte[] theNonce;
    private int theFlags;
    public IBlockCipher UnderlyingCipher { get; }
    public string AlgorithmName { get; }
    public GcmSivBlockCipher(IBlockCipher pCipher);
    [ObsoleteAttribute("Will be removed")]
public GcmSivBlockCipher(IBlockCipher pCipher, IGcmMultiplier pMultiplier);
    private static GcmSivBlockCipher();
    public virtual IBlockCipher get_UnderlyingCipher();
    public virtual int GetBlockSize();
    public virtual void Init(bool pEncrypt, ICipherParameters cipherParameters);
    public virtual string get_AlgorithmName();
    private void CheckAeadStatus(int pLen);
    private void CheckStatus(int pLen);
    public virtual void ProcessAadByte(byte pByte);
    public virtual void ProcessAadBytes(Byte[] pData, int pOffset, int pLen);
    public virtual int ProcessByte(byte pByte, Byte[] pOutput, int pOutOffset);
    public virtual int ProcessBytes(Byte[] pData, int pOffset, int pLen, Byte[] pOutput, int pOutOffset);
    public virtual int DoFinal(Byte[] pOutput, int pOffset);
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int pLen);
    public virtual int GetOutputSize(int pLen);
    public virtual void Reset();
    private void ResetStreams();
    private static int bufLength(Byte[] pBuffer);
    private int EncryptPlain(Byte[] pCounter, Byte[] pTarget, int pOffset);
    private void DecryptPlain();
    private Byte[] CalculateTag();
    private Byte[] completePolyVal();
    private void gHashLengths();
    private void gHASH(Byte[] pNext);
    private static void fillReverse(Byte[] pInput, int pOffset, int pLength, Byte[] pOutput);
    private static void xorBlock(Byte[] pLeft, Byte[] pRight);
    private static void xorBlock(Byte[] pLeft, Byte[] pRight, int pOffset, int pLength);
    private static void incrementCounter(Byte[] pCounter);
    private static void mulX(Byte[] pValue);
    private void DeriveKeys(KeyParameter pKey);
}
public class Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    private bool firstStep;
    private int N3;
    private int N4;
    private static int C1;
    private static int C2;
    public IBlockCipher UnderlyingCipher { get; }
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public GOfbBlockCipher(IBlockCipher cipher);
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher {
    public IBlockCipher UnderlyingCipher { get; }
    public abstract virtual int GetBlockSize();
    public abstract virtual IBlockCipher get_UnderlyingCipher();
}
public interface Org.BouncyCastle.Crypto.Modes.IAeadCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual void ProcessAadByte(byte input);
    public abstract virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public abstract virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public abstract virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public abstract virtual int DoFinal(Byte[] outBytes, int outOff);
    public abstract virtual Byte[] GetMac();
    public abstract virtual int GetUpdateOutputSize(int len);
    public abstract virtual int GetOutputSize(int len);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.Modes.IBlockCipherMode {
    public IBlockCipher UnderlyingCipher { get; }
    public bool IsPartialBlockOkay { get; }
    public abstract virtual IBlockCipher get_UnderlyingCipher();
    public abstract virtual bool get_IsPartialBlockOkay();
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.KCcmBlockCipher : object {
    private static int BYTES_IN_INT;
    private static int BITS_IN_BYTE;
    private static int MAX_MAC_BIT_LENGTH;
    private static int MIN_MAC_BIT_LENGTH;
    private IBlockCipher engine;
    private int macSize;
    private bool forEncryption;
    private Byte[] initialAssociatedText;
    private Byte[] mac;
    private Byte[] macBlock;
    private Byte[] nonce;
    private Byte[] G1;
    private Byte[] buffer;
    private Byte[] s;
    private Byte[] counter;
    private MemoryStream associatedText;
    private MemoryStream data;
    private int Nb_;
    public string AlgorithmName { get; }
    public IBlockCipher UnderlyingCipher { get; }
    public KCcmBlockCipher(IBlockCipher engine);
    public KCcmBlockCipher(IBlockCipher engine, int Nb);
    private static KCcmBlockCipher();
    private void SetNb(int Nb);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual IBlockCipher get_UnderlyingCipher();
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] input, int inOff, int len);
    private void ProcessAAD(Byte[] assocText, int assocOff, int assocLen, int dataLen);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int inLen, Byte[] output, int outOff);
    public int ProcessPacket(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    private void CalculateMac(Byte[] authText, int authOff, int len);
    private void ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public virtual int GetOutputSize(int len);
    public virtual void Reset();
    private void intToBytes(int num, Byte[] outBytes, int outOff);
    private byte getFlag(bool authTextPresents, int macSize);
}
public class Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher : object {
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private bool initialised;
    private int byteCount;
    private int blockSize;
    private IBlockCipher cipher;
    public IBlockCipher UnderlyingCipher { get; }
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public KCtrBlockCipher(IBlockCipher cipher);
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    protected byte CalculateByte(byte b);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void incrementCounterAt(int pos);
    private void checkCounter();
}
public class Org.BouncyCastle.Crypto.Modes.OcbBlockCipher : object {
    private static int BLOCK_SIZE;
    private IBlockCipher hashCipher;
    private IBlockCipher mainCipher;
    private bool forEncryption;
    private int macSize;
    private Byte[] initialAssociatedText;
    private IList`1<Byte[]> L;
    private Byte[] L_Asterisk;
    private Byte[] L_Dollar;
    private Byte[] KtopInput;
    private Byte[] Stretch;
    private Byte[] OffsetMAIN_0;
    private Byte[] hashBlock;
    private Byte[] mainBlock;
    private int hashBlockPos;
    private int mainBlockPos;
    private long hashBlockCount;
    private long mainBlockCount;
    private Byte[] OffsetHASH;
    private Byte[] Sum;
    private Byte[] OffsetMAIN;
    private Byte[] Checksum;
    private Byte[] macBlock;
    public string AlgorithmName { get; }
    public IBlockCipher UnderlyingCipher { get; }
    public OcbBlockCipher(IBlockCipher hashCipher, IBlockCipher mainCipher);
    public virtual string get_AlgorithmName();
    public virtual IBlockCipher get_UnderlyingCipher();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual int ProcessNonce(Byte[] N);
    public virtual int GetBlockSize();
    public virtual Byte[] GetMac();
    public virtual int GetOutputSize(int len);
    public virtual int GetUpdateOutputSize(int len);
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] input, int off, int len);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void Clear(Byte[] bs);
    protected virtual Byte[] GetLSub(int n);
    protected virtual void ProcessHashBlock();
    protected virtual void ProcessMainBlock(Byte[] output, int outOff);
    protected virtual void Reset(bool clearMac);
    protected virtual void UpdateHASH(Byte[] LSub);
    protected static Byte[] OCB_double(Byte[] block);
    protected static void OCB_extend(Byte[] block, int pos);
    protected static int OCB_ntz(long x);
    protected static int ShiftLeft(Byte[] block, Byte[] output);
    protected static void Xor(Byte[] block, Byte[] val);
}
public class Org.BouncyCastle.Crypto.Modes.OfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    public IBlockCipher UnderlyingCipher { get; }
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public OfbBlockCipher(IBlockCipher cipher, int blockSize);
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] FR;
    private Byte[] FRE;
    private IBlockCipher cipher;
    private int blockSize;
    private int count;
    private bool forEncryption;
    public IBlockCipher UnderlyingCipher { get; }
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public OpenPgpCfbBlockCipher(IBlockCipher cipher);
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte EncryptByte(byte data, int blockOff);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.SicBlockCipher : object {
    private IBlockCipher cipher;
    private int blockSize;
    private Byte[] counter;
    private Byte[] counterOut;
    private Byte[] IV;
    public IBlockCipher UnderlyingCipher { get; }
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public SicBlockCipher(IBlockCipher cipher);
    public sealed virtual IBlockCipher get_UnderlyingCipher();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1CipherBuilderWithKey : object {
    private KeyParameter encKey;
    private AlgorithmIdentifier algorithmIdentifier;
    public object AlgorithmDetails { get; }
    public ICipherParameters Key { get; }
    public Asn1CipherBuilderWithKey(DerObjectIdentifier encryptionOID, int keySize, SecureRandom random);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual int GetMaxOutputSize(int inputLen);
    public sealed virtual ICipher BuildCipher(Stream stream);
    public sealed virtual ICipherParameters get_Key();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1DigestFactory : object {
    private IDigest mDigest;
    private DerObjectIdentifier mOid;
    public object AlgorithmDetails { get; }
    public int DigestLength { get; }
    public Asn1DigestFactory(IDigest digest, DerObjectIdentifier oid);
    public static Asn1DigestFactory Get(DerObjectIdentifier oid);
    public static Asn1DigestFactory Get(string mechanism);
    public virtual object get_AlgorithmDetails();
    public virtual int get_DigestLength();
    public virtual IStreamCalculator`1<IBlockResult> CreateCalculator();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1KeyUnwrapper : object {
    private string algorithm;
    private IKeyUnwrapper wrapper;
    public object AlgorithmDetails { get; }
    public Asn1KeyUnwrapper(string algorithm, ICipherParameters key);
    public Asn1KeyUnwrapper(DerObjectIdentifier algorithm, ICipherParameters key);
    public Asn1KeyUnwrapper(DerObjectIdentifier algorithm, Asn1Encodable parameters, ICipherParameters key);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IBlockResult Unwrap(Byte[] keyData, int offSet, int length);
}
public class Org.BouncyCastle.Crypto.Operators.Asn1KeyWrapper : object {
    private string algorithm;
    private IKeyWrapper wrapper;
    public object AlgorithmDetails { get; }
    public Asn1KeyWrapper(string algorithm, X509Certificate cert);
    public Asn1KeyWrapper(DerObjectIdentifier algorithm, X509Certificate cert);
    public Asn1KeyWrapper(DerObjectIdentifier algorithm, ICipherParameters key);
    public Asn1KeyWrapper(DerObjectIdentifier algorithm, Asn1Encodable parameters, X509Certificate cert);
    public Asn1KeyWrapper(DerObjectIdentifier algorithm, Asn1Encodable parameters, ICipherParameters key);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IBlockResult Wrap(Byte[] keyData);
}
public class Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory : object {
    private AlgorithmIdentifier algID;
    private string algorithm;
    private AsymmetricKeyParameter privateKey;
    private SecureRandom random;
    public object AlgorithmDetails { get; }
    public static IEnumerable`1<string> SignatureAlgNames { get; }
    public Asn1SignatureFactory(string algorithm, AsymmetricKeyParameter privateKey);
    public Asn1SignatureFactory(string algorithm, AsymmetricKeyParameter privateKey, SecureRandom random);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IStreamCalculator`1<IBlockResult> CreateCalculator();
    public static IEnumerable`1<string> get_SignatureAlgNames();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory : object {
    private AlgorithmIdentifier algID;
    private AsymmetricKeyParameter publicKey;
    public object AlgorithmDetails { get; }
    public Asn1VerifierFactory(string algorithm, AsymmetricKeyParameter publicKey);
    public Asn1VerifierFactory(AlgorithmIdentifier algorithm, AsymmetricKeyParameter publicKey);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IStreamCalculator`1<IVerifier> CreateCalculator();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider : object {
    private AsymmetricKeyParameter publicKey;
    public IEnumerable`1<string> SignatureAlgNames { get; }
    public Asn1VerifierFactoryProvider(AsymmetricKeyParameter publicKey);
    public sealed virtual IVerifierFactory CreateVerifierFactory(object algorithmDetails);
    public IEnumerable`1<string> get_SignatureAlgNames();
}
public class Org.BouncyCastle.Crypto.Operators.BufferedCipherWrapper : object {
    private IBufferedCipher bufferedCipher;
    private CipherStream stream;
    public Stream Stream { get; }
    public BufferedCipherWrapper(IBufferedCipher bufferedCipher, Stream source);
    public sealed virtual int GetMaxOutputSize(int inputLen);
    public sealed virtual int GetUpdateOutputSize(int inputLen);
    public sealed virtual Stream get_Stream();
}
public class Org.BouncyCastle.Crypto.Operators.DefaultSignatureCalculator : object {
    private SignerSink mSignerSink;
    public Stream Stream { get; }
    public DefaultSignatureCalculator(ISigner signer);
    public sealed virtual Stream get_Stream();
    public sealed virtual IBlockResult GetResult();
}
public class Org.BouncyCastle.Crypto.Operators.DefaultSignatureResult : object {
    private ISigner mSigner;
    public DefaultSignatureResult(ISigner signer);
    public sealed virtual Byte[] Collect();
    public sealed virtual int Collect(Byte[] buf, int off);
    public sealed virtual int GetMaxResultLength();
}
public class Org.BouncyCastle.Crypto.Operators.DefaultVerifierCalculator : object {
    private SignerSink mSignerSink;
    public Stream Stream { get; }
    public DefaultVerifierCalculator(ISigner signer);
    public sealed virtual Stream get_Stream();
    public sealed virtual IVerifier GetResult();
}
public class Org.BouncyCastle.Crypto.Operators.DefaultVerifierResult : object {
    private ISigner mSigner;
    public DefaultVerifierResult(ISigner signer);
    public sealed virtual bool IsVerified(Byte[] signature);
    public sealed virtual bool IsVerified(Byte[] sig, int sigOff, int sigLen);
}
internal class Org.BouncyCastle.Crypto.Operators.DfDigestStream : object {
    private DigestSink mStream;
    public Stream Stream { get; }
    public DfDigestStream(IDigest digest);
    public sealed virtual Stream get_Stream();
    public sealed virtual SimpleBlockResult GetResult();
}
public class Org.BouncyCastle.Crypto.Operators.GenericKey : object {
    private AlgorithmIdentifier algorithmIdentifier;
    private object representation;
    public AlgorithmIdentifier AlgorithmIdentifier { get; }
    public object Representation { get; }
    public GenericKey(object representation);
    public GenericKey(AlgorithmIdentifier algorithmIdentifier, Byte[] representation);
    public GenericKey(AlgorithmIdentifier algorithmIdentifier, object representation);
    public AlgorithmIdentifier get_AlgorithmIdentifier();
    public object get_Representation();
}
internal class Org.BouncyCastle.Crypto.Operators.KeyWrapperUtil : object {
    private static Dictionary`2<string, WrapperProvider> m_providerMap;
    private static KeyWrapperUtil();
    public static IKeyWrapper WrapperForName(string algorithm, ICipherParameters parameters);
    public static IKeyUnwrapper UnwrapperForName(string algorithm, ICipherParameters parameters);
}
internal class Org.BouncyCastle.Crypto.Operators.RsaOaepWrapper : object {
    private AlgorithmIdentifier algId;
    private IAsymmetricBlockCipher engine;
    public object AlgorithmDetails { get; }
    public RsaOaepWrapper(bool forWrapping, ICipherParameters parameters, DerObjectIdentifier digestOid);
    public RsaOaepWrapper(bool forWrapping, ICipherParameters parameters, DerObjectIdentifier digestOid, DerObjectIdentifier mgfOid);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IBlockResult Unwrap(Byte[] cipherText, int offset, int length);
    public sealed virtual IBlockResult Wrap(Byte[] keyData);
}
internal class Org.BouncyCastle.Crypto.Operators.RsaOaepWrapperProvider : object {
    private DerObjectIdentifier digestOid;
    private DerObjectIdentifier mgfOid;
    internal RsaOaepWrapperProvider(DerObjectIdentifier digestOid);
    internal RsaOaepWrapperProvider(DerObjectIdentifier digestOid, DerObjectIdentifier mgfOid);
    private sealed virtual override object Org.BouncyCastle.Crypto.Operators.WrapperProvider.CreateWrapper(bool forWrapping, ICipherParameters parameters);
}
internal class Org.BouncyCastle.Crypto.Operators.RsaPkcs1Wrapper : object {
    private AlgorithmIdentifier algId;
    private IAsymmetricBlockCipher engine;
    public object AlgorithmDetails { get; }
    public RsaPkcs1Wrapper(bool forWrapping, ICipherParameters parameters);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IBlockResult Unwrap(Byte[] cipherText, int offset, int length);
    public sealed virtual IBlockResult Wrap(Byte[] keyData);
}
internal class Org.BouncyCastle.Crypto.Operators.RsaPkcs1WrapperProvider : object {
    private sealed virtual override object Org.BouncyCastle.Crypto.Operators.WrapperProvider.CreateWrapper(bool forWrapping, ICipherParameters parameters);
}
internal interface Org.BouncyCastle.Crypto.Operators.WrapperProvider {
    public abstract virtual object CreateWrapper(bool forWrapping, ICipherParameters parameters);
}
internal class Org.BouncyCastle.Crypto.Operators.X509Utilities : object {
    private static IDictionary`2<string, DerObjectIdentifier> m_algorithms;
    private static IDictionary`2<string, Asn1Encodable> m_exParams;
    private static HashSet`1<DerObjectIdentifier> noParams;
    private static X509Utilities();
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid, string algorithmName);
    internal static IEnumerable`1<string> GetAlgNames();
}
public class Org.BouncyCastle.Crypto.OutputLengthException : DataLengthException {
    public OutputLengthException(string message);
    public OutputLengthException(string message, Exception innerException);
    protected OutputLengthException(SerializationInfo info, StreamingContext context);
}
public interface Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding {
    public string PaddingName { get; }
    public abstract virtual void Init(SecureRandom random);
    public abstract virtual string get_PaddingName();
    public abstract virtual int AddPadding(Byte[] input, int inOff);
    public abstract virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding : object {
    private SecureRandom m_random;
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher : BufferedBlockCipher {
    private IBlockCipherPadding padding;
    public PaddedBufferedBlockCipher(IBlockCipher cipher, IBlockCipherPadding padding);
    public PaddedBufferedBlockCipher(IBlockCipherMode cipherMode, IBlockCipherPadding padding);
    public PaddedBufferedBlockCipher(IBlockCipherMode cipherMode);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.TbcPadding : object {
    public string PaddingName { get; }
    public virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public virtual int AddPadding(Byte[] input, int inOff);
    public virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.X923Padding : object {
    private SecureRandom m_random;
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding : object {
    public string PaddingName { get; }
    public sealed virtual string get_PaddingName();
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Parameters.AeadParameters : object {
    private Byte[] associatedText;
    private Byte[] nonce;
    private KeyParameter key;
    private int macSize;
    public KeyParameter Key { get; }
    public int MacSize { get; }
    public AeadParameters(KeyParameter key, int macSize, Byte[] nonce);
    public AeadParameters(KeyParameter key, int macSize, Byte[] nonce, Byte[] associatedText);
    public virtual KeyParameter get_Key();
    public virtual int get_MacSize();
    public virtual Byte[] GetAssociatedText();
    public virtual Byte[] GetNonce();
}
public class Org.BouncyCastle.Crypto.Parameters.Blake3Parameters : object {
    private static int KeyLen;
    private Byte[] m_theKey;
    private Byte[] m_theContext;
    public static Blake3Parameters Context(Byte[] pContext);
    public static Blake3Parameters Key(Byte[] pKey);
    public Byte[] GetKey();
    public void ClearKey();
    public Byte[] GetContext();
}
public class Org.BouncyCastle.Crypto.Parameters.DesEdeParameters : DesParameters {
    public static int DesEdeKeyLength;
    public DesEdeParameters(Byte[] key);
    public DesEdeParameters(Byte[] key, int keyOff, int keyLen);
    private static Byte[] FixKey(Byte[] key, int keyOff, int keyLen);
    public static bool IsWeakKey(Byte[] key, int offset, int length);
    public static bool IsWeakKey(Byte[] key, int offset);
    public static bool IsWeakKey(Byte[] key);
    public static bool IsRealEdeKey(Byte[] key, int offset);
    public static bool IsReal2Key(Byte[] key, int offset);
    public static bool IsReal3Key(Byte[] key, int offset);
}
public class Org.BouncyCastle.Crypto.Parameters.DesParameters : KeyParameter {
    public static int DesKeyLength;
    private static int N_DES_WEAK_KEYS;
    private static Byte[] DES_weak_keys;
    public DesParameters(Byte[] key);
    public DesParameters(Byte[] key, int keyOff, int keyLen);
    private static DesParameters();
    public static bool IsWeakKey(Byte[] key, int offset);
    public static bool IsWeakKey(Byte[] key);
    public static byte SetOddParity(byte b);
    public static void SetOddParity(Byte[] bytes);
    public static void SetOddParity(Byte[] bytes, int off, int len);
}
public class Org.BouncyCastle.Crypto.Parameters.DHKeyGenerationParameters : KeyGenerationParameters {
    private DHParameters parameters;
    public DHParameters Parameters { get; }
    public DHKeyGenerationParameters(SecureRandom random, DHParameters parameters);
    public DHParameters get_Parameters();
    internal static int GetStrength(DHParameters parameters);
}
public class Org.BouncyCastle.Crypto.Parameters.DHKeyParameters : AsymmetricKeyParameter {
    private DHParameters parameters;
    private DerObjectIdentifier algorithmOid;
    public DHParameters Parameters { get; }
    public DerObjectIdentifier AlgorithmOid { get; }
    protected DHKeyParameters(bool isPrivate, DHParameters parameters);
    protected DHKeyParameters(bool isPrivate, DHParameters parameters, DerObjectIdentifier algorithmOid);
    public DHParameters get_Parameters();
    public DerObjectIdentifier get_AlgorithmOid();
    public virtual bool Equals(object obj);
    protected bool Equals(DHKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHParameters : object {
    private static int DefaultMinimumLength;
    private BigInteger p;
    private BigInteger g;
    private BigInteger q;
    private BigInteger j;
    private int m;
    private int l;
    private DHValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger Q { get; }
    public BigInteger J { get; }
    public int M { get; }
    public int L { get; }
    public DHValidationParameters ValidationParameters { get; }
    public DHParameters(BigInteger p, BigInteger g);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int l);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int m, int l);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, BigInteger j, DHValidationParameters validation);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int m, int l, BigInteger j, DHValidationParameters validation);
    private static int GetDefaultMParam(int lParam);
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_Q();
    public BigInteger get_J();
    public int get_M();
    public int get_L();
    public DHValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected virtual bool Equals(DHParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHPrivateKeyParameters : DHKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public DHPrivateKeyParameters(BigInteger x, DHParameters parameters);
    public DHPrivateKeyParameters(BigInteger x, DHParameters parameters, DerObjectIdentifier algorithmOid);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(DHPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHPublicKeyParameters : DHKeyParameters {
    private BigInteger m_y;
    public BigInteger Y { get; }
    public DHPublicKeyParameters(BigInteger y, DHParameters parameters);
    public DHPublicKeyParameters(BigInteger y, DHParameters parameters, DerObjectIdentifier algorithmOid);
    private static BigInteger Validate(BigInteger y, DHParameters dhParams);
    public virtual BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(DHPublicKeyParameters other);
    public virtual int GetHashCode();
    private static int Legendre(BigInteger a, BigInteger b);
}
public class Org.BouncyCastle.Crypto.Parameters.DHValidationParameters : object {
    private Byte[] seed;
    private int counter;
    public int Counter { get; }
    public DHValidationParameters(Byte[] seed, int counter);
    public Byte[] GetSeed();
    public int get_Counter();
    public virtual bool Equals(object obj);
    protected bool Equals(DHValidationParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaKeyGenerationParameters : KeyGenerationParameters {
    private DsaParameters parameters;
    public DsaParameters Parameters { get; }
    public DsaKeyGenerationParameters(SecureRandom random, DsaParameters parameters);
    public DsaParameters get_Parameters();
}
public abstract class Org.BouncyCastle.Crypto.Parameters.DsaKeyParameters : AsymmetricKeyParameter {
    private DsaParameters parameters;
    public DsaParameters Parameters { get; }
    protected DsaKeyParameters(bool isPrivate, DsaParameters parameters);
    public DsaParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters : object {
    public static int DigitalSignatureUsage;
    public static int KeyEstablishmentUsage;
    private int l;
    private int n;
    private int certainty;
    private SecureRandom random;
    private int usageIndex;
    public int L { get; }
    public int N { get; }
    public int UsageIndex { get; }
    public int Certainty { get; }
    public SecureRandom Random { get; }
    public DsaParameterGenerationParameters(int L, int N, int certainty, SecureRandom random);
    public DsaParameterGenerationParameters(int L, int N, int certainty, SecureRandom random, int usageIndex);
    public virtual int get_L();
    public virtual int get_N();
    public virtual int get_UsageIndex();
    public virtual int get_Certainty();
    public virtual SecureRandom get_Random();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaParameters : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger g;
    private DsaValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public DsaValidationParameters ValidationParameters { get; }
    public DsaParameters(BigInteger p, BigInteger q, BigInteger g);
    public DsaParameters(BigInteger p, BigInteger q, BigInteger g, DsaValidationParameters parameters);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_G();
    public DsaValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaPrivateKeyParameters : DsaKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public DsaPrivateKeyParameters(BigInteger x, DsaParameters parameters);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaPublicKeyParameters : DsaKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public DsaPublicKeyParameters(BigInteger y, DsaParameters parameters);
    private static BigInteger Validate(BigInteger y, DsaParameters parameters);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaValidationParameters : object {
    private Byte[] seed;
    private int counter;
    private int usageIndex;
    public int Counter { get; }
    public int UsageIndex { get; }
    public DsaValidationParameters(Byte[] seed, int counter);
    public DsaValidationParameters(Byte[] seed, int counter, int usageIndex);
    public virtual Byte[] GetSeed();
    public virtual int get_Counter();
    public virtual int get_UsageIndex();
    public virtual bool Equals(object obj);
    protected virtual bool Equals(DsaValidationParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECDomainParameters : object {
    private ECCurve curve;
    private Byte[] seed;
    private ECPoint g;
    private BigInteger n;
    private BigInteger h;
    private BigInteger hInv;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public BigInteger HInv { get; }
    public ECDomainParameters(X9ECParameters x9);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public BigInteger get_HInv();
    public Byte[] GetSeed();
    public virtual bool Equals(object obj);
    protected virtual bool Equals(ECDomainParameters other);
    public virtual int GetHashCode();
    public BigInteger ValidatePrivateScalar(BigInteger d);
    public ECPoint ValidatePublicPoint(ECPoint q);
    internal static ECPoint ValidatePublicPoint(ECCurve c, ECPoint q);
}
public class Org.BouncyCastle.Crypto.Parameters.ECGost3410Parameters : ECNamedDomainParameters {
    private DerObjectIdentifier _publicKeyParamSet;
    private DerObjectIdentifier _digestParamSet;
    private DerObjectIdentifier _encryptionParamSet;
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public DerObjectIdentifier DigestParamSet { get; }
    public DerObjectIdentifier EncryptionParamSet { get; }
    public ECGost3410Parameters(ECNamedDomainParameters dp, DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet, DerObjectIdentifier encryptionParamSet);
    public ECGost3410Parameters(ECDomainParameters dp, DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet, DerObjectIdentifier encryptionParamSet);
    public DerObjectIdentifier get_PublicKeyParamSet();
    public DerObjectIdentifier get_DigestParamSet();
    public DerObjectIdentifier get_EncryptionParamSet();
}
public class Org.BouncyCastle.Crypto.Parameters.ECKeyGenerationParameters : KeyGenerationParameters {
    private ECDomainParameters domainParams;
    private DerObjectIdentifier publicKeyParamSet;
    public ECDomainParameters DomainParameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public ECKeyGenerationParameters(ECDomainParameters domainParameters, SecureRandom random);
    public ECKeyGenerationParameters(DerObjectIdentifier publicKeyParamSet, SecureRandom random);
    public ECDomainParameters get_DomainParameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
}
public abstract class Org.BouncyCastle.Crypto.Parameters.ECKeyParameters : AsymmetricKeyParameter {
    private static Dictionary`2<string, string> Algorithms;
    private string algorithm;
    private ECDomainParameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public string AlgorithmName { get; }
    public ECDomainParameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    protected ECKeyParameters(string algorithm, bool isPrivate, ECDomainParameters parameters);
    protected ECKeyParameters(string algorithm, bool isPrivate, DerObjectIdentifier publicKeyParamSet);
    private static ECKeyParameters();
    public string get_AlgorithmName();
    public ECDomainParameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    public virtual bool Equals(object obj);
    protected bool Equals(ECKeyParameters other);
    public virtual int GetHashCode();
    internal ECKeyGenerationParameters CreateKeyGenerationParameters(SecureRandom random);
    internal static string VerifyAlgorithmName(string algorithm);
    internal static ECDomainParameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public class Org.BouncyCastle.Crypto.Parameters.ECNamedDomainParameters : ECDomainParameters {
    private DerObjectIdentifier name;
    public DerObjectIdentifier Name { get; }
    public ECNamedDomainParameters(DerObjectIdentifier name, ECDomainParameters dp);
    public ECNamedDomainParameters(DerObjectIdentifier name, X9ECParameters x9);
    public ECNamedDomainParameters(DerObjectIdentifier name, ECCurve curve, ECPoint g, BigInteger n);
    public ECNamedDomainParameters(DerObjectIdentifier name, ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public ECNamedDomainParameters(DerObjectIdentifier name, ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public DerObjectIdentifier get_Name();
}
public class Org.BouncyCastle.Crypto.Parameters.ECPrivateKeyParameters : ECKeyParameters {
    private BigInteger d;
    public BigInteger D { get; }
    public ECPrivateKeyParameters(BigInteger d, ECDomainParameters parameters);
    public ECPrivateKeyParameters(string algorithm, BigInteger d, ECDomainParameters parameters);
    public ECPrivateKeyParameters(string algorithm, BigInteger d, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_D();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECPublicKeyParameters : ECKeyParameters {
    private ECPoint q;
    public ECPoint Q { get; }
    public ECPublicKeyParameters(ECPoint q, ECDomainParameters parameters);
    public ECPublicKeyParameters(string algorithm, ECPoint q, ECDomainParameters parameters);
    public ECPublicKeyParameters(string algorithm, ECPoint q, DerObjectIdentifier publicKeyParamSet);
    public ECPoint get_Q();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.Ed25519KeyGenerationParameters : KeyGenerationParameters {
    public Ed25519KeyGenerationParameters(SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed25519PrivateKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    public static int SignatureSize;
    private Byte[] data;
    private Ed25519PublicKeyParameters cachedPublicKey;
    public Ed25519PrivateKeyParameters(SecureRandom random);
    public Ed25519PrivateKeyParameters(Byte[] buf);
    public Ed25519PrivateKeyParameters(Byte[] buf, int off);
    public Ed25519PrivateKeyParameters(Stream input);
    private static Ed25519PrivateKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public Ed25519PublicKeyParameters GeneratePublicKey();
    public void Sign(Algorithm algorithm, Byte[] ctx, Byte[] msg, int msgOff, int msgLen, Byte[] sig, int sigOff);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed25519PublicKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    private PublicPoint m_publicPoint;
    public Ed25519PublicKeyParameters(Byte[] buf);
    public Ed25519PublicKeyParameters(Byte[] buf, int off);
    public Ed25519PublicKeyParameters(Stream input);
    public Ed25519PublicKeyParameters(PublicPoint publicPoint);
    private static Ed25519PublicKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public bool Verify(Algorithm algorithm, Byte[] ctx, Byte[] msg, int msgOff, int msgLen, Byte[] sig, int sigOff);
    private static PublicPoint Parse(Byte[] buf, int off);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed448KeyGenerationParameters : KeyGenerationParameters {
    public Ed448KeyGenerationParameters(SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed448PrivateKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    public static int SignatureSize;
    private Byte[] data;
    private Ed448PublicKeyParameters cachedPublicKey;
    public Ed448PrivateKeyParameters(SecureRandom random);
    public Ed448PrivateKeyParameters(Byte[] buf);
    public Ed448PrivateKeyParameters(Byte[] buf, int off);
    public Ed448PrivateKeyParameters(Stream input);
    private static Ed448PrivateKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public Ed448PublicKeyParameters GeneratePublicKey();
    public void Sign(Algorithm algorithm, Byte[] ctx, Byte[] msg, int msgOff, int msgLen, Byte[] sig, int sigOff);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed448PublicKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    private PublicPoint m_publicPoint;
    public Ed448PublicKeyParameters(Byte[] buf);
    public Ed448PublicKeyParameters(Byte[] buf, int off);
    public Ed448PublicKeyParameters(Stream input);
    public Ed448PublicKeyParameters(PublicPoint publicPoint);
    private static Ed448PublicKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public bool Verify(Algorithm algorithm, Byte[] ctx, Byte[] msg, int msgOff, int msgLen, Byte[] sig, int sigOff);
    private static PublicPoint Parse(Byte[] buf, int off);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalKeyGenerationParameters : KeyGenerationParameters {
    private ElGamalParameters parameters;
    public ElGamalParameters Parameters { get; }
    public ElGamalKeyGenerationParameters(SecureRandom random, ElGamalParameters parameters);
    public ElGamalParameters get_Parameters();
    internal static int GetStrength(ElGamalParameters parameters);
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalKeyParameters : AsymmetricKeyParameter {
    private ElGamalParameters parameters;
    public ElGamalParameters Parameters { get; }
    protected ElGamalKeyParameters(bool isPrivate, ElGamalParameters parameters);
    public ElGamalParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalParameters : object {
    private BigInteger p;
    private BigInteger g;
    private int l;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public int L { get; }
    public ElGamalParameters(BigInteger p, BigInteger g);
    public ElGamalParameters(BigInteger p, BigInteger g, int l);
    public BigInteger get_P();
    public BigInteger get_G();
    public int get_L();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalPrivateKeyParameters : ElGamalKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public ElGamalPrivateKeyParameters(BigInteger x, ElGamalParameters parameters);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalPublicKeyParameters : ElGamalKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public ElGamalPublicKeyParameters(BigInteger y, ElGamalParameters parameters);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.FpeParameters : object {
    private KeyParameter key;
    private int radix;
    private Byte[] tweak;
    private bool useInverse;
    public KeyParameter Key { get; }
    public int Radix { get; }
    public bool UseInverseFunction { get; }
    public FpeParameters(KeyParameter key, int radix, Byte[] tweak);
    public FpeParameters(KeyParameter key, int radix, Byte[] tweak, bool useInverse);
    public KeyParameter get_Key();
    public int get_Radix();
    public bool get_UseInverseFunction();
    public Byte[] GetTweak();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410KeyGenerationParameters : KeyGenerationParameters {
    private Gost3410Parameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public Gost3410Parameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public Gost3410KeyGenerationParameters(SecureRandom random, Gost3410Parameters parameters);
    public Gost3410KeyGenerationParameters(SecureRandom random, DerObjectIdentifier publicKeyParamSet);
    public Gost3410Parameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    private static Gost3410Parameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public abstract class Org.BouncyCastle.Crypto.Parameters.Gost3410KeyParameters : AsymmetricKeyParameter {
    private Gost3410Parameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public Gost3410Parameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    protected Gost3410KeyParameters(bool isPrivate, Gost3410Parameters parameters);
    protected Gost3410KeyParameters(bool isPrivate, DerObjectIdentifier publicKeyParamSet);
    public Gost3410Parameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    private static Gost3410Parameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410Parameters : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger a;
    private Gost3410ValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public Gost3410ValidationParameters ValidationParameters { get; }
    public Gost3410Parameters(BigInteger p, BigInteger q, BigInteger a);
    public Gost3410Parameters(BigInteger p, BigInteger q, BigInteger a, Gost3410ValidationParameters validation);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public Gost3410ValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(Gost3410Parameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410PrivateKeyParameters : Gost3410KeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public Gost3410PrivateKeyParameters(BigInteger x, Gost3410Parameters parameters);
    public Gost3410PrivateKeyParameters(BigInteger x, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_X();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410PublicKeyParameters : Gost3410KeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public Gost3410PublicKeyParameters(BigInteger y, Gost3410Parameters parameters);
    public Gost3410PublicKeyParameters(BigInteger y, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_Y();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410ValidationParameters : object {
    private int x0;
    private int c;
    private long x0L;
    private long cL;
    public int C { get; }
    public int X0 { get; }
    public long CL { get; }
    public long X0L { get; }
    public Gost3410ValidationParameters(int x0, int c);
    public Gost3410ValidationParameters(long x0L, long cL);
    public int get_C();
    public int get_X0();
    public long get_CL();
    public long get_X0L();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.HkdfParameters : object {
    private Byte[] ikm;
    private bool skipExpand;
    private Byte[] salt;
    private Byte[] info;
    public bool SkipExtract { get; }
    private HkdfParameters(Byte[] ikm, bool skip, Byte[] salt, Byte[] info);
    public HkdfParameters(Byte[] ikm, Byte[] salt, Byte[] info);
    public static HkdfParameters SkipExtractParameters(Byte[] ikm, Byte[] info);
    public static HkdfParameters DefaultParameters(Byte[] ikm);
    public virtual Byte[] GetIkm();
    public virtual bool get_SkipExtract();
    public virtual Byte[] GetSalt();
    public virtual Byte[] GetInfo();
}
public class Org.BouncyCastle.Crypto.Parameters.IesParameters : object {
    private Byte[] derivation;
    private Byte[] encoding;
    private int macKeySize;
    public int MacKeySize { get; }
    public IesParameters(Byte[] derivation, Byte[] encoding, int macKeySize);
    public Byte[] GetDerivationV();
    public Byte[] GetEncodingV();
    public int get_MacKeySize();
}
public class Org.BouncyCastle.Crypto.Parameters.IesWithCipherParameters : IesParameters {
    private int cipherKeySize;
    public int CipherKeySize { get; }
    public IesWithCipherParameters(Byte[] derivation, Byte[] encoding, int macKeySize, int cipherKeySize);
    public int get_CipherKeySize();
}
public class Org.BouncyCastle.Crypto.Parameters.Iso18033KdfParameters : object {
    private Byte[] seed;
    public Iso18033KdfParameters(Byte[] seed);
    public Byte[] GetSeed();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfCounterParameters : object {
    private Byte[] ki;
    private Byte[] fixedInputDataCounterPrefix;
    private Byte[] fixedInputDataCounterSuffix;
    private int r;
    public Byte[] Ki { get; }
    public Byte[] FixedInputData { get; }
    public Byte[] FixedInputDataCounterPrefix { get; }
    public Byte[] FixedInputDataCounterSuffix { get; }
    public int R { get; }
    public KdfCounterParameters(Byte[] ki, Byte[] fixedInputDataCounterSuffix, int r);
    public KdfCounterParameters(Byte[] ki, Byte[] fixedInputDataCounterPrefix, Byte[] fixedInputDataCounterSuffix, int r);
    public Byte[] get_Ki();
    public Byte[] get_FixedInputData();
    public Byte[] get_FixedInputDataCounterPrefix();
    public Byte[] get_FixedInputDataCounterSuffix();
    public int get_R();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfDoublePipelineIterationParameters : object {
    private static int UNUSED_R;
    private Byte[] ki;
    private bool useCounter;
    private int r;
    private Byte[] fixedInputData;
    public Byte[] Ki { get; }
    public bool UseCounter { get; }
    public int R { get; }
    public Byte[] FixedInputData { get; }
    private KdfDoublePipelineIterationParameters(Byte[] ki, Byte[] fixedInputData, int r, bool useCounter);
    private static KdfDoublePipelineIterationParameters();
    public static KdfDoublePipelineIterationParameters CreateWithCounter(Byte[] ki, Byte[] fixedInputData, int r);
    public static KdfDoublePipelineIterationParameters CreateWithoutCounter(Byte[] ki, Byte[] fixedInputData);
    public Byte[] get_Ki();
    public bool get_UseCounter();
    public int get_R();
    public Byte[] get_FixedInputData();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfFeedbackParameters : object {
    private static int UNUSED_R;
    private Byte[] ki;
    private Byte[] iv;
    private bool useCounter;
    private int r;
    private Byte[] fixedInputData;
    public Byte[] Ki { get; }
    public Byte[] Iv { get; }
    public bool UseCounter { get; }
    public int R { get; }
    public Byte[] FixedInputData { get; }
    private KdfFeedbackParameters(Byte[] ki, Byte[] iv, Byte[] fixedInputData, int r, bool useCounter);
    private static KdfFeedbackParameters();
    public static KdfFeedbackParameters CreateWithCounter(Byte[] ki, Byte[] iv, Byte[] fixedInputData, int r);
    public static KdfFeedbackParameters CreateWithoutCounter(Byte[] ki, Byte[] iv, Byte[] fixedInputData);
    public Byte[] get_Ki();
    public Byte[] get_Iv();
    public bool get_UseCounter();
    public int get_R();
    public Byte[] get_FixedInputData();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfParameters : object {
    private Byte[] m_iv;
    private Byte[] m_shared;
    public KdfParameters(Byte[] shared, Byte[] iv);
    public Byte[] GetSharedSecret();
    public Byte[] GetIV();
}
public class Org.BouncyCastle.Crypto.Parameters.KeyParameter : object {
    private Byte[] m_key;
    public int KeyLength { get; }
    public KeyParameter(Byte[] key);
    public KeyParameter(Byte[] key, int keyOff, int keyLen);
    private KeyParameter(int length);
    internal void CopyTo(Byte[] buf, int off, int len);
    public Byte[] GetKey();
    public int get_KeyLength();
    internal bool FixedTimeEquals(Byte[] data);
}
public class Org.BouncyCastle.Crypto.Parameters.MgfParameters : object {
    private Byte[] m_seed;
    public int SeedLength { get; }
    public MgfParameters(Byte[] seed);
    public MgfParameters(Byte[] seed, int off, int len);
    public Byte[] GetSeed();
    public void GetSeed(Byte[] buffer, int offset);
    public int get_SeedLength();
}
public class Org.BouncyCastle.Crypto.Parameters.MqvPrivateParameters : object {
    private ECPrivateKeyParameters staticPrivateKey;
    private ECPrivateKeyParameters ephemeralPrivateKey;
    private ECPublicKeyParameters ephemeralPublicKey;
    public ECPrivateKeyParameters StaticPrivateKey { get; }
    public ECPrivateKeyParameters EphemeralPrivateKey { get; }
    public ECPublicKeyParameters EphemeralPublicKey { get; }
    public MqvPrivateParameters(ECPrivateKeyParameters staticPrivateKey, ECPrivateKeyParameters ephemeralPrivateKey);
    public MqvPrivateParameters(ECPrivateKeyParameters staticPrivateKey, ECPrivateKeyParameters ephemeralPrivateKey, ECPublicKeyParameters ephemeralPublicKey);
    public virtual ECPrivateKeyParameters get_StaticPrivateKey();
    public virtual ECPrivateKeyParameters get_EphemeralPrivateKey();
    public virtual ECPublicKeyParameters get_EphemeralPublicKey();
}
public class Org.BouncyCastle.Crypto.Parameters.MqvPublicParameters : object {
    private ECPublicKeyParameters staticPublicKey;
    private ECPublicKeyParameters ephemeralPublicKey;
    public ECPublicKeyParameters StaticPublicKey { get; }
    public ECPublicKeyParameters EphemeralPublicKey { get; }
    public MqvPublicParameters(ECPublicKeyParameters staticPublicKey, ECPublicKeyParameters ephemeralPublicKey);
    public virtual ECPublicKeyParameters get_StaticPublicKey();
    public virtual ECPublicKeyParameters get_EphemeralPublicKey();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters : KeyGenerationParameters {
    private int certainty;
    private int countSmallPrimes;
    public int Certainty { get; }
    public int CountSmallPrimes { get; }
    public NaccacheSternKeyGenerationParameters(SecureRandom random, int strength, int certainty, int countSmallPrimes);
    public int get_Certainty();
    public int get_CountSmallPrimes();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters : AsymmetricKeyParameter {
    private BigInteger g;
    private BigInteger n;
    private int lowerSigmaBound;
    public BigInteger G { get; }
    public int LowerSigmaBound { get; }
    public BigInteger Modulus { get; }
    public NaccacheSternKeyParameters(bool privateKey, BigInteger g, BigInteger n, int lowerSigmaBound);
    public BigInteger get_G();
    public int get_LowerSigmaBound();
    public BigInteger get_Modulus();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters : NaccacheSternKeyParameters {
    private BigInteger phiN;
    private IList`1<BigInteger> smallPrimes;
    public BigInteger PhiN { get; }
    public IList`1<BigInteger> SmallPrimesList { get; }
    public NaccacheSternPrivateKeyParameters(BigInteger g, BigInteger n, int lowerSigmaBound, IList`1<BigInteger> smallPrimes, BigInteger phiN);
    public BigInteger get_PhiN();
    public IList`1<BigInteger> get_SmallPrimesList();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithID : object {
    private ICipherParameters m_parameters;
    private Byte[] m_id;
    public ICipherParameters Parameters { get; }
    public ParametersWithID(ICipherParameters parameters, Byte[] id);
    public ParametersWithID(ICipherParameters parameters, Byte[] id, int idOff, int idLen);
    public Byte[] GetID();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithIV : object {
    private ICipherParameters m_parameters;
    private Byte[] m_iv;
    public int IVLength { get; }
    public ICipherParameters Parameters { get; }
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv);
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv, int ivOff, int ivLen);
    private ParametersWithIV(ICipherParameters parameters, int ivLength);
    internal static ICipherParameters ApplyOptionalIV(ICipherParameters parameters, Byte[] iv);
    public Byte[] GetIV();
    public int get_IVLength();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithRandom : object {
    private ICipherParameters m_parameters;
    private SecureRandom m_random;
    public ICipherParameters Parameters { get; }
    public SecureRandom Random { get; }
    public ParametersWithRandom(ICipherParameters parameters);
    public ParametersWithRandom(ICipherParameters parameters, SecureRandom random);
    public ICipherParameters get_Parameters();
    public SecureRandom get_Random();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithSalt : object {
    private ICipherParameters m_parameters;
    private Byte[] m_salt;
    public ICipherParameters Parameters { get; }
    public ParametersWithSalt(ICipherParameters parameters, Byte[] salt);
    public ParametersWithSalt(ICipherParameters parameters, Byte[] salt, int saltOff, int saltLen);
    public Byte[] GetSalt();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithSBox : object {
    private ICipherParameters m_parameters;
    private Byte[] m_sBox;
    public ICipherParameters Parameters { get; }
    public ParametersWithSBox(ICipherParameters parameters, Byte[] sBox);
    public Byte[] GetSBox();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.RC2Parameters : KeyParameter {
    private int bits;
    public int EffectiveKeyBits { get; }
    public RC2Parameters(Byte[] key);
    public RC2Parameters(Byte[] key, int keyOff, int keyLen);
    public RC2Parameters(Byte[] key, int bits);
    public RC2Parameters(Byte[] key, int keyOff, int keyLen, int bits);
    public int get_EffectiveKeyBits();
}
public class Org.BouncyCastle.Crypto.Parameters.RC5Parameters : KeyParameter {
    private int rounds;
    public int Rounds { get; }
    public RC5Parameters(Byte[] key, int rounds);
    public int get_Rounds();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaBlindingParameters : object {
    private RsaKeyParameters publicKey;
    private BigInteger blindingFactor;
    public RsaKeyParameters PublicKey { get; }
    public BigInteger BlindingFactor { get; }
    public RsaBlindingParameters(RsaKeyParameters publicKey, BigInteger blindingFactor);
    public RsaKeyParameters get_PublicKey();
    public BigInteger get_BlindingFactor();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaKeyGenerationParameters : KeyGenerationParameters {
    private BigInteger publicExponent;
    private int certainty;
    public BigInteger PublicExponent { get; }
    public int Certainty { get; }
    public RsaKeyGenerationParameters(BigInteger publicExponent, SecureRandom random, int strength, int certainty);
    public BigInteger get_PublicExponent();
    public int get_Certainty();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaKeyParameters : AsymmetricKeyParameter {
    private static BigInteger SmallPrimesProduct;
    private BigInteger modulus;
    private BigInteger exponent;
    public BigInteger Modulus { get; }
    public BigInteger Exponent { get; }
    public RsaKeyParameters(bool isPrivate, BigInteger modulus, BigInteger exponent);
    private static RsaKeyParameters();
    private static BigInteger Validate(BigInteger modulus);
    public BigInteger get_Modulus();
    public BigInteger get_Exponent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static int AsInteger(string envVariable, int defaultValue);
}
public class Org.BouncyCastle.Crypto.Parameters.RsaPrivateCrtKeyParameters : RsaKeyParameters {
    private BigInteger e;
    private BigInteger p;
    private BigInteger q;
    private BigInteger dP;
    private BigInteger dQ;
    private BigInteger qInv;
    public BigInteger PublicExponent { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger DP { get; }
    public BigInteger DQ { get; }
    public BigInteger QInv { get; }
    public RsaPrivateCrtKeyParameters(BigInteger modulus, BigInteger publicExponent, BigInteger privateExponent, BigInteger p, BigInteger q, BigInteger dP, BigInteger dQ, BigInteger qInv);
    public RsaPrivateCrtKeyParameters(RsaPrivateKeyStructure rsaPrivateKey);
    public BigInteger get_PublicExponent();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_DP();
    public BigInteger get_DQ();
    public BigInteger get_QInv();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static void ValidateValue(BigInteger x, string name, string desc);
}
public class Org.BouncyCastle.Crypto.Parameters.SkeinParameters : object {
    public static int PARAM_TYPE_KEY;
    public static int PARAM_TYPE_CONFIG;
    public static int PARAM_TYPE_PERSONALISATION;
    public static int PARAM_TYPE_PUBLIC_KEY;
    public static int PARAM_TYPE_KEY_IDENTIFIER;
    public static int PARAM_TYPE_NONCE;
    public static int PARAM_TYPE_MESSAGE;
    public static int PARAM_TYPE_OUTPUT;
    private IDictionary`2<int, Byte[]> m_parameters;
    private SkeinParameters(IDictionary`2<int, Byte[]> parameters);
    public IDictionary`2<int, Byte[]> GetParameters();
    public Byte[] GetKey();
    public Byte[] GetPersonalisation();
    public Byte[] GetPublicKey();
    public Byte[] GetKeyIdentifier();
    public Byte[] GetNonce();
}
public class Org.BouncyCastle.Crypto.Parameters.SM2KeyExchangePrivateParameters : object {
    private bool mInitiator;
    private ECPrivateKeyParameters mStaticPrivateKey;
    private ECPoint mStaticPublicPoint;
    private ECPrivateKeyParameters mEphemeralPrivateKey;
    private ECPoint mEphemeralPublicPoint;
    public bool IsInitiator { get; }
    public ECPrivateKeyParameters StaticPrivateKey { get; }
    public ECPoint StaticPublicPoint { get; }
    public ECPrivateKeyParameters EphemeralPrivateKey { get; }
    public ECPoint EphemeralPublicPoint { get; }
    public SM2KeyExchangePrivateParameters(bool initiator, ECPrivateKeyParameters staticPrivateKey, ECPrivateKeyParameters ephemeralPrivateKey);
    public virtual bool get_IsInitiator();
    public virtual ECPrivateKeyParameters get_StaticPrivateKey();
    public virtual ECPoint get_StaticPublicPoint();
    public virtual ECPrivateKeyParameters get_EphemeralPrivateKey();
    public virtual ECPoint get_EphemeralPublicPoint();
}
public class Org.BouncyCastle.Crypto.Parameters.SM2KeyExchangePublicParameters : object {
    private ECPublicKeyParameters mStaticPublicKey;
    private ECPublicKeyParameters mEphemeralPublicKey;
    public ECPublicKeyParameters StaticPublicKey { get; }
    public ECPublicKeyParameters EphemeralPublicKey { get; }
    public SM2KeyExchangePublicParameters(ECPublicKeyParameters staticPublicKey, ECPublicKeyParameters ephemeralPublicKey);
    public virtual ECPublicKeyParameters get_StaticPublicKey();
    public virtual ECPublicKeyParameters get_EphemeralPublicKey();
}
public class Org.BouncyCastle.Crypto.Parameters.Srp6GroupParameters : object {
    private BigInteger n;
    private BigInteger g;
    public BigInteger G { get; }
    public BigInteger N { get; }
    public Srp6GroupParameters(BigInteger N, BigInteger g);
    public BigInteger get_G();
    public BigInteger get_N();
}
public class Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters : object {
    private Byte[] tweak;
    private KeyParameter key;
    public KeyParameter Key { get; }
    public Byte[] Tweak { get; }
    public TweakableBlockCipherParameters(KeyParameter key, Byte[] tweak);
    public KeyParameter get_Key();
    public Byte[] get_Tweak();
}
public class Org.BouncyCastle.Crypto.Parameters.X25519KeyGenerationParameters : KeyGenerationParameters {
    public X25519KeyGenerationParameters(SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Parameters.X25519PrivateKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    public static int SecretSize;
    private Byte[] data;
    public X25519PrivateKeyParameters(SecureRandom random);
    public X25519PrivateKeyParameters(Byte[] buf);
    public X25519PrivateKeyParameters(Byte[] buf, int off);
    public X25519PrivateKeyParameters(Stream input);
    private static X25519PrivateKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public X25519PublicKeyParameters GeneratePublicKey();
    public void GenerateSecret(X25519PublicKeyParameters publicKey, Byte[] buf, int off);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.X25519PublicKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    private Byte[] data;
    public X25519PublicKeyParameters(Byte[] buf);
    public X25519PublicKeyParameters(Byte[] buf, int off);
    public X25519PublicKeyParameters(Stream input);
    private static X25519PublicKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.X448KeyGenerationParameters : KeyGenerationParameters {
    public X448KeyGenerationParameters(SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Parameters.X448PrivateKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    public static int SecretSize;
    private Byte[] data;
    public X448PrivateKeyParameters(SecureRandom random);
    public X448PrivateKeyParameters(Byte[] buf);
    public X448PrivateKeyParameters(Byte[] buf, int off);
    public X448PrivateKeyParameters(Stream input);
    private static X448PrivateKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public X448PublicKeyParameters GeneratePublicKey();
    public void GenerateSecret(X448PublicKeyParameters publicKey, Byte[] buf, int off);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.X448PublicKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    private Byte[] data;
    public X448PublicKeyParameters(Byte[] buf);
    public X448PublicKeyParameters(Byte[] buf, int off);
    public X448PublicKeyParameters(Stream input);
    private static X448PublicKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    private static Byte[] Validate(Byte[] buf);
}
public abstract class Org.BouncyCastle.Crypto.PbeParametersGenerator : object {
    protected Byte[] mPassword;
    protected Byte[] mSalt;
    protected int mIterationCount;
    public Byte[] Password { get; }
    public Byte[] Salt { get; }
    public int IterationCount { get; }
    public virtual void Init(Byte[] password, Byte[] salt, int iterationCount);
    public virtual Byte[] get_Password();
    public virtual Byte[] get_Salt();
    public virtual int get_IterationCount();
    public abstract virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    public abstract virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public abstract virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
    public static Byte[] Pkcs5PasswordToBytes(Char[] password);
    public static Byte[] Pkcs5PasswordToUtf8Bytes(Char[] password);
    public static Byte[] Pkcs12PasswordToBytes(Char[] password);
    public static Byte[] Pkcs12PasswordToBytes(Char[] password, bool wrongPkcs12Zero);
}
public class Org.BouncyCastle.Crypto.Prng.BasicEntropySourceProvider : object {
    private SecureRandom mSecureRandom;
    private bool mPredictionResistant;
    public BasicEntropySourceProvider(SecureRandom secureRandom, bool isPredictionResistant);
    public sealed virtual IEntropySource Get(int bitsRequired);
}
public class Org.BouncyCastle.Crypto.Prng.CryptoApiEntropySourceProvider : object {
    private RandomNumberGenerator mRng;
    private bool mPredictionResistant;
    public CryptoApiEntropySourceProvider(RandomNumberGenerator rng, bool isPredictionResistant);
    public sealed virtual IEntropySource Get(int bitsRequired);
}
public class Org.BouncyCastle.Crypto.Prng.CryptoApiRandomGenerator : object {
    private RandomNumberGenerator m_randomNumberGenerator;
    public CryptoApiRandomGenerator(RandomNumberGenerator randomNumberGenerator);
    public sealed virtual void AddSeedMaterial(Byte[] seed);
    public sealed virtual void AddSeedMaterial(long seed);
    public sealed virtual void NextBytes(Byte[] bytes);
    public sealed virtual void NextBytes(Byte[] bytes, int start, int len);
    public sealed virtual void Dispose();
}
public class Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator : object {
    private static long CYCLE_COUNT;
    private long stateCounter;
    private long seedCounter;
    private IDigest digest;
    private Byte[] state;
    private Byte[] seed;
    public DigestRandomGenerator(IDigest digest);
    public sealed virtual void AddSeedMaterial(Byte[] inSeed);
    public sealed virtual void AddSeedMaterial(long rSeed);
    public sealed virtual void NextBytes(Byte[] bytes);
    public sealed virtual void NextBytes(Byte[] bytes, int start, int len);
    private void CycleSeed();
    private void GenerateState();
    private void DigestAddCounter(long seedVal);
    private void DigestUpdate(Byte[] inSeed);
    private void DigestDoFinal(Byte[] result);
}
public class Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg : object {
    private static long TDEA_RESEED_MAX;
    private static long AES_RESEED_MAX;
    private static int TDEA_MAX_BITS_REQUEST;
    private static int AES_MAX_BITS_REQUEST;
    private IEntropySource mEntropySource;
    private IBlockCipher mEngine;
    private int mKeySizeInBits;
    private int mSeedLength;
    private int mSecurityStrength;
    private Byte[] mKey;
    private Byte[] mV;
    private long mReseedCounter;
    private bool mIsTdea;
    private static Byte[] K_BITS;
    public int BlockSize { get; }
    public CtrSP800Drbg(IBlockCipher engine, int keySizeInBits, int securityStrength, IEntropySource entropySource, Byte[] personalizationString, Byte[] nonce);
    private static CtrSP800Drbg();
    private void CTR_DRBG_Instantiate_algorithm(Byte[] personalisationString, Byte[] nonce);
    private void CTR_DRBG_Update(Byte[] seed, Byte[] key, Byte[] v);
    private void CTR_DRBG_Reseed_algorithm(Byte[] additionalInput);
    private void Xor(Byte[] output, Byte[] a, Byte[] b, int bOff);
    private void AddOneTo(Byte[] longer);
    private Byte[] GetEntropy();
    private Byte[] BlockCipherDF(Byte[] input, int N);
    private void BCC(Byte[] bccOut, Byte[] iV, Byte[] data);
    public sealed virtual int get_BlockSize();
    public sealed virtual int Generate(Byte[] output, int outputOff, int outputLen, Byte[] additionalInput, bool predictionResistant);
    public sealed virtual void Reseed(Byte[] additionalInput);
    private bool IsTdea(IBlockCipher cipher);
    private int GetMaxSecurityStrength(IBlockCipher cipher, int keySizeInBits);
    private KeyParameter ExpandToKeyParameter(Byte[] key);
    private void PadKey(Byte[] keyMaster, int keyOff, Byte[] tmp, int tmpOff);
}
internal class Org.BouncyCastle.Crypto.Prng.Drbg.DrbgUtilities : object {
    private static IDictionary`2<string, int> MaxSecurityStrengths;
    private static DrbgUtilities();
    internal static int GetMaxSecurityStrength(IDigest d);
    internal static int GetMaxSecurityStrength(IMac m);
    internal static void HashDF(IDigest digest, Byte[] seedMaterial, int seedLength, Byte[] output);
}
public class Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg : object {
    private static Byte[] ONE;
    private static long RESEED_MAX;
    private static int MAX_BITS_REQUEST;
    private static IDictionary`2<string, int> SeedLens;
    private IDigest mDigest;
    private IEntropySource mEntropySource;
    private int mSecurityStrength;
    private int mSeedLength;
    private Byte[] mV;
    private Byte[] mC;
    private long mReseedCounter;
    public int BlockSize { get; }
    private static HashSP800Drbg();
    public HashSP800Drbg(IDigest digest, int securityStrength, IEntropySource entropySource, Byte[] personalizationString, Byte[] nonce);
    public sealed virtual int get_BlockSize();
    public sealed virtual int Generate(Byte[] output, int outputOff, int outputLen, Byte[] additionalInput, bool predictionResistant);
    private Byte[] GetEntropy();
    private void AddTo(Byte[] longer, Byte[] shorter);
    public sealed virtual void Reseed(Byte[] additionalInput);
    private void DoHash(Byte[] input, Byte[] output);
    private Byte[] Hash(Byte[] input);
    private Byte[] Hashgen(Byte[] input, int length);
}
public class Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg : object {
    private static long RESEED_MAX;
    private static int MAX_BITS_REQUEST;
    private Byte[] mK;
    private Byte[] mV;
    private IEntropySource mEntropySource;
    private IMac mHMac;
    private int mSecurityStrength;
    private long mReseedCounter;
    public int BlockSize { get; }
    public HMacSP800Drbg(IMac hMac, int securityStrength, IEntropySource entropySource, Byte[] personalizationString, Byte[] nonce);
    private static HMacSP800Drbg();
    private void hmac_DRBG_Update(Byte[] seedMaterial);
    private void hmac_DRBG_Update_Func(Byte[] seedMaterial, byte vValue);
    public sealed virtual int get_BlockSize();
    public sealed virtual int Generate(Byte[] output, int outputOff, int outputLen, Byte[] additionalInput, bool predictionResistant);
    public sealed virtual void Reseed(Byte[] additionalInput);
    private Byte[] GetEntropy();
}
public interface Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg {
    public int BlockSize { get; }
    public abstract virtual int get_BlockSize();
    public abstract virtual int Generate(Byte[] output, int outputOff, int outputLen, Byte[] additionalInput, bool predictionResistant);
    public abstract virtual void Reseed(Byte[] additionalInput);
}
public abstract class Org.BouncyCastle.Crypto.Prng.EntropyUtilities : object {
    public static Byte[] GenerateSeed(IEntropySource entropySource, int numBytes);
}
internal interface Org.BouncyCastle.Crypto.Prng.IDrbgProvider {
    public abstract virtual ISP80090Drbg Get(IEntropySource entropySource);
}
public interface Org.BouncyCastle.Crypto.Prng.IRandomGenerator {
    public abstract virtual void AddSeedMaterial(Byte[] seed);
    public abstract virtual void AddSeedMaterial(long seed);
    public abstract virtual void NextBytes(Byte[] bytes);
    public abstract virtual void NextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.SP800SecureRandom : SecureRandom {
    private IDrbgProvider mDrbgProvider;
    private bool mPredictionResistant;
    private SecureRandom mRandomSource;
    private IEntropySource mEntropySource;
    private ISP80090Drbg mDrbg;
    internal SP800SecureRandom(SecureRandom randomSource, IEntropySource entropySource, IDrbgProvider drbgProvider, bool predictionResistant);
    public virtual void SetSeed(Byte[] seed);
    public virtual void SetSeed(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] buf, int off, int len);
    public virtual Byte[] GenerateSeed(int numBytes);
    public virtual void Reseed(Byte[] additionalInput);
}
public class Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder : object {
    private SecureRandom mRandom;
    private IEntropySourceProvider mEntropySourceProvider;
    private Byte[] mPersonalizationString;
    private int mSecurityStrength;
    private int mEntropyBitsRequired;
    public SP800SecureRandomBuilder(SecureRandom entropySource, bool predictionResistant);
    public SP800SecureRandomBuilder(IEntropySourceProvider entropySourceProvider);
    public SP800SecureRandomBuilder SetPersonalizationString(Byte[] personalizationString);
    public SP800SecureRandomBuilder SetSecurityStrength(int securityStrength);
    public SP800SecureRandomBuilder SetEntropyBitsRequired(int entropyBitsRequired);
    public SP800SecureRandom BuildHash(IDigest digest, Byte[] nonce, bool predictionResistant);
    public SP800SecureRandom BuildCtr(IBlockCipher cipher, int keySizeInBits, Byte[] nonce, bool predictionResistant);
    public SP800SecureRandom BuildHMac(IMac hMac, Byte[] nonce, bool predictionResistant);
}
public class Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator : object {
    private Byte[] P;
    private byte s;
    private byte n;
    public sealed virtual void AddSeedMaterial(Byte[] seed);
    public sealed virtual void AddSeedMaterial(long seed);
    public sealed virtual void NextBytes(Byte[] bytes);
    public sealed virtual void NextBytes(Byte[] bytes, int start, int len);
}
internal class Org.BouncyCastle.Crypto.Prng.X931Rng : object {
    private static long BLOCK64_RESEED_MAX;
    private static long BLOCK128_RESEED_MAX;
    private static int BLOCK64_MAX_BITS_REQUEST;
    private static int BLOCK128_MAX_BITS_REQUEST;
    private IBlockCipher mEngine;
    private IEntropySource mEntropySource;
    private Byte[] mDT;
    private Byte[] mI;
    private Byte[] mR;
    private Byte[] mV;
    private long mReseedCounter;
    internal IEntropySource EntropySource { get; }
    internal X931Rng(IBlockCipher engine, Byte[] dateTimeVector, IEntropySource entropySource);
    internal int Generate(Byte[] output, int outputOff, int outputLen, bool predictionResistant);
    internal void Reseed();
    internal IEntropySource get_EntropySource();
    private void Process(Byte[] res, Byte[] a, Byte[] b);
    private void Increment(Byte[] val);
}
public class Org.BouncyCastle.Crypto.Prng.X931SecureRandom : SecureRandom {
    private bool mPredictionResistant;
    private SecureRandom mRandomSource;
    private X931Rng mDrbg;
    internal X931SecureRandom(SecureRandom randomSource, X931Rng drbg, bool predictionResistant);
    public virtual void SetSeed(Byte[] seed);
    public virtual void SetSeed(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] buf, int off, int len);
    public virtual Byte[] GenerateSeed(int numBytes);
}
public class Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder : object {
    private SecureRandom mRandom;
    private IEntropySourceProvider mEntropySourceProvider;
    private Byte[] mDateTimeVector;
    public X931SecureRandomBuilder(SecureRandom entropySource, bool predictionResistant);
    public X931SecureRandomBuilder(IEntropySourceProvider entropySourceProvider);
    public X931SecureRandomBuilder SetDateTimeVector(Byte[] dateTimeVector);
    public X931SecureRandom Build(IBlockCipher engine, KeyParameter key, bool predictionResistant);
}
public class Org.BouncyCastle.Crypto.Signers.DsaDigestSigner : object {
    private IDsa dsa;
    private IDigest digest;
    private IDsaEncoding encoding;
    private bool forSigning;
    public string AlgorithmName { get; }
    public DsaDigestSigner(IDsa dsa, IDigest digest);
    public DsaDigestSigner(IDsa dsa, IDigest digest, IDsaEncoding encoding);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    protected virtual BigInteger GetOrder();
}
public class Org.BouncyCastle.Crypto.Signers.DsaSigner : object {
    protected IDsaKCalculator kCalculator;
    protected DsaKeyParameters key;
    protected SecureRandom random;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public DsaSigner(IDsaKCalculator kCalculator);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    protected virtual BigInteger CalculateE(BigInteger n, Byte[] message);
    protected virtual SecureRandom InitSecureRandom(bool needed, SecureRandom provided);
}
public class Org.BouncyCastle.Crypto.Signers.ECDsaSigner : object {
    private static BigInteger Eight;
    protected IDsaKCalculator kCalculator;
    protected ECKeyParameters key;
    protected SecureRandom random;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public ECDsaSigner(IDsaKCalculator kCalculator);
    private static ECDsaSigner();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    protected virtual BigInteger CalculateE(BigInteger n, Byte[] message);
    protected virtual ECMultiplier CreateBasePointMultiplier();
    protected virtual ECFieldElement GetDenominator(int coordinateSystem, ECPoint p);
    protected virtual SecureRandom InitSecureRandom(bool needed, SecureRandom provided);
}
public class Org.BouncyCastle.Crypto.Signers.ECGost3410Signer : object {
    private ECKeyParameters key;
    private SecureRandom random;
    private bool forSigning;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    protected virtual ECMultiplier CreateBasePointMultiplier();
}
public class Org.BouncyCastle.Crypto.Signers.ECNRSigner : object {
    private bool forSigning;
    private ECKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.Ed25519ctxSigner : object {
    private Buffer buffer;
    private Byte[] context;
    private bool forSigning;
    private Ed25519PrivateKeyParameters privateKey;
    private Ed25519PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public Ed25519ctxSigner(Byte[] context);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Ed25519phSigner : object {
    private IDigest prehash;
    private Byte[] context;
    private bool forSigning;
    private Ed25519PrivateKeyParameters privateKey;
    private Ed25519PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public Ed25519phSigner(Byte[] context);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Ed25519Signer : object {
    private Buffer buffer;
    private bool forSigning;
    private Ed25519PrivateKeyParameters privateKey;
    private Ed25519PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Ed448phSigner : object {
    private IXof prehash;
    private Byte[] context;
    private bool forSigning;
    private Ed448PrivateKeyParameters privateKey;
    private Ed448PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public Ed448phSigner(Byte[] context);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Ed448Signer : object {
    private Buffer buffer;
    private Byte[] context;
    private bool forSigning;
    private Ed448PrivateKeyParameters privateKey;
    private Ed448PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public Ed448Signer(Byte[] context);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.GenericSigner : object {
    private IAsymmetricBlockCipher engine;
    private IDigest digest;
    private bool forSigning;
    public string AlgorithmName { get; }
    public GenericSigner(IAsymmetricBlockCipher engine, IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner : object {
    private IDigest digest;
    private IDsa dsaSigner;
    private int size;
    private int halfSize;
    private bool forSigning;
    public string AlgorithmName { get; }
    public Gost3410DigestSigner(IDsa signer, IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Gost3410Signer : object {
    private Gost3410KeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.HMacDsaKCalculator : object {
    private HMac hMac;
    private Byte[] K;
    private Byte[] V;
    private BigInteger n;
    public bool IsDeterministic { get; }
    public HMacDsaKCalculator(IDigest digest);
    public virtual bool get_IsDeterministic();
    public virtual void Init(BigInteger n, SecureRandom random);
    public sealed virtual void Init(BigInteger n, BigInteger d, Byte[] message);
    public virtual BigInteger NextK();
    protected virtual void InitAdditionalInput0(HMac hmac0);
    private BigInteger BitsToInt(Byte[] t);
}
public interface Org.BouncyCastle.Crypto.Signers.IDsaEncoding {
    public abstract virtual BigInteger[] Decode(BigInteger n, Byte[] encoding);
    public abstract virtual Byte[] Encode(BigInteger n, BigInteger r, BigInteger s);
    public abstract virtual int GetMaxEncodingSize(BigInteger n);
}
public interface Org.BouncyCastle.Crypto.Signers.IDsaKCalculator {
    public bool IsDeterministic { get; }
    public abstract virtual bool get_IsDeterministic();
    public abstract virtual void Init(BigInteger n, SecureRandom random);
    public abstract virtual void Init(BigInteger n, BigInteger d, Byte[] message);
    public abstract virtual BigInteger NextK();
}
public class Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner : object {
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private SecureRandom random;
    private Byte[] standardSalt;
    private int hLen;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    private Byte[] mBuf;
    private int messageLength;
    private int saltLength;
    private bool fullMessage;
    private Byte[] recoveredMessage;
    private Byte[] preSig;
    private Byte[] preBlock;
    private int preMStart;
    private int preTLength;
    public string AlgorithmName { get; }
    public Iso9796d2PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLength, bool isImplicit);
    public Iso9796d2PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLength);
    public sealed virtual Byte[] GetRecoveredMessage();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] block);
    public virtual void UpdateWithRecoveredMessage(Byte[] signature);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    public virtual bool HasFullMessage();
    private void ItoOSP(int i, Byte[] sp);
    private void LtoOSP(long l, Byte[] sp);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer : object {
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    private Byte[] mBuf;
    private int messageLength;
    private bool fullMessage;
    private Byte[] recoveredMessage;
    private Byte[] preSig;
    private Byte[] preBlock;
    public string AlgorithmName { get; }
    public Iso9796d2Signer(IAsymmetricBlockCipher cipher, IDigest digest, bool isImplicit);
    public Iso9796d2Signer(IAsymmetricBlockCipher cipher, IDigest digest);
    public sealed virtual Byte[] GetRecoveredMessage();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] block);
    public virtual void UpdateWithRecoveredMessage(Byte[] signature);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    private bool ReturnFalse(Byte[] block);
    public virtual bool HasFullMessage();
}
public class Org.BouncyCastle.Crypto.Signers.IsoTrailers : object {
    public static int TRAILER_IMPLICIT;
    public static int TRAILER_RIPEMD160;
    public static int TRAILER_RIPEMD128;
    public static int TRAILER_SHA1;
    public static int TRAILER_SHA256;
    public static int TRAILER_SHA512;
    public static int TRAILER_SHA384;
    public static int TRAILER_WHIRLPOOL;
    public static int TRAILER_SHA224;
    public static int TRAILER_SHA512_224;
    public static int TRAILER_SHA512_256;
    private static IDictionary`2<string, int> TrailerMap;
    private static IsoTrailers();
    private static IDictionary`2<string, int> CreateTrailerMap();
    public static int GetTrailer(IDigest digest);
    public static bool NoTrailerAvailable(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Signers.PlainDsaEncoding : object {
    public static PlainDsaEncoding Instance;
    private static PlainDsaEncoding();
    public virtual BigInteger[] Decode(BigInteger n, Byte[] encoding);
    public virtual Byte[] Encode(BigInteger n, BigInteger r, BigInteger s);
    public virtual int GetMaxEncodingSize(BigInteger n);
    protected virtual BigInteger CheckValue(BigInteger n, BigInteger x);
    protected virtual BigInteger DecodeValue(BigInteger n, Byte[] buf, int off, int len);
    protected virtual void EncodeValue(BigInteger n, BigInteger x, Byte[] buf, int off, int len);
}
public class Org.BouncyCastle.Crypto.Signers.PssSigner : object {
    public static byte TrailerImplicit;
    private IDigest contentDigest1;
    private IDigest contentDigest2;
    private IDigest mgfDigest;
    private IAsymmetricBlockCipher cipher;
    private SecureRandom random;
    private int hLen;
    private int mgfhLen;
    private int sLen;
    private bool sSet;
    private int emBits;
    private Byte[] salt;
    private Byte[] mDash;
    private Byte[] block;
    private byte trailer;
    public string AlgorithmName { get; }
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLen);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, Byte[] salt);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, int saltLen);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, Byte[] salt);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLen, byte trailer);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, int saltLen, byte trailer);
    private PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest1, IDigest contentDigest2, IDigest mgfDigest, int saltLen, Byte[] salt, byte trailer);
    public static PssSigner CreateRawSigner(IAsymmetricBlockCipher cipher, IDigest digest);
    public static PssSigner CreateRawSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, int saltLen, byte trailer);
    public static PssSigner CreateRawSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, Byte[] salt, byte trailer);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private void ClearBlock(Byte[] block);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    private void ItoOSP(int i, Byte[] sp);
    private Byte[] MaskGeneratorFunction(Byte[] Z, int zOff, int zLen, int length);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Signers.RandomDsaKCalculator : object {
    private BigInteger q;
    private SecureRandom random;
    public bool IsDeterministic { get; }
    public virtual bool get_IsDeterministic();
    public virtual void Init(BigInteger n, SecureRandom random);
    public virtual void Init(BigInteger n, BigInteger d, Byte[] message);
    public virtual BigInteger NextK();
}
public class Org.BouncyCastle.Crypto.Signers.RsaDigestSigner : object {
    private IAsymmetricBlockCipher rsaEngine;
    private AlgorithmIdentifier algId;
    private IDigest digest;
    private bool forSigning;
    private static IDictionary`2<string, DerObjectIdentifier> OidMap;
    public string AlgorithmName { get; }
    private static RsaDigestSigner();
    public RsaDigestSigner(IDigest digest);
    public RsaDigestSigner(IDigest digest, DerObjectIdentifier digestOid);
    public RsaDigestSigner(IDigest digest, AlgorithmIdentifier algId);
    public RsaDigestSigner(IRsa rsa, IDigest digest, DerObjectIdentifier digestOid);
    public RsaDigestSigner(IRsa rsa, IDigest digest, AlgorithmIdentifier algId);
    public RsaDigestSigner(IAsymmetricBlockCipher rsaEngine, IDigest digest, AlgorithmIdentifier algId);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    private Byte[] DerEncode(Byte[] hash);
}
public class Org.BouncyCastle.Crypto.Signers.SM2Signer : object {
    private IDsaKCalculator kCalculator;
    private IDigest digest;
    private IDsaEncoding encoding;
    private ECDomainParameters ecParams;
    private ECPoint pubPoint;
    private ECKeyParameters ecKey;
    private Byte[] z;
    public string AlgorithmName { get; }
    public SM2Signer(IDigest digest);
    public SM2Signer(IDsaEncoding encoding);
    public SM2Signer(IDsaEncoding encoding, IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    private bool VerifySignature(BigInteger r, BigInteger s);
    private Byte[] GetZ(Byte[] userID);
    private void AddUserID(IDigest digest, Byte[] userID);
    private void AddFieldElement(IDigest digest, ECFieldElement v);
    protected virtual BigInteger CalculateE(BigInteger n, Byte[] message);
    protected virtual ECMultiplier CreateBasePointMultiplier();
}
public class Org.BouncyCastle.Crypto.Signers.StandardDsaEncoding : object {
    public static StandardDsaEncoding Instance;
    private static StandardDsaEncoding();
    public virtual BigInteger[] Decode(BigInteger n, Byte[] encoding);
    public virtual Byte[] Encode(BigInteger n, BigInteger r, BigInteger s);
    public virtual int GetMaxEncodingSize(BigInteger n);
    protected virtual BigInteger CheckValue(BigInteger n, BigInteger x);
    protected virtual BigInteger DecodeValue(BigInteger n, Asn1Sequence s, int pos);
    protected virtual DerInteger EncodeValue(BigInteger n, BigInteger x);
}
public class Org.BouncyCastle.Crypto.Signers.X931Signer : object {
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private RsaKeyParameters kParam;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    public string AlgorithmName { get; }
    public X931Signer(IAsymmetricBlockCipher cipher, IDigest digest);
    public X931Signer(IAsymmetricBlockCipher cipher, IDigest digest, bool isImplicit);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] input, int inOff, int inLen);
    public virtual int GetMaxSignatureSize();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    private void CreateSignatureBlock();
}
public class Org.BouncyCastle.Crypto.SimpleBlockResult : object {
    private Byte[] result;
    public SimpleBlockResult(Byte[] result);
    public sealed virtual Byte[] Collect();
    public sealed virtual int Collect(Byte[] buf, int off);
    public sealed virtual int GetMaxResultLength();
}
public class Org.BouncyCastle.Crypto.StreamBlockCipher : object {
    private IBlockCipherMode m_cipherMode;
    private Byte[] oneByte;
    public string AlgorithmName { get; }
    public StreamBlockCipher(IBlockCipherMode cipherMode);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Utilities.AlgorithmIdentifierFactory : object {
    public static DerObjectIdentifier IDEA_CBC;
    public static DerObjectIdentifier CAST5_CBC;
    private static Int16[] rc2Table;
    private static AlgorithmIdentifierFactory();
    public static AlgorithmIdentifier GenerateEncryptionAlgID(DerObjectIdentifier encryptionOID, int keySize, SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Utilities.BasicAlphabetMapper : object {
    private IDictionary`2<char, int> m_indexMap;
    private IList`1<char> m_charMap;
    public int Radix { get; }
    public BasicAlphabetMapper(string alphabet);
    public BasicAlphabetMapper(Char[] alphabet);
    public sealed virtual int get_Radix();
    public sealed virtual Byte[] ConvertToIndexes(Char[] input);
    public sealed virtual Char[] ConvertToChars(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Utilities.CipherFactory : object {
    private static Byte[] RC2Ekb;
    private static CipherFactory();
    public static object CreateContentCipher(bool forEncryption, ICipherParameters encKey, AlgorithmIdentifier encryptionAlgID);
    private static BufferedBlockCipher CreateCipher(DerObjectIdentifier algorithm);
}
public static class Org.BouncyCastle.Crypto.Utilities.CipherKeyGeneratorFactory : object {
    public static CipherKeyGenerator CreateKeyGenerator(DerObjectIdentifier algorithm, SecureRandom random);
    private static CipherKeyGenerator CreateCipherKeyGenerator(SecureRandom random, int keySize);
}
public static class Org.BouncyCastle.Crypto.Utilities.OpenSshPrivateKeyUtilities : object {
    private static Byte[] AUTH_MAGIC;
    private static OpenSshPrivateKeyUtilities();
    public static Byte[] EncodePrivateKey(AsymmetricKeyParameter parameters);
    public static AsymmetricKeyParameter ParsePrivateKeyBlob(Byte[] blob);
    private static bool AllIntegers(Asn1Sequence sequence);
}
public static class Org.BouncyCastle.Crypto.Utilities.OpenSshPublicKeyUtilities : object {
    private static string RSA;
    private static string ECDSA;
    private static string ED_25519;
    private static string DSS;
    private static OpenSshPublicKeyUtilities();
    public static AsymmetricKeyParameter ParsePublicKey(Byte[] encoded);
    public static Byte[] EncodePublicKey(AsymmetricKeyParameter cipherParameters);
    private static AsymmetricKeyParameter ParsePublicKey(SshBuffer buffer);
}
internal static class Org.BouncyCastle.Crypto.Utilities.Pack : object {
    internal static void UInt16_To_BE(ushort n, Byte[] bs);
    internal static void UInt16_To_BE(ushort n, Byte[] bs, int off);
    internal static void UInt16_To_BE(UInt16[] ns, Byte[] bs, int off);
    internal static void UInt16_To_BE(UInt16[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static Byte[] UInt16_To_BE(ushort n);
    internal static Byte[] UInt16_To_BE(UInt16[] ns);
    internal static Byte[] UInt16_To_BE(UInt16[] ns, int nsOff, int nsLen);
    internal static ushort BE_To_UInt16(Byte[] bs, int off);
    internal static void BE_To_UInt16(Byte[] bs, int bsOff, UInt16[] ns, int nsOff);
    internal static UInt16[] BE_To_UInt16(Byte[] bs);
    internal static UInt16[] BE_To_UInt16(Byte[] bs, int off, int len);
    internal static void UInt24_To_BE(UInt32 n, Byte[] bs);
    internal static void UInt24_To_BE(UInt32 n, Byte[] bs, int off);
    internal static UInt32 BE_To_UInt24(Byte[] bs);
    internal static UInt32 BE_To_UInt24(Byte[] bs, int off);
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs, int off);
    internal static void UInt32_To_BE_High(UInt32 n, Byte[] bs, int off, int len);
    internal static void UInt32_To_BE_Low(UInt32 n, Byte[] bs, int off, int len);
    internal static void UInt32_To_BE(UInt32[] ns, Byte[] bs, int off);
    internal static void UInt32_To_BE(UInt32[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static Byte[] UInt32_To_BE(UInt32 n);
    internal static Byte[] UInt32_To_BE(UInt32[] ns);
    internal static UInt32 BE_To_UInt32(Byte[] bs);
    internal static UInt32 BE_To_UInt32(Byte[] bs, int off);
    internal static UInt32 BE_To_UInt32_High(Byte[] bs, int off, int len);
    internal static UInt32 BE_To_UInt32_Low(Byte[] bs, int off, int len);
    internal static void BE_To_UInt32(Byte[] bs, int off, UInt32[] ns);
    internal static void BE_To_UInt32(Byte[] bs, int bsOff, UInt32[] ns, int nsOff, int nsLen);
    internal static Byte[] UInt64_To_BE(ulong n);
    internal static void UInt64_To_BE(ulong n, Byte[] bs);
    internal static void UInt64_To_BE(ulong n, Byte[] bs, int off);
    internal static void UInt64_To_BE_High(ulong n, Byte[] bs, int off, int len);
    internal static void UInt64_To_BE_Low(ulong n, Byte[] bs, int off, int len);
    internal static Byte[] UInt64_To_BE(UInt64[] ns);
    internal static void UInt64_To_BE(UInt64[] ns, Byte[] bs, int off);
    internal static void UInt64_To_BE(UInt64[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static ulong BE_To_UInt64(Byte[] bs);
    internal static ulong BE_To_UInt64(Byte[] bs, int off);
    internal static ulong BE_To_UInt64_High(Byte[] bs, int off, int len);
    internal static ulong BE_To_UInt64_Low(Byte[] bs, int off, int len);
    internal static void BE_To_UInt64(Byte[] bs, int off, UInt64[] ns);
    internal static void BE_To_UInt64(Byte[] bs, int bsOff, UInt64[] ns, int nsOff, int nsLen);
    internal static void UInt16_To_LE(ushort n, Byte[] bs);
    internal static void UInt16_To_LE(ushort n, Byte[] bs, int off);
    internal static Byte[] UInt16_To_LE(ushort n);
    internal static Byte[] UInt16_To_LE(UInt16[] ns);
    internal static void UInt16_To_LE(UInt16[] ns, Byte[] bs, int off);
    internal static void UInt16_To_LE(UInt16[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static ushort LE_To_UInt16(Byte[] bs);
    internal static ushort LE_To_UInt16(Byte[] bs, int off);
    internal static void LE_To_UInt16(Byte[] bs, int off, UInt16[] ns);
    internal static void LE_To_UInt16(Byte[] bs, int bOff, UInt16[] ns, int nOff, int count);
    internal static UInt16[] LE_To_UInt16(Byte[] bs, int off, int count);
    internal static Byte[] UInt32_To_LE(UInt32 n);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs, int off);
    internal static Byte[] UInt32_To_LE(UInt32[] ns);
    internal static void UInt32_To_LE(UInt32[] ns, Byte[] bs, int off);
    internal static void UInt32_To_LE(UInt32[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static UInt32 LE_To_UInt24(Byte[] bs, int off);
    internal static UInt32 LE_To_UInt32(Byte[] bs);
    internal static UInt32 LE_To_UInt32(Byte[] bs, int off);
    internal static void LE_To_UInt32(Byte[] bs, int off, UInt32[] ns);
    internal static void LE_To_UInt32(Byte[] bs, int bOff, UInt32[] ns, int nOff, int count);
    internal static UInt32[] LE_To_UInt32(Byte[] bs, int off, int count);
    internal static Byte[] UInt64_To_LE(ulong n);
    internal static void UInt64_To_LE(ulong n, Byte[] bs);
    internal static void UInt64_To_LE(ulong n, Byte[] bs, int off);
    internal static Byte[] UInt64_To_LE(UInt64[] ns);
    internal static void UInt64_To_LE(UInt64[] ns, Byte[] bs, int off);
    internal static void UInt64_To_LE(UInt64[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static ulong LE_To_UInt64(Byte[] bs);
    internal static ulong LE_To_UInt64(Byte[] bs, int off);
    internal static void LE_To_UInt64(Byte[] bs, int off, UInt64[] ns);
    internal static void LE_To_UInt64(Byte[] bs, int bsOff, UInt64[] ns, int nsOff, int nsLen);
    internal static UInt64[] LE_To_UInt64(Byte[] bs, int off, int count);
}
internal class Org.BouncyCastle.Crypto.Utilities.SshBuffer : object {
    private Byte[] buffer;
    private int pos;
    internal SshBuffer(Byte[] magic, Byte[] buffer);
    internal SshBuffer(Byte[] buffer);
    public int ReadU32();
    public string ReadStringAscii();
    public string ReadStringUtf8();
    public Byte[] ReadBlock();
    public void SkipBlock();
    public Byte[] ReadPaddedBlock();
    public Byte[] ReadPaddedBlock(int blockSize);
    public BigInteger ReadMpint();
    public BigInteger ReadMpintPositive();
    public bool HasRemaining();
}
internal class Org.BouncyCastle.Crypto.Utilities.SshBuilder : object {
    private MemoryStream bos;
    public void U32(UInt32 value);
    public void WriteMpint(BigInteger n);
    public void WriteBlock(Byte[] value);
    public void WriteBytes(Byte[] value);
    public void WriteStringAscii(string str);
    public void WriteStringUtf8(string str);
    public Byte[] GetBytes();
    public Byte[] GetPaddedBytes();
    public Byte[] GetPaddedBytes(int blockSize);
}
public static class Org.BouncyCastle.Crypto.Utilities.SshNamedCurves : object {
    private static Dictionary`2<string, DerObjectIdentifier> objIds;
    private static Dictionary`2<DerObjectIdentifier, string> names;
    public static IEnumerable`1<string> Names { get; }
    private static SshNamedCurves();
    private static void DefineCurveAlias(string name, DerObjectIdentifier oid);
    private static X9ECParametersHolder FindByOidLazy(DerObjectIdentifier oid);
    public static X9ECParameters GetByName(string name);
    public static X9ECParametersHolder GetByNameLazy(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParametersHolder GetByOidLazy(DerObjectIdentifier oid);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static IEnumerable`1<string> get_Names();
}
public class Org.BouncyCastle.Math.BigInteger : object {
    internal static Int32[][] primeLists;
    internal static Int32[] primeProducts;
    private static long IMASK;
    private static ulong UIMASK;
    private static UInt32[] ZeroMagnitude;
    private static Byte[] ZeroEncoding;
    private static BigInteger[] SMALL_CONSTANTS;
    public static BigInteger Zero;
    public static BigInteger One;
    public static BigInteger Two;
    public static BigInteger Three;
    public static BigInteger Four;
    public static BigInteger Ten;
    private static Byte[] BitLengthTable;
    private static int chunk2;
    private static int chunk8;
    private static int chunk10;
    private static int chunk16;
    private static BigInteger radix2;
    private static BigInteger radix2E;
    private static BigInteger radix8;
    private static BigInteger radix8E;
    private static BigInteger radix10;
    private static BigInteger radix10E;
    private static BigInteger radix16;
    private static BigInteger radix16E;
    private static Int32[] ExpWindowThresholds;
    private static int BitsPerByte;
    private static int BitsPerInt;
    private static int BytesPerInt;
    private UInt32[] magnitude;
    private int sign;
    private int nBits;
    private int nBitLength;
    public int BitCount { get; }
    public int BitLength { get; }
    public int IntValue { get; }
    public int IntValueExact { get; }
    public long LongValue { get; }
    public long LongValueExact { get; }
    public int SignValue { get; }
    private static BigInteger();
    private BigInteger(int signum, UInt32[] mag, bool checkMag);
    public BigInteger(string value);
    public BigInteger(string str, int radix);
    public BigInteger(Byte[] bytes);
    public BigInteger(Byte[] bytes, int offset, int length);
    public BigInteger(int sign, Byte[] bytes);
    public BigInteger(int sign, Byte[] bytes, int offset, int length);
    public BigInteger(int sizeInBits, Random random);
    public BigInteger(int bitLength, int certainty, Random random);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    private static int GetBytesLength(int nBits);
    public static BigInteger Arbitrary(int sizeInBits);
    private static UInt32[] MakeMagnitude(Byte[] bytes);
    private static UInt32[] MakeMagnitude(Byte[] bytes, int offset, int length);
    public BigInteger Abs();
    private static UInt32[] AddMagnitudes(UInt32[] a, UInt32[] b);
    public BigInteger Add(BigInteger value);
    private BigInteger AddToMagnitude(UInt32[] magToAdd);
    public BigInteger And(BigInteger value);
    public BigInteger AndNot(BigInteger val);
    public int get_BitCount();
    private static int CalcBitLength(int sign, int indx, UInt32[] mag);
    public int get_BitLength();
    private static int BitLen(byte b);
    private static int BitLen(UInt32 v);
    private bool QuickPow2Check();
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(BigInteger other);
    private static int CompareTo(int xIndx, UInt32[] x, int yIndx, UInt32[] y);
    private static int CompareNoLeadingZeroes(int xIndx, UInt32[] x, int yIndx, UInt32[] y);
    private UInt32[] Divide(UInt32[] x, UInt32[] y);
    public BigInteger Divide(BigInteger val);
    public BigInteger[] DivideAndRemainder(BigInteger val);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BigInteger other);
    private bool IsEqualMagnitude(BigInteger x);
    public BigInteger Gcd(BigInteger value);
    public virtual int GetHashCode();
    private BigInteger Inc();
    public int get_IntValue();
    public int get_IntValueExact();
    public bool IsProbablePrime(int certainty);
    internal bool IsProbablePrime(int certainty, bool randomlySelected);
    private bool CheckProbablePrime(int certainty, Random random, bool randomlySelected);
    public bool RabinMillerTest(int certainty, Random random);
    internal bool RabinMillerTest(int certainty, Random random, bool randomlySelected);
    public long get_LongValue();
    public long get_LongValueExact();
    public BigInteger Max(BigInteger value);
    public BigInteger Min(BigInteger value);
    public BigInteger Mod(BigInteger m);
    public BigInteger ModInverse(BigInteger m);
    private BigInteger ModInversePow2(BigInteger m);
    private static BigInteger ExtEuclid(BigInteger a, BigInteger b, BigInteger& u1Out);
    private static void ZeroOut(Int32[] x);
    public BigInteger ModPow(BigInteger e, BigInteger m);
    private static BigInteger ModPowBarrett(BigInteger b, BigInteger e, BigInteger m);
    private static BigInteger ReduceBarrett(BigInteger x, BigInteger m, BigInteger mr, BigInteger yu);
    private static BigInteger ModPowMonty(BigInteger b, BigInteger e, BigInteger m, bool convert);
    private static Int32[] GetWindowList(UInt32[] mag, int extraBits);
    private static int CreateWindowEntry(int mult, int zeroes);
    private static UInt32[] Square(UInt32[] w, UInt32[] x);
    private static UInt32[] Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    private UInt32 GetMQuote();
    private static void MontgomeryReduce(UInt32[] x, UInt32[] m, UInt32 mDash);
    private static void MultiplyMonty(UInt32[] a, UInt32[] x, UInt32[] y, UInt32[] m, UInt32 mDash, bool smallMontyModulus);
    private static void SquareMonty(UInt32[] a, UInt32[] x, UInt32[] m, UInt32 mDash, bool smallMontyModulus);
    private static UInt32 MultiplyMontyNIsOne(UInt32 x, UInt32 y, UInt32 m, UInt32 mDash);
    public BigInteger Multiply(BigInteger val);
    public BigInteger Square();
    public BigInteger Negate();
    public BigInteger NextProbablePrime();
    public BigInteger Not();
    public BigInteger Pow(int exp);
    public static BigInteger ProbablePrime(int bitLength, Random random);
    private int Remainder(int m);
    private static UInt32[] Remainder(UInt32[] x, UInt32[] y);
    public BigInteger Remainder(BigInteger n);
    private UInt32[] LastNBits(int n);
    private BigInteger DivideWords(int w);
    private BigInteger RemainderWords(int w);
    private static UInt32[] ShiftLeft(UInt32[] mag, int n);
    private static int ShiftLeftOneInPlace(Int32[] x, int carry);
    public BigInteger ShiftLeft(int n);
    private static void ShiftRightInPlace(int start, UInt32[] mag, int n);
    private static void ShiftRightOneInPlace(int start, UInt32[] mag);
    public BigInteger ShiftRight(int n);
    public int get_SignValue();
    private static UInt32[] Subtract(int xStart, UInt32[] x, int yStart, UInt32[] y);
    public BigInteger Subtract(BigInteger n);
    private static UInt32[] DoSubBigLil(UInt32[] bigMag, UInt32[] lilMag);
    public int GetLengthofByteArray();
    public int GetLengthofByteArrayUnsigned();
    public Byte[] ToByteArray();
    public Byte[] ToByteArrayUnsigned();
    private Byte[] ToByteArray(bool unsigned);
    public virtual string ToString();
    public string ToString(int radix);
    private static void ToString(StringBuilder sb, int radix, IList`1<BigInteger> moduli, int scale, BigInteger pos);
    private static void AppendZeroExtendedString(StringBuilder sb, string s, int minLength);
    private static BigInteger CreateUValueOf(ulong value);
    private static BigInteger CreateValueOf(long value);
    public static BigInteger ValueOf(long value);
    public int GetLowestSetBit();
    private int GetLowestSetBitMaskFirst(UInt32 firstWordMaskX);
    public bool TestBit(int n);
    public BigInteger Or(BigInteger value);
    public BigInteger Xor(BigInteger value);
    public BigInteger SetBit(int n);
    public BigInteger ClearBit(int n);
    public BigInteger FlipBit(int n);
    private BigInteger FlipExistingBit(int n);
}
internal class Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal : object {
    private BigInteger bigInt;
    private int scale;
    public int IntValue { get; }
    public long LongValue { get; }
    public int Scale { get; }
    public SimpleBigDecimal(BigInteger bigInt, int scale);
    private SimpleBigDecimal(SimpleBigDecimal limBigDec);
    public static SimpleBigDecimal GetInstance(BigInteger val, int scale);
    private void CheckScale(SimpleBigDecimal b);
    public SimpleBigDecimal AdjustScale(int newScale);
    public SimpleBigDecimal Add(SimpleBigDecimal b);
    public SimpleBigDecimal Add(BigInteger b);
    public SimpleBigDecimal Negate();
    public SimpleBigDecimal Subtract(SimpleBigDecimal b);
    public SimpleBigDecimal Subtract(BigInteger b);
    public SimpleBigDecimal Multiply(SimpleBigDecimal b);
    public SimpleBigDecimal Multiply(BigInteger b);
    public SimpleBigDecimal Divide(SimpleBigDecimal b);
    public SimpleBigDecimal Divide(BigInteger b);
    public SimpleBigDecimal ShiftLeft(int n);
    public int CompareTo(SimpleBigDecimal val);
    public int CompareTo(BigInteger val);
    public BigInteger Floor();
    public BigInteger Round();
    public int get_IntValue();
    public long get_LongValue();
    public int get_Scale();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Org.BouncyCastle.Math.EC.Abc.Tnaf : object {
    private static BigInteger MinusOne;
    private static BigInteger MinusTwo;
    private static BigInteger MinusThree;
    private static BigInteger Four;
    private static string PRECOMP_NAME;
    public static sbyte Width;
    public static ZTauElement[] Alpha0;
    public static SByte[][] Alpha0Tnaf;
    public static ZTauElement[] Alpha1;
    public static SByte[][] Alpha1Tnaf;
    private static Tnaf();
    public static BigInteger Norm(sbyte mu, ZTauElement lambda);
    public static SimpleBigDecimal Norm(sbyte mu, SimpleBigDecimal u, SimpleBigDecimal v);
    public static ZTauElement Round(SimpleBigDecimal lambda0, SimpleBigDecimal lambda1, sbyte mu);
    public static SimpleBigDecimal ApproximateDivisionByN(BigInteger k, BigInteger s, BigInteger vm, sbyte a, int m, int c);
    public static SByte[] TauAdicNaf(sbyte mu, ZTauElement lambda);
    public static AbstractF2mPoint Tau(AbstractF2mPoint p);
    public static sbyte GetMu(AbstractF2mCurve curve);
    public static sbyte GetMu(ECFieldElement curveA);
    public static sbyte GetMu(int curveA);
    public static BigInteger[] GetLucas(sbyte mu, int k, bool doV);
    public static BigInteger GetTw(sbyte mu, int w);
    public static BigInteger[] GetSi(AbstractF2mCurve curve);
    public static BigInteger[] GetSi(int fieldSize, int curveA, BigInteger cofactor);
    private static int GetShiftsForCofactor(BigInteger h);
    public static ZTauElement PartModReduction(AbstractF2mCurve curve, BigInteger k, sbyte a, sbyte mu, sbyte c);
    public static AbstractF2mPoint MultiplyRTnaf(AbstractF2mPoint p, BigInteger k);
    public static AbstractF2mPoint MultiplyTnaf(AbstractF2mPoint p, ZTauElement lambda);
    public static AbstractF2mPoint MultiplyFromTnaf(AbstractF2mPoint p, AbstractF2mPoint pNeg, SByte[] u);
    public static SByte[] TauAdicWNaf(sbyte mu, ZTauElement lambda, int width, int tw, ZTauElement[] alpha);
    public static AbstractF2mPoint[] GetPreComp(AbstractF2mPoint p, sbyte a);
}
internal class Org.BouncyCastle.Math.EC.Abc.ZTauElement : object {
    public BigInteger u;
    public BigInteger v;
    public ZTauElement(BigInteger u, BigInteger v);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractECLookupTable : object {
    public int Size { get; }
    public abstract virtual ECPoint Lookup(int index);
    public abstract virtual int get_Size();
    public virtual ECPoint LookupVar(int index);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractF2mCurve : ECCurve {
    public bool IsKoblitz { get; }
    protected AbstractF2mCurve(int m, int k1, int k2, int k3);
    public static BigInteger Inverse(int m, Int32[] ks, BigInteger x);
    private static IFiniteField BuildField(int m, int k1, int k2, int k3);
    public virtual ECPoint CreatePoint(BigInteger x, BigInteger y);
    public virtual bool IsValidFieldElement(BigInteger x);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
    protected virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    internal ECFieldElement SolveQuadraticEquation(ECFieldElement beta);
    public virtual bool get_IsKoblitz();
    private static BigInteger ImplRandomFieldElementMult(SecureRandom r, int m);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractF2mFieldElement : ECFieldElement {
    public bool HasFastTrace { get; }
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
}
public abstract class Org.BouncyCastle.Math.EC.AbstractF2mPoint : ECPointBase {
    protected AbstractF2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    protected AbstractF2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual bool SatisfiesCurveEquation();
    protected virtual bool SatisfiesOrder();
    public virtual ECPoint ScaleX(ECFieldElement scale);
    public virtual ECPoint ScaleXNegateY(ECFieldElement scale);
    public virtual ECPoint ScaleY(ECFieldElement scale);
    public virtual ECPoint ScaleYNegateX(ECFieldElement scale);
    public virtual ECPoint Subtract(ECPoint b);
    public virtual AbstractF2mPoint Tau();
    public virtual AbstractF2mPoint TauPow(int pow);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractFpCurve : ECCurve {
    private static HashSet`1<BigInteger> KnownQs;
    protected AbstractFpCurve(BigInteger q);
    internal AbstractFpCurve(BigInteger q, bool isInternal);
    private static AbstractFpCurve();
    public virtual bool IsValidFieldElement(BigInteger x);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
    protected virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    private static int ImplGetInteger(string envVariable, int defaultValue);
    private static int ImplGetNumberOfIterations(int bits, int certainty);
    private static BigInteger ImplRandomFieldElement(SecureRandom r, BigInteger p);
    private static BigInteger ImplRandomFieldElementMult(SecureRandom r, BigInteger p);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractFpFieldElement : ECFieldElement {
}
public abstract class Org.BouncyCastle.Math.EC.AbstractFpPoint : ECPointBase {
    protected internal bool CompressionYTilde { get; }
    protected AbstractFpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    protected AbstractFpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected internal virtual bool get_CompressionYTilde();
    protected virtual bool SatisfiesCurveEquation();
    public virtual ECPoint Subtract(ECPoint b);
}
internal class Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SM2P256V1_DEFAULT_COORDS;
    private static int SM2P256V1_FE_INTS;
    private static ECFieldElement[] SM2P256V1_AFFINE_ZS;
    protected SM2P256V1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SM2P256V1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32 P7;
    private static UInt32 PExt15;
    private static SM2P256V1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static void Half(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SM2P256V1FieldElement(BigInteger x);
    protected internal SM2P256V1FieldElement(UInt32[] x);
    private static SM2P256V1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SM2P256V1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1Point : AbstractFpPoint {
    internal SM2P256V1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SM2P256V1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP128R1_DEFAULT_COORDS;
    private static int SECP128R1_FE_INTS;
    private static ECFieldElement[] SECP128R1_AFFINE_ZS;
    protected SecP128R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP128R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P3;
    private static UInt32 PExt7;
    private static SecP128R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP128R1FieldElement(BigInteger x);
    protected internal SecP128R1FieldElement(UInt32[] x);
    private static SecP128R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP128R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Point : AbstractFpPoint {
    internal SecP128R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP128R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160K1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP160K1_DEFAULT_COORDS;
    private static int SECP160K1_FE_INTS;
    private static ECFieldElement[] SECP160K1_AFFINE_ZS;
    protected SecP160K1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP160K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160K1Point : AbstractFpPoint {
    internal SecP160K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP160K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP160R1_DEFAULT_COORDS;
    private static int SECP160R1_FE_INTS;
    private static ECFieldElement[] SECP160R1_AFFINE_ZS;
    protected SecP160R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP160R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P4;
    private static UInt32 PExt9;
    private static UInt32 PInv;
    private static SecP160R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP160R1FieldElement(BigInteger x);
    protected internal SecP160R1FieldElement(UInt32[] x);
    private static SecP160R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP160R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Point : AbstractFpPoint {
    internal SecP160R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP160R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP160R2_DEFAULT_COORDS;
    private static int SECP160R2_FE_INTS;
    private static ECFieldElement[] SECP160R2_AFFINE_ZS;
    protected SecP160R2Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP160R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P4;
    private static UInt32 PExt9;
    private static UInt32 PInv33;
    private static SecP160R2Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP160R2FieldElement(BigInteger x);
    protected internal SecP160R2FieldElement(UInt32[] x);
    private static SecP160R2FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP160R2FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Point : AbstractFpPoint {
    internal SecP160R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP160R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP192K1_DEFAULT_COORDS;
    private static int SECP192K1_FE_INTS;
    private static ECFieldElement[] SECP192K1_AFFINE_ZS;
    protected SecP192K1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP192K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P5;
    private static UInt32 PExt11;
    private static UInt32 PInv33;
    private static SecP192K1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP192K1FieldElement(BigInteger x);
    protected internal SecP192K1FieldElement(UInt32[] x);
    private static SecP192K1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP192K1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Point : AbstractFpPoint {
    internal SecP192K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP192K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP192R1_DEFAULT_COORDS;
    private static int SECP192R1_FE_INTS;
    private static ECFieldElement[] SECP192R1_AFFINE_ZS;
    protected SecP192R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP192R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P5;
    private static UInt32 PExt11;
    private static SecP192R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP192R1FieldElement(BigInteger x);
    protected internal SecP192R1FieldElement(UInt32[] x);
    private static SecP192R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP192R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Point : AbstractFpPoint {
    internal SecP192R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP192R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP224K1_DEFAULT_COORDS;
    private static int SECP224K1_FE_INTS;
    private static ECFieldElement[] SECP224K1_AFFINE_ZS;
    protected SecP224K1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP224K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P6;
    private static UInt32 PExt13;
    private static UInt32 PInv33;
    private static SecP224K1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    private static UInt32[] PRECOMP_POW2;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP224K1FieldElement(BigInteger x);
    protected internal SecP224K1FieldElement(UInt32[] x);
    private static SecP224K1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP224K1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Point : AbstractFpPoint {
    internal SecP224K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP224K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP224R1_DEFAULT_COORDS;
    private static int SECP224R1_FE_INTS;
    private static ECFieldElement[] SECP224R1_AFFINE_ZS;
    protected SecP224R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP224R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P6;
    private static UInt32 PExt13;
    private static SecP224R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP224R1FieldElement(BigInteger x);
    protected internal SecP224R1FieldElement(UInt32[] x);
    private static SecP224R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP224R1FieldElement other);
    public virtual int GetHashCode();
    private static bool IsSquare(UInt32[] x);
    private static void RM(UInt32[] nc, UInt32[] d0, UInt32[] e0, UInt32[] d1, UInt32[] e1, UInt32[] f1, UInt32[] t);
    private static void RP(UInt32[] nc, UInt32[] d1, UInt32[] e1, UInt32[] f1, UInt32[] t);
    private static void RS(UInt32[] d, UInt32[] e, UInt32[] f, UInt32[] t);
    private static bool TrySqrt(UInt32[] nc, UInt32[] r, UInt32[] t);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Point : AbstractFpPoint {
    internal SecP224R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP224R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP256K1_DEFAULT_COORDS;
    private static int SECP256K1_FE_INTS;
    private static ECFieldElement[] SECP256K1_AFFINE_ZS;
    protected SecP256K1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP256K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P7;
    private static UInt32 PExt15;
    private static UInt32 PInv33;
    private static SecP256K1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z, UInt32[] tt);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z, UInt32[] tt);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z, UInt32[] tt);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP256K1FieldElement(BigInteger x);
    protected internal SecP256K1FieldElement(UInt32[] x);
    private static SecP256K1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP256K1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point : AbstractFpPoint {
    internal SecP256K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP256K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP256R1_DEFAULT_COORDS;
    private static int SECP256R1_FE_INTS;
    private static ECFieldElement[] SECP256R1_AFFINE_ZS;
    protected SecP256R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP256R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32 P7;
    private static UInt32 PExt15;
    private static SecP256R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z, UInt32[] tt);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z, UInt32[] tt);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z, UInt32[] tt);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP256R1FieldElement(BigInteger x);
    protected internal SecP256R1FieldElement(UInt32[] x);
    private static SecP256R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP256R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Point : AbstractFpPoint {
    internal SecP256R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP256R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP384R1_DEFAULT_COORDS;
    private static int SECP384R1_FE_INTS;
    private static ECFieldElement[] SECP384R1_AFFINE_ZS;
    protected SecP384R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP384R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P11;
    private static UInt32 PExt23;
    private static SecP384R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z, UInt32[] tt);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z, UInt32[] tt);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z, UInt32[] tt);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP384R1FieldElement(BigInteger x);
    protected internal SecP384R1FieldElement(UInt32[] x);
    private static SecP384R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP384R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Point : AbstractFpPoint {
    internal SecP384R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP384R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP521R1_DEFAULT_COORDS;
    private static int SECP521R1_FE_INTS;
    private static ECFieldElement[] SECP521R1_AFFINE_ZS;
    protected SecP521R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP521R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Field : object {
    internal static UInt32[] P;
    private static UInt32 P16;
    private static SecP521R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z, UInt32[] tt);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce23(UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z, UInt32[] tt);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z, UInt32[] tt);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Twice(UInt32[] x, UInt32[] z);
    protected static void ImplMultiply(UInt32[] x, UInt32[] y, UInt32[] zz);
    protected static void ImplSquare(UInt32[] x, UInt32[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP521R1FieldElement(BigInteger x);
    protected internal SecP521R1FieldElement(UInt32[] x);
    private static SecP521R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP521R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Point : AbstractFpPoint {
    internal SecP521R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecP521R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal static class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113Field : object {
    private static ulong M49;
    private static ulong M57;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    public static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce15(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    private static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    private static void ImplMulw(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT113FieldElement(BigInteger x);
    protected internal SecT113FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT113FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Curve : AbstractF2mCurve {
    private static int SECT113R1_DEFAULT_COORDS;
    private static int SECT113R1_FE_LONGS;
    private static ECFieldElement[] SECT113R1_AFFINE_ZS;
    protected SecT113R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT113R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT113R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT113R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Curve : AbstractF2mCurve {
    private static int SECT113R2_DEFAULT_COORDS;
    private static int SECT113R2_FE_LONGS;
    private static ECFieldElement[] SECT113R2_AFFINE_ZS;
    protected SecT113R2Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT113R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT113R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT113R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal static class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131Field : object {
    private static ulong M03;
    private static ulong M44;
    private static UInt64[] ROOT_Z;
    private static SecT131Field();
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    public static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce61(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    private static void ImplCompactExt(UInt64[] zz);
    private static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    private static void ImplMulw(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT131FieldElement(BigInteger x);
    protected internal SecT131FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT131FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Curve : AbstractF2mCurve {
    private static int SECT131R1_DEFAULT_COORDS;
    private static int SECT131R1_FE_LONGS;
    private static ECFieldElement[] SECT131R1_AFFINE_ZS;
    protected SecT131R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT131R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT131R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT131R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Curve : AbstractF2mCurve {
    private static int SECT131R2_DEFAULT_COORDS;
    private static int SECT131R2_FE_LONGS;
    private static ECFieldElement[] SECT131R2_AFFINE_ZS;
    protected SecT131R2Point m_infinity;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT131R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECPoint get_Infinity();
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT131R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT131R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal static class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163Field : object {
    private static ulong M35;
    private static ulong M55;
    private static UInt64[] ROOT_Z;
    private static SecT163Field();
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    public static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce29(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    private static void ImplCompactExt(UInt64[] zz);
    private static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    private static void ImplMulw(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT163FieldElement(BigInteger x);
    protected internal SecT163FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT163FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Curve : AbstractF2mCurve {
    private static int SECT163K1_DEFAULT_COORDS;
    private static int SECT163K1_FE_LONGS;
    private static ECFieldElement[] SECT163K1_AFFINE_ZS;
    protected SecT163K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT163K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT163K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT163K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Curve : AbstractF2mCurve {
    private static int SECT163R1_DEFAULT_COORDS;
    private static int SECT163R1_FE_LONGS;
    private static ECFieldElement[] SECT163R1_AFFINE_ZS;
    protected SecT163R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT163R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT163R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT163R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Curve : AbstractF2mCurve {
    private static int SECT163R2_DEFAULT_COORDS;
    private static int SECT163R2_FE_LONGS;
    private static ECFieldElement[] SECT163R2_AFFINE_ZS;
    protected SecT163R2Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT163R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT163R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT163R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal static class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193Field : object {
    private static ulong M01;
    private static ulong M49;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    public static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce63(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    private static void ImplCompactExt(UInt64[] zz);
    private static void ImplExpand(UInt64[] x, UInt64[] z);
    private static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    private static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT193FieldElement(BigInteger x);
    protected internal SecT193FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT193FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R1Curve : AbstractF2mCurve {
    private static int SECT193R1_DEFAULT_COORDS;
    private static int SECT193R1_FE_LONGS;
    private static ECFieldElement[] SECT193R1_AFFINE_ZS;
    protected SecT193R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT193R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT193R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT193R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R2Curve : AbstractF2mCurve {
    private static int SECT193R2_DEFAULT_COORDS;
    private static int SECT193R2_FE_LONGS;
    private static ECFieldElement[] SECT193R2_AFFINE_ZS;
    protected SecT193R2Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT193R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R2Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT193R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT193R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal static class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233Field : object {
    private static ulong M41;
    private static ulong M59;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    public static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce23(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    private static void ImplCompactExt(UInt64[] zz);
    private static void ImplExpand(UInt64[] x, UInt64[] z);
    private static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    private static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT233FieldElement(BigInteger x);
    protected internal SecT233FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT233FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Curve : AbstractF2mCurve {
    private static int SECT233K1_DEFAULT_COORDS;
    private static int SECT233K1_FE_LONGS;
    private static ECFieldElement[] SECT233K1_AFFINE_ZS;
    protected SecT233K1Point m_infinity;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT233K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECPoint get_Infinity();
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT233K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT233K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Curve : AbstractF2mCurve {
    private static int SECT233R1_DEFAULT_COORDS;
    private static int SECT233R1_FE_LONGS;
    private static ECFieldElement[] SECT233R1_AFFINE_ZS;
    protected SecT233R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT233R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT233R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT233R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal static class Org.BouncyCastle.Math.EC.Custom.Sec.SecT239Field : object {
    private static ulong M47;
    private static ulong M60;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    public static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce17(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    private static void ImplCompactExt(UInt64[] zz);
    private static void ImplExpand(UInt64[] x, UInt64[] z);
    private static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    private static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT239FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT239FieldElement(BigInteger x);
    protected internal SecT239FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT239FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Curve : AbstractF2mCurve {
    private static int SECT239K1_DEFAULT_COORDS;
    private static int SECT239K1_FE_LONGS;
    private static ECFieldElement[] SECT239K1_AFFINE_ZS;
    protected SecT239K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT239K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT239K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT239K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal static class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283Field : object {
    private static ulong M27;
    private static ulong M57;
    private static UInt64[] ROOT_Z;
    private static SecT283Field();
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    public static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce37(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    private static void ImplCompactExt(UInt64[] zz);
    private static void ImplExpand(UInt64[] x, UInt64[] z);
    private static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    private static void ImplMulw(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT283FieldElement(BigInteger x);
    protected internal SecT283FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT283FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Curve : AbstractF2mCurve {
    private static int SECT283K1_DEFAULT_COORDS;
    private static int SECT283K1_FE_LONGS;
    private static ECFieldElement[] SECT283K1_AFFINE_ZS;
    protected SecT283K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT283K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT283K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT283K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Curve : AbstractF2mCurve {
    private static int SECT283R1_DEFAULT_COORDS;
    private static int SECT283R1_FE_LONGS;
    private static ECFieldElement[] SECT283R1_AFFINE_ZS;
    protected SecT283R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT283R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal static class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409Field : object {
    private static ulong M25;
    private static ulong M59;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    public static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce39(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    private static void ImplCompactExt(UInt64[] zz);
    private static void ImplExpand(UInt64[] x, UInt64[] z);
    private static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    private static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT409FieldElement(BigInteger x);
    protected internal SecT409FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT409FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Curve : AbstractF2mCurve {
    private static int SECT409K1_DEFAULT_COORDS;
    private static int SECT409K1_FE_LONGS;
    private static ECFieldElement[] SECT409K1_AFFINE_ZS;
    protected SecT409K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT409K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT409K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT409K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Curve : AbstractF2mCurve {
    private static int SECT409R1_DEFAULT_COORDS;
    private static int SECT409R1_FE_LONGS;
    private static ECFieldElement[] SECT409R1_AFFINE_ZS;
    protected SecT409R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT409R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT409R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT409R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal static class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571Field : object {
    private static ulong M59;
    private static UInt64[] ROOT_Z;
    private static SecT571Field();
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    private static void Add(UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] z, int zOff);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    private static void AddBothTo(UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] z, int zOff);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    public static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyPrecomp(UInt64[] x, UInt64[] precomp, UInt64[] z);
    public static void MultiplyPrecompAddToExt(UInt64[] x, UInt64[] precomp, UInt64[] zz);
    public static UInt64[] PrecompMultiplicand(UInt64[] x);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce5(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    private static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    private static void ImplMultiplyPrecomp(UInt64[] x, UInt64[] precomp, UInt64[] zz);
    private static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT571FieldElement(BigInteger x);
    protected internal SecT571FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT571FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Curve : AbstractF2mCurve {
    private static int SECT571K1_DEFAULT_COORDS;
    private static int SECT571K1_FE_LONGS;
    private static ECFieldElement[] SECT571K1_AFFINE_ZS;
    protected SecT571K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT571K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT571K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT571K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Curve : AbstractF2mCurve {
    private static int SECT571R1_DEFAULT_COORDS;
    private static int SECT571R1_FE_LONGS;
    private static ECFieldElement[] SECT571R1_AFFINE_ZS;
    protected SecT571R1Point m_infinity;
    internal static SecT571FieldElement SecT571R1_B;
    internal static SecT571FieldElement SecT571R1_B_SQRT;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT571R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal SecT571R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal SecT571R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
public class Org.BouncyCastle.Math.EC.ECAlgorithms : object {
    public static bool IsF2mCurve(ECCurve c);
    public static bool IsF2mField(IFiniteField field);
    public static bool IsFpCurve(ECCurve c);
    public static bool IsFpField(IFiniteField field);
    public static ECPoint SumOfMultiplies(ECPoint[] ps, BigInteger[] ks);
    public static ECPoint SumOfTwoMultiplies(ECPoint P, BigInteger a, ECPoint Q, BigInteger b);
    public static ECPoint ShamirsTrick(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    public static ECPoint ImportPoint(ECCurve c, ECPoint p);
    public static void MontgomeryTrick(ECFieldElement[] zs, int off, int len);
    public static void MontgomeryTrick(ECFieldElement[] zs, int off, int len, ECFieldElement scale);
    public static ECPoint ReferenceMultiply(ECPoint p, BigInteger k);
    public static ECPoint ValidatePoint(ECPoint p);
    public static ECPoint CleanPoint(ECCurve c, ECPoint p);
    internal static ECPoint ImplCheckResult(ECPoint p);
    internal static ECPoint ImplShamirsTrickJsf(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    internal static ECPoint ImplShamirsTrickWNaf(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    internal static ECPoint ImplShamirsTrickWNaf(ECEndomorphism endomorphism, ECPoint P, BigInteger k, BigInteger l);
    private static ECPoint ImplShamirsTrickWNaf(ECPoint[] preCompP, ECPoint[] preCompNegP, Byte[] wnafP, ECPoint[] preCompQ, ECPoint[] preCompNegQ, Byte[] wnafQ);
    internal static ECPoint ImplSumOfMultiplies(ECPoint[] ps, BigInteger[] ks);
    internal static ECPoint ImplSumOfMultipliesGlv(ECPoint[] ps, BigInteger[] ks, GlvEndomorphism glvEndomorphism);
    internal static ECPoint ImplSumOfMultiplies(ECEndomorphism endomorphism, ECPoint[] ps, BigInteger[] ks);
    private static ECPoint ImplSumOfMultiplies(Boolean[] negs, WNafPreCompInfo[] infos, Byte[][] wnafs);
    private static ECPoint ImplShamirsTrickFixedPoint(ECPoint p, BigInteger k, ECPoint q, BigInteger l);
}
public abstract class Org.BouncyCastle.Math.EC.ECCurve : object {
    public static int COORD_AFFINE;
    public static int COORD_HOMOGENEOUS;
    public static int COORD_JACOBIAN;
    public static int COORD_JACOBIAN_CHUDNOVSKY;
    public static int COORD_JACOBIAN_MODIFIED;
    public static int COORD_LAMBDA_AFFINE;
    public static int COORD_LAMBDA_PROJECTIVE;
    public static int COORD_SKEWED;
    protected IFiniteField m_field;
    protected ECFieldElement m_a;
    protected ECFieldElement m_b;
    protected BigInteger m_order;
    protected BigInteger m_cofactor;
    protected int m_coord;
    protected ECEndomorphism m_endomorphism;
    protected ECMultiplier m_multiplier;
    private IDictionary`2<string, PreCompInfo> m_preCompTable;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public IFiniteField Field { get; }
    public ECFieldElement A { get; }
    public ECFieldElement B { get; }
    public BigInteger Order { get; }
    public BigInteger Cofactor { get; }
    public int CoordinateSystem { get; }
    protected ECCurve(IFiniteField field);
    public static Int32[] GetAllCoordinateSystems();
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement FromBigInteger(BigInteger x);
    public abstract virtual bool IsValidFieldElement(BigInteger x);
    public abstract virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public abstract virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
    public virtual Config Configure();
    public virtual ECPoint ValidatePoint(BigInteger x, BigInteger y);
    public virtual ECPoint CreatePoint(BigInteger x, BigInteger y);
    protected abstract virtual ECCurve CloneCurve();
    protected internal abstract virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal abstract virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual PreCompInfo GetPreCompInfo(ECPoint point, string name);
    internal virtual PreCompInfo Precompute(string name, IPreCompCallback callback);
    public virtual PreCompInfo Precompute(ECPoint point, string name, IPreCompCallback callback);
    public virtual ECPoint ImportPoint(ECPoint p);
    public virtual void NormalizeAll(ECPoint[] points);
    public virtual void NormalizeAll(ECPoint[] points, int off, int len, ECFieldElement iso);
    public abstract virtual ECPoint get_Infinity();
    public virtual IFiniteField get_Field();
    public virtual ECFieldElement get_A();
    public virtual ECFieldElement get_B();
    public virtual BigInteger get_Order();
    public virtual BigInteger get_Cofactor();
    public virtual int get_CoordinateSystem();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    protected virtual void CheckPoint(ECPoint point);
    protected virtual void CheckPoints(ECPoint[] points);
    protected virtual void CheckPoints(ECPoint[] points, int off, int len);
    public virtual bool Equals(ECCurve other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected abstract virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    public virtual ECEndomorphism GetEndomorphism();
    public virtual ECMultiplier GetMultiplier();
    public virtual ECPoint DecodePoint(Byte[] encoded);
}
public abstract class Org.BouncyCastle.Math.EC.ECFieldElement : object {
    public string FieldName { get; }
    public int FieldSize { get; }
    public int BitLength { get; }
    public bool IsOne { get; }
    public bool IsZero { get; }
    public abstract virtual BigInteger ToBigInteger();
    public abstract virtual string get_FieldName();
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement Add(ECFieldElement b);
    public abstract virtual ECFieldElement AddOne();
    public abstract virtual ECFieldElement Subtract(ECFieldElement b);
    public abstract virtual ECFieldElement Multiply(ECFieldElement b);
    public abstract virtual ECFieldElement Divide(ECFieldElement b);
    public abstract virtual ECFieldElement Negate();
    public abstract virtual ECFieldElement Square();
    public abstract virtual ECFieldElement Invert();
    public abstract virtual ECFieldElement Sqrt();
    public virtual int get_BitLength();
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual bool TestBitZero();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Byte[] GetEncoded();
    public virtual int GetEncodedLength();
    public virtual void EncodeTo(Byte[] buf, int off);
}
public interface Org.BouncyCastle.Math.EC.ECLookupTable {
    public int Size { get; }
    public abstract virtual int get_Size();
    public abstract virtual ECPoint Lookup(int index);
    public abstract virtual ECPoint LookupVar(int index);
}
public abstract class Org.BouncyCastle.Math.EC.ECPoint : object {
    protected static ECFieldElement[] EMPTY_ZS;
    protected internal ECCurve m_curve;
    protected internal ECFieldElement m_x;
    protected internal ECFieldElement m_y;
    protected internal ECFieldElement[] m_zs;
    protected internal IDictionary`2<string, PreCompInfo> m_preCompTable;
    public ECCurve Curve { get; }
    protected int CurveCoordinateSystem { get; }
    public ECFieldElement AffineXCoord { get; }
    public ECFieldElement AffineYCoord { get; }
    public ECFieldElement XCoord { get; }
    public ECFieldElement YCoord { get; }
    protected internal ECFieldElement RawXCoord { get; }
    protected internal ECFieldElement RawYCoord { get; }
    protected internal ECFieldElement[] RawZCoords { get; }
    public bool IsInfinity { get; }
    protected internal bool CompressionYTilde { get; }
    protected ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    private static ECPoint();
    protected static ECFieldElement[] GetInitialZCoords(ECCurve curve);
    protected abstract virtual bool SatisfiesCurveEquation();
    protected virtual bool SatisfiesOrder();
    public ECPoint GetDetachedPoint();
    public virtual ECCurve get_Curve();
    protected abstract virtual ECPoint Detach();
    protected virtual int get_CurveCoordinateSystem();
    public virtual ECFieldElement get_AffineXCoord();
    public virtual ECFieldElement get_AffineYCoord();
    public virtual ECFieldElement get_XCoord();
    public virtual ECFieldElement get_YCoord();
    public virtual ECFieldElement GetZCoord(int index);
    public virtual ECFieldElement[] GetZCoords();
    protected internal ECFieldElement get_RawXCoord();
    protected internal ECFieldElement get_RawYCoord();
    protected internal ECFieldElement[] get_RawZCoords();
    protected virtual void CheckNormalized();
    public virtual bool IsNormalized();
    public virtual ECPoint Normalize();
    internal virtual ECPoint Normalize(ECFieldElement zInv);
    protected virtual ECPoint CreateScaledPoint(ECFieldElement sx, ECFieldElement sy);
    public bool get_IsInfinity();
    public bool IsValid();
    internal bool IsValidPartial();
    internal bool ImplIsValid(bool decompressed, bool checkOrder);
    public virtual ECPoint ScaleX(ECFieldElement scale);
    public virtual ECPoint ScaleXNegateY(ECFieldElement scale);
    public virtual ECPoint ScaleY(ECFieldElement scale);
    public virtual ECPoint ScaleYNegateX(ECFieldElement scale);
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECPoint other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Byte[] GetEncoded();
    public abstract virtual Byte[] GetEncoded(bool compressed);
    public abstract virtual int GetEncodedLength(bool compressed);
    public abstract virtual void EncodeTo(bool compressed, Byte[] buf, int off);
    protected internal abstract virtual bool get_CompressionYTilde();
    public abstract virtual ECPoint Add(ECPoint b);
    public abstract virtual ECPoint Subtract(ECPoint b);
    public abstract virtual ECPoint Negate();
    public virtual ECPoint TimesPow2(int e);
    public abstract virtual ECPoint Twice();
    public abstract virtual ECPoint Multiply(BigInteger b);
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
}
public abstract class Org.BouncyCastle.Math.EC.ECPointBase : ECPoint {
    protected internal ECPointBase(ECCurve curve, ECFieldElement x, ECFieldElement y);
    protected internal ECPointBase(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual Byte[] GetEncoded(bool compressed);
    public virtual int GetEncodedLength(bool compressed);
    public virtual void EncodeTo(bool compressed, Byte[] buf, int off);
    public virtual ECPoint Multiply(BigInteger k);
}
public interface Org.BouncyCastle.Math.EC.ECPointMap {
    public abstract virtual ECPoint Map(ECPoint p);
}
public interface Org.BouncyCastle.Math.EC.Endo.ECEndomorphism {
    public ECPointMap PointMap { get; }
    public bool HasEfficientPointMap { get; }
    public abstract virtual ECPointMap get_PointMap();
    public abstract virtual bool get_HasEfficientPointMap();
}
public class Org.BouncyCastle.Math.EC.Endo.EndoPreCompInfo : object {
    protected ECEndomorphism m_endomorphism;
    protected ECPoint m_mappedPoint;
    public ECEndomorphism Endomorphism { get; public set; }
    public ECPoint MappedPoint { get; public set; }
    public virtual ECEndomorphism get_Endomorphism();
    public virtual void set_Endomorphism(ECEndomorphism value);
    public virtual ECPoint get_MappedPoint();
    public virtual void set_MappedPoint(ECPoint value);
}
public abstract class Org.BouncyCastle.Math.EC.Endo.EndoUtilities : object {
    public static string PRECOMP_NAME;
    private static EndoUtilities();
    public static BigInteger[] DecomposeScalar(ScalarSplitParameters p, BigInteger k);
    public static ECPoint MapPoint(ECEndomorphism endomorphism, ECPoint p);
    private static BigInteger CalculateB(BigInteger k, BigInteger g, int t);
}
public interface Org.BouncyCastle.Math.EC.Endo.GlvEndomorphism {
    public abstract virtual BigInteger[] DecomposeScalar(BigInteger k);
}
public class Org.BouncyCastle.Math.EC.Endo.GlvTypeAEndomorphism : object {
    protected GlvTypeAParameters m_parameters;
    protected ECPointMap m_pointMap;
    public ECPointMap PointMap { get; }
    public bool HasEfficientPointMap { get; }
    public GlvTypeAEndomorphism(ECCurve curve, GlvTypeAParameters parameters);
    public virtual BigInteger[] DecomposeScalar(BigInteger k);
    public virtual ECPointMap get_PointMap();
    public virtual bool get_HasEfficientPointMap();
}
public class Org.BouncyCastle.Math.EC.Endo.GlvTypeAParameters : object {
    protected BigInteger m_i;
    protected BigInteger m_lambda;
    protected ScalarSplitParameters m_splitParams;
    public BigInteger I { get; }
    public BigInteger Lambda { get; }
    public ScalarSplitParameters SplitParams { get; }
    public GlvTypeAParameters(BigInteger i, BigInteger lambda, ScalarSplitParameters splitParams);
    public virtual BigInteger get_I();
    public virtual BigInteger get_Lambda();
    public virtual ScalarSplitParameters get_SplitParams();
}
public class Org.BouncyCastle.Math.EC.Endo.GlvTypeBEndomorphism : object {
    protected GlvTypeBParameters m_parameters;
    protected ECPointMap m_pointMap;
    public ECPointMap PointMap { get; }
    public bool HasEfficientPointMap { get; }
    public GlvTypeBEndomorphism(ECCurve curve, GlvTypeBParameters parameters);
    public virtual BigInteger[] DecomposeScalar(BigInteger k);
    public virtual ECPointMap get_PointMap();
    public virtual bool get_HasEfficientPointMap();
}
public class Org.BouncyCastle.Math.EC.Endo.GlvTypeBParameters : object {
    protected BigInteger m_beta;
    protected BigInteger m_lambda;
    protected ScalarSplitParameters m_splitParams;
    public BigInteger Beta { get; }
    public BigInteger Lambda { get; }
    public ScalarSplitParameters SplitParams { get; }
    public GlvTypeBParameters(BigInteger beta, BigInteger lambda, ScalarSplitParameters splitParams);
    public virtual BigInteger get_Beta();
    public virtual BigInteger get_Lambda();
    public virtual ScalarSplitParameters get_SplitParams();
}
public class Org.BouncyCastle.Math.EC.Endo.ScalarSplitParameters : object {
    protected BigInteger m_v1A;
    protected BigInteger m_v1B;
    protected BigInteger m_v2A;
    protected BigInteger m_v2B;
    protected BigInteger m_g1;
    protected BigInteger m_g2;
    protected int m_bits;
    public BigInteger V1A { get; }
    public BigInteger V1B { get; }
    public BigInteger V2A { get; }
    public BigInteger V2B { get; }
    public BigInteger G1 { get; }
    public BigInteger G2 { get; }
    public int Bits { get; }
    public ScalarSplitParameters(BigInteger[] v1, BigInteger[] v2, BigInteger g1, BigInteger g2, int bits);
    private static void CheckVector(BigInteger[] v, string name);
    public virtual BigInteger get_V1A();
    public virtual BigInteger get_V1B();
    public virtual BigInteger get_V2A();
    public virtual BigInteger get_V2B();
    public virtual BigInteger get_G1();
    public virtual BigInteger get_G2();
    public virtual int get_Bits();
}
public class Org.BouncyCastle.Math.EC.F2mCurve : AbstractF2mCurve {
    private static int F2M_DEFAULT_COORDS;
    private int m;
    private int k1;
    private int k2;
    private int k3;
    protected F2mPoint m_infinity;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    [ObsoleteAttribute("Use constructor taking order/cofactor")]
public F2mCurve(int m, int k, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor);
    [ObsoleteAttribute("Use constructor taking order/cofactor")]
public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor);
    internal F2mCurve(int m, int k1, int k2, int k3, ECFieldElement a, ECFieldElement b, BigInteger order, BigInteger cofactor);
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECPoint get_Infinity();
    public int get_M();
    public bool IsTrinomial();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
public class Org.BouncyCastle.Math.EC.F2mFieldElement : AbstractF2mFieldElement {
    public static int Gnb;
    public static int Tpb;
    public static int Ppb;
    private int representation;
    private int m;
    private Int32[] ks;
    internal LongArray x;
    public int BitLength { get; }
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    internal F2mFieldElement(int m, Int32[] ks, LongArray x);
    public virtual int get_BitLength();
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public static void CheckFieldElements(ECFieldElement a, ECFieldElement b);
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public int get_Representation();
    public int get_M();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(F2mFieldElement other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.F2mPoint : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    internal F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
public class Org.BouncyCastle.Math.EC.FpCurve : AbstractFpCurve {
    private static int FP_DEFAULT_COORDS;
    protected BigInteger m_q;
    protected BigInteger m_r;
    protected FpPoint m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    [ObsoleteAttribute("Use constructor taking order/cofactor")]
public FpCurve(BigInteger q, BigInteger a, BigInteger b);
    public FpCurve(BigInteger q, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor);
    internal FpCurve(BigInteger q, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor, bool isInternal);
    internal FpCurve(BigInteger q, BigInteger r, ECFieldElement a, ECFieldElement b, BigInteger order, BigInteger cofactor);
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    public virtual ECPoint ImportPoint(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.FpFieldElement : AbstractFpFieldElement {
    private BigInteger q;
    private BigInteger r;
    private BigInteger x;
    public string FieldName { get; }
    public int FieldSize { get; }
    public BigInteger Q { get; }
    internal FpFieldElement(BigInteger q, BigInteger r, BigInteger x);
    internal static BigInteger CalculateResidue(BigInteger p);
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public BigInteger get_Q();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    private ECFieldElement CheckSqrt(ECFieldElement z);
    private BigInteger[] LucasSequence(BigInteger P, BigInteger Q, BigInteger k);
    protected virtual BigInteger ModAdd(BigInteger x1, BigInteger x2);
    protected virtual BigInteger ModDouble(BigInteger x);
    protected virtual BigInteger ModHalf(BigInteger x);
    protected virtual BigInteger ModHalfAbs(BigInteger x);
    protected virtual BigInteger ModInverse(BigInteger x);
    protected virtual BigInteger ModMult(BigInteger x1, BigInteger x2);
    protected virtual BigInteger ModReduce(BigInteger x);
    protected virtual BigInteger ModSubtract(BigInteger x1, BigInteger x2);
    public virtual bool Equals(object obj);
    public virtual bool Equals(FpFieldElement other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.FpPoint : AbstractFpPoint {
    internal FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    internal FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement GetZCoord(int index);
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint TimesPow2(int e);
    protected virtual ECFieldElement Two(ECFieldElement x);
    protected virtual ECFieldElement Three(ECFieldElement x);
    protected virtual ECFieldElement Four(ECFieldElement x);
    protected virtual ECFieldElement Eight(ECFieldElement x);
    protected virtual ECFieldElement DoubleProductFromSquares(ECFieldElement a, ECFieldElement b, ECFieldElement aSquared, ECFieldElement bSquared);
    public virtual ECPoint Negate();
    protected virtual ECFieldElement CalculateJacobianModifiedW(ECFieldElement Z, ECFieldElement ZSquared);
    protected virtual ECFieldElement GetJacobianModifiedW();
    protected virtual FpPoint TwiceJacobianModified(bool calculateW);
}
internal class Org.BouncyCastle.Math.EC.LongArray : ValueType {
    private UInt64[] m_data;
    internal LongArray(int intLen);
    internal LongArray(UInt64[] data);
    internal LongArray(UInt64[] data, int off, int len);
    internal LongArray(BigInteger bigInt);
    internal static bool AreAliased(LongArray& a, LongArray& b);
    internal void CopyTo(UInt64[] z, int zOff);
    internal bool IsOne();
    internal bool IsZero();
    internal int GetUsedLength();
    internal int GetUsedLengthFrom(int from);
    internal int Degree();
    private int DegreeFrom(int limit);
    private static int BitLength(ulong w);
    private UInt64[] ResizedData(int newLen);
    internal BigInteger ToBigInteger();
    private static ulong ShiftUp(UInt64[] x, int xOff, int count, int shift);
    private static ulong ShiftUp(UInt64[] x, int xOff, UInt64[] z, int zOff, int count, int shift);
    internal LongArray AddOne();
    private void AddShiftedByBitsSafe(LongArray other, int otherDegree, int bits);
    private static ulong AddShiftedUp(UInt64[] x, int xOff, UInt64[] y, int yOff, int count, int shift);
    private static ulong AddShiftedDown(UInt64[] x, int xOff, UInt64[] y, int yOff, int count, int shift);
    internal void AddShiftedByWords(LongArray other, int words);
    private static void Add(UInt64[] x, int xOff, UInt64[] y, int yOff, int count);
    private static void Add(UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] z, int zOff, int count);
    private static void AddBoth(UInt64[] x, int xOff, UInt64[] y1, int y1Off, UInt64[] y2, int y2Off, int count);
    private static void FlipWord(UInt64[] buf, int off, int bit, ulong word);
    internal bool TestBitZero();
    private static bool TestBit(UInt64[] buf, int off, int n);
    private static void FlipBit(UInt64[] buf, int off, int n);
    private static void MultiplyWord(ulong a, UInt64[] b, int bLen, UInt64[] c, int cOff);
    internal LongArray ModMultiplyLD(LongArray other, int m, Int32[] ks);
    internal LongArray ModMultiply(LongArray other, int m, Int32[] ks);
    internal LongArray Multiply(LongArray other, int m, Int32[] ks);
    internal void Reduce(int m, Int32[] ks);
    private static LongArray ReduceResult(UInt64[] buf, int off, int len, int m, Int32[] ks);
    private static int ReduceInPlace(UInt64[] buf, int off, int len, int m, Int32[] ks);
    private static void ReduceBitWise(UInt64[] buf, int off, int BitLength, int m, Int32[] ks);
    private static void ReduceBit(UInt64[] buf, int off, int bit, int m, Int32[] ks);
    private static void ReduceWordWise(UInt64[] buf, int off, int len, int toBit, int m, Int32[] ks);
    private static void ReduceWord(UInt64[] buf, int off, int bit, ulong word, int m, Int32[] ks);
    private static void ReduceVectorWise(UInt64[] buf, int off, int len, int words, int m, Int32[] ks);
    private static void FlipVector(UInt64[] x, int xOff, UInt64[] y, int yOff, int yLen, int bits);
    internal LongArray ModSquare(int m, Int32[] ks);
    internal LongArray ModSquareN(int n, int m, Int32[] ks);
    internal LongArray Square(int m, Int32[] ks);
    internal LongArray ModInverse(int m, Int32[] ks);
    public virtual bool Equals(object obj);
    internal bool Equals(LongArray& other);
    public virtual int GetHashCode();
    public LongArray Copy();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Math.EC.Multiplier.AbstractECMultiplier : object {
    public virtual ECPoint Multiply(ECPoint p, BigInteger k);
    protected abstract virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
    protected virtual ECPoint CheckResult(ECPoint p);
}
public interface Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier {
    public abstract virtual ECPoint Multiply(ECPoint p, BigInteger k);
}
public class Org.BouncyCastle.Math.EC.Multiplier.FixedPointCombMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
public class Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo : object {
    protected ECPoint m_offset;
    protected ECLookupTable m_lookupTable;
    protected int m_width;
    public ECLookupTable LookupTable { get; public set; }
    public ECPoint Offset { get; public set; }
    public int Width { get; public set; }
    public virtual ECLookupTable get_LookupTable();
    public virtual void set_LookupTable(ECLookupTable value);
    public virtual ECPoint get_Offset();
    public virtual void set_Offset(ECPoint value);
    public virtual int get_Width();
    public virtual void set_Width(int value);
}
public class Org.BouncyCastle.Math.EC.Multiplier.FixedPointUtilities : object {
    public static string PRECOMP_NAME;
    private static FixedPointUtilities();
    public static int GetCombSize(ECCurve c);
    public static FixedPointPreCompInfo GetFixedPointPreCompInfo(PreCompInfo preCompInfo);
    public static FixedPointPreCompInfo Precompute(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.Multiplier.GlvMultiplier : AbstractECMultiplier {
    protected ECCurve curve;
    protected GlvEndomorphism glvEndomorphism;
    public GlvMultiplier(ECCurve curve, GlvEndomorphism glvEndomorphism);
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
public interface Org.BouncyCastle.Math.EC.Multiplier.IPreCompCallback {
    public abstract virtual PreCompInfo Precompute(PreCompInfo existing);
}
public interface Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo {
}
internal class Org.BouncyCastle.Math.EC.Multiplier.ValidityPreCompInfo : object {
    internal static string PRECOMP_NAME;
    private bool failed;
    private bool curveEquationPassed;
    private bool orderPassed;
    private static ValidityPreCompInfo();
    internal bool HasFailed();
    internal void ReportFailed();
    internal bool HasCurveEquationPassed();
    internal void ReportCurveEquationPassed();
    internal bool HasOrderPassed();
    internal void ReportOrderPassed();
}
public class Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
public class Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo : object {
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_promotionCountdown;
    protected int m_confWidth;
    protected ECPoint[] m_preComp;
    protected ECPoint[] m_preCompNeg;
    protected ECPoint m_twice;
    protected int m_width;
    internal int PromotionCountdown { get; internal set; }
    public bool IsPromoted { get; }
    public int ConfWidth { get; public set; }
    public ECPoint[] PreComp { get; public set; }
    public ECPoint[] PreCompNeg { get; public set; }
    public ECPoint Twice { get; public set; }
    public int Width { get; public set; }
    internal int DecrementPromotionCountdown();
    internal int get_PromotionCountdown();
    internal void set_PromotionCountdown(int value);
    public virtual bool get_IsPromoted();
    public virtual int get_ConfWidth();
    public virtual void set_ConfWidth(int value);
    public virtual ECPoint[] get_PreComp();
    public virtual void set_PreComp(ECPoint[] value);
    public virtual ECPoint[] get_PreCompNeg();
    public virtual void set_PreCompNeg(ECPoint[] value);
    public virtual ECPoint get_Twice();
    public virtual void set_Twice(ECPoint value);
    public virtual int get_Width();
    public virtual void set_Width(int value);
}
public abstract class Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities : object {
    public static string PRECOMP_NAME;
    private static Int32[] DEFAULT_WINDOW_SIZE_CUTOFFS;
    private static int MAX_WIDTH;
    private static ECPoint[] EMPTY_POINTS;
    private static WNafUtilities();
    public static void ConfigureBasepoint(ECPoint p);
    public static Int32[] GenerateCompactNaf(BigInteger k);
    public static Int32[] GenerateCompactWindowNaf(int width, BigInteger k);
    public static Byte[] GenerateJsf(BigInteger g, BigInteger h);
    public static Byte[] GenerateNaf(BigInteger k);
    public static Byte[] GenerateWindowNaf(int width, BigInteger k);
    public static int GetNafWeight(BigInteger k);
    public static WNafPreCompInfo GetWNafPreCompInfo(ECPoint p);
    public static WNafPreCompInfo GetWNafPreCompInfo(PreCompInfo preCompInfo);
    public static int GetWindowSize(int bits);
    public static int GetWindowSize(int bits, int maxWidth);
    public static int GetWindowSize(int bits, Int32[] windowSizeCutoffs);
    public static int GetWindowSize(int bits, Int32[] windowSizeCutoffs, int maxWidth);
    public static WNafPreCompInfo Precompute(ECPoint p, int minWidth, bool includeNegated);
    public static WNafPreCompInfo PrecomputeWithPointMap(ECPoint p, ECPointMap pointMap, WNafPreCompInfo fromWNaf, bool includeNegated);
    private static Byte[] Trim(Byte[] a, int length);
    private static Int32[] Trim(Int32[] a, int length);
    private static ECPoint[] ResizeTable(ECPoint[] a, int length);
}
public class Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier : AbstractECMultiplier {
    internal static string PRECOMP_NAME;
    private static WTauNafMultiplier();
    protected virtual ECPoint MultiplyPositive(ECPoint point, BigInteger k);
    private AbstractF2mPoint MultiplyWTnaf(AbstractF2mPoint p, ZTauElement lambda, sbyte a, sbyte mu);
    private static AbstractF2mPoint MultiplyFromWTnaf(AbstractF2mPoint p, SByte[] u);
}
public class Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo : object {
    protected AbstractF2mPoint[] m_preComp;
    public AbstractF2mPoint[] PreComp { get; public set; }
    public virtual AbstractF2mPoint[] get_PreComp();
    public virtual void set_PreComp(AbstractF2mPoint[] value);
}
public static class Org.BouncyCastle.Math.EC.Rfc7748.X25519 : object {
    public static int PointSize;
    public static int ScalarSize;
    private static int C_A;
    private static int C_A24;
    public static bool CalculateAgreement(Byte[] k, int kOff, Byte[] u, int uOff, Byte[] r, int rOff);
    private static UInt32 Decode32(Byte[] bs, int off);
    private static void DecodeScalar(Byte[] k, int kOff, UInt32[] n);
    public static void GeneratePrivateKey(SecureRandom random, Byte[] k);
    public static void GeneratePublicKey(Byte[] k, int kOff, Byte[] r, int rOff);
    private static void PointDouble(Int32[] x, Int32[] z);
    public static void Precompute();
    public static void ScalarMult(Byte[] k, int kOff, Byte[] u, int uOff, Byte[] r, int rOff);
    public static void ScalarMultBase(Byte[] k, int kOff, Byte[] r, int rOff);
}
public static class Org.BouncyCastle.Math.EC.Rfc7748.X25519Field : object {
    public static int Size;
    private static int M24;
    private static int M25;
    private static int M26;
    private static UInt32[] P32;
    private static Int32[] RootNegOne;
    private static X25519Field();
    public static void Add(Int32[] x, Int32[] y, Int32[] z);
    public static void AddOne(Int32[] z);
    public static void AddOne(Int32[] z, int zOff);
    public static void Apm(Int32[] x, Int32[] y, Int32[] zp, Int32[] zm);
    public static int AreEqual(Int32[] x, Int32[] y);
    public static bool AreEqualVar(Int32[] x, Int32[] y);
    public static void Carry(Int32[] z);
    public static void CMov(int cond, Int32[] x, int xOff, Int32[] z, int zOff);
    public static void CNegate(int negate, Int32[] z);
    public static void Copy(Int32[] x, int xOff, Int32[] z, int zOff);
    public static Int32[] Create();
    public static Int32[] CreateTable(int n);
    public static void CSwap(int swap, Int32[] a, Int32[] b);
    [CLSCompliantAttribute("False")]
public static void Decode(UInt32[] x, int xOff, Int32[] z);
    public static void Decode(Byte[] x, Int32[] z);
    public static void Decode(Byte[] x, int xOff, Int32[] z);
    public static void Decode(Byte[] x, int xOff, Int32[] z, int zOff);
    private static void Decode128(UInt32[] x, int xOff, Int32[] z, int zOff);
    private static void Decode128(Byte[] bs, int off, Int32[] z, int zOff);
    private static UInt32 Decode32(Byte[] bs, int off);
    [CLSCompliantAttribute("False")]
public static void Encode(Int32[] x, UInt32[] z, int zOff);
    public static void Encode(Int32[] x, Byte[] z);
    public static void Encode(Int32[] x, Byte[] z, int zOff);
    public static void Encode(Int32[] x, int xOff, Byte[] z, int zOff);
    private static void Encode128(Int32[] x, int xOff, UInt32[] z, int zOff);
    private static void Encode128(Int32[] x, int xOff, Byte[] bs, int off);
    private static void Encode32(UInt32 n, Byte[] bs, int off);
    public static void Inv(Int32[] x, Int32[] z);
    public static void InvVar(Int32[] x, Int32[] z);
    public static int IsOne(Int32[] x);
    public static bool IsOneVar(Int32[] x);
    public static int IsZero(Int32[] x);
    public static bool IsZeroVar(Int32[] x);
    public static void Mul(Int32[] x, int y, Int32[] z);
    public static void Mul(Int32[] x, Int32[] y, Int32[] z);
    public static void Negate(Int32[] x, Int32[] z);
    public static void Normalize(Int32[] z);
    public static void One(Int32[] z);
    private static void PowPm5d8(Int32[] x, Int32[] rx2, Int32[] rz);
    private static void Reduce(Int32[] z, int x);
    public static void Sqr(Int32[] x, Int32[] z);
    public static void Sqr(Int32[] x, int n, Int32[] z);
    public static bool SqrtRatioVar(Int32[] u, Int32[] v, Int32[] z);
    public static void Sub(Int32[] x, Int32[] y, Int32[] z);
    public static void SubOne(Int32[] z);
    public static void Zero(Int32[] z);
}
public static class Org.BouncyCastle.Math.EC.Rfc7748.X448 : object {
    public static int PointSize;
    public static int ScalarSize;
    private static UInt32 C_A;
    private static UInt32 C_A24;
    public static bool CalculateAgreement(Byte[] k, int kOff, Byte[] u, int uOff, Byte[] r, int rOff);
    private static UInt32 Decode32(Byte[] bs, int off);
    private static void DecodeScalar(Byte[] k, int kOff, UInt32[] n);
    public static void GeneratePrivateKey(SecureRandom random, Byte[] k);
    public static void GeneratePublicKey(Byte[] k, int kOff, Byte[] r, int rOff);
    private static void PointDouble(UInt32[] x, UInt32[] z);
    public static void Precompute();
    public static void ScalarMult(Byte[] k, int kOff, Byte[] u, int uOff, Byte[] r, int rOff);
    public static void ScalarMultBase(Byte[] k, int kOff, Byte[] r, int rOff);
}
[CLSCompliantAttribute("False")]
public static class Org.BouncyCastle.Math.EC.Rfc7748.X448Field : object {
    public static int Size;
    private static UInt32 M28;
    private static UInt32[] P32;
    private static X448Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddOne(UInt32[] z);
    public static void AddOne(UInt32[] z, int zOff);
    public static int AreEqual(UInt32[] x, UInt32[] y);
    public static bool AreEqualVar(UInt32[] x, UInt32[] y);
    public static void Carry(UInt32[] z);
    public static void CMov(int cond, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void CNegate(int negate, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt32[] Create();
    public static UInt32[] CreateTable(int n);
    public static void CSwap(int swap, UInt32[] a, UInt32[] b);
    public static void Decode(UInt32[] x, int xOff, UInt32[] z);
    public static void Decode(Byte[] x, UInt32[] z);
    public static void Decode(Byte[] x, int xOff, UInt32[] z);
    public static void Decode(Byte[] x, int xOff, UInt32[] z, int zOff);
    private static void Decode224(UInt32[] x, int xOff, UInt32[] z, int zOff);
    private static UInt32 Decode24(Byte[] bs, int off);
    private static UInt32 Decode32(Byte[] bs, int off);
    private static void Decode56(Byte[] bs, int off, UInt32[] z, int zOff);
    public static void Encode(UInt32[] x, UInt32[] z, int zOff);
    public static void Encode(UInt32[] x, Byte[] z);
    public static void Encode(UInt32[] x, Byte[] z, int zOff);
    public static void Encode(UInt32[] x, int xOff, Byte[] z, int zOff);
    private static void Encode224(UInt32[] x, int xOff, UInt32[] z, int zOff);
    private static void Encode24(UInt32 n, Byte[] bs, int off);
    private static void Encode32(UInt32 n, Byte[] bs, int off);
    private static void Encode56(UInt32[] x, int xOff, Byte[] bs, int off);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static void InvVar(UInt32[] x, UInt32[] z);
    public static int IsOne(UInt32[] x);
    public static bool IsOneVar(UInt32[] x);
    public static int IsZero(UInt32[] x);
    public static bool IsZeroVar(UInt32[] x);
    public static void Mul(UInt32[] x, UInt32 y, UInt32[] z);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Normalize(UInt32[] z);
    public static void One(UInt32[] z);
    private static void PowPm3d4(UInt32[] x, UInt32[] z);
    private static void Reduce(UInt32[] z, int x);
    public static void Sqr(UInt32[] x, UInt32[] z);
    public static void Sqr(UInt32[] x, int n, UInt32[] z);
    public static bool SqrtRatioVar(UInt32[] u, UInt32[] v, UInt32[] z);
    public static void Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubOne(UInt32[] z);
    public static void Zero(UInt32[] z);
}
internal static class Org.BouncyCastle.Math.EC.Rfc8032.Codec : object {
    internal static UInt32 Decode16(Byte[] bs, int off);
    internal static UInt32 Decode24(Byte[] bs, int off);
    internal static UInt32 Decode32(Byte[] bs, int off);
    internal static void Decode32(Byte[] bs, int bsOff, UInt32[] n, int nOff, int nLen);
    internal static void Encode24(UInt32 n, Byte[] bs, int off);
    internal static void Encode32(UInt32 n, Byte[] bs, int off);
    internal static void Encode32(UInt32[] n, int nOff, int nLen, Byte[] bs, int bsOff);
    internal static void Encode56(ulong n, Byte[] bs, int off);
}
public static class Org.BouncyCastle.Math.EC.Rfc8032.Ed25519 : object {
    private static int CoordUints;
    private static int PointBytes;
    private static int ScalarUints;
    private static int ScalarBytes;
    public static int PrehashSize;
    public static int PublicKeySize;
    public static int SecretKeySize;
    public static int SignatureSize;
    private static Byte[] Dom2Prefix;
    private static UInt32[] P;
    private static UInt32[] Order8_y1;
    private static UInt32[] Order8_y2;
    private static Int32[] B_x;
    private static Int32[] B_y;
    private static Int32[] B128_x;
    private static Int32[] B128_y;
    private static Int32[] C_d;
    private static Int32[] C_d2;
    private static Int32[] C_d4;
    private static int WnafWidth128;
    private static int WnafWidthBase;
    private static int PrecompBlocks;
    private static int PrecompTeeth;
    private static int PrecompSpacing;
    private static int PrecompRange;
    private static int PrecompPoints;
    private static int PrecompMask;
    private static object PrecompLock;
    private static PointPrecomp[] PrecompBaseWnaf;
    private static PointPrecomp[] PrecompBase128Wnaf;
    private static Int32[] PrecompBaseComb;
    private static Ed25519();
    private static Byte[] CalculateS(Byte[] r, Byte[] k, Byte[] s);
    private static bool CheckContextVar(Byte[] ctx, byte phflag);
    private static int CheckPoint(PointAffine& p);
    private static int CheckPoint(PointAccum p);
    private static bool CheckPointFullVar(Byte[] p);
    private static bool CheckPointOrderVar(PointAffine& p);
    private static bool CheckPointVar(Byte[] p);
    private static Byte[] Copy(Byte[] buf, int off, int len);
    private static IDigest CreateDigest();
    public static IDigest CreatePrehash();
    private static bool DecodePointVar(Byte[] p, bool negate, PointAffine& r);
    private static void Dom2(IDigest d, byte phflag, Byte[] ctx);
    private static void EncodePoint(PointAffine& p, Byte[] r, int rOff);
    public static void EncodePublicPoint(PublicPoint publicPoint, Byte[] pk, int pkOff);
    private static int EncodeResult(PointAccum& p, Byte[] r, int rOff);
    private static PublicPoint ExportPoint(PointAffine& p);
    public static void GeneratePrivateKey(SecureRandom random, Byte[] k);
    public static void GeneratePublicKey(Byte[] sk, int skOff, Byte[] pk, int pkOff);
    public static PublicPoint GeneratePublicKey(Byte[] sk, int skOff);
    private static UInt32 GetWindow4(UInt32[] x, int n);
    private static void GroupCombBits(UInt32[] n);
    private static void ImplSign(IDigest d, Byte[] h, Byte[] s, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static void ImplSign(Byte[] sk, int skOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static void ImplSign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static bool ImplVerify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen);
    private static bool ImplVerify(Byte[] sig, int sigOff, PublicPoint publicPoint, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen);
    private static void Init(PointAccum& r);
    private static void Init(PointAffine& r);
    private static void Init(PointExtended& r);
    private static void Init(PointPrecomp& r);
    private static void Init(PointPrecompZ& r);
    private static void Init(PointTemp& r);
    private static void InvertDoubleZs(PointExtended[] points);
    private static bool IsNeutralElementVar(Int32[] x, Int32[] y, Int32[] z);
    private static void NormalizeToAffine(PointAccum& p, PointAffine& r);
    private static bool NormalizeToNeutralElementVar(PointAccum& p);
    private static void PointAdd(PointExtended& p, PointExtended& q, PointExtended& r, PointTemp& t);
    private static void PointAdd(PointPrecomp& p, PointAccum& r, PointTemp& t);
    private static void PointAdd(PointPrecompZ& p, PointAccum& r, PointTemp& t);
    private static void PointAddVar(bool negate, PointPrecomp& p, PointAccum& r, PointTemp& t);
    private static void PointAddVar(bool negate, PointPrecompZ& p, PointAccum& r, PointTemp& t);
    private static void PointCopy(PointAccum& p, PointExtended& r);
    private static void PointCopy(PointAffine& p, PointExtended& r);
    private static void PointCopy(PointExtended& p, PointPrecompZ& r);
    private static void PointDouble(PointAccum& r);
    private static void PointLookup(int block, int index, PointPrecomp& p);
    private static void PointLookupZ(UInt32[] x, int n, Int32[] table, PointPrecompZ& r);
    private static void PointPrecompute(PointAffine& p, PointExtended[] points, int pointsOff, int pointsLen, PointTemp& t);
    private static Int32[] PointPrecomputeZ(PointAffine& p, int count, PointTemp& t);
    private static void PointPrecomputeZ(PointAffine& p, PointPrecompZ[] points, int count, PointTemp& t);
    private static void PointSetNeutral(PointAccum& p);
    public static void Precompute();
    private static void PruneScalar(Byte[] n, int nOff, Byte[] r);
    private static void ScalarMult(Byte[] k, PointAffine& p, PointAccum& r);
    private static void ScalarMultBase(Byte[] k, PointAccum& r);
    private static void ScalarMultBaseEncoded(Byte[] k, Byte[] r, int rOff);
    internal static void ScalarMultBaseYZ(Byte[] k, int kOff, Int32[] y, Int32[] z);
    private static void ScalarMultOrderVar(PointAffine& p, PointAccum& r);
    private static void ScalarMultStraus128Var(UInt32[] nb, UInt32[] np, PointAffine& p, UInt32[] nq, PointAffine& q, PointAccum& r);
    public static void Sign(Byte[] sk, int skOff, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void Sign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void Sign(Byte[] sk, int skOff, Byte[] ctx, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void Sign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] ctx, Byte[] ph, int phOff, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] ph, int phOff, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] ctx, IDigest ph, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, IDigest ph, Byte[] sig, int sigOff);
    public static bool ValidatePublicKeyFull(Byte[] pk, int pkOff);
    public static PublicPoint ValidatePublicKeyFullExport(Byte[] pk, int pkOff);
    public static bool ValidatePublicKeyPartial(Byte[] pk, int pkOff);
    public static PublicPoint ValidatePublicKeyPartialExport(Byte[] pk, int pkOff);
    public static bool Verify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] m, int mOff, int mLen);
    public static bool Verify(Byte[] sig, int sigOff, PublicPoint publicPoint, Byte[] m, int mOff, int mLen);
    public static bool Verify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] m, int mOff, int mLen);
    public static bool Verify(Byte[] sig, int sigOff, PublicPoint publicPoint, Byte[] ctx, Byte[] m, int mOff, int mLen);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] ph, int phOff);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, PublicPoint publicPoint, Byte[] ctx, Byte[] ph, int phOff);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, IDigest ph);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, PublicPoint publicPoint, Byte[] ctx, IDigest ph);
}
public static class Org.BouncyCastle.Math.EC.Rfc8032.Ed448 : object {
    private static int CoordUints;
    private static int PointBytes;
    private static int ScalarUints;
    private static int ScalarBytes;
    public static int PrehashSize;
    public static int PublicKeySize;
    public static int SecretKeySize;
    public static int SignatureSize;
    private static Byte[] Dom4Prefix;
    private static UInt32[] P;
    private static UInt32[] B_x;
    private static UInt32[] B_y;
    private static UInt32[] B225_x;
    private static UInt32[] B225_y;
    private static int C_d;
    private static int WnafWidth225;
    private static int WnafWidthBase;
    private static int PrecompBlocks;
    private static int PrecompTeeth;
    private static int PrecompSpacing;
    private static int PrecompRange;
    private static int PrecompPoints;
    private static int PrecompMask;
    private static object PrecompLock;
    private static PointAffine[] PrecompBaseWnaf;
    private static PointAffine[] PrecompBase225Wnaf;
    private static UInt32[] PrecompBaseComb;
    private static Ed448();
    private static Byte[] CalculateS(Byte[] r, Byte[] k, Byte[] s);
    private static bool CheckContextVar(Byte[] ctx);
    private static int CheckPoint(PointAffine& p);
    private static int CheckPoint(PointProjective p);
    private static bool CheckPointFullVar(Byte[] p);
    private static bool CheckPointOrderVar(PointAffine& p);
    private static bool CheckPointVar(Byte[] p);
    private static Byte[] Copy(Byte[] buf, int off, int len);
    public static IXof CreatePrehash();
    private static IXof CreateXof();
    private static bool DecodePointVar(Byte[] p, bool negate, PointAffine& r);
    private static void Dom4(IXof d, byte phflag, Byte[] ctx);
    private static void EncodePoint(PointAffine& p, Byte[] r, int rOff);
    public static void EncodePublicPoint(PublicPoint publicPoint, Byte[] pk, int pkOff);
    private static int EncodeResult(PointProjective& p, Byte[] r, int rOff);
    private static PublicPoint ExportPoint(PointAffine& p);
    public static void GeneratePrivateKey(SecureRandom random, Byte[] k);
    public static void GeneratePublicKey(Byte[] sk, int skOff, Byte[] pk, int pkOff);
    public static PublicPoint GeneratePublicKey(Byte[] sk, int skOff);
    private static UInt32 GetWindow4(UInt32[] x, int n);
    private static void ImplSign(IXof d, Byte[] h, Byte[] s, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static void ImplSign(Byte[] sk, int skOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static void ImplSign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static bool ImplVerify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen);
    private static bool ImplVerify(Byte[] sig, int sigOff, PublicPoint publicPoint, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen);
    private static void Init(PointAffine& r);
    private static void Init(PointProjective& r);
    private static void Init(PointTemp& r);
    private static void InvertZs(PointProjective[] points);
    private static bool IsNeutralElementVar(UInt32[] x, UInt32[] y, UInt32[] z);
    private static void NormalizeToAffine(PointProjective& p, PointAffine& r);
    private static bool NormalizeToNeutralElementVar(PointProjective& p);
    private static void PointAdd(PointAffine& p, PointProjective& r, PointTemp& t);
    private static void PointAdd(PointProjective& p, PointProjective& r, PointTemp& t);
    private static void PointAddVar(bool negate, PointAffine& p, PointProjective& r, PointTemp& t);
    private static void PointAddVar(bool negate, PointProjective& p, PointProjective& r, PointTemp& t);
    private static void PointCopy(PointAffine& p, PointProjective& r);
    private static void PointCopy(PointProjective& p, PointProjective& r);
    private static void PointDouble(PointProjective& r, PointTemp& t);
    private static void PointLookup(int block, int index, PointAffine& p);
    private static void PointLookup(UInt32[] x, int n, UInt32[] table, PointProjective& r);
    private static void PointLookup15(UInt32[] table, PointProjective& r);
    private static UInt32[] PointPrecompute(PointProjective& p, int count, PointTemp& t);
    private static void PointPrecompute(PointAffine& p, PointProjective[] points, int pointsOff, int pointsLen, PointTemp& t);
    private static void PointSetNeutral(PointProjective& p);
    public static void Precompute();
    private static void PruneScalar(Byte[] n, int nOff, Byte[] r);
    private static void ScalarMult(Byte[] k, PointProjective& p, PointProjective& r);
    private static void ScalarMultBase(Byte[] k, PointProjective& r);
    private static void ScalarMultBaseEncoded(Byte[] k, Byte[] r, int rOff);
    internal static void ScalarMultBaseXY(Byte[] k, int kOff, UInt32[] x, UInt32[] y);
    private static void ScalarMultOrderVar(PointAffine& p, PointProjective& r);
    private static void ScalarMultStraus225Var(UInt32[] nb, UInt32[] np, PointAffine& p, UInt32[] nq, PointAffine& q, PointProjective& r);
    public static void Sign(Byte[] sk, int skOff, Byte[] ctx, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void Sign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] ctx, Byte[] ph, int phOff, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] ph, int phOff, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] ctx, IXof ph, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, IXof ph, Byte[] sig, int sigOff);
    public static bool ValidatePublicKeyFull(Byte[] pk, int pkOff);
    public static PublicPoint ValidatePublicKeyFullExport(Byte[] pk, int pkOff);
    public static bool ValidatePublicKeyPartial(Byte[] pk, int pkOff);
    public static PublicPoint ValidatePublicKeyPartialExport(Byte[] pk, int pkOff);
    public static bool Verify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] m, int mOff, int mLen);
    public static bool Verify(Byte[] sig, int sigOff, PublicPoint publicPoint, Byte[] ctx, Byte[] m, int mOff, int mLen);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] ph, int phOff);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, PublicPoint publicPoint, Byte[] ctx, Byte[] ph, int phOff);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, IXof ph);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, PublicPoint publicPoint, Byte[] ctx, IXof ph);
}
internal static class Org.BouncyCastle.Math.EC.Rfc8032.Scalar25519 : object {
    internal static int Size;
    private static long M08L;
    private static long M28L;
    private static long M32L;
    private static int TargetLength;
    private static UInt32[] L;
    private static UInt32[] LSq;
    private static int L0;
    private static int L1;
    private static int L2;
    private static int L3;
    private static int L4;
    private static Scalar25519();
    internal static bool CheckVar(Byte[] s, UInt32[] n);
    internal static void Decode(Byte[] k, UInt32[] n);
    internal static void GetOrderWnafVar(int width, SByte[] ws);
    internal static void Multiply128Var(UInt32[] x, UInt32[] y128, UInt32[] z);
    internal static Byte[] Reduce(Byte[] n);
    internal static void ReduceBasisVar(UInt32[] k, UInt32[] z0, UInt32[] z1);
    internal static void ToSignedDigits(int bits, UInt32[] x, UInt32[] z);
}
internal static class Org.BouncyCastle.Math.EC.Rfc8032.Scalar448 : object {
    internal static int Size;
    private static int ScalarBytes;
    private static ulong M26UL;
    private static ulong M28UL;
    private static int TargetLength;
    private static UInt32[] L;
    private static UInt32[] LSq;
    private static int L_0;
    private static int L_1;
    private static int L_2;
    private static int L_3;
    private static int L_4;
    private static int L_5;
    private static int L_6;
    private static int L_7;
    private static int L4_0;
    private static int L4_1;
    private static int L4_2;
    private static int L4_3;
    private static int L4_4;
    private static int L4_5;
    private static int L4_6;
    private static int L4_7;
    private static Scalar448();
    internal static bool CheckVar(Byte[] s, UInt32[] n);
    internal static void Decode(Byte[] k, UInt32[] n);
    internal static void GetOrderWnafVar(int width, SByte[] ws);
    internal static void Multiply225Var(UInt32[] x, UInt32[] y225, UInt32[] z);
    internal static Byte[] Reduce(Byte[] n);
    internal static void ReduceBasisVar(UInt32[] k, UInt32[] z0, UInt32[] z1);
    internal static void ToSignedDigits(int bits, UInt32[] x, UInt32[] z);
}
internal static class Org.BouncyCastle.Math.EC.Rfc8032.ScalarUtilities : object {
    internal static void AddShifted_NP(int last, int s, UInt32[] Nu, UInt32[] Nv, UInt32[] _p);
    internal static void AddShifted_UV(int last, int s, UInt32[] u0, UInt32[] u1, UInt32[] v0, UInt32[] v1);
    internal static int GetBitLength(int last, UInt32[] x);
    internal static int GetBitLengthPositive(int last, UInt32[] x);
    internal static bool LessThan(int last, UInt32[] x, UInt32[] y);
    internal static void SubShifted_NP(int last, int s, UInt32[] Nu, UInt32[] Nv, UInt32[] _p);
    internal static void SubShifted_UV(int last, int s, UInt32[] u0, UInt32[] u1, UInt32[] v0, UInt32[] v1);
    internal static void Swap(UInt32[]& x, UInt32[]& y);
}
internal static class Org.BouncyCastle.Math.EC.Rfc8032.Wnaf : object {
    internal static void GetSignedVar(UInt32[] n, int width, SByte[] ws);
}
public class Org.BouncyCastle.Math.EC.ScaleXNegateYPointMap : object {
    protected ECFieldElement scale;
    public ScaleXNegateYPointMap(ECFieldElement scale);
    public virtual ECPoint Map(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.ScaleXPointMap : object {
    protected ECFieldElement scale;
    public ScaleXPointMap(ECFieldElement scale);
    public virtual ECPoint Map(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.ScaleYNegateXPointMap : object {
    protected ECFieldElement scale;
    public ScaleYNegateXPointMap(ECFieldElement scale);
    public virtual ECPoint Map(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.ScaleYPointMap : object {
    protected ECFieldElement scale;
    public ScaleYPointMap(ECFieldElement scale);
    public virtual ECPoint Map(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.SimpleLookupTable : AbstractECLookupTable {
    private ECPoint[] points;
    public int Size { get; }
    public SimpleLookupTable(ECPoint[] points, int off, int len);
    private static ECPoint[] Copy(ECPoint[] points, int off, int len);
    public virtual int get_Size();
    public virtual ECPoint Lookup(int index);
    public virtual ECPoint LookupVar(int index);
}
public abstract class Org.BouncyCastle.Math.Field.FiniteFields : object {
    internal static IFiniteField GF_2;
    internal static IFiniteField GF_3;
    private static FiniteFields();
    public static IPolynomialExtensionField GetBinaryExtensionField(Int32[] exponents);
    public static IFiniteField GetPrimeField(BigInteger characteristic);
}
internal class Org.BouncyCastle.Math.Field.GenericPolynomialExtensionField : object {
    protected IFiniteField subfield;
    protected IPolynomial minimalPolynomial;
    public BigInteger Characteristic { get; }
    public int Dimension { get; }
    public IFiniteField Subfield { get; }
    public int Degree { get; }
    public IPolynomial MinimalPolynomial { get; }
    internal GenericPolynomialExtensionField(IFiniteField subfield, IPolynomial polynomial);
    public virtual BigInteger get_Characteristic();
    public virtual int get_Dimension();
    public virtual IFiniteField get_Subfield();
    public virtual int get_Degree();
    public virtual IPolynomial get_MinimalPolynomial();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.Field.GF2Polynomial : object {
    protected Int32[] exponents;
    public int Degree { get; }
    internal GF2Polynomial(Int32[] exponents);
    public virtual int get_Degree();
    public virtual Int32[] GetExponentsPresent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface Org.BouncyCastle.Math.Field.IExtensionField {
    public IFiniteField Subfield { get; }
    public int Degree { get; }
    public abstract virtual IFiniteField get_Subfield();
    public abstract virtual int get_Degree();
}
public interface Org.BouncyCastle.Math.Field.IFiniteField {
    public BigInteger Characteristic { get; }
    public int Dimension { get; }
    public abstract virtual BigInteger get_Characteristic();
    public abstract virtual int get_Dimension();
}
public interface Org.BouncyCastle.Math.Field.IPolynomial {
    public int Degree { get; }
    public abstract virtual int get_Degree();
    public abstract virtual Int32[] GetExponentsPresent();
}
public interface Org.BouncyCastle.Math.Field.IPolynomialExtensionField {
    public IPolynomial MinimalPolynomial { get; }
    public abstract virtual IPolynomial get_MinimalPolynomial();
}
internal class Org.BouncyCastle.Math.Field.PrimeField : object {
    protected BigInteger characteristic;
    public BigInteger Characteristic { get; }
    public int Dimension { get; }
    internal PrimeField(BigInteger characteristic);
    public virtual BigInteger get_Characteristic();
    public virtual int get_Dimension();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class Org.BouncyCastle.Math.Primes : object {
    public static int SmallFactorLimit;
    private static BigInteger One;
    private static BigInteger Two;
    private static BigInteger Three;
    private static Primes();
    public static STOutput GenerateSTRandomPrime(IDigest hash, int length, Byte[] inputSeed);
    public static MROutput EnhancedMRProbablePrimeTest(BigInteger candidate, SecureRandom random, int iterations);
    public static bool HasAnySmallFactors(BigInteger candidate);
    public static bool IsMRProbablePrime(BigInteger candidate, SecureRandom random, int iterations);
    public static bool IsMRProbablePrimeToBase(BigInteger candidate, BigInteger baseValue);
    private static void CheckCandidate(BigInteger n, string name);
    private static bool ImplHasAnySmallFactors(BigInteger x);
    private static bool ImplMRProbablePrimeToBase(BigInteger w, BigInteger wSubOne, BigInteger m, int a, BigInteger b);
    private static STOutput ImplSTRandomPrime(IDigest d, int length, Byte[] primeSeed);
    private static void Hash(IDigest d, Byte[] input, Byte[] output, int outPos);
    private static BigInteger HashGen(IDigest d, Byte[] seed, int count);
    private static void Inc(Byte[] seed, int c);
    private static bool IsPrime32(UInt32 x);
}
internal static class Org.BouncyCastle.Math.Raw.Bits : object {
    internal static UInt32 BitPermuteStep(UInt32 x, UInt32 m, int s);
    internal static ulong BitPermuteStep(ulong x, ulong m, int s);
    internal static void BitPermuteStep2(UInt32& hi, UInt32& lo, UInt32 m, int s);
    internal static void BitPermuteStep2(UInt64& hi, UInt64& lo, ulong m, int s);
    internal static UInt32 BitPermuteStepSimple(UInt32 x, UInt32 m, int s);
    internal static ulong BitPermuteStepSimple(ulong x, ulong m, int s);
}
internal static class Org.BouncyCastle.Math.Raw.Interleave : object {
    private static ulong M32;
    private static ulong M64;
    private static ulong M64R;
    internal static UInt32 Expand8to16(byte x);
    internal static UInt32 Expand16to32(ushort x);
    internal static ulong Expand32to64(UInt32 x);
    internal static void Expand64To128(ulong x, UInt64[] z, int zOff);
    internal static void Expand64To128(UInt64[] xs, int xsOff, int xsLen, UInt64[] zs, int zsOff);
    internal static ulong Expand64To128Rev(ulong x, UInt64& low);
    internal static UInt32 Shuffle(UInt32 x);
    internal static ulong Shuffle(ulong x);
    internal static UInt32 Shuffle2(UInt32 x);
    internal static UInt32 Unshuffle(UInt32 x);
    internal static ulong Unshuffle(ulong x);
    internal static ulong Unshuffle(ulong x, UInt64& even);
    internal static ulong Unshuffle(ulong x0, ulong x1, UInt64& even);
    internal static UInt32 Unshuffle2(UInt32 x);
}
internal static class Org.BouncyCastle.Math.Raw.Mod : object {
    private static int M30;
    private static ulong M32UL;
    public static void CheckedModOddInverse(UInt32[] m, UInt32[] x, UInt32[] z);
    public static void CheckedModOddInverseVar(UInt32[] m, UInt32[] x, UInt32[] z);
    public static UInt32 Inverse32(UInt32 d);
    public static ulong Inverse64(ulong d);
    public static UInt32 ModOddInverse(UInt32[] m, UInt32[] x, UInt32[] z);
    public static bool ModOddInverseVar(UInt32[] m, UInt32[] x, UInt32[] z);
    public static UInt32[] Random(SecureRandom random, UInt32[] p);
    private static int Add30(int len30, Int32[] D, Int32[] M);
    private static void CNegate30(int len30, int cond, Int32[] D);
    private static void CNormalize30(int len30, int condNegate, Int32[] D, Int32[] M);
    private static void Decode30(int bits, Int32[] x, int xOff, UInt32[] z, int zOff);
    private static int Divsteps30(int delta, int f0, int g0, Int32[] t);
    private static int Divsteps30Var(int eta, int f0, int g0, Int32[] t);
    private static void Encode30(int bits, UInt32[] x, int xOff, Int32[] z, int zOff);
    private static int EqualTo(int len, Int32[] x, int y);
    private static bool EqualToOneVar_Expected(int len, Int32[] x);
    private static int EqualToZero(int len, Int32[] x);
    private static bool EqualToZeroVar_Unlikely(int len, Int32[] x);
    private static int GetMaximumDivsteps(int bits);
    private static int Negate30(int len30, Int32[] D);
    private static void UpdateDE30(int len30, Int32[] D, Int32[] E, Int32[] t, int m0Inv32, Int32[] M);
    private static void UpdateFG30(int len30, Int32[] F, Int32[] G, Int32[] t);
}
internal static class Org.BouncyCastle.Math.Raw.Nat : object {
    private static ulong M;
    public static UInt32 Add(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 Add33At(int len, UInt32 x, UInt32[] z, int zPos);
    public static UInt32 Add33At(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static UInt32 Add33To(int len, UInt32 x, UInt32[] z);
    public static UInt32 Add33To(int len, UInt32 x, UInt32[] z, int zOff);
    public static UInt32 AddBothTo(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddDWordAt(int len, ulong x, UInt32[] z, int zPos);
    public static UInt32 AddDWordAt(int len, ulong x, UInt32[] z, int zOff, int zPos);
    public static UInt32 AddDWordTo(int len, ulong x, UInt32[] z);
    public static UInt32 AddDWordTo(int len, ulong x, UInt32[] z, int zOff);
    public static UInt32 AddTo(int len, UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(int len, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt32 AddTo(int len, UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(int len, UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static UInt32 AddWordAt(int len, UInt32 x, UInt32[] z, int zPos);
    public static UInt32 AddWordAt(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static UInt32 AddWordTo(int len, UInt32 x, UInt32[] z);
    public static UInt32 AddWordTo(int len, UInt32 x, UInt32[] z, int zOff);
    public static UInt32 CAdd(int len, int mask, UInt32[] x, UInt32[] y, UInt32[] z);
    public static void CMov(int len, int mask, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static int Compare(int len, UInt32[] x, UInt32[] y);
    public static int Compare(int len, UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static UInt32[] Copy(int len, UInt32[] x);
    public static void Copy(int len, UInt32[] x, UInt32[] z);
    public static void Copy(int len, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt64[] Copy64(int len, UInt64[] x);
    public static void Copy64(int len, UInt64[] x, UInt64[] z);
    public static void Copy64(int len, UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt32[] Create(int len);
    public static UInt64[] Create64(int len);
    public static int CSub(int len, int mask, UInt32[] x, UInt32[] y, UInt32[] z);
    public static int CSub(int len, int mask, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int Dec(int len, UInt32[] z);
    public static int Dec(int len, UInt32[] x, UInt32[] z);
    public static int DecAt(int len, UInt32[] z, int zPos);
    public static int DecAt(int len, UInt32[] z, int zOff, int zPos);
    public static bool Eq(int len, UInt32[] x, UInt32[] y);
    public static UInt32 EqualTo(int len, UInt32[] x, UInt32 y);
    public static UInt32 EqualTo(int len, UInt32[] x, int xOff, UInt32 y);
    public static UInt32 EqualTo(int len, UInt32[] x, UInt32[] y);
    public static UInt32 EqualTo(int len, UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static UInt32 EqualToZero(int len, UInt32[] x);
    public static UInt32 EqualToZero(int len, UInt32[] x, int xOff);
    public static UInt32[] FromBigInteger(int bits, BigInteger x);
    public static UInt64[] FromBigInteger64(int bits, BigInteger x);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static int GetLengthForBits(int bits);
    public static int GetLengthForBits64(int bits);
    public static bool Gte(int len, UInt32[] x, UInt32[] y);
    public static UInt32 Inc(int len, UInt32[] z);
    public static UInt32 Inc(int len, UInt32[] x, UInt32[] z);
    public static UInt32 IncAt(int len, UInt32[] z, int zPos);
    public static UInt32 IncAt(int len, UInt32[] z, int zOff, int zPos);
    public static bool IsOne(int len, UInt32[] x);
    public static bool IsZero(int len, UInt32[] x);
    public static int LessThan(int len, UInt32[] x, UInt32[] y);
    public static int LessThan(int len, UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static void Mul(int len, UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static void Mul(UInt32[] x, int xOff, int xLen, UInt32[] y, int yOff, int yLen, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(int len, UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 Mul31BothAdd(int len, UInt32 a, UInt32[] x, UInt32 b, UInt32[] y, UInt32[] z, int zOff);
    public static UInt32 MulWord(int len, UInt32 x, UInt32[] y, UInt32[] z);
    public static UInt32 MulWord(int len, UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordAddTo(int len, UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAddAt(int len, UInt32 x, ulong y, UInt32[] z, int zPos);
    public static int Negate(int len, UInt32[] x, UInt32[] z);
    public static UInt32 ShiftDownBit(int len, UInt32[] z, UInt32 c);
    public static UInt32 ShiftDownBit(int len, UInt32[] z, int zOff, UInt32 c);
    public static UInt32 ShiftDownBit(int len, UInt32[] x, UInt32 c, UInt32[] z);
    public static UInt32 ShiftDownBit(int len, UInt32[] x, int xOff, UInt32 c, UInt32[] z, int zOff);
    public static UInt32 ShiftDownBits(int len, UInt32[] z, int bits, UInt32 c);
    public static UInt32 ShiftDownBits(int len, UInt32[] z, int zOff, int bits, UInt32 c);
    public static UInt32 ShiftDownBits(int len, UInt32[] x, int bits, UInt32 c, UInt32[] z);
    public static UInt32 ShiftDownBits(int len, UInt32[] x, int xOff, int bits, UInt32 c, UInt32[] z, int zOff);
    public static ulong ShiftDownBits64(int len, UInt64[] z, int zOff, int bits, ulong c);
    public static UInt32 ShiftDownWord(int len, UInt32[] z, UInt32 c);
    public static UInt32 ShiftUpBit(int len, UInt32[] z, UInt32 c);
    public static UInt32 ShiftUpBit(int len, UInt32[] z, int zOff, UInt32 c);
    public static UInt32 ShiftUpBit(int len, UInt32[] x, UInt32 c, UInt32[] z);
    public static UInt32 ShiftUpBit(int len, UInt32[] x, int xOff, UInt32 c, UInt32[] z, int zOff);
    public static ulong ShiftUpBit64(int len, UInt64[] x, ulong c, UInt64[] z);
    public static ulong ShiftUpBit64(int len, UInt64[] x, int xOff, ulong c, UInt64[] z, int zOff);
    public static UInt32 ShiftUpBits(int len, UInt32[] z, int bits, UInt32 c);
    public static UInt32 ShiftUpBits(int len, UInt32[] z, int zOff, int bits, UInt32 c);
    public static UInt32 ShiftUpBits(int len, UInt32[] x, int bits, UInt32 c, UInt32[] z);
    public static UInt32 ShiftUpBits(int len, UInt32[] x, int xOff, int bits, UInt32 c, UInt32[] z, int zOff);
    public static ulong ShiftUpBits64(int len, UInt64[] z, int bits, ulong c);
    public static ulong ShiftUpBits64(int len, UInt64[] z, int zOff, int bits, ulong c);
    public static ulong ShiftUpBits64(int len, UInt64[] x, int bits, ulong c, UInt64[] z);
    public static ulong ShiftUpBits64(int len, UInt64[] x, int xOff, int bits, ulong c, UInt64[] z, int zOff);
    public static void Square(int len, UInt32[] x, UInt32[] zz);
    public static void Square(int len, UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static UInt32 SquareWordAddTo(UInt32[] x, int xPos, UInt32[] z);
    public static UInt32 SquareWordAddTo(UInt32[] x, int xOff, int xPos, UInt32[] z, int zOff);
    public static int Sub(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int Sub33At(int len, UInt32 x, UInt32[] z, int zPos);
    public static int Sub33At(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static int Sub33From(int len, UInt32 x, UInt32[] z);
    public static int Sub33From(int len, UInt32 x, UInt32[] z, int zOff);
    public static int SubBothFrom(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubBothFrom(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubDWordAt(int len, ulong x, UInt32[] z, int zPos);
    public static int SubDWordAt(int len, ulong x, UInt32[] z, int zOff, int zPos);
    public static int SubDWordFrom(int len, ulong x, UInt32[] z);
    public static int SubDWordFrom(int len, ulong x, UInt32[] z, int zOff);
    public static int SubFrom(int len, UInt32[] x, UInt32[] z);
    public static int SubFrom(int len, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static int SubWordAt(int len, UInt32 x, UInt32[] z, int zPos);
    public static int SubWordAt(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static int SubWordFrom(int len, UInt32 x, UInt32[] z);
    public static int SubWordFrom(int len, UInt32 x, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(int len, UInt32[] x);
    public static void Xor(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Xor(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static void Xor64(int len, UInt64[] x, ulong y, UInt64[] z);
    public static void Xor64(int len, UInt64[] x, int xOff, ulong y, UInt64[] z, int zOff);
    public static void Xor64(int len, UInt64[] x, UInt64[] y, UInt64[] z);
    public static void Xor64(int len, UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] z, int zOff);
    public static void XorTo(int len, UInt32[] x, UInt32[] z);
    public static void XorTo(int len, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void XorTo64(int len, UInt64[] x, UInt64[] z);
    public static void XorTo64(int len, UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static void Zero(int len, UInt32[] z);
    public static void Zero64(int len, UInt64[] z);
}
internal static class Org.BouncyCastle.Math.Raw.Nat128 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt32[] Create();
    public static UInt64[] Create64();
    public static UInt32[] CreateExt();
    public static UInt64[] CreateExt64();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero(UInt32[] x);
    public static bool IsZero64(UInt64[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordAddExt(UInt32 x, UInt32[] yy, int yyOff, UInt32[] zz, int zzOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWordsAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
    public static void Zero(UInt32[] z);
}
internal static class Org.BouncyCastle.Math.Raw.Nat160 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt32[] Create();
    public static UInt32[] CreateExt();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsZero(UInt32[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordAddExt(UInt32 x, UInt32[] yy, int yyOff, UInt32[] zz, int zzOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWordsAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static void Zero(UInt32[] z);
}
internal static class Org.BouncyCastle.Math.Raw.Nat192 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt32[] Create();
    public static UInt64[] Create64();
    public static UInt32[] CreateExt();
    public static UInt64[] CreateExt64();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero(UInt32[] x);
    public static bool IsZero64(UInt64[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordAddExt(UInt32 x, UInt32[] yy, int yyOff, UInt32[] zz, int zzOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
    public static void Zero(UInt32[] z);
}
internal static class Org.BouncyCastle.Math.Raw.Nat224 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 Add(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z, UInt32 cIn);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt32[] Create();
    public static UInt32[] CreateExt();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsZero(UInt32[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulByWord(UInt32 x, UInt32[] z);
    public static UInt32 MulByWordAddTo(UInt32 x, UInt32[] y, UInt32[] z);
    public static UInt32 MulWordAddTo(UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static void Zero(UInt32[] z);
}
internal static class Org.BouncyCastle.Math.Raw.Nat256 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 Add(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z, UInt32 cIn);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt32[] Create();
    public static UInt64[] Create64();
    public static UInt32[] CreateExt();
    public static UInt64[] CreateExt64();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero(UInt32[] x);
    public static bool IsZero64(UInt64[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static void Mul128(UInt32[] x, UInt32[] y128, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulByWord(UInt32 x, UInt32[] z);
    public static UInt32 MulByWordAddTo(UInt32 x, UInt32[] y, UInt32[] z);
    public static UInt32 MulWordAddTo(UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z, int cIn);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff, int cIn);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
    public static void Xor(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static void Zero(UInt32[] z);
}
internal static class Org.BouncyCastle.Math.Raw.Nat320 : object {
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt64[] Create64();
    public static UInt64[] CreateExt64();
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero64(UInt64[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
}
internal static class Org.BouncyCastle.Math.Raw.Nat384 : object {
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Square(UInt32[] x, UInt32[] zz);
}
internal static class Org.BouncyCastle.Math.Raw.Nat448 : object {
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt64[] Create64();
    public static UInt64[] CreateExt64();
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero64(UInt64[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static BigInteger ToBigInteger64(UInt64[] x);
}
internal static class Org.BouncyCastle.Math.Raw.Nat512 : object {
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Xor(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static void XorTo(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void Xor64(UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] z, int zOff);
    public static void XorTo64(UInt64[] x, int xOff, UInt64[] z, int zOff);
}
internal static class Org.BouncyCastle.Math.Raw.Nat576 : object {
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt64[] Create64();
    public static UInt64[] CreateExt64();
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero64(UInt64[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
}
public class Org.BouncyCastle.Ocsp.BasicOcspResp : X509ExtensionBase {
    private BasicOcspResponse resp;
    private ResponseData data;
    public int Version { get; }
    public RespID ResponderId { get; }
    public DateTime ProducedAt { get; }
    public SingleResp[] Responses { get; }
    public X509Extensions ResponseExtensions { get; }
    public string SignatureAlgName { get; }
    public string SignatureAlgOid { get; }
    public BasicOcspResp(BasicOcspResponse resp);
    public Byte[] GetTbsResponseData();
    public int get_Version();
    public RespID get_ResponderId();
    public DateTime get_ProducedAt();
    public SingleResp[] get_Responses();
    public X509Extensions get_ResponseExtensions();
    protected virtual X509Extensions GetX509Extensions();
    public string get_SignatureAlgName();
    public string get_SignatureAlgOid();
    public Byte[] GetSignature();
    private List`1<X509Certificate> GetCertList();
    public X509Certificate[] GetCerts();
    public IStore`1<X509Certificate> GetCertificates();
    public bool Verify(AsymmetricKeyParameter publicKey);
    public Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.BasicOcspRespGenerator : object {
    private List`1<ResponseObject> list;
    private X509Extensions responseExtensions;
    private RespID responderID;
    public IEnumerable`1<string> SignatureAlgNames { get; }
    public BasicOcspRespGenerator(RespID responderID);
    public BasicOcspRespGenerator(AsymmetricKeyParameter publicKey);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, X509Extensions singleExtensions);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, Nullable`1<DateTime> nextUpdate, X509Extensions singleExtensions);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, DateTime thisUpdate, Nullable`1<DateTime> nextUpdate, X509Extensions singleExtensions);
    public void SetResponseExtensions(X509Extensions responseExtensions);
    private BasicOcspResp GenerateResponse(ISignatureFactory signatureFactory, X509Certificate[] chain, DateTime producedAt);
    public BasicOcspResp Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime thisUpdate);
    public BasicOcspResp Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime producedAt, SecureRandom random);
    public BasicOcspResp Generate(ISignatureFactory signatureCalculatorFactory, X509Certificate[] chain, DateTime producedAt);
    public IEnumerable`1<string> get_SignatureAlgNames();
}
public class Org.BouncyCastle.Ocsp.CertificateID : object {
    public static string HashSha1;
    private CertID id;
    public string HashAlgOid { get; }
    public BigInteger SerialNumber { get; }
    public CertificateID(CertID id);
    public CertificateID(string hashAlgorithm, X509Certificate issuerCert, BigInteger serialNumber);
    public string get_HashAlgOid();
    public Byte[] GetIssuerNameHash();
    public Byte[] GetIssuerKeyHash();
    public BigInteger get_SerialNumber();
    public bool MatchesIssuer(X509Certificate issuerCert);
    public CertID ToAsn1Object();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static CertificateID DeriveCertificateID(CertificateID original, BigInteger newSerialNumber);
    private static CertID CreateCertID(AlgorithmIdentifier hashAlg, X509Certificate issuerCert, DerInteger serialNumber);
}
public abstract class Org.BouncyCastle.Ocsp.CertificateStatus : object {
    public static CertificateStatus Good;
}
public class Org.BouncyCastle.Ocsp.OcspException : Exception {
    public OcspException(string message);
    public OcspException(string message, Exception innerException);
    protected OcspException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Ocsp.OcspReq : X509ExtensionBase {
    private OcspRequest req;
    public int Version { get; }
    public GeneralName RequestorName { get; }
    public X509Extensions RequestExtensions { get; }
    public string SignatureAlgOid { get; }
    public bool IsSigned { get; }
    public OcspReq(OcspRequest req);
    public OcspReq(Byte[] req);
    public OcspReq(Stream inStr);
    private OcspReq(Asn1InputStream aIn);
    public Byte[] GetTbsRequest();
    public int get_Version();
    public GeneralName get_RequestorName();
    public Req[] GetRequestList();
    public X509Extensions get_RequestExtensions();
    protected virtual X509Extensions GetX509Extensions();
    public string get_SignatureAlgOid();
    public Byte[] GetSignature();
    private List`1<X509Certificate> GetCertList();
    public X509Certificate[] GetCerts();
    public IStore`1<X509Certificate> GetCertificates();
    public bool get_IsSigned();
    public bool Verify(AsymmetricKeyParameter publicKey);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Ocsp.OcspReqGenerator : object {
    private List`1<RequestObject> list;
    private GeneralName requestorName;
    private X509Extensions requestExtensions;
    public IEnumerable`1<string> SignatureAlgNames { get; }
    public void AddRequest(CertificateID certId);
    public void AddRequest(CertificateID certId, X509Extensions singleRequestExtensions);
    public void SetRequestorName(X509Name requestorName);
    public void SetRequestorName(GeneralName requestorName);
    public void SetRequestExtensions(X509Extensions requestExtensions);
    private OcspReq GenerateRequest(DerObjectIdentifier signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, SecureRandom random);
    public OcspReq Generate();
    public OcspReq Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain);
    public OcspReq Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, SecureRandom random);
    public IEnumerable`1<string> get_SignatureAlgNames();
}
public class Org.BouncyCastle.Ocsp.OcspResp : object {
    private OcspResponse resp;
    public int Status { get; }
    public OcspResp(OcspResponse resp);
    public OcspResp(Byte[] resp);
    public OcspResp(Stream inStr);
    private OcspResp(Asn1InputStream aIn);
    public int get_Status();
    public object GetResponseObject();
    public Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.OCSPRespGenerator : object {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SigRequired;
    public static int Unauthorized;
    public OcspResp Generate(int status, object response);
}
public abstract class Org.BouncyCastle.Ocsp.OcspRespStatus : object {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SigRequired;
    public static int Unauthorized;
}
internal class Org.BouncyCastle.Ocsp.OcspUtilities : object {
    private static Dictionary`2<string, DerObjectIdentifier> Algorithms;
    private static Dictionary`2<DerObjectIdentifier, string> Oids;
    private static HashSet`1<DerObjectIdentifier> NoParams;
    internal static IEnumerable`1<string> AlgNames { get; }
    private static OcspUtilities();
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static string GetAlgorithmName(DerObjectIdentifier oid);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid);
    internal static IEnumerable`1<string> get_AlgNames();
}
public class Org.BouncyCastle.Ocsp.Req : X509ExtensionBase {
    private Request req;
    public X509Extensions SingleRequestExtensions { get; }
    public Req(Request req);
    public CertificateID GetCertID();
    public X509Extensions get_SingleRequestExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.RespData : X509ExtensionBase {
    internal ResponseData data;
    public int Version { get; }
    public DateTime ProducedAt { get; }
    public X509Extensions ResponseExtensions { get; }
    public RespData(ResponseData data);
    public int get_Version();
    public RespID GetResponderId();
    public DateTime get_ProducedAt();
    public SingleResp[] GetResponses();
    public X509Extensions get_ResponseExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.RespID : object {
    internal ResponderID id;
    public RespID(ResponderID id);
    public RespID(X509Name name);
    public RespID(AsymmetricKeyParameter publicKey);
    public ResponderID ToAsn1Object();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.RevokedStatus : CertificateStatus {
    private RevokedInfo m_revokedInfo;
    public DateTime RevocationTime { get; }
    public bool HasRevocationReason { get; }
    public int RevocationReason { get; }
    public RevokedStatus(RevokedInfo revokedInfo);
    public RevokedStatus(DateTime revocationDate);
    public RevokedStatus(DateTime revocationDate, int reason);
    public DateTime get_RevocationTime();
    public bool get_HasRevocationReason();
    public int get_RevocationReason();
}
public class Org.BouncyCastle.Ocsp.SingleResp : X509ExtensionBase {
    internal SingleResponse resp;
    public DateTime ThisUpdate { get; }
    public Nullable`1<DateTime> NextUpdate { get; }
    public X509Extensions SingleExtensions { get; }
    public SingleResp(SingleResponse resp);
    public CertificateID GetCertID();
    public object GetCertStatus();
    public DateTime get_ThisUpdate();
    public Nullable`1<DateTime> get_NextUpdate();
    public X509Extensions get_SingleExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.UnknownStatus : CertificateStatus {
}
public interface Org.BouncyCastle.OpenSsl.IPasswordFinder {
    public abstract virtual Char[] GetPassword();
}
public class Org.BouncyCastle.OpenSsl.MiscPemGenerator : object {
    private object obj;
    private string algorithm;
    private Char[] password;
    private SecureRandom random;
    public MiscPemGenerator(object obj);
    public MiscPemGenerator(object obj, string algorithm, Char[] password, SecureRandom random);
    private static PemObject CreatePemObject(object obj);
    private static PemObject CreatePemObject(object obj, string algorithm, Char[] password, SecureRandom random);
    public sealed virtual PemObject Generate();
    private static Byte[] EncodePrivateKey(AsymmetricKeyParameter akp, String& keyType);
    private static Byte[] EncodePrivateKeyInfo(PrivateKeyInfo info, String& keyType);
    private static Byte[] EncodePublicKey(AsymmetricKeyParameter akp, String& keyType);
    private static Byte[] EncodePublicKeyInfo(SubjectPublicKeyInfo info, String& keyType);
}
public class Org.BouncyCastle.OpenSsl.PemException : IOException {
    public PemException(string message);
    public PemException(string message, Exception innerException);
    protected PemException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.OpenSsl.PemReader : PemReader {
    private IPasswordFinder pFinder;
    private static PemReader();
    public PemReader(TextReader reader);
    public PemReader(TextReader reader, IPasswordFinder pFinder);
    public object ReadObject();
    private AsymmetricKeyParameter ReadRsaPublicKey(PemObject pemObject);
    private AsymmetricKeyParameter ReadPublicKey(PemObject pemObject);
    private X509Certificate ReadCertificate(PemObject pemObject);
    private X509Crl ReadCrl(PemObject pemObject);
    private Pkcs10CertificationRequest ReadCertificateRequest(PemObject pemObject);
    private X509V2AttributeCertificate ReadAttributeCertificate(PemObject pemObject);
    private ContentInfo ReadPkcs7(PemObject pemObject);
    private object ReadPrivateKey(PemObject pemObject);
}
internal class Org.BouncyCastle.OpenSsl.PemUtilities : object {
    private static PemUtilities();
    private static void ParseDekAlgName(string dekAlgName, PemBaseAlg& baseAlg, PemMode& mode);
    internal static Byte[] Crypt(bool encrypt, Byte[] bytes, Char[] password, string dekAlgName, Byte[] iv);
    private static ICipherParameters GetCipherParameters(Char[] password, PemBaseAlg baseAlg, Byte[] salt);
}
public class Org.BouncyCastle.OpenSsl.PemWriter : PemWriter {
    public PemWriter(TextWriter writer);
    public void WriteObject(object obj);
    public void WriteObject(object obj, string algorithm, Char[] password, SecureRandom random);
}
public class Org.BouncyCastle.OpenSsl.Pkcs8Generator : object {
    public static string PbeSha1_RC4_128;
    public static string PbeSha1_RC4_40;
    public static string PbeSha1_3DES;
    public static string PbeSha1_2DES;
    public static string PbeSha1_RC2_128;
    public static string PbeSha1_RC2_40;
    private Char[] password;
    private string algorithm;
    private int iterationCount;
    private AsymmetricKeyParameter privKey;
    private SecureRandom random;
    unknown SecureRandom SecureRandom {public set; }
    unknown Char[] Password {public set; }
    unknown int IterationCount {public set; }
    public Pkcs8Generator(AsymmetricKeyParameter privKey);
    public Pkcs8Generator(AsymmetricKeyParameter privKey, string algorithm);
    private static Pkcs8Generator();
    public void set_SecureRandom(SecureRandom value);
    public void set_Password(Char[] value);
    public void set_IterationCount(int value);
    public sealed virtual PemObject Generate();
}
public class Org.BouncyCastle.Operators.CmsContentEncryptorBuilder : object {
    private static IDictionary`2<DerObjectIdentifier, int> KeySizes;
    private DerObjectIdentifier encryptionOID;
    private int keySize;
    private EnvelopedDataHelper helper;
    private static CmsContentEncryptorBuilder();
    public CmsContentEncryptorBuilder(DerObjectIdentifier encryptionOID);
    public CmsContentEncryptorBuilder(DerObjectIdentifier encryptionOID, int keySize);
    private static int GetKeySize(DerObjectIdentifier oid);
    public ICipherBuilderWithKey Build();
}
public class Org.BouncyCastle.Operators.CmsKeyTransRecipientInfoGenerator : KeyTransRecipientInfoGenerator {
    public CmsKeyTransRecipientInfoGenerator(X509Certificate recipCert, IKeyWrapper keyWrapper);
    public CmsKeyTransRecipientInfoGenerator(IssuerAndSerialNumber issuerAndSerial, IKeyWrapper keyWrapper);
    public CmsKeyTransRecipientInfoGenerator(Byte[] subjectKeyID, IKeyWrapper keyWrapper);
}
public class Org.BouncyCastle.Pkcs.AsymmetricKeyEntry : Pkcs12Entry {
    private AsymmetricKeyParameter key;
    public AsymmetricKeyParameter Key { get; }
    public AsymmetricKeyEntry(AsymmetricKeyParameter key);
    public AsymmetricKeyEntry(AsymmetricKeyParameter key, IDictionary`2<DerObjectIdentifier, Asn1Encodable> attributes);
    public AsymmetricKeyParameter get_Key();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Pkcs.EncryptedPrivateKeyInfoFactory : object {
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(DerObjectIdentifier algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, PrivateKeyInfo keyInfo);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(DerObjectIdentifier cipherAlgorithm, DerObjectIdentifier prfAlgorithm, Char[] passPhrase, Byte[] salt, int iterationCount, SecureRandom random, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(DerObjectIdentifier cipherAlgorithm, DerObjectIdentifier prfAlgorithm, Char[] passPhrase, Byte[] salt, int iterationCount, SecureRandom random, PrivateKeyInfo keyInfo);
}
public class Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest : CertificationRequest {
    internal static Dictionary`2<string, DerObjectIdentifier> m_algorithms;
    internal static Dictionary`2<string, Asn1Encodable> m_exParams;
    internal static Dictionary`2<DerObjectIdentifier, string> m_keyAlgorithms;
    internal static Dictionary`2<DerObjectIdentifier, string> m_oids;
    internal static HashSet`1<DerObjectIdentifier> m_noParams;
    private static Pkcs10CertificationRequest();
    public Pkcs10CertificationRequest(Byte[] encoded);
    public Pkcs10CertificationRequest(Asn1Sequence seq);
    public Pkcs10CertificationRequest(Stream input);
    public Pkcs10CertificationRequest(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes, AsymmetricKeyParameter signingKey);
    public Pkcs10CertificationRequest(ISignatureFactory signatureFactory, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes);
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    private void Init(ISignatureFactory signatureFactory, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes);
    public AsymmetricKeyParameter GetPublicKey();
    public bool Verify();
    public bool Verify(AsymmetricKeyParameter publicKey);
    public bool Verify(IVerifierFactoryProvider verifierProvider);
    public bool Verify(IVerifierFactory verifier);
    private void SetSignatureParameters(ISigner signature, Asn1Encodable asn1Params);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
    public X509Extensions GetRequestedExtensions();
}
public class Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned : Pkcs10CertificationRequest {
    public Pkcs10CertificationRequestDelaySigned(Byte[] encoded);
    public Pkcs10CertificationRequestDelaySigned(Asn1Sequence seq);
    public Pkcs10CertificationRequestDelaySigned(Stream input);
    public Pkcs10CertificationRequestDelaySigned(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes, AsymmetricKeyParameter signingKey);
    public Pkcs10CertificationRequestDelaySigned(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes);
    public Byte[] GetDataToSign();
    public void SignRequest(Byte[] signedData);
    public void SignRequest(DerBitString signedData);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Pkcs.Pkcs12Entry : object {
    private IDictionary`2<DerObjectIdentifier, Asn1Encodable> m_attributes;
    public Asn1Encodable Item { get; }
    public IEnumerable`1<DerObjectIdentifier> BagAttributeKeys { get; }
    protected internal Pkcs12Entry(IDictionary`2<DerObjectIdentifier, Asn1Encodable> attributes);
    public Asn1Encodable get_Item(DerObjectIdentifier oid);
    public IEnumerable`1<DerObjectIdentifier> get_BagAttributeKeys();
}
public class Org.BouncyCastle.Pkcs.Pkcs12Store : object {
    public static string IgnoreUselessPasswordProperty;
    private Dictionary`2<string, AsymmetricKeyEntry> m_keys;
    private Dictionary`2<string, string> m_localIds;
    private Dictionary`2<string, X509CertificateEntry> m_certs;
    private Dictionary`2<CertId, X509CertificateEntry> m_chainCerts;
    private Dictionary`2<string, X509CertificateEntry> m_keyCerts;
    private DerObjectIdentifier keyAlgorithm;
    private DerObjectIdentifier keyPrfAlgorithm;
    private DerObjectIdentifier certAlgorithm;
    private bool useDerEncoding;
    private AsymmetricKeyEntry unmarkedKeyEntry;
    private static int MinIterations;
    private static int SaltSize;
    public IEnumerable`1<string> Aliases { get; }
    public int Count { get; }
    internal Pkcs12Store(DerObjectIdentifier keyAlgorithm, DerObjectIdentifier keyPrfAlgorithm, DerObjectIdentifier certAlgorithm, bool useDerEncoding);
    private static SubjectKeyIdentifier CreateSubjectKeyID(AsymmetricKeyParameter pubKey);
    protected virtual void LoadKeyBag(PrivateKeyInfo privKeyInfo, Asn1Set bagAttributes);
    protected virtual void LoadPkcs8ShroudedKeyBag(EncryptedPrivateKeyInfo encPrivKeyInfo, Asn1Set bagAttributes, Char[] password, bool wrongPkcs12Zero);
    public void Load(Stream input, Char[] password);
    public AsymmetricKeyEntry GetKey(string alias);
    public bool IsCertificateEntry(string alias);
    public bool IsKeyEntry(string alias);
    public IEnumerable`1<string> get_Aliases();
    public bool ContainsAlias(string alias);
    public X509CertificateEntry GetCertificate(string alias);
    public string GetCertificateAlias(X509Certificate cert);
    public X509CertificateEntry[] GetCertificateChain(string alias);
    public void SetCertificateEntry(string alias, X509CertificateEntry certEntry);
    public void SetKeyEntry(string alias, AsymmetricKeyEntry keyEntry, X509CertificateEntry[] chain);
    public void DeleteEntry(string alias);
    public bool IsEntryOfType(string alias, Type entryType);
    public int get_Count();
    public void Save(Stream stream, Char[] password, SecureRandom random);
    internal static Byte[] CalculatePbeMac(DerObjectIdentifier oid, Byte[] salt, int itCount, Char[] password, bool wrongPkcs12Zero, Byte[] data);
    private static Byte[] CryptPbeData(bool forEncryption, AlgorithmIdentifier algId, Char[] password, bool wrongPkcs12Zero, Byte[] data);
}
public class Org.BouncyCastle.Pkcs.Pkcs12StoreBuilder : object {
    private DerObjectIdentifier keyAlgorithm;
    private DerObjectIdentifier certAlgorithm;
    private DerObjectIdentifier keyPrfAlgorithm;
    private bool useDerEncoding;
    public Pkcs12Store Build();
    public Pkcs12StoreBuilder SetCertAlgorithm(DerObjectIdentifier certAlgorithm);
    public Pkcs12StoreBuilder SetKeyAlgorithm(DerObjectIdentifier keyAlgorithm);
    public Pkcs12StoreBuilder SetKeyAlgorithm(DerObjectIdentifier keyAlgorithm, DerObjectIdentifier keyPrfAlgorithm);
    public Pkcs12StoreBuilder SetUseDerEncoding(bool useDerEncoding);
}
public class Org.BouncyCastle.Pkcs.Pkcs12Utilities : object {
    public static Byte[] ConvertToDefiniteLength(Byte[] berPkcs12File);
    public static Byte[] ConvertToDefiniteLength(Byte[] berPkcs12File, Char[] passwd);
}
public class Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo : object {
    private EncryptedPrivateKeyInfo encryptedPrivateKeyInfo;
    public Pkcs8EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo encryptedPrivateKeyInfo);
    public Pkcs8EncryptedPrivateKeyInfo(Byte[] encryptedPrivateKeyInfo);
    private static EncryptedPrivateKeyInfo parseBytes(Byte[] pkcs8Encoding);
    public EncryptedPrivateKeyInfo ToAsn1Structure();
    public Byte[] GetEncryptedData();
    public Byte[] GetEncoded();
    public PrivateKeyInfo DecryptPrivateKeyInfo(IDecryptorBuilderProvider inputDecryptorProvider);
}
public class Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfoBuilder : object {
    private PrivateKeyInfo privateKeyInfo;
    public Pkcs8EncryptedPrivateKeyInfoBuilder(Byte[] privateKeyInfo);
    public Pkcs8EncryptedPrivateKeyInfoBuilder(PrivateKeyInfo privateKeyInfo);
    public Pkcs8EncryptedPrivateKeyInfo Build(ICipherBuilder encryptor);
}
public class Org.BouncyCastle.Pkcs.PkcsException : Exception {
    public PkcsException(string message);
    public PkcsException(string message, Exception innerException);
    protected PkcsException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Pkcs.PkcsIOException : IOException {
    public PkcsIOException(string message);
    public PkcsIOException(string message, Exception innerException);
    protected PkcsIOException(SerializationInfo info, StreamingContext context);
}
public static class Org.BouncyCastle.Pkcs.PrivateKeyInfoFactory : object {
    public static PrivateKeyInfo CreatePrivateKeyInfo(AsymmetricKeyParameter privateKey);
    public static PrivateKeyInfo CreatePrivateKeyInfo(AsymmetricKeyParameter privateKey, Asn1Set attributes);
    public static PrivateKeyInfo CreatePrivateKeyInfo(Char[] passPhrase, EncryptedPrivateKeyInfo encInfo);
    public static PrivateKeyInfo CreatePrivateKeyInfo(Char[] passPhrase, bool wrongPkcs12Zero, EncryptedPrivateKeyInfo encInfo);
    private static void ExtractBytes(Byte[] encKey, int size, int offSet, BigInteger bI);
}
public class Org.BouncyCastle.Pkcs.X509CertificateEntry : Pkcs12Entry {
    private X509Certificate cert;
    public X509Certificate Certificate { get; }
    public X509CertificateEntry(X509Certificate cert);
    public X509CertificateEntry(X509Certificate cert, IDictionary`2<DerObjectIdentifier, Asn1Encodable> attributes);
    public X509Certificate get_Certificate();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Pkix.CertStatus : object {
    public static int Unrevoked;
    public static int Undetermined;
    private int status;
    private Nullable`1<DateTime> revocationDate;
    public Nullable`1<DateTime> RevocationDate { get; public set; }
    public int Status { get; public set; }
    public Nullable`1<DateTime> get_RevocationDate();
    public void set_RevocationDate(Nullable`1<DateTime> value);
    public int get_Status();
    public void set_Status(int value);
}
public abstract class Org.BouncyCastle.Pkix.PkixAttrCertChecker : object {
    public abstract virtual ISet`1<DerObjectIdentifier> GetSupportedExtensions();
    public abstract virtual void Check(X509V2AttributeCertificate attrCert, PkixCertPath certPath, PkixCertPath holderCertPath, ICollection`1<string> unresolvedCritExts);
    public abstract virtual PkixAttrCertChecker Clone();
}
public class Org.BouncyCastle.Pkix.PkixAttrCertPathBuilder : object {
    private Exception certPathException;
    public virtual PkixCertPathBuilderResult Build(PkixBuilderParameters pkixParams);
    private PkixCertPathBuilderResult Build(X509V2AttributeCertificate attrCert, X509Certificate tbvCert, PkixBuilderParameters pkixParams, IList`1<X509Certificate> tbvPath);
    internal static HashSet`1<X509V2AttributeCertificate> FindAttributeCertificates(ISelector`1<X509V2AttributeCertificate> attrCertSelector, IList`1<IStore`1<X509V2AttributeCertificate>> attrCertStores);
}
public class Org.BouncyCastle.Pkix.PkixAttrCertPathValidator : object {
    public virtual PkixCertPathValidatorResult Validate(PkixCertPath certPath, PkixParameters pkixParams);
}
public class Org.BouncyCastle.Pkix.PkixBuilderParameters : PkixParameters {
    private int maxPathLength;
    private HashSet`1<X509Certificate> excludedCerts;
    public int MaxPathLength { get; public set; }
    public PkixBuilderParameters(ISet`1<TrustAnchor> trustAnchors, ISelector`1<X509Certificate> targetConstraintsCert);
    public PkixBuilderParameters(ISet`1<TrustAnchor> trustAnchors, ISelector`1<X509Certificate> targetConstraintsCert, ISelector`1<X509V2AttributeCertificate> targetConstraintsAttrCert);
    public static PkixBuilderParameters GetInstance(PkixParameters pkixParams);
    public virtual int get_MaxPathLength();
    public virtual void set_MaxPathLength(int value);
    public virtual ISet`1<X509Certificate> GetExcludedCerts();
    public virtual void SetExcludedCerts(ISet`1<X509Certificate> excludedCerts);
    protected virtual void SetParams(PkixParameters parameters);
    public virtual object Clone();
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixCertPath : object {
    private static List`1<string> EncodingNames;
    private IList`1<X509Certificate> m_certificates;
    public IEnumerable`1<string> Encodings { get; }
    public IList`1<X509Certificate> Certificates { get; }
    public PkixCertPath(IList`1<X509Certificate> certificates);
    public PkixCertPath(Stream inStream);
    public PkixCertPath(Stream inStream, string encoding);
    private static PkixCertPath();
    private static IList`1<X509Certificate> SortCerts(IList`1<X509Certificate> certs);
    public virtual IEnumerable`1<string> get_Encodings();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Byte[] GetEncoded();
    public virtual Byte[] GetEncoded(string encoding);
    public virtual IList`1<X509Certificate> get_Certificates();
    private Asn1Object ToAsn1Object(X509Certificate cert);
    private Byte[] ToDerEncoded(Asn1Encodable obj);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilder : object {
    private Exception certPathException;
    public virtual PkixCertPathBuilderResult Build(PkixBuilderParameters pkixParams);
    protected virtual PkixCertPathBuilderResult Build(X509Certificate tbvCert, PkixBuilderParameters pkixParams, IList`1<X509Certificate> tbvPath);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilderException : GeneralSecurityException {
    public PkixCertPathBuilderException(string message);
    public PkixCertPathBuilderException(string message, Exception innerException);
    protected PkixCertPathBuilderException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilderResult : PkixCertPathValidatorResult {
    private PkixCertPath certPath;
    public PkixCertPath CertPath { get; }
    public PkixCertPathBuilderResult(PkixCertPath certPath, TrustAnchor trustAnchor, PkixPolicyNode policyTree, AsymmetricKeyParameter subjectPublicKey);
    public PkixCertPath get_CertPath();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Pkix.PkixCertPathChecker : object {
    public abstract virtual void Init(bool forward);
    public abstract virtual bool IsForwardCheckingSupported();
    public abstract virtual ISet`1<string> GetSupportedExtensions();
    public abstract virtual void Check(X509Certificate cert, ISet`1<string> unresolvedCritExts);
    public virtual object Clone();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidator : object {
    public virtual PkixCertPathValidatorResult Validate(PkixCertPath certPath, PkixParameters paramsPkix);
    internal static void CheckCertificate(X509Certificate cert);
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorException : GeneralSecurityException {
    protected int m_index;
    public int Index { get; }
    public PkixCertPathValidatorException(string message);
    public PkixCertPathValidatorException(string message, Exception innerException);
    public PkixCertPathValidatorException(string message, Exception innerException, int index);
    protected PkixCertPathValidatorException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public int get_Index();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorResult : object {
    private TrustAnchor trustAnchor;
    private PkixPolicyNode policyTree;
    private AsymmetricKeyParameter subjectPublicKey;
    public PkixPolicyNode PolicyTree { get; }
    public TrustAnchor TrustAnchor { get; }
    public AsymmetricKeyParameter SubjectPublicKey { get; }
    public PkixCertPathValidatorResult(TrustAnchor trustAnchor, PkixPolicyNode policyTree, AsymmetricKeyParameter subjectPublicKey);
    public PkixPolicyNode get_PolicyTree();
    public TrustAnchor get_TrustAnchor();
    public AsymmetricKeyParameter get_SubjectPublicKey();
    public object Clone();
    public virtual string ToString();
}
internal static class Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities : object {
    private static PkixCrlUtilities CrlUtilities;
    internal static string ANY_POLICY;
    internal static string CRL_NUMBER;
    internal static int KEY_CERT_SIGN;
    internal static int CRL_SIGN;
    private static PkixCertPathValidatorUtilities();
    internal static TrustAnchor FindTrustAnchor(X509Certificate cert, ISet`1<TrustAnchor> trustAnchors);
    internal static bool IsIssuerTrustAnchor(X509Certificate cert, ISet`1<TrustAnchor> trustAnchors);
    internal static void AddAdditionalStoresFromAltNames(X509Certificate cert, PkixParameters pkixParams);
    internal static DateTime GetValidDate(PkixParameters paramsPKIX);
    internal static X509Name GetIssuerPrincipal(object obj);
    internal static X509Name GetIssuerPrincipal(X509V2AttributeCertificate attrCert);
    internal static X509Name GetIssuerPrincipal(X509Certificate cert);
    internal static bool IsSelfIssued(X509Certificate cert);
    internal static AlgorithmIdentifier GetAlgorithmIdentifier(AsymmetricKeyParameter key);
    internal static bool IsAnyPolicy(ISet`1<string> policySet);
    internal static void AddAdditionalStoreFromLocation(string location, PkixParameters pkixParams);
    private static BigInteger GetSerialNumber(object cert);
    internal static HashSet`1<PolicyQualifierInfo> GetQualifierSet(Asn1Sequence qualifiers);
    internal static PkixPolicyNode RemovePolicyNode(PkixPolicyNode validPolicyTree, IList`1[] policyNodes, PkixPolicyNode _node);
    private static void RemovePolicyNodeRecurse(IList`1[] policyNodes, PkixPolicyNode _node);
    internal static void PrepareNextCertB1(int i, IList`1[] policyNodes, string id_p, IDictionary`2<string, HashSet`1<string>> m_idp, X509Certificate cert);
    internal static PkixPolicyNode PrepareNextCertB2(int i, IList`1[] policyNodes, string id_p, PkixPolicyNode validPolicyTree);
    internal static void GetCertStatus(DateTime validDate, X509Crl crl, object cert, CertStatus certStatus);
    internal static AsymmetricKeyParameter GetNextWorkingKey(IList`1<X509Certificate> certs, int index);
    internal static DateTime GetValidCertDateFromValidityModel(PkixParameters paramsPkix, PkixCertPath certPath, int index);
    internal static void GetCrlIssuersFromDistributionPoint(DistributionPoint dp, ICollection`1<X509Name> issuerPrincipals, X509CrlStoreSelector selector, PkixParameters pkixParameters);
    internal static ISet`1<X509Crl> GetCompleteCrls(DistributionPoint dp, object certObj, DateTime currentDate, PkixParameters pkixParameters);
    internal static HashSet`1<X509Crl> GetDeltaCrls(DateTime currentDate, PkixParameters pkixParameters, X509Crl completeCRL);
    private static bool IsDeltaCrl(X509Crl crl);
    internal static void AddAdditionalStoresFromCrlDistributionPoint(CrlDistPoint crldp, PkixParameters pkixParams);
    internal static bool ProcessCertD1i(int index, IList`1[] policyNodes, DerObjectIdentifier pOid, HashSet`1<PolicyQualifierInfo> pq);
    internal static void ProcessCertD1ii(int index, IList`1[] policyNodes, DerObjectIdentifier _poid, HashSet`1<PolicyQualifierInfo> _pq);
    internal static HashSet`1<X509Certificate> FindIssuerCerts(X509Certificate cert, PkixBuilderParameters pkixBuilderParameters);
    internal static Asn1Object GetExtensionValue(IX509Extension extensions, DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Pkix.PkixCrlUtilities : object {
    public virtual ISet`1<X509Crl> FindCrls(X509CrlStoreSelector crlSelector, PkixParameters paramsPkix);
    public virtual ISet`1<X509Crl> FindCrls(X509CrlStoreSelector crlSelector, PkixParameters paramsPkix, DateTime currentDate);
    private HashSet`1<X509Crl> FindCrls(ISelector`1<X509Crl> crlSelector, IEnumerable`1<IStore`1<X509Crl>> crlStores);
}
public class Org.BouncyCastle.Pkix.PkixNameConstraintValidator : object {
    private static DerObjectIdentifier SerialNumberOid;
    private HashSet`1<Asn1Sequence> excludedSubtreesDN;
    private HashSet`1<string> excludedSubtreesDns;
    private HashSet`1<string> excludedSubtreesEmail;
    private HashSet`1<string> excludedSubtreesUri;
    private HashSet`1<Byte[]> excludedSubtreesIP;
    private HashSet`1<OtherName> excludedSubtreesOtherName;
    private HashSet`1<Asn1Sequence> permittedSubtreesDN;
    private HashSet`1<string> permittedSubtreesDns;
    private HashSet`1<string> permittedSubtreesEmail;
    private HashSet`1<string> permittedSubtreesUri;
    private HashSet`1<Byte[]> permittedSubtreesIP;
    private HashSet`1<OtherName> permittedSubtreesOtherName;
    private static PkixNameConstraintValidator();
    private static bool WithinDNSubtree(Asn1Sequence dns, Asn1Sequence subtree);
    public void CheckExcludedDN(Asn1Sequence dn);
    public void CheckPermittedDN(Asn1Sequence dn);
    private void CheckExcludedDN(HashSet`1<Asn1Sequence> excluded, Asn1Sequence directory);
    private void CheckPermittedDN(HashSet`1<Asn1Sequence> permitted, Asn1Sequence directory);
    private bool IsDNConstrained(HashSet`1<Asn1Sequence> constraints, Asn1Sequence directory);
    private HashSet`1<Asn1Sequence> IntersectDN(HashSet`1<Asn1Sequence> permitted, HashSet`1<GeneralSubtree> dns);
    private HashSet`1<Asn1Sequence> UnionDN(HashSet`1<Asn1Sequence> excluded, Asn1Sequence dn);
    private void CheckExcludedOtherName(HashSet`1<OtherName> excluded, OtherName name);
    private void CheckPermittedOtherName(HashSet`1<OtherName> permitted, OtherName name);
    private bool IsOtherNameConstrained(HashSet`1<OtherName> constraints, OtherName otherName);
    private bool IsOtherNameConstrained(OtherName constraint, OtherName otherName);
    private HashSet`1<OtherName> IntersectOtherName(HashSet`1<OtherName> permitted, HashSet`1<GeneralSubtree> otherNames);
    private void IntersectOtherName(OtherName otherName1, OtherName otherName2, HashSet`1<OtherName> intersect);
    private HashSet`1<OtherName> UnionOtherName(HashSet`1<OtherName> permitted, OtherName otherName);
    private void CheckExcludedEmail(HashSet`1<string> excluded, string email);
    private void CheckPermittedEmail(HashSet`1<string> permitted, string email);
    private bool IsEmailConstrained(HashSet`1<string> constraints, string email);
    private bool IsEmailConstrained(string constraint, string email);
    private HashSet`1<string> IntersectEmail(HashSet`1<string> permitted, HashSet`1<GeneralSubtree> emails);
    private void IntersectEmail(string email1, string email2, HashSet`1<string> intersect);
    private HashSet`1<string> UnionEmail(HashSet`1<string> excluded, string email);
    private void UnionEmail(string email1, string email2, HashSet`1<string> union);
    private void CheckExcludedIP(HashSet`1<Byte[]> excluded, Byte[] ip);
    private void CheckPermittedIP(HashSet`1<Byte[]> permitted, Byte[] ip);
    private bool IsIPConstrained(HashSet`1<Byte[]> constraints, Byte[] ip);
    private bool IsIPConstrained(Byte[] constraint, Byte[] ip);
    private HashSet`1<Byte[]> IntersectIP(HashSet`1<Byte[]> permitted, HashSet`1<GeneralSubtree> ips);
    private HashSet`1<Byte[]> IntersectIPRange(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private HashSet`1<Byte[]> UnionIP(HashSet`1<Byte[]> excluded, Byte[] ip);
    private HashSet`1<Byte[]> UnionIPRange(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private Byte[] IpWithSubnetMask(Byte[] ip, Byte[] subnetMask);
    private Byte[][] ExtractIPsAndSubnetMasks(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private Byte[][] MinMaxIPs(Byte[] ip1, Byte[] subnetmask1, Byte[] ip2, Byte[] subnetmask2);
    private static Byte[] Max(Byte[] ip1, Byte[] ip2);
    private static Byte[] Min(Byte[] ip1, Byte[] ip2);
    private static int CompareTo(Byte[] ip1, Byte[] ip2);
    private static Byte[] Or(Byte[] ip1, Byte[] ip2);
    private void CheckExcludedDns(HashSet`1<string> excluded, string dns);
    private void CheckPermittedDns(HashSet`1<string> permitted, string dns);
    private bool IsDnsConstrained(HashSet`1<string> constraints, string dns);
    private bool IsDnsConstrained(string constraint, string dns);
    private HashSet`1<string> IntersectDns(HashSet`1<string> permitted, HashSet`1<GeneralSubtree> dnss);
    private HashSet`1<string> UnionDns(HashSet`1<string> excluded, string dns);
    private void CheckExcludedUri(HashSet`1<string> excluded, string uri);
    private void CheckPermittedUri(HashSet`1<string> permitted, string uri);
    private bool IsUriConstrained(HashSet`1<string> constraints, string uri);
    private bool IsUriConstrained(string constraint, string uri);
    private HashSet`1<string> IntersectUri(HashSet`1<string> permitted, HashSet`1<GeneralSubtree> uris);
    private void IntersectUri(string email1, string email2, HashSet`1<string> intersect);
    private HashSet`1<string> UnionUri(HashSet`1<string> excluded, string uri);
    private void UnionUri(string email1, string email2, HashSet`1<string> union);
    private static string ExtractHostFromURL(string url);
    private bool WithinDomain(string testDomain, string domain);
    [ObsoleteAttribute("Use 'CheckPermittedName' instead")]
public void checkPermitted(GeneralName name);
    public void CheckPermittedName(GeneralName name);
    [ObsoleteAttribute("Use 'CheckExcludedName' instead")]
public void checkExcluded(GeneralName name);
    public void CheckExcludedName(GeneralName name);
    public void IntersectPermittedSubtree(Asn1Sequence permitted);
    private string ExtractNameAsString(GeneralName name);
    public void IntersectEmptyPermittedSubtree(int nameType);
    public void AddExcludedSubtree(GeneralSubtree subtree);
    public virtual int GetHashCode();
    private int HashCollection(HashSet`1<Byte[]> c);
    private int HashCollection(HashSet`1<T> c);
    public virtual bool Equals(object o);
    private bool AreEqualSets(HashSet`1<Byte[]> set1, HashSet`1<Byte[]> set2);
    private bool AreEqualSets(HashSet`1<T> set1, HashSet`1<T> set2);
    private string StringifyIP(Byte[] ip);
    private string StringifyIPCollection(HashSet`1<Byte[]> ips);
    private string StringifyOtherNameCollection(HashSet`1<OtherName> otherNames);
    public virtual string ToString();
    private static void Append(StringBuilder sb, string name, object value);
}
public class Org.BouncyCastle.Pkix.PkixNameConstraintValidatorException : Exception {
    public PkixNameConstraintValidatorException(string message);
    public PkixNameConstraintValidatorException(string message, Exception innerException);
    protected PkixNameConstraintValidatorException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Pkix.PkixParameters : object {
    public static int PkixValidityModel;
    public static int ChainValidityModel;
    private HashSet`1<TrustAnchor> trustAnchors;
    private Nullable`1<DateTime> date;
    private List`1<PkixCertPathChecker> m_checkers;
    private bool revocationEnabled;
    private HashSet`1<string> initialPolicies;
    private bool explicitPolicyRequired;
    private bool anyPolicyInhibited;
    private bool policyMappingInhibited;
    private bool policyQualifiersRejected;
    private List`1<IStore`1<X509V2AttributeCertificate>> m_storesAttrCert;
    private List`1<IStore`1<X509Certificate>> m_storesCert;
    private List`1<IStore`1<X509Crl>> m_storesCrl;
    private ISelector`1<X509V2AttributeCertificate> m_targetConstraintsAttrCert;
    private ISelector`1<X509Certificate> m_targetConstraintsCert;
    private bool additionalLocationsEnabled;
    private ISet`1<TrustAnchor> trustedACIssuers;
    private ISet`1<string> necessaryACAttributes;
    private ISet`1<string> prohibitedACAttributes;
    private ISet`1<PkixAttrCertChecker> attrCertCheckers;
    private int validityModel;
    private bool useDeltas;
    public bool IsRevocationEnabled { get; public set; }
    public bool IsExplicitPolicyRequired { get; public set; }
    public bool IsAnyPolicyInhibited { get; public set; }
    public bool IsPolicyMappingInhibited { get; public set; }
    public bool IsPolicyQualifiersRejected { get; public set; }
    public Nullable`1<DateTime> Date { get; public set; }
    public bool IsUseDeltasEnabled { get; public set; }
    public int ValidityModel { get; public set; }
    public bool IsAdditionalLocationsEnabled { get; }
    public PkixParameters(ISet`1<TrustAnchor> trustAnchors);
    public virtual bool get_IsRevocationEnabled();
    public virtual void set_IsRevocationEnabled(bool value);
    public virtual bool get_IsExplicitPolicyRequired();
    public virtual void set_IsExplicitPolicyRequired(bool value);
    public virtual bool get_IsAnyPolicyInhibited();
    public virtual void set_IsAnyPolicyInhibited(bool value);
    public virtual bool get_IsPolicyMappingInhibited();
    public virtual void set_IsPolicyMappingInhibited(bool value);
    public virtual bool get_IsPolicyQualifiersRejected();
    public virtual void set_IsPolicyQualifiersRejected(bool value);
    public virtual Nullable`1<DateTime> get_Date();
    public virtual void set_Date(Nullable`1<DateTime> value);
    public virtual ISet`1<TrustAnchor> GetTrustAnchors();
    public virtual void SetTrustAnchors(ISet`1<TrustAnchor> tas);
    public virtual ISelector`1<X509V2AttributeCertificate> GetTargetConstraintsAttrCert();
    public virtual void SetTargetConstraintsAttrCert(ISelector`1<X509V2AttributeCertificate> targetConstraintsAttrCert);
    public virtual ISelector`1<X509Certificate> GetTargetConstraintsCert();
    public virtual void SetTargetConstraintsCert(ISelector`1<X509Certificate> targetConstraintsCert);
    public virtual ISet`1<string> GetInitialPolicies();
    public virtual void SetInitialPolicies(ISet`1<string> initialPolicies);
    public virtual void SetCertPathCheckers(IList`1<PkixCertPathChecker> checkers);
    public virtual IList`1<PkixCertPathChecker> GetCertPathCheckers();
    public virtual void AddCertPathChecker(PkixCertPathChecker checker);
    public virtual object Clone();
    protected virtual void SetParams(PkixParameters parameters);
    public virtual bool get_IsUseDeltasEnabled();
    public virtual void set_IsUseDeltasEnabled(bool value);
    public virtual int get_ValidityModel();
    public virtual void set_ValidityModel(int value);
    public virtual IList`1<IStore`1<X509V2AttributeCertificate>> GetStoresAttrCert();
    public virtual IList`1<IStore`1<X509Certificate>> GetStoresCert();
    public virtual IList`1<IStore`1<X509Crl>> GetStoresCrl();
    [ObsoleteAttribute("Use 'SetStoresAttrCert' instead")]
public virtual void SetAttrStoresCert(IList`1<IStore`1<X509V2AttributeCertificate>> storesAttrCert);
    public virtual void SetStoresAttrCert(IList`1<IStore`1<X509V2AttributeCertificate>> storesAttrCert);
    public virtual void SetStoresCert(IList`1<IStore`1<X509Certificate>> storesCert);
    public virtual void SetStoresCrl(IList`1<IStore`1<X509Crl>> storesCrl);
    public virtual void AddStoreAttrCert(IStore`1<X509V2AttributeCertificate> storeAttrCert);
    public virtual void AddStoreCert(IStore`1<X509Certificate> storeCert);
    public virtual void AddStoreCrl(IStore`1<X509Crl> storeCrl);
    public virtual bool get_IsAdditionalLocationsEnabled();
    public virtual void SetAdditionalLocationsEnabled(bool enabled);
    public virtual ISet`1<TrustAnchor> GetTrustedACIssuers();
    public virtual void SetTrustedACIssuers(ISet`1<TrustAnchor> trustedACIssuers);
    public virtual ISet`1<string> GetNecessaryACAttributes();
    public virtual void SetNecessaryACAttributes(ISet`1<string> necessaryACAttributes);
    public virtual ISet`1<string> GetProhibitedACAttributes();
    public virtual void SetProhibitedACAttributes(ISet`1<string> prohibitedACAttributes);
    public virtual ISet`1<PkixAttrCertChecker> GetAttrCertCheckers();
    public virtual void SetAttrCertCheckers(ISet`1<PkixAttrCertChecker> attrCertCheckers);
}
public class Org.BouncyCastle.Pkix.PkixPolicyNode : object {
    protected IList`1<PkixPolicyNode> mChildren;
    protected int mDepth;
    protected ISet`1<string> mExpectedPolicies;
    protected PkixPolicyNode mParent;
    protected ISet`1<PolicyQualifierInfo> mPolicyQualifiers;
    protected string mValidPolicy;
    protected bool mCritical;
    public int Depth { get; }
    public IEnumerable`1<PkixPolicyNode> Children { get; }
    public bool IsCritical { get; public set; }
    public ISet`1<PolicyQualifierInfo> PolicyQualifiers { get; }
    public string ValidPolicy { get; }
    public bool HasChildren { get; }
    public ISet`1<string> ExpectedPolicies { get; public set; }
    public PkixPolicyNode Parent { get; public set; }
    public PkixPolicyNode(IEnumerable`1<PkixPolicyNode> children, int depth, ISet`1<string> expectedPolicies, PkixPolicyNode parent, ISet`1<PolicyQualifierInfo> policyQualifiers, string validPolicy, bool critical);
    public virtual int get_Depth();
    public virtual IEnumerable`1<PkixPolicyNode> get_Children();
    public virtual bool get_IsCritical();
    public virtual void set_IsCritical(bool value);
    public virtual ISet`1<PolicyQualifierInfo> get_PolicyQualifiers();
    public virtual string get_ValidPolicy();
    public virtual bool get_HasChildren();
    public virtual ISet`1<string> get_ExpectedPolicies();
    public virtual void set_ExpectedPolicies(ISet`1<string> value);
    public virtual PkixPolicyNode get_Parent();
    public virtual void set_Parent(PkixPolicyNode value);
    public virtual void AddChild(PkixPolicyNode child);
    public virtual void RemoveChild(PkixPolicyNode child);
    public virtual string ToString();
    public virtual string ToString(string indent);
    public virtual object Clone();
    public virtual PkixPolicyNode Copy();
}
internal class Org.BouncyCastle.Pkix.ReasonsMask : object {
    private int _reasons;
    internal static ReasonsMask AllReasons;
    internal bool IsAllReasons { get; }
    public ReasonFlags Reasons { get; }
    internal ReasonsMask(int reasons);
    private static ReasonsMask();
    internal void AddReasons(ReasonsMask mask);
    internal bool get_IsAllReasons();
    internal ReasonsMask Intersect(ReasonsMask mask);
    internal bool HasNewReasons(ReasonsMask mask);
    public ReasonFlags get_Reasons();
}
internal static class Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities : object {
    private static PkixCrlUtilities CrlUtilities;
    internal static string ANY_POLICY;
    internal static int KEY_CERT_SIGN;
    internal static int CRL_SIGN;
    internal static String[] CrlReasons;
    private static Rfc3280CertPathUtilities();
    internal static void ProcessCrlB2(DistributionPoint dp, object cert, X509Crl crl);
    internal static void ProcessCertBC(PkixCertPath certPath, int index, PkixNameConstraintValidator nameConstraintValidator);
    internal static void PrepareNextCertA(PkixCertPath certPath, int index);
    internal static PkixPolicyNode ProcessCertD(PkixCertPath certPath, int index, HashSet`1<string> acceptablePolicies, PkixPolicyNode validPolicyTree, IList`1[] policyNodes, int inhibitAnyPolicy);
    internal static void ProcessCrlB1(DistributionPoint dp, object cert, X509Crl crl);
    internal static ReasonsMask ProcessCrlD(X509Crl crl, DistributionPoint dp);
    internal static HashSet`1<AsymmetricKeyParameter> ProcessCrlF(X509Crl crl, object cert, X509Certificate defaultCRLSignCert, AsymmetricKeyParameter defaultCRLSignKey, PkixParameters paramsPKIX, IList`1<X509Certificate> certPathCerts);
    internal static AsymmetricKeyParameter ProcessCrlG(X509Crl crl, HashSet`1<AsymmetricKeyParameter> keys);
    internal static X509Crl ProcessCrlH(HashSet`1<X509Crl> deltaCrls, AsymmetricKeyParameter key);
    private static void CheckCrl(DistributionPoint dp, PkixParameters paramsPKIX, X509Certificate cert, DateTime validDate, X509Certificate defaultCRLSignCert, AsymmetricKeyParameter defaultCRLSignKey, CertStatus certStatus, ReasonsMask reasonMask, IList`1<X509Certificate> certPathCerts);
    internal static void CheckCrls(PkixParameters paramsPKIX, X509Certificate cert, DateTime validDate, X509Certificate sign, AsymmetricKeyParameter workingPublicKey, IList`1<X509Certificate> certPathCerts);
    internal static PkixPolicyNode PrepareCertB(PkixCertPath certPath, int index, IList`1[] policyNodes, PkixPolicyNode validPolicyTree, int policyMapping);
    internal static ISet`1[] ProcessCrlA1ii(DateTime currentDate, PkixParameters paramsPKIX, X509Certificate cert, X509Crl crl);
    internal static ISet`1<X509Crl> ProcessCrlA1i(DateTime currentDate, PkixParameters paramsPKIX, X509Certificate cert, X509Crl crl);
    internal static void ProcessCertF(PkixCertPath certPath, int index, PkixPolicyNode validPolicyTree, int explicitPolicy);
    internal static void ProcessCertA(PkixCertPath certPath, PkixParameters paramsPKIX, int index, AsymmetricKeyParameter workingPublicKey, X509Name workingIssuerName, X509Certificate sign);
    internal static int PrepareNextCertI1(PkixCertPath certPath, int index, int explicitPolicy);
    internal static int PrepareNextCertI2(PkixCertPath certPath, int index, int policyMapping);
    internal static void PrepareNextCertG(PkixCertPath certPath, int index, PkixNameConstraintValidator nameConstraintValidator);
    internal static int PrepareNextCertJ(PkixCertPath certPath, int index, int inhibitAnyPolicy);
    internal static void PrepareNextCertK(PkixCertPath certPath, int index);
    internal static int PrepareNextCertL(PkixCertPath certPath, int index, int maxPathLength);
    internal static int PrepareNextCertM(PkixCertPath certPath, int index, int maxPathLength);
    internal static void PrepareNextCertN(PkixCertPath certPath, int index);
    internal static void PrepareNextCertO(PkixCertPath certPath, int index, ISet`1<string> criticalExtensions, IEnumerable`1<PkixCertPathChecker> checkers);
    internal static int PrepareNextCertH1(PkixCertPath certPath, int index, int explicitPolicy);
    internal static int PrepareNextCertH2(PkixCertPath certPath, int index, int policyMapping);
    internal static int PrepareNextCertH3(PkixCertPath certPath, int index, int inhibitAnyPolicy);
    internal static int WrapupCertA(int explicitPolicy, X509Certificate cert);
    internal static int WrapupCertB(PkixCertPath certPath, int index, int explicitPolicy);
    internal static void WrapupCertF(PkixCertPath certPath, int index, IEnumerable`1<PkixCertPathChecker> checkers, ISet`1<string> criticalExtensions);
    internal static PkixPolicyNode WrapupCertG(PkixCertPath certPath, PkixParameters paramsPKIX, ISet`1<string> userInitialPolicySet, int index, IList`1[] policyNodes, PkixPolicyNode validPolicyTree, HashSet`1<string> acceptablePolicies);
    internal static void ProcessCrlC(X509Crl deltaCRL, X509Crl completeCRL, PkixParameters pkixParams);
    internal static void ProcessCrlI(DateTime validDate, X509Crl deltacrl, object cert, CertStatus certStatus, PkixParameters pkixParams);
    internal static void ProcessCrlJ(DateTime validDate, X509Crl completecrl, object cert, CertStatus certStatus);
    internal static PkixPolicyNode ProcessCertE(PkixCertPath certPath, int index, PkixPolicyNode validPolicyTree);
}
internal static class Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities : object {
    internal static void ProcessAttrCert7(X509V2AttributeCertificate attrCert, PkixCertPath certPath, PkixCertPath holderCertPath, PkixParameters pkixParams);
    internal static void CheckCrls(X509V2AttributeCertificate attrCert, PkixParameters paramsPKIX, X509Certificate issuerCert, DateTime validDate, IList`1<X509Certificate> certPathCerts);
    internal static void AdditionalChecks(X509V2AttributeCertificate attrCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert5(X509V2AttributeCertificate attrCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert4(X509Certificate acIssuerCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert3(X509Certificate acIssuerCert, PkixParameters pkixParams);
    internal static PkixCertPathValidatorResult ProcessAttrCert2(PkixCertPath certPath, PkixParameters pkixParams);
    internal static PkixCertPath ProcessAttrCert1(X509V2AttributeCertificate attrCert, PkixParameters pkixParams);
    private static void CheckCrl(DistributionPoint dp, X509V2AttributeCertificate attrCert, PkixParameters paramsPKIX, DateTime validDate, X509Certificate issuerCert, CertStatus certStatus, ReasonsMask reasonMask, IList`1<X509Certificate> certPathCerts);
}
public class Org.BouncyCastle.Pkix.TrustAnchor : object {
    private AsymmetricKeyParameter pubKey;
    private string caName;
    private X509Name caPrincipal;
    private X509Certificate trustedCert;
    private Byte[] ncBytes;
    private NameConstraints nc;
    public X509Certificate TrustedCert { get; }
    public X509Name CA { get; }
    public string CAName { get; }
    public AsymmetricKeyParameter CAPublicKey { get; }
    public Byte[] GetNameConstraints { get; }
    public TrustAnchor(X509Certificate trustedCert, Byte[] nameConstraints);
    public TrustAnchor(X509Name caPrincipal, AsymmetricKeyParameter pubKey, Byte[] nameConstraints);
    public TrustAnchor(string caName, AsymmetricKeyParameter pubKey, Byte[] nameConstraints);
    public X509Certificate get_TrustedCert();
    public X509Name get_CA();
    public string get_CAName();
    public AsymmetricKeyParameter get_CAPublicKey();
    private void setNameConstraints(Byte[] bytes);
    public Byte[] get_GetNameConstraints();
    public virtual string ToString();
}
public class Org.BouncyCastle.Pqc.Asn1.CmcePrivateKey : Asn1Object {
    private int version;
    private Byte[] delta;
    private Byte[] c;
    private Byte[] g;
    private Byte[] alpha;
    private Byte[] s;
    private CmcePublicKey publicKey;
    public int Version { get; }
    public Byte[] Delta { get; }
    public Byte[] C { get; }
    public Byte[] G { get; }
    public Byte[] Alpha { get; }
    public Byte[] S { get; }
    public CmcePublicKey PublicKey { get; }
    public CmcePrivateKey(int version, Byte[] delta, Byte[] c, Byte[] g, Byte[] alpha, Byte[] s, CmcePublicKey pubKey);
    private CmcePrivateKey(Asn1Sequence seq);
    public static CmcePrivateKey GetInstance(object o);
    public int get_Version();
    public Byte[] get_Delta();
    public Byte[] get_C();
    public Byte[] get_G();
    public Byte[] get_Alpha();
    public Byte[] get_S();
    public CmcePublicKey get_PublicKey();
    public Asn1Object ToAsn1Primitive();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal sealed virtual DerEncoding GetEncodingDer();
    internal sealed virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Pqc.Asn1.CmcePublicKey : Asn1Object {
    private Byte[] t;
    public Byte[] T { get; }
    public CmcePublicKey(Byte[] t);
    public CmcePublicKey(Asn1Sequence seq);
    public static CmcePublicKey GetInstance(object o);
    public Byte[] get_T();
    public Asn1Object ToAsn1Primitive();
    internal virtual IAsn1Encoding GetEncoding(int encoding);
    internal virtual IAsn1Encoding GetEncodingImplicit(int encoding, int tagClass, int tagNo);
    internal virtual DerEncoding GetEncodingDer();
    internal virtual DerEncoding GetEncodingDerImplicit(int tagClass, int tagNo);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
internal class Org.BouncyCastle.Pqc.Crypto.Bike.BikeEngine : object {
    private int r;
    private int w;
    private int hw;
    private int t;
    private int nbIter;
    private int tau;
    private BikeRing bikeRing;
    private int L_BYTE;
    private int R_BYTE;
    private int R2_UINT;
    private int R_ULONG;
    private int R2_ULONG;
    internal int SessionKeySize { get; }
    internal BikeEngine(int r, int w, int t, int l, int nbIter, int tau);
    internal int get_SessionKeySize();
    private UInt64[] FunctionH(Byte[] seed);
    private void FunctionL(UInt64[] e01, Byte[] c1, int c1Off);
    private void FunctionK(Byte[] m, Byte[] c01, Byte[] result);
    private void FunctionK(Byte[] m, Byte[] c0, Byte[] c1, Byte[] result);
    internal void GenKeyPair(Byte[] h0, Byte[] h1, Byte[] sigma, Byte[] h, SecureRandom random);
    internal void Encaps(Byte[] c01, Byte[] k, Byte[] h, SecureRandom random);
    internal void Decaps(Byte[] k, Byte[] h0, Byte[] h1, Byte[] sigma, Byte[] c0, Byte[] c1);
    private Byte[] ComputeSyndrome(Byte[] c0, Byte[] h0);
    private Byte[] BGFDecoder(Byte[] s, Int32[] h0Compact, Int32[] h1Compact);
    private void BFIter(Byte[] s, Byte[] e, int T, Int32[] h0Compact, Int32[] h1Compact, Int32[] h0CompactCol, Int32[] h1CompactCol, UInt32[] black, UInt32[] gray, Byte[] ctrs);
    private void BFIter2(Byte[] s, Byte[] e, int T, Int32[] h0Compact, Int32[] h1Compact, Int32[] h0CompactCol, Int32[] h1CompactCol, UInt32[] black, Byte[] ctrs);
    private void BFMaskedIter(Byte[] s, Byte[] e, UInt32[] mask, int T, Int32[] h0Compact, Int32[] h1Compact, Int32[] h0CompactCol, Int32[] h1CompactCol);
    private static int Threshold(int hammingWeight, int r);
    private static int ThresholdFromParameters(int hammingWeight, double dm, double da, int min);
    private int Ctr(Int32[] hCompactCol, Byte[] s, int j);
    private void CtrAll(Int32[] hCompactCol, Byte[] s, Byte[] ctrs);
    private void ConvertToCompact(Int32[] compactVersion, Byte[] h);
    private Int32[] GetColumnFromCompactVersion(Int32[] hCompact);
    private void RecomputeSyndrome(Byte[] syndrome, int index, Int32[] h0Compact, Int32[] h1Compact);
    private void AlignE01From1To64(UInt64[] e01);
    private void AlignE01From64To8(UInt64[] e01);
    private void AlignE01From8To1(UInt64[] e01);
}
public class Org.BouncyCastle.Pqc.Crypto.Bike.BikeKemExtractor : object {
    private BikeKeyParameters key;
    public int EncapsulationLength { get; }
    public BikeKemExtractor(BikePrivateKeyParameters privParams);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    public sealed virtual int get_EncapsulationLength();
}
public class Org.BouncyCastle.Pqc.Crypto.Bike.BikeKemGenerator : object {
    private SecureRandom sr;
    public BikeKemGenerator(SecureRandom random);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
}
public class Org.BouncyCastle.Pqc.Crypto.Bike.BikeKeyGenerationParameters : KeyGenerationParameters {
    private BikeParameters m_parameters;
    public BikeParameters Parameters { get; }
    public BikeKeyGenerationParameters(SecureRandom random, BikeParameters parameters);
    public BikeParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Bike.BikeKeyPairGenerator : object {
    private SecureRandom random;
    private int r;
    private int l;
    private int L_BYTE;
    private int R_BYTE;
    private BikeKeyGenerationParameters bikeKeyGenerationParameters;
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Bike.BikeKeyParameters : AsymmetricKeyParameter {
    private BikeParameters m_parameters;
    public BikeParameters Parameters { get; }
    internal BikeKeyParameters(bool isPrivate, BikeParameters parameters);
    public BikeParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Bike.BikeParameters : object {
    public static BikeParameters bike128;
    public static BikeParameters bike192;
    public static BikeParameters bike256;
    private string name;
    private int r;
    private int w;
    private int t;
    private int l;
    private int nbIter;
    private int tau;
    private int defaultKeySize;
    private BikeEngine bikeEngine;
    public int R { get; }
    public int RByte { get; }
    public int LByte { get; }
    public int W { get; }
    public int T { get; }
    public int L { get; }
    public int NbIter { get; }
    public int Tau { get; }
    public string Name { get; }
    public int DefaultKeySize { get; }
    internal BikeEngine BikeEngine { get; }
    private BikeParameters(string name, int r, int w, int t, int l, int nbIter, int tau, int defaultKeySize);
    private static BikeParameters();
    public int get_R();
    public int get_RByte();
    public int get_LByte();
    public int get_W();
    public int get_T();
    public int get_L();
    public int get_NbIter();
    public int get_Tau();
    public string get_Name();
    public int get_DefaultKeySize();
    internal BikeEngine get_BikeEngine();
}
public class Org.BouncyCastle.Pqc.Crypto.Bike.BikePrivateKeyParameters : BikeKeyParameters {
    private Byte[] h0;
    private Byte[] h1;
    private Byte[] sigma;
    public BikePrivateKeyParameters(BikeParameters bikeParameters, Byte[] h0, Byte[] h1, Byte[] sigma);
    public Byte[] GetH0();
    public Byte[] GetH1();
    public Byte[] GetSigma();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Bike.BikePublicKeyParameters : BikeKeyParameters {
    private Byte[] publicKey;
    internal Byte[] PublicKey { get; }
    public BikePublicKeyParameters(BikeParameters param, Byte[] publicKey);
    internal Byte[] get_PublicKey();
    public Byte[] GetEncoded();
}
internal class Org.BouncyCastle.Pqc.Crypto.Bike.BikeRing : object {
    private static int PermutationCutoff;
    private int m_bits;
    private int m_size;
    private int m_sizeExt;
    private Dictionary`2<int, int> m_halfPowers;
    internal int Size { get; }
    internal int SizeExt { get; }
    internal BikeRing(int r);
    internal void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    internal void AddTo(UInt64[] x, UInt64[] z);
    internal void Copy(UInt64[] x, UInt64[] z);
    internal UInt64[] Create();
    internal UInt64[] CreateExt();
    internal void DecodeBytes(Byte[] bs, UInt64[] z);
    internal Byte[] EncodeBitsTransposed(UInt64[] x);
    internal void EncodeBytes(UInt64[] x, Byte[] bs);
    internal void Inv(UInt64[] a, UInt64[] z);
    internal void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    internal void Multiply(UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] z);
    internal void Reduce(UInt64[] tt, UInt64[] z);
    internal int get_Size();
    internal int get_SizeExt();
    internal void Square(UInt64[] x, UInt64[] z);
    internal void SquareN(UInt64[] x, int n, UInt64[] z);
    private static int ImplModAdd(int m, int x, int y);
    private void ImplMultiplyAcc(UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] zz);
    private void ImplPermute(UInt64[] x, int n, UInt64[] z);
    [IteratorStateMachineAttribute("Org.BouncyCastle.Pqc.Crypto.Bike.BikeRing/<EnumerateSquarePowersInv>d__27")]
private static IEnumerable`1<int> EnumerateSquarePowersInv(int r);
    private static int GenerateHalfPower(UInt32 r, UInt32 r32, int n);
    private static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    private void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Pqc.Crypto.Bike.BikeUtilities : object {
    internal static int GetHammingWeight(Byte[] bytes);
    internal static void FromBitsToUlongs(UInt64[] output, Byte[] input, int inputOff, int inputLen);
    internal static void GenerateRandomUlongs(UInt64[] res, int size, int weight, IXof digest);
    private static bool CheckBit(UInt64[] tmp, UInt32 position);
    private static void SetBit(UInt64[] tmp, UInt32 position);
}
internal abstract class Org.BouncyCastle.Pqc.Crypto.Cmce.Benes : object {
    protected int SYS_N;
    protected int SYS_T;
    protected int GFBITS;
    internal Benes(int n, int t, int m);
    internal static void Transpose64x64(UInt64[] output, UInt64[] input);
    internal static void Transpose64x64(UInt64[] output, UInt64[] input, int offset);
    internal abstract virtual void SupportGen(UInt16[] s, Byte[] c);
}
internal class Org.BouncyCastle.Pqc.Crypto.Cmce.Benes12 : Benes {
    internal Benes12(int n, int t, int m);
    internal static void LayerBenes(UInt64[] data, UInt64[] bits, int lgs);
    private void ApplyBenes(Byte[] r, Byte[] bits, int rev);
    internal virtual void SupportGen(UInt16[] s, Byte[] c);
}
internal class Org.BouncyCastle.Pqc.Crypto.Cmce.Benes13 : Benes {
    internal Benes13(int n, int t, int m);
    internal static void LayerIn(UInt64[] data, UInt64[] bits, int lgs);
    internal static void LayerEx(UInt64[] data, UInt64[] bits, int lgs);
    internal void ApplyBenes(Byte[] r, Byte[] bits, int rev);
    internal virtual void SupportGen(UInt16[] s, Byte[] c);
}
internal class Org.BouncyCastle.Pqc.Crypto.Cmce.CmceEngine`1 : object {
    private int SYS_N;
    private int SYS_T;
    private int GFBITS;
    private int IRR_BYTES;
    private int COND_BYTES;
    private int PK_NROWS;
    private int PK_NCOLS;
    private int PK_ROW_BYTES;
    private int SYND_BYTES;
    private int GFMASK;
    private Int32[] poly;
    private int defaultKeySize;
    private GFImpl gf;
    private Benes benes;
    private bool usePadding;
    private bool countErrorIndices;
    private bool usePivots;
    public int IrrBytes { get; }
    public int CondBytes { get; }
    public int PrivateKeySize { get; }
    public int PublicKeySize { get; }
    public int CipherTextSize { get; }
    public int DefaultSessionKeySize { get; }
    internal CmceEngine`1(int m, int n, int t, Int32[] p, bool usePivots, int defaultKeySize);
    public int get_IrrBytes();
    public int get_CondBytes();
    public sealed virtual int get_PrivateKeySize();
    public sealed virtual int get_PublicKeySize();
    public sealed virtual int get_CipherTextSize();
    public sealed virtual int get_DefaultSessionKeySize();
    public sealed virtual Byte[] GeneratePublicKeyFromPrivateKey(Byte[] sk);
    public sealed virtual Byte[] DecompressPrivateKey(Byte[] sk);
    public sealed virtual void KemKeypair(Byte[] pk, Byte[] sk, SecureRandom random);
    private void Syndrome(Byte[] cipher_text, Byte[] pk, Byte[] error_vector);
    private void GenerateErrorVector(Byte[] error_vector, SecureRandom random);
    private void Encrypt(Byte[] cipher_text, Byte[] pk, Byte[] error_vector, SecureRandom random);
    public sealed virtual int KemEnc(Byte[] cipher_text, Byte[] key, Byte[] pk, SecureRandom random);
    public sealed virtual int KemDec(Byte[] key, Byte[] cipher_text, Byte[] sk);
    private int Decrypt(Byte[] error_vector, Byte[] sk, Byte[] cipher_text);
    private static int Min(ushort a, int b);
    private void BM(UInt16[] output, UInt16[] s);
    private void Synd(UInt16[] output, UInt16[] f, UInt16[] L, Byte[] r);
    private int MovColumns(Byte[][] mat, UInt16[] pi, UInt64[] pivots);
    private static int Ctz(ulong input);
    private static ulong SameMask64(ushort x, ushort y);
    private static byte SameMask32(short x, short y);
    private static void Layer(UInt16[] p, Byte[] output, int ptrIndex, int s, int n);
    private static void ControlBitsFromPermutation(Byte[] output, UInt16[] pi, long w, long n);
    private static short GetQShort(Int32[] temp, int q_index);
    private static void CBRecursion(Byte[] output, long pos, long step, UInt16[] pi, int qIndex, long w, long n, Int32[] temp);
    private int PKGen(Byte[] pk, Byte[] sk, UInt32[] perm, UInt16[] pi, UInt64[] pivots);
    private ushort Eval(UInt16[] f, ushort a);
    private void Root(UInt16[] output, UInt16[] f, UInt16[] L);
    private int GenerateIrrPoly(UInt16[] field);
    private int CheckPKPadding(Byte[] pk);
    private int CheckCPadding(Byte[] c);
    private static void Sort32(Int32[] temp, int from, int to);
    private static void Sort64(Int64[] temp, int from, int to);
}
public class Org.BouncyCastle.Pqc.Crypto.Cmce.CmceKemExtractor : object {
    private ICmceEngine engine;
    private CmceKeyParameters key;
    public int EncapsulationLength { get; }
    public CmceKemExtractor(CmcePrivateKeyParameters privParams);
    private void InitCipher(CmceParameters param);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    private Byte[] ExtractSecret(Byte[] encapsulation, int sessionKeySizeInBits);
    public sealed virtual int get_EncapsulationLength();
}
public class Org.BouncyCastle.Pqc.Crypto.Cmce.CmceKemGenerator : object {
    private SecureRandom sr;
    public CmceKemGenerator(SecureRandom random);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
    private ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey, int sessionKeySizeInBits);
}
public class Org.BouncyCastle.Pqc.Crypto.Cmce.CmceKeyGenerationParameters : KeyGenerationParameters {
    private CmceParameters parameters;
    public CmceParameters Parameters { get; }
    public CmceKeyGenerationParameters(SecureRandom random, CmceParameters CmceParams);
    public CmceParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Cmce.CmceKeyPairGenerator : object {
    private CmceKeyGenerationParameters m_cmceParams;
    private SecureRandom random;
    private void Initialize(KeyGenerationParameters param);
    private AsymmetricCipherKeyPair GenKeyPair();
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Cmce.CmceKeyParameters : AsymmetricKeyParameter {
    private CmceParameters parameters;
    public CmceParameters Parameters { get; }
    internal CmceKeyParameters(bool isPrivate, CmceParameters parameters);
    public CmceParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Cmce.CmceParameters : object {
    private static Int32[] poly3488;
    private static Int32[] poly4608;
    private static Int32[] poly6688;
    private static Int32[] poly6960;
    private static Int32[] poly8192;
    public static CmceParameters mceliece348864r3;
    public static CmceParameters mceliece348864fr3;
    public static CmceParameters mceliece460896r3;
    public static CmceParameters mceliece460896fr3;
    public static CmceParameters mceliece6688128r3;
    public static CmceParameters mceliece6688128fr3;
    public static CmceParameters mceliece6960119r3;
    public static CmceParameters mceliece6960119fr3;
    public static CmceParameters mceliece8192128r3;
    public static CmceParameters mceliece8192128fr3;
    private string name;
    private int m;
    private int n;
    private int t;
    private bool usePivots;
    private int defaultKeySize;
    private ICmceEngine engine;
    public string Name { get; }
    public int M { get; }
    public int N { get; }
    public int T { get; }
    public int Mu { get; }
    public int Nu { get; }
    public int DefaultKeySize { get; }
    internal ICmceEngine Engine { get; }
    private CmceParameters(string name, int m, int n, int t, Int32[] p, bool usePivots, int defaultKeySize);
    private static CmceParameters();
    public string get_Name();
    public int get_M();
    public int get_N();
    public int get_T();
    public int get_Mu();
    public int get_Nu();
    public int get_DefaultKeySize();
    internal ICmceEngine get_Engine();
}
public class Org.BouncyCastle.Pqc.Crypto.Cmce.CmcePrivateKeyParameters : CmceKeyParameters {
    internal Byte[] privateKey;
    internal Byte[] Delta { get; }
    internal Byte[] C { get; }
    internal Byte[] G { get; }
    internal Byte[] Alpha { get; }
    internal Byte[] S { get; }
    public CmcePrivateKeyParameters(CmceParameters parameters, Byte[] privateKey);
    public CmcePrivateKeyParameters(CmceParameters parameters, Byte[] delta, Byte[] C, Byte[] g, Byte[] alpha, Byte[] s);
    public Byte[] GetPrivateKey();
    public Byte[] ReconstructPublicKey();
    public Byte[] GetEncoded();
    internal Byte[] get_Delta();
    internal Byte[] get_C();
    internal Byte[] get_G();
    internal Byte[] get_Alpha();
    internal Byte[] get_S();
}
public class Org.BouncyCastle.Pqc.Crypto.Cmce.CmcePublicKeyParameters : CmceKeyParameters {
    internal Byte[] publicKey;
    public CmcePublicKeyParameters(CmceParameters parameters, Byte[] publicKey);
    public Byte[] GetPublicKey();
    public Byte[] GetEncoded();
}
internal interface Org.BouncyCastle.Pqc.Crypto.Cmce.GF {
    public abstract virtual void GFMulPoly(int length, Int32[] poly, UInt16[] output, UInt16[] left, UInt16[] right, UInt32[] temp);
    public abstract virtual void GFSqrPoly(int length, Int32[] poly, UInt16[] output, UInt16[] input, UInt32[] temp);
    public abstract virtual ushort GFFrac(ushort den, ushort num);
    public abstract virtual ushort GFInv(ushort input);
    public abstract virtual ushort GFIsZero(ushort a);
    public abstract virtual ushort GFMul(ushort left, ushort right);
    public abstract virtual UInt32 GFMulExt(ushort left, ushort right);
    public abstract virtual ushort GFReduce(UInt32 input);
    public abstract virtual ushort GFSq(ushort input);
    public abstract virtual UInt32 GFSqExt(ushort input);
}
internal class Org.BouncyCastle.Pqc.Crypto.Cmce.GF12 : ValueType {
    public sealed virtual void GFMulPoly(int length, Int32[] poly, UInt16[] output, UInt16[] left, UInt16[] right, UInt32[] temp);
    public sealed virtual void GFSqrPoly(int length, Int32[] poly, UInt16[] output, UInt16[] input, UInt32[] temp);
    public sealed virtual ushort GFFrac(ushort den, ushort num);
    public sealed virtual ushort GFInv(ushort input);
    public sealed virtual ushort GFIsZero(ushort a);
    public sealed virtual ushort GFMul(ushort left, ushort right);
    public sealed virtual UInt32 GFMulExt(ushort left, ushort right);
    private UInt32 GFMulExtPar(ushort left0, ushort right0, ushort left1, ushort right1);
    public sealed virtual ushort GFReduce(UInt32 x);
    public sealed virtual ushort GFSq(ushort input);
    public sealed virtual UInt32 GFSqExt(ushort input);
}
internal class Org.BouncyCastle.Pqc.Crypto.Cmce.GF13 : ValueType {
    public sealed virtual void GFMulPoly(int length, Int32[] poly, UInt16[] output, UInt16[] left, UInt16[] right, UInt32[] temp);
    public sealed virtual void GFSqrPoly(int length, Int32[] poly, UInt16[] output, UInt16[] input, UInt32[] temp);
    public sealed virtual ushort GFFrac(ushort den, ushort num);
    public sealed virtual ushort GFInv(ushort den);
    public sealed virtual ushort GFIsZero(ushort a);
    public sealed virtual ushort GFMul(ushort in0, ushort in1);
    public sealed virtual UInt32 GFMulExt(ushort left, ushort right);
    private UInt32 GFMulExtPar(ushort left0, ushort right0, ushort left1, ushort right1);
    public sealed virtual ushort GFReduce(UInt32 x);
    public sealed virtual ushort GFSq(ushort input);
    public sealed virtual UInt32 GFSqExt(ushort input);
    private ushort GFSq2(ushort input);
    private ushort GFSqMul(ushort input, ushort m);
    private ushort GFSq2Mul(ushort input, ushort m);
}
internal interface Org.BouncyCastle.Pqc.Crypto.Cmce.ICmceEngine {
    public int CipherTextSize { get; }
    public int DefaultSessionKeySize { get; }
    public int PrivateKeySize { get; }
    public int PublicKeySize { get; }
    public abstract virtual int get_CipherTextSize();
    public abstract virtual Byte[] DecompressPrivateKey(Byte[] sk);
    public abstract virtual int get_DefaultSessionKeySize();
    public abstract virtual Byte[] GeneratePublicKeyFromPrivateKey(Byte[] sk);
    public abstract virtual int KemDec(Byte[] key, Byte[] cipher_text, Byte[] sk);
    public abstract virtual int KemEnc(Byte[] cipher_text, Byte[] key, Byte[] pk, SecureRandom random);
    public abstract virtual void KemKeypair(Byte[] pk, Byte[] sk, SecureRandom random);
    public abstract virtual int get_PrivateKeySize();
    public abstract virtual int get_PublicKeySize();
}
internal class Org.BouncyCastle.Pqc.Crypto.Cmce.Utils : object {
    internal static void StoreGF(Byte[] dest, int offset, ushort a);
    internal static ushort LoadGF(Byte[] src, int offset, int gfmask);
    internal static UInt32 Load4(Byte[] input, int offset);
    internal static void Store8(Byte[] output, int offset, ulong input);
    internal static void Store8(Byte[] output, int offset, UInt64[] input, int inOff, int inLen);
    internal static ulong Load8(Byte[] input, int offset);
    internal static void Load8(Byte[] input, int offset, UInt64[] output, int outOff, int outLen);
    internal static ushort Bitrev(ushort a, int GFBITS);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.DilithiumEngine : object {
    private SecureRandom _random;
    public static int N;
    public static int Q;
    public static int QInv;
    public static int D;
    public static int RootOfUnity;
    public static int SeedBytes;
    public static int CrhBytes;
    public static int PolyT1PackedBytes;
    public static int PolyT0PackedBytes;
    [CompilerGeneratedAttribute]
private int <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <K>k__BackingField;
    [CompilerGeneratedAttribute]
private int <L>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Eta>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Tau>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Beta>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Gamma1>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Gamma2>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Omega>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PolyVecHPackedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PolyZPackedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PolyW1PackedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PolyEtaPackedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CryptoPublicKeyBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CryptoSecretKeyBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CryptoBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PolyUniformGamma1NBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Symmetric <Symmetric>k__BackingField;
    public int Mode { get; private set; }
    public int K { get; private set; }
    public int L { get; private set; }
    public int Eta { get; private set; }
    public int Tau { get; private set; }
    public int Beta { get; private set; }
    public int Gamma1 { get; private set; }
    public int Gamma2 { get; private set; }
    public int Omega { get; private set; }
    public int PolyVecHPackedBytes { get; private set; }
    public int PolyZPackedBytes { get; private set; }
    public int PolyW1PackedBytes { get; private set; }
    public int PolyEtaPackedBytes { get; private set; }
    public int CryptoPublicKeyBytes { get; private set; }
    public int CryptoSecretKeyBytes { get; private set; }
    public int CryptoBytes { get; private set; }
    public int PolyUniformGamma1NBytes { get; private set; }
    public Symmetric Symmetric { get; private set; }
    public DilithiumEngine(int mode, SecureRandom random, bool usingAes);
    [CompilerGeneratedAttribute]
public int get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(int value);
    [CompilerGeneratedAttribute]
public int get_K();
    [CompilerGeneratedAttribute]
private void set_K(int value);
    [CompilerGeneratedAttribute]
public int get_L();
    [CompilerGeneratedAttribute]
private void set_L(int value);
    [CompilerGeneratedAttribute]
public int get_Eta();
    [CompilerGeneratedAttribute]
private void set_Eta(int value);
    [CompilerGeneratedAttribute]
public int get_Tau();
    [CompilerGeneratedAttribute]
private void set_Tau(int value);
    [CompilerGeneratedAttribute]
public int get_Beta();
    [CompilerGeneratedAttribute]
private void set_Beta(int value);
    [CompilerGeneratedAttribute]
public int get_Gamma1();
    [CompilerGeneratedAttribute]
private void set_Gamma1(int value);
    [CompilerGeneratedAttribute]
public int get_Gamma2();
    [CompilerGeneratedAttribute]
private void set_Gamma2(int value);
    [CompilerGeneratedAttribute]
public int get_Omega();
    [CompilerGeneratedAttribute]
private void set_Omega(int value);
    [CompilerGeneratedAttribute]
public int get_PolyVecHPackedBytes();
    [CompilerGeneratedAttribute]
private void set_PolyVecHPackedBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PolyZPackedBytes();
    [CompilerGeneratedAttribute]
private void set_PolyZPackedBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PolyW1PackedBytes();
    [CompilerGeneratedAttribute]
private void set_PolyW1PackedBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PolyEtaPackedBytes();
    [CompilerGeneratedAttribute]
private void set_PolyEtaPackedBytes(int value);
    [CompilerGeneratedAttribute]
public int get_CryptoPublicKeyBytes();
    [CompilerGeneratedAttribute]
private void set_CryptoPublicKeyBytes(int value);
    [CompilerGeneratedAttribute]
public int get_CryptoSecretKeyBytes();
    [CompilerGeneratedAttribute]
private void set_CryptoSecretKeyBytes(int value);
    [CompilerGeneratedAttribute]
public int get_CryptoBytes();
    [CompilerGeneratedAttribute]
private void set_CryptoBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PolyUniformGamma1NBytes();
    [CompilerGeneratedAttribute]
private void set_PolyUniformGamma1NBytes(int value);
    [CompilerGeneratedAttribute]
public Symmetric get_Symmetric();
    [CompilerGeneratedAttribute]
private void set_Symmetric(Symmetric value);
    public void GenerateKeyPair(Byte[]& rho, Byte[]& key, Byte[]& tr, Byte[]& s1_, Byte[]& s2_, Byte[]& t0_, Byte[]& encT1);
    public void SignSignature(Byte[] sig, int siglen, Byte[] msg, int msglen, Byte[] rho, Byte[] key, Byte[] tr, Byte[] t0Enc, Byte[] s1Enc, Byte[] s2Enc);
    public void Sign(Byte[] sig, int siglen, Byte[] msg, int mlen, Byte[] rho, Byte[] key, Byte[] tr, Byte[] t0, Byte[] s1, Byte[] s2);
    public bool SignVerify(Byte[] sig, int siglen, Byte[] msg, int msglen, Byte[] rho, Byte[] encT1);
    public bool SignOpen(Byte[] msg, Byte[] sig, int siglen, Byte[] rho, Byte[] t1);
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.DilithiumKeyGenerationParameters : KeyGenerationParameters {
    private DilithiumParameters parameters;
    public DilithiumParameters Parameters { get; }
    public DilithiumKeyGenerationParameters(SecureRandom random, DilithiumParameters parameters);
    public DilithiumParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.DilithiumKeyPairGenerator : object {
    private SecureRandom random;
    private DilithiumParameters parameters;
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.DilithiumKeyParameters : AsymmetricKeyParameter {
    private DilithiumParameters m_parameters;
    public DilithiumParameters Parameters { get; }
    internal DilithiumKeyParameters(bool isPrivate, DilithiumParameters parameters);
    public DilithiumParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.DilithiumParameters : object {
    public static DilithiumParameters Dilithium2;
    public static DilithiumParameters Dilithium2Aes;
    public static DilithiumParameters Dilithium3;
    public static DilithiumParameters Dilithium3Aes;
    public static DilithiumParameters Dilithium5;
    public static DilithiumParameters Dilithium5Aes;
    private int k;
    private bool usingAes;
    private DilithiumParameters(int param, bool usingAes);
    private static DilithiumParameters();
    internal DilithiumEngine GetEngine(SecureRandom Random);
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.DilithiumPrivateKeyParameters : DilithiumKeyParameters {
    internal Byte[] rho;
    internal Byte[] k;
    internal Byte[] tr;
    internal Byte[] s1;
    internal Byte[] s2;
    internal Byte[] t0;
    private Byte[] t1;
    public Byte[] Rho { get; }
    public Byte[] K { get; }
    public Byte[] Tr { get; }
    public Byte[] S1 { get; }
    public Byte[] S2 { get; }
    public Byte[] T0 { get; }
    public Byte[] T1 { get; }
    public DilithiumPrivateKeyParameters(DilithiumParameters parameters, Byte[] rho, Byte[] K, Byte[] tr, Byte[] s1, Byte[] s2, Byte[] t0, Byte[] t1);
    public Byte[] get_Rho();
    public Byte[] get_K();
    public Byte[] get_Tr();
    public Byte[] get_S1();
    public Byte[] get_S2();
    public Byte[] get_T0();
    public Byte[] get_T1();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.DilithiumPublicKeyParameters : DilithiumKeyParameters {
    internal Byte[] rho;
    internal Byte[] t1;
    internal Byte[] Rho { get; }
    internal Byte[] T1 { get; }
    public DilithiumPublicKeyParameters(DilithiumParameters parameters, Byte[] pkEncoded);
    public DilithiumPublicKeyParameters(DilithiumParameters parameters, Byte[] rho, Byte[] t1);
    public Byte[] GetEncoded();
    internal Byte[] get_Rho();
    internal Byte[] get_T1();
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.DilithiumSigner : object {
    private DilithiumPrivateKeyParameters privKey;
    private DilithiumPublicKeyParameters pubKey;
    private SecureRandom random;
    public sealed virtual void Init(bool forSigning, ICipherParameters param);
    public sealed virtual Byte[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, Byte[] signature);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.Ntt : object {
    private static Int32[] Zetas;
    private static Ntt();
    public static void NTT(Int32[] r);
    public static void InverseNttToMont(Int32[] a);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.Packing : object {
    public static Byte[] PackPublicKey(PolyVecK t1, DilithiumEngine Engine);
    public static PolyVecK UnpackPublicKey(PolyVecK t1, Byte[] pk, DilithiumEngine Engine);
    public static void PackSecretKey(Byte[] t0_, Byte[] s1_, Byte[] s2_, PolyVecK t0, PolyVecL s1, PolyVecK s2, DilithiumEngine Engine);
    public static void UnpackSecretKey(PolyVecK t0, PolyVecL s1, PolyVecK s2, Byte[] t0Enc, Byte[] s1Enc, Byte[] s2Enc, DilithiumEngine Engine);
    public static void PackSignature(Byte[] sig, Byte[] c, PolyVecL z, PolyVecK h, DilithiumEngine engine);
    public static bool UnpackSignature(PolyVecL z, PolyVecK h, Byte[] sig, DilithiumEngine Engine);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.Poly : object {
    [CompilerGeneratedAttribute]
private Int32[] <Coeffs>k__BackingField;
    private int N;
    private DilithiumEngine Engine;
    private int PolyUniformNBlocks;
    private Symmetric Symmetric;
    public Int32[] Coeffs { get; public set; }
    public Poly(DilithiumEngine engine);
    [CompilerGeneratedAttribute]
public Int32[] get_Coeffs();
    [CompilerGeneratedAttribute]
public void set_Coeffs(Int32[] value);
    public void UniformBlocks(Byte[] seed, ushort nonce);
    private static int RejectUniform(Int32[] coeffs, int off, int len, Byte[] buf, int buflen);
    public void UniformEta(Byte[] seed, ushort nonce);
    private static int RejectEta(Int32[] coeffs, int off, int len, Byte[] buf, int buflen, int eta);
    public void PointwiseMontgomery(Poly v, Poly w);
    public void PointwiseAccountMontgomery(PolyVecL u, PolyVecL v);
    public void AddPoly(Poly a);
    public void Subtract(Poly b);
    public void ReducePoly();
    public void PolyNtt();
    public void InverseNttToMont();
    public void ConditionalAddQ();
    public void Power2Round(Poly a);
    public void PolyT0Pack(Byte[] r, int off);
    public void PolyT0Unpack(Byte[] a, int off);
    public Byte[] PolyT1Pack();
    public void PolyT1Unpack(Byte[] a);
    public void PolyEtaPack(Byte[] r, int off);
    public void PolyEtaUnpack(Byte[] a, int off);
    public void UniformGamma1(Byte[] seed, ushort nonce);
    public void PackZ(Byte[] r, int offset);
    public void UnpackZ(Byte[] a);
    public void Decompose(Poly a);
    public void PackW1(Byte[] r, int off);
    public void Challenge(Byte[] seed);
    public bool CheckNorm(int B);
    public int PolyMakeHint(Poly a0, Poly a1);
    public void PolyUseHint(Poly a, Poly h);
    public void ShiftLeft();
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.PolyVecK : object {
    public Poly[] Vec;
    private DilithiumEngine Engine;
    private int K;
    public PolyVecK(DilithiumEngine Engine);
    public void UniformEta(Byte[] seed, ushort nonce);
    public void Reduce();
    public void Ntt();
    public void InverseNttToMont();
    public void AddPolyVecK(PolyVecK b);
    public void Subtract(PolyVecK v);
    public void ConditionalAddQ();
    public void Power2Round(PolyVecK v);
    public void Decompose(PolyVecK v);
    public void PackW1(Byte[] r);
    public void PointwisePolyMontgomery(Poly a, PolyVecK v);
    public bool CheckNorm(int bound);
    public int MakeHint(PolyVecK v0, PolyVecK v1);
    public void UseHint(PolyVecK a, PolyVecK h);
    public void ShiftLeft();
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.PolyVecL : object {
    public Poly[] Vec;
    private int L;
    private int K;
    public PolyVecL(DilithiumEngine Engine);
    public void UniformEta(Byte[] seed, ushort nonce);
    public void CopyPolyVecL(PolyVecL OutPoly);
    public void InverseNttToMont();
    public void Ntt();
    public void UniformGamma1(Byte[] seed, ushort nonce);
    public void PointwisePolyMontgomery(Poly a, PolyVecL v);
    public void AddPolyVecL(PolyVecL b);
    public void Reduce();
    public bool CheckNorm(int bound);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.PolyVecMatrix : object {
    private int K;
    private int L;
    public PolyVecL[] Matrix;
    public PolyVecMatrix(DilithiumEngine Engine);
    public void ExpandMatrix(Byte[] rho);
    public void PointwiseMontgomery(PolyVecK t, PolyVecL v);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.Reduce : object {
    public static int MontgomeryReduce(long a);
    public static int Reduce32(int a);
    public static int ConditionalAddQ(int a);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.Rounding : object {
    public static Int32[] Power2Round(int a);
    public static Int32[] Decompose(int a, int gamma2);
    public static int MakeHint(int a0, int a1, DilithiumEngine engine);
    public static int UseHint(int a, int hint, int gamma2);
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.Symmetric : object {
    public int Stream128BlockBytes;
    public int Stream256BlockBytes;
    private Symmetric(int stream128, int stream256);
    internal abstract virtual void Stream128Init(Byte[] seed, ushort nonce);
    internal abstract virtual void Stream256Init(Byte[] seed, ushort nonce);
    internal abstract virtual void Stream128SqueezeBlocks(Byte[] output, int offset, int size);
    internal abstract virtual void Stream256SqueezeBlocks(Byte[] output, int offset, int size);
}
internal static class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.Cbd : object {
    internal static void Eta(Poly r, Byte[] bytes, int eta);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberEngine : object {
    private SecureRandom m_random;
    private KyberIndCpa m_indCpa;
    public static int N;
    public static int Q;
    public static int QInv;
    public static int SymBytes;
    private static int SharedSecretBytes;
    public static int PolyBytes;
    public static int Eta2;
    public int IndCpaMsgBytes;
    [CompilerGeneratedAttribute]
private Symmetric <Symmetric>k__BackingField;
    [CompilerGeneratedAttribute]
private int <K>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PolyVecBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PolyCompressedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PolyVecCompressedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Eta1>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndCpaPublicKeyBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndCpaSecretKeyBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndCpaBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PublicKeyBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SecretKeyBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CipherTextBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CryptoBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CryptoSecretKeyBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CryptoPublicKeyBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CryptoCipherTextBytes>k__BackingField;
    public Symmetric Symmetric { get; private set; }
    public int K { get; private set; }
    public int PolyVecBytes { get; private set; }
    public int PolyCompressedBytes { get; private set; }
    public int PolyVecCompressedBytes { get; private set; }
    public int Eta1 { get; private set; }
    public int IndCpaPublicKeyBytes { get; private set; }
    public int IndCpaSecretKeyBytes { get; private set; }
    public int IndCpaBytes { get; private set; }
    public int PublicKeyBytes { get; private set; }
    public int SecretKeyBytes { get; private set; }
    public int CipherTextBytes { get; private set; }
    public int CryptoBytes { get; private set; }
    public int CryptoSecretKeyBytes { get; private set; }
    public int CryptoPublicKeyBytes { get; private set; }
    public int CryptoCipherTextBytes { get; private set; }
    public KyberEngine(int k, bool usingAes);
    private static KyberEngine();
    [CompilerGeneratedAttribute]
public Symmetric get_Symmetric();
    [CompilerGeneratedAttribute]
private void set_Symmetric(Symmetric value);
    [CompilerGeneratedAttribute]
public int get_K();
    [CompilerGeneratedAttribute]
private void set_K(int value);
    [CompilerGeneratedAttribute]
public int get_PolyVecBytes();
    [CompilerGeneratedAttribute]
private void set_PolyVecBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PolyCompressedBytes();
    [CompilerGeneratedAttribute]
private void set_PolyCompressedBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PolyVecCompressedBytes();
    [CompilerGeneratedAttribute]
private void set_PolyVecCompressedBytes(int value);
    [CompilerGeneratedAttribute]
public int get_Eta1();
    [CompilerGeneratedAttribute]
private void set_Eta1(int value);
    [CompilerGeneratedAttribute]
public int get_IndCpaPublicKeyBytes();
    [CompilerGeneratedAttribute]
private void set_IndCpaPublicKeyBytes(int value);
    [CompilerGeneratedAttribute]
public int get_IndCpaSecretKeyBytes();
    [CompilerGeneratedAttribute]
private void set_IndCpaSecretKeyBytes(int value);
    [CompilerGeneratedAttribute]
public int get_IndCpaBytes();
    [CompilerGeneratedAttribute]
private void set_IndCpaBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PublicKeyBytes();
    [CompilerGeneratedAttribute]
private void set_PublicKeyBytes(int value);
    [CompilerGeneratedAttribute]
public int get_SecretKeyBytes();
    [CompilerGeneratedAttribute]
private void set_SecretKeyBytes(int value);
    [CompilerGeneratedAttribute]
public int get_CipherTextBytes();
    [CompilerGeneratedAttribute]
private void set_CipherTextBytes(int value);
    [CompilerGeneratedAttribute]
public int get_CryptoBytes();
    [CompilerGeneratedAttribute]
private void set_CryptoBytes(int value);
    [CompilerGeneratedAttribute]
public int get_CryptoSecretKeyBytes();
    [CompilerGeneratedAttribute]
private void set_CryptoSecretKeyBytes(int value);
    [CompilerGeneratedAttribute]
public int get_CryptoPublicKeyBytes();
    [CompilerGeneratedAttribute]
private void set_CryptoPublicKeyBytes(int value);
    [CompilerGeneratedAttribute]
public int get_CryptoCipherTextBytes();
    [CompilerGeneratedAttribute]
private void set_CryptoCipherTextBytes(int value);
    internal void Init(SecureRandom random);
    internal void GenerateKemKeyPair(Byte[]& t, Byte[]& rho, Byte[]& s, Byte[]& hpk, Byte[]& nonce);
    internal void KemEncrypt(Byte[] cipherText, Byte[] sharedSecret, Byte[] pk);
    internal void KemDecrypt(Byte[] sharedSecret, Byte[] cipherText, Byte[] secretKey);
    private void CMov(Byte[] r, Byte[] x, int len, bool b);
    internal void RandomBytes(Byte[] buf, int len);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberIndCpa : object {
    private KyberEngine m_engine;
    private Symmetric m_symmetric;
    private int GenerateMatrixNBlocks { get; }
    internal KyberIndCpa(KyberEngine mEngine);
    private int get_GenerateMatrixNBlocks();
    private void GenerateMatrix(PolyVec[] a, Byte[] seed, bool transposed);
    private int RejectionSampling(Int16[] r, int off, int len, Byte[] buf, int buflen);
    internal void GenerateKeyPair(Byte[]& pk, Byte[]& sk);
    private void PackSecretKey(Byte[]& sk, PolyVec skpv);
    private void UnpackSecretKey(PolyVec skpv, Byte[] sk);
    private void PackPublicKey(Byte[]& pk, PolyVec pkpv, Byte[] seed);
    private void UnpackPublicKey(PolyVec pkpv, Byte[] seed, Byte[] pk);
    public void Encrypt(Byte[] c, Byte[] m, Byte[] pk, Byte[] coins);
    private void PackCipherText(Byte[] r, PolyVec b, Poly v);
    private void UnpackCipherText(PolyVec b, Poly v, Byte[] c);
    internal void Decrypt(Byte[] m, Byte[] c, Byte[] sk);
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberKemExtractor : object {
    private KyberKeyParameters m_key;
    private KyberEngine m_engine;
    public int EncapsulationLength { get; }
    public KyberKemExtractor(KyberKeyParameters privParams);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    public sealed virtual int get_EncapsulationLength();
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberKemGenerator : object {
    private SecureRandom m_random;
    public KyberKemGenerator(SecureRandom random);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberKeyGenerationParameters : KeyGenerationParameters {
    private KyberParameters m_parameters;
    public KyberParameters Parameters { get; }
    public KyberKeyGenerationParameters(SecureRandom random, KyberParameters KyberParameters);
    public KyberParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberKeyPairGenerator : object {
    private KyberParameters KyberParams;
    private SecureRandom random;
    private void Initialize(KeyGenerationParameters param);
    private AsymmetricCipherKeyPair GenKeyPair();
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberKeyParameters : AsymmetricKeyParameter {
    private KyberParameters m_parameters;
    public KyberParameters Parameters { get; }
    internal KyberKeyParameters(bool isPrivate, KyberParameters parameters);
    public KyberParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberParameters : object {
    public static KyberParameters kyber512;
    public static KyberParameters kyber768;
    public static KyberParameters kyber1024;
    public static KyberParameters kyber512_aes;
    public static KyberParameters kyber768_aes;
    public static KyberParameters kyber1024_aes;
    private string m_name;
    private int m_sessionKeySize;
    private KyberEngine m_engine;
    public string Name { get; }
    public int K { get; }
    public int SessionKeySize { get; }
    internal KyberEngine Engine { get; }
    private KyberParameters(string name, int k, int sessionKeySize, bool usingAes);
    private static KyberParameters();
    public string get_Name();
    public int get_K();
    public int get_SessionKeySize();
    internal KyberEngine get_Engine();
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberPrivateKeyParameters : KyberKeyParameters {
    private Byte[] m_s;
    private Byte[] m_hpk;
    private Byte[] m_nonce;
    private Byte[] m_t;
    private Byte[] m_rho;
    internal Byte[] S { get; }
    internal Byte[] Hpk { get; }
    internal Byte[] Nonce { get; }
    internal Byte[] T { get; }
    internal Byte[] Rho { get; }
    public KyberPrivateKeyParameters(KyberParameters parameters, Byte[] s, Byte[] hpk, Byte[] nonce, Byte[] t, Byte[] rho);
    public Byte[] GetEncoded();
    internal Byte[] get_S();
    internal Byte[] get_Hpk();
    internal Byte[] get_Nonce();
    internal Byte[] get_T();
    internal Byte[] get_Rho();
}
public class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.KyberPublicKeyParameters : KyberKeyParameters {
    private Byte[] m_t;
    private Byte[] m_rho;
    internal Byte[] T { get; }
    internal Byte[] Rho { get; }
    public KyberPublicKeyParameters(KyberParameters parameters, Byte[] encoding);
    public KyberPublicKeyParameters(KyberParameters parameters, Byte[] t, Byte[] rho);
    public Byte[] GetEncoded();
    internal Byte[] get_T();
    internal Byte[] get_Rho();
}
internal static class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.Ntt : object {
    internal static Int16[] Zetas;
    internal static Int16[] ZetasInv;
    private static Ntt();
    private static short FactorQMulMont(short a, short b);
    internal static void NTT(Int16[] r);
    internal static void InvNTT(Int16[] r);
    internal static void BaseMult(Int16[] r, int off, short a0, short a1, short b0, short b1, short zeta);
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.Poly : object {
    private KyberEngine m_engine;
    public Int16[] m_coeffs;
    private Symmetric m_symmetric;
    internal Int16[] Coeffs { get; }
    public Poly(KyberEngine mEngine);
    internal Int16[] get_Coeffs();
    internal void GetNoiseEta1(Byte[] seed, byte nonce);
    internal void GetNoiseEta2(Byte[] seed, byte nonce);
    internal void PolyNtt();
    internal void PolyInverseNttToMont();
    internal static void BaseMultMontgomery(Poly r, Poly a, Poly b);
    internal void ToMont();
    internal void Add(Poly a);
    internal void Subtract(Poly a);
    internal void PolyReduce();
    internal void CompressPoly(Byte[] r, int off);
    internal void DecompressPoly(Byte[] CompressedCipherText, int off);
    internal void ToBytes(Byte[] r, int off);
    internal void FromBytes(Byte[] a, int off);
    internal void ToMsg(Byte[] msg);
    internal void FromMsg(Byte[] m);
    internal void CondSubQ();
}
internal class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.PolyVec : object {
    private KyberEngine m_engine;
    internal Poly[] m_vec;
    internal PolyVec(KyberEngine engine);
    internal void Ntt();
    internal void InverseNttToMont();
    internal static void PointwiseAccountMontgomery(Poly r, PolyVec a, PolyVec b, KyberEngine engine);
    internal void Add(PolyVec a);
    internal void Reduce();
    internal void CompressPolyVec(Byte[] r);
    internal void DecompressPolyVec(Byte[] compressedCipherText);
    internal void ToBytes(Byte[] r);
    internal void FromBytes(Byte[] pk);
    private void ConditionalSubQ();
}
internal static class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.Reduce : object {
    internal static short MontgomeryReduce(int a);
    internal static short BarrettReduce(short a);
    internal static short CondSubQ(short a);
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Crystals.Kyber.Symmetric : object {
    internal int XofBlockBytes;
    private Symmetric(int xofBlockBytes);
    internal abstract virtual void Hash_h(Byte[] output, Byte[] input, int outOffset);
    internal abstract virtual void Hash_g(Byte[] output, Byte[] input);
    internal abstract virtual void XofAbsorb(Byte[] seed, byte x, byte y);
    internal abstract virtual void XofSqueezeBlocks(Byte[] output, int outOffset, int outLen);
    internal abstract virtual void Prf(Byte[] output, Byte[] key, byte nonce);
    internal abstract virtual void Kdf(Byte[] output, Byte[] input);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconCodec : object {
    internal Byte[] max_fg_bits;
    internal Byte[] max_FG_bits;
    internal Byte[] max_sig_bits;
    internal int modq_encode(Byte[] outarrsrc, int outarr, int max_out_len, UInt16[] xsrc, int x, UInt32 logn);
    internal int modq_decode(UInt16[] xsrc, int x, UInt32 logn, Byte[] inarrsrc, int inarr, int max_in_len);
    internal int trim_i16_encode(Byte[] outarrsrc, int outarr, int max_out_len, Int16[] xsrc, int x, UInt32 logn, UInt32 bits);
    internal int trim_i16_decode(Int16[] xsrc, int x, UInt32 logn, UInt32 bits, Byte[] inarrsrc, int inarr, int max_in_len);
    internal int trim_i8_encode(Byte[] outarrsrc, int outarr, int max_out_len, SByte[] xsrc, int x, UInt32 logn, UInt32 bits);
    internal int trim_i8_decode(SByte[] xsrc, int x, UInt32 logn, UInt32 bits, Byte[] inarrsrc, int inarr, int max_in_len);
    internal int comp_encode(Byte[] outarrsrc, int outarr, int max_out_len, Int16[] xsrc, int x, UInt32 logn);
    internal int comp_decode(Int16[] xsrc, int x, UInt32 logn, Byte[] inarrsrc, int inarr, int max_in_len);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconCommon : object {
    internal UInt32[] l2bound;
    internal void hash_to_point_vartime(SHAKE256 sc, UInt16[] xsrc, int x, UInt32 logn);
    internal bool is_short(Int16[] s1src, int s1, Int16[] s2src, int s2, UInt32 logn);
    internal bool is_short_half(UInt32 sqn, Int16[] s2src, int s2, UInt32 logn);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconConversions : object {
    internal Byte[] int_to_bytes(int x);
    internal UInt32 bytes_to_uint(Byte[] src, int pos);
    internal Byte[] ulong_to_bytes(ulong x);
    internal ulong bytes_to_ulong(Byte[] src, int pos);
    internal UInt32[] bytes_to_uint_array(Byte[] src, int pos, int num);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconFFT : object {
    private FprEngine fpre;
    internal FalconFFT(FprEngine fprengine);
    internal FalconFPR[] FPC_ADD(FalconFPR a_re, FalconFPR a_im, FalconFPR b_re, FalconFPR b_im);
    internal FalconFPR[] FPC_SUB(FalconFPR a_re, FalconFPR a_im, FalconFPR b_re, FalconFPR b_im);
    internal FalconFPR[] FPC_MUL(FalconFPR a_re, FalconFPR a_im, FalconFPR b_re, FalconFPR b_im);
    internal FalconFPR[] FPC_SQR(FalconFPR d_re, FalconFPR d_im, FalconFPR a_re, FalconFPR a_im);
    internal FalconFPR[] FPC_INV(FalconFPR a_re, FalconFPR a_im);
    internal FalconFPR[] FPC_DIV(FalconFPR a_re, FalconFPR a_im, FalconFPR b_re, FalconFPR b_im);
    internal void FFT(FalconFPR[] fsrc, int f, UInt32 logn);
    internal void iFFT(FalconFPR[] fsrc, int f, UInt32 logn);
    internal void poly_add(FalconFPR[] asrc, int a, FalconFPR[] bsrc, int b, UInt32 logn);
    internal void poly_sub(FalconFPR[] asrc, int a, FalconFPR[] bsrc, int b, UInt32 logn);
    internal void poly_neg(FalconFPR[] asrc, int a, UInt32 logn);
    internal void poly_adj_fft(FalconFPR[] asrc, int a, UInt32 logn);
    internal void poly_mul_fft(FalconFPR[] asrc, int a, FalconFPR[] bsrc, int b, UInt32 logn);
    internal void poly_muladj_fft(FalconFPR[] asrc, int a, FalconFPR[] bsrc, int b, UInt32 logn);
    internal void poly_mulselfadj_fft(FalconFPR[] asrc, int a, UInt32 logn);
    internal void poly_mulconst(FalconFPR[] asrc, int a, FalconFPR x, UInt32 logn);
    internal void poly_div_fft(FalconFPR[] asrc, int a, FalconFPR[] bsrc, int b, UInt32 logn);
    internal void poly_invnorm2_fft(FalconFPR[] dsrc, int d, FalconFPR[] asrc, int a, FalconFPR[] bsrc, int b, UInt32 logn);
    internal void poly_add_muladj_fft(FalconFPR[] dsrc, int d, FalconFPR[] Fsrc, int F, FalconFPR[] Gsrc, int G, FalconFPR[] fsrc, int f, FalconFPR[] gsrc, int g, UInt32 logn);
    internal void poly_mul_autoadj_fft(FalconFPR[] asrc, int a, FalconFPR[] bsrc, int b, UInt32 logn);
    internal void poly_div_autoadj_fft(FalconFPR[] asrc, int a, FalconFPR[] bsrc, int b, UInt32 logn);
    internal void poly_LDL_fft(FalconFPR[] g00src, int g00, FalconFPR[] g01src, int g01, FalconFPR[] g11src, int g11, UInt32 logn);
    internal void poly_LDLmv_fft(FalconFPR[] d11src, int d11, FalconFPR[] l10src, int l10, FalconFPR[] g00src, int g00, FalconFPR[] g01src, int g01, FalconFPR[] g11src, int g11, UInt32 logn);
    internal void poly_split_fft(FalconFPR[] f0src, int f0, FalconFPR[] f1src, int f1, FalconFPR[] fsrc, int f, UInt32 logn);
    internal void poly_merge_fft(FalconFPR[] fsrc, int f, FalconFPR[] f0src, int f0, FalconFPR[] f1src, int f1, UInt32 logn);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconFPR : ValueType {
    internal double v;
    internal FalconFPR(double v);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconKeygen : object {
    private FprEngine fpre;
    private FalconFFT ffte;
    private FalconSmallPrime[] PRIMES;
    private FalconCodec codec;
    private FalconVrfy vrfy;
    internal UInt16[] REV10;
    internal UInt64[] gauss_1024_12289;
    internal Int32[] MAX_BL_SMALL;
    internal Int32[] MAX_BL_LARGE;
    internal Int32[] BITLENGTH_avg;
    internal Int32[] BITLENGTH_std;
    internal static int DEPTH_INT_FG;
    internal FalconKeygen(FalconCodec codec, FalconVrfy vrfy);
    internal UInt32 modp_set(int x, UInt32 p);
    internal int modp_norm(UInt32 x, UInt32 p);
    internal UInt32 modp_ninv31(UInt32 p);
    internal UInt32 modp_R(UInt32 p);
    internal UInt32 modp_add(UInt32 a, UInt32 b, UInt32 p);
    internal UInt32 modp_sub(UInt32 a, UInt32 b, UInt32 p);
    internal UInt32 modp_montymul(UInt32 a, UInt32 b, UInt32 p, UInt32 p0i);
    internal UInt32 modp_R2(UInt32 p, UInt32 p0i);
    internal UInt32 modp_Rx(UInt32 x, UInt32 p, UInt32 p0i, UInt32 R2);
    internal UInt32 modp_div(UInt32 a, UInt32 b, UInt32 p, UInt32 p0i, UInt32 R);
    internal void modp_mkgm2(UInt32[] gmsrc, int gm, UInt32[] igmsrc, int igm, UInt32 logn, UInt32 g, UInt32 p, UInt32 p0i);
    internal void modp_NTT2_ext(UInt32[] asrc, int a, int stride, UInt32[] gmsrc, int gm, UInt32 logn, UInt32 p, UInt32 p0i);
    internal void modp_iNTT2_ext(UInt32[] asrc, int a, int stride, UInt32[] igmsrc, int igm, UInt32 logn, UInt32 p, UInt32 p0i);
    internal void modp_NTT2(UInt32[] asrc, int a, UInt32[] gmsrc, int gm, UInt32 logn, UInt32 p, UInt32 p0i);
    internal void modp_iNTT2(UInt32[] asrc, int a, UInt32[] igmsrc, int igm, UInt32 logn, UInt32 p, UInt32 p0i);
    internal void modp_poly_rec_res(UInt32[] fsrc, int f, UInt32 logn, UInt32 p, UInt32 p0i, UInt32 R2);
    internal UInt32 zint_sub(UInt32[] asrc, int a, UInt32[] bsrc, int b, int len, UInt32 ctl);
    internal UInt32 zint_mul_small(UInt32[] msrc, int m, int mlen, UInt32 x);
    internal UInt32 zint_mod_small_uint(UInt32[] dsrc, int d, int dlen, UInt32 p, UInt32 p0i, UInt32 R2);
    internal UInt32 zint_mod_small_signed(UInt32[] dsrc, int d, int dlen, UInt32 p, UInt32 p0i, UInt32 R2, UInt32 Rx);
    internal void zint_add_mul_small(UInt32[] xsrc, int x, UInt32[] ysrc, int y, int len, UInt32 s);
    internal void zint_norm_zero(UInt32[] xsrc, int x, UInt32[] psrc, int p, int len);
    internal void zint_rebuild_CRT(UInt32[] xxsrc, int xx, int xlen, int xstride, int num, FalconSmallPrime[] primes, int normalize_signed, UInt32[] tmpsrc, int tmp);
    internal void zint_negate(UInt32[] asrc, int a, int len, UInt32 ctl);
    internal UInt32 zint_co_reduce(UInt32[] asrc, int a, UInt32[] bsrc, int b, int len, long xa, long xb, long ya, long yb);
    internal void zint_finish_mod(UInt32[] asrc, int a, int len, UInt32[] msrc, int m, UInt32 neg);
    internal void zint_co_reduce_mod(UInt32[] asrc, int a, UInt32[] bsrc, int b, UInt32[] msrc, int m, int len, UInt32 m0i, long xa, long xb, long ya, long yb);
    internal int zint_bezout(UInt32[] usrc, int u, UInt32[] vsrc, int v, UInt32[] xsrc, int x, UInt32[] ysrc, int y, int len, UInt32[] tmpsrc, int tmp);
    internal void zint_add_scaled_mul_small(UInt32[] xsrc, int x, int xlen, UInt32[] ysrc, int y, int ylen, int k, UInt32 sch, UInt32 scl);
    internal void zint_sub_scaled(UInt32[] xsrc, int x, int xlen, UInt32[] ysrc, int y, int ylen, UInt32 sch, UInt32 scl);
    internal int zint_one_to_plain(UInt32[] xsrc, int x);
    internal void poly_big_to_fp(FalconFPR[] dsrc, int d, UInt32[] fsrc, int f, int flen, int fstride, UInt32 logn);
    internal int poly_big_to_small(SByte[] dsrc, int d, UInt32[] ssrc, int s, int lim, UInt32 logn);
    internal void poly_sub_scaled(UInt32[] Fsrc, int F, int Flen, int Fstride, UInt32[] fsrc, int f, int flen, int fstride, Int32[] ksrc, int k, UInt32 sch, UInt32 scl, UInt32 logn);
    internal void poly_sub_scaled_ntt(UInt32[] Fsrc, int F, int Flen, int Fstride, UInt32[] fsrc, int f, int flen, int fstride, Int32[] ksrc, int k, UInt32 sch, UInt32 scl, UInt32 logn, UInt32[] tmpsrc, int tmp);
    internal ulong get_rng_u64(SHAKE256 rng);
    internal int mkgauss(SHAKE256 rng, UInt32 logn);
    internal UInt32 poly_small_sqnorm(SByte[] fsrc, int f, UInt32 logn);
    internal void poly_small_to_fp(FalconFPR[] xsrc, int x, SByte[] fsrc, int f, UInt32 logn);
    internal void make_fg_step(UInt32[] datasrc, int data, UInt32 logn, UInt32 depth, int in_ntt, int out_ntt);
    internal void make_fg(UInt32[] datasrc, int data, SByte[] fsrc, int f, SByte[] gsrc, int g, UInt32 logn, UInt32 depth, int out_ntt);
    internal int solve_NTRU_deepest(UInt32 logn_top, SByte[] fsrc, int f, SByte[] gsrc, int g, UInt32[] tmpsrc, int tmp);
    internal int solve_NTRU_intermediate(UInt32 logn_top, SByte[] fsrc, int f, SByte[] gsrc, int g, UInt32 depth, UInt32[] tmpsrc, int tmp);
    internal int solve_NTRU_binary_depth1(UInt32 logn_top, SByte[] fsrc, int f, SByte[] gsrc, int g, UInt32[] tmpsrc, int tmp);
    internal int solve_NTRU_binary_depth0(UInt32 logn, SByte[] fsrc, int f, SByte[] gsrc, int g, UInt32[] tmpsrc, int tmp);
    internal int solve_NTRU(UInt32 logn, SByte[] Fsrc, int F, SByte[] Gsrc, int G, SByte[] fsrc, int f, SByte[] gsrc, int g, int lim, UInt32[] tmpsrc, int tmp);
    internal void poly_small_mkgauss(SHAKE256 rng, SByte[] fsrc, int f, UInt32 logn);
    internal void keygen(SHAKE256 rng, SByte[] fsrc, int f, SByte[] gsrc, int g, SByte[] Fsrc, int F, SByte[] Gsrc, int G, UInt16[] hsrc, int h, UInt32 logn);
}
public class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconKeyGenerationParameters : KeyGenerationParameters {
    private FalconParameters parameters;
    public FalconParameters Parameters { get; }
    public FalconKeyGenerationParameters(SecureRandom random, FalconParameters parameters);
    public FalconParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconKeyPairGenerator : object {
    private FalconKeyGenerationParameters parameters;
    private SecureRandom random;
    private FalconNist nist;
    private UInt32 logn;
    private UInt32 noncelen;
    private int pk_size;
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconKeyParameters : AsymmetricKeyParameter {
    private FalconParameters m_parameters;
    public FalconParameters Parameters { get; }
    internal FalconKeyParameters(bool isprivate, FalconParameters parameters);
    public FalconParameters get_Parameters();
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconNist : object {
    private FalconCodec codec;
    private FalconVrfy vrfy;
    private FalconCommon common;
    private SecureRandom random;
    private UInt32 logn;
    private UInt32 noncelen;
    private int CRYPTO_BYTES;
    private int CRYPTO_PUBLICKEYBYTES;
    private int CRYPTO_SECRETKEYBYTES;
    internal UInt32 NonceLength { get; }
    internal UInt32 LogN { get; }
    internal int CryptoBytes { get; }
    internal FalconNist(SecureRandom random, UInt32 logn, UInt32 noncelen);
    internal UInt32 get_NonceLength();
    internal UInt32 get_LogN();
    internal int get_CryptoBytes();
    internal int crypto_sign_keypair(Byte[]& pk, Byte[]& fEnc, Byte[]& gEnc, Byte[]& FEnc);
    internal Byte[] crypto_sign(bool attached, Byte[] sm, Byte[] msrc, int m, UInt32 mlen, Byte[] sksrc, int sk);
    internal int crypto_sign_open(bool attached, Byte[] sig_encoded, Byte[] nonce, Byte[] m, Byte[] pksrc, int pk);
}
public class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconParameters : object {
    public static FalconParameters falcon_512;
    public static FalconParameters falcon_1024;
    private string name;
    private UInt32 logn;
    private UInt32 nonce_length;
    public int LogN { get; }
    public int NonceLength { get; }
    public string Name { get; }
    private FalconParameters(string name, UInt32 logn, UInt32 nonce_length);
    private static FalconParameters();
    public int get_LogN();
    public int get_NonceLength();
    public string get_Name();
}
public class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconPrivateKeyParameters : FalconKeyParameters {
    private Byte[] pk;
    private Byte[] f;
    private Byte[] g;
    private Byte[] F;
    public FalconPrivateKeyParameters(FalconParameters parameters, Byte[] f, Byte[] g, Byte[] F, Byte[] pk_encoded);
    public Byte[] GetEncoded();
    public Byte[] GetPublicKey();
    public Byte[] GetSpolyLittleF();
    public Byte[] GetG();
    public Byte[] GetSpolyBigF();
}
public class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconPublicKeyParameters : FalconKeyParameters {
    private Byte[] publicKey;
    public FalconPublicKeyParameters(FalconParameters parameters, Byte[] h);
    public Byte[] GetEncoded();
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconRNG : object {
    private Byte[] bd;
    private Byte[] sd;
    private int ptr;
    private FalconConversions convertor;
    internal void prng_init(SHAKE256 src);
    private void QROUND(UInt32[] state, int a, int b, int c, int d);
    private void prng_refill();
    internal void prng_get_bytes(Byte[] dstsrc, int dst, int len);
    internal ulong prng_get_u64();
    internal UInt32 prng_get_u8();
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconSign : object {
    private FalconFFT ffte;
    private FprEngine fpre;
    private FalconCommon common;
    internal FalconSign(FalconCommon common);
    internal UInt32 ffLDL_treesize(UInt32 logn);
    internal void ffLDL_fft_inner(FalconFPR[] treesrc, int tree, FalconFPR[] g0src, int g0, FalconFPR[] g1src, int g1, UInt32 logn, FalconFPR[] tmpsrc, int tmp);
    internal void ffLDL_fft(FalconFPR[] treesrc, int tree, FalconFPR[] g00src, int g00, FalconFPR[] g01src, int g01, FalconFPR[] g11src, int g11, UInt32 logn, FalconFPR[] tmpsrc, int tmp);
    internal void ffLDL_binary_normalize(FalconFPR[] treesrc, int tree, UInt32 orig_logn, UInt32 logn);
    internal void smallints_to_fpr(FalconFPR[] rsrc, int r, SByte[] tsrc, int t, UInt32 logn);
    private int skoff_b00(UInt32 logn);
    private int skoff_b01(UInt32 logn);
    private int skoff_b10(UInt32 logn);
    private int skoff_b11(UInt32 logn);
    private int skoff_tree(UInt32 logn);
    internal void ffSampling_fft_dyntree(SamplerZ samp, FalconFPR[] t0src, int t0, FalconFPR[] t1src, int t1, FalconFPR[] g00src, int g00, FalconFPR[] g01src, int g01, FalconFPR[] g11src, int g11, UInt32 orig_logn, UInt32 logn, FalconFPR[] tmpsrc, int tmp);
    internal void ffSampling_fft(SamplerZ samp, FalconFPR[] z0src, int z0, FalconFPR[] z1src, int z1, FalconFPR[] treesrc, int tree, FalconFPR[] t0src, int t0, FalconFPR[] t1src, int t1, UInt32 logn, FalconFPR[] tmpsrc, int tmp);
    internal int do_sign_tree(SamplerZ samp, Int16[] s2src, int s2, FalconFPR[] ex_keysrc, int expanded_key, UInt16[] hmsrc, int hm, UInt32 logn, FalconFPR[] tmpsrc, int tmp);
    internal int do_sign_dyn(SamplerZ samp, Int16[] s2src, int s2, SByte[] fsrc, int f, SByte[] gsrc, int g, SByte[] Fsrc, int F, SByte[] Gsrc, int G, UInt16[] hmsrc, int hm, UInt32 logn, FalconFPR[] tmpsrc, int tmp);
    internal void sign_tree(Int16[] sigsrc, int sig, SHAKE256 rng, FalconFPR[] ex_keysrc, int expanded_key, UInt16[] hmsrc, int hm, UInt32 logn, FalconFPR[] tmpsrc, int tmp);
    internal void sign_dyn(Int16[] sigsrc, int sig, SHAKE256 rng, SByte[] fsrc, int f, SByte[] gsrc, int g, SByte[] Fsrc, int F, SByte[] Gsrc, int G, UInt16[] hmsrc, int hm, UInt32 logn, FalconFPR[] tmpsrc, int tmp);
}
public class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconSigner : object {
    private Byte[] encodedkey;
    private FalconNist nist;
    public sealed virtual void Init(bool forSigning, ICipherParameters param);
    public sealed virtual Byte[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, Byte[] signature);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconSmallPrime : object {
    internal UInt32 p;
    internal UInt32 g;
    internal UInt32 s;
    internal FalconSmallPrime(UInt32 p, UInt32 g, UInt32 s);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconSmallPrimes : object {
    internal FalconSmallPrime[] PRIMES;
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FalconVrfy : object {
    private FalconCommon common;
    private static int Q;
    private static int Q0I;
    private static int R;
    private static int R2;
    internal UInt16[] GMb;
    internal UInt16[] iGMb;
    internal FalconVrfy(FalconCommon common);
    internal UInt32 mq_conv_small(int x);
    internal UInt32 mq_add(UInt32 x, UInt32 y);
    internal UInt32 mq_sub(UInt32 x, UInt32 y);
    internal UInt32 mq_rshift1(UInt32 x);
    internal UInt32 mq_montymul(UInt32 x, UInt32 y);
    internal UInt32 mq_montysqr(UInt32 x);
    internal UInt32 mq_div_12289(UInt32 x, UInt32 y);
    internal void mq_NTT(UInt16[] asrc, int a, UInt32 logn);
    internal void mq_iNTT(UInt16[] asrc, int a, UInt32 logn);
    internal void mq_poly_tomonty(UInt16[] fsrc, int f, UInt32 logn);
    internal void mq_poly_montymul_ntt(UInt16[] fsrc, int f, UInt16[] gsrc, int g, UInt32 logn);
    internal void mq_poly_sub(UInt16[] fsrc, int f, UInt16[] gsrc, int g, UInt32 logn);
    internal void to_ntt_monty(UInt16[] hsrc, int h, UInt32 logn);
    internal bool verify_raw(UInt16[] c0src, int c0, Int16[] s2src, int s2, UInt16[] hsrc, int h, UInt32 logn, UInt16[] tmpsrc, int tmp);
    internal int compute_public(UInt16[] hsrc, int h, SByte[] fsrc, int f, SByte[] gsrc, int g, UInt32 logn, UInt16[] tmpsrc, int tmp);
    internal int complete_private(SByte[] Gsrc, int G, SByte[] fsrc, int f, SByte[] gsrc, int g, SByte[] Fsrc, int F, UInt32 logn, UInt16[] tmpsrc, int tmp);
    internal int is_invertible(Int16[] s2src, int s2, UInt32 logn, UInt16[] tmpsrc, int tmp);
    internal int verify_recover(UInt16[] hsrc, int h, UInt16[] c0src, int c0, Int16[] s1src, int s1, Int16[] s2src, int s2, UInt32 logn, UInt16[] tmpsrc, int tmp);
    internal int count_nttzero(Int16[] sigsrc, int sig, UInt32 logn, UInt16[] tmpsrc, int tmp);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.FprEngine : object {
    internal FalconFPR[] fpr_gm_tab;
    internal FalconFPR[] fpr_p2_tab;
    internal FalconFPR fpr_log2;
    internal FalconFPR fpr_inv_log2;
    internal FalconFPR fpr_bnorm_max;
    internal FalconFPR fpr_zero;
    internal FalconFPR fpr_one;
    internal FalconFPR fpr_two;
    internal FalconFPR fpr_onehalf;
    internal FalconFPR fpr_invsqrt2;
    internal FalconFPR fpr_invsqrt8;
    internal FalconFPR fpr_ptwo31;
    internal FalconFPR fpr_ptwo31m1;
    internal FalconFPR fpr_mtwo31m1;
    internal FalconFPR fpr_ptwo63m1;
    internal FalconFPR fpr_mtwo63m1;
    internal FalconFPR fpr_ptwo63;
    internal FalconFPR fpr_q;
    internal FalconFPR fpr_inverse_of_q;
    internal FalconFPR fpr_inv_2sqrsigma0;
    internal FalconFPR[] fpr_inv_sigma;
    internal FalconFPR[] fpr_sigma_min;
    internal FalconFPR Fpr(double v);
    internal FalconFPR fpr_of(long i);
    internal long fpr_rint(FalconFPR x);
    internal long fpr_floor(FalconFPR x);
    internal long fpr_trunc(FalconFPR x);
    internal FalconFPR fpr_add(FalconFPR x, FalconFPR y);
    internal FalconFPR fpr_sub(FalconFPR x, FalconFPR y);
    internal FalconFPR fpr_neg(FalconFPR x);
    internal FalconFPR fpr_half(FalconFPR x);
    internal FalconFPR fpr_double(FalconFPR x);
    internal FalconFPR fpr_mul(FalconFPR x, FalconFPR y);
    internal FalconFPR fpr_sqr(FalconFPR x);
    internal FalconFPR fpr_inv(FalconFPR x);
    internal FalconFPR fpr_div(FalconFPR x, FalconFPR y);
    internal FalconFPR fpr_sqrt(FalconFPR x);
    internal bool fpr_lt(FalconFPR x, FalconFPR y);
    internal ulong fpr_expm_p63(FalconFPR x, FalconFPR ccs);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.SamplerZ : object {
    private FalconRNG p;
    private FalconFPR sigma_min;
    private FprEngine fpre;
    internal SamplerZ(FalconRNG p, FalconFPR sigma_min, FprEngine fpre);
    internal int Sample(FalconFPR mu, FalconFPR isigma);
    private int gaussian0_sampler(FalconRNG p);
    private int BerExp(FalconRNG p, FalconFPR x, FalconFPR ccs);
    private int sampler(FalconFPR mu, FalconFPR isigma);
}
internal class Org.BouncyCastle.Pqc.Crypto.Falcon.SHAKE256 : object {
    private UInt64[] A;
    private Byte[] dubf;
    private ulong dptr;
    private UInt64[] RC;
    private void process_block(UInt64[] A);
    internal void i_shake256_init();
    internal void i_shake256_inject(Byte[] insrc, int inarray, int len);
    internal void i_shake256_flip();
    internal void i_shake256_extract(Byte[] outsrc, int outarray, int len);
}
public class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoEngine : object {
    internal static int nbar;
    private static int mbar;
    private static int len_seedA;
    private static int len_z;
    private static int len_chi;
    private static int len_seedA_bytes;
    private static int len_z_bytes;
    private static int len_chi_bytes;
    private int D;
    private int q;
    private int n;
    private int B;
    private int len_sk_bytes;
    private int len_pk_bytes;
    private int len_ct_bytes;
    private Int16[] T_chi;
    private int len_mu;
    private int len_seedSE;
    private int len_s;
    private int len_k;
    private int len_pkh;
    private int len_ss;
    private int len_mu_bytes;
    private int len_seedSE_bytes;
    private int len_s_bytes;
    private int len_k_bytes;
    private int len_pkh_bytes;
    private int len_ss_bytes;
    private IDigest digest;
    private FrodoMatrixGenerator gen;
    public int CipherTextSize { get; }
    public int SessionKeySize { get; }
    public int PrivateKeySize { get; }
    public int PublicKeySize { get; }
    public FrodoEngine(int n, int D, int B, Int16[] cdf_table, IDigest digest, FrodoMatrixGenerator mGen);
    private static FrodoEngine();
    public int get_CipherTextSize();
    public int get_SessionKeySize();
    public int get_PrivateKeySize();
    public int get_PublicKeySize();
    private short Sample(short r);
    private Int16[] SampleMatrix(Int16[] r, int offset, int n1, int n2);
    private Int16[] MatrixTranspose(Int16[] X, int n1, int n2);
    private Int16[] MatrixMul(Int16[] X, int Xrow, int Xcol, Int16[] Y, int Ycol);
    private Int16[] MatrixAdd(Int16[] X, Int16[] Y, int n1, int m1);
    private Byte[] FrodoPack(Int16[] C);
    public void kem_keypair(Byte[] pk, Byte[] sk, SecureRandom random);
    private Int16[] FrodoUnpack(Byte[] input, int n1, int n2);
    private Int16[] Encode(Byte[] k);
    public void kem_enc(Byte[] ct, Byte[] ss, Byte[] pk, SecureRandom random);
    private Int16[] MatrixSub(Int16[] X, Int16[] Y, int n1, int n2);
    private Byte[] Decode(Int16[] input);
    private short CTVerify(Int16[] a1, Int16[] a2, Int16[] b1, Int16[] b2);
    private Byte[] CTSelect(Byte[] a, Byte[] b, short selector);
    public void kem_dec(Byte[] ss, Byte[] ct, Byte[] sk);
}
public class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoKEMExtractor : object {
    private FrodoEngine engine;
    private FrodoKeyParameters key;
    public int EncapsulationLength { get; }
    public FrodoKEMExtractor(FrodoKeyParameters privParams);
    private void InitCipher(FrodoParameters param);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    public sealed virtual int get_EncapsulationLength();
}
public class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoKEMGenerator : object {
    private SecureRandom sr;
    public FrodoKEMGenerator(SecureRandom random);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
}
public class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoKeyGenerationParameters : KeyGenerationParameters {
    private FrodoParameters parameters;
    public FrodoParameters Parameters { get; }
    public FrodoKeyGenerationParameters(SecureRandom random, FrodoParameters frodoParameters);
    public FrodoParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoKeyPairGenerator : object {
    private FrodoKeyGenerationParameters frodoParams;
    private int n;
    private int D;
    private int B;
    private SecureRandom random;
    private void Initialize(KeyGenerationParameters param);
    private AsymmetricCipherKeyPair GenKeyPair();
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoKeyParameters : AsymmetricKeyParameter {
    private FrodoParameters m_parameters;
    public FrodoParameters Parameters { get; }
    internal FrodoKeyParameters(bool isPrivate, FrodoParameters parameters);
    public FrodoParameters get_Parameters();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoMatrixGenerator : object {
    private int n;
    private int q;
    public FrodoMatrixGenerator(int n, int q);
    internal abstract virtual Int16[] GenMatrix(Byte[] seedA);
}
public class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoParameters : object {
    private static Int16[] cdf_table640;
    private static Int16[] cdf_table976;
    private static Int16[] cdf_table1344;
    public static FrodoParameters frodokem19888r3;
    public static FrodoParameters frodokem19888shaker3;
    public static FrodoParameters frodokem31296r3;
    public static FrodoParameters frodokem31296shaker3;
    public static FrodoParameters frodokem43088r3;
    public static FrodoParameters frodokem43088shaker3;
    private string name;
    private int n;
    private int d;
    private int b;
    private Int16[] cdf_table;
    private IDigest digest;
    private FrodoMatrixGenerator mGen;
    private int defaultKeySize;
    private FrodoEngine engine;
    public FrodoEngine Engine { get; }
    public int N { get; }
    public string Name { get; }
    public int D { get; }
    public int B { get; }
    public Int16[] CdfTable { get; }
    public IDigest Digest { get; }
    public int DefaultKeySize { get; }
    public FrodoMatrixGenerator MGen { get; }
    private FrodoParameters(string name, int n, int d, int b, Int16[] cdf_table, IDigest digest, FrodoMatrixGenerator mGen);
    private static FrodoParameters();
    public FrodoEngine get_Engine();
    public int get_N();
    public string get_Name();
    public int get_D();
    public int get_B();
    public Int16[] get_CdfTable();
    public IDigest get_Digest();
    public int get_DefaultKeySize();
    public FrodoMatrixGenerator get_MGen();
}
public class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoPrivateKeyParameters : FrodoKeyParameters {
    internal Byte[] privateKey;
    public FrodoPrivateKeyParameters(FrodoParameters parameters, Byte[] privateKey);
    public Byte[] GetPrivateKey();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Frodo.FrodoPublicKeyParameters : FrodoKeyParameters {
    internal Byte[] m_publicKey;
    public FrodoPublicKeyParameters(FrodoParameters parameters, Byte[] publicKey);
    public Byte[] GetPublicKey();
    public Byte[] GetEncoded();
}
internal class Org.BouncyCastle.Pqc.Crypto.Hqc.FastFourierTransform : object {
    internal static void FFT(Int32[] output, Int32[] elements, int noCoefs, int fft);
    internal static void ComputeFFTBetas(Int32[] betas, int m);
    internal static void ComputeSubsetSum(Int32[] subsetSum, Int32[] set, int size);
    internal static void ComputeRadix(Int32[] f0, Int32[] f1, Int32[] f, int mf, int fft);
    internal static void ComputeRadixBig(Int32[] f0, Int32[] f1, Int32[] f, int mf, int fft);
    internal static void ComputeFFTRec(Int32[] output, Int32[] func, int noCoeffs, int noOfBetas, int noCoeffsPlus, Int32[] betaSet, int fft, int m);
    internal static void FastFourierTransformGetError(Byte[] errorSet, Int32[] input, int mSize, Int32[] logArrays);
}
internal class Org.BouncyCastle.Pqc.Crypto.Hqc.GF2PolynomialCalculator : object {
    private int _vecNSize64;
    private int _paramN;
    private long _redMask;
    public GF2PolynomialCalculator(int vecNSize64, int paramN, ulong redMask);
    internal void MultLongs(Int64[] res, Int64[] a, Int64[] b);
    private void base_mul(Int64[] c, int cOffset, long a, long b);
    private void karatsuba_add1(Int64[] alh, int alhOffset, Int64[] blh, int blhOffset, Int64[] a, int aOffset, Int64[] b, int bOffset, int size_l, int size_h);
    private void karatsuba_add2(Int64[] o, int oOffset, Int64[] tmp1, int tmp1Offset, Int64[] tmp2, int tmp2Offset, int size_l, int size_h);
    private void karatsuba(Int64[] o, int oOffset, Int64[] a, int aOffset, Int64[] b, int bOffset, int size, Int64[] stack, int stackOffset);
    private void reduce(Int64[] o, Int64[] a);
    internal static void AddLongs(Int64[] res, Int64[] a, Int64[] b);
}
internal class Org.BouncyCastle.Pqc.Crypto.Hqc.GFCalculator : object {
    private static Int32[] exp;
    private static Int32[] log;
    private static GFCalculator();
    internal static int mult(int a, int b);
    internal static int mod(int a);
    internal static int inverse(int a);
}
internal class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcEngine : object {
    private int n;
    private int n1;
    private int n2;
    private int k;
    private int delta;
    private int w;
    private int wr;
    private int we;
    private int g;
    private int rejectionThreshold;
    private int fft;
    private int mulParam;
    private int SEED_SIZE;
    private byte G_FCT_DOMAIN;
    private byte H_FCT_DOMAIN;
    private byte K_FCT_DOMAIN;
    private int N_BYTE;
    private int n1n2;
    private int N_BYTE_64;
    private int K_BYTE;
    private int K_BYTE_64;
    private int N1_BYTE_64;
    private int N1N2_BYTE_64;
    private int N1N2_BYTE;
    private int N1_BYTE;
    private int SALT_SIZE_BYTES;
    private Int32[] generatorPoly;
    private int SHA512_BYTES;
    private ulong RED_MASK;
    private GF2PolynomialCalculator gfCalculator;
    public HqcEngine(int n, int n1, int n2, int k, int g, int delta, int w, int wr, int we, int rejectionThreshold, int fft, Int32[] generatorPoly);
    public void GenKeyPair(Byte[] pk, Byte[] sk, Byte[] seed);
    public void Encaps(Byte[] u, Byte[] v, Byte[] K, Byte[] d, Byte[] pk, Byte[] seed, Byte[] salt);
    public void Decaps(Byte[] ss, Byte[] ct, Byte[] sk);
    internal int GetSessionKeySize();
    private void Encrypt(Byte[] u, Int64[] v, Int64[] h, Byte[] s, Byte[] m, Byte[] theta);
    private void Decrypt(Byte[] output, Byte[] m, Byte[] u, Byte[] v, Int64[] y);
    private void GenerateRandomFixedWeight(Int64[] output, HqcKeccakRandomGenerator random, int weight);
    private void GeneratePublicKeyH(Int64[] output, HqcKeccakRandomGenerator random);
    private void ExtractPublicKeys(Int64[] h, Byte[] s, Byte[] pk);
    private void ExtractKeysFromSecretKeys(Int64[] x, Int64[] y, Byte[] pk, Byte[] sk);
    private static void ExtractCiphertexts(Byte[] u, Byte[] v, Byte[] d, Byte[] salt, Byte[] ct);
}
internal class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcKeccakRandomGenerator : object {
    private static UInt64[] KeccakRoundConstants;
    private UInt64[] state;
    private Byte[] dataQueue;
    private int rate;
    private int fixedOutputLength;
    public HqcKeccakRandomGenerator(int bitLength);
    private static HqcKeccakRandomGenerator();
    private void Init(int bitLength);
    private void InitSponge(int rate);
    private void KeccakIncAbsorb(Byte[] input, int inputLen);
    private void KeccakIncFinalize(int p);
    private void KeccakIncSqueeze(Byte[] output, int outLen);
    public void Squeeze(Byte[] output, int outLen);
    public void RandomGeneratorInit(Byte[] entropyInput, Byte[] personalizationString, int entropyLen, int perLen);
    public void SeedExpanderInit(Byte[] seed, int seedLen);
    public void ExpandSeed(Byte[] output, int outLen);
    public void SHAKE256_512_ds(Byte[] output, Byte[] input, int inLen, Byte[] domain);
}
public class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcKemExtractor : object {
    private HqcEngine engine;
    private HqcKeyParameters key;
    public int EncapsulationLength { get; }
    public HqcKemExtractor(HqcPrivateKeyParameters privParams);
    private void InitCipher(HqcParameters param);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    public sealed virtual int get_EncapsulationLength();
}
public class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcKemGenerator : object {
    private SecureRandom sr;
    public HqcKemGenerator(SecureRandom random);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
}
public class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcKeyGenerationParameters : KeyGenerationParameters {
    private HqcParameters param;
    public HqcParameters Parameters { get; }
    public HqcKeyGenerationParameters(SecureRandom random, HqcParameters param);
    public HqcParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcKeyPairGenerator : object {
    private int n;
    private int k;
    private int delta;
    private int w;
    private int wr;
    private int we;
    private int N_BYTE;
    private HqcKeyGenerationParameters hqcKeyGenerationParameters;
    private SecureRandom random;
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    public AsymmetricCipherKeyPair GenerateKeyPairWithSeed(Byte[] seed);
    public sealed virtual void Init(KeyGenerationParameters parameters);
    private AsymmetricCipherKeyPair GenKeyPair(Byte[] seed);
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcKeyParameters : AsymmetricKeyParameter {
    private HqcParameters m_parameters;
    public HqcParameters Parameters { get; }
    internal HqcKeyParameters(bool isPrivate, HqcParameters parameters);
    public HqcParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcParameters : object {
    public static HqcParameters hqc128;
    public static HqcParameters hqc192;
    public static HqcParameters hqc256;
    private string name;
    private int n;
    private int n1;
    private int n2;
    private int k;
    private int g;
    private int delta;
    private int w;
    private int wr;
    private int we;
    private int utilRejectionThreshold;
    private int fft;
    private Int32[] generatorPoly;
    private int defaultKeySize;
    internal static int PARAM_M;
    internal static int GF_MUL_ORDER;
    private HqcEngine hqcEngine;
    public int N { get; }
    public int K { get; }
    public int Delta { get; }
    public int W { get; }
    public int Wr { get; }
    public int We { get; }
    public int N1 { get; }
    public int N2 { get; }
    public int Sha512Bytes { get; }
    public int NBytes { get; }
    public int N1n2Bytes { get; }
    public int DefaultKeySize { get; }
    public int SaltSizeBytes { get; }
    internal HqcEngine Engine { get; }
    private HqcParameters(string name, int n, int n1, int n2, int k, int g, int delta, int w, int wr, int we, int utilRejectionThreshold, int fft, Int32[] generatorPoly, int defaultKeySize);
    private static HqcParameters();
    public int get_N();
    public int get_K();
    public int get_Delta();
    public int get_W();
    public int get_Wr();
    public int get_We();
    public int get_N1();
    public int get_N2();
    public int get_Sha512Bytes();
    public int get_NBytes();
    public int get_N1n2Bytes();
    public int get_DefaultKeySize();
    public int get_SaltSizeBytes();
    internal HqcEngine get_Engine();
}
public class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcPrivateKeyParameters : HqcKeyParameters {
    private Byte[] sk;
    public Byte[] PrivateKey { get; }
    public HqcPrivateKeyParameters(HqcParameters param, Byte[] sk);
    public Byte[] get_PrivateKey();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Hqc.HqcPublicKeyParameters : HqcKeyParameters {
    private Byte[] pk;
    public Byte[] PublicKey { get; }
    public HqcPublicKeyParameters(HqcParameters param, Byte[] pk);
    public Byte[] get_PublicKey();
    public Byte[] GetEncoded();
}
internal class Org.BouncyCastle.Pqc.Crypto.Hqc.ReedMuller : object {
    private static void EncodeSub(Codeword codeword, int m);
    private static void HadamardTransform(Int32[] srcCode, Int32[] desCode);
    private static void ExpandThenSum(Int32[] desCode, Codeword[] srcCode, int off, int mulParam);
    private static int FindPeaks(Int32[] input);
    private static int Bit0Mask(int b);
    public static void Encode(Int64[] codeword, Byte[] m, int n1, int mulParam);
    public static void Decode(Byte[] m, Int64[] codeword, int n1, int mulParam);
}
internal class Org.BouncyCastle.Pqc.Crypto.Hqc.ReedSolomon : object {
    private static Int32[0...,0...] alpha128;
    private static Int32[0...,0...] alpha192;
    private static Int32[0...,0...] alpha256;
    private static Int32[] logArrays;
    private static Int32[] expArrays;
    private static ReedSolomon();
    internal static void Encode(Byte[] codeWord, Byte[] message, int mBitSize, int n1, int paramK, int paramG, Int32[] rsPoly);
    internal static void Decode(Byte[] message, Byte[] codeWord, int n1, int fft, int delta, int paramK, int paramG);
    private static void ComputeSyndromes(Int32[] syndromes, Byte[] codeWord, int delta, int n1);
    private static int ComputeELP(Int32[] sigma, Int32[] syndromes, int delta);
    private static void ComputeZx(Int32[] output, Int32[] sigma, int deg, Int32[] syndromes, int delta);
    private static void ComputeErrors(Int32[] res, Int32[] zx, Byte[] errorCompactSet, int delta, int n1);
}
internal class Org.BouncyCastle.Pqc.Crypto.Hqc.Utils : object {
    internal static void ResizeArray(Int64[] output, int sizeOutBits, Int64[] input, int sizeInBits, int n1n2ByteSize, int n1n2Byte64Size);
    internal static void FromLongArrayToByteArray(Byte[] output, Int64[] input);
    internal static long BitMask(ulong a, ulong b);
    internal static void FromByteArrayToLongArray(Int64[] output, Byte[] input);
    internal static void FromByteArrayToByte16Array(Int32[] output, Byte[] input);
    internal static void FromByte32ArrayToLongArray(Int64[] output, Int32[] input);
    internal static void FromByte16ArrayToULongArray(UInt64[] output, UInt16[] input);
    internal static void FromLongArrayToByte32Array(Int32[] output, Int64[] input);
    internal static void CopyBytes(Int32[] src, int offsetSrc, Int32[] dst, int offsetDst, int lengthBytes);
    internal static int GetByteSizeFromBitSize(int size);
    internal static int GetByte64SizeFromBitSize(int size);
    internal static int ToUnsigned8bits(int a);
    internal static int ToUnsigned16Bits(int a);
    internal static void XorULongToByte16Array(UInt16[] output, int outOff, ulong input);
}
public interface Org.BouncyCastle.Pqc.Crypto.IMessageSigner {
    public abstract virtual void Init(bool forSigning, ICipherParameters param);
    public abstract virtual Byte[] GenerateSignature(Byte[] message);
    public abstract virtual bool VerifySignature(Byte[] message, Byte[] signature);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.Composer : object {
    private MemoryStream bos;
    public static Composer Compose();
    public Composer U64Str(long n);
    public Composer U32Str(int n);
    public Composer U16Str(int n);
    public Composer Bytes(IEncodable[] encodable);
    public Composer Bytes(IEncodable encodable);
    public Composer Pad(int v, int len);
    public Composer Bytes2(Byte[][] arrays);
    public Composer Bytes2(Byte[][] arrays, int start, int end);
    public Composer Bytes(Byte[] array);
    public Composer Bytes(Byte[] array, int start, int len);
    public Byte[] Build();
    public Composer PadUntil(int v, int requiredLen);
    public Composer Boolean(bool v);
}
public static class Org.BouncyCastle.Pqc.Crypto.Lms.Hss : object {
    public static HssPrivateKeyParameters GenerateHssKeyPair(HssKeyGenerationParameters parameters);
    public static void IncrementIndex(HssPrivateKeyParameters keyPair);
    public static void RangeTestKeys(HssPrivateKeyParameters keyPair);
    public static HssSignature GenerateSignature(HssPrivateKeyParameters keyPair, Byte[] message);
    public static HssSignature GenerateSignature(int L, LmsContext context);
    public static bool VerifySignature(HssPublicKeyParameters publicKey, HssSignature signature, Byte[] message);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.HssKeyGenerationParameters : KeyGenerationParameters {
    private LmsParameters[] m_lmsParameters;
    public int Depth { get; }
    public HssKeyGenerationParameters(LmsParameters[] lmsParameters, SecureRandom random);
    private static LmsParameters[] ValidateLmsParameters(LmsParameters[] lmsParameters);
    public int get_Depth();
    public LmsParameters GetLmsParameters(int index);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.HssKeyPairGenerator : object {
    private HssKeyGenerationParameters m_parameters;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.HssPrivateKeyParameters : LmsKeyParameters {
    private int l;
    private bool isShard;
    private IList`1<LmsPrivateKeyParameters> keys;
    private IList`1<LmsSignature> sig;
    private long indexLimit;
    private long index;
    private HssPublicKeyParameters publicKey;
    public int L { get; }
    public long IndexLimit { get; }
    public HssPrivateKeyParameters(int l, IList`1<LmsPrivateKeyParameters> keys, IList`1<LmsSignature> sig, long index, long indexLimit);
    private HssPrivateKeyParameters(int l, IList`1<LmsPrivateKeyParameters> keys, IList`1<LmsSignature> sig, long index, long indexLimit, bool isShard);
    public static HssPrivateKeyParameters GetInstance(Byte[] privEnc, Byte[] pubEnc);
    public static HssPrivateKeyParameters GetInstance(object src);
    public int get_L();
    public long GetIndex();
    public LmsParameters[] GetLmsParameters();
    internal void IncIndex();
    private static HssPrivateKeyParameters MakeCopy(HssPrivateKeyParameters privateKeyParameters);
    protected void UpdateHierarchy(IList`1<LmsPrivateKeyParameters> newKeys, IList`1<LmsSignature> newSig);
    public bool IsShard();
    public long get_IndexLimit();
    public sealed virtual long GetUsagesRemaining();
    private LmsPrivateKeyParameters GetRootKey();
    public HssPrivateKeyParameters ExtractKeyShard(int usageCount);
    public IList`1<LmsPrivateKeyParameters> GetKeys();
    internal IList`1<LmsSignature> GetSig();
    private void ResetKeyToIndex();
    public HssPublicKeyParameters GetPublicKey();
    internal void ReplaceConsumedKey(int d);
    public virtual bool Equals(object o);
    private bool CompareLists(IList`1<T> arr1, IList`1<T> arr2);
    public virtual Byte[] GetEncoded();
    public virtual int GetHashCode();
    protected object Clone();
    public sealed virtual LmsContext GenerateLmsContext();
    public sealed virtual Byte[] GenerateSignature(LmsContext context);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.HssPublicKeyParameters : LmsKeyParameters {
    private int m_l;
    private LmsPublicKeyParameters m_lmsPublicKey;
    public int L { get; }
    public LmsPublicKeyParameters LmsPublicKey { get; }
    public HssPublicKeyParameters(int l, LmsPublicKeyParameters lmsPublicKey);
    public static HssPublicKeyParameters GetInstance(object src);
    public int get_L();
    public LmsPublicKeyParameters get_LmsPublicKey();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual Byte[] GetEncoded();
    public sealed virtual LmsContext GenerateLmsContext(Byte[] sigEnc);
    public sealed virtual bool Verify(LmsContext context);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.HssSignature : object {
    private int m_lMinus1;
    private LmsSignedPubKey[] m_signedPubKey;
    private LmsSignature m_signature;
    public LmsSignature Signature { get; }
    public HssSignature(int lMinus1, LmsSignedPubKey[] signedPubKey, LmsSignature signature);
    public static HssSignature GetInstance(object src, int L);
    public int GetLMinus1();
    public LmsSignedPubKey[] GetSignedPubKeys();
    public LmsSignature get_Signature();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public sealed virtual Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.HssSigner : object {
    private HssPrivateKeyParameters privKey;
    private HssPublicKeyParameters pubKey;
    public sealed virtual void Init(bool forSigning, ICipherParameters param);
    public sealed virtual Byte[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, Byte[] signature);
}
public interface Org.BouncyCastle.Pqc.Crypto.Lms.ILmsContextBasedSigner {
    public abstract virtual LmsContext GenerateLmsContext();
    public abstract virtual Byte[] GenerateSignature(LmsContext context);
    public abstract virtual long GetUsagesRemaining();
}
public interface Org.BouncyCastle.Pqc.Crypto.Lms.ILmsContextBasedVerifier {
    public abstract virtual LmsContext GenerateLmsContext(Byte[] signature);
    public abstract virtual bool Verify(LmsContext context);
}
public static class Org.BouncyCastle.Pqc.Crypto.Lms.LMOts : object {
    private static ushort D_PBLC;
    private static int ITER_K;
    private static int ITER_PREV;
    private static int ITER_J;
    internal static int SEED_RANDOMISER_INDEX;
    internal static int SEED_LEN;
    internal static int MAX_HASH;
    internal static ushort D_MESG;
    private static LMOts();
    public static int Coef(Byte[] S, int i, int w);
    public static int Cksm(Byte[] S, int sLen, LMOtsParameters parameters);
    public static LMOtsPublicKey LmsOtsGeneratePublicKey(LMOtsPrivateKey privateKey);
    internal static Byte[] LmsOtsGeneratePublicKey(LMOtsParameters parameter, Byte[] I, int q, Byte[] masterSecret);
    public static LMOtsSignature lm_ots_generate_signature(LMSigParameters sigParams, LMOtsPrivateKey privateKey, Byte[][] path, Byte[] message, bool preHashed);
    public static LMOtsSignature LMOtsGenerateSignature(LMOtsPrivateKey privateKey, Byte[] Q, Byte[] C);
    public static bool LMOtsValidateSignature(LMOtsPublicKey publicKey, LMOtsSignature signature, Byte[] message, bool prehashed);
    public static Byte[] LMOtsValidateSignatureCalculate(LMOtsPublicKey publicKey, LMOtsSignature signature, Byte[] message);
    public static Byte[] LMOtsValidateSignatureCalculate(LmsContext context);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LMOtsParameters : object {
    public static LMOtsParameters sha256_n32_w1;
    public static LMOtsParameters sha256_n32_w2;
    public static LMOtsParameters sha256_n32_w4;
    public static LMOtsParameters sha256_n32_w8;
    private static Dictionary`2<object, LMOtsParameters> Suppliers;
    private int m_id;
    private int m_n;
    private int m_w;
    private int m_p;
    private int m_ls;
    private UInt32 m_sigLen;
    private DerObjectIdentifier m_digestOid;
    public int ID { get; }
    public int N { get; }
    public int W { get; }
    public int P { get; }
    public int Ls { get; }
    public int SigLen { get; }
    public DerObjectIdentifier DigestOid { get; }
    internal LMOtsParameters(int id, int n, int w, int p, int ls, UInt32 sigLen, DerObjectIdentifier digestOid);
    private static LMOtsParameters();
    public int get_ID();
    public int get_N();
    public int get_W();
    public int get_P();
    public int get_Ls();
    public int get_SigLen();
    public DerObjectIdentifier get_DigestOid();
    public static LMOtsParameters GetParametersByID(int id);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LMOtsPrivateKey : object {
    private LMOtsParameters m_parameters;
    private Byte[] m_I;
    private int m_q;
    private Byte[] m_masterSecret;
    public LMOtsParameters Parameters { get; }
    public Byte[] I { get; }
    public int Q { get; }
    public Byte[] MasterSecret { get; }
    public LMOtsPrivateKey(LMOtsParameters parameters, Byte[] i, int q, Byte[] masterSecret);
    public LmsContext GetSignatureContext(LMSigParameters sigParams, Byte[][] path);
    internal SeedDerive GetDerivationFunction();
    public LMOtsParameters get_Parameters();
    public Byte[] get_I();
    public int get_Q();
    public Byte[] get_MasterSecret();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LMOtsPublicKey : object {
    private LMOtsParameters m_parameters;
    private Byte[] m_I;
    private int m_q;
    private Byte[] m_K;
    public LMOtsParameters Parameters { get; }
    public Byte[] I { get; }
    public int Q { get; }
    public Byte[] K { get; }
    public LMOtsPublicKey(LMOtsParameters parameters, Byte[] i, int q, Byte[] k);
    public static LMOtsPublicKey GetInstance(object src);
    public LMOtsParameters get_Parameters();
    public Byte[] get_I();
    public int get_Q();
    public Byte[] get_K();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Byte[] GetEncoded();
    internal LmsContext CreateOtsContext(LMOtsSignature signature);
    internal LmsContext CreateOtsContext(LmsSignature signature);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LMOtsSignature : object {
    private LMOtsParameters m_paramType;
    private Byte[] m_C;
    private Byte[] m_y;
    public LMOtsParameters ParamType { get; }
    public Byte[] C { get; }
    public Byte[] Y { get; }
    public LMOtsSignature(LMOtsParameters paramType, Byte[] c, Byte[] y);
    public static LMOtsSignature GetInstance(object src);
    public LMOtsParameters get_ParamType();
    public Byte[] get_C();
    public Byte[] get_Y();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Byte[] GetEncoded();
}
public static class Org.BouncyCastle.Pqc.Crypto.Lms.Lms : object {
    internal static ushort D_LEAF;
    internal static ushort D_INTR;
    private static Lms();
    public static LmsPrivateKeyParameters GenerateKeys(LMSigParameters parameterSet, LMOtsParameters lmOtsParameters, int q, Byte[] I, Byte[] rootSeed);
    public static LmsSignature GenerateSign(LmsPrivateKeyParameters privateKey, Byte[] message);
    public static LmsSignature GenerateSign(LmsContext context);
    public static bool VerifySignature(LmsPublicKeyParameters publicKey, LmsSignature S, Byte[] message);
    public static bool VerifySignature(LmsPublicKeyParameters publicKey, Byte[] S, Byte[] message);
    public static bool VerifySignature(LmsPublicKeyParameters publicKey, LmsContext context);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsContext : object {
    private Byte[] m_c;
    private LMOtsPrivateKey m_privateKey;
    private LMSigParameters m_sigParams;
    private Byte[][] m_path;
    private LMOtsPublicKey m_publicKey;
    private object m_signature;
    private LmsSignedPubKey[] m_signedPubKeys;
    private IDigest modreq(System.Runtime.CompilerServices.IsVolatile) m_digest;
    public Byte[] C { get; }
    internal Byte[][] Path { get; }
    internal LMOtsPrivateKey PrivateKey { get; }
    public LMOtsPublicKey PublicKey { get; }
    internal LMSigParameters SigParams { get; }
    public object Signature { get; }
    internal LmsSignedPubKey[] SignedPubKeys { get; }
    public string AlgorithmName { get; }
    public LmsContext(LMOtsPrivateKey privateKey, LMSigParameters sigParams, IDigest digest, Byte[] C, Byte[][] path);
    public LmsContext(LMOtsPublicKey publicKey, object signature, IDigest digest);
    public Byte[] get_C();
    public Byte[] GetQ();
    internal Byte[][] get_Path();
    internal LMOtsPrivateKey get_PrivateKey();
    public LMOtsPublicKey get_PublicKey();
    internal LMSigParameters get_SigParams();
    public object get_Signature();
    internal LmsSignedPubKey[] get_SignedPubKeys();
    internal LmsContext WithSignedPublicKeys(LmsSignedPubKey[] signedPubKeys);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsException : Exception {
    public LmsException(string message);
    public LmsException(string message, Exception innerException);
    protected LmsException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LMSigParameters : object {
    public static LMSigParameters lms_sha256_n32_h5;
    public static LMSigParameters lms_sha256_n32_h10;
    public static LMSigParameters lms_sha256_n32_h15;
    public static LMSigParameters lms_sha256_n32_h20;
    public static LMSigParameters lms_sha256_n32_h25;
    private static Dictionary`2<int, LMSigParameters> ParametersByID;
    private int m_id;
    private int m_m;
    private int m_h;
    private DerObjectIdentifier m_digestOid;
    public int ID { get; }
    public int H { get; }
    public int M { get; }
    public DerObjectIdentifier DigestOid { get; }
    internal LMSigParameters(int id, int m, int h, DerObjectIdentifier digestOid);
    private static LMSigParameters();
    public int get_ID();
    public int get_H();
    public int get_M();
    public DerObjectIdentifier get_DigestOid();
    public static LMSigParameters GetParametersByID(int id);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsKeyGenerationParameters : KeyGenerationParameters {
    private LmsParameters m_lmsParameters;
    public LmsParameters LmsParameters { get; }
    public LmsKeyGenerationParameters(LmsParameters lmsParameters, SecureRandom random);
    public LmsParameters get_LmsParameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsKeyPairGenerator : object {
    private LmsKeyGenerationParameters m_parameters;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Lms.LmsKeyParameters : AsymmetricKeyParameter {
    internal LmsKeyParameters(bool isPrivateKey);
    public abstract virtual Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsParameters : object {
    private LMSigParameters m_lmSigParameters;
    private LMOtsParameters m_lmOtsParameters;
    public LMSigParameters LMSigParameters { get; }
    public LMOtsParameters LMOtsParameters { get; }
    public LmsParameters(LMSigParameters lmSigParameters, LMOtsParameters lmOtsParameters);
    public LMSigParameters get_LMSigParameters();
    public LMOtsParameters get_LMOtsParameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsPrivateKeyParameters : LmsKeyParameters {
    private static CacheKey T1;
    private static CacheKey[] internedKeys;
    private Byte[] I;
    private LMSigParameters parameters;
    private LMOtsParameters otsParameters;
    private int maxQ;
    private Byte[] masterSecret;
    private Dictionary`2<CacheKey, Byte[]> tCache;
    private int maxCacheR;
    private IDigest tDigest;
    private int q;
    private bool m_isPlaceholder;
    private LmsPublicKeyParameters publicKey;
    private static LmsPrivateKeyParameters();
    public LmsPrivateKeyParameters(LMSigParameters lmsParameter, LMOtsParameters otsParameters, int q, Byte[] I, int maxQ, Byte[] masterSecret);
    internal LmsPrivateKeyParameters(LMSigParameters lmsParameter, LMOtsParameters otsParameters, int q, Byte[] I, int maxQ, Byte[] masterSecret, bool isPlaceholder);
    private LmsPrivateKeyParameters(LmsPrivateKeyParameters parent, int q, int maxQ);
    public static LmsPrivateKeyParameters GetInstance(Byte[] privEnc, Byte[] pubEnc);
    public static LmsPrivateKeyParameters GetInstance(object src);
    internal LMOtsPrivateKey GetCurrentOtsKey();
    public int GetIndex();
    internal void IncIndex();
    public sealed virtual LmsContext GenerateLmsContext();
    public sealed virtual Byte[] GenerateSignature(LmsContext context);
    internal LMOtsPrivateKey GetNextOtsPrivateKey();
    public LmsPrivateKeyParameters ExtractKeyShard(int usageCount);
    public LMSigParameters GetSigParameters();
    public LMOtsParameters GetOtsParameters();
    public Byte[] GetI();
    public Byte[] GetMasterSecret();
    public sealed virtual long GetUsagesRemaining();
    public LmsPublicKeyParameters GetPublicKey();
    internal Byte[] FindT(int r);
    private Byte[] FindT(CacheKey key);
    private Byte[] CalcT(int r);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsPublicKeyParameters : LmsKeyParameters {
    private LMSigParameters parameterSet;
    private LMOtsParameters lmOtsType;
    private Byte[] I;
    private Byte[] T1;
    public LmsPublicKeyParameters(LMSigParameters parameterSet, LMOtsParameters lmOtsType, Byte[] T1, Byte[] I);
    public static LmsPublicKeyParameters GetInstance(object src);
    public virtual Byte[] GetEncoded();
    public LMSigParameters GetSigParameters();
    public LMOtsParameters GetOtsParameters();
    public LmsParameters GetLmsParameters();
    public Byte[] GetT1();
    internal bool MatchesT1(Byte[] sig);
    public Byte[] GetI();
    private Byte[] RefI();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal Byte[] ToByteArray();
    public sealed virtual LmsContext GenerateLmsContext(Byte[] signature);
    internal LmsContext GenerateOtsContext(LmsSignature S);
    public sealed virtual bool Verify(LmsContext context);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsSignature : object {
    private int q;
    private LMOtsSignature otsSignature;
    private LMSigParameters parameter;
    private Byte[][] y;
    public int Q { get; }
    public LMOtsSignature OtsSignature { get; }
    public LMSigParameters SigParameters { get; }
    public Byte[][] Y { get; }
    public LmsSignature(int q, LMOtsSignature otsSignature, LMSigParameters parameter, Byte[][] y);
    public static LmsSignature GetInstance(object src);
    public virtual bool Equals(object o);
    private bool Compare2DArrays(Byte[][] a, Byte[][] b);
    public virtual int GetHashCode();
    public sealed virtual Byte[] GetEncoded();
    public int get_Q();
    public LMOtsSignature get_OtsSignature();
    public LMSigParameters get_SigParameters();
    public Byte[][] get_Y();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsSignedPubKey : object {
    private LmsSignature signature;
    private LmsPublicKeyParameters publicKey;
    public LmsSignedPubKey(LmsSignature signature, LmsPublicKeyParameters publicKey);
    public LmsSignature GetSignature();
    public LmsPublicKeyParameters GetPublicKey();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public sealed virtual Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.LmsSigner : object {
    private LmsPrivateKeyParameters m_privateKey;
    private LmsPublicKeyParameters m_publicKey;
    public sealed virtual void Init(bool forSigning, ICipherParameters param);
    public sealed virtual Byte[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, Byte[] signature);
}
public static class Org.BouncyCastle.Pqc.Crypto.Lms.LmsUtilities : object {
    public static void U32Str(int n, IDigest d);
    public static void U16Str(short n, IDigest d);
    public static void ByteArray(Byte[] array, IDigest digest);
    public static void ByteArray(Byte[] array, int start, int len, IDigest digest);
    public static int CalculateStrength(LmsParameters lmsParameters);
}
public class Org.BouncyCastle.Pqc.Crypto.Lms.SeedDerive : object {
    private Byte[] m_I;
    private Byte[] m_masterSeed;
    private IDigest m_digest;
    [CompilerGeneratedAttribute]
private int <Q>k__BackingField;
    [CompilerGeneratedAttribute]
private int <J>k__BackingField;
    public int Q { get; public set; }
    public int J { get; public set; }
    public Byte[] I { get; }
    public Byte[] MasterSeed { get; }
    public SeedDerive(Byte[] I, Byte[] masterSeed, IDigest digest);
    [CompilerGeneratedAttribute]
public int get_Q();
    [CompilerGeneratedAttribute]
public void set_Q(int value);
    [CompilerGeneratedAttribute]
public int get_J();
    [CompilerGeneratedAttribute]
public void set_J(int value);
    public Byte[] get_I();
    public Byte[] get_MasterSeed();
    public Byte[] DeriveSeed(bool incJ, Byte[] target, int offset);
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruEncapsulation : object {
    private Byte[] _sharedKey;
    private Byte[] _ciphertext;
    private bool _hasBeenDestroyed;
    internal NtruEncapsulation(Byte[] sharedKey, Byte[] ciphertext);
    public sealed virtual void Dispose();
    public sealed virtual Byte[] GetSecret();
    public sealed virtual Byte[] GetEncapsulation();
    private void CheckDestroyed();
    public bool IsDestroyed();
}
public class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruKemExtractor : object {
    private NtruParameters _parameters;
    private NtruPrivateKeyParameters _ntruPrivateKey;
    public int EncapsulationLength { get; }
    public NtruKemExtractor(NtruPrivateKeyParameters ntruPrivateKey);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    private static void Cmov(Byte[] r, Byte[] x, byte b);
    public sealed virtual int get_EncapsulationLength();
}
public class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruKemGenerator : object {
    private SecureRandom _random;
    public NtruKemGenerator(SecureRandom random);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
}
public class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruKeyGenerationParameters : KeyGenerationParameters {
    [CompilerGeneratedAttribute]
private NtruParameters <NtruParameters>k__BackingField;
    internal NtruParameters NtruParameters { get; }
    public NtruKeyGenerationParameters(SecureRandom random, NtruParameters ntruParameters);
    [CompilerGeneratedAttribute]
internal NtruParameters get_NtruParameters();
    public NtruParameters GetParameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruKeyPairGenerator : object {
    private NtruKeyGenerationParameters _keygenParameters;
    private SecureRandom _random;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruKeyParameters : AsymmetricKeyParameter {
    private NtruParameters m_parameters;
    public NtruParameters Parameters { get; }
    internal NtruKeyParameters(bool privateKey, NtruParameters parameters);
    public NtruParameters get_Parameters();
    public abstract virtual Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruParameters : object {
    public static NtruParameters NtruHps2048509;
    public static NtruParameters NtruHps2048677;
    public static NtruParameters NtruHps4096821;
    public static NtruParameters NtruHrss701;
    internal NtruParameterSet ParameterSet;
    private string _name;
    public string Name { get; }
    public int DefaultKeySize { get; }
    private NtruParameters(string name, NtruParameterSet parameterSet);
    private static NtruParameters();
    public string get_Name();
    public int get_DefaultKeySize();
}
public class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruPrivateKeyParameters : NtruKeyParameters {
    private Byte[] _privateKey;
    public Byte[] PrivateKey { get; private set; }
    public NtruPrivateKeyParameters(NtruParameters parameters, Byte[] key);
    public Byte[] get_PrivateKey();
    private void set_PrivateKey(Byte[] value);
    public virtual Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruPublicKeyParameters : NtruKeyParameters {
    private Byte[] _publicKey;
    public Byte[] PublicKey { get; public set; }
    public NtruPublicKeyParameters(NtruParameters parameters, Byte[] key);
    public Byte[] get_PublicKey();
    public void set_PublicKey(Byte[] value);
    public virtual Byte[] GetEncoded();
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.NtruSampling : object {
    private NtruParameterSet _parameterSet;
    internal NtruSampling(NtruParameterSet parameterSet);
    internal PolynomialPair SampleFg(Byte[] uniformBytes);
    internal PolynomialPair SampleRm(Byte[] uniformBytes);
    internal Polynomial SampleIid(Byte[] uniformBytes);
    internal HpsPolynomial SampleFixedType(Byte[] uniformBytes);
    internal HrssPolynomial SampleIidPlus(Byte[] uniformBytes);
    private static int Mod3(int a);
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.Owcpa.NtruOwcpa : object {
    private NtruParameterSet _parameterSet;
    private NtruSampling _sampling;
    internal NtruOwcpa(NtruParameterSet parameterSet);
    internal OwcpaKeyPair KeyPair(Byte[] seed);
    internal Byte[] Encrypt(Polynomial r, Polynomial m, Byte[] publicKey);
    internal OwcpaDecryptResult Decrypt(Byte[] ciphertext, Byte[] privateKey);
    private int CheckCiphertext(Byte[] ciphertext);
    private int CheckR(Polynomial r);
    private int CheckM(HpsPolynomial m);
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.Owcpa.OwcpaDecryptResult : object {
    internal Byte[] Rm;
    internal int Fail;
    internal OwcpaDecryptResult(Byte[] rm, int fail);
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.Owcpa.OwcpaKeyPair : object {
    internal Byte[] PublicKey;
    internal Byte[] PrivateKey;
    internal OwcpaKeyPair(Byte[] publicKey, Byte[] privateKey);
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.ParameterSets.NtruHps2048509 : NtruHpsParameterSet {
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.ParameterSets.NtruHps2048677 : NtruHpsParameterSet {
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.ParameterSets.NtruHps4096821 : NtruHpsParameterSet {
    internal virtual Polynomial CreatePolynomial();
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.ParameterSets.NtruHpsParameterSet : NtruParameterSet {
    private protected NtruHpsParameterSet(int n, int logQ, int seedBytes, int prfKeyBytes, int sharedKeyBytes);
    internal virtual Polynomial CreatePolynomial();
    internal virtual int SampleFgBytes();
    internal virtual int SampleRmBytes();
    internal int Weight();
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.ParameterSets.NtruHrss701 : NtruHrssParameterSet {
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.ParameterSets.NtruHrssParameterSet : NtruParameterSet {
    private protected NtruHrssParameterSet(int n, int logQ, int seedBytes, int prfKeyBytes, int sharedKeyBytes);
    internal virtual Polynomial CreatePolynomial();
    internal virtual int SampleFgBytes();
    internal virtual int SampleRmBytes();
}
internal abstract class Org.BouncyCastle.Pqc.Crypto.Ntru.ParameterSets.NtruParameterSet : object {
    [CompilerGeneratedAttribute]
private int <N>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LogQ>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SeedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PrfKeyBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SharedKeyBytes>k__BackingField;
    internal int N { get; }
    internal int LogQ { get; }
    internal int SeedBytes { get; }
    internal int PrfKeyBytes { get; }
    internal int SharedKeyBytes { get; }
    internal NtruParameterSet(int n, int logQ, int seedBytes, int prfKeyBytes, int sharedKeyBytes);
    [CompilerGeneratedAttribute]
internal int get_N();
    [CompilerGeneratedAttribute]
internal int get_LogQ();
    [CompilerGeneratedAttribute]
internal int get_SeedBytes();
    [CompilerGeneratedAttribute]
internal int get_PrfKeyBytes();
    [CompilerGeneratedAttribute]
internal int get_SharedKeyBytes();
    internal abstract virtual Polynomial CreatePolynomial();
    internal int Q();
    internal int SampleIidBytes();
    internal int SampleFixedTypeBytes();
    internal abstract virtual int SampleFgBytes();
    internal abstract virtual int SampleRmBytes();
    internal int PackDegree();
    internal int PackTrinaryBytes();
    internal int OwcpaMsgBytes();
    internal int OwcpaPublicKeyBytes();
    internal int OwcpaSecretKeyBytes();
    internal int OwcpaBytes();
    internal int NtruPublicKeyBytes();
    internal int NtruSecretKeyBytes();
    internal int NtruCiphertextBytes();
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.PolynomialPair : object {
    private Polynomial _a;
    private Polynomial _b;
    public PolynomialPair(Polynomial a, Polynomial b);
    internal Polynomial F();
    internal Polynomial G();
    internal Polynomial R();
    internal Polynomial M();
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.Polynomials.Hps4096Polynomial : HpsPolynomial {
    internal Hps4096Polynomial(NtruParameterSet parameterSet);
    public virtual Byte[] SqToBytes(int len);
    public virtual void SqFromBytes(Byte[] a);
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.Polynomials.HpsPolynomial : Polynomial {
    internal HpsPolynomial(NtruParameterSet parameterSet);
    public virtual Byte[] SqToBytes(int len);
    public virtual void SqFromBytes(Byte[] a);
    public virtual void Lift(Polynomial a);
    public virtual void R2Inv(Polynomial a);
    public virtual void RqInv(Polynomial a);
    public virtual void S3Inv(Polynomial a);
}
internal class Org.BouncyCastle.Pqc.Crypto.Ntru.Polynomials.HrssPolynomial : Polynomial {
    internal HrssPolynomial(NtruParameterSet parameterSet);
    public virtual Byte[] SqToBytes(int len);
    public virtual void SqFromBytes(Byte[] a);
    public virtual void Lift(Polynomial a);
    public virtual void R2Inv(Polynomial a);
    public virtual void RqInv(Polynomial a);
    public virtual void S3Inv(Polynomial a);
}
internal abstract class Org.BouncyCastle.Pqc.Crypto.Ntru.Polynomials.Polynomial : object {
    internal UInt16[] coeffs;
    private protected NtruParameterSet ParameterSet;
    internal Polynomial(NtruParameterSet parameterSet);
    internal static short BothNegativeMask(short x, short y);
    internal static ushort Mod3(ushort a);
    internal static byte Mod3(byte a);
    internal static UInt32 ModQ(UInt32 x, UInt32 q);
    internal void Mod3PhiN();
    internal void ModQPhiN();
    internal static ushort Mod(double a, double b);
    public abstract virtual Byte[] SqToBytes(int len);
    public abstract virtual void SqFromBytes(Byte[] a);
    public Byte[] RqSumZeroToBytes(int len);
    public void RqSumZeroFromBytes(Byte[] a);
    public Byte[] S3ToBytes(int messageSize);
    public void S3FromBytes(Byte[] msg);
    public void RqMul(Polynomial a, Polynomial b);
    public void SqMul(Polynomial a, Polynomial b);
    public void S3Mul(Polynomial a, Polynomial b);
    public abstract virtual void Lift(Polynomial a);
    public void RqToS3(Polynomial a);
    public abstract virtual void R2Inv(Polynomial a);
    internal void R2Inv(Polynomial a, Polynomial f, Polynomial g, Polynomial v, Polynomial w);
    public abstract virtual void RqInv(Polynomial a);
    internal void RqInv(Polynomial a, Polynomial ai2, Polynomial b, Polynomial c, Polynomial s);
    private void R2InvToRqInv(Polynomial ai, Polynomial a, Polynomial b, Polynomial c, Polynomial s);
    public abstract virtual void S3Inv(Polynomial a);
    internal void S3Inv(Polynomial a, Polynomial f, Polynomial g, Polynomial v, Polynomial w);
    public void Z3ToZq();
    public void TrinaryZqToZ3();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.NtruLPRimeKemExtractor : object {
    private NtruPrimeEngine _primeEngine;
    private NtruLPRimeKeyParameters _primeKey;
    public int EncapsulationLength { get; }
    public NtruLPRimeKemExtractor(NtruLPRimeKeyParameters privParams);
    private void InitCipher(NtruLPRimeParameters param);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    public sealed virtual int get_EncapsulationLength();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.NtruLPRimeKemGenerator : object {
    private SecureRandom sr;
    public NtruLPRimeKemGenerator(SecureRandom sr);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.NtruLPRimeKeyGenerationParameters : KeyGenerationParameters {
    private NtruLPRimeParameters _primeParameters;
    public NtruLPRimeParameters Parameters { get; }
    public NtruLPRimeKeyGenerationParameters(SecureRandom random, NtruLPRimeParameters ntruPrimeParameters);
    public NtruLPRimeParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.NtruLPRimeKeyPairGenerator : object {
    private NtruLPRimeKeyGenerationParameters _ntruPrimeParams;
    private int p;
    private int q;
    private SecureRandom random;
    private void Initialize(KeyGenerationParameters param);
    private AsymmetricCipherKeyPair GenKeyPair();
    public void Init(KeyGenerationParameters param);
    public AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.NtruPrime.NtruLPRimeKeyParameters : AsymmetricKeyParameter {
    private NtruLPRimeParameters m_primeParameters;
    public NtruLPRimeParameters Parameters { get; }
    internal NtruLPRimeKeyParameters(bool isPrivate, NtruLPRimeParameters primeParameters);
    public NtruLPRimeParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.NtruLPRimeParameters : object {
    private string name;
    private int p;
    private int q;
    private int _roundedBytes;
    private bool m_LPR;
    private int _w;
    private int _rqBytes;
    private int _tau0;
    private int _tau1;
    private int _tau2;
    private int _tau3;
    private int _skBytes;
    private int _pkBytes;
    private int _ctBytes;
    private int _defaultKeySize;
    private NtruPrimeEngine _primeEngine;
    public static NtruLPRimeParameters ntrulpr653;
    public static NtruLPRimeParameters ntrulpr761;
    public static NtruLPRimeParameters ntrulpr857;
    public static NtruLPRimeParameters ntrulpr953;
    public static NtruLPRimeParameters ntrulpr1013;
    public static NtruLPRimeParameters ntrulpr1277;
    public int P { get; }
    public bool LPR { get; }
    public int Q { get; }
    public int DefaultKeySize { get; }
    internal NtruPrimeEngine PrimeEngine { get; }
    private NtruLPRimeParameters(string name, int p, int q, bool LPR, int w, int tau0, int tau1, int tau2, int tau3, int skBytes, int pkBytes, int ctBytes, int roundedBytes, int rqBytes, int defaultKeySize);
    private static NtruLPRimeParameters();
    public int get_P();
    public bool get_LPR();
    public int get_Q();
    public int get_DefaultKeySize();
    internal NtruPrimeEngine get_PrimeEngine();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.NtruLPRimePrivateKeyParameters : NtruLPRimeKeyParameters {
    internal Byte[] privKey;
    public NtruLPRimePrivateKeyParameters(NtruLPRimeParameters primeParameters, Byte[] privKey);
    public Byte[] GetPrivateKey();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.NtruLPRimePublicKeyParameters : NtruLPRimeKeyParameters {
    internal Byte[] pubKey;
    public NtruLPRimePublicKeyParameters(NtruLPRimeParameters primeParameters, Byte[] pubKey);
    public Byte[] GetPublicKey();
    public Byte[] GetEncoded();
}
internal class Org.BouncyCastle.Pqc.Crypto.NtruPrime.NtruPrimeEngine : object {
    private int _skBytes;
    private int _pkBytes;
    private int _ctBytes;
    private int _secretKeyBytes;
    private int _publicKeyBytes;
    private int _ciphertextsBytes;
    private int _confirmBytes;
    private int _inputsBytes;
    private int _topBytes;
    private int _seedBytes;
    private int _smallBytes;
    private int _hashBytes;
    private int SessionKeyBytes;
    private int _p;
    private int _q;
    private int _roundedBytes;
    private bool _lpr;
    private int _w;
    private int _tau0;
    private int _tau1;
    private int _tau2;
    private int _tau3;
    private int _I;
    private int _q12;
    public int PrivateKeySize { get; }
    public int PublicKeySize { get; }
    public int CipherTextSize { get; }
    public int SessionKeySize { get; }
    public NtruPrimeEngine(int p, int q, bool lpr, int w, int tau0, int tau1, int tau2, int tau3, int skBytes, int pkBytes, int ctBytes, int roundedBytes, int rqBytes, int defaultKeyLen);
    public int get_PrivateKeySize();
    public int get_PublicKeySize();
    public int get_CipherTextSize();
    public int get_SessionKeySize();
    public void kem_keypair(Byte[] pk, Byte[] sk, SecureRandom random);
    public void kem_enc(Byte[] ct, Byte[] ss, Byte[] pk, SecureRandom random);
    public void kem_dec(Byte[] ss, Byte[] ct, Byte[] sk);
    private void KeyGen(SecureRandom random, Byte[]& pk, Byte[]& sk);
    private void ByteRandom(SByte[]& output, SecureRandom random);
    private int R3Recip(SByte[]& output, SByte[] input);
    private int RqRecip3(Int16[]& output, SByte[] input);
    private short FqRecip(short a1);
    private void RqMult(Int16[]& output, Int16[] f, SByte[] g);
    private void RqEncode(Byte[]& output, Int16[] r);
    private void RqDecode(Int16[]& output, Byte[] s);
    private void RqMult3(Int16[]& output, Int16[] f);
    private void R3FromRq(SByte[]& output, Int16[] r);
    private void R3Mult(SByte[]& output, SByte[] f, SByte[] g);
    private int WeightMask(SByte[] r);
    private int NonZeroMask(short x);
    private List`1<ushort> Decode(List`1<byte> S, List`1<ushort> M);
    private void Encode(List`1& output, UInt16[] R, UInt16[] M, long len);
    private void Encrypt(Byte[]& output, SByte[] r, Byte[] pk);
    private void Decrypt(SByte[]& output, Byte[] c, Byte[] sk);
    private void Hide(Byte[]& output, Byte[] r_enc, SByte[] r, Byte[] pk, Byte[] cache);
    private void Generator(Int16[]& output, Byte[] seed);
    private UInt32[] Expand(Byte[] k);
    private void ShortRandom(SByte[]& output, SecureRandom random);
    private void ShortFromList(SByte[]& output, UInt32[] L_in);
    private void RqMult(Int16[]& output, Int16[] G, SByte[]& a);
    private void Round(Int16[]& output, Int16[] aG);
    private void InputsRandom(SByte[]& output, SecureRandom random);
    private void InputsEncode(Byte[]& output, SByte[] r);
    private void RoundedEncode(Byte[]& output, Int16[] A);
    private void RoundedDecode(Int16[]& output, Byte[] s);
    private void ByteEncode(Byte[]& output, SByte[] a);
    private void ByteDecode(SByte[]& output, Byte[] s);
    private void TopEncode(Byte[]& output, SByte[] T);
    private void TopDecode(SByte[]& output, Byte[] s);
    private void HashShort(SByte[]& output, SByte[] r);
    private void HashPrefix(Byte[]& output, int b, Byte[]& input, int inlen);
    private void HashConfirm(Byte[]& output, Byte[]& r, Byte[]& pk, Byte[]& cache);
    private void HashSession(Byte[]& output, int b, Byte[] y, Byte[] z);
    private int NegativeMask(short x);
    private int ctDiffMask(Byte[] c, Byte[] c2);
    private double mod(double a, double b);
    private short ArithmeticMod_q(int x);
    private short ArithmeticMod_3(int x);
    private sbyte Top(int C);
    private short Right(sbyte T);
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.SNtruPrimeKemExtractor : object {
    private NtruPrimeEngine _primeEngine;
    private SNtruPrimeKeyParameters _primeKey;
    public int EncapsulationLength { get; }
    public SNtruPrimeKemExtractor(SNtruPrimeKeyParameters privParams);
    private void InitCipher(SNtruPrimeParameters param);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    public sealed virtual int get_EncapsulationLength();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.SNtruPrimeKemGenerator : object {
    private SecureRandom sr;
    public SNtruPrimeKemGenerator(SecureRandom sr);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.SNtruPrimeKeyGenerationParameters : KeyGenerationParameters {
    private SNtruPrimeParameters _primeParameters;
    public SNtruPrimeParameters Parameters { get; }
    public SNtruPrimeKeyGenerationParameters(SecureRandom random, SNtruPrimeParameters ntruPrimeParameters);
    public SNtruPrimeParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.SNtruPrimeKeyPairGenerator : object {
    private SNtruPrimeKeyGenerationParameters _ntruPrimeParams;
    private int p;
    private int q;
    private SecureRandom random;
    private void Initialize(KeyGenerationParameters param);
    private AsymmetricCipherKeyPair GenKeyPair();
    public void Init(KeyGenerationParameters param);
    public AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.NtruPrime.SNtruPrimeKeyParameters : AsymmetricKeyParameter {
    private SNtruPrimeParameters m_primeParameters;
    public SNtruPrimeParameters Parameters { get; }
    internal SNtruPrimeKeyParameters(bool isPrivate, SNtruPrimeParameters primeParameters);
    public SNtruPrimeParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.SNtruPrimeParameters : object {
    private string name;
    private int p;
    private int q;
    private int _roundedBytes;
    private bool m_LPR;
    private int _w;
    private int _rqBytes;
    private int _tau0;
    private int _tau1;
    private int _tau2;
    private int _tau3;
    private int _skBytes;
    private int _pkBytes;
    private int _ctBytes;
    private int _defaultKeySize;
    private NtruPrimeEngine _primeEngine;
    public static SNtruPrimeParameters sntrup653;
    public static SNtruPrimeParameters sntrup761;
    public static SNtruPrimeParameters sntrup857;
    public static SNtruPrimeParameters sntrup953;
    public static SNtruPrimeParameters sntrup1013;
    public static SNtruPrimeParameters sntrup1277;
    public int P { get; }
    public bool LPR { get; }
    public int Q { get; }
    public int DefaultKeySize { get; }
    internal NtruPrimeEngine PrimeEngine { get; }
    private SNtruPrimeParameters(string name, int p, int q, bool LPR, int w, int tau0, int tau1, int tau2, int tau3, int skBytes, int pkBytes, int ctBytes, int roundedBytes, int rqBytes, int defaultKeySize);
    private static SNtruPrimeParameters();
    public int get_P();
    public bool get_LPR();
    public int get_Q();
    public int get_DefaultKeySize();
    internal NtruPrimeEngine get_PrimeEngine();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.SNtruPrimePrivateKeyParameters : SNtruPrimeKeyParameters {
    internal Byte[] privKey;
    public SNtruPrimePrivateKeyParameters(SNtruPrimeParameters primeParameters, Byte[] privKey);
    public Byte[] GetPrivateKey();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.NtruPrime.SNtruPrimePublicKeyParameters : SNtruPrimeKeyParameters {
    internal Byte[] pubKey;
    public SNtruPrimePublicKeyParameters(SNtruPrimeParameters primeParameters, Byte[] pubKey);
    public Byte[] GetPublicKey();
    public Byte[] GetEncoded();
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.KMatrices : object {
    private int nmatrices;
    private int rows;
    private int columns;
    private UInt32[] data;
    internal KMatrices(int nmatrices, int rows, int columns, UInt32[] data);
    internal int GetNmatrices();
    internal int GetSize();
    internal int GetRows();
    internal int GetColumns();
    internal UInt32[] GetData();
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.KMatricesWithPointer : KMatrices {
    private int matrixPointer;
    internal KMatricesWithPointer(KMatrices m);
    internal int GetMatrixPointer();
    internal void SetMatrixPointer(int matrixPointer);
}
internal abstract class Org.BouncyCastle.Pqc.Crypto.Picnic.LowmcConstants : object {
    internal Dictionary`2<string, string> _matrixToHex;
    internal UInt32[] linearMatrices;
    internal UInt32[] roundConstants;
    internal UInt32[] keyMatrices;
    internal KMatrices _LMatrix;
    internal KMatrices _KMatrix;
    internal KMatrices RConstants;
    internal UInt32[] linearMatrices_full;
    internal UInt32[] keyMatrices_full;
    internal UInt32[] keyMatrices_inv;
    internal UInt32[] linearMatrices_inv;
    internal UInt32[] roundConstants_full;
    internal KMatrices LMatrix_full;
    internal KMatrices LMatrix_inv;
    internal KMatrices KMatrix_full;
    internal KMatrices KMatrix_inv;
    internal KMatrices RConstants_full;
    internal static UInt32[] ReadFromProperty(string s, int intSize);
    private KMatricesWithPointer GET_MAT(KMatrices m, int r);
    internal KMatricesWithPointer LMatrix(PicnicEngine engine, int round);
    internal KMatricesWithPointer LMatrixInv(PicnicEngine engine, int round);
    internal KMatricesWithPointer KMatrix(PicnicEngine engine, int round);
    internal KMatricesWithPointer KMatrixInv(PicnicEngine engine, int round);
    internal KMatricesWithPointer RConstant(PicnicEngine engine, int round);
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.LowmcConstantsL1 : LowmcConstants {
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.LowmcConstantsL3 : LowmcConstants {
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.LowmcConstantsL5 : LowmcConstants {
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.Msg : object {
    internal Byte[][] msgs;
    internal int pos;
    internal int unopened;
    internal Msg(PicnicEngine engine);
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.PicnicEngine : object {
    internal static int saltSizeBytes;
    private static UInt32 MAX_DIGEST_SIZE;
    private static int WORD_SIZE_BITS;
    private static UInt32 LOWMC_MAX_STATE_SIZE;
    internal static UInt32 LOWMC_MAX_WORDS;
    internal static UInt32 LOWMC_MAX_KEY_BITS;
    internal static UInt32 LOWMC_MAX_AND_GATES;
    private static UInt32 MAX_AUX_BYTES;
    private static UInt32 PICNIC_MAX_LOWMC_BLOCK_SIZE;
    private static UInt32 PICNIC_MAX_PUBLICKEY_SIZE;
    private static UInt32 PICNIC_MAX_PRIVATEKEY_SIZE;
    private static UInt32 TRANSFORM_FS;
    private static UInt32 TRANSFORM_UR;
    private static UInt32 TRANSFORM_INVALID;
    private int CRYPTO_SECRETKEYBYTES;
    private int CRYPTO_PUBLICKEYBYTES;
    private int CRYPTO_BYTES;
    internal int numRounds;
    private int numSboxes;
    internal int stateSizeBits;
    internal int stateSizeBytes;
    internal int stateSizeWords;
    internal int andSizeBytes;
    private int UnruhGWithoutInputBytes;
    internal int UnruhGWithInputBytes;
    internal int numMPCRounds;
    internal int numOpenedRounds;
    internal int numMPCParties;
    internal int seedSizeBytes;
    internal int digestSizeBytes;
    internal int pqSecurityLevel;
    private UInt32 transform;
    private int parameters;
    internal IXof digest;
    private int signatureLength;
    internal LowmcConstants _lowmcConstants;
    internal PicnicEngine(int picnicParams, LowmcConstants lowmcConstants);
    private static PicnicEngine();
    internal int GetSecretKeySize();
    internal int GetPublicKeySize();
    internal int GetSignatureSize(int messageLength);
    internal int GetTrueSignatureSize();
    internal bool crypto_sign_open(Byte[] m, Byte[] sm, Byte[] pk);
    private int picnic_verify(Byte[] pk, Byte[] message, Byte[] signature, UInt32 sigLen);
    private int Verify(Signature sig, UInt32[] pubKey, UInt32[] plaintext, Byte[] message);
    private void VerifyProof(Proof proof, View view1, View view2, int challenge, Byte[] salt, UInt32 roundNumber, Byte[] tmp, UInt32[] plaintext, Tape tape);
    private void mpc_LowMC_verify(View view1, View view2, Tape tapes, UInt32[] tmp, UInt32[] plaintext, int challenge);
    private void mpc_substitution_verify(UInt32[] state, Tape rand, View view1, View view2);
    private void mpc_AND_verify(UInt32[] in1, UInt32[] in2, UInt32[] output, Tape rand, View view1, View view2);
    private void mpc_xor_constant_verify(UInt32[] state, UInt32[] input, int inOffset, int length, int challenge);
    private int DeserializeSignature(Signature sig, Byte[] sigBytes, UInt32 sigBytesLen, int sigBytesOffset);
    private bool IsChallengeValid(Byte[] challengeBits);
    private int ComputeInputShareSize(Byte[] challengeBits, int stateSizeBytes);
    private UInt32 picnic_read_public_key(Byte[] ciphertext, Byte[] plaintext, Byte[] pk);
    private int verify_picnic3(Signature2 sig, UInt32[] pubKey, UInt32[] plaintext, Byte[] message);
    private int DeserializeSignature2(Signature2 sig, Byte[] sigBytes, UInt32 sigLen, int sigBytesOffset);
    private bool ArePaddingBitsZero(Byte[] data, int bitLength);
    internal void crypto_sign(Byte[] sm, Byte[] m, Byte[] sk);
    private void picnic_sign(Byte[] sk, Byte[] message, Byte[] signature);
    private int SerializeSignature(Signature sig, Byte[] sigBytes, int sigOffset);
    private int GetChallenge(Byte[] challenge, int round);
    private int SerializeSignature2(Signature2 sig, Byte[] sigBytes, int sigOffset);
    private int sign_picnic1(UInt32[] privateKey, UInt32[] pubKey, UInt32[] plaintext, Byte[] message, Signature sig);
    private void Prove(Proof proof, int challenge, Byte[] seeds, int seedsOffset, View[] views, Byte[][] commitments, Byte[][] gs);
    private void H3(UInt32[] circuitOutput, UInt32[] plaintext, UInt32[][][] viewOutputs, Byte[][][] AS, Byte[] challengeBits, Byte[] salt, Byte[] message, Byte[][][] gs);
    private void SetChallenge(Byte[] challenge, int round, UInt32 trit);
    private void G(int viewNumber, Byte[] seed, int seedOffset, View view, Byte[] output);
    private void mpc_LowMC(Tape tapes, View[] views, UInt32[] plaintext, UInt32[] slab);
    private void Commit(Byte[] seed, int seedOffset, View view, Byte[] hash);
    private void mpc_substitution(UInt32[] state, Tape rand, View[] views);
    private void mpc_AND(UInt32[] in1, UInt32[] in2, UInt32[] output, Tape rand, View[] views);
    private void mpc_xor(UInt32[] state, UInt32[] input, int len, int players);
    private void mpc_matrix_mul(UInt32[] output, int outputOffset, UInt32[] state, int stateOffset, UInt32[] matrix, int matrixOffset, int players);
    private void mpc_xor_constant(UInt32[] state, int stateOffset, UInt32[] input, int inOffset, int len);
    private bool CreateRandomTape(Byte[] seed, int seedOffset, Byte[] salt, UInt32 roundNumber, UInt32 playerNumber, Byte[] tape, int tapeLen);
    private Byte[] ComputeSeeds(UInt32[] privateKey, UInt32[] publicKey, UInt32[] plaintext, Byte[] message);
    private void sign_picnic3(UInt32[] privateKey, UInt32[] pubKey, UInt32[] plaintext, Byte[] message, Signature2 sig);
    private static int IndexOf(UInt32[] list, int len, UInt32 value);
    private UInt32[] GetMissingLeavesList(UInt32[] challengeC);
    private void HCP(Byte[] challengeHash, UInt32[] challengeC, UInt32[] challengeP, Byte[][] Ch, Byte[] hCv, Byte[] salt, UInt32[] pubKey, UInt32[] plaintext, Byte[] message);
    private static int BitsToChunks(int chunkLenBits, Byte[] input, int inputLen, UInt32[] chunks);
    private static UInt32 AppendUnique(UInt32[] list, UInt32 value, UInt32 position);
    private void ExpandChallengeHash(Byte[] challengeHash, UInt32[] challengeC, UInt32[] challengeP);
    private void commit_h(Byte[] digest_arr, Byte[][] C);
    private void commit_v(Byte[] digest_arr, Byte[] input, Msg msg);
    private int SimulateOnline(UInt32[] maskedKey, Tape tape, UInt32[] tmp_shares, Msg msg, UInt32[] plaintext, UInt32[] pubKey);
    private void CreateRandomTapes(Tape tape, Byte[][] seeds, UInt32 seedsOffset, Byte[] salt, UInt32 t);
    private static bool SubarrayEquals(Byte[] a, Byte[] b, int length);
    private static bool SubarrayEquals(UInt32[] a, UInt32[] b, int length);
    private static UInt32 Extend(UInt32 bit);
    private void WordToMsgs(UInt32 w, Msg msg);
    private UInt32 mpc_AND(UInt32 a, UInt32 b, UInt32 mask_a, UInt32 mask_b, Tape tape, Msg msg);
    private void mpc_sbox(UInt32[] state, UInt32[] state_masks, Tape tape, Msg msg);
    internal void aux_mpc_sbox(UInt32[] input, UInt32[] output, Tape tape);
    private void aux_mpc_AND(UInt32 mask_a, UInt32 mask_b, UInt32 fresh_output_mask, Tape tape);
    private bool Contains(UInt32[] list, int len, UInt32 value);
    private void TapesToWords(UInt32[] shares, Tape tape);
    private void GetAuxBits(Byte[] output, Tape tape);
    private void commit(Byte[] digest_arr, Byte[] seed, Byte[] aux, Byte[] salt, UInt32 t, UInt32 j);
    private void ComputeSaltAndRootSeed(Byte[] saltAndRoot, UInt32[] privateKey, UInt32[] pubKey, UInt32[] plaintext, Byte[] message);
    private static bool is_picnic3(int parameters);
    internal void crypto_sign_keypair(Byte[] pk, Byte[] sk, SecureRandom random);
    private int picnic_write_private_key(Byte[] data, Byte[] ciphertext, Byte[] plaintext, Byte[] buf);
    private int picnic_write_public_key(Byte[] ciphertext, Byte[] plaintext, Byte[] buf);
    private void picnic_keygen(Byte[] plaintext_bytes, Byte[] ciphertext_bytes, Byte[] data_bytes, SecureRandom random);
    private void LowMCEnc(UInt32[] plaintext, UInt32[] output, UInt32[] key);
    private void Substitution(UInt32[] state);
    private void xor_three(UInt32[] output, UInt32[] in1, UInt32[] in2, UInt32[] in3, int lenBytes);
    internal void xor_array(UInt32[] output, UInt32[] in1, UInt32[] in2, int in2_offset, int length);
    internal void matrix_mul(UInt32[] output, UInt32[] state, UInt32[] matrix, int matrixOffset);
    internal void matrix_mul_offset(UInt32[] output, int outputOffset, UInt32[] state, int stateOffset, UInt32[] matrix, int matrixOffset);
}
public class Org.BouncyCastle.Pqc.Crypto.Picnic.PicnicKeyGenerationParameters : KeyGenerationParameters {
    private PicnicParameters m_parameters;
    public PicnicParameters Parameters { get; }
    public PicnicKeyGenerationParameters(SecureRandom random, PicnicParameters parameters);
    public PicnicParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Picnic.PicnicKeyPairGenerator : object {
    private SecureRandom random;
    private PicnicParameters parameters;
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Picnic.PicnicKeyParameters : AsymmetricKeyParameter {
    private PicnicParameters m_parameters;
    public PicnicParameters Parameters { get; }
    internal PicnicKeyParameters(bool isPrivate, PicnicParameters parameters);
    public PicnicParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Picnic.PicnicParameters : object {
    public static PicnicParameters picnicl1fs;
    public static PicnicParameters picnicl1ur;
    public static PicnicParameters picnicl3fs;
    public static PicnicParameters picnicl3ur;
    public static PicnicParameters picnicl5fs;
    public static PicnicParameters picnicl5ur;
    public static PicnicParameters picnic3l1;
    public static PicnicParameters picnic3l3;
    public static PicnicParameters picnic3l5;
    public static PicnicParameters picnicl1full;
    public static PicnicParameters picnicl3full;
    public static PicnicParameters picnicl5full;
    private string name;
    private int param;
    public string Name { get; }
    private PicnicParameters(string name, int param);
    private static PicnicParameters();
    public string get_Name();
    internal PicnicEngine GetEngine();
}
public class Org.BouncyCastle.Pqc.Crypto.Picnic.PicnicPrivateKeyParameters : PicnicKeyParameters {
    private Byte[] m_privateKey;
    public PicnicPrivateKeyParameters(PicnicParameters parameters, Byte[] skEncoded);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Picnic.PicnicPublicKeyParameters : PicnicKeyParameters {
    private Byte[] m_publicKey;
    public PicnicPublicKeyParameters(PicnicParameters parameters, Byte[] pkEncoded);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.Picnic.PicnicSigner : object {
    private PicnicPrivateKeyParameters privKey;
    private PicnicPublicKeyParameters pubKey;
    public sealed virtual void Init(bool forSigning, ICipherParameters param);
    public sealed virtual Byte[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, Byte[] signature);
}
internal static class Org.BouncyCastle.Pqc.Crypto.Picnic.PicnicUtilities : object {
    internal static void Fill(UInt32[] buf, int from, int to, UInt32 b);
    internal static int NumBytes(int numBits);
    internal static UInt32 ceil_log2(UInt32 x);
    internal static int Parity(Byte[] data, int len);
    internal static UInt32 Parity16(UInt32 x);
    internal static UInt32 Parity32(UInt32 x);
    internal static void SetBitInWordArray(UInt32[] array, int bitNumber, UInt32 val);
    internal static UInt32 GetBitFromWordArray(UInt32[] array, int bitNumber);
    internal static byte GetBit(Byte[] array, int bitNumber);
    internal static UInt32 GetBit(UInt32 word, int bitNumber);
    internal static UInt32 GetBit(UInt32[] array, int bitNumber);
    internal static void SetBit(Byte[] array, int bitNumber, byte val);
    internal static UInt32 SetBit(UInt32 word, int bitNumber, UInt32 bit);
    internal static void SetBit(UInt32[] array, int bitNumber, UInt32 val);
    internal static void ZeroTrailingBits(Byte[] data, int bitLength);
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.Signature : object {
    internal Byte[] challengeBits;
    internal Byte[] salt;
    internal Proof[] proofs;
    internal Signature(PicnicEngine engine);
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.Signature2 : object {
    internal Byte[] salt;
    internal Byte[] iSeedInfo;
    internal int iSeedInfoLen;
    internal Byte[] cvInfo;
    internal int cvInfoLen;
    internal Byte[] challengeHash;
    internal UInt32[] challengeC;
    internal UInt32[] challengeP;
    internal Proof2[] proofs;
    internal Signature2(PicnicEngine engine);
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.Tape : object {
    internal Byte[][] tapes;
    internal int pos;
    private int nTapes;
    private PicnicEngine engine;
    internal Tape(PicnicEngine engine);
    internal void SetAuxBits(Byte[] input);
    internal void ComputeAuxTape(Byte[] inputs);
    private void TapesToParityBits(UInt32[] output, int outputBitLen);
    internal UInt32 TapesToWord();
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.Tree : object {
    private static int MAX_SEED_SIZE_BYTES;
    private UInt32 MAX_AUX_BYTES;
    private UInt32 depth;
    internal Byte[][] nodes;
    private int dataSize;
    private Boolean[] haveNode;
    private Byte[] exists;
    private UInt32 numNodes;
    private UInt32 numLeaves;
    private PicnicEngine engine;
    internal Tree(PicnicEngine engine, UInt32 numLeaves, int dataSize);
    private static Tree();
    internal Byte[][] GetLeaves();
    internal UInt32 GetLeavesOffset();
    internal void BuildMerkleTree(Byte[][] leafData, Byte[] salt);
    internal int VerifyMerkleTree(Byte[][] leafData, Byte[] salt);
    internal int ReconstructSeeds(UInt32[] hideList, UInt32 hideListSize, Byte[] input, UInt32 inputLen, Byte[] salt, UInt32 repIndex);
    internal Byte[] OpenMerkleTree(UInt32[] missingLeaves, UInt32 missingLeavesSize, Int32[] outputSizeBytes);
    private UInt32[] GetRevealedNodes(UInt32[] hideList, UInt32 hideListSize, UInt32[] outputSize);
    private UInt32 GetSibling(UInt32 node);
    private bool IsLeafNode(UInt32 node);
    private bool HasSibling(UInt32 node);
    internal UInt32 RevealSeedsSize(UInt32[] hideList, UInt32 hideListSize);
    internal int RevealSeeds(UInt32[] hideList, UInt32 hideListSize, Byte[] output, int outputSize);
    internal UInt32 OpenMerkleTreeSize(UInt32[] missingLeaves, UInt32 missingLeavesSize);
    private UInt32[] GetRevealedMerkleNodes(UInt32[] missingLeaves, UInt32 missingLeavesSize, UInt32[] outputSize);
    private bool Contains(UInt32[] list, UInt32 len, UInt32 value);
    private void ComputeParentHash(UInt32 child, Byte[] salt);
    internal Byte[] GetLeaf(UInt32 leafIndex);
    internal int AddMerkleNodes(UInt32[] missingLeaves, UInt32 missingLeavesSize, Byte[] input, UInt32 inputSize);
    internal void GenerateSeeds(Byte[] rootSeed, Byte[] salt, UInt32 repIndex);
    private void ExpandSeeds(Byte[] salt, UInt32 repIndex);
    private void HashSeed(Byte[] digest_arr, Byte[] inputSeed, Byte[] salt, byte hashPrefix, UInt32 repIndex, UInt32 nodeIndex);
    private bool IsLeftChild(UInt32 node);
    private bool HasRightChild(UInt32 node);
    private UInt32 GetParent(UInt32 node);
    private bool Exists(UInt32 i);
}
internal class Org.BouncyCastle.Pqc.Crypto.Picnic.View : object {
    internal UInt32[] inputShare;
    internal Byte[] communicatedBits;
    internal UInt32[] outputShare;
    internal View(PicnicEngine engine);
}
internal class Org.BouncyCastle.Pqc.Crypto.Saber.Poly : object {
    private static int KARATSUBA_N;
    private int N_SB;
    private int N_SB_RES;
    private int SABER_N;
    private int SABER_L;
    private SaberEngine engine;
    private SaberUtilities utils;
    public Poly(SaberEngine engine);
    public void GenMatrix(Int16[][][] A, Byte[] seed);
    public void GenSecret(Int16[][] s, Byte[] seed);
    private long LoadLittleEndian(Byte[] x, int offset, int bytes);
    private void Cbd(Int16[] s, Byte[] buf, int offset);
    private short OVERFLOWING_MUL(int x, int y);
    private void karatsuba_simple(Int32[] a_1, Int32[] b_1, Int32[] result_final);
    private void toom_cook_4way(Int16[] a1, Int16[] b1, Int16[] result);
    private void poly_mul_acc(Int16[] a, Int16[] b, Int16[] res);
    public void MatrixVectorMul(Int16[][][] A, Int16[][] s, Int16[][] res, int transpose);
    public void InnerProd(Int16[][] b, Int16[][] s, Int16[] res);
}
internal class Org.BouncyCastle.Pqc.Crypto.Saber.SaberEngine : object {
    internal static int SABER_EP;
    internal static int SABER_N;
    private static int SABER_SEEDBYTES;
    private static int SABER_NOISE_SEEDBYTES;
    private static int SABER_KEYBYTES;
    private static int SABER_HASHBYTES;
    private int SABER_L;
    private int SABER_MU;
    private int SABER_ET;
    private int SABER_POLYCOINBYTES;
    private int SABER_EQ;
    private int SABER_POLYBYTES;
    private int SABER_POLYVECBYTES;
    private int SABER_POLYCOMPRESSEDBYTES;
    private int SABER_POLYVECCOMPRESSEDBYTES;
    private int SABER_SCALEBYTES_KEM;
    private int SABER_INDCPA_PUBLICKEYBYTES;
    private int SABER_INDCPA_SECRETKEYBYTES;
    private int SABER_PUBLICKEYBYTES;
    private int SABER_SECRETKEYBYTES;
    private int SABER_BYTES_CCA_DEC;
    private int defaultKeySize;
    private int h1;
    private int h2;
    private Symmetric symmetric;
    private SaberUtilities utils;
    private Poly poly;
    private bool usingAes;
    private bool usingEffectiveMasking;
    public bool UsingAes { get; }
    public bool UsingEffectiveMasking { get; }
    public Symmetric Symmetric { get; }
    public int EQ { get; }
    public int N { get; }
    public int EP { get; }
    public int KeyBytes { get; }
    public int L { get; }
    public int ET { get; }
    public int PolyBytes { get; }
    public int PolyVecBytes { get; }
    public int SeedBytes { get; }
    public int PolyCoinBytes { get; }
    public int NoiseSeedBytes { get; }
    public int MU { get; }
    public SaberUtilities Utilities { get; }
    internal SaberEngine(int l, int defaultKeySize, bool usingAes, bool usingEffectiveMasking);
    public bool get_UsingAes();
    public bool get_UsingEffectiveMasking();
    public Symmetric get_Symmetric();
    public int get_EQ();
    public int get_N();
    public int get_EP();
    public int get_KeyBytes();
    public int get_L();
    public int get_ET();
    public int get_PolyBytes();
    public int get_PolyVecBytes();
    public int get_SeedBytes();
    public int get_PolyCoinBytes();
    public int get_NoiseSeedBytes();
    public int get_MU();
    public SaberUtilities get_Utilities();
    public int GetSessionKeySize();
    public int GetCipherTextSize();
    public int GetPublicKeySize();
    public int GetPrivateKeySize();
    private void indcpa_kem_keypair(Byte[] pk, Byte[] sk, SecureRandom random);
    public int crypto_kem_keypair(Byte[] pk, Byte[] sk, SecureRandom random);
    private void indcpa_kem_enc(Byte[] m, Byte[] seed_sp, Byte[] pk, Byte[] ciphertext);
    public int crypto_kem_enc(Byte[] c, Byte[] k, Byte[] pk, SecureRandom random);
    private void indcpa_kem_dec(Byte[] sk, Byte[] ciphertext, Byte[] m);
    public int crypto_kem_dec(Byte[] k, Byte[] c, Byte[] sk);
    private static int verify(Byte[] a, Byte[] b, int len);
    private static void cmov(Byte[] r, Byte[] x, int x_offset, int len, byte b);
}
public class Org.BouncyCastle.Pqc.Crypto.Saber.SaberKemExtractor : object {
    private SaberKeyParameters key;
    private SaberEngine engine;
    public int EncapsulationLength { get; }
    public SaberKemExtractor(SaberKeyParameters privParams);
    private void InitCipher(SaberParameters param);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    public sealed virtual int get_EncapsulationLength();
}
public class Org.BouncyCastle.Pqc.Crypto.Saber.SaberKemGenerator : object {
    private SecureRandom sr;
    public SaberKemGenerator(SecureRandom random);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
}
public class Org.BouncyCastle.Pqc.Crypto.Saber.SaberKeyGenerationParameters : KeyGenerationParameters {
    private SaberParameters parameters;
    public SaberParameters Parameters { get; }
    public SaberKeyGenerationParameters(SecureRandom random, SaberParameters saberParameters);
    public SaberParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Saber.SaberKeyPairGenerator : object {
    private SaberKeyGenerationParameters saberParams;
    private int l;
    private SecureRandom random;
    private void Initialize(KeyGenerationParameters param);
    private AsymmetricCipherKeyPair GenKeyPair();
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Saber.SaberKeyParameters : AsymmetricKeyParameter {
    private SaberParameters m_parameters;
    public SaberParameters Parameters { get; }
    internal SaberKeyParameters(bool isPrivate, SaberParameters parameters);
    public SaberParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.Saber.SaberParameters : object {
    public static SaberParameters lightsaberkem128r3;
    public static SaberParameters saberkem128r3;
    public static SaberParameters firesaberkem128r3;
    public static SaberParameters lightsaberkem192r3;
    public static SaberParameters saberkem192r3;
    public static SaberParameters firesaberkem192r3;
    public static SaberParameters lightsaberkem256r3;
    public static SaberParameters saberkem256r3;
    public static SaberParameters firesaberkem256r3;
    public static SaberParameters lightsaberkem90sr3;
    public static SaberParameters saberkem90sr3;
    public static SaberParameters firesaberkem90sr3;
    public static SaberParameters ulightsaberkemr3;
    public static SaberParameters usaberkemr3;
    public static SaberParameters ufiresaberkemr3;
    public static SaberParameters ulightsaberkem90sr3;
    public static SaberParameters usaberkem90sr3;
    public static SaberParameters ufiresaberkem90sr3;
    private string name;
    private int l;
    private int defaultKeySize;
    private SaberEngine engine;
    public string Name { get; }
    public int L { get; }
    public int DefaultKeySize { get; }
    internal SaberEngine Engine { get; }
    private SaberParameters(string name, int l, int defaultKeySize, bool usingAes, bool usingEffectiveMasking);
    private static SaberParameters();
    public string get_Name();
    public int get_L();
    public int get_DefaultKeySize();
    internal SaberEngine get_Engine();
}
public class Org.BouncyCastle.Pqc.Crypto.Saber.SaberPrivateKeyParameters : SaberKeyParameters {
    private Byte[] privateKey;
    public SaberPrivateKeyParameters(SaberParameters parameters, Byte[] privateKey);
    public Byte[] GetEncoded();
    public Byte[] GetPrivateKey();
}
public class Org.BouncyCastle.Pqc.Crypto.Saber.SaberPublicKeyParameters : SaberKeyParameters {
    public Byte[] publicKey;
    public SaberPublicKeyParameters(SaberParameters parameters, Byte[] publicKey);
    public Byte[] GetEncoded();
    public Byte[] GetPublicKey();
}
internal class Org.BouncyCastle.Pqc.Crypto.Saber.SaberUtilities : object {
    private int SABER_N;
    private int SABER_L;
    private int SABER_ET;
    private int SABER_POLYBYTES;
    private int SABER_EP;
    private int SABER_KEYBYTES;
    private bool usingEffectiveMasking;
    internal SaberUtilities(SaberEngine engine);
    public void POLT2BS(Byte[] bytes, int byteIndex, Int16[] data);
    public void BS2POLT(Byte[] bytes, int byteIndex, Int16[] data);
    private void POLq2BS(Byte[] bytes, int byteIndex, Int16[] data);
    private void BS2POLq(Byte[] bytes, int byteIndex, Int16[] data);
    private void POLp2BS(Byte[] bytes, int byteIndex, Int16[] data);
    public void BS2POLp(Byte[] bytes, int byteIndex, Int16[] data);
    public void POLVECq2BS(Byte[] bytes, Int16[][] data);
    public void BS2POLVECq(Byte[] bytes, int byteIndex, Int16[][] data);
    public void POLVECp2BS(Byte[] bytes, Int16[][] data);
    public void BS2POLVECp(Byte[] bytes, Int16[][] data);
    public void BS2POLmsg(Byte[] bytes, Int16[] data);
    public void POLmsg2BS(Byte[] bytes, Int16[] data);
}
public abstract class Org.BouncyCastle.Pqc.Crypto.Saber.Symmetric : object {
    internal abstract virtual void Hash_h(Byte[] output, Byte[] input, int outputOffset);
    internal abstract virtual void Hash_g(Byte[] output, Byte[] input);
    internal abstract virtual void Prf(Byte[] output, Byte[] input, int inLen, int outputLen);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.Fpx : object {
    private SikeEngine engine;
    internal Fpx(SikeEngine engine);
    private void mp_shiftl1(UInt64[] x, UInt32 nwords);
    internal void sqr_Fp2_cycl(UInt64[][] a, UInt64[] one);
    internal void mont_n_way_inv(UInt64[][][] vec, UInt32 n, UInt64[][][] output);
    internal void fpcopy(UInt64[] a, long aOffset, UInt64[] c);
    internal void mp2_add(UInt64[][] a, UInt64[][] b, UInt64[][] c);
    internal void fp2correction(UInt64[][] a);
    internal ulong mp_add(UInt64[] a, UInt64[] b, UInt64[] c, UInt32 nwords);
    private ulong mp_add(UInt64[] a, UInt32 aOffset, UInt64[] b, UInt64[] c, UInt32 cOffset, UInt32 nwords);
    private ulong mp_add(UInt64[] a, UInt32 aOffset, UInt64[] b, UInt32 bOffset, UInt64[] c, UInt32 cOffset, UInt32 nwords);
    private ulong is_digit_lessthan_ct(ulong x, ulong y);
    private ulong is_digit_nonzero_ct(ulong x);
    private ulong is_digit_zero_ct(ulong x);
    internal void fp2neg(UInt64[][] a);
    internal bool is_felm_zero(UInt64[] x);
    private bool is_felm_lt(UInt64[] x, UInt64[] y);
    private static bool is_felm_even(UInt64[] x);
    internal bool is_sqr_fp2(UInt64[][] a, UInt64[] s);
    private UInt32 fpinv_mont_bingcd_partial(UInt64[] a, UInt64[] x1);
    private void power2_setup(UInt64[] x, int mark, UInt32 nwords);
    private void fpinv_mont_bingcd(UInt64[] a);
    internal void fp2inv_mont_bingcd(UInt64[][] a);
    internal void fp2div2(UInt64[][] a, UInt64[][] c);
    private void fpdiv2_PRIME(UInt64[] a, UInt64[] c);
    private void mp_subPRIME_p2(UInt64[] a, UInt64[] b, UInt64[] c);
    private void mp_subPRIME_p4(UInt64[] a, UInt64[] b, UInt64[] c);
    private ulong digit_x_digit(ulong a, ulong b, UInt64& low);
    private void rdc_mont(UInt64[] ma, UInt64[] mc);
    internal static bool subarrayEquals(UInt64[] a, UInt64[] b, UInt32 length);
    internal static bool subarrayEquals(UInt64[][] a, UInt64[][] b, UInt32 length);
    internal static bool subarrayEquals(UInt64[][] a, UInt64[][] b, UInt32 bOffset, UInt32 length);
    internal static bool subarrayEquals(UInt64[][] a, UInt64[] b, UInt32 bOffset, UInt32 length);
    internal void sqrt_Fp2(UInt64[][] u, UInt64[][] y);
    internal void fp2sqr_mont(UInt64[][] a, UInt64[][] c);
    internal void fpaddPRIME(UInt64[] a, UInt64[] b, UInt64[] c);
    internal void cube_Fp2_cycl(UInt64[][] a, UInt64[] one);
    internal void fpsubPRIME(UInt64[] a, UInt64[] b, UInt32 bOffset, UInt64[] c);
    internal void fpsubPRIME(UInt64[] a, UInt32 aOffset, UInt64[] b, UInt64[] c);
    internal void fpsubPRIME(UInt64[] a, UInt64[] b, UInt64[] c);
    internal void fpnegPRIME(UInt64[] a);
    internal void from_fp2mont(UInt64[][] ma, UInt64[][] c);
    internal void fp2_encode(UInt64[][] x, Byte[] enc, UInt32 encOffset);
    internal void fp2_decode(Byte[] x, UInt64[][] dec, UInt32 xOffset);
    internal void to_Montgomery_mod_order(UInt64[] a, UInt64[] mc, UInt64[] order, UInt64[] Montgomery_rprime, UInt64[] Montgomery_Rprime);
    internal void Montgomery_multiply_mod_order(UInt64[] ma, UInt64[] mb, UInt64[] mc, UInt64[] order, UInt64[] Montgomery_rprime);
    internal void inv_mod_orderA(UInt64[] a, UInt64[] c);
    internal void multiply(UInt64[] a, UInt64[] b, UInt64[] c, UInt32 nwords);
    private bool is_zero_mod_order(UInt64[] x);
    private bool is_even_mod_order(UInt64[] x);
    private bool is_lt_mod_order(UInt64[] x, UInt64[] y);
    private bool is_zero(UInt64[] a, UInt32 nwords);
    private UInt32 Montgomery_inversion_mod_order_bingcd_partial(UInt64[] a, UInt64[] x1, UInt64[] order);
    internal void Montgomery_inversion_mod_order_bingcd(UInt64[] a, UInt64[] c, UInt64[] order, UInt64[] Montgomery_rprime, UInt64[] Montgomery_Rprime);
    internal void from_Montgomery_mod_order(UInt64[] ma, UInt64[] c, UInt64[] order, UInt64[] Montgomery_rprime);
    internal UInt32 mod3(UInt64[] a);
    internal void to_fp2mont(UInt64[][] a, UInt64[][] mc);
    private void to_mont(UInt64[] a, UInt64[] mc);
    internal void fpcorrectionPRIME(UInt64[] a);
    internal byte cmp_f2elm(UInt64[][] x, UInt64[][] y);
    internal void encode_to_bytes(UInt64[] x, Byte[] enc, UInt32 encOffset, UInt32 nbytes);
    internal void decode_to_digits(Byte[] x, UInt32 xOffset, UInt64[] dec, UInt32 nbytes, UInt32 ndigits);
    internal void fp2_conj(UInt64[][] v, UInt64[][] r);
    private void from_mont(UInt64[] ma, UInt64[] c);
    private void mp_shiftr1(UInt64[] x);
    private void mp_shiftr1(UInt64[] x, UInt32 nwords);
    internal void fp2copy(UInt64[][] a, UInt64[][] c);
    internal void fp2copy(UInt64[][] a, UInt32 aOffset, UInt64[][] c);
    internal void fp2copy(UInt64[] a, UInt32 aOffset, UInt64[][] c);
    internal void fpzero(UInt64[] a);
    internal void mp2_sub_p2(UInt64[][] a, UInt64[][] b, UInt64[][] c);
    internal void mp_mul(UInt64[] a, UInt64[] b, UInt64[] c, UInt32 nwords);
    internal void mp_mul(UInt64[] a, UInt32 aOffset, UInt64[] b, UInt64[] c, UInt32 nwords);
    internal void fp2mul_mont(UInt64[][] a, UInt64[][] b, UInt64[][] c);
    internal void fp2mul_mont(UInt64[][] a, UInt64[][] b, UInt32 bOffset, UInt64[][] c);
    internal void fp2mul_mont(UInt64[][] a, UInt64[] b, UInt32 bOffset, UInt64[][] c);
    private void mp_dblsubfast(UInt64[] a, UInt64[] b, UInt64[] c);
    internal ulong mp_sub(UInt64[] a, UInt64[] b, UInt64[] c, UInt32 nwords);
    internal bool is_orderelm_lt(UInt64[] x, UInt64[] y);
    private void mp_subaddfast(UInt64[] a, UInt64[] b, UInt64[] c);
    internal void fpsqr_mont(UInt64[] ma, UInt64[] mc);
    private void fpinv_mont(UInt64[] a);
    internal void fp2inv_mont(UInt64[][] a);
    internal void mul3(Byte[] a);
    internal byte ct_compare(Byte[] a, Byte[] b, UInt32 len);
    internal void ct_cmov(Byte[] r, Byte[] a, UInt32 len, byte selector);
    internal void copy_words(UInt64[] a, UInt64[] c, UInt32 nwords);
    internal void fp2shl(UInt64[][] a, UInt32 k, UInt64[][] c);
    internal void copy_words(PointProj a, PointProj c);
    internal void Montgomery_neg(UInt64[] a, UInt64[] order);
    internal void fp2add(UInt64[][] a, UInt64[][] b, UInt64[][] c);
    internal void fp2sub(UInt64[][] a, UInt64[][] b, UInt64[][] c);
    private void mp2_sub_p4(UInt64[][] a, UInt64[][] b, UInt64[][] c);
    internal void fpmul_mont(UInt64[] ma, UInt64[] mb, UInt64[] mc);
    internal void fpmul_mont(UInt64[] ma, UInt32 maOffset, UInt64[] mb, UInt64[] mc);
    private void fpinv_chain_mont(UInt64[] a);
}
internal abstract class Org.BouncyCastle.Pqc.Crypto.Sike.Internal : object {
    protected internal static UInt32 RADIX;
    protected internal static UInt32 LOG2RADIX;
    protected internal UInt32 CRYPTO_PUBLICKEYBYTES;
    protected internal int CRYPTO_CIPHERTEXTBYTES;
    protected internal UInt32 CRYPTO_BYTES;
    protected internal UInt32 CRYPTO_SECRETKEYBYTES;
    protected internal UInt32 NWORDS_FIELD;
    protected internal UInt32 PRIME_ZERO_WORDS;
    protected internal UInt32 NBITS_FIELD;
    protected internal UInt32 MAXBITS_FIELD;
    protected UInt32 MAXWORDS_FIELD;
    protected UInt32 NWORDS64_FIELD;
    protected internal UInt32 NBITS_ORDER;
    protected internal UInt32 NWORDS_ORDER;
    protected UInt32 NWORDS64_ORDER;
    protected internal UInt32 MAXBITS_ORDER;
    protected internal UInt32 ALICE;
    protected internal UInt32 BOB;
    protected internal UInt32 OALICE_BITS;
    protected internal UInt32 OBOB_BITS;
    protected internal UInt32 OBOB_EXPON;
    protected internal UInt32 MASK_ALICE;
    protected internal UInt32 MASK_BOB;
    protected UInt32 PARAM_A;
    protected UInt32 PARAM_C;
    protected internal UInt32 MAX_INT_POINTS_ALICE;
    protected internal UInt32 MAX_INT_POINTS_BOB;
    protected internal UInt32 MAX_Alice;
    protected internal UInt32 MAX_Bob;
    protected internal UInt32 MSG_BYTES;
    protected internal UInt32 SECRETKEY_A_BYTES;
    protected internal UInt32 SECRETKEY_B_BYTES;
    protected internal UInt32 FP2_ENCODED_BYTES;
    protected bool COMPRESS;
    protected internal UInt32 MASK2_BOB;
    protected internal UInt32 MASK3_BOB;
    protected internal UInt32 ORDER_A_ENCODED_BYTES;
    protected internal UInt32 ORDER_B_ENCODED_BYTES;
    protected internal UInt32 PARTIALLY_COMPRESSED_CHUNK_CT;
    protected UInt32 COMPRESSED_CHUNK_CT;
    protected UInt32 UNCOMPRESSEDPK_BYTES;
    protected UInt32 TABLE_R_LEN;
    protected internal UInt32 TABLE_V_LEN;
    protected UInt32 TABLE_V3_LEN;
    protected internal UInt32 W_2;
    protected internal UInt32 W_3;
    protected internal UInt32 ELL2_W;
    protected internal UInt32 ELL3_W;
    protected internal UInt32 ELL2_EMODW;
    protected internal UInt32 ELL3_EMODW;
    protected internal UInt32 DLEN_2;
    protected internal UInt32 DLEN_3;
    protected internal UInt32 PLEN_2;
    protected internal UInt32 PLEN_3;
    protected internal UInt64[] PRIME;
    protected internal UInt64[] PRIMEx2;
    protected internal UInt64[] PRIMEx4;
    protected internal UInt64[] PRIMEp1;
    protected UInt64[] PRIMEx16p;
    protected UInt64[] PRIMEp1x64;
    protected internal UInt64[] Alice_order;
    protected internal UInt64[] Bob_order;
    protected internal UInt64[] A_gen;
    protected internal UInt64[] B_gen;
    protected internal UInt64[] Montgomery_R2;
    protected internal UInt64[] Montgomery_one;
    protected internal UInt32[] strat_Alice;
    protected internal UInt32[] strat_Bob;
    protected internal UInt64[] XQB3;
    protected internal UInt64[] A_basis_zero;
    protected UInt64[] B_basis_zero;
    protected internal UInt64[] B_gen_3_tors;
    protected internal UInt64[] g_R_S_im;
    protected UInt64[] g_phiR_phiS_re;
    protected UInt64[] g_phiR_phiS_im;
    protected UInt64[] Montgomery_R;
    protected internal UInt64[] Montgomery_RB1;
    protected internal UInt64[] Montgomery_RB2;
    protected UInt64[] threeinv;
    protected internal UInt32[] ph2_path;
    protected internal UInt32[] ph3_path;
    protected UInt64[] u_entang;
    protected UInt64[] u0_entang;
    protected internal UInt64[][] table_r_qr;
    protected internal UInt64[][] table_r_qnr;
    protected internal UInt64[][] table_v_qr;
    protected internal UInt64[][] table_v_qnr;
    protected internal UInt64[][][] v_3_torsion;
    protected internal UInt64[] T_tate3;
    protected internal UInt64[] T_tate2_firststep_P;
    protected internal UInt64[] T_tate2_P;
    protected internal UInt64[] T_tate2_firststep_Q;
    protected internal UInt64[] T_tate2_Q;
    protected internal UInt64[] ph2_T;
    protected internal UInt64[] ph2_T1;
    protected internal UInt64[] ph2_T2;
    protected internal UInt64[] ph3_T;
    protected internal UInt64[] ph3_T1;
    protected internal UInt64[] ph3_T2;
    private static Internal();
    internal static UInt32[] ReadIntsFromProperty(IDictionary`2<string, string> props, string key, UInt32 intSize);
    internal static UInt64[] ReadFromProperty(IDictionary`2<string, string> props, string key, UInt32 ulongSize);
    internal static UInt64[][] ReadFromProperty(IDictionary`2<string, string> props, string key, UInt32 d1Size, UInt32 d2Size);
    internal static UInt64[][][] ReadFromProperty(IDictionary`2<string, string> props, string key, UInt32 d1Size, UInt32 d2Size, UInt32 d3Size);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.Isogeny : object {
    private SikeEngine engine;
    internal Isogeny(SikeEngine engine);
    internal void Double(PointProj P, PointProj Q, UInt64[][] A24, UInt32 k);
    internal void CompleteMPoint(UInt64[][] A, PointProj P, PointProjFull R);
    internal void Ladder(PointProj P, UInt64[] m, UInt64[][] A, UInt32 order_bits, PointProj R);
    private void XDblAddProj(PointProj P, PointProj Q, UInt64[][] XPQ, UInt64[][] ZPQ, UInt64[][] A24);
    private void XDblE(PointProj P, PointProj Q, UInt64[][] A24, int e);
    internal void XTplEFast(PointProj P, PointProj Q, UInt64[][] A2, UInt32 e);
    private void XTplFast(PointProj P, PointProj Q, UInt64[][] A2);
    internal void LADDER3PT(UInt64[][] xP, UInt64[][] xQ, UInt64[][] xPQ, UInt64[] m, UInt32 AliceOrBob, PointProj R, UInt64[][] A);
    internal void CompletePoint(PointProj P, PointProjFull R);
    internal void SwapPoints(PointProj P, PointProj Q, ulong option);
    internal void XDblAdd(PointProj P, PointProj Q, UInt64[][] xPQ, UInt64[][] A24);
    internal void XDblE(PointProj P, PointProj Q, UInt64[][] A24plus, UInt64[][] C24, UInt32 e);
    internal void XDbl(PointProj P, PointProj Q, UInt64[][] A24plus, UInt64[][] C24);
    private void XTpl(PointProj P, PointProj Q, UInt64[][] A24minus, UInt64[][] A24plus);
    internal void XTplE(PointProj P, PointProj Q, UInt64[][] A24minus, UInt64[][] A24plus, UInt32 e);
    internal void GetA(UInt64[][] xP, UInt64[][] xQ, UInt64[][] xR, UInt64[][] A);
    internal void JInv(UInt64[][] A, UInt64[][] C, UInt64[][] jinv);
    internal void Get3Isog(PointProj P, UInt64[][] A24minus, UInt64[][] A24plus, UInt64[][][] coeff);
    internal void Eval3Isog(PointProj Q, UInt64[][][] coeff);
    internal void Inv3Way(UInt64[][] z1, UInt64[][] z2, UInt64[][] z3);
    internal void Get2Isog(PointProj P, UInt64[][] A, UInt64[][] C);
    internal void Eval2Isog(PointProj P, PointProj Q);
    internal void Get4Isog(PointProj P, UInt64[][] A24plus, UInt64[][] C24, UInt64[][][] coeff);
    internal void Eval4Isog(PointProj P, UInt64[][][] coeff);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.P434 : Internal {
    internal P434(bool isCompressed);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.P503 : Internal {
    internal P503(bool isCompressed);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.P610 : Internal {
    internal P610(bool isCompressed);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.P751 : Internal {
    internal P751(bool isCompressed);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.PointProj : object {
    internal UInt64[][] X;
    internal UInt64[][] Z;
    internal PointProj(UInt32 nwords_field);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.PointProjFull : object {
    internal UInt64[][] X;
    internal UInt64[][] Y;
    internal UInt64[][] Z;
    internal PointProjFull(UInt32 nwords_field);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.Sidh : object {
    private SikeEngine engine;
    internal Sidh(SikeEngine engine);
    internal void init_basis(UInt64[] gen, UInt64[][] XP, UInt64[][] XQ, UInt64[][] XR);
    internal void EphemeralKeyGeneration_B(Byte[] sk, Byte[] pk);
    internal void EphemeralKeyGeneration_A(Byte[] ephemeralsk, Byte[] ct);
    internal void EphemeralSecretAgreement_A(Byte[] ephemeralsk, Byte[] pk, Byte[] jinvariant);
    internal void EphemeralSecretAgreement_B(Byte[] sk, Byte[] ct, Byte[] jinvariant_);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.SidhCompressed : object {
    private SikeEngine engine;
    private static UInt32 t_points;
    internal SidhCompressed(SikeEngine engine);
    private static SidhCompressed();
    internal void init_basis(UInt64[] gen, UInt64[][] XP, UInt64[][] XQ, UInt64[][] XR);
    internal void FormatPrivKey_B(Byte[] skB);
    internal void random_mod_order_A(Byte[] random_digits, SecureRandom random);
    internal void random_mod_order_B(Byte[] random_digits, SecureRandom random);
    internal void Ladder3pt_dual(PointProj[] Rs, UInt64[] m, UInt32 AliceOrBob, PointProj R, UInt64[][] A24);
    internal void Elligator2(UInt64[][] a24, UInt32[] r, UInt32 rIndex, UInt64[][] x, Byte[] bit, UInt32 bitOffset, UInt32 COMPorDEC);
    internal void make_positive(UInt64[][] x);
    internal void BiQuad_affine(UInt64[][] a24, UInt64[][] x0, UInt64[][] x1, PointProj R);
    internal void get_4_isog_dual(PointProj P, UInt64[][] A24, UInt64[][] C24, UInt64[][][] coeff);
    internal void eval_dual_2_isog(UInt64[][] X2, UInt64[][] Z2, PointProj P);
    internal void eval_final_dual_2_isog(PointProj P);
    internal void eval_dual_4_isog_shared(UInt64[][] X4pZ4, UInt64[][] X42, UInt64[][] Z42, UInt64[][][] coeff, UInt32 coeffOffset);
    internal void eval_dual_4_isog(UInt64[][] A24, UInt64[][] C24, UInt64[][][] coeff, UInt32 coeffOffset, PointProj P);
    internal void eval_full_dual_4_isog(UInt64[][][][] As, PointProj P);
    internal void TripleAndParabola_proj(PointProjFull R, UInt64[][] l1x, UInt64[][] l1z);
    internal void Tate3_proj(PointProjFull P, PointProjFull Q, UInt64[][] gX, UInt64[][] gZ);
    internal void FinalExpo3(UInt64[][] gX, UInt64[][] gZ);
    internal void FinalExpo3_2way(UInt64[][][] gX, UInt64[][][] gZ);
    private bool FirstPoint_dual(PointProj P, PointProjFull R, Byte[] ind);
    private bool SecondPoint_dual(PointProj P, PointProjFull R, Byte[] ind);
    internal void FirstPoint3n(UInt64[][] a24, UInt64[][][][] As, UInt64[][] x, PointProjFull R, UInt32[] r, Byte[] ind, Byte[] bitEll);
    internal void SecondPoint3n(UInt64[][] a24, UInt64[][][][] As, UInt64[][] x, PointProjFull R, UInt32[] r, Byte[] ind, Byte[] bitEll);
    internal void makeDiff(PointProjFull R, PointProjFull S, PointProj D);
    internal void BuildOrdinary3nBasis_dual(UInt64[][] a24, UInt64[][][][] As, PointProjFull[] R, UInt32[] r, UInt32[] bitsEll, UInt32 bitsEllOffset);
    internal void FullIsogeny_A_dual(Byte[] PrivateKeyA, UInt64[][][][] As, UInt64[][] a24, UInt32 sike);
    internal void Dlogs3_dual(UInt64[][][] f, Int32[] D, UInt64[] d0, UInt64[] c0, UInt64[] d1, UInt64[] c1);
    internal void BuildOrdinary3nBasis_Decomp_dual(UInt64[][] A24, PointProj[] Rs, UInt32[] r, UInt32[] bitsEll, UInt32 bitsEllIndex);
    internal void PKADecompression_dual(Byte[] SecretKeyB, Byte[] CompressedPKA, PointProj R, UInt64[][] A);
    internal void Compress_PKA_dual(UInt64[] d0, UInt64[] c0, UInt64[] d1, UInt64[] c1, UInt64[][] a24, UInt32[] rs, Byte[] CompressedPKA);
    internal UInt32 EphemeralKeyGeneration_A_extended(Byte[] PrivateKeyA, Byte[] CompressedPKA);
    private UInt32 EphemeralKeyGeneration_A(Byte[] PrivateKeyA, Byte[] CompressedPKA);
    internal UInt32 EphemeralSecretAgreement_B(Byte[] PrivateKeyB, Byte[] PKA, Byte[] SharedSecretB);
    internal void BuildEntangledXonly(UInt64[][] A, PointProj[] R, Byte[] qnr, Byte[] ind);
    internal void RecoverY(UInt64[][] A, PointProj[] xs, PointProjFull[] Rs);
    internal void BuildOrdinary2nBasis_dual(UInt64[][] A, UInt64[][][][] Ds, PointProjFull[] Rs, Byte[] qnr, Byte[] ind);
    internal void FullIsogeny_B_dual(Byte[] PrivateKeyB, UInt64[][][][] Ds, UInt64[][] A);
    internal void Dlogs2_dual(UInt64[][][] f, Int32[] D, UInt64[] d0, UInt64[] c0, UInt64[] d1, UInt64[] c1);
    internal void BuildEntangledXonly_Decomp(UInt64[][] A, PointProj[] R, UInt32 qnr, UInt32 ind);
    internal void PKBDecompression_extended(Byte[] SecretKeyA, UInt32 SecretKeyAOffset, Byte[] CompressedPKB, PointProj R, UInt64[][] A, Byte[] tphiBKA_t, UInt32 tphiBKA_tOffset);
    internal void Compress_PKB_dual_extended(UInt64[] d0, UInt64[] c0, UInt64[] d1, UInt64[] c1, UInt64[][] A, Byte[] qnr, Byte[] ind, Byte[] CompressedPKB);
    internal void PKBDecompression(Byte[] SecretKeyA, UInt32 SecretKeyAOffset, Byte[] CompressedPKB, PointProj R, UInt64[][] A);
    internal void Compress_PKB_dual(UInt64[] d0, UInt64[] c0, UInt64[] d1, UInt64[] c1, UInt64[][] A, Byte[] qnr, Byte[] ind, Byte[] CompressedPKB);
    internal UInt32 EphemeralKeyGeneration_B_extended(Byte[] PrivateKeyB, Byte[] CompressedPKB, UInt32 sike);
    internal UInt32 EphemeralKeyGeneration_B(Byte[] PrivateKeyB, Byte[] CompressedPKB);
    internal UInt32 EphemeralSecretAgreement_A_extended(Byte[] PrivateKeyA, UInt32 PrivateKeyAOffset, Byte[] PKB, Byte[] SharedSecretA, UInt32 sike);
    private UInt32 EphemeralSecretAgreement_A(Byte[] PrivateKeyA, UInt32 PrivateKeyAOffset, Byte[] PKB, Byte[] SharedSecretA);
    internal byte validate_ciphertext(Byte[] ephemeralsk_, Byte[] CompressedPKB, Byte[] xKA, UInt32 xKAOffset, Byte[] tphiBKA_t, UInt32 tphiBKA_tOffset);
    internal void solve_dlog(UInt64[][] r, Int32[] D, UInt64[] d, UInt32 ell);
    private void from_base(Int32[] D, UInt64[] r, UInt32 Dlen, UInt32 baseNum);
    internal void Traverse_w_notdiv_e_fullsigned(UInt64[][] r, UInt32 j, UInt32 k, UInt32 z, UInt32[] P, UInt64[] CT1, UInt64[] CT2, Int32[] D, UInt32 Dlen, UInt32 ell, UInt32 ellw, UInt32 ell_emodw, UInt32 w, UInt32 e);
    internal void Traverse_w_div_e_fullsigned(UInt64[][] r, UInt32 j, UInt32 k, UInt32 z, UInt32[] P, UInt64[] CT, Int32[] D, UInt32 Dlen, UInt32 ellw, UInt32 w);
    private void Tate3_pairings(PointProjFull[] Qj, UInt64[][][] f);
    private void final_exponentiation_3_torsion(UInt64[][] f, UInt64[][] finv, UInt64[][] fout);
    private void Tate2_pairings(PointProj P, PointProj Q, PointProjFull[] Qj, UInt64[][][] f);
    private void final_exponentiation_2_torsion(UInt64[][] f, UInt64[][] finv, UInt64[][] fout);
}
internal class Org.BouncyCastle.Pqc.Crypto.Sike.SikeEngine : object {
    internal Internal param;
    internal Isogeny isogeny;
    internal Fpx fpx;
    private Sidh sidh;
    private SidhCompressed sidhCompressed;
    private bool isCompressed;
    internal SikeEngine(int ver, bool isCompressed, SecureRandom random);
    internal UInt32 GetDefaultSessionKeySize();
    internal int GetCipherTextSize();
    internal UInt32 GetPrivateKeySize();
    internal UInt32 GetPublicKeySize();
    internal int crypto_kem_keypair(Byte[] pk, Byte[] sk, SecureRandom random);
    internal int crypto_kem_enc(Byte[] ct, Byte[] ss, Byte[] pk, SecureRandom random);
    internal int crypto_kem_dec(Byte[] ss, Byte[] ct, Byte[] sk);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Pqc.Crypto.Sike.SikeKemExtractor : object {
    private SikeKeyParameters key;
    private SikeEngine engine;
    public int EncapsulationLength { get; }
    public SikeKemExtractor(SikePrivateKeyParameters privParams);
    private void InitCipher(SikeParameters param);
    public sealed virtual Byte[] ExtractSecret(Byte[] encapsulation);
    public Byte[] ExtractSecret(Byte[] encapsulation, int sessionKeySizeInBits);
    public sealed virtual int get_EncapsulationLength();
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Pqc.Crypto.Sike.SikeKemGenerator : object {
    private SecureRandom sr;
    public SikeKemGenerator(SecureRandom random);
    public sealed virtual ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey);
    public ISecretWithEncapsulation GenerateEncapsulated(AsymmetricKeyParameter recipientKey, int sessionKeySizeInBits);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Pqc.Crypto.Sike.SikeKeyGenerationParameters : KeyGenerationParameters {
    private SikeParameters m_parameters;
    public SikeParameters Parameters { get; }
    public SikeKeyGenerationParameters(SecureRandom random, SikeParameters sikeParameters);
    public SikeParameters get_Parameters();
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Pqc.Crypto.Sike.SikeKeyPairGenerator : object {
    private SikeKeyGenerationParameters sikeParams;
    private SecureRandom random;
    private void Initialize(KeyGenerationParameters param);
    private AsymmetricCipherKeyPair GenKeyPair();
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
[ObsoleteAttribute("Will be removed")]
public abstract class Org.BouncyCastle.Pqc.Crypto.Sike.SikeKeyParameters : AsymmetricKeyParameter {
    private SikeParameters m_parameters;
    public SikeParameters Parameters { get; }
    internal SikeKeyParameters(bool isPrivate, SikeParameters parameters);
    public SikeParameters get_Parameters();
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Pqc.Crypto.Sike.SikeParameters : object {
    public static SikeParameters sikep434;
    public static SikeParameters sikep503;
    public static SikeParameters sikep610;
    public static SikeParameters sikep751;
    public static SikeParameters sikep434_compressed;
    public static SikeParameters sikep503_compressed;
    public static SikeParameters sikep610_compressed;
    public static SikeParameters sikep751_compressed;
    private int ver;
    private bool isCompressed;
    private string name;
    public string Name { get; }
    public int DefaultKeySize { get; }
    private SikeParameters(int ver, bool isCompressed, string name);
    private static SikeParameters();
    internal SikeEngine GetEngine();
    public string get_Name();
    public int get_DefaultKeySize();
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Pqc.Crypto.Sike.SikePrivateKeyParameters : SikeKeyParameters {
    private Byte[] privateKey;
    public SikePrivateKeyParameters(SikeParameters param, Byte[] privateKey);
    public Byte[] GetEncoded();
    public Byte[] GetPrivateKey();
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Pqc.Crypto.Sike.SikePublicKeyParameters : SikeKeyParameters {
    public Byte[] publicKey;
    public SikePublicKeyParameters(SikeParameters param, Byte[] publicKey);
    public Byte[] GetEncoded();
    public Byte[] GetPublicKey();
}
internal static class Org.BouncyCastle.Pqc.Crypto.Sike.SikeUtilities : object {
    internal static UInt64[][] InitArray(UInt32 size1, UInt32 size2);
    internal static UInt64[][][] InitArray(UInt32 size1, UInt32 size2, UInt32 size3);
    internal static UInt64[][][][] InitArray(UInt32 size1, UInt32 size2, UInt32 size3, UInt32 size4);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.Adrs : object {
    internal static UInt32 WOTS_HASH;
    internal static UInt32 WOTS_PK;
    internal static UInt32 TREE;
    internal static UInt32 FORS_TREE;
    internal static UInt32 FORS_PK;
    internal static UInt32 WOTS_PRF;
    internal static UInt32 FORS_PRF;
    internal static int OFFSET_LAYER;
    internal static int OFFSET_TREE;
    internal static int OFFSET_TREE_HGT;
    internal static int OFFSET_TREE_INDEX;
    internal static int OFFSET_TYPE;
    internal static int OFFSET_KP_ADDR;
    internal static int OFFSET_CHAIN_ADDR;
    internal static int OFFSET_HASH_ADDR;
    internal Byte[] value;
    internal Adrs(Adrs adrs);
    private static Adrs();
    internal void SetLayerAddress(UInt32 layer);
    internal UInt32 GetLayerAddress();
    internal void SetTreeAddress(ulong tree);
    internal ulong GetTreeAddress();
    internal void SetTreeHeight(UInt32 height);
    internal UInt32 GetTreeHeight();
    internal void SetTreeIndex(UInt32 index);
    internal UInt32 GetTreeIndex();
    internal void SetAdrsType(UInt32 adrsType);
    internal void ChangeAdrsType(UInt32 adrsType);
    internal UInt32 GetAdrsType();
    internal void SetKeyPairAddress(UInt32 keyPairAddr);
    internal UInt32 GetKeyPairAddress();
    internal void SetHashAddress(UInt32 hashAddr);
    public void SetChainAddress(UInt32 chainAddr);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.Fors : object {
    private SphincsPlusEngine engine;
    internal Fors(SphincsPlusEngine engine);
    internal Byte[] TreeHash(Byte[] skSeed, UInt32 s, int z, Byte[] pkSeed, Adrs adrsParam);
    internal SIG_FORS[] Sign(Byte[] md, Byte[] skSeed, Byte[] pkSeed, Adrs paramAdrs);
    internal Byte[] PKFromSig(SIG_FORS[] sig_fors, Byte[] message, Byte[] pkSeed, Adrs adrs);
    private static UInt32 GetMessageIdx(Byte[] msg, int fors_tree, int fors_height);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.Haraka256EngineProvider : object {
    private bool robust;
    private int n;
    private UInt32 w;
    private UInt32 d;
    private int a;
    private int k;
    private UInt32 h;
    public int N { get; }
    public Haraka256EngineProvider(bool robust, int n, UInt32 w, UInt32 d, int a, int k, UInt32 h);
    public sealed virtual int get_N();
    public sealed virtual SphincsPlusEngine Get();
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.HarakaS256Digest : HarakaSBase {
    public string AlgorithmName { get; }
    public HarakaS256Digest(HarakaSXof harakaSXof);
    public string get_AlgorithmName();
    public int GetDigestSize();
    public void Update(byte input);
    public void BlockUpdate(Byte[] input, int inOff, int len);
    public int DoFinal(Byte[] output, int outOff);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.HarakaS512Digest : HarakaSBase {
    public string AlgorithmName { get; }
    public HarakaS512Digest(HarakaSBase harakaSBase);
    public string get_AlgorithmName();
    public int GetDigestSize();
    public void Update(byte input);
    public void BlockUpdate(Byte[] input, int inOff, int len);
    public int DoFinal(Byte[] output, int outOff);
}
internal abstract class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.HarakaSBase : object {
    private static Byte[] RC0;
    private static Byte[] RC1;
    private static Byte[] RC2;
    private static Byte[] RC3;
    private static Byte[] RC4;
    private static Byte[] RC5;
    private static Byte[] RC6;
    private static Byte[] RC7;
    private static Byte[] RC8;
    private static Byte[] RC9;
    private static Byte[] RC10;
    private static Byte[] RC11;
    private static Byte[] RC12;
    private static Byte[] RC13;
    private static Byte[] RC14;
    private static Byte[] RC15;
    private static Byte[] RC16;
    private static Byte[] RC17;
    private static Byte[] RC18;
    private static Byte[] RC19;
    private static Byte[] RC20;
    private static Byte[] RC21;
    private static Byte[] RC22;
    private static Byte[] RC23;
    private static Byte[] RC24;
    private static Byte[] RC25;
    private static Byte[] RC26;
    private static Byte[] RC27;
    private static Byte[] RC28;
    private static Byte[] RC29;
    private static Byte[] RC30;
    private static Byte[] RC31;
    private static Byte[] RC32;
    private static Byte[] RC33;
    private static Byte[] RC34;
    private static Byte[] RC35;
    private static Byte[] RC36;
    private static Byte[] RC37;
    private static Byte[] RC38;
    private static Byte[] RC39;
    private static Byte[][] RoundConstants;
    internal UInt64[][] haraka512_rc;
    internal UInt32[][] haraka256_rc;
    protected Byte[] buffer;
    protected int off;
    private static HarakaSBase();
    protected void Reset();
    protected static void InterleaveConstant(UInt64[] output, Byte[] input, int startPos);
    protected static void InterleaveConstant32(UInt32[] output, Byte[] input, int startPos);
    internal void Haraka512Perm(Byte[] output);
    internal void Haraka256Perm(Byte[] output);
    private static void BrAesCt64InterleaveIn(UInt64[] q, int qPos, UInt32[] w, int startPos);
    private static void BrAesCtBitsliceSbox(UInt32[] q);
    private static void ShiftRows32(UInt32[] q);
    private static void MixColumns32(UInt32[] q);
    private static void AddRoundKey32(UInt32[] q, UInt32[] sk);
    private static void BrAesCt64Ortho(UInt64[] q);
    private static void BrAesCtOrtho(UInt32[] q);
    private static void BrAesCt64BitsliceSbox(UInt64[] q);
    private static void ShiftRows(UInt64[] q);
    private static void MixColumns(UInt64[] q);
    private static void AddRoundKey(UInt64[] q, UInt64[] sk);
    private static void BrAesCt64InterleaveOut(UInt32[] w, UInt64[] q, int pos);
    protected static void Xor(Byte[] x, int xOff, Byte[] y, int yOff, Byte[] z, int zOff, int zLen);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.HarakaSXof : HarakaSBase {
    public string AlgorithmName { get; }
    public HarakaSXof(Byte[] pkSeed);
    public string get_AlgorithmName();
    public void Update(byte input);
    public void BlockUpdate(Byte[] input, int inOff, int len);
    public int OutputFinal(Byte[] output, int outOff, int len);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.HT : object {
    private Byte[] skSeed;
    private Byte[] pkSeed;
    private SphincsPlusEngine engine;
    private WotsPlus wots;
    internal Byte[] HTPubKey;
    internal HT(SphincsPlusEngine engine, Byte[] skSeed, Byte[] pkSeed);
    internal Byte[] Sign(Byte[] M, ulong idx_tree, UInt32 idx_leaf);
    private Byte[] xmss_PKgen(Byte[] skSeed, Byte[] pkSeed, Adrs adrs);
    private Byte[] xmss_pkFromSig(UInt32 idx, SIG_XMSS sig_xmss, Byte[] M, Byte[] pkSeed, Adrs paramAdrs);
    private SIG_XMSS xmss_sign(Byte[] M, Byte[] skSeed, UInt32 idx, Byte[] pkSeed, Adrs paramAdrs);
    private Byte[] TreeHash(Byte[] skSeed, UInt32 s, UInt32 z, Byte[] pkSeed, Adrs adrsParam);
    internal bool Verify(Byte[] M, SIG_XMSS[] sig_ht, Byte[] pkSeed, ulong idx_tree, UInt32 idx_leaf, Byte[] PK_HT);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.IndexedDigest : object {
    internal ulong idx_tree;
    internal UInt32 idx_leaf;
    internal Byte[] digest;
    internal IndexedDigest(ulong idx_tree, UInt32 idx_leaf, Byte[] digest);
}
internal interface Org.BouncyCastle.Pqc.Crypto.SphincsPlus.ISphincsPlusEngineProvider {
    public int N { get; }
    public abstract virtual int get_N();
    public abstract virtual SphincsPlusEngine Get();
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.NodeEntry : object {
    internal Byte[] nodeValue;
    internal UInt32 nodeHeight;
    internal NodeEntry(Byte[] nodeValue, UInt32 nodeHeight);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.PK : object {
    internal Byte[] seed;
    internal Byte[] root;
    internal PK(Byte[] seed, Byte[] root);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.Sha2EngineProvider : object {
    private bool robust;
    private int n;
    private UInt32 w;
    private UInt32 d;
    private int a;
    private int k;
    private UInt32 h;
    public int N { get; }
    internal Sha2EngineProvider(bool robust, int n, UInt32 w, UInt32 d, int a, int k, UInt32 h);
    public sealed virtual int get_N();
    public sealed virtual SphincsPlusEngine Get();
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.Shake256EngineProvider : object {
    private bool robust;
    private int n;
    private UInt32 w;
    private UInt32 d;
    private int a;
    private int k;
    private UInt32 h;
    public int N { get; }
    internal Shake256EngineProvider(bool robust, int n, UInt32 w, UInt32 d, int a, int k, UInt32 h);
    public sealed virtual int get_N();
    public sealed virtual SphincsPlusEngine Get();
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SIG : object {
    private Byte[] r;
    private SIG_FORS[] sig_fors;
    private SIG_XMSS[] sig_ht;
    public Byte[] R { get; }
    public SIG_FORS[] SIG_FORS { get; }
    public SIG_XMSS[] SIG_HT { get; }
    public SIG(int n, int k, int a, UInt32 d, UInt32 hPrime, int wots_len, Byte[] signature);
    public Byte[] get_R();
    public SIG_FORS[] get_SIG_FORS();
    public SIG_XMSS[] get_SIG_HT();
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SIG_FORS : object {
    internal Byte[][] authPath;
    internal Byte[] sk;
    public Byte[] SK { get; }
    public Byte[][] AuthPath { get; }
    internal SIG_FORS(Byte[] sk, Byte[][] authPath);
    public Byte[] get_SK();
    public Byte[][] get_AuthPath();
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SIG_XMSS : object {
    internal Byte[] sig;
    internal Byte[][] auth;
    internal Byte[] WotsSig { get; }
    internal Byte[][] XmssAuth { get; }
    internal SIG_XMSS(Byte[] sig, Byte[][] auth);
    internal Byte[] get_WotsSig();
    internal Byte[][] get_XmssAuth();
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SK : object {
    internal Byte[] seed;
    internal Byte[] prf;
    internal SK(Byte[] seed, Byte[] prf);
}
internal abstract class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SphincsPlusEngine : object {
    internal bool robust;
    internal int N;
    internal UInt32 WOTS_W;
    internal int WOTS_LOGW;
    internal int WOTS_LEN;
    internal int WOTS_LEN1;
    internal int WOTS_LEN2;
    internal UInt32 D;
    internal int A;
    internal int K;
    internal UInt32 FH;
    internal UInt32 H_PRIME;
    internal UInt32 T;
    internal SphincsPlusEngine(bool robust, int n, UInt32 w, UInt32 d, int a, int k, UInt32 h);
    public abstract virtual void Init(Byte[] pkSeed);
    public abstract virtual Byte[] F(Byte[] pkSeed, Adrs adrs, Byte[] m1);
    public abstract virtual void H(Byte[] pkSeed, Adrs adrs, Byte[] m1, Byte[] m2, Byte[] output);
    public abstract virtual IndexedDigest H_msg(Byte[] prf, Byte[] pkSeed, Byte[] pkRoot, Byte[] message);
    public abstract virtual void T_l(Byte[] pkSeed, Adrs adrs, Byte[] m, Byte[] output);
    public abstract virtual void PRF(Byte[] pkSeed, Byte[] skSeed, Adrs adrs, Byte[] prf, int prfOff);
    public abstract virtual Byte[] PRF_msg(Byte[] prf, Byte[] randomiser, Byte[] message);
}
public class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SphincsPlusKeyGenerationParameters : KeyGenerationParameters {
    private SphincsPlusParameters m_parameters;
    public SphincsPlusParameters Parameters { get; }
    public SphincsPlusKeyGenerationParameters(SecureRandom random, SphincsPlusParameters parameters);
    public SphincsPlusParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SphincsPlusKeyPairGenerator : object {
    private SecureRandom random;
    private SphincsPlusParameters parameters;
    public sealed virtual void Init(KeyGenerationParameters param);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    private Byte[] SecRand(int n);
}
public abstract class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SphincsPlusKeyParameters : AsymmetricKeyParameter {
    private SphincsPlusParameters m_parameters;
    public SphincsPlusParameters Parameters { get; }
    internal SphincsPlusKeyParameters(bool isPrivate, SphincsPlusParameters parameters);
    public SphincsPlusParameters get_Parameters();
}
public class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SphincsPlusParameters : object {
    public static SphincsPlusParameters sha2_128f;
    public static SphincsPlusParameters sha2_128s;
    public static SphincsPlusParameters sha2_192f;
    public static SphincsPlusParameters sha2_192s;
    public static SphincsPlusParameters sha2_256f;
    public static SphincsPlusParameters sha2_256s;
    public static SphincsPlusParameters sha2_128f_simple;
    public static SphincsPlusParameters sha2_128s_simple;
    public static SphincsPlusParameters sha2_192f_simple;
    public static SphincsPlusParameters sha2_192s_simple;
    public static SphincsPlusParameters sha2_256f_simple;
    public static SphincsPlusParameters sha2_256s_simple;
    public static SphincsPlusParameters shake_128f;
    public static SphincsPlusParameters shake_128s;
    public static SphincsPlusParameters shake_192f;
    public static SphincsPlusParameters shake_192s;
    public static SphincsPlusParameters shake_256f;
    public static SphincsPlusParameters shake_256s;
    public static SphincsPlusParameters shake_128f_simple;
    public static SphincsPlusParameters shake_128s_simple;
    public static SphincsPlusParameters shake_192f_simple;
    public static SphincsPlusParameters shake_192s_simple;
    public static SphincsPlusParameters shake_256f_simple;
    public static SphincsPlusParameters shake_256s_simple;
    public static SphincsPlusParameters haraka_128f;
    public static SphincsPlusParameters haraka_128s;
    public static SphincsPlusParameters haraka_256f;
    public static SphincsPlusParameters haraka_256s;
    public static SphincsPlusParameters haraka_192f;
    public static SphincsPlusParameters haraka_192s;
    public static SphincsPlusParameters haraka_128f_simple;
    public static SphincsPlusParameters haraka_128s_simple;
    public static SphincsPlusParameters haraka_192f_simple;
    public static SphincsPlusParameters haraka_192s_simple;
    public static SphincsPlusParameters haraka_256f_simple;
    public static SphincsPlusParameters haraka_256s_simple;
    private static UInt32 sphincsPlus_sha2_128f_robust;
    private static UInt32 sphincsPlus_sha2_128s_robust;
    private static UInt32 sphincsPlus_sha2_192f_robust;
    private static UInt32 sphincsPlus_sha2_192s_robust;
    private static UInt32 sphincsPlus_sha2_256f_robust;
    private static UInt32 sphincsPlus_sha2_256s_robust;
    private static UInt32 sphincsPlus_sha2_128f_simple;
    private static UInt32 sphincsPlus_sha2_128s_simple;
    private static UInt32 sphincsPlus_sha2_192f_simple;
    private static UInt32 sphincsPlus_sha2_192s_simple;
    private static UInt32 sphincsPlus_sha2_256f_simple;
    private static UInt32 sphincsPlus_sha2_256s_simple;
    private static UInt32 sphincsPlus_shake_128f_robust;
    private static UInt32 sphincsPlus_shake_128s_robust;
    private static UInt32 sphincsPlus_shake_192f_robust;
    private static UInt32 sphincsPlus_shake_192s_robust;
    private static UInt32 sphincsPlus_shake_256f_robust;
    private static UInt32 sphincsPlus_shake_256s_robust;
    private static UInt32 sphincsPlus_shake_128f_simple;
    private static UInt32 sphincsPlus_shake_128s_simple;
    private static UInt32 sphincsPlus_shake_192f_simple;
    private static UInt32 sphincsPlus_shake_192s_simple;
    private static UInt32 sphincsPlus_shake_256f_simple;
    private static UInt32 sphincsPlus_shake_256s_simple;
    private static UInt32 sphincsPlus_haraka_128f_robust;
    private static UInt32 sphincsPlus_haraka_128s_robust;
    private static UInt32 sphincsPlus_haraka_192f_robust;
    private static UInt32 sphincsPlus_haraka_192s_robust;
    private static UInt32 sphincsPlus_haraka_256f_robust;
    private static UInt32 sphincsPlus_haraka_256s_robust;
    private static UInt32 sphincsPlus_haraka_128f_simple;
    private static UInt32 sphincsPlus_haraka_128s_simple;
    private static UInt32 sphincsPlus_haraka_192f_simple;
    private static UInt32 sphincsPlus_haraka_192s_simple;
    private static UInt32 sphincsPlus_haraka_256f_simple;
    private static UInt32 sphincsPlus_haraka_256s_simple;
    private static Dictionary`2<UInt32, SphincsPlusParameters> oidToParams;
    private static Dictionary`2<SphincsPlusParameters, UInt32> paramsToOid;
    private string m_name;
    private ISphincsPlusEngineProvider m_engineProvider;
    public string Name { get; }
    internal int N { get; }
    private static SphincsPlusParameters();
    private SphincsPlusParameters(string name, ISphincsPlusEngineProvider engineProvider);
    public string get_Name();
    internal int get_N();
    internal SphincsPlusEngine GetEngine();
    public static SphincsPlusParameters GetParams(int id);
    public static int GetID(SphincsPlusParameters parameters);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SphincsPlusPrivateKeyParameters : SphincsPlusKeyParameters {
    internal SK m_sk;
    internal PK m_pk;
    public SphincsPlusPrivateKeyParameters(SphincsPlusParameters parameters, Byte[] skpkEncoded);
    internal SphincsPlusPrivateKeyParameters(SphincsPlusParameters parameters, SK sk, PK pk);
    public Byte[] GetSeed();
    public Byte[] GetPrf();
    public Byte[] GetPublicSeed();
    public Byte[] GetPublicKey();
    public Byte[] GetEncoded();
    public Byte[] GetEncodedPublicKey();
}
public class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SphincsPlusPublicKeyParameters : SphincsPlusKeyParameters {
    private PK m_pk;
    public SphincsPlusPublicKeyParameters(SphincsPlusParameters parameters, Byte[] pkEncoded);
    internal SphincsPlusPublicKeyParameters(SphincsPlusParameters parameters, PK pk);
    public Byte[] GetSeed();
    public Byte[] GetRoot();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.SphincsPlusSigner : object {
    private SphincsPlusPrivateKeyParameters m_privKey;
    private SphincsPlusPublicKeyParameters m_pubKey;
    private SecureRandom m_random;
    public sealed virtual void Init(bool forSigning, ICipherParameters param);
    public sealed virtual Byte[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, Byte[] signature);
}
internal class Org.BouncyCastle.Pqc.Crypto.SphincsPlus.WotsPlus : object {
    private SphincsPlusEngine engine;
    private UInt32 w;
    internal WotsPlus(SphincsPlusEngine engine);
    internal void PKGen(Byte[] skSeed, Byte[] pkSeed, Adrs paramAdrs, Byte[] output);
    private Byte[] Chain(Byte[] X, UInt32 i, UInt32 s, Byte[] pkSeed, Adrs adrs);
    internal Byte[] Sign(Byte[] M, Byte[] skSeed, Byte[] pkSeed, Adrs paramAdrs);
    internal void BaseW(Byte[] X, int XOff, UInt32 w, UInt32[] output, int outOff, int outLen);
    internal void PKFromSig(Byte[] sig, Byte[] M, Byte[] pkSeed, Adrs adrs, Byte[] output);
}
public static class Org.BouncyCastle.Pqc.Crypto.Utilities.PqcPrivateKeyFactory : object {
    public static AsymmetricKeyParameter CreateKey(Byte[] privateKeyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(PrivateKeyInfo keyInfo);
}
public static class Org.BouncyCastle.Pqc.Crypto.Utilities.PqcPrivateKeyInfoFactory : object {
    public static PrivateKeyInfo CreatePrivateKeyInfo(AsymmetricKeyParameter privateKey);
    public static PrivateKeyInfo CreatePrivateKeyInfo(AsymmetricKeyParameter privateKey, Asn1Set attributes);
}
public static class Org.BouncyCastle.Pqc.Crypto.Utilities.PqcPublicKeyFactory : object {
    private static Dictionary`2<DerObjectIdentifier, SubjectPublicKeyInfoConverter> Converters;
    private static PqcPublicKeyFactory();
    public static AsymmetricKeyParameter CreateKey(Byte[] keyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(SubjectPublicKeyInfo keyInfo);
    public static AsymmetricKeyParameter CreateKey(SubjectPublicKeyInfo keyInfo, object defaultParams);
}
public static class Org.BouncyCastle.Pqc.Crypto.Utilities.PqcSubjectPublicKeyInfoFactory : object {
    public static SubjectPublicKeyInfo CreateSubjectPublicKeyInfo(AsymmetricKeyParameter publicKey);
}
internal class Org.BouncyCastle.Pqc.Crypto.Utilities.PqcUtilities : object {
    private static Dictionary`2<CmceParameters, DerObjectIdentifier> mcElieceOids;
    private static Dictionary`2<DerObjectIdentifier, CmceParameters> mcElieceParams;
    private static Dictionary`2<SaberParameters, DerObjectIdentifier> saberOids;
    private static Dictionary`2<DerObjectIdentifier, SaberParameters> saberParams;
    private static Dictionary`2<PicnicParameters, DerObjectIdentifier> picnicOids;
    private static Dictionary`2<DerObjectIdentifier, PicnicParameters> picnicParams;
    private static Dictionary`2<SikeParameters, DerObjectIdentifier> sikeOids;
    private static Dictionary`2<DerObjectIdentifier, SikeParameters> sikeParams;
    private static Dictionary`2<KyberParameters, DerObjectIdentifier> kyberOids;
    private static Dictionary`2<DerObjectIdentifier, KyberParameters> kyberParams;
    private static Dictionary`2<DilithiumParameters, DerObjectIdentifier> dilithiumOids;
    private static Dictionary`2<DerObjectIdentifier, DilithiumParameters> dilithiumParams;
    private static Dictionary`2<FalconParameters, DerObjectIdentifier> falconOids;
    private static Dictionary`2<DerObjectIdentifier, FalconParameters> falconParams;
    private static Dictionary`2<BikeParameters, DerObjectIdentifier> bikeOids;
    private static Dictionary`2<DerObjectIdentifier, BikeParameters> bikeParams;
    private static Dictionary`2<HqcParameters, DerObjectIdentifier> hqcOids;
    private static Dictionary`2<DerObjectIdentifier, HqcParameters> hqcParams;
    private static PqcUtilities();
    internal static DerObjectIdentifier McElieceOidLookup(CmceParameters parameters);
    internal static CmceParameters McElieceParamsLookup(DerObjectIdentifier oid);
    internal static DerObjectIdentifier SaberOidLookup(SaberParameters parameters);
    internal static SaberParameters SaberParamsLookup(DerObjectIdentifier oid);
    internal static KyberParameters KyberParamsLookup(DerObjectIdentifier oid);
    internal static DerObjectIdentifier KyberOidLookup(KyberParameters parameters);
    internal static FalconParameters FalconParamsLookup(DerObjectIdentifier oid);
    internal static DerObjectIdentifier FalconOidLookup(FalconParameters parameters);
    internal static DilithiumParameters DilithiumParamsLookup(DerObjectIdentifier oid);
    internal static DerObjectIdentifier DilithiumOidLookup(DilithiumParameters parameters);
    internal static DerObjectIdentifier SphincsPlusOidLookup(SphincsPlusParameters parameters);
    internal static DerObjectIdentifier PicnicOidLookup(PicnicParameters parameters);
    internal static PicnicParameters PicnicParamsLookup(DerObjectIdentifier oid);
    internal static DerObjectIdentifier SikeOidLookup(SikeParameters parameters);
    internal static SikeParameters SikeParamsLookup(DerObjectIdentifier oid);
    internal static DerObjectIdentifier BikeOidLookup(BikeParameters parameters);
    internal static BikeParameters BikeParamsLookup(DerObjectIdentifier oid);
    internal static DerObjectIdentifier HqcOidLookup(HqcParameters parameters);
    internal static HqcParameters HqcParamsLookup(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Pqc.Crypto.Utilities.SecretWithEncapsulationImpl : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasBeenDestroyed;
    private Byte[] sessionKey;
    private Byte[] cipher_text;
    public SecretWithEncapsulationImpl(Byte[] sessionKey, Byte[] cipher_text);
    public sealed virtual Byte[] GetSecret();
    public sealed virtual Byte[] GetEncapsulation();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public bool IsDestroyed();
    private void CheckDestroyed();
}
public static class Org.BouncyCastle.Security.AgreementUtilities : object {
    private static IDictionary`2<string, string> Algorithms;
    private static AgreementUtilities();
    public static IBasicAgreement GetBasicAgreement(DerObjectIdentifier oid);
    public static IBasicAgreement GetBasicAgreement(string algorithm);
    public static IBasicAgreement GetBasicAgreementWithKdf(DerObjectIdentifier oid, string wrapAlgorithm);
    public static IBasicAgreement GetBasicAgreementWithKdf(string agreeAlgorithm, string wrapAlgorithm);
    public static IRawAgreement GetRawAgreement(DerObjectIdentifier oid);
    public static IRawAgreement GetRawAgreement(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    private static string GetMechanism(string algorithm);
}
public class Org.BouncyCastle.Security.Certificates.CertificateEncodingException : CertificateException {
    public CertificateEncodingException(string message);
    public CertificateEncodingException(string message, Exception innerException);
    protected CertificateEncodingException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Security.Certificates.CertificateException : GeneralSecurityException {
    public CertificateException(string message);
    public CertificateException(string message, Exception innerException);
    protected CertificateException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Security.Certificates.CertificateExpiredException : CertificateException {
    public CertificateExpiredException(string message);
    public CertificateExpiredException(string message, Exception innerException);
    protected CertificateExpiredException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException : CertificateException {
    public CertificateNotYetValidException(string message);
    public CertificateNotYetValidException(string message, Exception innerException);
    protected CertificateNotYetValidException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Security.Certificates.CertificateParsingException : CertificateException {
    public CertificateParsingException(string message);
    public CertificateParsingException(string message, Exception innerException);
    protected CertificateParsingException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Security.Certificates.CrlException : GeneralSecurityException {
    public CrlException(string message);
    public CrlException(string message, Exception innerException);
    protected CrlException(SerializationInfo info, StreamingContext context);
}
public static class Org.BouncyCastle.Security.CipherUtilities : object {
    private static Dictionary`2<string, string> Algorithms;
    private static CipherUtilities();
    public static IBufferedCipher GetCipher(DerObjectIdentifier oid);
    public static IBufferedCipher GetCipher(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    private static int GetDigitIndex(string s);
    private static IBlockCipher CreateBlockCipher(CipherAlgorithm cipherAlgorithm);
}
public static class Org.BouncyCastle.Security.DigestUtilities : object {
    private static IDictionary`2<string, string> Aliases;
    private static IDictionary`2<string, DerObjectIdentifier> Oids;
    private static DigestUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static IDigest GetDigest(DerObjectIdentifier id);
    public static IDigest GetDigest(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    public static Byte[] CalculateDigest(DerObjectIdentifier id, Byte[] input);
    public static Byte[] CalculateDigest(string algorithm, Byte[] input);
    public static Byte[] CalculateDigest(string algorithm, Byte[] buf, int off, int len);
    public static Byte[] DoFinal(IDigest digest);
    public static Byte[] DoFinal(IDigest digest, Byte[] input);
    public static Byte[] DoFinal(IDigest digest, Byte[] buf, int off, int len);
}
public static class Org.BouncyCastle.Security.DotNetUtilities : object {
    public static X509Certificate ToX509Certificate(X509CertificateStructure x509Struct);
    public static X509Certificate ToX509Certificate(X509Certificate x509Cert);
    public static X509Certificate FromX509Certificate(X509Certificate x509Cert);
    public static AsymmetricCipherKeyPair GetDsaKeyPair(DSA dsa);
    public static AsymmetricCipherKeyPair GetDsaKeyPair(DSAParameters dp);
    public static DsaPublicKeyParameters GetDsaPublicKey(DSA dsa);
    public static DsaPublicKeyParameters GetDsaPublicKey(DSAParameters dp);
    public static AsymmetricCipherKeyPair GetRsaKeyPair(RSA rsa);
    public static AsymmetricCipherKeyPair GetRsaKeyPair(RSAParameters rp);
    public static RsaKeyParameters GetRsaPublicKey(RSA rsa);
    public static RsaKeyParameters GetRsaPublicKey(RSAParameters rp);
    public static AsymmetricCipherKeyPair GetKeyPair(AsymmetricAlgorithm privateKey);
    public static RSA ToRSA(RsaKeyParameters rsaKey);
    public static RSA ToRSA(RsaKeyParameters rsaKey, CspParameters csp);
    public static RSA ToRSA(RsaPrivateCrtKeyParameters privKey);
    public static RSA ToRSA(RsaPrivateCrtKeyParameters privKey, CspParameters csp);
    public static RSA ToRSA(RsaPrivateKeyStructure privKey);
    public static RSA ToRSA(RsaPrivateKeyStructure privKey, CspParameters csp);
    public static RSAParameters ToRSAParameters(RsaKeyParameters rsaKey);
    public static RSAParameters ToRSAParameters(RsaPrivateCrtKeyParameters privKey);
    public static RSAParameters ToRSAParameters(RsaPrivateKeyStructure privKey);
    private static Byte[] ConvertRSAParametersField(BigInteger n, int size);
    private static RSACryptoServiceProvider CreateRSAProvider(RSAParameters rp);
    private static RSACryptoServiceProvider CreateRSAProvider(RSAParameters rp, CspParameters csp);
}
public class Org.BouncyCastle.Security.EncryptionException : IOException {
    public EncryptionException(string message);
    public EncryptionException(string message, Exception innerException);
    protected EncryptionException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Security.GeneralSecurityException : Exception {
    public GeneralSecurityException(string message);
    public GeneralSecurityException(string message, Exception innerException);
    protected GeneralSecurityException(SerializationInfo info, StreamingContext context);
}
public static class Org.BouncyCastle.Security.GeneratorUtilities : object {
    private static IDictionary`2<string, string> KgAlgorithms;
    private static IDictionary`2<string, string> KpgAlgorithms;
    private static IDictionary`2<string, int> DefaultKeySizes;
    private static GeneratorUtilities();
    private static void AddDefaultKeySizeEntries(int size, String[] algorithms);
    private static void AddKgAlgorithm(string canonicalName, Object[] aliases);
    private static void AddKpgAlgorithm(string canonicalName, Object[] aliases);
    private static void AddHMacKeyGenerator(string algorithm, Object[] aliases);
    internal static string GetCanonicalKeyGeneratorAlgorithm(string algorithm);
    internal static string GetCanonicalKeyPairGeneratorAlgorithm(string algorithm);
    public static CipherKeyGenerator GetKeyGenerator(DerObjectIdentifier oid);
    public static CipherKeyGenerator GetKeyGenerator(string algorithm);
    public static IAsymmetricCipherKeyPairGenerator GetKeyPairGenerator(DerObjectIdentifier oid);
    public static IAsymmetricCipherKeyPairGenerator GetKeyPairGenerator(string algorithm);
    internal static int GetDefaultKeySize(DerObjectIdentifier oid);
    internal static int GetDefaultKeySize(string algorithm);
    private static int FindDefaultKeySize(string canonicalName);
}
public class Org.BouncyCastle.Security.InvalidKeyException : KeyException {
    public InvalidKeyException(string message);
    public InvalidKeyException(string message, Exception innerException);
    protected InvalidKeyException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Security.InvalidParameterException : KeyException {
    public InvalidParameterException(string message);
    public InvalidParameterException(string message, Exception innerException);
    protected InvalidParameterException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Security.JksStore : object {
    private static int Magic;
    private static AlgorithmIdentifier JksObfuscationAlg;
    private Dictionary`2<string, JksTrustedCertEntry> m_certificateEntries;
    private Dictionary`2<string, JksKeyEntry> m_keyEntries;
    public IEnumerable`1<string> Aliases { get; }
    public int Count { get; }
    private static JksStore();
    public bool Probe(Stream stream);
    public AsymmetricKeyParameter GetKey(string alias, Char[] password);
    private Byte[] GetKeyChecksum(IDigest digest, Char[] password, Byte[] pkcs8Key);
    private Byte[] CalculateKeyStream(IDigest digest, Char[] password, Byte[] salt, int count);
    public X509Certificate[] GetCertificateChain(string alias);
    public X509Certificate GetCertificate(string alias);
    public Nullable`1<DateTime> GetCreationDate(string alias);
    public void SetKeyEntry(string alias, AsymmetricKeyParameter key, Char[] password, X509Certificate[] chain);
    public void SetKeyEntry(string alias, Byte[] key, X509Certificate[] chain);
    public void SetCertificateEntry(string alias, X509Certificate cert);
    public void DeleteEntry(string alias);
    public IEnumerable`1<string> get_Aliases();
    public bool ContainsAlias(string alias);
    public int get_Count();
    public bool IsKeyEntry(string alias);
    public bool IsCertificateEntry(string alias);
    public string GetCertificateAlias(X509Certificate cert);
    public void Save(Stream stream, Char[] password);
    private void SaveStream(Stream stream, IDigest checksumDigest);
    public void Load(Stream stream, Char[] password);
    public void LoadUnchecked(Stream stream);
    private void LoadStream(ErasableByteStream storeStream);
    private ErasableByteStream ValidateStream(Stream inputStream, Char[] password);
    private static void AddPassword(IDigest digest, Char[] password);
    private static Byte[] CalculateChecksum(Char[] password, Byte[] buffer, int offset, int length);
    private static X509Certificate[] CloneChain(X509Certificate[] chain);
    private static string ConvertAlias(string alias);
    private static IDigest CreateChecksumDigest(Char[] password);
    private static Byte[] ReadBufferWithInt16Length(BinaryReader br);
    private static Byte[] ReadBufferWithInt32Length(BinaryReader br);
    private static DateTime ReadDateTime(BinaryReader br);
    private static X509Certificate ReadTypedCertificate(BinaryReader br, int storeVersion);
    private static string ReadUtf(BinaryReader br);
    private static void WriteBufferWithInt16Length(BinaryWriter bw, Byte[] buffer);
    private static void WriteBufferWithInt32Length(BinaryWriter bw, Byte[] buffer);
    private static void WriteDateTime(BinaryWriter bw, DateTime dateTime);
    private static void WriteTypedCertificate(BinaryWriter bw, X509Certificate cert);
    private static void WriteUtf(BinaryWriter bw, string s);
}
public class Org.BouncyCastle.Security.KeyException : GeneralSecurityException {
    public KeyException(string message);
    public KeyException(string message, Exception innerException);
    protected KeyException(SerializationInfo info, StreamingContext context);
}
public static class Org.BouncyCastle.Security.MacUtilities : object {
    private static IDictionary`2<string, string> Algorithms;
    private static MacUtilities();
    public static IMac GetMac(DerObjectIdentifier id);
    public static IMac GetMac(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    public static Byte[] CalculateMac(string algorithm, ICipherParameters cp, Byte[] input);
    public static Byte[] DoFinal(IMac mac);
    public static Byte[] DoFinal(IMac mac, Byte[] input);
}
public static class Org.BouncyCastle.Security.ParameterUtilities : object {
    private static IDictionary`2<string, string> Algorithms;
    private static IDictionary`2<string, int> BasicIVSizes;
    private static ParameterUtilities();
    private static void AddAlgorithm(string canonicalName, Object[] aliases);
    private static void AddBasicIVSizeEntries(int size, String[] algorithms);
    public static string GetCanonicalAlgorithmName(string algorithm);
    public static KeyParameter CreateKeyParameter(DerObjectIdentifier algOid, Byte[] keyBytes);
    public static KeyParameter CreateKeyParameter(string algorithm, Byte[] keyBytes);
    public static KeyParameter CreateKeyParameter(DerObjectIdentifier algOid, Byte[] keyBytes, int offset, int length);
    public static KeyParameter CreateKeyParameter(string algorithm, Byte[] keyBytes, int offset, int length);
    public static ICipherParameters GetCipherParameters(DerObjectIdentifier algOid, ICipherParameters key, Asn1Object asn1Params);
    public static ICipherParameters GetCipherParameters(string algorithm, ICipherParameters key, Asn1Object asn1Params);
    public static Asn1Encodable GenerateParameters(DerObjectIdentifier algID, SecureRandom random);
    public static Asn1Encodable GenerateParameters(string algorithm, SecureRandom random);
    public static ICipherParameters WithRandom(ICipherParameters cp, SecureRandom random);
    private static Asn1OctetString CreateIVOctetString(SecureRandom random, int ivLength);
    private static Byte[] CreateIV(SecureRandom random, int ivLength);
    private static int FindBasicIVSize(string canonicalName);
}
public class Org.BouncyCastle.Security.PasswordException : IOException {
    public PasswordException(string message);
    public PasswordException(string message, Exception innerException);
    protected PasswordException(SerializationInfo info, StreamingContext context);
}
public static class Org.BouncyCastle.Security.PbeUtilities : object {
    private static string Pkcs5S1;
    private static string Pkcs5S2;
    private static string Pkcs12;
    private static string OpenSsl;
    private static IDictionary`2<string, string> Algorithms;
    private static IDictionary`2<string, string> AlgorithmType;
    private static IDictionary`2<string, DerObjectIdentifier> Oids;
    private static PbeUtilities();
    private static PbeParametersGenerator MakePbeGenerator(string type, IDigest digest, Byte[] key, Byte[] salt, int iterationCount);
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static bool IsPkcs12(string algorithm);
    public static bool IsPkcs5Scheme1(string algorithm);
    public static bool IsPkcs5Scheme2(string algorithm);
    public static bool IsOpenSsl(string algorithm);
    public static bool IsPbeAlgorithm(string algorithm);
    public static Asn1Encodable GenerateAlgorithmParameters(DerObjectIdentifier algorithmOid, Byte[] salt, int iterationCount);
    public static Asn1Encodable GenerateAlgorithmParameters(string algorithm, Byte[] salt, int iterationCount);
    public static Asn1Encodable GenerateAlgorithmParameters(DerObjectIdentifier cipherAlgorithm, DerObjectIdentifier hashAlgorithm, Byte[] salt, int iterationCount, SecureRandom secureRandom);
    public static ICipherParameters GenerateCipherParameters(DerObjectIdentifier algorithmOid, Char[] password, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(DerObjectIdentifier algorithmOid, Char[] password, bool wrongPkcs12Zero, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(AlgorithmIdentifier algID, Char[] password);
    public static ICipherParameters GenerateCipherParameters(AlgorithmIdentifier algID, Char[] password, bool wrongPkcs12Zero);
    public static ICipherParameters GenerateCipherParameters(string algorithm, Char[] password, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(string algorithm, Char[] password, bool wrongPkcs12Zero, Asn1Encodable pbeParameters);
    public static object CreateEngine(DerObjectIdentifier algorithmOid);
    public static object CreateEngine(AlgorithmIdentifier algID);
    public static object CreateEngine(string algorithm);
    public static string GetEncodingName(DerObjectIdentifier oid);
    private static ICipherParameters FixDesParity(string mechanism, ICipherParameters parameters);
}
public static class Org.BouncyCastle.Security.PrivateKeyFactory : object {
    public static AsymmetricKeyParameter CreateKey(Byte[] privateKeyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(PrivateKeyInfo keyInfo);
    private static Byte[] GetRawKey(PrivateKeyInfo keyInfo);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, EncryptedPrivateKeyInfo encInfo);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Byte[] encryptedPrivateKeyInfoData);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Stream encryptedPrivateKeyInfoStream);
    private static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Asn1Object asn1Object);
    public static Byte[] EncryptKey(DerObjectIdentifier algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static Byte[] EncryptKey(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
}
public static class Org.BouncyCastle.Security.PublicKeyFactory : object {
    public static AsymmetricKeyParameter CreateKey(Byte[] keyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(SubjectPublicKeyInfo keyInfo);
    private static Byte[] GetRawKey(SubjectPublicKeyInfo keyInfo);
    private static bool IsPkcsDHParam(Asn1Sequence seq);
    private static DHPublicKeyParameters ReadPkcsDHParam(DerObjectIdentifier algOid, BigInteger y, Asn1Sequence seq);
}
public class Org.BouncyCastle.Security.SecureRandom : Random {
    private static long counter;
    private static SecureRandom MasterRandom;
    internal static SecureRandom ArbitraryRandom;
    protected IRandomGenerator generator;
    private static double DoubleScale;
    public SecureRandom(IRandomGenerator generator);
    public SecureRandom(IRandomGenerator generator, int autoSeedLengthInBytes);
    private static SecureRandom();
    private static long NextCounterValue();
    private static DigestRandomGenerator CreatePrng(string digestName, bool autoSeed);
    public static Byte[] GetNextBytes(SecureRandom secureRandom, int length);
    public static SecureRandom GetInstance(string algorithm);
    public static SecureRandom GetInstance(string algorithm, bool autoSeed);
    public virtual Byte[] GenerateSeed(int length);
    public virtual void SetSeed(Byte[] seed);
    public virtual void SetSeed(long seed);
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buf);
    public virtual void NextBytes(Byte[] buf, int off, int len);
    public virtual double NextDouble();
    public virtual int NextInt();
    public virtual long NextLong();
    private static void AutoSeed(IRandomGenerator generator, int seedLength);
}
public class Org.BouncyCastle.Security.SecurityUtilityException : Exception {
    public SecurityUtilityException(string message);
    public SecurityUtilityException(string message, Exception innerException);
    protected SecurityUtilityException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Security.SignatureException : GeneralSecurityException {
    public SignatureException(string message);
    public SignatureException(string message, Exception innerException);
    protected SignatureException(SerializationInfo info, StreamingContext context);
}
public static class Org.BouncyCastle.Security.SignerUtilities : object {
    private static IDictionary`2<string, string> AlgorithmMap;
    private static HashSet`1<string> NoRandom;
    private static IDictionary`2<string, DerObjectIdentifier> Oids;
    public static ICollection`1<string> Algorithms { get; }
    private static SignerUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection`1<string> get_Algorithms();
    public static Asn1Encodable GetDefaultX509Parameters(DerObjectIdentifier id);
    public static Asn1Encodable GetDefaultX509Parameters(string algorithm);
    private static string GetMechanism(string algorithm);
    private static Asn1Encodable GetPssX509Parameters(string digestName);
    public static ISigner GetSigner(DerObjectIdentifier id);
    public static ISigner GetSigner(string algorithm);
    private static ISigner GetSignerForMechanism(string mechanism);
    public static string GetEncodingName(DerObjectIdentifier oid);
    public static ISigner InitSigner(DerObjectIdentifier algorithmOid, bool forSigning, AsymmetricKeyParameter privateKey, SecureRandom random);
    public static ISigner InitSigner(string algorithm, bool forSigning, AsymmetricKeyParameter privateKey, SecureRandom random);
}
public static class Org.BouncyCastle.Security.WrapperUtilities : object {
    private static IDictionary`2<string, string> Algorithms;
    private static WrapperUtilities();
    public static IWrapper GetWrapper(DerObjectIdentifier oid);
    public static IWrapper GetWrapper(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsClient : AbstractTlsPeer {
    protected TlsClientContext m_context;
    protected ProtocolVersion[] m_protocolVersions;
    protected Int32[] m_cipherSuites;
    protected IList`1<int> m_supportedGroups;
    protected IList`1<SignatureAndHashAlgorithm> m_supportedSignatureAlgorithms;
    protected IList`1<SignatureAndHashAlgorithm> m_supportedSignatureAlgorithmsCert;
    protected AbstractTlsClient(TlsCrypto crypto);
    protected virtual bool AllowUnexpectedServerExtension(int extensionType, Byte[] extensionData);
    protected virtual IList`1<int> GetNamedGroupRoles();
    protected virtual void CheckForUnexpectedServerExtension(IDictionary`2<int, Byte[]> serverExtensions, int extensionType);
    protected virtual Byte[] GetNewConnectionID();
    public virtual TlsPskIdentity GetPskIdentity();
    public virtual TlsSrpIdentity GetSrpIdentity();
    public virtual TlsDHGroupVerifier GetDHGroupVerifier();
    public virtual TlsSrpConfigVerifier GetSrpConfigVerifier();
    protected virtual IList`1<X509Name> GetCertificateAuthorities();
    protected virtual IList`1<ProtocolName> GetProtocolNames();
    protected virtual CertificateStatusRequest GetCertificateStatusRequest();
    protected virtual IList`1<CertificateStatusRequestItemV2> GetMultiCertStatusRequest();
    protected virtual IList`1<ServerName> GetSniServerNames();
    protected virtual IList`1<int> GetSupportedGroups(IList`1<int> namedGroupRoles);
    protected virtual IList`1<SignatureAndHashAlgorithm> GetSupportedSignatureAlgorithms();
    protected virtual IList`1<SignatureAndHashAlgorithm> GetSupportedSignatureAlgorithmsCert();
    protected virtual IList`1<TrustedAuthority> GetTrustedCAIndication();
    protected virtual Int16[] GetAllowedClientCertificateTypes();
    protected virtual Int16[] GetAllowedServerCertificateTypes();
    public virtual void Init(TlsClientContext context);
    public virtual ProtocolVersion[] GetProtocolVersions();
    public virtual Int32[] GetCipherSuites();
    public virtual void NotifyHandshakeBeginning();
    public virtual TlsSession GetSessionToResume();
    public virtual IList`1<TlsPskExternal> GetExternalPsks();
    public virtual bool IsFallback();
    public virtual IDictionary`2<int, Byte[]> GetClientExtensions();
    public virtual IList`1<int> GetEarlyKeyShareGroups();
    public virtual void NotifyServerVersion(ProtocolVersion serverVersion);
    public virtual void NotifySessionToResume(TlsSession session);
    public virtual void NotifySessionID(Byte[] sessionID);
    public virtual void NotifySelectedCipherSuite(int selectedCipherSuite);
    public virtual void NotifySelectedPsk(TlsPsk selectedPsk);
    public virtual void ProcessServerExtensions(IDictionary`2<int, Byte[]> serverExtensions);
    public virtual void ProcessServerSupplementalData(IList`1<SupplementalDataEntry> serverSupplementalData);
    public abstract virtual TlsAuthentication GetAuthentication();
    public virtual IList`1<SupplementalDataEntry> GetClientSupplementalData();
    public virtual void NotifyNewSessionTicket(NewSessionTicket newSessionTicket);
}
internal abstract class Org.BouncyCastle.Tls.AbstractTlsContext : object {
    private static long counter;
    private TlsCrypto m_crypto;
    private int m_connectionEnd;
    private TlsNonceGenerator m_nonceGenerator;
    private SecurityParameters m_securityParameters;
    private ProtocolVersion[] m_clientSupportedVersions;
    private ProtocolVersion m_clientVersion;
    private ProtocolVersion m_rsaPreMasterSecretVersion;
    private TlsSession m_session;
    private object m_userObject;
    private bool m_connected;
    internal bool IsConnected { get; }
    internal bool IsHandshaking { get; }
    public TlsCrypto Crypto { get; }
    public TlsNonceGenerator NonceGenerator { get; }
    public SecurityParameters SecurityParameters { get; }
    public bool IsServer { get; }
    public ProtocolVersion[] ClientSupportedVersions { get; }
    public ProtocolVersion ClientVersion { get; }
    public ProtocolVersion RsaPreMasterSecretVersion { get; }
    public ProtocolVersion ServerVersion { get; }
    public TlsSession ResumableSession { get; }
    public TlsSession Session { get; }
    public object UserObject { get; public set; }
    internal AbstractTlsContext(TlsCrypto crypto, int connectionEnd);
    private static AbstractTlsContext();
    private static long NextCounterValue();
    private static TlsNonceGenerator CreateNonceGenerator(TlsCrypto crypto, int connectionEnd);
    internal void HandshakeBeginning(TlsPeer peer);
    internal void HandshakeComplete(TlsPeer peer, TlsSession session);
    internal bool get_IsConnected();
    internal bool get_IsHandshaking();
    public sealed virtual TlsCrypto get_Crypto();
    public virtual TlsNonceGenerator get_NonceGenerator();
    public sealed virtual SecurityParameters get_SecurityParameters();
    public abstract virtual bool get_IsServer();
    public virtual ProtocolVersion[] get_ClientSupportedVersions();
    internal void SetClientSupportedVersions(ProtocolVersion[] clientSupportedVersions);
    public virtual ProtocolVersion get_ClientVersion();
    internal void SetClientVersion(ProtocolVersion clientVersion);
    public virtual ProtocolVersion get_RsaPreMasterSecretVersion();
    internal void SetRsaPreMasterSecretVersion(ProtocolVersion rsaPreMasterSecretVersion);
    public virtual ProtocolVersion get_ServerVersion();
    public virtual TlsSession get_ResumableSession();
    public virtual TlsSession get_Session();
    public virtual object get_UserObject();
    public virtual void set_UserObject(object value);
    public virtual Byte[] ExportChannelBinding(int channelBinding);
    public virtual Byte[] ExportEarlyKeyingMaterial(string asciiLabel, Byte[] context, int length);
    public virtual Byte[] ExportKeyingMaterial(string asciiLabel, Byte[] context, int length);
    protected virtual Byte[] ExportKeyingMaterial13(TlsSecret secret, int cryptoHashAlgorithm, string asciiLabel, Byte[] context, int length);
    protected virtual TlsSecret CheckEarlyExportSecret(TlsSecret secret);
    protected virtual TlsSecret CheckExportSecret(TlsSecret secret);
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsKeyExchange : object {
    protected int m_keyExchange;
    protected TlsContext m_context;
    public bool RequiresServerKeyExchange { get; }
    public bool RequiresCertificateVerify { get; }
    protected AbstractTlsKeyExchange(int keyExchange);
    public virtual void Init(TlsContext context);
    public abstract virtual void SkipServerCredentials();
    public abstract virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void SkipClientCredentials();
    public abstract virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public abstract virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual bool get_RequiresCertificateVerify();
    public abstract virtual TlsSecret GeneratePreMasterSecret();
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsKeyExchangeFactory : object {
    public virtual TlsKeyExchange CreateDHKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateDHanonKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreateDHanonKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public virtual TlsKeyExchange CreateDheKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreateDheKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public virtual TlsKeyExchange CreateECDHKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateECDHanonKeyExchangeClient(int keyExchange);
    public virtual TlsKeyExchange CreateECDHanonKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreateECDheKeyExchangeClient(int keyExchange);
    public virtual TlsKeyExchange CreateECDheKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreatePskKeyExchangeClient(int keyExchange, TlsPskIdentity pskIdentity, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreatePskKeyExchangeServer(int keyExchange, TlsPskIdentityManager pskIdentityManager, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreateRsaKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateSrpKeyExchangeClient(int keyExchange, TlsSrpIdentity srpIdentity, TlsSrpConfigVerifier srpConfigVerifier);
    public virtual TlsKeyExchange CreateSrpKeyExchangeServer(int keyExchange, TlsSrpLoginParameters loginParameters);
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsPeer : object {
    private TlsCrypto m_crypto;
    private TlsCloseable modreq(System.Runtime.CompilerServices.IsVolatile) m_closeHandle;
    public TlsCrypto Crypto { get; }
    public bool IgnoreCorruptDtlsRecords { get; }
    protected AbstractTlsPeer(TlsCrypto crypto);
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected abstract virtual Int32[] GetSupportedCipherSuites();
    public virtual void Cancel();
    public virtual TlsCrypto get_Crypto();
    public virtual void NotifyCloseHandle(TlsCloseable closeHandle);
    public abstract virtual ProtocolVersion[] GetProtocolVersions();
    public abstract virtual Int32[] GetCipherSuites();
    public virtual void NotifyHandshakeBeginning();
    public virtual int GetHandshakeTimeoutMillis();
    public virtual int GetHandshakeResendTimeMillis();
    public virtual bool AllowLegacyResumption();
    public virtual int GetMaxCertificateChainLength();
    public virtual int GetMaxHandshakeMessageSize();
    public virtual Int16[] GetPskKeyExchangeModes();
    public virtual bool RequiresCloseNotify();
    public virtual bool RequiresExtendedMasterSecret();
    public virtual bool ShouldCheckSigAlgOfPeerCerts();
    public virtual bool ShouldUseExtendedMasterSecret();
    public virtual bool ShouldUseExtendedPadding();
    public virtual bool ShouldUseGmtUnixTime();
    public virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public virtual TlsKeyExchangeFactory GetKeyExchangeFactory();
    public virtual void NotifyAlertRaised(short alertLevel, short alertDescription, string message, Exception cause);
    public virtual void NotifyAlertReceived(short alertLevel, short alertDescription);
    public virtual void NotifyHandshakeComplete();
    public virtual TlsHeartbeat GetHeartbeat();
    public virtual short GetHeartbeatPolicy();
    public virtual bool get_IgnoreCorruptDtlsRecords();
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsServer : AbstractTlsPeer {
    protected TlsServerContext m_context;
    protected ProtocolVersion[] m_protocolVersions;
    protected Int32[] m_cipherSuites;
    protected Int32[] m_offeredCipherSuites;
    protected IDictionary`2<int, Byte[]> m_clientExtensions;
    protected bool m_encryptThenMACOffered;
    protected short m_maxFragmentLengthOffered;
    protected bool m_truncatedHMacOffered;
    protected bool m_clientSentECPointFormats;
    protected CertificateStatusRequest m_certificateStatusRequest;
    protected IList`1<CertificateStatusRequestItemV2> m_statusRequestV2;
    protected IList`1<TrustedAuthority> m_trustedCAKeys;
    protected int m_selectedCipherSuite;
    protected IList`1<ProtocolName> m_clientProtocolNames;
    protected ProtocolName m_selectedProtocolName;
    protected IDictionary`2<int, Byte[]> m_serverExtensions;
    public AbstractTlsServer(TlsCrypto crypto);
    protected virtual bool AllowCertificateStatus();
    protected virtual bool AllowEncryptThenMac();
    protected virtual bool AllowMultiCertStatus();
    protected virtual bool AllowTruncatedHmac();
    protected virtual bool AllowTrustedCAIndication();
    protected virtual int GetMaximumNegotiableCurveBits();
    protected virtual int GetMaximumNegotiableFiniteFieldBits();
    protected virtual IList`1<ProtocolName> GetProtocolNames();
    protected virtual bool IsSelectableCipherSuite(int cipherSuite, int availCurveBits, int availFiniteFieldBits, IList`1<short> sigAlgs);
    protected virtual bool PreferLocalCipherSuites();
    protected virtual bool SelectCipherSuite(int cipherSuite);
    protected virtual int SelectDH(int minimumFiniteFieldBits);
    protected virtual int SelectDHDefault(int minimumFiniteFieldBits);
    protected virtual int SelectECDH(int minimumCurveBits);
    protected virtual int SelectECDHDefault(int minimumCurveBits);
    protected virtual ProtocolName SelectProtocolName();
    protected virtual ProtocolName SelectProtocolName(IList`1<ProtocolName> clientProtocolNames, IList`1<ProtocolName> serverProtocolNames);
    protected virtual bool ShouldSelectProtocolNameEarly();
    protected virtual bool PreferLocalClientCertificateTypes();
    protected virtual Int16[] GetAllowedClientCertificateTypes();
    protected virtual Byte[] GetNewConnectionID();
    public virtual void Init(TlsServerContext context);
    public virtual ProtocolVersion[] GetProtocolVersions();
    public virtual Int32[] GetCipherSuites();
    public virtual void NotifyHandshakeBeginning();
    public virtual TlsSession GetSessionToResume(Byte[] sessionID);
    public virtual Byte[] GetNewSessionID();
    public virtual TlsPskExternal GetExternalPsk(IList`1<PskIdentity> identities);
    public virtual void NotifySession(TlsSession session);
    public virtual void NotifyClientVersion(ProtocolVersion clientVersion);
    public virtual void NotifyFallback(bool isFallback);
    public virtual void NotifyOfferedCipherSuites(Int32[] offeredCipherSuites);
    public virtual void ProcessClientExtensions(IDictionary`2<int, Byte[]> clientExtensions);
    public virtual ProtocolVersion GetServerVersion();
    public virtual Int32[] GetSupportedGroups();
    public virtual int GetSelectedCipherSuite();
    public virtual IDictionary`2<int, Byte[]> GetServerExtensions();
    public virtual void GetServerExtensionsForConnection(IDictionary`2<int, Byte[]> serverExtensions);
    public virtual IList`1<SupplementalDataEntry> GetServerSupplementalData();
    public abstract virtual TlsCredentials GetCredentials();
    public virtual CertificateStatus GetCertificateStatus();
    public virtual CertificateRequest GetCertificateRequest();
    public virtual TlsPskIdentityManager GetPskIdentityManager();
    public virtual TlsSrpLoginParameters GetSrpLoginParameters();
    public virtual TlsDHConfig GetDHConfig();
    public virtual TlsECConfig GetECDHConfig();
    public virtual void ProcessClientSupplementalData(IList`1<SupplementalDataEntry> clientSupplementalData);
    public virtual void NotifyClientCertificate(Certificate clientCertificate);
    public virtual NewSessionTicket GetNewSessionTicket();
}
public abstract class Org.BouncyCastle.Tls.AlertDescription : object {
    public static short close_notify;
    public static short unexpected_message;
    public static short bad_record_mac;
    public static short decryption_failed;
    public static short record_overflow;
    public static short decompression_failure;
    public static short handshake_failure;
    public static short no_certificate;
    public static short bad_certificate;
    public static short unsupported_certificate;
    public static short certificate_revoked;
    public static short certificate_expired;
    public static short certificate_unknown;
    public static short illegal_parameter;
    public static short unknown_ca;
    public static short access_denied;
    public static short decode_error;
    public static short decrypt_error;
    public static short export_restriction;
    public static short protocol_version;
    public static short insufficient_security;
    public static short internal_error;
    public static short user_canceled;
    public static short no_renegotiation;
    public static short unsupported_extension;
    public static short certificate_unobtainable;
    public static short unrecognized_name;
    public static short bad_certificate_status_response;
    public static short bad_certificate_hash_value;
    public static short unknown_psk_identity;
    public static short no_application_protocol;
    public static short inappropriate_fallback;
    public static short missing_extension;
    public static short certificate_required;
    public static string GetName(short alertDescription);
    public static string GetText(short alertDescription);
}
public abstract class Org.BouncyCastle.Tls.AlertLevel : object {
    public static short warning;
    public static short fatal;
    public static string GetName(short alertDescription);
    public static string GetText(short alertDescription);
}
public class Org.BouncyCastle.Tls.BasicTlsPskExternal : object {
    protected Byte[] m_identity;
    protected TlsSecret m_key;
    protected int m_prfAlgorithm;
    public Byte[] Identity { get; }
    public TlsSecret Key { get; }
    public int PrfAlgorithm { get; }
    public BasicTlsPskExternal(Byte[] identity, TlsSecret key);
    public BasicTlsPskExternal(Byte[] identity, TlsSecret key, int prfAlgorithm);
    public virtual Byte[] get_Identity();
    public virtual TlsSecret get_Key();
    public virtual int get_PrfAlgorithm();
}
public class Org.BouncyCastle.Tls.BasicTlsPskIdentity : object {
    protected Byte[] m_identity;
    protected Byte[] m_psk;
    public BasicTlsPskIdentity(Byte[] identity, Byte[] psk);
    public BasicTlsPskIdentity(string identity, Byte[] psk);
    public virtual void SkipIdentityHint();
    public virtual void NotifyIdentityHint(Byte[] psk_identity_hint);
    public virtual Byte[] GetPskIdentity();
    public sealed virtual Byte[] GetPsk();
}
public class Org.BouncyCastle.Tls.BasicTlsSrpIdentity : object {
    protected Byte[] m_identity;
    protected Byte[] m_password;
    public BasicTlsSrpIdentity(Byte[] identity, Byte[] password);
    public BasicTlsSrpIdentity(string identity, string password);
    public virtual Byte[] GetSrpIdentity();
    public virtual Byte[] GetSrpPassword();
}
public class Org.BouncyCastle.Tls.ByteQueue : object {
    private Byte[] m_databuf;
    private int m_skipped;
    private int m_available;
    private bool m_readOnlyBuf;
    public int Available { get; }
    public ByteQueue(int capacity);
    public ByteQueue(Byte[] buf, int off, int len);
    private static int GetAllocationSize(int i);
    public void AddData(Byte[] buf, int off, int len);
    public int get_Available();
    public void CopyTo(Stream output, int length);
    public void Read(Byte[] buf, int offset, int len, int skip);
    internal HandshakeMessageInput ReadHandshakeMessage(int length);
    public int ReadInt32();
    public short ReadUint8(int skip);
    public int ReadUint16(int skip);
    public void RemoveData(int i);
    public void RemoveData(Byte[] buf, int off, int len, int skip);
    public Byte[] RemoveData(int len, int skip);
    public void Shrink();
}
public class Org.BouncyCastle.Tls.ByteQueueInputStream : BaseInputStream {
    private ByteQueue m_buffer;
    public int Available { get; }
    public void AddBytes(Byte[] buf);
    public void AddBytes(Byte[] buf, int bufOff, int bufLen);
    public int Peek(Byte[] buf);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public long Skip(long n);
    public int get_Available();
}
public class Org.BouncyCastle.Tls.ByteQueueOutputStream : BaseOutputStream {
    private ByteQueue m_buffer;
    public ByteQueue Buffer { get; }
    public ByteQueue get_Buffer();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public abstract class Org.BouncyCastle.Tls.CachedInformationType : object {
    public static short cert;
    public static short cert_req;
    public static string GetName(short cachedInformationType);
    public static string GetText(short cachedInformationType);
}
public abstract class Org.BouncyCastle.Tls.CertChainType : object {
    public static short individual_certs;
    public static short pkipath;
    public static string GetName(short certChainType);
    public static string GetText(short certChainType);
    public static bool IsValid(short certChainType);
}
public class Org.BouncyCastle.Tls.Certificate : object {
    private static TlsCertificate[] EmptyCerts;
    private static CertificateEntry[] EmptyCertEntries;
    public static Certificate EmptyChain;
    public static Certificate EmptyChainTls13;
    private Byte[] m_certificateRequestContext;
    private CertificateEntry[] m_certificateEntryList;
    private short m_certificateType;
    public short CertificateType { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Certificate(TlsCertificate[] certificateList);
    public Certificate(Byte[] certificateRequestContext, CertificateEntry[] certificateEntryList);
    public Certificate(short certificateType, Byte[] certificateRequestContext, CertificateEntry[] certificateEntryList);
    private static Certificate();
    private static CertificateEntry[] Convert(TlsCertificate[] certificateList);
    public Byte[] GetCertificateRequestContext();
    public TlsCertificate[] GetCertificateList();
    public TlsCertificate GetCertificateAt(int index);
    public CertificateEntry GetCertificateEntryAt(int index);
    public CertificateEntry[] GetCertificateEntryList();
    public short get_CertificateType();
    public int get_Length();
    public bool get_IsEmpty();
    public void Encode(TlsContext context, Stream messageOutput, Stream endPointHashOutput);
    public static Certificate Parse(ParseOptions options, TlsContext context, Stream messageInput, Stream endPointHashOutput);
    private static void CalculateEndPointHash(TlsContext context, TlsCertificate cert, Byte[] encoding, Stream output);
    private TlsCertificate[] CloneCertificateList();
    private CertificateEntry[] CloneCertificateEntryList();
}
public abstract class Org.BouncyCastle.Tls.CertificateCompressionAlgorithm : object {
    public static int zlib;
    public static int brotli;
    public static int zstd;
    public static string GetName(int certificateCompressionAlgorithm);
    public static string GetText(int certificateCompressionAlgorithm);
    public static bool IsRecognized(int certificateCompressionAlgorithm);
}
public class Org.BouncyCastle.Tls.CertificateEntry : object {
    private TlsCertificate m_certificate;
    private IDictionary`2<int, Byte[]> m_extensions;
    public TlsCertificate Certificate { get; }
    public IDictionary`2<int, Byte[]> Extensions { get; }
    public CertificateEntry(TlsCertificate certificate, IDictionary`2<int, Byte[]> extensions);
    public TlsCertificate get_Certificate();
    public IDictionary`2<int, Byte[]> get_Extensions();
}
public class Org.BouncyCastle.Tls.CertificateRequest : object {
    private Byte[] m_certificateRequestContext;
    private Int16[] m_certificateTypes;
    private IList`1<SignatureAndHashAlgorithm> m_supportedSignatureAlgorithms;
    private IList`1<SignatureAndHashAlgorithm> m_supportedSignatureAlgorithmsCert;
    private IList`1<X509Name> m_certificateAuthorities;
    public Int16[] CertificateTypes { get; }
    public IList`1<SignatureAndHashAlgorithm> SupportedSignatureAlgorithms { get; }
    public IList`1<SignatureAndHashAlgorithm> SupportedSignatureAlgorithmsCert { get; }
    public IList`1<X509Name> CertificateAuthorities { get; }
    public CertificateRequest(Int16[] certificateTypes, IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms, IList`1<X509Name> certificateAuthorities);
    public CertificateRequest(Byte[] certificateRequestContext, IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms, IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithmsCert, IList`1<X509Name> certificateAuthorities);
    private CertificateRequest(Byte[] certificateRequestContext, Int16[] certificateTypes, IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms, IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithmsCert, IList`1<X509Name> certificateAuthorities);
    private static IList`1<SignatureAndHashAlgorithm> CheckSupportedSignatureAlgorithms(IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms, short alertDescription);
    public Byte[] GetCertificateRequestContext();
    public Int16[] get_CertificateTypes();
    public IList`1<SignatureAndHashAlgorithm> get_SupportedSignatureAlgorithms();
    public IList`1<SignatureAndHashAlgorithm> get_SupportedSignatureAlgorithmsCert();
    public IList`1<X509Name> get_CertificateAuthorities();
    public bool HasCertificateRequestContext(Byte[] certificateRequestContext);
    public void Encode(TlsContext context, Stream output);
    public static CertificateRequest Parse(TlsContext context, Stream input);
}
public class Org.BouncyCastle.Tls.CertificateStatus : object {
    private short m_statusType;
    private object m_response;
    public short StatusType { get; }
    public object Response { get; }
    public OcspResponse OcspResponse { get; }
    public IList`1<OcspResponse> OcspResponseList { get; }
    public CertificateStatus(short statusType, object response);
    public short get_StatusType();
    public object get_Response();
    public OcspResponse get_OcspResponse();
    public IList`1<OcspResponse> get_OcspResponseList();
    public void Encode(Stream output);
    public static CertificateStatus Parse(TlsContext context, Stream input);
    private static bool IsCorrectType(short statusType, object response);
    private static bool IsOcspResponseList(object response);
    private static OcspResponse ParseOcspResponse(Byte[] derEncoding);
    private static void RequireStatusRequestVersion(int minVersion, int statusRequestVersion);
}
public class Org.BouncyCastle.Tls.CertificateStatusRequest : object {
    private short m_statusType;
    private object m_request;
    public short StatusType { get; }
    public object Request { get; }
    public OcspStatusRequest OcspStatusRequest { get; }
    public CertificateStatusRequest(short statusType, object request);
    public short get_StatusType();
    public object get_Request();
    public OcspStatusRequest get_OcspStatusRequest();
    public void Encode(Stream output);
    public static CertificateStatusRequest Parse(Stream input);
    private static bool IsCorrectType(short statusType, object request);
}
public class Org.BouncyCastle.Tls.CertificateStatusRequestItemV2 : object {
    private short m_statusType;
    private object m_request;
    public short StatusType { get; }
    public object Request { get; }
    public OcspStatusRequest OcspStatusRequest { get; }
    public CertificateStatusRequestItemV2(short statusType, object request);
    public short get_StatusType();
    public object get_Request();
    public OcspStatusRequest get_OcspStatusRequest();
    public void Encode(Stream output);
    public static CertificateStatusRequestItemV2 Parse(Stream input);
    private static bool IsCorrectType(short statusType, object request);
}
public abstract class Org.BouncyCastle.Tls.CertificateStatusType : object {
    public static short ocsp;
    public static short ocsp_multi;
}
public abstract class Org.BouncyCastle.Tls.CertificateType : object {
    public static short X509;
    public static short OpenPGP;
    public static short RawPublicKey;
}
public class Org.BouncyCastle.Tls.CertificateUrl : object {
    private short m_type;
    private IList`1<UrlAndHash> m_urlAndHashList;
    public short Type { get; }
    public IList`1<UrlAndHash> UrlAndHashList { get; }
    public CertificateUrl(short type, IList`1<UrlAndHash> urlAndHashList);
    public short get_Type();
    public IList`1<UrlAndHash> get_UrlAndHashList();
    public void Encode(Stream output);
    public static CertificateUrl Parse(TlsContext context, Stream input);
}
public class Org.BouncyCastle.Tls.CertificateVerify : object {
    private int m_algorithm;
    private Byte[] m_signature;
    public int Algorithm { get; }
    public Byte[] Signature { get; }
    public CertificateVerify(int algorithm, Byte[] signature);
    public int get_Algorithm();
    public Byte[] get_Signature();
    public void Encode(Stream output);
    public static CertificateVerify Parse(TlsContext context, Stream input);
}
public abstract class Org.BouncyCastle.Tls.ChangeCipherSpec : object {
    public static short change_cipher_spec;
}
public abstract class Org.BouncyCastle.Tls.ChannelBinding : object {
    public static int tls_server_end_point;
    public static int tls_unique;
    public static int tls_unique_for_telnet;
    public static int tls_exporter;
}
public abstract class Org.BouncyCastle.Tls.CipherSuite : object {
    public static int TLS_NULL_WITH_NULL_NULL;
    public static int TLS_RSA_WITH_NULL_MD5;
    public static int TLS_RSA_WITH_NULL_SHA;
    public static int TLS_RSA_EXPORT_WITH_RC4_40_MD5;
    public static int TLS_RSA_WITH_RC4_128_MD5;
    public static int TLS_RSA_WITH_RC4_128_SHA;
    public static int TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5;
    public static int TLS_RSA_WITH_IDEA_CBC_SHA;
    public static int TLS_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_RSA_WITH_DES_CBC_SHA;
    public static int TLS_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DH_DSS_WITH_DES_CBC_SHA;
    public static int TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DH_RSA_WITH_DES_CBC_SHA;
    public static int TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_DES_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_DES_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DH_anon_EXPORT_WITH_RC4_40_MD5;
    public static int TLS_DH_anon_WITH_RC4_128_MD5;
    public static int TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DH_anon_WITH_DES_CBC_SHA;
    public static int TLS_DH_anon_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_DH_DSS_WITH_AES_128_CBC_SHA;
    public static int TLS_DH_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_AES_128_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_DH_anon_WITH_AES_128_CBC_SHA;
    public static int TLS_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_DH_DSS_WITH_AES_256_CBC_SHA;
    public static int TLS_DH_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_AES_256_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_DH_anon_WITH_AES_256_CBC_SHA;
    public static int TLS_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_RSA_WITH_SEED_CBC_SHA;
    public static int TLS_DH_DSS_WITH_SEED_CBC_SHA;
    public static int TLS_DH_RSA_WITH_SEED_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_SEED_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_SEED_CBC_SHA;
    public static int TLS_DH_anon_WITH_SEED_CBC_SHA;
    public static int TLS_PSK_WITH_RC4_128_SHA;
    public static int TLS_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_DHE_PSK_WITH_RC4_128_SHA;
    public static int TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DHE_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_DHE_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_RSA_PSK_WITH_RC4_128_SHA;
    public static int TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_RSA_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_RSA_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDH_ECDSA_WITH_NULL_SHA;
    public static int TLS_ECDH_ECDSA_WITH_RC4_128_SHA;
    public static int TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_NULL_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_RC4_128_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDH_RSA_WITH_NULL_SHA;
    public static int TLS_ECDH_RSA_WITH_RC4_128_SHA;
    public static int TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDHE_RSA_WITH_NULL_SHA;
    public static int TLS_ECDHE_RSA_WITH_RC4_128_SHA;
    public static int TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDH_anon_WITH_NULL_SHA;
    public static int TLS_ECDH_anon_WITH_RC4_128_SHA;
    public static int TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDH_anon_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDH_anon_WITH_AES_256_CBC_SHA;
    public static int TLS_PSK_WITH_NULL_SHA;
    public static int TLS_DHE_PSK_WITH_NULL_SHA;
    public static int TLS_RSA_PSK_WITH_NULL_SHA;
    public static int TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_SRP_SHA_WITH_AES_128_CBC_SHA;
    public static int TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA;
    public static int TLS_SRP_SHA_WITH_AES_256_CBC_SHA;
    public static int TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA;
    public static int TLS_RSA_WITH_NULL_SHA256;
    public static int TLS_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_RSA_WITH_AES_256_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_AES_128_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_AES_128_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_AES_256_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_AES_256_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_AES_256_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
    public static int TLS_DH_anon_WITH_AES_128_CBC_SHA256;
    public static int TLS_DH_anon_WITH_AES_256_CBC_SHA256;
    public static int TLS_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_DH_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_DH_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_DHE_DSS_WITH_AES_128_GCM_SHA256;
    public static int TLS_DHE_DSS_WITH_AES_256_GCM_SHA384;
    public static int TLS_DH_DSS_WITH_AES_128_GCM_SHA256;
    public static int TLS_DH_DSS_WITH_AES_256_GCM_SHA384;
    public static int TLS_DH_anon_WITH_AES_128_GCM_SHA256;
    public static int TLS_DH_anon_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_DHE_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_DHE_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_RSA_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_RSA_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_PSK_WITH_NULL_SHA256;
    public static int TLS_PSK_WITH_NULL_SHA384;
    public static int TLS_DHE_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_DHE_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_DHE_PSK_WITH_NULL_SHA256;
    public static int TLS_DHE_PSK_WITH_NULL_SHA384;
    public static int TLS_RSA_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_RSA_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_RSA_PSK_WITH_NULL_SHA256;
    public static int TLS_RSA_PSK_WITH_NULL_SHA384;
    public static int TLS_ECDHE_PSK_WITH_RC4_128_SHA;
    public static int TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDHE_PSK_WITH_NULL_SHA;
    public static int TLS_ECDHE_PSK_WITH_NULL_SHA256;
    public static int TLS_ECDHE_PSK_WITH_NULL_SHA384;
    public static int TLS_EMPTY_RENEGOTIATION_INFO_SCSV;
    public static int TLS_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DH_anon_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DH_anon_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DH_anon_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DH_anon_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_PSK_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_PSK_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_PSK_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_PSK_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_RSA_WITH_AES_128_CCM;
    public static int TLS_RSA_WITH_AES_256_CCM;
    public static int TLS_DHE_RSA_WITH_AES_128_CCM;
    public static int TLS_DHE_RSA_WITH_AES_256_CCM;
    public static int TLS_RSA_WITH_AES_128_CCM_8;
    public static int TLS_RSA_WITH_AES_256_CCM_8;
    public static int TLS_DHE_RSA_WITH_AES_128_CCM_8;
    public static int TLS_DHE_RSA_WITH_AES_256_CCM_8;
    public static int TLS_PSK_WITH_AES_128_CCM;
    public static int TLS_PSK_WITH_AES_256_CCM;
    public static int TLS_DHE_PSK_WITH_AES_128_CCM;
    public static int TLS_DHE_PSK_WITH_AES_256_CCM;
    public static int TLS_PSK_WITH_AES_128_CCM_8;
    public static int TLS_PSK_WITH_AES_256_CCM_8;
    public static int TLS_PSK_DHE_WITH_AES_128_CCM_8;
    public static int TLS_PSK_DHE_WITH_AES_256_CCM_8;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CCM;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CCM;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8;
    public static int TLS_FALLBACK_SCSV;
    public static int TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256;
    public static int TLS_AES_128_GCM_SHA256;
    public static int TLS_AES_256_GCM_SHA384;
    public static int TLS_CHACHA20_POLY1305_SHA256;
    public static int TLS_AES_128_CCM_SHA256;
    public static int TLS_AES_128_CCM_8_SHA256;
    public static int TLS_SM4_GCM_SM3;
    public static int TLS_SM4_CCM_SM3;
    public static int TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC;
    public static int TLS_GOSTR341112_256_WITH_MAGMA_CTR_OMAC;
    public static int TLS_GOSTR341112_256_WITH_28147_CNT_IMIT;
    public static bool IsScsv(int cipherSuite);
}
public abstract class Org.BouncyCastle.Tls.CipherType : object {
    public static int stream;
    public static int block;
    public static int aead;
}
public abstract class Org.BouncyCastle.Tls.ClientAuthenticationType : object {
    public static short anonymous;
    public static short certificate_based;
    public static short psk;
}
public abstract class Org.BouncyCastle.Tls.ClientCertificateType : object {
    public static short rsa_sign;
    public static short dss_sign;
    public static short rsa_fixed_dh;
    public static short dss_fixed_dh;
    public static short rsa_ephemeral_dh_RESERVED;
    public static short dss_ephemeral_dh_RESERVED;
    public static short fortezza_dms_RESERVED;
    public static short ecdsa_sign;
    public static short rsa_fixed_ecdh;
    public static short ecdsa_fixed_ecdh;
    public static short gost_sign256;
    public static short gost_sign512;
    public static string GetName(short clientCertificateType);
    public static string GetText(short clientCertificateType);
}
public class Org.BouncyCastle.Tls.ClientHello : object {
    private ProtocolVersion m_version;
    private Byte[] m_random;
    private Byte[] m_sessionID;
    private Byte[] m_cookie;
    private Int32[] m_cipherSuites;
    private IDictionary`2<int, Byte[]> m_extensions;
    private int m_bindersSize;
    public int BindersSize { get; }
    public Int32[] CipherSuites { get; }
    public Byte[] Cookie { get; }
    public IDictionary`2<int, Byte[]> Extensions { get; }
    public Byte[] Random { get; }
    public Byte[] SessionID { get; }
    public ProtocolVersion Version { get; }
    public ClientHello(ProtocolVersion version, Byte[] random, Byte[] sessionID, Byte[] cookie, Int32[] cipherSuites, IDictionary`2<int, Byte[]> extensions, int bindersSize);
    public int get_BindersSize();
    public Int32[] get_CipherSuites();
    public Byte[] get_Cookie();
    public IDictionary`2<int, Byte[]> get_Extensions();
    public Byte[] get_Random();
    public Byte[] get_SessionID();
    public ProtocolVersion get_Version();
    public void Encode(TlsContext context, Stream output);
    public static ClientHello Parse(MemoryStream messageInput, Stream dtlsOutput);
    private static ClientHello ImplParse(MemoryStream messageInput, Stream dtlsOutput);
}
public class Org.BouncyCastle.Tls.CombinedHash : object {
    protected TlsContext m_context;
    protected TlsCrypto m_crypto;
    protected TlsHash m_md5;
    protected TlsHash m_sha1;
    internal CombinedHash(TlsContext context, TlsHash md5, TlsHash sha1);
    public CombinedHash(TlsCrypto crypto);
    public CombinedHash(CombinedHash t);
    public virtual void Update(Byte[] input, int inOff, int len);
    public virtual Byte[] CalculateHash();
    public virtual TlsHash CloneHash();
    public virtual void Reset();
}
public abstract class Org.BouncyCastle.Tls.CompressionMethod : object {
    public static short cls_null;
    public static short DEFLATE;
}
public abstract class Org.BouncyCastle.Tls.ConnectionEnd : object {
    public static int server;
    public static int client;
}
public abstract class Org.BouncyCastle.Tls.ContentType : object {
    public static short change_cipher_spec;
    public static short alert;
    public static short handshake;
    public static short application_data;
    public static short heartbeat;
    public static short tls12_cid;
    public static string GetName(short contentType);
    public static string GetText(short contentType);
}
public abstract class Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm : object {
    public static int md5;
    public static int sha1;
    public static int sha224;
    public static int sha256;
    public static int sha384;
    public static int sha512;
    public static int sm3;
}
public abstract class Org.BouncyCastle.Tls.Crypto.CryptoSignatureAlgorithm : object {
    public static int rsa;
    public static int dsa;
    public static int ecdsa;
    public static int rsa_pss_rsae_sha256;
    public static int rsa_pss_rsae_sha384;
    public static int rsa_pss_rsae_sha512;
    public static int ed25519;
    public static int ed448;
    public static int rsa_pss_pss_sha256;
    public static int rsa_pss_pss_sha384;
    public static int rsa_pss_pss_sha512;
    public static int ecdsa_brainpoolP256r1tls13_sha256;
    public static int ecdsa_brainpoolP384r1tls13_sha384;
    public static int ecdsa_brainpoolP512r1tls13_sha512;
    public static int gostr34102012_256;
    public static int gostr34102012_512;
    public static int sm2;
}
public class Org.BouncyCastle.Tls.Crypto.DHGroup : object {
    private BigInteger g;
    private BigInteger p;
    private BigInteger q;
    private int l;
    public BigInteger G { get; }
    public int L { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public DHGroup(BigInteger p, BigInteger q, BigInteger g, int l);
    public virtual BigInteger get_G();
    public virtual int get_L();
    public virtual BigInteger get_P();
    public virtual BigInteger get_Q();
}
public class Org.BouncyCastle.Tls.Crypto.DHStandardGroups : object {
    private static BigInteger Two;
    private static string rfc2409_768_p;
    public static DHGroup rfc2409_768;
    private static string rfc2409_1024_p;
    public static DHGroup rfc2409_1024;
    private static string rfc3526_1536_p;
    private static int rfc3526_1536_l;
    public static DHGroup rfc3526_1536;
    private static string rfc3526_2048_p;
    private static int rfc3526_2048_l;
    public static DHGroup rfc3526_2048;
    private static string rfc3526_3072_p;
    private static int rfc3526_3072_l;
    public static DHGroup rfc3526_3072;
    private static string rfc3526_4096_p;
    private static int rfc3526_4096_l;
    public static DHGroup rfc3526_4096;
    private static string rfc3526_6144_p;
    private static int rfc3526_6144_l;
    public static DHGroup rfc3526_6144;
    private static string rfc3526_8192_p;
    private static int rfc3526_8192_l;
    public static DHGroup rfc3526_8192;
    public static DHGroup rfc4306_768;
    public static DHGroup rfc4306_1024;
    public static DHGroup rfc5996_768;
    public static DHGroup rfc5996_1024;
    private static string rfc7919_ffdhe2048_p;
    private static int rfc7919_ffdhe2048_l;
    public static DHGroup rfc7919_ffdhe2048;
    private static string rfc7919_ffdhe3072_p;
    private static int rfc7919_ffdhe3072_l;
    public static DHGroup rfc7919_ffdhe3072;
    private static string rfc7919_ffdhe4096_p;
    private static int rfc7919_ffdhe4096_l;
    public static DHGroup rfc7919_ffdhe4096;
    private static string rfc7919_ffdhe6144_p;
    private static int rfc7919_ffdhe6144_l;
    public static DHGroup rfc7919_ffdhe6144;
    private static string rfc7919_ffdhe8192_p;
    private static int rfc7919_ffdhe8192_l;
    public static DHGroup rfc7919_ffdhe8192;
    private static DHStandardGroups();
    private static BigInteger FromHex(string hex);
    private static DHGroup SafePrimeGen2(string hexP);
    private static DHGroup SafePrimeGen2(string hexP, int l);
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsCrypto : object {
    public SecureRandom SecureRandom { get; }
    public abstract virtual bool HasAnyStreamVerifiers(IList`1<SignatureAndHashAlgorithm> signatureAndHashAlgorithms);
    public abstract virtual bool HasAnyStreamVerifiersLegacy(Int16[] clientCertificateTypes);
    public abstract virtual bool HasCryptoHashAlgorithm(int cryptoHashAlgorithm);
    public abstract virtual bool HasCryptoSignatureAlgorithm(int cryptoSignatureAlgorithm);
    public abstract virtual bool HasDHAgreement();
    public abstract virtual bool HasECDHAgreement();
    public abstract virtual bool HasEncryptionAlgorithm(int encryptionAlgorithm);
    public abstract virtual bool HasHkdfAlgorithm(int cryptoHashAlgorithm);
    public abstract virtual bool HasMacAlgorithm(int macAlgorithm);
    public abstract virtual bool HasNamedGroup(int namedGroup);
    public abstract virtual bool HasRsaEncryption();
    public abstract virtual bool HasSignatureAlgorithm(short signatureAlgorithm);
    public abstract virtual bool HasSignatureAndHashAlgorithm(SignatureAndHashAlgorithm sigAndHashAlgorithm);
    public abstract virtual bool HasSignatureScheme(int signatureScheme);
    public abstract virtual bool HasSrpAuthentication();
    public abstract virtual TlsSecret CreateSecret(Byte[] data);
    public abstract virtual TlsSecret GenerateRsaPreMasterSecret(ProtocolVersion clientVersion);
    public abstract virtual SecureRandom get_SecureRandom();
    public virtual TlsCertificate CreateCertificate(Byte[] encoding);
    public abstract virtual TlsCertificate CreateCertificate(short type, Byte[] encoding);
    public abstract virtual TlsCipher CreateCipher(TlsCryptoParameters cryptoParams, int encryptionAlgorithm, int macAlgorithm);
    public abstract virtual TlsDHDomain CreateDHDomain(TlsDHConfig dhConfig);
    public abstract virtual TlsECDomain CreateECDomain(TlsECConfig ecConfig);
    public virtual TlsSecret AdoptSecret(TlsSecret secret);
    public abstract virtual TlsHash CreateHash(int cryptoHashAlgorithm);
    public abstract virtual TlsHmac CreateHmac(int macAlgorithm);
    public abstract virtual TlsHmac CreateHmacForHash(int cryptoHashAlgorithm);
    public abstract virtual TlsNonceGenerator CreateNonceGenerator(Byte[] additionalSeedMaterial);
    public abstract virtual TlsSrp6Client CreateSrp6Client(TlsSrpConfig srpConfig);
    public abstract virtual TlsSrp6Server CreateSrp6Server(TlsSrpConfig srpConfig, BigInteger srpVerifier);
    public abstract virtual TlsSrp6VerifierGenerator CreateSrp6VerifierGenerator(TlsSrpConfig srpConfig);
    public abstract virtual TlsSecret HkdfInit(int cryptoHashAlgorithm);
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsSecret : object {
    protected Byte[] m_data;
    protected AbstractTlsCrypto Crypto { get; }
    public int Length { get; }
    protected AbstractTlsSecret(Byte[] data);
    protected static Byte[] CopyData(AbstractTlsSecret other);
    protected virtual void CheckAlive();
    protected abstract virtual AbstractTlsCrypto get_Crypto();
    public virtual Byte[] CalculateHmac(int cryptoHashAlgorithm, Byte[] buf, int off, int len);
    public abstract virtual TlsSecret DeriveUsingPrf(int prfAlgorithm, string label, Byte[] seed, int length);
    public virtual void Destroy();
    public virtual Byte[] Encrypt(TlsEncryptor encryptor);
    public virtual Byte[] Extract();
    public abstract virtual TlsSecret HkdfExpand(int cryptoHashAlgorithm, Byte[] info, int length);
    public abstract virtual TlsSecret HkdfExtract(int cryptoHashAlgorithm, TlsSecret ikm);
    public virtual bool IsAlive();
    public virtual int get_Length();
    internal virtual Byte[] CopyData();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcChaCha20Poly1305 : object {
    private static Byte[] Zeroes;
    private ChaCha7539Engine m_cipher;
    private Poly1305 m_mac;
    private bool m_isEncrypting;
    private int m_additionalDataLength;
    public BcChaCha20Poly1305(bool isEncrypting);
    private static BcChaCha20Poly1305();
    public sealed virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
    public sealed virtual int GetOutputSize(int inputLength);
    public sealed virtual void Init(Byte[] nonce, int macSize, Byte[] additionalData);
    public sealed virtual void Reset();
    public sealed virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    private void InitMac();
    private void UpdateMac(Byte[] buf, int off, int len);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedAgreement : object {
    protected TlsCredentialedAgreement m_agreementCredentials;
    public Certificate Certificate { get; }
    public BcDefaultTlsCredentialedAgreement(BcTlsCrypto crypto, Certificate certificate, AsymmetricKeyParameter privateKey);
    public virtual Certificate get_Certificate();
    public virtual TlsSecret GenerateAgreement(TlsCertificate peerCertificate);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedDecryptor : object {
    protected BcTlsCrypto m_crypto;
    protected Certificate m_certificate;
    protected AsymmetricKeyParameter m_privateKey;
    public Certificate Certificate { get; }
    public BcDefaultTlsCredentialedDecryptor(BcTlsCrypto crypto, Certificate certificate, AsymmetricKeyParameter privateKey);
    public virtual Certificate get_Certificate();
    public virtual TlsSecret Decrypt(TlsCryptoParameters cryptoParams, Byte[] ciphertext);
    protected virtual TlsSecret SafeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, RsaKeyParameters rsaServerPrivateKey, Byte[] encryptedPreMasterSecret);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedSigner : DefaultTlsCredentialedSigner {
    public BcDefaultTlsCredentialedSigner(TlsCryptoParameters cryptoParams, BcTlsCrypto crypto, AsymmetricKeyParameter privateKey, Certificate certificate, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    private static BcTlsCertificate GetEndEntity(BcTlsCrypto crypto, Certificate certificate);
    private static TlsSigner MakeSigner(BcTlsCrypto crypto, AsymmetricKeyParameter privateKey, Certificate certificate, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcSsl3Hmac : object {
    private static byte IPAD_BYTE;
    private static byte OPAD_BYTE;
    private static Byte[] IPAD;
    private static Byte[] OPAD;
    private IDigest m_digest;
    private int m_padLength;
    private Byte[] m_secret;
    public int InternalBlockSize { get; }
    public int MacLength { get; }
    internal BcSsl3Hmac(IDigest digest);
    private static BcSsl3Hmac();
    public virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public virtual void Update(Byte[] input, int inOff, int len);
    public virtual Byte[] CalculateMac();
    public virtual void CalculateMac(Byte[] output, int outOff);
    public virtual int get_InternalBlockSize();
    public virtual int get_MacLength();
    public virtual void Reset();
    private void DoFinal(Byte[] output, int outOff);
    private static Byte[] GenPad(byte b, int count);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTls13Verifier : object {
    private SignerSink m_output;
    public Stream Stream { get; }
    internal BcTls13Verifier(ISigner verifier);
    public sealed virtual Stream get_Stream();
    public sealed virtual bool VerifySignature(Byte[] signature);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsAeadCipherImpl : object {
    private bool m_isEncrypting;
    internal IAeadCipher m_cipher;
    private KeyParameter key;
    internal BcTlsAeadCipherImpl(IAeadCipher cipher, bool isEncrypting);
    public sealed virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public sealed virtual void Init(Byte[] nonce, int macSize, Byte[] additionalData);
    public sealed virtual int GetOutputSize(int inputLength);
    public virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
    public sealed virtual void Reset();
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsBlockCipherImpl : object {
    private bool m_isEncrypting;
    private IBlockCipher m_cipher;
    private KeyParameter key;
    internal BcTlsBlockCipherImpl(IBlockCipher cipher, bool isEncrypting);
    public sealed virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public sealed virtual void Init(Byte[] iv, int ivOff, int ivLen);
    public sealed virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
    public sealed virtual int GetBlockSize();
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCcmImpl : BcTlsAeadCipherImpl {
    internal BcTlsCcmImpl(CcmBlockCipher cipher, bool isEncrypting);
    public virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate : BcTlsRawKeyCertificate {
    protected X509CertificateStructure m_certificate;
    public X509CertificateStructure X509CertificateStructure { get; }
    public BigInteger SerialNumber { get; }
    public string SigAlgOid { get; }
    public BcTlsCertificate(BcTlsCrypto crypto, Byte[] encoding);
    public BcTlsCertificate(BcTlsCrypto crypto, X509CertificateStructure certificate);
    public static BcTlsCertificate Convert(BcTlsCrypto crypto, TlsCertificate certificate);
    public static X509CertificateStructure ParseCertificate(Byte[] encoding);
    public virtual X509CertificateStructure get_X509CertificateStructure();
    public virtual Byte[] GetEncoded();
    public virtual Byte[] GetExtension(DerObjectIdentifier extensionOid);
    public virtual BigInteger get_SerialNumber();
    public virtual string get_SigAlgOid();
    public virtual Asn1Encodable GetSigAlgParams();
    protected virtual bool SupportsKeyUsage(int keyUsageBits);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto : AbstractTlsCrypto {
    private SecureRandom m_entropySource;
    public SecureRandom SecureRandom { get; }
    public BcTlsCrypto(SecureRandom entropySource);
    internal virtual BcTlsSecret AdoptLocalSecret(Byte[] data);
    public virtual SecureRandom get_SecureRandom();
    public virtual TlsCertificate CreateCertificate(short type, Byte[] encoding);
    public virtual TlsCipher CreateCipher(TlsCryptoParameters cryptoParams, int encryptionAlgorithm, int macAlgorithm);
    public virtual TlsDHDomain CreateDHDomain(TlsDHConfig dhConfig);
    public virtual TlsECDomain CreateECDomain(TlsECConfig ecConfig);
    public virtual TlsNonceGenerator CreateNonceGenerator(Byte[] additionalSeedMaterial);
    public virtual bool HasAnyStreamVerifiers(IList`1<SignatureAndHashAlgorithm> signatureAndHashAlgorithms);
    public virtual bool HasAnyStreamVerifiersLegacy(Int16[] clientCertificateTypes);
    public virtual bool HasCryptoHashAlgorithm(int cryptoHashAlgorithm);
    public virtual bool HasCryptoSignatureAlgorithm(int cryptoSignatureAlgorithm);
    public virtual bool HasDHAgreement();
    public virtual bool HasECDHAgreement();
    public virtual bool HasEncryptionAlgorithm(int encryptionAlgorithm);
    public virtual bool HasHkdfAlgorithm(int cryptoHashAlgorithm);
    public virtual bool HasMacAlgorithm(int macAlgorithm);
    public virtual bool HasNamedGroup(int namedGroup);
    public virtual bool HasRsaEncryption();
    public virtual bool HasSignatureAlgorithm(short signatureAlgorithm);
    public virtual bool HasSignatureAndHashAlgorithm(SignatureAndHashAlgorithm sigAndHashAlgorithm);
    public virtual bool HasSignatureScheme(int signatureScheme);
    public virtual bool HasSrpAuthentication();
    public virtual TlsSecret CreateSecret(Byte[] data);
    public virtual TlsSecret GenerateRsaPreMasterSecret(ProtocolVersion version);
    public virtual IDigest CloneDigest(int cryptoHashAlgorithm, IDigest digest);
    public virtual IDigest CreateDigest(int cryptoHashAlgorithm);
    public virtual TlsHash CreateHash(int cryptoHashAlgorithm);
    protected virtual IBlockCipher CreateBlockCipher(int encryptionAlgorithm);
    protected virtual IBlockCipher CreateCbcBlockCipher(IBlockCipher blockCipher);
    protected virtual IBlockCipher CreateCbcBlockCipher(int encryptionAlgorithm);
    protected virtual TlsCipher CreateChaCha20Poly1305(TlsCryptoParameters cryptoParams);
    protected virtual TlsAeadCipher CreateCipher_Aes_Ccm(TlsCryptoParameters cryptoParams, int cipherKeySize, int macSize);
    protected virtual TlsAeadCipher CreateCipher_Aes_Gcm(TlsCryptoParameters cryptoParams, int cipherKeySize, int macSize);
    protected virtual TlsAeadCipher CreateCipher_Aria_Gcm(TlsCryptoParameters cryptoParams, int cipherKeySize, int macSize);
    protected virtual TlsAeadCipher CreateCipher_Camellia_Gcm(TlsCryptoParameters cryptoParams, int cipherKeySize, int macSize);
    protected virtual TlsCipher CreateCipher_Cbc(TlsCryptoParameters cryptoParams, int encryptionAlgorithm, int cipherKeySize, int macAlgorithm);
    protected virtual TlsAeadCipher CreateCipher_SM4_Ccm(TlsCryptoParameters cryptoParams);
    protected virtual TlsAeadCipher CreateCipher_SM4_Gcm(TlsCryptoParameters cryptoParams);
    protected virtual TlsNullCipher CreateNullCipher(TlsCryptoParameters cryptoParams, int macAlgorithm);
    protected virtual IBlockCipher CreateAesEngine();
    protected virtual IBlockCipher CreateAriaEngine();
    protected virtual IBlockCipher CreateCamelliaEngine();
    protected virtual IBlockCipher CreateDesEdeEngine();
    protected virtual IBlockCipher CreateSeedEngine();
    protected virtual IBlockCipher CreateSM4Engine();
    protected virtual CcmBlockCipher CreateCcmMode(IBlockCipher engine);
    protected virtual IAeadCipher CreateGcmMode(IBlockCipher engine);
    protected virtual CcmBlockCipher CreateAeadCipher_Aes_Ccm();
    protected virtual IAeadCipher CreateAeadCipher_Aes_Gcm();
    protected virtual IAeadCipher CreateAeadCipher_Aria_Gcm();
    protected virtual IAeadCipher CreateAeadCipher_Camellia_Gcm();
    protected virtual CcmBlockCipher CreateAeadCipher_SM4_Ccm();
    protected virtual IAeadCipher CreateAeadCipher_SM4_Gcm();
    public virtual TlsHmac CreateHmac(int macAlgorithm);
    public virtual TlsHmac CreateHmacForHash(int cryptoHashAlgorithm);
    protected virtual TlsHmac CreateHmac_Ssl(int macAlgorithm);
    protected virtual TlsHmac CreateMac(TlsCryptoParameters cryptoParams, int macAlgorithm);
    public virtual TlsSrp6Client CreateSrp6Client(TlsSrpConfig srpConfig);
    public virtual TlsSrp6Server CreateSrp6Server(TlsSrpConfig srpConfig, BigInteger srpVerifier);
    public virtual TlsSrp6VerifierGenerator CreateSrp6VerifierGenerator(TlsSrpConfig srpConfig);
    public virtual TlsSecret HkdfInit(int cryptoHashAlgorithm);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDH : object {
    protected BcTlsDHDomain m_domain;
    protected AsymmetricCipherKeyPair m_localKeyPair;
    protected DHPublicKeyParameters m_peerPublicKey;
    public BcTlsDH(BcTlsDHDomain domain);
    public virtual Byte[] GenerateEphemeral();
    public virtual void ReceivePeerValue(Byte[] peerValue);
    public virtual TlsSecret CalculateSecret();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDHDomain : object {
    protected BcTlsCrypto m_crypto;
    protected TlsDHConfig m_config;
    protected DHParameters m_domainParameters;
    public BcTlsDHDomain(BcTlsCrypto crypto, TlsDHConfig dhConfig);
    private static Byte[] EncodeValue(DHParameters dh, bool padded, BigInteger x);
    private static int GetValueLength(DHParameters dh);
    public static BcTlsSecret CalculateDHAgreement(BcTlsCrypto crypto, DHPrivateKeyParameters privateKey, DHPublicKeyParameters publicKey, bool padded);
    public static DHParameters GetDomainParameters(TlsDHConfig dhConfig);
    public virtual BcTlsSecret CalculateDHAgreement(DHPrivateKeyParameters privateKey, DHPublicKeyParameters publicKey);
    public virtual TlsAgreement CreateDH();
    public virtual BigInteger DecodeParameter(Byte[] encoding);
    public virtual DHPublicKeyParameters DecodePublicKey(Byte[] encoding);
    public virtual Byte[] EncodeParameter(BigInteger x);
    public virtual Byte[] EncodePublicKey(DHPublicKeyParameters publicKey);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDsaSigner : BcTlsDssSigner {
    protected short SignatureAlgorithm { get; }
    public BcTlsDsaSigner(BcTlsCrypto crypto, DsaPrivateKeyParameters privateKey);
    protected virtual IDsa CreateDsaImpl(int cryptoHashAlgorithm);
    protected virtual short get_SignatureAlgorithm();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDsaVerifier : BcTlsDssVerifier {
    protected short SignatureAlgorithm { get; }
    public BcTlsDsaVerifier(BcTlsCrypto crypto, DsaPublicKeyParameters publicKey);
    protected virtual IDsa CreateDsaImpl();
    protected virtual short get_SignatureAlgorithm();
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDssSigner : BcTlsSigner {
    protected short SignatureAlgorithm { get; }
    protected BcTlsDssSigner(BcTlsCrypto crypto, AsymmetricKeyParameter privateKey);
    protected abstract virtual IDsa CreateDsaImpl(int cryptoHashAlgorithm);
    protected abstract virtual short get_SignatureAlgorithm();
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDssVerifier : BcTlsVerifier {
    protected short SignatureAlgorithm { get; }
    protected BcTlsDssVerifier(BcTlsCrypto crypto, AsymmetricKeyParameter publicKey);
    protected abstract virtual IDsa CreateDsaImpl();
    protected abstract virtual short get_SignatureAlgorithm();
    public virtual bool VerifyRawSignature(DigitallySigned digitallySigned, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDH : object {
    protected BcTlsECDomain m_domain;
    protected AsymmetricCipherKeyPair m_localKeyPair;
    protected ECPublicKeyParameters m_peerPublicKey;
    public BcTlsECDH(BcTlsECDomain domain);
    public virtual Byte[] GenerateEphemeral();
    public virtual void ReceivePeerValue(Byte[] peerValue);
    public virtual TlsSecret CalculateSecret();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDomain : object {
    protected BcTlsCrypto m_crypto;
    protected TlsECConfig m_config;
    protected ECDomainParameters m_domainParameters;
    public BcTlsECDomain(BcTlsCrypto crypto, TlsECConfig ecConfig);
    public static BcTlsSecret CalculateECDHAgreement(BcTlsCrypto crypto, ECPrivateKeyParameters privateKey, ECPublicKeyParameters publicKey);
    public static ECDomainParameters GetDomainParameters(TlsECConfig ecConfig);
    public static ECDomainParameters GetDomainParameters(int namedGroup);
    public virtual BcTlsSecret CalculateECDHAgreement(ECPrivateKeyParameters privateKey, ECPublicKeyParameters publicKey);
    public virtual TlsAgreement CreateECDH();
    public virtual ECPoint DecodePoint(Byte[] encoding);
    public virtual ECPublicKeyParameters DecodePublicKey(Byte[] encoding);
    public virtual Byte[] EncodePoint(ECPoint point);
    public virtual Byte[] EncodePublicKey(ECPublicKeyParameters publicKey);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsa13Signer : BcTlsSigner {
    private int m_signatureScheme;
    public BcTlsECDsa13Signer(BcTlsCrypto crypto, ECPrivateKeyParameters privateKey, int signatureScheme);
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsaSigner : BcTlsDssSigner {
    protected short SignatureAlgorithm { get; }
    public BcTlsECDsaSigner(BcTlsCrypto crypto, ECPrivateKeyParameters privateKey);
    protected virtual IDsa CreateDsaImpl(int cryptoHashAlgorithm);
    protected virtual short get_SignatureAlgorithm();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsaVerifier : BcTlsDssVerifier {
    protected short SignatureAlgorithm { get; }
    public BcTlsECDsaVerifier(BcTlsCrypto crypto, ECPublicKeyParameters publicKey);
    protected virtual IDsa CreateDsaImpl();
    protected virtual short get_SignatureAlgorithm();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsEd25519Signer : BcTlsSigner {
    public BcTlsEd25519Signer(BcTlsCrypto crypto, Ed25519PrivateKeyParameters privateKey);
    public virtual TlsStreamSigner GetStreamSigner(SignatureAndHashAlgorithm algorithm);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsEd448Signer : BcTlsSigner {
    public BcTlsEd448Signer(BcTlsCrypto crypto, Ed448PrivateKeyParameters privateKey);
    public virtual TlsStreamSigner GetStreamSigner(SignatureAndHashAlgorithm algorithm);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsHash : object {
    private BcTlsCrypto m_crypto;
    private int m_cryptoHashAlgorithm;
    private IDigest m_digest;
    internal BcTlsHash(BcTlsCrypto crypto, int cryptoHashAlgorithm);
    private BcTlsHash(BcTlsCrypto crypto, int cryptoHashAlgorithm, IDigest digest);
    public sealed virtual void Update(Byte[] data, int offSet, int length);
    public sealed virtual Byte[] CalculateHash();
    public sealed virtual TlsHash CloneHash();
    public sealed virtual void Reset();
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsHmac : object {
    private HMac m_hmac;
    public int InternalBlockSize { get; }
    public int MacLength { get; }
    internal BcTlsHmac(HMac hmac);
    public sealed virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public sealed virtual void Update(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] CalculateMac();
    public sealed virtual void CalculateMac(Byte[] output, int outOff);
    public sealed virtual int get_InternalBlockSize();
    public sealed virtual int get_MacLength();
    public sealed virtual void Reset();
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsNonceGenerator : object {
    private IRandomGenerator m_randomGenerator;
    internal BcTlsNonceGenerator(IRandomGenerator randomGenerator);
    public sealed virtual Byte[] GenerateNonce(int size);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRawKeyCertificate : object {
    protected BcTlsCrypto m_crypto;
    protected SubjectPublicKeyInfo m_keyInfo;
    protected DHPublicKeyParameters m_pubKeyDH;
    protected ECPublicKeyParameters m_pubKeyEC;
    protected Ed25519PublicKeyParameters m_pubKeyEd25519;
    protected Ed448PublicKeyParameters m_pubKeyEd448;
    protected RsaKeyParameters m_pubKeyRsa;
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public BigInteger SerialNumber { get; }
    public string SigAlgOid { get; }
    public BcTlsRawKeyCertificate(BcTlsCrypto crypto, Byte[] encoding);
    public BcTlsRawKeyCertificate(BcTlsCrypto crypto, SubjectPublicKeyInfo keyInfo);
    public virtual SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public virtual TlsEncryptor CreateEncryptor(int tlsCertificateRole);
    public virtual TlsVerifier CreateVerifier(short signatureAlgorithm);
    public virtual Tls13Verifier CreateVerifier(int signatureScheme);
    public virtual Byte[] GetEncoded();
    public virtual Byte[] GetExtension(DerObjectIdentifier extensionOid);
    public virtual BigInteger get_SerialNumber();
    public virtual string get_SigAlgOid();
    public virtual Asn1Encodable GetSigAlgParams();
    public virtual short GetLegacySignatureAlgorithm();
    public virtual DHPublicKeyParameters GetPubKeyDH();
    public virtual DsaPublicKeyParameters GetPubKeyDss();
    public virtual ECPublicKeyParameters GetPubKeyEC();
    public virtual Ed25519PublicKeyParameters GetPubKeyEd25519();
    public virtual Ed448PublicKeyParameters GetPubKeyEd448();
    public virtual RsaKeyParameters GetPubKeyRsa();
    public virtual bool SupportsSignatureAlgorithm(short signatureAlgorithm);
    public virtual bool SupportsSignatureAlgorithmCA(short signatureAlgorithm);
    public virtual TlsCertificate CheckUsageInRole(int tlsCertificateRole);
    protected virtual AsymmetricKeyParameter GetPublicKey();
    protected virtual bool SupportsKeyUsage(int keyUsageBits);
    protected virtual bool SupportsRsa_Pkcs1();
    protected virtual bool SupportsRsa_Pss_Pss(short signatureAlgorithm);
    protected virtual bool SupportsRsa_Pss_Rsae();
    protected virtual bool SupportsSignatureAlgorithm(short signatureAlgorithm, int keyUsage);
    public virtual void ValidateKeyUsage(int keyUsageBits);
    protected virtual void ValidateRsa_Pkcs1();
    protected virtual void ValidateRsa_Pss_Pss(short signatureAlgorithm);
    protected virtual void ValidateRsa_Pss_Rsae();
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaEncryptor : object {
    private BcTlsCrypto m_crypto;
    private RsaKeyParameters m_pubKeyRsa;
    internal BcTlsRsaEncryptor(BcTlsCrypto crypto, RsaKeyParameters pubKeyRsa);
    private static RsaKeyParameters CheckPublicKey(RsaKeyParameters pubKeyRsa);
    public sealed virtual Byte[] Encrypt(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaPssSigner : BcTlsSigner {
    private int m_signatureScheme;
    public BcTlsRsaPssSigner(BcTlsCrypto crypto, RsaKeyParameters privateKey, int signatureScheme);
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaPssVerifier : BcTlsVerifier {
    private int m_signatureScheme;
    public BcTlsRsaPssVerifier(BcTlsCrypto crypto, RsaKeyParameters publicKey, int signatureScheme);
    public virtual bool VerifyRawSignature(DigitallySigned digitallySigned, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaSigner : BcTlsSigner {
    private RsaKeyParameters m_publicKey;
    public BcTlsRsaSigner(BcTlsCrypto crypto, RsaKeyParameters privateKey, RsaKeyParameters publicKey);
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaVerifier : BcTlsVerifier {
    public BcTlsRsaVerifier(BcTlsCrypto crypto, RsaKeyParameters publicKey);
    public virtual bool VerifyRawSignature(DigitallySigned digitallySigned, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSecret : AbstractTlsSecret {
    private static Byte[] Ssl3Const;
    protected BcTlsCrypto m_crypto;
    protected AbstractTlsCrypto Crypto { get; }
    public BcTlsSecret(BcTlsCrypto crypto, Byte[] data);
    private static BcTlsSecret();
    public static BcTlsSecret Convert(BcTlsCrypto crypto, TlsSecret secret);
    private static Byte[] GenerateSsl3Constants();
    public virtual TlsSecret DeriveUsingPrf(int prfAlgorithm, string label, Byte[] seed, int length);
    public virtual TlsSecret HkdfExpand(int cryptoHashAlgorithm, Byte[] info, int length);
    public virtual TlsSecret HkdfExtract(int cryptoHashAlgorithm, TlsSecret ikm);
    protected virtual AbstractTlsCrypto get_Crypto();
    protected virtual void HmacHash(int cryptoHashAlgorithm, Byte[] secret, int secretOff, int secretLen, Byte[] seed, Byte[] output);
    protected virtual Byte[] Prf(int prfAlgorithm, string label, Byte[] seed, int length);
    protected virtual Byte[] Prf_Ssl(Byte[] seed, int length);
    protected virtual Byte[] Prf_1_0(Byte[] labelSeed, int length);
    protected virtual Byte[] Prf_1_2(int prfAlgorithm, Byte[] labelSeed, int length);
    protected virtual void UpdateMac(IMac mac);
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSigner : object {
    protected BcTlsCrypto m_crypto;
    protected AsymmetricKeyParameter m_privateKey;
    protected BcTlsSigner(BcTlsCrypto crypto, AsymmetricKeyParameter privateKey);
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
    public virtual TlsStreamSigner GetStreamSigner(SignatureAndHashAlgorithm algorithm);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSrp6Client : object {
    private Srp6Client m_srp6Client;
    internal BcTlsSrp6Client(Srp6Client srpClient);
    public sealed virtual BigInteger CalculateSecret(BigInteger serverB);
    public sealed virtual BigInteger GenerateClientCredentials(Byte[] srpSalt, Byte[] identity, Byte[] password);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSrp6Server : object {
    private Srp6Server m_srp6Server;
    internal BcTlsSrp6Server(Srp6Server srp6Server);
    public sealed virtual BigInteger GenerateServerCredentials();
    public sealed virtual BigInteger CalculateSecret(BigInteger clientA);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSrp6VerifierGenerator : object {
    private Srp6VerifierGenerator m_srp6VerifierGenerator;
    internal BcTlsSrp6VerifierGenerator(Srp6VerifierGenerator srp6VerifierGenerator);
    public sealed virtual BigInteger GenerateVerifier(Byte[] salt, Byte[] identity, Byte[] password);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsStreamSigner : object {
    private SignerSink m_output;
    public Stream Stream { get; }
    internal BcTlsStreamSigner(ISigner signer);
    public sealed virtual Stream get_Stream();
    public sealed virtual Byte[] GetSignature();
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsStreamVerifier : object {
    private SignerSink m_output;
    private Byte[] m_signature;
    public Stream Stream { get; }
    internal BcTlsStreamVerifier(ISigner verifier, Byte[] signature);
    public sealed virtual Stream get_Stream();
    public sealed virtual bool IsVerified();
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsVerifier : object {
    protected BcTlsCrypto m_crypto;
    protected AsymmetricKeyParameter m_publicKey;
    protected BcTlsVerifier(BcTlsCrypto crypto, AsymmetricKeyParameter publicKey);
    public virtual TlsStreamVerifier GetStreamVerifier(DigitallySigned digitallySigned);
    public virtual bool VerifyRawSignature(DigitallySigned digitallySigned, Byte[] hash);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcVerifyingStreamSigner : object {
    private ISigner m_signer;
    private ISigner m_verifier;
    private TeeOutputStream m_output;
    public Stream Stream { get; }
    internal BcVerifyingStreamSigner(ISigner signer, ISigner verifier);
    public sealed virtual Stream get_Stream();
    public sealed virtual Byte[] GetSignature();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX25519 : object {
    protected BcTlsCrypto m_crypto;
    protected Byte[] m_privateKey;
    protected Byte[] m_peerPublicKey;
    public BcX25519(BcTlsCrypto crypto);
    public virtual Byte[] GenerateEphemeral();
    public virtual void ReceivePeerValue(Byte[] peerValue);
    public virtual TlsSecret CalculateSecret();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX25519Domain : object {
    protected BcTlsCrypto m_crypto;
    public BcX25519Domain(BcTlsCrypto crypto);
    public virtual TlsAgreement CreateECDH();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX448 : object {
    protected BcTlsCrypto m_crypto;
    protected Byte[] m_privateKey;
    protected Byte[] m_peerPublicKey;
    public BcX448(BcTlsCrypto crypto);
    public virtual Byte[] GenerateEphemeral();
    public virtual void ReceivePeerValue(Byte[] peerValue);
    public virtual TlsSecret CalculateSecret();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX448Domain : object {
    protected BcTlsCrypto m_crypto;
    public BcX448Domain(BcTlsCrypto crypto);
    public virtual TlsAgreement CreateECDH();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.LegacyTls13Verifier : object {
    private int m_signatureScheme;
    private Tls13Verifier m_tls13Verifier;
    public LegacyTls13Verifier(int signatureScheme, Tls13Verifier tls13Verifier);
    public sealed virtual TlsStreamVerifier GetStreamVerifier(DigitallySigned digitallySigned);
    public sealed virtual bool VerifyRawSignature(DigitallySigned digitallySigned, Byte[] hash);
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.RsaUtilities : object {
    private static Byte[] RSAPSSParams_256_A;
    private static Byte[] RSAPSSParams_384_A;
    private static Byte[] RSAPSSParams_512_A;
    private static Byte[] RSAPSSParams_256_B;
    private static Byte[] RSAPSSParams_384_B;
    private static Byte[] RSAPSSParams_512_B;
    private static RsaUtilities();
    public static bool SupportsPkcs1(AlgorithmIdentifier pubKeyAlgID);
    public static bool SupportsPss_Pss(short signatureAlgorithm, AlgorithmIdentifier pubKeyAlgID);
    public static bool SupportsPss_Rsae(AlgorithmIdentifier pubKeyAlgID);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipher : object {
    public static int AEAD_CCM;
    public static int AEAD_CHACHA20_POLY1305;
    public static int AEAD_GCM;
    private static int NONCE_RFC5288;
    private static int NONCE_RFC7905;
    private static long SequenceNumberPlaceholder;
    protected TlsCryptoParameters m_cryptoParams;
    protected int m_keySize;
    protected int m_macSize;
    protected int m_fixed_iv_length;
    protected int m_record_iv_length;
    protected TlsAeadCipherImpl m_decryptCipher;
    protected TlsAeadCipherImpl m_encryptCipher;
    protected Byte[] m_decryptNonce;
    protected Byte[] m_encryptNonce;
    protected Byte[] m_decryptConnectionID;
    protected Byte[] m_encryptConnectionID;
    protected bool m_decryptUseInnerPlaintext;
    protected bool m_encryptUseInnerPlaintext;
    protected bool m_isTlsV13;
    protected int m_nonceMode;
    public bool UsesOpaqueRecordType { get; }
    public TlsAeadCipher(TlsCryptoParameters cryptoParams, TlsAeadCipherImpl encryptCipher, TlsAeadCipherImpl decryptCipher, int keySize, int macSize, int aeadType);
    public virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual int GetPlaintextDecodeLimit(int ciphertextLimit);
    public virtual int GetPlaintextEncodeLimit(int ciphertextLimit);
    public virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int plaintextOffset, int plaintextLength);
    public virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int ciphertextOffset, int ciphertextLength);
    public virtual void RekeyDecoder();
    public virtual void RekeyEncoder();
    public virtual bool get_UsesOpaqueRecordType();
    protected virtual Byte[] GetAdditionalData(long seqNo, short recordType, ProtocolVersion recordVersion, int ciphertextLength, int plaintextLength);
    protected virtual Byte[] GetAdditionalData(long seqNo, short recordType, ProtocolVersion recordVersion, int ciphertextLength, int plaintextLength, Byte[] connectionID);
    protected virtual void RekeyCipher(SecurityParameters securityParameters, TlsAeadCipherImpl cipher, Byte[] nonce, bool serverSecret);
    protected virtual void Setup13Cipher(TlsAeadCipherImpl cipher, Byte[] nonce, TlsSecret secret, int cryptoHashAlgorithm);
    private static int GetNonceMode(bool isTLSv13, int aeadType);
}
public interface Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl {
    public abstract virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public abstract virtual void Init(Byte[] nonce, int macSize, Byte[] additionalData);
    public abstract virtual int GetOutputSize(int inputLength);
    public abstract virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipher : object {
    protected TlsCryptoParameters m_cryptoParams;
    protected Byte[] m_randomData;
    protected bool m_encryptThenMac;
    protected bool m_useExplicitIV;
    protected bool m_acceptExtraPadding;
    protected bool m_useExtraPadding;
    protected TlsBlockCipherImpl m_decryptCipher;
    protected TlsBlockCipherImpl m_encryptCipher;
    protected TlsSuiteHmac m_readMac;
    protected TlsSuiteHmac m_writeMac;
    protected Byte[] m_decryptConnectionID;
    protected Byte[] m_encryptConnectionID;
    protected bool m_decryptUseInnerPlaintext;
    protected bool m_encryptUseInnerPlaintext;
    public bool UsesOpaqueRecordType { get; }
    public TlsBlockCipher(TlsCryptoParameters cryptoParams, TlsBlockCipherImpl encryptCipher, TlsBlockCipherImpl decryptCipher, TlsHmac clientMac, TlsHmac serverMac, int cipherKeySize);
    public virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual int GetPlaintextDecodeLimit(int ciphertextLimit);
    public virtual int GetPlaintextEncodeLimit(int ciphertextLimit);
    public virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int offset, int len);
    public virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int offset, int len);
    public virtual void RekeyDecoder();
    public virtual void RekeyEncoder();
    public virtual bool get_UsesOpaqueRecordType();
    protected virtual int CheckPaddingConstantTime(Byte[] buf, int off, int len, int blockSize, int macSize);
    protected virtual int ChooseExtraPadBlocks(int max);
    protected virtual int GetCiphertextLength(int blockSize, int macSize, int maxPadding, int plaintextLength);
    protected virtual int GetPlaintextLength(int blockSize, int macSize, int ciphertextLength);
}
public interface Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl {
    public abstract virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public abstract virtual void Init(Byte[] iv, int ivOff, int ivLen);
    public abstract virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
    public abstract virtual int GetBlockSize();
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.TlsImplUtilities : object {
    public static bool IsSsl(TlsCryptoParameters cryptoParams);
    public static bool IsTlsV10(ProtocolVersion version);
    public static bool IsTlsV10(TlsCryptoParameters cryptoParams);
    public static bool IsTlsV11(ProtocolVersion version);
    public static bool IsTlsV11(TlsCryptoParameters cryptoParams);
    public static bool IsTlsV12(ProtocolVersion version);
    public static bool IsTlsV12(TlsCryptoParameters cryptoParams);
    public static bool IsTlsV13(ProtocolVersion version);
    public static bool IsTlsV13(TlsCryptoParameters cryptoParams);
    public static Byte[] CalculateKeyBlock(TlsCryptoParameters cryptoParams, int length);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.TlsNullCipher : object {
    protected TlsCryptoParameters m_cryptoParams;
    protected TlsSuiteHmac m_readMac;
    protected TlsSuiteHmac m_writeMac;
    protected Byte[] m_decryptConnectionID;
    protected Byte[] m_encryptConnectionID;
    protected bool m_decryptUseInnerPlaintext;
    protected bool m_encryptUseInnerPlaintext;
    public bool UsesOpaqueRecordType { get; }
    public TlsNullCipher(TlsCryptoParameters cryptoParams, TlsHmac clientMac, TlsHmac serverMac);
    public virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual int GetPlaintextDecodeLimit(int ciphertextLimit);
    public virtual int GetPlaintextEncodeLimit(int ciphertextLimit);
    public virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int offset, int len);
    public virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int offset, int len);
    public virtual void RekeyDecoder();
    public virtual void RekeyEncoder();
    public virtual bool get_UsesOpaqueRecordType();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteHmac : object {
    private static long SequenceNumberPlaceholder;
    protected TlsCryptoParameters m_cryptoParams;
    protected TlsHmac m_mac;
    protected int m_digestBlockSize;
    protected int m_digestOverhead;
    protected int m_macSize;
    public int Size { get; }
    public TlsSuiteHmac(TlsCryptoParameters cryptoParams, TlsHmac mac);
    protected static int GetMacSize(TlsCryptoParameters cryptoParams, TlsMac mac);
    public virtual int get_Size();
    public virtual Byte[] CalculateMac(long seqNo, short type, Byte[] msg, int msgOff, int msgLen);
    public virtual Byte[] CalculateMac(long seqNo, short type, Byte[] connectionID, Byte[] msg, int msgOff, int msgLen);
    public virtual Byte[] CalculateMacConstantTime(long seqNo, short type, Byte[] msg, int msgOff, int msgLen, int fullLength, Byte[] dummyData);
    public virtual Byte[] CalculateMacConstantTime(long seqNo, short type, Byte[] connectionID, Byte[] msg, int msgOff, int msgLen, int fullLength, Byte[] dummyData);
    protected virtual int GetDigestBlockCount(int inputLength);
    protected virtual int GetHeaderLength(Byte[] connectionID);
    protected virtual Byte[] Truncate(Byte[] bs);
}
public interface Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac {
    public int Size { get; }
    public abstract virtual int get_Size();
    public abstract virtual Byte[] CalculateMac(long seqNo, short type, Byte[] message, int offset, int length);
    public abstract virtual Byte[] CalculateMacConstantTime(long seqNo, short type, Byte[] message, int offset, int length, int expectedLength, Byte[] randomData);
}
public class Org.BouncyCastle.Tls.Crypto.Srp6Group : object {
    private BigInteger n;
    private BigInteger g;
    public BigInteger G { get; }
    public BigInteger N { get; }
    public Srp6Group(BigInteger n, BigInteger g);
    public virtual BigInteger get_G();
    public virtual BigInteger get_N();
}
public class Org.BouncyCastle.Tls.Crypto.Srp6StandardGroups : object {
    private static string rfc5054_1024_N;
    private static string rfc5054_1024_g;
    public static Srp6Group rfc5054_1024;
    private static string rfc5054_1536_N;
    private static string rfc5054_1536_g;
    public static Srp6Group rfc5054_1536;
    private static string rfc5054_2048_N;
    private static string rfc5054_2048_g;
    public static Srp6Group rfc5054_2048;
    private static string rfc5054_3072_N;
    private static string rfc5054_3072_g;
    public static Srp6Group rfc5054_3072;
    private static string rfc5054_4096_N;
    private static string rfc5054_4096_g;
    public static Srp6Group rfc5054_4096;
    private static string rfc5054_6144_N;
    private static string rfc5054_6144_g;
    public static Srp6Group rfc5054_6144;
    private static string rfc5054_8192_N;
    private static string rfc5054_8192_g;
    public static Srp6Group rfc5054_8192;
    private static Srp6StandardGroups();
    private static BigInteger FromHex(string hex);
    private static Srp6Group FromNG(string hexN, string hexG);
}
public interface Org.BouncyCastle.Tls.Crypto.Tls13Verifier {
    public Stream Stream { get; }
    public abstract virtual Stream get_Stream();
    public abstract virtual bool VerifySignature(Byte[] signature);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsAgreement {
    public abstract virtual Byte[] GenerateEphemeral();
    public abstract virtual void ReceivePeerValue(Byte[] peerValue);
    public abstract virtual TlsSecret CalculateSecret();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsCertificate {
    public BigInteger SerialNumber { get; }
    public string SigAlgOid { get; }
    public abstract virtual TlsEncryptor CreateEncryptor(int tlsCertificateRole);
    public abstract virtual TlsVerifier CreateVerifier(short signatureAlgorithm);
    public abstract virtual Tls13Verifier CreateVerifier(int signatureScheme);
    public abstract virtual Byte[] GetEncoded();
    public abstract virtual Byte[] GetExtension(DerObjectIdentifier extensionOid);
    public abstract virtual BigInteger get_SerialNumber();
    public abstract virtual string get_SigAlgOid();
    public abstract virtual Asn1Encodable GetSigAlgParams();
    public abstract virtual short GetLegacySignatureAlgorithm();
    public abstract virtual bool SupportsSignatureAlgorithm(short signatureAlgorithm);
    public abstract virtual bool SupportsSignatureAlgorithmCA(short signatureAlgorithm);
    public abstract virtual TlsCertificate CheckUsageInRole(int tlsCertificateRole);
}
public abstract class Org.BouncyCastle.Tls.Crypto.TlsCertificateRole : object {
    public static int DH;
    public static int ECDH;
    public static int RsaEncryption;
    public static int Sm2Encryption;
}
public interface Org.BouncyCastle.Tls.Crypto.TlsCipher {
    public bool UsesOpaqueRecordType { get; }
    public abstract virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public abstract virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public abstract virtual int GetPlaintextLimit(int ciphertextLimit);
    public abstract virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int offset, int len);
    public abstract virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int offset, int len);
    public abstract virtual void RekeyDecoder();
    public abstract virtual void RekeyEncoder();
    public abstract virtual bool get_UsesOpaqueRecordType();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsCipherExt {
    public abstract virtual int GetPlaintextDecodeLimit(int ciphertextLimit);
    public abstract virtual int GetPlaintextEncodeLimit(int ciphertextLimit);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsCrypto {
    public SecureRandom SecureRandom { get; }
    public abstract virtual bool HasAnyStreamVerifiers(IList`1<SignatureAndHashAlgorithm> signatureAndHashAlgorithms);
    public abstract virtual bool HasAnyStreamVerifiersLegacy(Int16[] clientCertificateTypes);
    public abstract virtual bool HasCryptoHashAlgorithm(int cryptoHashAlgorithm);
    public abstract virtual bool HasCryptoSignatureAlgorithm(int cryptoSignatureAlgorithm);
    public abstract virtual bool HasDHAgreement();
    public abstract virtual bool HasECDHAgreement();
    public abstract virtual bool HasEncryptionAlgorithm(int encryptionAlgorithm);
    public abstract virtual bool HasHkdfAlgorithm(int cryptoHashAlgorithm);
    public abstract virtual bool HasMacAlgorithm(int macAlgorithm);
    public abstract virtual bool HasNamedGroup(int namedGroup);
    public abstract virtual bool HasRsaEncryption();
    public abstract virtual bool HasSignatureAlgorithm(short signatureAlgorithm);
    public abstract virtual bool HasSignatureAndHashAlgorithm(SignatureAndHashAlgorithm sigAndHashAlgorithm);
    public abstract virtual bool HasSignatureScheme(int signatureScheme);
    public abstract virtual bool HasSrpAuthentication();
    public abstract virtual TlsSecret CreateSecret(Byte[] data);
    public abstract virtual TlsSecret GenerateRsaPreMasterSecret(ProtocolVersion clientVersion);
    public abstract virtual SecureRandom get_SecureRandom();
    public abstract virtual TlsCertificate CreateCertificate(Byte[] encoding);
    public abstract virtual TlsCertificate CreateCertificate(short type, Byte[] encoding);
    public abstract virtual TlsCipher CreateCipher(TlsCryptoParameters cryptoParams, int encryptionAlgorithm, int macAlgorithm);
    public abstract virtual TlsDHDomain CreateDHDomain(TlsDHConfig dhConfig);
    public abstract virtual TlsECDomain CreateECDomain(TlsECConfig ecConfig);
    public abstract virtual TlsSecret AdoptSecret(TlsSecret secret);
    public abstract virtual TlsHash CreateHash(int cryptoHashAlgorithm);
    public abstract virtual TlsHmac CreateHmac(int macAlgorithm);
    public abstract virtual TlsHmac CreateHmacForHash(int cryptoHashAlgorithm);
    public abstract virtual TlsNonceGenerator CreateNonceGenerator(Byte[] additionalSeedMaterial);
    public abstract virtual TlsSrp6Client CreateSrp6Client(TlsSrpConfig srpConfig);
    public abstract virtual TlsSrp6Server CreateSrp6Server(TlsSrpConfig srpConfig, BigInteger srpVerifier);
    public abstract virtual TlsSrp6VerifierGenerator CreateSrp6VerifierGenerator(TlsSrpConfig srpConfig);
    public abstract virtual TlsSecret HkdfInit(int cryptoHashAlgorithm);
}
public class Org.BouncyCastle.Tls.Crypto.TlsCryptoException : TlsException {
    public TlsCryptoException(string message);
    public TlsCryptoException(string message, Exception innerException);
    protected TlsCryptoException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters : object {
    private TlsContext m_context;
    public SecurityParameters SecurityParameters { get; }
    public ProtocolVersion ClientVersion { get; }
    public ProtocolVersion RsaPreMasterSecretVersion { get; }
    public ProtocolVersion ServerVersion { get; }
    public bool IsServer { get; }
    public TlsNonceGenerator NonceGenerator { get; }
    public TlsCryptoParameters(TlsContext context);
    public SecurityParameters get_SecurityParameters();
    public ProtocolVersion get_ClientVersion();
    public ProtocolVersion get_RsaPreMasterSecretVersion();
    public virtual ProtocolVersion get_ServerVersion();
    public bool get_IsServer();
    public TlsNonceGenerator get_NonceGenerator();
}
public abstract class Org.BouncyCastle.Tls.Crypto.TlsCryptoUtilities : object {
    private static Byte[] Tls13Prefix;
    private static TlsCryptoUtilities();
    public static int GetHash(short hashAlgorithm);
    public static int GetHashForHmac(int macAlgorithm);
    public static int GetHashForPrf(int prfAlgorithm);
    public static int GetHashInternalSize(int cryptoHashAlgorithm);
    public static int GetHashOutputSize(int cryptoHashAlgorithm);
    public static DerObjectIdentifier GetOidForHash(int cryptoHashAlgorithm);
    public static int GetSignature(short signatureAlgorithm);
    public static TlsSecret HkdfExpandLabel(TlsSecret secret, int cryptoHashAlgorithm, string label, Byte[] context, int length);
}
public class Org.BouncyCastle.Tls.Crypto.TlsDecodeResult : object {
    public Byte[] buf;
    public int off;
    public int len;
    public short contentType;
    public TlsDecodeResult(Byte[] buf, int off, int len, short contentType);
}
public class Org.BouncyCastle.Tls.Crypto.TlsDHConfig : object {
    protected DHGroup m_explicitGroup;
    protected int m_namedGroup;
    protected bool m_padded;
    public DHGroup ExplicitGroup { get; }
    public int NamedGroup { get; }
    public bool IsPadded { get; }
    public TlsDHConfig(DHGroup explicitGroup);
    public TlsDHConfig(int namedGroup, bool padded);
    public virtual DHGroup get_ExplicitGroup();
    public virtual int get_NamedGroup();
    public virtual bool get_IsPadded();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsDHDomain {
    public abstract virtual TlsAgreement CreateDH();
}
public class Org.BouncyCastle.Tls.Crypto.TlsECConfig : object {
    protected int m_namedGroup;
    public int NamedGroup { get; }
    public TlsECConfig(int namedGroup);
    public virtual int get_NamedGroup();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsECDomain {
    public abstract virtual TlsAgreement CreateECDH();
}
public class Org.BouncyCastle.Tls.Crypto.TlsEncodeResult : object {
    public Byte[] buf;
    public int off;
    public int len;
    public short recordType;
    public TlsEncodeResult(Byte[] buf, int off, int len, short recordType);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsEncryptor {
    public abstract virtual Byte[] Encrypt(Byte[] input, int inOff, int length);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsHash {
    public abstract virtual void Update(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] CalculateHash();
    public abstract virtual TlsHash CloneHash();
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Tls.Crypto.TlsHashSink : BaseOutputStream {
    private TlsHash m_hash;
    public TlsHash Hash { get; }
    public TlsHashSink(TlsHash hash);
    public virtual TlsHash get_Hash();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsHmac {
    public int InternalBlockSize { get; }
    public abstract virtual int get_InternalBlockSize();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsMac {
    public int MacLength { get; }
    public abstract virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public abstract virtual void Update(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] CalculateMac();
    public abstract virtual void CalculateMac(Byte[] output, int outOff);
    public abstract virtual int get_MacLength();
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Tls.Crypto.TlsMacSink : BaseOutputStream {
    private TlsMac m_mac;
    public TlsMac Mac { get; }
    public TlsMacSink(TlsMac mac);
    public virtual TlsMac get_Mac();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsNonceGenerator {
    public abstract virtual Byte[] GenerateNonce(int size);
}
public class Org.BouncyCastle.Tls.Crypto.TlsNullNullCipher : object {
    public static TlsNullNullCipher Instance;
    public bool UsesOpaqueRecordType { get; }
    private static TlsNullNullCipher();
    public sealed virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public sealed virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public sealed virtual int GetPlaintextLimit(int ciphertextLimit);
    public sealed virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int offset, int len);
    public sealed virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int offset, int len);
    public sealed virtual void RekeyDecoder();
    public sealed virtual void RekeyEncoder();
    public sealed virtual bool get_UsesOpaqueRecordType();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSecret {
    public int Length { get; }
    public abstract virtual Byte[] CalculateHmac(int cryptoHashAlgorithm, Byte[] buf, int off, int len);
    public abstract virtual TlsSecret DeriveUsingPrf(int prfAlgorithm, string label, Byte[] seed, int length);
    public abstract virtual void Destroy();
    public abstract virtual Byte[] Encrypt(TlsEncryptor encryptor);
    public abstract virtual Byte[] Extract();
    public abstract virtual TlsSecret HkdfExpand(int cryptoHashAlgorithm, Byte[] info, int length);
    public abstract virtual TlsSecret HkdfExtract(int cryptoHashAlgorithm, TlsSecret ikm);
    public abstract virtual bool IsAlive();
    public abstract virtual int get_Length();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSigner {
    public abstract virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
    public abstract virtual TlsStreamSigner GetStreamSigner(SignatureAndHashAlgorithm algorithm);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSrp6Client {
    public abstract virtual BigInteger CalculateSecret(BigInteger serverB);
    public abstract virtual BigInteger GenerateClientCredentials(Byte[] salt, Byte[] identity, Byte[] password);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSrp6Server {
    public abstract virtual BigInteger GenerateServerCredentials();
    public abstract virtual BigInteger CalculateSecret(BigInteger clientA);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSrp6VerifierGenerator {
    public abstract virtual BigInteger GenerateVerifier(Byte[] salt, Byte[] identity, Byte[] password);
}
public class Org.BouncyCastle.Tls.Crypto.TlsSrpConfig : object {
    protected BigInteger[] m_explicitNG;
    public BigInteger[] GetExplicitNG();
    public void SetExplicitNG(BigInteger[] explicitNG);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsStreamSigner {
    public Stream Stream { get; }
    public abstract virtual Stream get_Stream();
    public abstract virtual Byte[] GetSignature();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsStreamVerifier {
    public Stream Stream { get; }
    public abstract virtual Stream get_Stream();
    public abstract virtual bool IsVerified();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsVerifier {
    public abstract virtual TlsStreamVerifier GetStreamVerifier(DigitallySigned digitallySigned);
    public abstract virtual bool VerifyRawSignature(DigitallySigned digitallySigned, Byte[] hash);
}
public interface Org.BouncyCastle.Tls.DatagramReceiver {
    public abstract virtual int GetReceiveLimit();
    public abstract virtual int Receive(Byte[] buf, int off, int len, int waitMillis);
}
public interface Org.BouncyCastle.Tls.DatagramSender {
    public abstract virtual int GetSendLimit();
    public abstract virtual void Send(Byte[] buf, int off, int len);
}
public interface Org.BouncyCastle.Tls.DatagramTransport {
}
public abstract class Org.BouncyCastle.Tls.DefaultTlsClient : AbstractTlsClient {
    private static Int32[] DefaultCipherSuites;
    public DefaultTlsClient(TlsCrypto crypto);
    private static DefaultTlsClient();
    protected virtual Int32[] GetSupportedCipherSuites();
}
public class Org.BouncyCastle.Tls.DefaultTlsCredentialedSigner : object {
    protected TlsCryptoParameters m_cryptoParams;
    protected Certificate m_certificate;
    protected SignatureAndHashAlgorithm m_signatureAndHashAlgorithm;
    protected TlsSigner m_signer;
    public Certificate Certificate { get; }
    public SignatureAndHashAlgorithm SignatureAndHashAlgorithm { get; }
    public DefaultTlsCredentialedSigner(TlsCryptoParameters cryptoParams, TlsSigner signer, Certificate certificate, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    public virtual Certificate get_Certificate();
    public virtual Byte[] GenerateRawSignature(Byte[] hash);
    public virtual SignatureAndHashAlgorithm get_SignatureAndHashAlgorithm();
    public virtual TlsStreamSigner GetStreamSigner();
    protected virtual SignatureAndHashAlgorithm GetEffectiveAlgorithm();
}
public class Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier : object {
    public static int DefaultMinimumPrimeBits;
    private static List`1<DHGroup> DefaultGroups;
    protected IList`1<DHGroup> m_groups;
    protected int m_minimumPrimeBits;
    public int MinimumPrimeBits { get; }
    private static DefaultTlsDHGroupVerifier();
    public DefaultTlsDHGroupVerifier(int minimumPrimeBits);
    public DefaultTlsDHGroupVerifier(IList`1<DHGroup> groups, int minimumPrimeBits);
    private static void AddDefaultGroup(DHGroup dhGroup);
    public virtual bool Accept(DHGroup dhGroup);
    public virtual int get_MinimumPrimeBits();
    protected virtual bool AreGroupsEqual(DHGroup a, DHGroup b);
    protected virtual bool AreParametersEqual(BigInteger a, BigInteger b);
    protected virtual bool CheckGroup(DHGroup dhGroup);
    protected virtual bool CheckMinimumPrimeBits(DHGroup dhGroup);
}
public class Org.BouncyCastle.Tls.DefaultTlsHeartbeat : object {
    private int idleMillis;
    private int timeoutMillis;
    private UInt32 counter;
    public int IdleMillis { get; }
    public int TimeoutMillis { get; }
    public DefaultTlsHeartbeat(int idleMillis, int timeoutMillis);
    public virtual Byte[] GeneratePayload();
    public virtual int get_IdleMillis();
    public virtual int get_TimeoutMillis();
}
public class Org.BouncyCastle.Tls.DefaultTlsKeyExchangeFactory : AbstractTlsKeyExchangeFactory {
    public virtual TlsKeyExchange CreateDHKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateDHanonKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreateDHanonKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public virtual TlsKeyExchange CreateDheKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreateDheKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public virtual TlsKeyExchange CreateECDHKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateECDHanonKeyExchangeClient(int keyExchange);
    public virtual TlsKeyExchange CreateECDHanonKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreateECDheKeyExchangeClient(int keyExchange);
    public virtual TlsKeyExchange CreateECDheKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreatePskKeyExchangeClient(int keyExchange, TlsPskIdentity pskIdentity, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreatePskKeyExchangeServer(int keyExchange, TlsPskIdentityManager pskIdentityManager, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreateRsaKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateSrpKeyExchangeClient(int keyExchange, TlsSrpIdentity srpIdentity, TlsSrpConfigVerifier srpConfigVerifier);
    public virtual TlsKeyExchange CreateSrpKeyExchangeServer(int keyExchange, TlsSrpLoginParameters loginParameters);
}
public abstract class Org.BouncyCastle.Tls.DefaultTlsServer : AbstractTlsServer {
    private static Int32[] DefaultCipherSuites;
    public DefaultTlsServer(TlsCrypto crypto);
    private static DefaultTlsServer();
    protected virtual TlsCredentialedSigner GetDsaSignerCredentials();
    protected virtual TlsCredentialedSigner GetECDsaSignerCredentials();
    protected virtual TlsCredentialedDecryptor GetRsaEncryptionCredentials();
    protected virtual TlsCredentialedSigner GetRsaSignerCredentials();
    protected virtual Int32[] GetSupportedCipherSuites();
    public virtual TlsCredentials GetCredentials();
}
public class Org.BouncyCastle.Tls.DefaultTlsSrpConfigVerifier : object {
    private static List`1<Srp6Group> DefaultGroups;
    protected IList`1<Srp6Group> m_groups;
    private static DefaultTlsSrpConfigVerifier();
    public DefaultTlsSrpConfigVerifier(IList`1<Srp6Group> groups);
    public virtual bool Accept(TlsSrpConfig srpConfig);
    protected virtual bool AreGroupsEqual(TlsSrpConfig a, Srp6Group b);
    protected virtual bool AreParametersEqual(BigInteger a, BigInteger b);
}
internal class Org.BouncyCastle.Tls.DeferredHash : object {
    private static int BufferingHashLimit;
    private TlsContext m_context;
    private DigestInputBuffer m_buf;
    private IDictionary`2<int, TlsHash> m_hashes;
    private bool m_forceBuffering;
    private bool m_sealed;
    internal DeferredHash(TlsContext context);
    public sealed virtual void CopyBufferTo(Stream output);
    public sealed virtual void ForceBuffering();
    public sealed virtual void NotifyPrfDetermined();
    public sealed virtual void TrackHashAlgorithm(int cryptoHashAlgorithm);
    public sealed virtual void SealHashAlgorithms();
    public sealed virtual void StopTracking();
    public sealed virtual TlsHash ForkPrfHash();
    public sealed virtual Byte[] GetFinalHash(int cryptoHashAlgorithm);
    public sealed virtual void Update(Byte[] input, int inOff, int len);
    public sealed virtual Byte[] CalculateHash();
    public sealed virtual TlsHash CloneHash();
    public sealed virtual void Reset();
    private void CheckStopBuffering();
    private void CheckTrackingHash(int cryptoHashAlgorithm);
    private TlsHash CloneHash(int cryptoHashAlgorithm);
    private void CloneHash(IDictionary`2<int, TlsHash> newHashes, int cryptoHashAlgorithm);
}
internal class Org.BouncyCastle.Tls.DigestInputBuffer : MemoryStream {
    internal void UpdateDigest(TlsHash hash);
    internal void CopyInputTo(Stream output);
}
public class Org.BouncyCastle.Tls.DigitallySigned : object {
    private SignatureAndHashAlgorithm m_algorithm;
    private Byte[] m_signature;
    public SignatureAndHashAlgorithm Algorithm { get; }
    public Byte[] Signature { get; }
    public DigitallySigned(SignatureAndHashAlgorithm algorithm, Byte[] signature);
    public SignatureAndHashAlgorithm get_Algorithm();
    public Byte[] get_Signature();
    public void Encode(Stream output);
    public static DigitallySigned Parse(TlsContext context, Stream input);
}
public class Org.BouncyCastle.Tls.DtlsClientProtocol : DtlsProtocol {
    public virtual DtlsTransport Connect(TlsClient client, DatagramTransport transport);
    internal virtual void AbortClientHandshake(ClientHandshakeState state, DtlsRecordLayer recordLayer, short alertDescription);
    internal virtual DtlsTransport ClientHandshake(ClientHandshakeState state, DtlsRecordLayer recordLayer);
    protected virtual Byte[] GenerateCertificateVerify(ClientHandshakeState state, DigitallySigned certificateVerify);
    protected virtual Byte[] GenerateClientHello(ClientHandshakeState state);
    protected virtual Byte[] GenerateClientKeyExchange(ClientHandshakeState state);
    protected virtual void InvalidateSession(ClientHandshakeState state);
    protected virtual void ProcessCertificateRequest(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessCertificateStatus(ClientHandshakeState state, Byte[] body);
    protected virtual Byte[] ProcessHelloVerifyRequest(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessNewSessionTicket(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerCertificate(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerHello(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerKeyExchange(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerSupplementalData(ClientHandshakeState state, Byte[] body);
    protected virtual void ReportServerVersion(ClientHandshakeState state, ProtocolVersion server_version);
    protected static Byte[] PatchClientHelloWithCookie(Byte[] clientHelloBody, Byte[] cookie);
}
internal class Org.BouncyCastle.Tls.DtlsEpoch : object {
    private DtlsReplayWindow m_replayWindow;
    private int m_epoch;
    private TlsCipher m_cipher;
    private int m_recordHeaderLengthRead;
    private int m_recordHeaderLengthWrite;
    private long m_sequenceNumber;
    internal TlsCipher Cipher { get; }
    internal int Epoch { get; }
    internal int RecordHeaderLengthRead { get; }
    internal int RecordHeaderLengthWrite { get; }
    internal DtlsReplayWindow ReplayWindow { get; }
    internal long SequenceNumber { get; internal set; }
    internal DtlsEpoch(int epoch, TlsCipher cipher, int recordHeaderLengthRead, int recordHeaderLengthWrite);
    internal long AllocateSequenceNumber();
    internal TlsCipher get_Cipher();
    internal int get_Epoch();
    internal int get_RecordHeaderLengthRead();
    internal int get_RecordHeaderLengthWrite();
    internal DtlsReplayWindow get_ReplayWindow();
    internal long get_SequenceNumber();
    internal void set_SequenceNumber(long value);
}
internal interface Org.BouncyCastle.Tls.DtlsHandshakeRetransmit {
    public abstract virtual void ReceivedHandshakeRecord(int epoch, Byte[] buf, int off, int len);
}
public abstract class Org.BouncyCastle.Tls.DtlsProtocol : object {
    internal virtual void ProcessFinished(Byte[] body, Byte[] expected_verify_data);
    internal static void ApplyMaxFragmentLengthExtension(DtlsRecordLayer recordLayer, short maxFragmentLength);
    internal static short EvaluateMaxFragmentLengthExtension(bool resumedSession, IDictionary`2<int, Byte[]> clientExtensions, IDictionary`2<int, Byte[]> serverExtensions, short alertDescription);
    internal static Byte[] GenerateCertificate(TlsContext context, Certificate certificate, Stream endPointHash);
    internal static Byte[] GenerateSupplementalData(IList`1<SupplementalDataEntry> supplementalData);
    internal static void SendCertificateMessage(TlsContext context, DtlsReliableHandshake handshake, Certificate certificate, Stream endPointHash);
    internal static int ValidateSelectedCipherSuite(int selectedCipherSuite, short alertDescription);
}
internal class Org.BouncyCastle.Tls.DtlsReassembler : object {
    private short m_msg_type;
    private Byte[] m_body;
    private List`1<Range> m_missing;
    internal short MsgType { get; }
    internal DtlsReassembler(short msg_type, int length);
    internal short get_MsgType();
    internal Byte[] GetBodyIfComplete();
    internal void ContributeFragment(short msg_type, int length, Byte[] buf, int off, int fragment_offset, int fragment_length);
    internal void Reset();
}
public class Org.BouncyCastle.Tls.DtlsRecordCallback : MulticastDelegate {
    public DtlsRecordCallback(object object, IntPtr method);
    public virtual void Invoke(DtlsRecordFlags flags);
    public virtual IAsyncResult BeginInvoke(DtlsRecordFlags flags, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum Org.BouncyCastle.Tls.DtlsRecordFlags : Enum {
    public int value__;
    public static DtlsRecordFlags None;
    public static DtlsRecordFlags IsNewest;
    public static DtlsRecordFlags UsesConnectionID;
}
internal class Org.BouncyCastle.Tls.DtlsRecordLayer : object {
    private static int RECORD_HEADER_LENGTH;
    private static int MAX_FRAGMENT_LENGTH;
    private static long TCP_MSL;
    private static long RETRANSMIT_TIMEOUT;
    private TlsContext m_context;
    private TlsPeer m_peer;
    private DatagramTransport m_transport;
    private ByteQueue m_recordQueue;
    private object m_writeLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_closed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_failed;
    private ProtocolVersion modreq(System.Runtime.CompilerServices.IsVolatile) m_readVersion;
    private ProtocolVersion modreq(System.Runtime.CompilerServices.IsVolatile) m_writeVersion;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_inConnection;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_inHandshake;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_plaintextLimit;
    private DtlsEpoch m_currentEpoch;
    private DtlsEpoch m_pendingEpoch;
    private DtlsEpoch m_readEpoch;
    private DtlsEpoch m_writeEpoch;
    private DtlsHandshakeRetransmit m_retransmit;
    private DtlsEpoch m_retransmitEpoch;
    private Timeout m_retransmitTimeout;
    private TlsHeartbeat m_heartbeat;
    private bool m_heartBeatResponder;
    private HeartbeatMessage m_heartbeatInFlight;
    private Timeout m_heartbeatTimeout;
    private int m_heartbeatResendMillis;
    private Timeout m_heartbeatResendTimeout;
    internal bool IsClosed { get; }
    internal int ReadEpoch { get; }
    internal ProtocolVersion ReadVersion { get; internal set; }
    internal DtlsRecordLayer(TlsContext context, TlsPeer peer, DatagramTransport transport);
    internal static Byte[] ReceiveClientHelloRecord(Byte[] data, int dataOff, int dataLen);
    internal static void SendHelloVerifyRequestRecord(DatagramSender sender, long recordSeq, Byte[] message);
    private static void SendDatagram(DatagramSender sender, Byte[] buf, int off, int len);
    internal virtual bool get_IsClosed();
    internal virtual void ResetAfterHelloVerifyRequestServer(long recordSeq);
    internal virtual void SetPlaintextLimit(int plaintextLimit);
    internal virtual int get_ReadEpoch();
    internal virtual ProtocolVersion get_ReadVersion();
    internal virtual void set_ReadVersion(ProtocolVersion value);
    internal virtual void SetWriteVersion(ProtocolVersion writeVersion);
    internal virtual void InitPendingEpoch(TlsCipher pendingCipher);
    internal virtual void HandshakeSuccessful(DtlsHandshakeRetransmit retransmit);
    internal virtual void InitHeartbeat(TlsHeartbeat heartbeat, bool heartbeatResponder);
    internal virtual void ResetWriteEpoch();
    public virtual int GetReceiveLimit();
    public virtual int GetSendLimit();
    public virtual int Receive(Byte[] buf, int off, int len, int waitMillis);
    internal int Receive(Byte[] buf, int off, int len, int waitMillis, DtlsRecordCallback recordCallback);
    internal int ReceivePending(Byte[] buf, int off, int len, DtlsRecordCallback recordCallback);
    public virtual void Send(Byte[] buf, int off, int len);
    public virtual void Close();
    internal virtual void Fail(short alertDescription);
    internal virtual void Failed();
    internal virtual void Warn(short alertDescription, string message);
    private void CloseTransport();
    private void RaiseAlert(short alertLevel, short alertDescription, string message, Exception cause);
    private int ReceiveDatagram(Byte[] buf, int off, int len, int waitMillis);
    private int ProcessRecord(int received, Byte[] record, Byte[] buf, int off, int len, DtlsRecordCallback recordCallback);
    private int ReceivePendingRecord(Byte[] buf, int off, int len);
    private int ReceiveRecord(Byte[] buf, int off, int len, int waitMillis);
    private void ResetHeartbeat();
    private void SendHeartbeatMessage(HeartbeatMessage heartbeatMessage);
    private void SendRecord(short contentType, Byte[] buf, int off, int len);
    private static long GetMacSequenceNumber(int epoch, long sequence_number);
}
internal class Org.BouncyCastle.Tls.DtlsReliableHandshake : object {
    private static int MAX_RECEIVE_AHEAD;
    private static int MESSAGE_HEADER_LENGTH;
    private static int MAX_RESEND_MILLIS;
    private DtlsRecordLayer m_recordLayer;
    private Timeout m_handshakeTimeout;
    private TlsHandshakeHash m_handshakeHash;
    private IDictionary`2<int, DtlsReassembler> m_currentInboundFlight;
    private IDictionary`2<int, DtlsReassembler> m_previousInboundFlight;
    private IList`1<Message> m_outboundFlight;
    private int m_initialResendMillis;
    private int m_resendMillis;
    private Timeout m_resendTimeout;
    private int m_next_send_seq;
    private int m_next_receive_seq;
    internal TlsHandshakeHash HandshakeHash { get; }
    internal DtlsReliableHandshake(TlsContext context, DtlsRecordLayer transport, int timeoutMillis, int initialResendMillis, DtlsRequest request);
    internal static DtlsRequest ReadClientRequest(Byte[] data, int dataOff, int dataLen, Stream dtlsOutput);
    internal static void SendHelloVerifyRequest(DatagramSender sender, long recordSeq, Byte[] cookie);
    internal void ResetAfterHelloVerifyRequestClient();
    internal TlsHandshakeHash get_HandshakeHash();
    internal void PrepareToFinish();
    internal void SendMessage(short msg_type, Byte[] body);
    internal Message ReceiveMessage();
    internal Byte[] ReceiveMessageBody(short msg_type);
    internal Message ReceiveMessageDelayedDigest(short msg_type);
    internal void UpdateHandshakeMessagesDigest(Message message);
    internal void Finish();
    internal static int BackOff(int timeoutMillis);
    private void CheckInboundFlight();
    private Message GetPendingMessage();
    private Message ImplReceiveMessage();
    private void PrepareInboundFlight(IDictionary`2<int, DtlsReassembler> nextFlight);
    private void ProcessRecord(int windowSize, int epoch, Byte[] buf, int off, int len);
    private void ResendOutboundFlight();
    private void WriteMessage(Message message);
    private void WriteHandshakeFragment(Message message, int fragment_offset, int fragment_length);
    private static bool CheckAll(IDictionary`2<int, DtlsReassembler> inboundFlight);
    private static void ResetAll(IDictionary`2<int, DtlsReassembler> inboundFlight);
}
internal class Org.BouncyCastle.Tls.DtlsReplayWindow : object {
    private static long ValidSeqMask;
    private static long WindowSize;
    private long m_latestConfirmedSeq;
    private ulong m_bitmap;
    internal bool ShouldDiscard(long seq);
    internal void ReportAuthenticated(long seq, Boolean& isLatestConfirmed);
    internal void Reset(long seq);
}
public class Org.BouncyCastle.Tls.DtlsRequest : object {
    private long m_recordSeq;
    private Byte[] m_message;
    private ClientHello m_clientHello;
    internal ClientHello ClientHello { get; }
    internal Byte[] Message { get; }
    internal int MessageSeq { get; }
    internal long RecordSeq { get; }
    internal DtlsRequest(long recordSeq, Byte[] message, ClientHello clientHello);
    internal ClientHello get_ClientHello();
    internal Byte[] get_Message();
    internal int get_MessageSeq();
    internal long get_RecordSeq();
}
public class Org.BouncyCastle.Tls.DtlsServerProtocol : DtlsProtocol {
    protected bool m_verifyRequests;
    public bool VerifyRequests { get; public set; }
    public virtual bool get_VerifyRequests();
    public virtual void set_VerifyRequests(bool value);
    public virtual DtlsTransport Accept(TlsServer server, DatagramTransport transport);
    public virtual DtlsTransport Accept(TlsServer server, DatagramTransport transport, DtlsRequest request);
    internal virtual void AbortServerHandshake(ServerHandshakeState state, DtlsRecordLayer recordLayer, short alertDescription);
    internal virtual DtlsTransport ServerHandshake(ServerHandshakeState state, DtlsRecordLayer recordLayer, DtlsRequest request);
    protected virtual Byte[] GenerateCertificateRequest(ServerHandshakeState state, CertificateRequest certificateRequest);
    protected virtual Byte[] GenerateCertificateStatus(ServerHandshakeState state, CertificateStatus certificateStatus);
    protected virtual Byte[] GenerateNewSessionTicket(ServerHandshakeState state, NewSessionTicket newSessionTicket);
    internal virtual Byte[] GenerateServerHello(ServerHandshakeState state, DtlsRecordLayer recordLayer);
    protected virtual void InvalidateSession(ServerHandshakeState state);
    protected virtual void NotifyClientCertificate(ServerHandshakeState state, Certificate clientCertificate);
    protected virtual void ProcessClientCertificate(ServerHandshakeState state, Byte[] body);
    protected virtual void ProcessCertificateVerify(ServerHandshakeState state, Byte[] body, TlsHandshakeHash handshakeHash);
    protected virtual void ProcessClientHello(ServerHandshakeState state, Byte[] body);
    protected virtual void ProcessClientHello(ServerHandshakeState state, ClientHello clientHello);
    protected virtual void ProcessClientKeyExchange(ServerHandshakeState state, Byte[] body);
    protected virtual void ProcessClientSupplementalData(ServerHandshakeState state, Byte[] body);
    protected virtual bool ExpectCertificateVerifyMessage(ServerHandshakeState state);
}
public class Org.BouncyCastle.Tls.DtlsTransport : object {
    private DtlsRecordLayer m_recordLayer;
    private bool m_ignoreCorruptRecords;
    internal DtlsTransport(DtlsRecordLayer recordLayer, bool ignoreCorruptRecords);
    public virtual int GetReceiveLimit();
    public virtual int GetSendLimit();
    public virtual int Receive(Byte[] buf, int off, int len, int waitMillis);
    public virtual int Receive(Byte[] buf, int off, int len, int waitMillis, DtlsRecordCallback recordCallback);
    public virtual int ReceivePending(Byte[] buf, int off, int len, DtlsRecordCallback recordCallback);
    public virtual void Send(Byte[] buf, int off, int len);
    public virtual void Close();
}
public class Org.BouncyCastle.Tls.DtlsVerifier : object {
    private TlsMac m_cookieMac;
    private TlsMacSink m_cookieMacSink;
    public DtlsVerifier(TlsCrypto crypto);
    private static TlsMac CreateCookieMac(TlsCrypto crypto);
    public virtual DtlsRequest VerifyRequest(Byte[] clientID, Byte[] data, int dataOff, int dataLen, DatagramSender sender);
}
public abstract class Org.BouncyCastle.Tls.ECCurveType : object {
    public static short explicit_prime;
    public static short explicit_char2;
    public static short named_curve;
}
public abstract class Org.BouncyCastle.Tls.ECPointFormat : object {
    public static short uncompressed;
    public static short ansiX962_compressed_prime;
    public static short ansiX962_compressed_char2;
}
public abstract class Org.BouncyCastle.Tls.EncryptionAlgorithm : object {
    public static int NULL;
    public static int RC4_40;
    public static int RC4_128;
    public static int RC2_CBC_40;
    public static int IDEA_CBC;
    public static int DES40_CBC;
    public static int DES_CBC;
    public static int cls_3DES_EDE_CBC;
    public static int AES_128_CBC;
    public static int AES_256_CBC;
    public static int AES_128_GCM;
    public static int AES_256_GCM;
    public static int CAMELLIA_128_CBC;
    public static int CAMELLIA_256_CBC;
    public static int SEED_CBC;
    public static int AES_128_CCM;
    public static int AES_128_CCM_8;
    public static int AES_256_CCM;
    public static int AES_256_CCM_8;
    public static int CAMELLIA_128_GCM;
    public static int CAMELLIA_256_GCM;
    public static int CHACHA20_POLY1305;
    public static int ARIA_128_CBC;
    public static int ARIA_256_CBC;
    public static int ARIA_128_GCM;
    public static int ARIA_256_GCM;
    public static int SM4_CCM;
    public static int SM4_GCM;
    public static int SM4_CBC;
}
public abstract class Org.BouncyCastle.Tls.ExporterLabel : object {
    public static string client_finished;
    public static string server_finished;
    public static string master_secret;
    public static string key_expansion;
    public static string client_EAP_encryption;
    public static string ttls_keying_material;
    public static string ttls_challenge;
    public static string dtls_srtp;
    public static string extended_master_secret;
    public static string token_binding;
}
public abstract class Org.BouncyCastle.Tls.ExtensionType : object {
    public static int server_name;
    public static int max_fragment_length;
    public static int client_certificate_url;
    public static int trusted_ca_keys;
    public static int truncated_hmac;
    public static int status_request;
    public static int user_mapping;
    public static int client_authz;
    public static int server_authz;
    public static int cert_type;
    public static int supported_groups;
    public static int ec_point_formats;
    public static int srp;
    public static int signature_algorithms;
    public static int use_srtp;
    public static int heartbeat;
    public static int application_layer_protocol_negotiation;
    public static int status_request_v2;
    public static int signed_certificate_timestamp;
    public static int client_certificate_type;
    public static int server_certificate_type;
    public static int padding;
    public static int encrypt_then_mac;
    public static int extended_master_secret;
    public static int token_binding;
    public static int cached_info;
    public static int compress_certificate;
    public static int record_size_limit;
    public static int session_ticket;
    public static int pre_shared_key;
    public static int early_data;
    public static int supported_versions;
    public static int cookie;
    public static int psk_key_exchange_modes;
    public static int certificate_authorities;
    public static int oid_filters;
    public static int post_handshake_auth;
    public static int signature_algorithms_cert;
    public static int key_share;
    public static int connection_id;
    public static int renegotiation_info;
    public static string GetName(int extensionType);
    public static string GetText(int extensionType);
    public static bool IsRecognized(int extensionType);
}
public class Org.BouncyCastle.Tls.HandshakeMessageInput : MemoryStream {
    private int m_offset;
    internal HandshakeMessageInput(Byte[] buf, int offset, int length);
    public void UpdateHash(TlsHash hash);
    internal void UpdateHashPrefix(TlsHash hash, int bindersSize);
    internal void UpdateHashSuffix(TlsHash hash, int bindersSize);
}
internal class Org.BouncyCastle.Tls.HandshakeMessageOutput : MemoryStream {
    internal HandshakeMessageOutput(short handshakeType);
    internal HandshakeMessageOutput(short handshakeType, int bodyLength);
    internal static int GetLength(int bodyLength);
    internal static void Send(TlsProtocol protocol, short handshakeType, Byte[] body);
    internal void Send(TlsProtocol protocol);
    internal void PrepareClientHello(TlsHandshakeHash handshakeHash, int bindersSize);
    internal void SendClientHello(TlsClientProtocol clientProtocol, TlsHandshakeHash handshakeHash, int bindersSize);
}
public abstract class Org.BouncyCastle.Tls.HandshakeType : object {
    public static short hello_request;
    public static short client_hello;
    public static short server_hello;
    public static short certificate;
    public static short server_key_exchange;
    public static short certificate_request;
    public static short server_hello_done;
    public static short certificate_verify;
    public static short client_key_exchange;
    public static short finished;
    public static short certificate_url;
    public static short certificate_status;
    public static short hello_verify_request;
    public static short supplemental_data;
    public static short new_session_ticket;
    public static short end_of_early_data;
    public static short hello_retry_request;
    public static short encrypted_extensions;
    public static short key_update;
    public static short message_hash;
    public static short compressed_certificate;
    public static string GetName(short handshakeType);
    public static string GetText(short handshakeType);
    public static bool IsRecognized(short handshakeType);
}
public abstract class Org.BouncyCastle.Tls.HashAlgorithm : object {
    public static short none;
    public static short md5;
    public static short sha1;
    public static short sha224;
    public static short sha256;
    public static short sha384;
    public static short sha512;
    public static short Intrinsic;
    public static string GetName(short hashAlgorithm);
    public static int GetOutputSize(short hashAlgorithm);
    public static string GetText(short hashAlgorithm);
    public static bool IsPrivate(short hashAlgorithm);
    public static bool IsRecognized(short hashAlgorithm);
}
public class Org.BouncyCastle.Tls.HeartbeatExtension : object {
    private short m_mode;
    public short Mode { get; }
    public HeartbeatExtension(short mode);
    public short get_Mode();
    public void Encode(Stream output);
    public static HeartbeatExtension Parse(Stream input);
}
public class Org.BouncyCastle.Tls.HeartbeatMessage : object {
    private short m_type;
    private Byte[] m_payload;
    private Byte[] m_padding;
    public int PaddingLength { get; }
    public Byte[] Payload { get; }
    public short Type { get; }
    public HeartbeatMessage(short type, Byte[] payload, Byte[] padding);
    public static HeartbeatMessage Create(TlsContext context, short type, Byte[] payload);
    public static HeartbeatMessage Create(TlsContext context, short type, Byte[] payload, int paddingLength);
    public int get_PaddingLength();
    public Byte[] get_Payload();
    public short get_Type();
    public void Encode(Stream output);
    public static HeartbeatMessage Parse(Stream input);
    private static Byte[] GetPayload(Byte[] payloadBuffer, int payloadLength);
    private static Byte[] GetPadding(Byte[] payloadBuffer, int payloadLength);
}
public abstract class Org.BouncyCastle.Tls.HeartbeatMessageType : object {
    public static short heartbeat_request;
    public static short heartbeat_response;
    public static string GetName(short heartbeatMessageType);
    public static string GetText(short heartbeatMessageType);
    public static bool IsValid(short heartbeatMessageType);
}
public abstract class Org.BouncyCastle.Tls.HeartbeatMode : object {
    public static short peer_allowed_to_send;
    public static short peer_not_allowed_to_send;
    public static string GetName(short heartbeatMode);
    public static string GetText(short heartbeatMode);
    public static bool IsValid(short heartbeatMode);
}
public abstract class Org.BouncyCastle.Tls.IdentifierType : object {
    public static short pre_agreed;
    public static short key_sha1_hash;
    public static short x509_name;
    public static short cert_sha1_hash;
    public static string GetName(short identifierType);
    public static string GetText(short identifierType);
}
public abstract class Org.BouncyCastle.Tls.KeyExchangeAlgorithm : object {
    public static int NULL;
    public static int RSA;
    public static int RSA_EXPORT;
    public static int DHE_DSS;
    public static int DHE_DSS_EXPORT;
    public static int DHE_RSA;
    public static int DHE_RSA_EXPORT;
    public static int DH_DSS;
    public static int DH_DSS_EXPORT;
    public static int DH_RSA;
    public static int DH_RSA_EXPORT;
    public static int DH_anon;
    public static int DH_anon_EXPORT;
    public static int PSK;
    public static int DHE_PSK;
    public static int RSA_PSK;
    public static int ECDH_ECDSA;
    public static int ECDHE_ECDSA;
    public static int ECDH_RSA;
    public static int ECDHE_RSA;
    public static int ECDH_anon;
    public static int SRP;
    public static int SRP_DSS;
    public static int SRP_RSA;
    public static int ECDHE_PSK;
    public static int SM2;
    public static bool IsAnonymous(int keyExchangeAlgorithm);
}
public class Org.BouncyCastle.Tls.KeyShareEntry : object {
    private int m_namedGroup;
    private Byte[] m_keyExchange;
    public int NamedGroup { get; }
    public Byte[] KeyExchange { get; }
    public KeyShareEntry(int namedGroup, Byte[] keyExchange);
    private static bool CheckKeyExchangeLength(int length);
    public int get_NamedGroup();
    public Byte[] get_KeyExchange();
    public void Encode(Stream output);
    public static KeyShareEntry Parse(Stream input);
}
public abstract class Org.BouncyCastle.Tls.KeyUpdateRequest : object {
    public static short update_not_requested;
    public static short update_requested;
    public static string GetName(short keyUpdateRequest);
    public static string GetText(short keyUpdateRequest);
    public static bool IsValid(short keyUpdateRequest);
}
public abstract class Org.BouncyCastle.Tls.MacAlgorithm : object {
    public static int cls_null;
    public static int md5;
    public static int sha;
    public static int hmac_md5;
    public static int hmac_sha1;
    public static int hmac_sha256;
    public static int hmac_sha384;
    public static int hmac_sha512;
    public static string GetName(int macAlgorithm);
    public static string GetText(int macAlgorithm);
    public static bool IsHmac(int macAlgorithm);
}
public abstract class Org.BouncyCastle.Tls.MaxFragmentLength : object {
    public static short pow2_9;
    public static short pow2_10;
    public static short pow2_11;
    public static short pow2_12;
    public static bool IsValid(short maxFragmentLength);
}
public abstract class Org.BouncyCastle.Tls.NamedGroup : object {
    public static int sect163k1;
    public static int sect163r1;
    public static int sect163r2;
    public static int sect193r1;
    public static int sect193r2;
    public static int sect233k1;
    public static int sect233r1;
    public static int sect239k1;
    public static int sect283k1;
    public static int sect283r1;
    public static int sect409k1;
    public static int sect409r1;
    public static int sect571k1;
    public static int sect571r1;
    public static int secp160k1;
    public static int secp160r1;
    public static int secp160r2;
    public static int secp192k1;
    public static int secp192r1;
    public static int secp224k1;
    public static int secp224r1;
    public static int secp256k1;
    public static int secp256r1;
    public static int secp384r1;
    public static int secp521r1;
    public static int brainpoolP256r1;
    public static int brainpoolP384r1;
    public static int brainpoolP512r1;
    public static int x25519;
    public static int x448;
    public static int brainpoolP256r1tls13;
    public static int brainpoolP384r1tls13;
    public static int brainpoolP512r1tls13;
    public static int GC256A;
    public static int GC256B;
    public static int GC256C;
    public static int GC256D;
    public static int GC512A;
    public static int GC512B;
    public static int GC512C;
    public static int curveSM2;
    public static int ffdhe2048;
    public static int ffdhe3072;
    public static int ffdhe4096;
    public static int ffdhe6144;
    public static int ffdhe8192;
    public static int arbitrary_explicit_prime_curves;
    public static int arbitrary_explicit_char2_curves;
    private static String[] CurveNames;
    private static String[] FiniteFieldNames;
    private static NamedGroup();
    public static bool CanBeNegotiated(int namedGroup, ProtocolVersion version);
    public static int GetCurveBits(int namedGroup);
    public static string GetCurveName(int namedGroup);
    public static int GetFiniteFieldBits(int namedGroup);
    public static string GetFiniteFieldName(int namedGroup);
    public static int GetMaximumChar2CurveBits();
    public static int GetMaximumCurveBits();
    public static int GetMaximumFiniteFieldBits();
    public static int GetMaximumPrimeCurveBits();
    public static string GetName(int namedGroup);
    public static string GetStandardName(int namedGroup);
    public static string GetText(int namedGroup);
    public static bool IsChar2Curve(int namedGroup);
    public static bool IsPrimeCurve(int namedGroup);
    public static bool IsPrivate(int namedGroup);
    public static bool IsValid(int namedGroup);
    public static bool RefersToAnECDHCurve(int namedGroup);
    public static bool RefersToAnECDSACurve(int namedGroup);
    public static bool RefersToAnXDHCurve(int namedGroup);
    public static bool RefersToASpecificCurve(int namedGroup);
    public static bool RefersToASpecificFiniteField(int namedGroup);
    public static bool RefersToASpecificGroup(int namedGroup);
}
public abstract class Org.BouncyCastle.Tls.NamedGroupRole : object {
    public static int dh;
    public static int ecdh;
    public static int ecdsa;
}
public abstract class Org.BouncyCastle.Tls.NameType : object {
    public static short host_name;
    public static string GetName(short nameType);
    public static string GetText(short nameType);
    public static bool IsRecognized(short nameType);
    public static bool IsValid(short nameType);
}
public class Org.BouncyCastle.Tls.NewSessionTicket : object {
    private long m_ticketLifetimeHint;
    private Byte[] m_ticket;
    public long TicketLifetimeHint { get; }
    public Byte[] Ticket { get; }
    public NewSessionTicket(long ticketLifetimeHint, Byte[] ticket);
    public long get_TicketLifetimeHint();
    public Byte[] get_Ticket();
    public void Encode(Stream output);
    public static NewSessionTicket Parse(Stream input);
}
public class Org.BouncyCastle.Tls.OcspStatusRequest : object {
    private IList`1<ResponderID> m_responderIDList;
    private X509Extensions m_requestExtensions;
    public IList`1<ResponderID> ResponderIDList { get; }
    public X509Extensions RequestExtensions { get; }
    public OcspStatusRequest(IList`1<ResponderID> responderIDList, X509Extensions requestExtensions);
    public IList`1<ResponderID> get_ResponderIDList();
    public X509Extensions get_RequestExtensions();
    public void Encode(Stream output);
    public static OcspStatusRequest Parse(Stream input);
}
public class Org.BouncyCastle.Tls.OfferedPsks : object {
    private IList`1<PskIdentity> m_identities;
    private IList`1<Byte[]> m_binders;
    private int m_bindersSize;
    public IList`1<Byte[]> Binders { get; }
    public int BindersSize { get; }
    public IList`1<PskIdentity> Identities { get; }
    public OfferedPsks(IList`1<PskIdentity> identities);
    private OfferedPsks(IList`1<PskIdentity> identities, IList`1<Byte[]> binders, int bindersSize);
    public IList`1<Byte[]> get_Binders();
    public int get_BindersSize();
    public IList`1<PskIdentity> get_Identities();
    public int GetIndexOfIdentity(PskIdentity pskIdentity);
    public void Encode(Stream output);
    internal static void EncodeBinders(Stream output, TlsCrypto crypto, TlsHandshakeHash handshakeHash, BindersConfig bindersConfig);
    internal static int GetBindersSize(TlsPsk[] psks);
    public static OfferedPsks Parse(Stream input);
}
public abstract class Org.BouncyCastle.Tls.PrfAlgorithm : object {
    public static int ssl_prf_legacy;
    public static int tls_prf_legacy;
    public static int tls_prf_sha256;
    public static int tls_prf_sha384;
    public static int tls13_hkdf_sha256;
    public static int tls13_hkdf_sha384;
    public static int tls13_hkdf_sm3;
    public static string GetName(int prfAlgorithm);
    public static string GetText(int prfAlgorithm);
}
public class Org.BouncyCastle.Tls.ProtocolName : object {
    public static ProtocolName Http_1_1;
    public static ProtocolName Spdy_1;
    public static ProtocolName Spdy_2;
    public static ProtocolName Spdy_3;
    public static ProtocolName Stun_Turn;
    public static ProtocolName Stun_Nat_Discovery;
    public static ProtocolName Http_2_Tls;
    public static ProtocolName Http_2_Tcp;
    public static ProtocolName WebRtc;
    public static ProtocolName WebRtc_Confidential;
    public static ProtocolName Ftp;
    public static ProtocolName Imap;
    public static ProtocolName Pop3;
    public static ProtocolName ManageSieve;
    public static ProtocolName Coap;
    public static ProtocolName Xmpp_Client;
    public static ProtocolName Xmpp_Server;
    public static ProtocolName Acme_Tls_1;
    public static ProtocolName Oasis_Mqtt;
    public static ProtocolName Dns_Over_Tls;
    public static ProtocolName Ntske_1;
    public static ProtocolName Sun_Rpc;
    public static ProtocolName Http_3;
    public static ProtocolName Smb_2;
    public static ProtocolName Irc;
    public static ProtocolName Nntp_Reading;
    public static ProtocolName Nntp_Transit;
    public static ProtocolName Dns_Over_Quic;
    private Byte[] m_bytes;
    private ProtocolName(Byte[] bytes);
    private static ProtocolName();
    public static ProtocolName AsRawBytes(Byte[] bytes);
    public static ProtocolName AsUtf8Encoding(string name);
    public Byte[] GetBytes();
    public string GetUtf8Decoding();
    public void Encode(Stream output);
    public static ProtocolName Parse(Stream input);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Tls.ProtocolVersion : object {
    public static ProtocolVersion SSLv3;
    public static ProtocolVersion TLSv10;
    public static ProtocolVersion TLSv11;
    public static ProtocolVersion TLSv12;
    public static ProtocolVersion TLSv13;
    public static ProtocolVersion DTLSv10;
    public static ProtocolVersion DTLSv12;
    public static ProtocolVersion DTLSv13;
    internal static ProtocolVersion CLIENT_EARLIEST_SUPPORTED_DTLS;
    internal static ProtocolVersion CLIENT_EARLIEST_SUPPORTED_TLS;
    internal static ProtocolVersion CLIENT_LATEST_SUPPORTED_DTLS;
    internal static ProtocolVersion CLIENT_LATEST_SUPPORTED_TLS;
    internal static ProtocolVersion SERVER_EARLIEST_SUPPORTED_DTLS;
    internal static ProtocolVersion SERVER_EARLIEST_SUPPORTED_TLS;
    internal static ProtocolVersion SERVER_LATEST_SUPPORTED_DTLS;
    internal static ProtocolVersion SERVER_LATEST_SUPPORTED_TLS;
    private int version;
    private string name;
    public int FullVersion { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public string Name { get; }
    public bool IsDtls { get; }
    public bool IsSsl { get; }
    public bool IsTls { get; }
    private ProtocolVersion(int v, string name);
    private static ProtocolVersion();
    public static bool Contains(ProtocolVersion[] versions, ProtocolVersion version);
    public static ProtocolVersion GetEarliestDtls(ProtocolVersion[] versions);
    public static ProtocolVersion GetEarliestTls(ProtocolVersion[] versions);
    public static ProtocolVersion GetLatestDtls(ProtocolVersion[] versions);
    public static ProtocolVersion GetLatestTls(ProtocolVersion[] versions);
    internal static bool IsSupportedDtlsVersionClient(ProtocolVersion version);
    internal static bool IsSupportedDtlsVersionServer(ProtocolVersion version);
    internal static bool IsSupportedTlsVersionClient(ProtocolVersion version);
    internal static bool IsSupportedTlsVersionServer(ProtocolVersion version);
    public ProtocolVersion[] DownTo(ProtocolVersion min);
    public int get_FullVersion();
    public int get_MajorVersion();
    public int get_MinorVersion();
    public string get_Name();
    public bool get_IsDtls();
    public bool get_IsSsl();
    public bool get_IsTls();
    public ProtocolVersion GetEquivalentTlsVersion();
    public ProtocolVersion GetNextVersion();
    public ProtocolVersion GetPreviousVersion();
    public bool IsEarlierVersionOf(ProtocolVersion version);
    public bool IsEqualOrEarlierVersionOf(ProtocolVersion version);
    public bool IsEqualOrLaterVersionOf(ProtocolVersion version);
    public bool IsLaterVersionOf(ProtocolVersion version);
    public virtual bool Equals(object other);
    public bool Equals(ProtocolVersion other);
    public virtual int GetHashCode();
    public static ProtocolVersion Get(int major, int minor);
    public ProtocolVersion[] Only();
    public virtual string ToString();
    private static void CheckUint8(int versionOctet);
    private static ProtocolVersion GetUnknownVersion(int major, int minor, string prefix);
}
public class Org.BouncyCastle.Tls.PskIdentity : object {
    private Byte[] m_identity;
    private long m_obfuscatedTicketAge;
    public Byte[] Identity { get; }
    public long ObfuscatedTicketAge { get; }
    public PskIdentity(Byte[] identity, long obfuscatedTicketAge);
    public int GetEncodedLength();
    public Byte[] get_Identity();
    public long get_ObfuscatedTicketAge();
    public void Encode(Stream output);
    public static PskIdentity Parse(Stream input);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Org.BouncyCastle.Tls.PskKeyExchangeMode : object {
    public static short psk_ke;
    public static short psk_dhe_ke;
    public static string GetName(short pskKeyExchangeMode);
    public static string GetText(short pskKeyExchangeMode);
}
public class Org.BouncyCastle.Tls.PskTlsClient : AbstractTlsClient {
    private static Int32[] DefaultCipherSuites;
    protected TlsPskIdentity m_pskIdentity;
    public PskTlsClient(TlsCrypto crypto, Byte[] identity, Byte[] psk);
    public PskTlsClient(TlsCrypto crypto, TlsPskIdentity pskIdentity);
    private static PskTlsClient();
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected virtual Int32[] GetSupportedCipherSuites();
    public virtual TlsPskIdentity GetPskIdentity();
    public virtual TlsAuthentication GetAuthentication();
}
public class Org.BouncyCastle.Tls.PskTlsServer : AbstractTlsServer {
    private static Int32[] DefaultCipherSuites;
    protected TlsPskIdentityManager m_pskIdentityManager;
    public PskTlsServer(TlsCrypto crypto, TlsPskIdentityManager pskIdentityManager);
    private static PskTlsServer();
    protected virtual TlsCredentialedDecryptor GetRsaEncryptionCredentials();
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected virtual Int32[] GetSupportedCipherSuites();
    public virtual TlsCredentials GetCredentials();
    public virtual TlsPskIdentityManager GetPskIdentityManager();
}
public abstract class Org.BouncyCastle.Tls.RecordFormat : object {
    public static int TypeOffset;
    public static int VersionOffset;
    public static int LengthOffset;
    public static int FragmentOffset;
}
public class Org.BouncyCastle.Tls.RecordPreview : object {
    private int recordSize;
    private int contentLimit;
    public int ContentLimit { get; }
    public int RecordSize { get; }
    internal RecordPreview(int recordSize, int contentLimit);
    internal static RecordPreview CombineAppData(RecordPreview a, RecordPreview b);
    internal static RecordPreview ExtendRecordSize(RecordPreview a, int recordSize);
    public int get_ContentLimit();
    public int get_RecordSize();
}
internal class Org.BouncyCastle.Tls.RecordStream : object {
    private static int DefaultPlaintextLimit;
    private Record m_inputRecord;
    private SequenceNumber m_readSeqNo;
    private SequenceNumber m_writeSeqNo;
    private TlsProtocol m_handler;
    private Stream m_input;
    private Stream m_output;
    private TlsCipher m_pendingCipher;
    private TlsCipher m_readCipher;
    private TlsCipher m_readCipherDeferred;
    private TlsCipher m_writeCipher;
    private ProtocolVersion m_writeVersion;
    private int m_plaintextLimit;
    private int m_ciphertextLimit;
    private bool m_ignoreChangeCipherSpec;
    internal int PlaintextLimit { get; }
    internal RecordStream(TlsProtocol handler, Stream input, Stream output);
    internal int get_PlaintextLimit();
    internal void SetPlaintextLimit(int plaintextLimit);
    internal void SetWriteVersion(ProtocolVersion writeVersion);
    internal void SetIgnoreChangeCipherSpec(bool ignoreChangeCipherSpec);
    internal void SetPendingCipher(TlsCipher tlsCipher);
    internal void NotifyChangeCipherSpecReceived();
    internal void EnablePendingCipherRead(bool deferred);
    internal void EnablePendingCipherWrite();
    internal void FinaliseHandshake();
    internal bool NeedsKeyUpdate();
    internal void NotifyKeyUpdateReceived();
    internal void NotifyKeyUpdateSent();
    internal RecordPreview PreviewRecordHeader(Byte[] recordHeader);
    internal RecordPreview PreviewOutputRecord(int contentLength);
    internal int PreviewOutputRecordSize(int contentLength);
    internal bool ReadFullRecord(Byte[] input, int inputOff, int inputLen);
    internal bool ReadRecord();
    internal TlsDecodeResult DecodeAndVerify(short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int off, int len);
    internal void WriteRecord(short contentType, Byte[] plaintext, int plaintextOffset, int plaintextLength);
    internal void Close();
    private void CheckChangeCipherSpec(Byte[] buf, int off, int len);
    private short CheckRecordType(Byte[] buf, int off);
    private static void CheckLength(int length, int limit, short alertDescription);
}
public class Org.BouncyCastle.Tls.SecurityParameters : object {
    internal int m_entity;
    internal bool m_resumedSession;
    internal bool m_secureRenegotiation;
    internal int m_cipherSuite;
    internal short m_maxFragmentLength;
    internal int m_prfAlgorithm;
    internal int m_prfCryptoHashAlgorithm;
    internal int m_prfHashLength;
    internal int m_verifyDataLength;
    internal TlsSecret m_baseKeyClient;
    internal TlsSecret m_baseKeyServer;
    internal TlsSecret m_earlyExporterMasterSecret;
    internal TlsSecret m_earlySecret;
    internal TlsSecret m_exporterMasterSecret;
    internal TlsSecret m_handshakeSecret;
    internal TlsSecret m_masterSecret;
    internal TlsSecret m_trafficSecretClient;
    internal TlsSecret m_trafficSecretServer;
    internal Byte[] m_clientRandom;
    internal Byte[] m_serverRandom;
    internal Byte[] m_sessionHash;
    internal Byte[] m_sessionID;
    internal Byte[] m_pskIdentity;
    internal Byte[] m_srpIdentity;
    internal Byte[] m_tlsServerEndPoint;
    internal Byte[] m_tlsUnique;
    internal bool m_encryptThenMac;
    internal bool m_extendedMasterSecret;
    internal bool m_extendedPadding;
    internal bool m_truncatedHmac;
    internal ProtocolName m_applicationProtocol;
    internal bool m_applicationProtocolSet;
    internal Int16[] m_clientCertTypes;
    internal IList`1<ServerName> m_clientServerNames;
    internal IList`1<SignatureAndHashAlgorithm> m_clientSigAlgs;
    internal IList`1<SignatureAndHashAlgorithm> m_clientSigAlgsCert;
    internal Int32[] m_clientSupportedGroups;
    internal IList`1<SignatureAndHashAlgorithm> m_serverSigAlgs;
    internal IList`1<SignatureAndHashAlgorithm> m_serverSigAlgsCert;
    internal Int32[] m_serverSupportedGroups;
    internal int m_keyExchangeAlgorithm;
    internal Certificate m_localCertificate;
    internal Certificate m_peerCertificate;
    internal ProtocolVersion m_negotiatedVersion;
    internal int m_statusRequestVersion;
    internal short m_clientCertificateType;
    internal Byte[] m_localVerifyData;
    internal Byte[] m_peerVerifyData;
    internal Byte[] m_connectionIDLocal;
    internal Byte[] m_connectionIDPeer;
    public ProtocolName ApplicationProtocol { get; }
    public TlsSecret BaseKeyClient { get; }
    public TlsSecret BaseKeyServer { get; }
    public int CipherSuite { get; }
    public short ClientCertificateType { get; }
    public Int16[] ClientCertTypes { get; }
    public Byte[] ClientRandom { get; }
    public IList`1<ServerName> ClientServerNames { get; }
    public IList`1<SignatureAndHashAlgorithm> ClientSigAlgs { get; }
    public IList`1<SignatureAndHashAlgorithm> ClientSigAlgsCert { get; }
    public Int32[] ClientSupportedGroups { get; }
    public Byte[] ConnectionIDLocal { get; }
    public Byte[] ConnectionIDPeer { get; }
    public TlsSecret EarlyExporterMasterSecret { get; }
    public TlsSecret EarlySecret { get; }
    public TlsSecret ExporterMasterSecret { get; }
    public int Entity { get; }
    public TlsSecret HandshakeSecret { get; }
    public bool IsApplicationProtocolSet { get; }
    public bool IsEncryptThenMac { get; }
    public bool IsExtendedMasterSecret { get; }
    public bool IsExtendedPadding { get; }
    public bool IsResumedSession { get; }
    public bool IsSecureRenegotiation { get; }
    public bool IsTruncatedHmac { get; }
    public int KeyExchangeAlgorithm { get; }
    public Certificate LocalCertificate { get; }
    public Byte[] LocalVerifyData { get; }
    public TlsSecret MasterSecret { get; }
    public short MaxFragmentLength { get; }
    public ProtocolVersion NegotiatedVersion { get; }
    public Certificate PeerCertificate { get; }
    public Byte[] PeerVerifyData { get; }
    public int PrfAlgorithm { get; }
    public int PrfCryptoHashAlgorithm { get; }
    public int PrfHashLength { get; }
    public Byte[] PskIdentity { get; }
    public Byte[] ServerRandom { get; }
    public IList`1<SignatureAndHashAlgorithm> ServerSigAlgs { get; }
    public IList`1<SignatureAndHashAlgorithm> ServerSigAlgsCert { get; }
    public Int32[] ServerSupportedGroups { get; }
    public Byte[] SessionHash { get; }
    public Byte[] SessionID { get; }
    public Byte[] SrpIdentity { get; }
    public int StatusRequestVersion { get; }
    public Byte[] TlsServerEndPoint { get; }
    public Byte[] TlsUnique { get; }
    public TlsSecret TrafficSecretClient { get; }
    public TlsSecret TrafficSecretServer { get; }
    public int VerifyDataLength { get; }
    internal void Clear();
    public ProtocolName get_ApplicationProtocol();
    public TlsSecret get_BaseKeyClient();
    public TlsSecret get_BaseKeyServer();
    public int get_CipherSuite();
    public short get_ClientCertificateType();
    public Int16[] get_ClientCertTypes();
    public Byte[] get_ClientRandom();
    public IList`1<ServerName> get_ClientServerNames();
    public IList`1<SignatureAndHashAlgorithm> get_ClientSigAlgs();
    public IList`1<SignatureAndHashAlgorithm> get_ClientSigAlgsCert();
    public Int32[] get_ClientSupportedGroups();
    public Byte[] get_ConnectionIDLocal();
    public Byte[] get_ConnectionIDPeer();
    public TlsSecret get_EarlyExporterMasterSecret();
    public TlsSecret get_EarlySecret();
    public TlsSecret get_ExporterMasterSecret();
    public int get_Entity();
    public TlsSecret get_HandshakeSecret();
    public bool get_IsApplicationProtocolSet();
    public bool get_IsEncryptThenMac();
    public bool get_IsExtendedMasterSecret();
    public bool get_IsExtendedPadding();
    public bool get_IsResumedSession();
    public bool get_IsSecureRenegotiation();
    public bool get_IsTruncatedHmac();
    public int get_KeyExchangeAlgorithm();
    public Certificate get_LocalCertificate();
    public Byte[] get_LocalVerifyData();
    public TlsSecret get_MasterSecret();
    public short get_MaxFragmentLength();
    public ProtocolVersion get_NegotiatedVersion();
    public Certificate get_PeerCertificate();
    public Byte[] get_PeerVerifyData();
    public int get_PrfAlgorithm();
    public int get_PrfCryptoHashAlgorithm();
    public int get_PrfHashLength();
    public Byte[] get_PskIdentity();
    public Byte[] get_ServerRandom();
    public IList`1<SignatureAndHashAlgorithm> get_ServerSigAlgs();
    public IList`1<SignatureAndHashAlgorithm> get_ServerSigAlgsCert();
    public Int32[] get_ServerSupportedGroups();
    public Byte[] get_SessionHash();
    public Byte[] get_SessionID();
    public Byte[] get_SrpIdentity();
    public int get_StatusRequestVersion();
    public Byte[] get_TlsServerEndPoint();
    public Byte[] get_TlsUnique();
    public TlsSecret get_TrafficSecretClient();
    public TlsSecret get_TrafficSecretServer();
    public int get_VerifyDataLength();
    private static TlsSecret ClearSecret(TlsSecret secret);
}
public class Org.BouncyCastle.Tls.ServerHello : object {
    private static Byte[] HelloRetryRequestMagic;
    private ProtocolVersion m_version;
    private Byte[] m_random;
    private Byte[] m_sessionID;
    private int m_cipherSuite;
    private IDictionary`2<int, Byte[]> m_extensions;
    public int CipherSuite { get; }
    public IDictionary`2<int, Byte[]> Extensions { get; }
    public Byte[] Random { get; }
    public Byte[] SessionID { get; }
    public ProtocolVersion Version { get; }
    public ServerHello(Byte[] sessionID, int cipherSuite, IDictionary`2<int, Byte[]> extensions);
    public ServerHello(ProtocolVersion version, Byte[] random, Byte[] sessionID, int cipherSuite, IDictionary`2<int, Byte[]> extensions);
    private static ServerHello();
    public int get_CipherSuite();
    public IDictionary`2<int, Byte[]> get_Extensions();
    public Byte[] get_Random();
    public Byte[] get_SessionID();
    public ProtocolVersion get_Version();
    public bool IsHelloRetryRequest();
    public void Encode(TlsContext context, Stream output);
    public static ServerHello Parse(MemoryStream input);
}
public class Org.BouncyCastle.Tls.ServerName : object {
    private short nameType;
    private Byte[] nameData;
    public Byte[] NameData { get; }
    public short NameType { get; }
    public ServerName(short nameType, Byte[] nameData);
    public Byte[] get_NameData();
    public short get_NameType();
    public void Encode(Stream output);
    public static ServerName Parse(Stream input);
}
public class Org.BouncyCastle.Tls.ServerNameList : object {
    private IList`1<ServerName> m_serverNameList;
    public IList`1<ServerName> ServerNames { get; }
    public ServerNameList(IList`1<ServerName> serverNameList);
    public IList`1<ServerName> get_ServerNames();
    public void Encode(Stream output);
    public static ServerNameList Parse(Stream input);
    private static Int16[] CheckNameType(Int16[] nameTypesSeen, short nameType);
}
public abstract class Org.BouncyCastle.Tls.ServerOnlyTlsAuthentication : object {
    public abstract virtual void NotifyServerCertificate(TlsServerCertificate serverCertificate);
    public sealed virtual TlsCredentials GetClientCredentials(CertificateRequest certificateRequest);
}
public class Org.BouncyCastle.Tls.ServerSrpParams : object {
    private BigInteger m_N;
    private BigInteger m_g;
    private BigInteger m_B;
    private Byte[] m_s;
    public BigInteger B { get; }
    public BigInteger G { get; }
    public BigInteger N { get; }
    public Byte[] S { get; }
    public ServerSrpParams(BigInteger N, BigInteger g, Byte[] s, BigInteger B);
    public BigInteger get_B();
    public BigInteger get_G();
    public BigInteger get_N();
    public Byte[] get_S();
    public void Encode(Stream output);
    public static ServerSrpParams Parse(Stream input);
}
public class Org.BouncyCastle.Tls.SessionParameters : object {
    private int m_cipherSuite;
    private Certificate m_localCertificate;
    private TlsSecret m_masterSecret;
    private ProtocolVersion m_negotiatedVersion;
    private Certificate m_peerCertificate;
    private Byte[] m_pskIdentity;
    private Byte[] m_srpIdentity;
    private Byte[] m_encodedServerExtensions;
    private bool m_extendedMasterSecret;
    public int CipherSuite { get; }
    public bool IsExtendedMasterSecret { get; }
    public Certificate LocalCertificate { get; }
    public TlsSecret MasterSecret { get; }
    public ProtocolVersion NegotiatedVersion { get; }
    public Certificate PeerCertificate { get; }
    public Byte[] PskIdentity { get; }
    public Byte[] SrpIdentity { get; }
    private SessionParameters(int cipherSuite, Certificate localCertificate, TlsSecret masterSecret, ProtocolVersion negotiatedVersion, Certificate peerCertificate, Byte[] pskIdentity, Byte[] srpIdentity, Byte[] encodedServerExtensions, bool extendedMasterSecret);
    public int get_CipherSuite();
    public void Clear();
    public SessionParameters Copy();
    public bool get_IsExtendedMasterSecret();
    public Certificate get_LocalCertificate();
    public TlsSecret get_MasterSecret();
    public ProtocolVersion get_NegotiatedVersion();
    public Certificate get_PeerCertificate();
    public Byte[] get_PskIdentity();
    public IDictionary`2<int, Byte[]> ReadServerExtensions();
    public Byte[] get_SrpIdentity();
}
public class Org.BouncyCastle.Tls.SignatureAlgorithm : object {
    public static short anonymous;
    public static short rsa;
    public static short dsa;
    public static short ecdsa;
    public static short ed25519;
    public static short ed448;
    public static short rsa_pss_rsae_sha256;
    public static short rsa_pss_rsae_sha384;
    public static short rsa_pss_rsae_sha512;
    public static short rsa_pss_pss_sha256;
    public static short rsa_pss_pss_sha384;
    public static short rsa_pss_pss_sha512;
    public static short ecdsa_brainpoolP256r1tls13_sha256;
    public static short ecdsa_brainpoolP384r1tls13_sha384;
    public static short ecdsa_brainpoolP512r1tls13_sha512;
    public static short gostr34102012_256;
    public static short gostr34102012_512;
    public static short GetClientCertificateType(short signatureAlgorithm);
    public static string GetName(short signatureAlgorithm);
    public static string GetText(short signatureAlgorithm);
    public static bool IsRecognized(short signatureAlgorithm);
}
public class Org.BouncyCastle.Tls.SignatureAndHashAlgorithm : object {
    public static SignatureAndHashAlgorithm ecdsa_brainpoolP256r1tls13_sha256;
    public static SignatureAndHashAlgorithm ecdsa_brainpoolP384r1tls13_sha384;
    public static SignatureAndHashAlgorithm ecdsa_brainpoolP512r1tls13_sha512;
    public static SignatureAndHashAlgorithm ed25519;
    public static SignatureAndHashAlgorithm ed448;
    public static SignatureAndHashAlgorithm gostr34102012_256;
    public static SignatureAndHashAlgorithm gostr34102012_512;
    public static SignatureAndHashAlgorithm rsa_pss_rsae_sha256;
    public static SignatureAndHashAlgorithm rsa_pss_rsae_sha384;
    public static SignatureAndHashAlgorithm rsa_pss_rsae_sha512;
    public static SignatureAndHashAlgorithm rsa_pss_pss_sha256;
    public static SignatureAndHashAlgorithm rsa_pss_pss_sha384;
    public static SignatureAndHashAlgorithm rsa_pss_pss_sha512;
    private short m_hash;
    private short m_signature;
    public short Hash { get; }
    public short Signature { get; }
    public SignatureAndHashAlgorithm(short hash, short signature);
    private static SignatureAndHashAlgorithm();
    public static SignatureAndHashAlgorithm GetInstance(short hashAlgorithm, short signatureAlgorithm);
    private static SignatureAndHashAlgorithm GetInstanceIntrinsic(short signatureAlgorithm);
    private static SignatureAndHashAlgorithm Create(int signatureScheme);
    private static SignatureAndHashAlgorithm Create(short hashAlgorithm, short signatureAlgorithm);
    public short get_Hash();
    public short get_Signature();
    public void Encode(Stream output);
    public static SignatureAndHashAlgorithm Parse(Stream input);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Tls.SignatureScheme : object {
    public static int rsa_pkcs1_sha1;
    public static int ecdsa_sha1;
    public static int rsa_pkcs1_sha256;
    public static int rsa_pkcs1_sha384;
    public static int rsa_pkcs1_sha512;
    public static int ecdsa_secp256r1_sha256;
    public static int ecdsa_secp384r1_sha384;
    public static int ecdsa_secp521r1_sha512;
    public static int rsa_pss_rsae_sha256;
    public static int rsa_pss_rsae_sha384;
    public static int rsa_pss_rsae_sha512;
    public static int ed25519;
    public static int ed448;
    public static int rsa_pss_pss_sha256;
    public static int rsa_pss_pss_sha384;
    public static int rsa_pss_pss_sha512;
    public static int ecdsa_brainpoolP256r1tls13_sha256;
    public static int ecdsa_brainpoolP384r1tls13_sha384;
    public static int ecdsa_brainpoolP512r1tls13_sha512;
    public static int sm2sig_sm3;
    public static int From(SignatureAndHashAlgorithm sigAndHashAlg);
    public static int From(short hashAlgorithm, short signatureAlgorithm);
    public static int GetCryptoHashAlgorithm(int signatureScheme);
    public static int GetCryptoHashAlgorithm(SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    public static string GetName(int signatureScheme);
    public static int GetNamedGroup(int signatureScheme);
    public static short GetHashAlgorithm(int signatureScheme);
    public static short GetSignatureAlgorithm(int signatureScheme);
    public static SignatureAndHashAlgorithm GetSignatureAndHashAlgorithm(int signatureScheme);
    public static string GetText(int signatureScheme);
    public static bool IsPrivate(int signatureScheme);
    public static bool IsECDsa(int signatureScheme);
    public static bool IsRsaPss(int signatureScheme);
}
public class Org.BouncyCastle.Tls.SimulatedTlsSrpIdentityManager : object {
    private static Byte[] PrefixPassword;
    private static Byte[] PrefixSalt;
    protected Srp6Group m_group;
    protected TlsSrp6VerifierGenerator m_verifierGenerator;
    protected TlsMac m_mac;
    public SimulatedTlsSrpIdentityManager(Srp6Group group, TlsSrp6VerifierGenerator verifierGenerator, TlsMac mac);
    private static SimulatedTlsSrpIdentityManager();
    public static SimulatedTlsSrpIdentityManager GetRfc5054Default(TlsCrypto crypto, Srp6Group group, Byte[] seedKey);
    public virtual TlsSrpLoginParameters GetLoginParameters(Byte[] identity);
}
public class Org.BouncyCastle.Tls.SrpTlsClient : AbstractTlsClient {
    private static Int32[] DefaultCipherSuites;
    protected TlsSrpIdentity m_srpIdentity;
    protected bool RequireSrpServerExtension { get; }
    public SrpTlsClient(TlsCrypto crypto, Byte[] identity, Byte[] password);
    public SrpTlsClient(TlsCrypto crypto, TlsSrpIdentity srpIdentity);
    private static SrpTlsClient();
    protected virtual Int32[] GetSupportedCipherSuites();
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected virtual bool get_RequireSrpServerExtension();
    public virtual IDictionary`2<int, Byte[]> GetClientExtensions();
    public virtual void ProcessServerExtensions(IDictionary`2<int, Byte[]> serverExtensions);
    public virtual TlsSrpIdentity GetSrpIdentity();
    public virtual TlsAuthentication GetAuthentication();
}
public class Org.BouncyCastle.Tls.SrpTlsServer : AbstractTlsServer {
    private static Int32[] DefaultCipherSuites;
    protected TlsSrpIdentityManager m_srpIdentityManager;
    protected Byte[] m_srpIdentity;
    protected TlsSrpLoginParameters m_srpLoginParameters;
    public SrpTlsServer(TlsCrypto crypto, TlsSrpIdentityManager srpIdentityManager);
    private static SrpTlsServer();
    protected virtual TlsCredentialedSigner GetDsaSignerCredentials();
    protected virtual TlsCredentialedSigner GetRsaSignerCredentials();
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected virtual Int32[] GetSupportedCipherSuites();
    public virtual void ProcessClientExtensions(IDictionary`2<int, Byte[]> clientExtensions);
    public virtual int GetSelectedCipherSuite();
    public virtual TlsCredentials GetCredentials();
    public virtual TlsSrpLoginParameters GetSrpLoginParameters();
}
public abstract class Org.BouncyCastle.Tls.SrtpProtectionProfile : object {
    public static int SRTP_AES128_CM_HMAC_SHA1_80;
    public static int SRTP_AES128_CM_HMAC_SHA1_32;
    public static int SRTP_NULL_HMAC_SHA1_80;
    public static int SRTP_NULL_HMAC_SHA1_32;
    public static int SRTP_AEAD_AES_128_GCM;
    public static int SRTP_AEAD_AES_256_GCM;
}
internal abstract class Org.BouncyCastle.Tls.Ssl3Utilities : object {
    private static Byte[] SSL_CLIENT;
    private static Byte[] SSL_SERVER;
    private static byte IPAD_BYTE;
    private static byte OPAD_BYTE;
    private static Byte[] IPAD;
    private static Byte[] OPAD;
    private static Ssl3Utilities();
    internal static Byte[] CalculateVerifyData(TlsHandshakeHash handshakeHash, bool isServer);
    internal static void CompleteCombinedHash(TlsContext context, TlsHash md5, TlsHash sha1);
    private static void CompleteHash(Byte[] master_secret, TlsHash hash, int padLength);
    private static Byte[] GenPad(byte b, int count);
    internal static Byte[] ReadEncryptedPms(Stream input);
    internal static void WriteEncryptedPms(Byte[] encryptedPms, Stream output);
}
public class Org.BouncyCastle.Tls.SupplementalDataEntry : object {
    private int m_dataType;
    private Byte[] m_data;
    public int DataType { get; }
    public Byte[] Data { get; }
    public SupplementalDataEntry(int dataType, Byte[] data);
    public int get_DataType();
    public Byte[] get_Data();
}
public abstract class Org.BouncyCastle.Tls.SupplementalDataType : object {
    public static int user_mapping_data;
}
internal class Org.BouncyCastle.Tls.Timeout : object {
    private long durationMillis;
    private long startMillis;
    internal Timeout(long durationMillis);
    internal Timeout(long durationMillis, long currentTimeMillis);
    internal long RemainingMillis(long currentTimeMillis);
    internal static int ConstrainWaitMillis(int waitMillis, Timeout timeout, long currentTimeMillis);
    internal static Timeout ForWaitMillis(int waitMillis);
    internal static Timeout ForWaitMillis(int waitMillis, long currentTimeMillis);
    internal static int GetWaitMillis(Timeout timeout, long currentTimeMillis);
    internal static bool HasExpired(Timeout timeout);
    internal static bool HasExpired(Timeout timeout, long currentTimeMillis);
}
public interface Org.BouncyCastle.Tls.TlsAuthentication {
    public abstract virtual void NotifyServerCertificate(TlsServerCertificate serverCertificate);
    public abstract virtual TlsCredentials GetClientCredentials(CertificateRequest certificateRequest);
}
public interface Org.BouncyCastle.Tls.TlsClient {
    public abstract virtual void Init(TlsClientContext context);
    public abstract virtual TlsSession GetSessionToResume();
    public abstract virtual IList`1<TlsPskExternal> GetExternalPsks();
    public abstract virtual bool IsFallback();
    public abstract virtual IDictionary`2<int, Byte[]> GetClientExtensions();
    public abstract virtual IList`1<int> GetEarlyKeyShareGroups();
    public abstract virtual void NotifyServerVersion(ProtocolVersion selectedVersion);
    public abstract virtual void NotifySessionToResume(TlsSession session);
    public abstract virtual void NotifySessionID(Byte[] sessionID);
    public abstract virtual void NotifySelectedCipherSuite(int selectedCipherSuite);
    public abstract virtual void NotifySelectedPsk(TlsPsk selectedPsk);
    public abstract virtual void ProcessServerExtensions(IDictionary`2<int, Byte[]> serverExtensions);
    public abstract virtual void ProcessServerSupplementalData(IList`1<SupplementalDataEntry> serverSupplementalData);
    public abstract virtual TlsPskIdentity GetPskIdentity();
    public abstract virtual TlsSrpIdentity GetSrpIdentity();
    public abstract virtual TlsDHGroupVerifier GetDHGroupVerifier();
    public abstract virtual TlsSrpConfigVerifier GetSrpConfigVerifier();
    public abstract virtual TlsAuthentication GetAuthentication();
    public abstract virtual IList`1<SupplementalDataEntry> GetClientSupplementalData();
    public abstract virtual void NotifyNewSessionTicket(NewSessionTicket newSessionTicket);
}
public interface Org.BouncyCastle.Tls.TlsClientContext {
}
internal class Org.BouncyCastle.Tls.TlsClientContextImpl : AbstractTlsContext {
    public bool IsServer { get; }
    internal TlsClientContextImpl(TlsCrypto crypto);
    public virtual bool get_IsServer();
}
public class Org.BouncyCastle.Tls.TlsClientProtocol : TlsProtocol {
    protected TlsClient m_tlsClient;
    internal TlsClientContextImpl m_tlsClientContext;
    protected IDictionary`2<int, TlsAgreement> m_clientAgreements;
    internal BindersConfig m_clientBinders;
    protected ClientHello m_clientHello;
    protected TlsKeyExchange m_keyExchange;
    protected TlsAuthentication m_authentication;
    protected CertificateStatus m_certificateStatus;
    protected CertificateRequest m_certificateRequest;
    protected TlsContext Context { get; }
    internal AbstractTlsContext ContextAdmin { get; }
    protected TlsPeer Peer { get; }
    public TlsClientProtocol(Stream stream);
    public TlsClientProtocol(Stream input, Stream output);
    public virtual void Connect(TlsClient tlsClient);
    protected virtual void BeginHandshake();
    protected virtual void CleanupHandshake();
    protected virtual TlsContext get_Context();
    internal virtual AbstractTlsContext get_ContextAdmin();
    protected virtual TlsPeer get_Peer();
    protected virtual void Handle13HandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void HandleHandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void HandleServerCertificate();
    protected virtual void HandleSupplementalData(IList`1<SupplementalDataEntry> serverSupplementalData);
    protected virtual void Process13HelloRetryRequest(ServerHello helloRetryRequest);
    protected virtual void Process13ServerHello(ServerHello serverHello, bool afterHelloRetryRequest);
    protected virtual void Process13ServerHelloCoda(ServerHello serverHello, bool afterHelloRetryRequest);
    protected virtual void ProcessServerHello(ServerHello serverHello);
    protected virtual void Receive13CertificateRequest(MemoryStream buf, bool postHandshakeAuth);
    protected virtual void Receive13EncryptedExtensions(MemoryStream buf);
    protected virtual void Receive13NewSessionTicket(MemoryStream buf);
    protected virtual void Receive13ServerCertificate(MemoryStream buf);
    protected virtual void Receive13ServerCertificateVerify(MemoryStream buf);
    protected virtual void Receive13ServerFinished(MemoryStream buf);
    protected virtual void ReceiveCertificateRequest(MemoryStream buf);
    protected virtual void ReceiveNewSessionTicket(MemoryStream buf);
    protected virtual ServerHello ReceiveServerHelloMessage(MemoryStream buf);
    protected virtual void Send13ClientHelloRetry();
    protected virtual void SendCertificateVerifyMessage(DigitallySigned certificateVerify);
    protected virtual void SendClientHello();
    protected virtual void SendClientHelloMessage();
    protected virtual void SendClientKeyExchange();
    protected virtual void Skip13CertificateRequest();
    protected virtual void Skip13ServerCertificate();
}
public interface Org.BouncyCastle.Tls.TlsCloseable {
    public abstract virtual void Close();
}
public interface Org.BouncyCastle.Tls.TlsContext {
    public TlsCrypto Crypto { get; }
    public TlsNonceGenerator NonceGenerator { get; }
    public SecurityParameters SecurityParameters { get; }
    public bool IsServer { get; }
    public ProtocolVersion[] ClientSupportedVersions { get; }
    public ProtocolVersion ClientVersion { get; }
    public ProtocolVersion RsaPreMasterSecretVersion { get; }
    public ProtocolVersion ServerVersion { get; }
    public TlsSession ResumableSession { get; }
    public TlsSession Session { get; }
    public object UserObject { get; public set; }
    public abstract virtual TlsCrypto get_Crypto();
    public abstract virtual TlsNonceGenerator get_NonceGenerator();
    public abstract virtual SecurityParameters get_SecurityParameters();
    public abstract virtual bool get_IsServer();
    public abstract virtual ProtocolVersion[] get_ClientSupportedVersions();
    public abstract virtual ProtocolVersion get_ClientVersion();
    public abstract virtual ProtocolVersion get_RsaPreMasterSecretVersion();
    public abstract virtual ProtocolVersion get_ServerVersion();
    public abstract virtual TlsSession get_ResumableSession();
    public abstract virtual TlsSession get_Session();
    public abstract virtual object get_UserObject();
    public abstract virtual void set_UserObject(object value);
    public abstract virtual Byte[] ExportChannelBinding(int channelBinding);
    public abstract virtual Byte[] ExportEarlyKeyingMaterial(string asciiLabel, Byte[] context_value, int length);
    public abstract virtual Byte[] ExportKeyingMaterial(string asciiLabel, Byte[] context_value, int length);
}
public interface Org.BouncyCastle.Tls.TlsCredentialedAgreement {
    public abstract virtual TlsSecret GenerateAgreement(TlsCertificate peerCertificate);
}
public interface Org.BouncyCastle.Tls.TlsCredentialedDecryptor {
    public abstract virtual TlsSecret Decrypt(TlsCryptoParameters cryptoParams, Byte[] ciphertext);
}
public interface Org.BouncyCastle.Tls.TlsCredentialedSigner {
    public SignatureAndHashAlgorithm SignatureAndHashAlgorithm { get; }
    public abstract virtual Byte[] GenerateRawSignature(Byte[] hash);
    public abstract virtual SignatureAndHashAlgorithm get_SignatureAndHashAlgorithm();
    public abstract virtual TlsStreamSigner GetStreamSigner();
}
public interface Org.BouncyCastle.Tls.TlsCredentials {
    public Certificate Certificate { get; }
    public abstract virtual Certificate get_Certificate();
}
public class Org.BouncyCastle.Tls.TlsDHanonKeyExchange : AbstractTlsKeyExchange {
    protected TlsDHGroupVerifier m_dhGroupVerifier;
    protected TlsDHConfig m_dhConfig;
    protected TlsAgreement m_agreement;
    public bool RequiresServerKeyExchange { get; }
    public TlsDHanonKeyExchange(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public TlsDHanonKeyExchange(int keyExchange, TlsDHConfig dhConfig);
    private TlsDHanonKeyExchange(int keyExchange, TlsDHGroupVerifier dhGroupVerifier, TlsDHConfig dhConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
}
public class Org.BouncyCastle.Tls.TlsDheKeyExchange : AbstractTlsKeyExchange {
    protected TlsDHGroupVerifier m_dhGroupVerifier;
    protected TlsDHConfig m_dhConfig;
    protected TlsCredentialedSigner m_serverCredentials;
    protected TlsCertificate m_serverCertificate;
    protected TlsAgreement m_agreement;
    public bool RequiresServerKeyExchange { get; }
    public TlsDheKeyExchange(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public TlsDheKeyExchange(int keyExchange, TlsDHConfig dhConfig);
    private TlsDheKeyExchange(int keyExchange, TlsDHGroupVerifier dhGroupVerifier, TlsDHConfig dhConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
}
public interface Org.BouncyCastle.Tls.TlsDHGroupVerifier {
    public abstract virtual bool Accept(DHGroup dhGroup);
}
public class Org.BouncyCastle.Tls.TlsDHKeyExchange : AbstractTlsKeyExchange {
    protected TlsCredentialedAgreement m_agreementCredentials;
    protected TlsCertificate m_dhPeerCertificate;
    public bool RequiresCertificateVerify { get; }
    public TlsDHKeyExchange(int keyExchange);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void SkipClientCredentials();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual bool get_RequiresCertificateVerify();
    public virtual TlsSecret GeneratePreMasterSecret();
}
public abstract class Org.BouncyCastle.Tls.TlsDHUtilities : object {
    public static TlsDHConfig CreateNamedDHConfig(TlsContext context, int namedGroup);
    public static DHGroup GetDHGroup(TlsDHConfig dhConfig);
    public static DHGroup GetNamedDHGroup(int namedGroup);
    public static int GetMinimumFiniteFieldBits(int cipherSuite);
    public static bool IsDHCipherSuite(int cipherSuite);
    public static int GetNamedGroupForDHParameters(BigInteger p, BigInteger g);
    public static DHGroup GetStandardGroupForDHParameters(BigInteger p, BigInteger g);
    public static TlsDHConfig ReceiveDHConfig(TlsContext context, TlsDHGroupVerifier dhGroupVerifier, Stream input);
    public static BigInteger ReadDHParameter(Stream input);
    public static void WriteDHConfig(TlsDHConfig dhConfig, Stream output);
    public static void WriteDHParameter(BigInteger x, Stream output);
}
public abstract class Org.BouncyCastle.Tls.TlsEccUtilities : object {
    public static TlsECConfig CreateNamedECConfig(TlsContext context, int namedGroup);
    public static int GetMinimumCurveBits(int cipherSuite);
    public static bool IsEccCipherSuite(int cipherSuite);
    public static void CheckPointEncoding(int namedGroup, Byte[] encoding);
    public static TlsECConfig ReceiveECDHConfig(TlsContext context, Stream input);
    public static void WriteECConfig(TlsECConfig ecConfig, Stream output);
    public static void WriteNamedECParameters(int namedGroup, Stream output);
}
public class Org.BouncyCastle.Tls.TlsECDHanonKeyExchange : AbstractTlsKeyExchange {
    protected TlsECConfig m_ecConfig;
    protected TlsAgreement m_agreement;
    public bool RequiresServerKeyExchange { get; }
    public TlsECDHanonKeyExchange(int keyExchange);
    public TlsECDHanonKeyExchange(int keyExchange, TlsECConfig ecConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
    protected virtual void GenerateEphemeral(Stream output);
    protected virtual void ProcessEphemeral(Byte[] point);
}
public class Org.BouncyCastle.Tls.TlsECDheKeyExchange : AbstractTlsKeyExchange {
    protected TlsECConfig m_ecConfig;
    protected TlsCredentialedSigner m_serverCredentials;
    protected TlsCertificate m_serverCertificate;
    protected TlsAgreement m_agreement;
    public bool RequiresServerKeyExchange { get; }
    public TlsECDheKeyExchange(int keyExchange);
    public TlsECDheKeyExchange(int keyExchange, TlsECConfig ecConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
    protected virtual void GenerateEphemeral(Stream output);
    protected virtual void ProcessEphemeral(Byte[] point);
}
public class Org.BouncyCastle.Tls.TlsECDHKeyExchange : AbstractTlsKeyExchange {
    protected TlsCredentialedAgreement m_agreementCredentials;
    protected TlsCertificate m_ecdhPeerCertificate;
    public bool RequiresCertificateVerify { get; }
    public TlsECDHKeyExchange(int keyExchange);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void SkipClientCredentials();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual bool get_RequiresCertificateVerify();
    public virtual TlsSecret GeneratePreMasterSecret();
}
public class Org.BouncyCastle.Tls.TlsException : IOException {
    public TlsException(string message);
    public TlsException(string message, Exception innerException);
    protected TlsException(SerializationInfo info, StreamingContext context);
}
public static class Org.BouncyCastle.Tls.TlsExtensionsUtilities : object {
    public static IDictionary`2<int, Byte[]> EnsureExtensionsInitialised(IDictionary`2<int, Byte[]> extensions);
    public static void AddAlpnExtensionClient(IDictionary`2<int, Byte[]> extensions, IList`1<ProtocolName> protocolNameList);
    public static void AddAlpnExtensionServer(IDictionary`2<int, Byte[]> extensions, ProtocolName protocolName);
    public static void AddCertificateAuthoritiesExtension(IDictionary`2<int, Byte[]> extensions, IList`1<X509Name> authorities);
    public static void AddClientCertificateTypeExtensionClient(IDictionary`2<int, Byte[]> extensions, Int16[] certificateTypes);
    public static void AddClientCertificateTypeExtensionServer(IDictionary`2<int, Byte[]> extensions, short certificateType);
    public static void AddClientCertificateUrlExtension(IDictionary`2<int, Byte[]> extensions);
    public static void AddCompressCertificateExtension(IDictionary`2<int, Byte[]> extensions, Int32[] algorithms);
    public static void AddConnectionIDExtension(IDictionary`2<int, Byte[]> extensions, Byte[] connectionID);
    public static void AddCookieExtension(IDictionary`2<int, Byte[]> extensions, Byte[] cookie);
    public static void AddEarlyDataIndication(IDictionary`2<int, Byte[]> extensions);
    public static void AddEarlyDataMaxSize(IDictionary`2<int, Byte[]> extensions, long maxSize);
    public static void AddEmptyExtensionData(IDictionary`2<int, Byte[]> extensions, int extType);
    public static void AddEncryptThenMacExtension(IDictionary`2<int, Byte[]> extensions);
    public static void AddExtendedMasterSecretExtension(IDictionary`2<int, Byte[]> extensions);
    public static void AddHeartbeatExtension(IDictionary`2<int, Byte[]> extensions, HeartbeatExtension heartbeatExtension);
    public static void AddKeyShareClientHello(IDictionary`2<int, Byte[]> extensions, IList`1<KeyShareEntry> clientShares);
    public static void AddKeyShareHelloRetryRequest(IDictionary`2<int, Byte[]> extensions, int namedGroup);
    public static void AddKeyShareServerHello(IDictionary`2<int, Byte[]> extensions, KeyShareEntry serverShare);
    public static void AddMaxFragmentLengthExtension(IDictionary`2<int, Byte[]> extensions, short maxFragmentLength);
    public static void AddOidFiltersExtension(IDictionary`2<int, Byte[]> extensions, IDictionary`2<DerObjectIdentifier, Byte[]> filters);
    public static void AddPaddingExtension(IDictionary`2<int, Byte[]> extensions, int dataLength);
    public static void AddPostHandshakeAuthExtension(IDictionary`2<int, Byte[]> extensions);
    public static void AddPreSharedKeyClientHello(IDictionary`2<int, Byte[]> extensions, OfferedPsks offeredPsks);
    public static void AddPreSharedKeyServerHello(IDictionary`2<int, Byte[]> extensions, int selectedIdentity);
    public static void AddPskKeyExchangeModesExtension(IDictionary`2<int, Byte[]> extensions, Int16[] modes);
    public static void AddRecordSizeLimitExtension(IDictionary`2<int, Byte[]> extensions, int recordSizeLimit);
    public static void AddServerCertificateTypeExtensionClient(IDictionary`2<int, Byte[]> extensions, Int16[] certificateTypes);
    public static void AddServerCertificateTypeExtensionServer(IDictionary`2<int, Byte[]> extensions, short certificateType);
    public static void AddServerNameExtensionClient(IDictionary`2<int, Byte[]> extensions, IList`1<ServerName> serverNameList);
    public static void AddServerNameExtensionServer(IDictionary`2<int, Byte[]> extensions);
    public static void AddSignatureAlgorithmsExtension(IDictionary`2<int, Byte[]> extensions, IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms);
    public static void AddSignatureAlgorithmsCertExtension(IDictionary`2<int, Byte[]> extensions, IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms);
    public static void AddStatusRequestExtension(IDictionary`2<int, Byte[]> extensions, CertificateStatusRequest statusRequest);
    public static void AddStatusRequestV2Extension(IDictionary`2<int, Byte[]> extensions, IList`1<CertificateStatusRequestItemV2> statusRequestV2);
    public static void AddSupportedGroupsExtension(IDictionary`2<int, Byte[]> extensions, IList`1<int> namedGroups);
    public static void AddSupportedPointFormatsExtension(IDictionary`2<int, Byte[]> extensions, Int16[] ecPointFormats);
    public static void AddSupportedVersionsExtensionClient(IDictionary`2<int, Byte[]> extensions, ProtocolVersion[] versions);
    public static void AddSupportedVersionsExtensionServer(IDictionary`2<int, Byte[]> extensions, ProtocolVersion selectedVersion);
    public static void AddTruncatedHmacExtension(IDictionary`2<int, Byte[]> extensions);
    public static void AddTrustedCAKeysExtensionClient(IDictionary`2<int, Byte[]> extensions, IList`1<TrustedAuthority> trustedAuthoritiesList);
    public static void AddTrustedCAKeysExtensionServer(IDictionary`2<int, Byte[]> extensions);
    public static IList`1<ProtocolName> GetAlpnExtensionClient(IDictionary`2<int, Byte[]> extensions);
    public static ProtocolName GetAlpnExtensionServer(IDictionary`2<int, Byte[]> extensions);
    public static IList`1<X509Name> GetCertificateAuthoritiesExtension(IDictionary`2<int, Byte[]> extensions);
    public static Int16[] GetClientCertificateTypeExtensionClient(IDictionary`2<int, Byte[]> extensions);
    public static short GetClientCertificateTypeExtensionServer(IDictionary`2<int, Byte[]> extensions, short defaultValue);
    public static Int32[] GetCompressCertificateExtension(IDictionary`2<int, Byte[]> extensions);
    public static Byte[] GetConnectionIDExtension(IDictionary`2<int, Byte[]> extensions);
    public static Byte[] GetCookieExtension(IDictionary`2<int, Byte[]> extensions);
    public static long GetEarlyDataMaxSize(IDictionary`2<int, Byte[]> extensions);
    public static HeartbeatExtension GetHeartbeatExtension(IDictionary`2<int, Byte[]> extensions);
    public static IList`1<KeyShareEntry> GetKeyShareClientHello(IDictionary`2<int, Byte[]> extensions);
    public static int GetKeyShareHelloRetryRequest(IDictionary`2<int, Byte[]> extensions);
    public static KeyShareEntry GetKeyShareServerHello(IDictionary`2<int, Byte[]> extensions);
    public static short GetMaxFragmentLengthExtension(IDictionary`2<int, Byte[]> extensions);
    public static IDictionary`2<DerObjectIdentifier, Byte[]> GetOidFiltersExtension(IDictionary`2<int, Byte[]> extensions);
    public static int GetPaddingExtension(IDictionary`2<int, Byte[]> extensions);
    public static OfferedPsks GetPreSharedKeyClientHello(IDictionary`2<int, Byte[]> extensions);
    public static int GetPreSharedKeyServerHello(IDictionary`2<int, Byte[]> extensions);
    public static Int16[] GetPskKeyExchangeModesExtension(IDictionary`2<int, Byte[]> extensions);
    public static int GetRecordSizeLimitExtension(IDictionary`2<int, Byte[]> extensions);
    public static Int16[] GetServerCertificateTypeExtensionClient(IDictionary`2<int, Byte[]> extensions);
    public static short GetServerCertificateTypeExtensionServer(IDictionary`2<int, Byte[]> extensions, short defaultValue);
    public static IList`1<ServerName> GetServerNameExtensionClient(IDictionary`2<int, Byte[]> extensions);
    public static IList`1<SignatureAndHashAlgorithm> GetSignatureAlgorithmsExtension(IDictionary`2<int, Byte[]> extensions);
    public static IList`1<SignatureAndHashAlgorithm> GetSignatureAlgorithmsCertExtension(IDictionary`2<int, Byte[]> extensions);
    public static CertificateStatusRequest GetStatusRequestExtension(IDictionary`2<int, Byte[]> extensions);
    public static IList`1<CertificateStatusRequestItemV2> GetStatusRequestV2Extension(IDictionary`2<int, Byte[]> extensions);
    public static Int32[] GetSupportedGroupsExtension(IDictionary`2<int, Byte[]> extensions);
    public static Int16[] GetSupportedPointFormatsExtension(IDictionary`2<int, Byte[]> extensions);
    public static ProtocolVersion[] GetSupportedVersionsExtensionClient(IDictionary`2<int, Byte[]> extensions);
    public static ProtocolVersion GetSupportedVersionsExtensionServer(IDictionary`2<int, Byte[]> extensions);
    public static IList`1<TrustedAuthority> GetTrustedCAKeysExtensionClient(IDictionary`2<int, Byte[]> extensions);
    public static bool HasClientCertificateUrlExtension(IDictionary`2<int, Byte[]> extensions);
    public static bool HasEarlyDataIndication(IDictionary`2<int, Byte[]> extensions);
    public static bool HasEncryptThenMacExtension(IDictionary`2<int, Byte[]> extensions);
    public static bool HasExtendedMasterSecretExtension(IDictionary`2<int, Byte[]> extensions);
    public static bool HasServerNameExtensionServer(IDictionary`2<int, Byte[]> extensions);
    public static bool HasPostHandshakeAuthExtension(IDictionary`2<int, Byte[]> extensions);
    public static bool HasTruncatedHmacExtension(IDictionary`2<int, Byte[]> extensions);
    public static bool HasTrustedCAKeysExtensionServer(IDictionary`2<int, Byte[]> extensions);
    public static Byte[] CreateAlpnExtensionClient(IList`1<ProtocolName> protocolNameList);
    public static Byte[] CreateAlpnExtensionServer(ProtocolName protocolName);
    public static Byte[] CreateCertificateAuthoritiesExtension(IList`1<X509Name> authorities);
    public static Byte[] CreateCertificateTypeExtensionClient(Int16[] certificateTypes);
    public static Byte[] CreateCertificateTypeExtensionServer(short certificateType);
    public static Byte[] CreateClientCertificateUrlExtension();
    public static Byte[] CreateCompressCertificateExtension(Int32[] algorithms);
    public static Byte[] CreateConnectionIDExtension(Byte[] connectionID);
    public static Byte[] CreateCookieExtension(Byte[] cookie);
    public static Byte[] CreateEarlyDataIndication();
    public static Byte[] CreateEarlyDataMaxSize(long maxSize);
    public static Byte[] CreateEmptyExtensionData();
    public static Byte[] CreateEncryptThenMacExtension();
    public static Byte[] CreateExtendedMasterSecretExtension();
    public static Byte[] CreateHeartbeatExtension(HeartbeatExtension heartbeatExtension);
    public static Byte[] CreateKeyShareClientHello(IList`1<KeyShareEntry> clientShares);
    public static Byte[] CreateKeyShareHelloRetryRequest(int namedGroup);
    public static Byte[] CreateKeyShareServerHello(KeyShareEntry serverShare);
    public static Byte[] CreateMaxFragmentLengthExtension(short maxFragmentLength);
    public static Byte[] CreateOidFiltersExtension(IDictionary`2<DerObjectIdentifier, Byte[]> filters);
    public static Byte[] CreatePaddingExtension(int dataLength);
    public static Byte[] CreatePostHandshakeAuthExtension();
    public static Byte[] CreatePreSharedKeyClientHello(OfferedPsks offeredPsks);
    public static Byte[] CreatePreSharedKeyServerHello(int selectedIdentity);
    public static Byte[] CreatePskKeyExchangeModesExtension(Int16[] modes);
    public static Byte[] CreateRecordSizeLimitExtension(int recordSizeLimit);
    public static Byte[] CreateServerNameExtensionClient(IList`1<ServerName> serverNameList);
    public static Byte[] CreateServerNameExtensionServer();
    public static Byte[] CreateSignatureAlgorithmsExtension(IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms);
    public static Byte[] CreateSignatureAlgorithmsCertExtension(IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms);
    public static Byte[] CreateStatusRequestExtension(CertificateStatusRequest statusRequest);
    public static Byte[] CreateStatusRequestV2Extension(IList`1<CertificateStatusRequestItemV2> statusRequestV2);
    public static Byte[] CreateSupportedGroupsExtension(IList`1<int> namedGroups);
    public static Byte[] CreateSupportedPointFormatsExtension(Int16[] ecPointFormats);
    public static Byte[] CreateSupportedVersionsExtensionClient(ProtocolVersion[] versions);
    public static Byte[] CreateSupportedVersionsExtensionServer(ProtocolVersion selectedVersion);
    public static Byte[] CreateTruncatedHmacExtension();
    public static Byte[] CreateTrustedCAKeysExtensionClient(IList`1<TrustedAuthority> trustedAuthoritiesList);
    public static Byte[] CreateTrustedCAKeysExtensionServer();
    private static bool ReadEmptyExtensionData(Byte[] extensionData);
    public static IList`1<ProtocolName> ReadAlpnExtensionClient(Byte[] extensionData);
    public static ProtocolName ReadAlpnExtensionServer(Byte[] extensionData);
    public static IList`1<X509Name> ReadCertificateAuthoritiesExtension(Byte[] extensionData);
    public static Int16[] ReadCertificateTypeExtensionClient(Byte[] extensionData);
    public static short ReadCertificateTypeExtensionServer(Byte[] extensionData);
    public static bool ReadClientCertificateUrlExtension(Byte[] extensionData);
    public static Int32[] ReadCompressCertificateExtension(Byte[] extensionData);
    public static Byte[] ReadConnectionIDExtension(Byte[] extensionData);
    public static Byte[] ReadCookieExtension(Byte[] extensionData);
    public static bool ReadEarlyDataIndication(Byte[] extensionData);
    public static long ReadEarlyDataMaxSize(Byte[] extensionData);
    public static bool ReadEncryptThenMacExtension(Byte[] extensionData);
    public static bool ReadExtendedMasterSecretExtension(Byte[] extensionData);
    public static HeartbeatExtension ReadHeartbeatExtension(Byte[] extensionData);
    public static IList`1<KeyShareEntry> ReadKeyShareClientHello(Byte[] extensionData);
    public static int ReadKeyShareHelloRetryRequest(Byte[] extensionData);
    public static KeyShareEntry ReadKeyShareServerHello(Byte[] extensionData);
    public static short ReadMaxFragmentLengthExtension(Byte[] extensionData);
    public static IDictionary`2<DerObjectIdentifier, Byte[]> ReadOidFiltersExtension(Byte[] extensionData);
    public static int ReadPaddingExtension(Byte[] extensionData);
    public static bool ReadPostHandshakeAuthExtension(Byte[] extensionData);
    public static OfferedPsks ReadPreSharedKeyClientHello(Byte[] extensionData);
    public static int ReadPreSharedKeyServerHello(Byte[] extensionData);
    public static Int16[] ReadPskKeyExchangeModesExtension(Byte[] extensionData);
    public static int ReadRecordSizeLimitExtension(Byte[] extensionData);
    public static IList`1<ServerName> ReadServerNameExtensionClient(Byte[] extensionData);
    public static bool ReadServerNameExtensionServer(Byte[] extensionData);
    public static IList`1<SignatureAndHashAlgorithm> ReadSignatureAlgorithmsExtension(Byte[] extensionData);
    public static IList`1<SignatureAndHashAlgorithm> ReadSignatureAlgorithmsCertExtension(Byte[] extensionData);
    public static CertificateStatusRequest ReadStatusRequestExtension(Byte[] extensionData);
    public static IList`1<CertificateStatusRequestItemV2> ReadStatusRequestV2Extension(Byte[] extensionData);
    public static Int32[] ReadSupportedGroupsExtension(Byte[] extensionData);
    public static Int16[] ReadSupportedPointFormatsExtension(Byte[] extensionData);
    public static ProtocolVersion[] ReadSupportedVersionsExtensionClient(Byte[] extensionData);
    public static ProtocolVersion ReadSupportedVersionsExtensionServer(Byte[] extensionData);
    public static bool ReadTruncatedHmacExtension(Byte[] extensionData);
    public static IList`1<TrustedAuthority> ReadTrustedCAKeysExtensionClient(Byte[] extensionData);
    public static bool ReadTrustedCAKeysExtensionServer(Byte[] extensionData);
    private static Byte[] PatchOpaque16(MemoryStream buf);
}
public class Org.BouncyCastle.Tls.TlsFatalAlert : TlsException {
    protected byte m_alertDescription;
    public short AlertDescription { get; }
    public TlsFatalAlert(short alertDescription);
    public TlsFatalAlert(short alertDescription, string detailMessage);
    public TlsFatalAlert(short alertDescription, Exception alertCause);
    public TlsFatalAlert(short alertDescription, string detailMessage, Exception alertCause);
    protected TlsFatalAlert(SerializationInfo info, StreamingContext context);
    private static string GetMessage(short alertDescription, string detailMessage);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual short get_AlertDescription();
}
public class Org.BouncyCastle.Tls.TlsFatalAlertReceived : TlsException {
    protected byte m_alertDescription;
    public short AlertDescription { get; }
    public TlsFatalAlertReceived(short alertDescription);
    protected TlsFatalAlertReceived(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual short get_AlertDescription();
}
public interface Org.BouncyCastle.Tls.TlsHandshakeHash {
    public abstract virtual void CopyBufferTo(Stream output);
    public abstract virtual void ForceBuffering();
    public abstract virtual void NotifyPrfDetermined();
    public abstract virtual void TrackHashAlgorithm(int cryptoHashAlgorithm);
    public abstract virtual void SealHashAlgorithms();
    public abstract virtual void StopTracking();
    public abstract virtual TlsHash ForkPrfHash();
    public abstract virtual Byte[] GetFinalHash(int cryptoHashAlgorithm);
}
public interface Org.BouncyCastle.Tls.TlsHeartbeat {
    public int IdleMillis { get; }
    public int TimeoutMillis { get; }
    public abstract virtual Byte[] GeneratePayload();
    public abstract virtual int get_IdleMillis();
    public abstract virtual int get_TimeoutMillis();
}
public interface Org.BouncyCastle.Tls.TlsKeyExchange {
    public bool RequiresServerKeyExchange { get; }
    public bool RequiresCertificateVerify { get; }
    public abstract virtual void Init(TlsContext context);
    public abstract virtual void SkipServerCredentials();
    public abstract virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public abstract virtual void ProcessServerCertificate(Certificate serverCertificate);
    public abstract virtual bool get_RequiresServerKeyExchange();
    public abstract virtual Byte[] GenerateServerKeyExchange();
    public abstract virtual void SkipServerKeyExchange();
    public abstract virtual void ProcessServerKeyExchange(Stream input);
    public abstract virtual Int16[] GetClientCertificateTypes();
    public abstract virtual void SkipClientCredentials();
    public abstract virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public abstract virtual void ProcessClientCertificate(Certificate clientCertificate);
    public abstract virtual void GenerateClientKeyExchange(Stream output);
    public abstract virtual void ProcessClientKeyExchange(Stream input);
    public abstract virtual bool get_RequiresCertificateVerify();
    public abstract virtual TlsSecret GeneratePreMasterSecret();
}
public interface Org.BouncyCastle.Tls.TlsKeyExchangeFactory {
    public abstract virtual TlsKeyExchange CreateDHKeyExchange(int keyExchange);
    public abstract virtual TlsKeyExchange CreateDHanonKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public abstract virtual TlsKeyExchange CreateDHanonKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public abstract virtual TlsKeyExchange CreateDheKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public abstract virtual TlsKeyExchange CreateDheKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public abstract virtual TlsKeyExchange CreateECDHKeyExchange(int keyExchange);
    public abstract virtual TlsKeyExchange CreateECDHanonKeyExchangeClient(int keyExchange);
    public abstract virtual TlsKeyExchange CreateECDHanonKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public abstract virtual TlsKeyExchange CreateECDheKeyExchangeClient(int keyExchange);
    public abstract virtual TlsKeyExchange CreateECDheKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public abstract virtual TlsKeyExchange CreatePskKeyExchangeClient(int keyExchange, TlsPskIdentity pskIdentity, TlsDHGroupVerifier dhGroupVerifier);
    public abstract virtual TlsKeyExchange CreatePskKeyExchangeServer(int keyExchange, TlsPskIdentityManager pskIdentityManager, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    public abstract virtual TlsKeyExchange CreateRsaKeyExchange(int keyExchange);
    public abstract virtual TlsKeyExchange CreateSrpKeyExchangeClient(int keyExchange, TlsSrpIdentity srpIdentity, TlsSrpConfigVerifier srpConfigVerifier);
    public abstract virtual TlsKeyExchange CreateSrpKeyExchangeServer(int keyExchange, TlsSrpLoginParameters loginParameters);
}
public class Org.BouncyCastle.Tls.TlsNoCloseNotifyException : EndOfStreamException {
    protected TlsNoCloseNotifyException(SerializationInfo info, StreamingContext context);
}
public abstract class Org.BouncyCastle.Tls.TlsObjectIdentifiers : object {
    public static DerObjectIdentifier id_pe_tlsfeature;
    private static TlsObjectIdentifiers();
}
public interface Org.BouncyCastle.Tls.TlsPeer {
    public TlsCrypto Crypto { get; }
    public bool IgnoreCorruptDtlsRecords { get; }
    public abstract virtual TlsCrypto get_Crypto();
    public abstract virtual void NotifyCloseHandle(TlsCloseable closehandle);
    public abstract virtual void Cancel();
    public abstract virtual ProtocolVersion[] GetProtocolVersions();
    public abstract virtual Int32[] GetCipherSuites();
    public abstract virtual void NotifyHandshakeBeginning();
    public abstract virtual int GetHandshakeTimeoutMillis();
    public abstract virtual bool AllowLegacyResumption();
    public abstract virtual int GetMaxCertificateChainLength();
    public abstract virtual int GetMaxHandshakeMessageSize();
    public abstract virtual Int16[] GetPskKeyExchangeModes();
    public abstract virtual bool RequiresCloseNotify();
    public abstract virtual bool RequiresExtendedMasterSecret();
    public abstract virtual bool ShouldUseExtendedMasterSecret();
    public abstract virtual bool ShouldUseExtendedPadding();
    public abstract virtual bool ShouldUseGmtUnixTime();
    public abstract virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public abstract virtual TlsKeyExchangeFactory GetKeyExchangeFactory();
    public abstract virtual void NotifyAlertRaised(short alertLevel, short alertDescription, string message, Exception cause);
    public abstract virtual void NotifyAlertReceived(short alertLevel, short alertDescription);
    public abstract virtual void NotifyHandshakeComplete();
    public abstract virtual TlsHeartbeat GetHeartbeat();
    public abstract virtual short GetHeartbeatPolicy();
    public abstract virtual bool get_IgnoreCorruptDtlsRecords();
}
public abstract class Org.BouncyCastle.Tls.TlsProtocol : object {
    protected static short CS_START;
    protected static short CS_CLIENT_HELLO;
    protected static short CS_SERVER_HELLO_RETRY_REQUEST;
    protected static short CS_CLIENT_HELLO_RETRY;
    protected static short CS_SERVER_HELLO;
    protected static short CS_SERVER_ENCRYPTED_EXTENSIONS;
    protected static short CS_SERVER_SUPPLEMENTAL_DATA;
    protected static short CS_SERVER_CERTIFICATE;
    protected static short CS_SERVER_CERTIFICATE_STATUS;
    protected static short CS_SERVER_CERTIFICATE_VERIFY;
    protected static short CS_SERVER_KEY_EXCHANGE;
    protected static short CS_SERVER_CERTIFICATE_REQUEST;
    protected static short CS_SERVER_HELLO_DONE;
    protected static short CS_CLIENT_END_OF_EARLY_DATA;
    protected static short CS_CLIENT_SUPPLEMENTAL_DATA;
    protected static short CS_CLIENT_CERTIFICATE;
    protected static short CS_CLIENT_KEY_EXCHANGE;
    protected static short CS_CLIENT_CERTIFICATE_VERIFY;
    protected static short CS_CLIENT_FINISHED;
    protected static short CS_SERVER_SESSION_TICKET;
    protected static short CS_SERVER_FINISHED;
    protected static short CS_END;
    protected static short ADS_MODE_1_Nsub1;
    protected static short ADS_MODE_0_N;
    protected static short ADS_MODE_0_N_FIRSTONLY;
    private ByteQueue m_applicationDataQueue;
    private ByteQueue m_alertQueue;
    private ByteQueue m_handshakeQueue;
    internal RecordStream m_recordStream;
    internal object m_recordWriteLock;
    private int m_maxHandshakeMessageSize;
    internal TlsHandshakeHash m_handshakeHash;
    private TlsStream m_tlsStream;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_closed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_failedWithError;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_appDataReady;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_appDataSplitEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_keyUpdateEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_keyUpdatePendingSend;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_resumableHandshake;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_appDataSplitMode;
    protected TlsSession m_tlsSession;
    protected SessionParameters m_sessionParameters;
    protected TlsSecret m_sessionMasterSecret;
    protected Byte[] m_retryCookie;
    protected int m_retryGroup;
    protected IDictionary`2<int, Byte[]> m_clientExtensions;
    protected IDictionary`2<int, Byte[]> m_serverExtensions;
    protected short m_connectionState;
    protected bool m_selectedPsk13;
    protected bool m_receivedChangeCipherSpec;
    protected bool m_expectSessionTicket;
    protected bool m_blocking;
    protected ByteQueueInputStream m_inputBuffers;
    protected ByteQueueOutputStream m_outputBuffer;
    protected TlsContext Context { get; }
    internal AbstractTlsContext ContextAdmin { get; }
    protected TlsPeer Peer { get; }
    public int ApplicationDataAvailable { get; }
    public int AppDataSplitMode { get; public set; }
    public bool IsResumableHandshake { get; public set; }
    public Stream Stream { get; }
    public int ApplicationDataLimit { get; }
    internal bool IsApplicationDataReady { get; }
    public bool IsClosed { get; }
    public bool IsConnected { get; }
    public bool IsHandshaking { get; }
    public TlsProtocol(Stream stream);
    public TlsProtocol(Stream input, Stream output);
    protected bool IsLegacyConnectionState();
    protected bool IsTlsV13ConnectionState();
    public virtual void ResumeHandshake();
    protected virtual void CloseConnection();
    protected abstract virtual TlsContext get_Context();
    internal abstract virtual AbstractTlsContext get_ContextAdmin();
    protected abstract virtual TlsPeer get_Peer();
    protected virtual void HandleAlertMessage(short alertLevel, short alertDescription);
    protected virtual void HandleAlertWarningMessage(short alertDescription);
    protected virtual void HandleChangeCipherSpecMessage();
    protected virtual void HandleClose(bool user_canceled);
    protected virtual void HandleException(short alertDescription, string message, Exception e);
    protected virtual void HandleFailure();
    protected abstract virtual void HandleHandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void ApplyMaxFragmentLengthExtension(short maxFragmentLength);
    protected virtual void CheckReceivedChangeCipherSpec(bool expected);
    protected virtual void BlockForHandshake();
    protected virtual void BeginHandshake();
    protected virtual void CleanupHandshake();
    protected virtual void CompleteHandshake();
    internal void ProcessRecord(short protocol, Byte[] buf, int off, int len);
    private void ProcessHandshakeQueue(ByteQueue queue);
    private void ProcessApplicationDataQueue();
    private void ProcessAlertQueue();
    private void ProcessChangeCipherSpec(Byte[] buf, int off, int len);
    public virtual int get_ApplicationDataAvailable();
    public virtual int ReadApplicationData(Byte[] buffer, int offset, int count);
    protected virtual RecordPreview SafePreviewRecordHeader(Byte[] recordHeader);
    protected virtual void SafeReadRecord();
    protected virtual bool SafeReadFullRecord(Byte[] input, int inputOff, int inputLen);
    protected virtual void SafeWriteRecord(short type, Byte[] buf, int offset, int len);
    public virtual void WriteApplicationData(Byte[] buffer, int offset, int count);
    public virtual int get_AppDataSplitMode();
    public virtual void set_AppDataSplitMode(int value);
    public virtual bool get_IsResumableHandshake();
    public virtual void set_IsResumableHandshake(bool value);
    internal void WriteHandshakeMessage(Byte[] buf, int off, int len);
    public virtual Stream get_Stream();
    public virtual void CloseInput();
    public virtual RecordPreview PreviewInputRecord(Byte[] recordHeader);
    public virtual int PreviewOutputRecord();
    public virtual RecordPreview PreviewOutputRecord(int applicationDataSize);
    public virtual void OfferInput(Byte[] input);
    public virtual void OfferInput(Byte[] input, int inputOff, int inputLen);
    public virtual int get_ApplicationDataLimit();
    public virtual int GetAvailableInputBytes();
    public virtual int ReadInput(Byte[] buf, int off, int len);
    public virtual int GetAvailableOutputBytes();
    public virtual int ReadOutput(Byte[] buffer, int offset, int length);
    protected virtual bool EstablishSession(TlsSession sessionToResume);
    protected virtual void InvalidateSession();
    protected virtual void ProcessFinishedMessage(MemoryStream buf);
    protected virtual void Process13FinishedMessage(MemoryStream buf);
    protected virtual void RaiseAlertFatal(short alertDescription, string message, Exception cause);
    protected virtual void RaiseAlertWarning(short alertDescription, string message);
    protected virtual void Receive13KeyUpdate(MemoryStream buf);
    protected virtual void SendCertificateMessage(Certificate certificate, Stream endPointHash);
    protected virtual void Send13CertificateMessage(Certificate certificate);
    protected virtual void Send13CertificateVerifyMessage(DigitallySigned certificateVerify);
    protected virtual void SendChangeCipherSpec();
    protected virtual void SendChangeCipherSpecMessage();
    protected virtual void SendFinishedMessage();
    protected virtual void Send13FinishedMessage();
    protected virtual void Send13KeyUpdate(bool updateRequested);
    protected virtual void SendSupplementalDataMessage(IList`1<SupplementalDataEntry> supplementalData);
    public virtual void Close();
    public virtual void Flush();
    internal bool get_IsApplicationDataReady();
    public virtual bool get_IsClosed();
    public virtual bool get_IsConnected();
    public virtual bool get_IsHandshaking();
    protected virtual short ProcessMaxFragmentLengthExtension(IDictionary`2<int, Byte[]> clientExtensions, IDictionary`2<int, Byte[]> serverExtensions, short alertDescription);
    protected virtual void RefuseRenegotiation();
    internal static void AssertEmpty(MemoryStream buf);
    internal static Byte[] CreateRandomBlock(bool useGmtUnixTime, TlsContext context);
    internal static Byte[] CreateRenegotiationInfo(Byte[] renegotiated_connection);
    internal static void EstablishMasterSecret(TlsContext context, TlsKeyExchange keyExchange);
    internal static IDictionary`2<int, Byte[]> ReadExtensions(MemoryStream input);
    internal static IDictionary`2<int, Byte[]> ReadExtensionsData(Byte[] extBytes);
    internal static IDictionary`2<int, Byte[]> ReadExtensionsData13(int handshakeType, Byte[] extBytes);
    internal static IDictionary`2<int, Byte[]> ReadExtensionsDataClientHello(Byte[] extBytes);
    internal static IList`1<SupplementalDataEntry> ReadSupplementalDataMessage(MemoryStream input);
    internal static void WriteExtensions(Stream output, IDictionary`2<int, Byte[]> extensions);
    internal static void WriteExtensions(Stream output, IDictionary`2<int, Byte[]> extensions, int bindersSize);
    internal static Byte[] WriteExtensionsData(IDictionary`2<int, Byte[]> extensions);
    internal static Byte[] WriteExtensionsData(IDictionary`2<int, Byte[]> extensions, int bindersSize);
    internal static void WriteExtensionsData(IDictionary`2<int, Byte[]> extensions, MemoryStream buf);
    internal static void WriteExtensionsData(IDictionary`2<int, Byte[]> extensions, MemoryStream buf, int bindersSize);
    internal static void WritePreSharedKeyExtension(MemoryStream buf, IDictionary`2<int, Byte[]> extensions, int bindersSize);
    internal static void WriteSelectedExtensions(Stream output, IDictionary`2<int, Byte[]> extensions, bool selectEmpty);
    internal static void WriteSupplementalData(Stream output, IList`1<SupplementalDataEntry> supplementalData);
}
public interface Org.BouncyCastle.Tls.TlsPsk {
    public Byte[] Identity { get; }
    public TlsSecret Key { get; }
    public int PrfAlgorithm { get; }
    public abstract virtual Byte[] get_Identity();
    public abstract virtual TlsSecret get_Key();
    public abstract virtual int get_PrfAlgorithm();
}
public interface Org.BouncyCastle.Tls.TlsPskExternal {
}
public interface Org.BouncyCastle.Tls.TlsPskIdentity {
    public abstract virtual void SkipIdentityHint();
    public abstract virtual void NotifyIdentityHint(Byte[] psk_identity_hint);
    public abstract virtual Byte[] GetPskIdentity();
    public abstract virtual Byte[] GetPsk();
}
public interface Org.BouncyCastle.Tls.TlsPskIdentityManager {
    public abstract virtual Byte[] GetHint();
    public abstract virtual Byte[] GetPsk(Byte[] identity);
}
public class Org.BouncyCastle.Tls.TlsPskKeyExchange : AbstractTlsKeyExchange {
    protected TlsPskIdentity m_pskIdentity;
    protected TlsPskIdentityManager m_pskIdentityManager;
    protected TlsDHGroupVerifier m_dhGroupVerifier;
    protected Byte[] m_psk_identity_hint;
    protected Byte[] m_psk;
    protected TlsDHConfig m_dhConfig;
    protected TlsECConfig m_ecConfig;
    protected TlsAgreement m_agreement;
    protected TlsCredentialedDecryptor m_serverCredentials;
    protected TlsEncryptor m_serverEncryptor;
    protected TlsSecret m_preMasterSecret;
    public bool RequiresServerKeyExchange { get; }
    public TlsPskKeyExchange(int keyExchange, TlsPskIdentity pskIdentity, TlsDHGroupVerifier dhGroupVerifier);
    public TlsPskKeyExchange(int keyExchange, TlsPskIdentityManager pskIdentityManager, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    private TlsPskKeyExchange(int keyExchange, TlsPskIdentity pskIdentity, TlsPskIdentityManager pskIdentityManager, TlsDHGroupVerifier dhGroupVerifier, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual bool get_RequiresServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
    protected virtual void GenerateEphemeralDH(Stream output);
    protected virtual void GenerateEphemeralECDH(Stream output);
    protected virtual Byte[] GenerateOtherSecret(int pskLength);
    protected virtual void ProcessEphemeralDH(Byte[] y);
    protected virtual void ProcessEphemeralECDH(Byte[] point);
}
public class Org.BouncyCastle.Tls.TlsRsaKeyExchange : AbstractTlsKeyExchange {
    protected TlsCredentialedDecryptor m_serverCredentials;
    protected TlsEncryptor m_serverEncryptor;
    protected TlsSecret m_preMasterSecret;
    public TlsRsaKeyExchange(int keyExchange);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
}
public interface Org.BouncyCastle.Tls.TlsServer {
    public abstract virtual void Init(TlsServerContext context);
    public abstract virtual TlsSession GetSessionToResume(Byte[] sessionID);
    public abstract virtual Byte[] GetNewSessionID();
    public abstract virtual TlsPskExternal GetExternalPsk(IList`1<PskIdentity> identities);
    public abstract virtual void NotifySession(TlsSession session);
    public abstract virtual void NotifyClientVersion(ProtocolVersion clientVersion);
    public abstract virtual void NotifyFallback(bool isFallback);
    public abstract virtual void NotifyOfferedCipherSuites(Int32[] offeredCipherSuites);
    public abstract virtual void ProcessClientExtensions(IDictionary`2<int, Byte[]> clientExtensions);
    public abstract virtual ProtocolVersion GetServerVersion();
    public abstract virtual Int32[] GetSupportedGroups();
    public abstract virtual int GetSelectedCipherSuite();
    public abstract virtual IDictionary`2<int, Byte[]> GetServerExtensions();
    public abstract virtual void GetServerExtensionsForConnection(IDictionary`2<int, Byte[]> serverExtensions);
    public abstract virtual IList`1<SupplementalDataEntry> GetServerSupplementalData();
    public abstract virtual TlsCredentials GetCredentials();
    public abstract virtual CertificateStatus GetCertificateStatus();
    public abstract virtual CertificateRequest GetCertificateRequest();
    public abstract virtual TlsPskIdentityManager GetPskIdentityManager();
    public abstract virtual TlsSrpLoginParameters GetSrpLoginParameters();
    public abstract virtual TlsDHConfig GetDHConfig();
    public abstract virtual TlsECConfig GetECDHConfig();
    public abstract virtual void ProcessClientSupplementalData(IList`1<SupplementalDataEntry> clientSupplementalData);
    public abstract virtual void NotifyClientCertificate(Certificate clientCertificate);
    public abstract virtual NewSessionTicket GetNewSessionTicket();
}
public interface Org.BouncyCastle.Tls.TlsServerCertificate {
    public Certificate Certificate { get; }
    public CertificateStatus CertificateStatus { get; }
    public abstract virtual Certificate get_Certificate();
    public abstract virtual CertificateStatus get_CertificateStatus();
}
internal class Org.BouncyCastle.Tls.TlsServerCertificateImpl : object {
    private Certificate m_certificate;
    private CertificateStatus m_certificateStatus;
    public Certificate Certificate { get; }
    public CertificateStatus CertificateStatus { get; }
    internal TlsServerCertificateImpl(Certificate certificate, CertificateStatus certificateStatus);
    public sealed virtual Certificate get_Certificate();
    public sealed virtual CertificateStatus get_CertificateStatus();
}
public interface Org.BouncyCastle.Tls.TlsServerContext {
}
internal class Org.BouncyCastle.Tls.TlsServerContextImpl : AbstractTlsContext {
    public bool IsServer { get; }
    internal TlsServerContextImpl(TlsCrypto crypto);
    public virtual bool get_IsServer();
}
public class Org.BouncyCastle.Tls.TlsServerProtocol : TlsProtocol {
    protected TlsServer m_tlsServer;
    internal TlsServerContextImpl m_tlsServerContext;
    protected Int32[] m_offeredCipherSuites;
    protected TlsKeyExchange m_keyExchange;
    protected CertificateRequest m_certificateRequest;
    protected TlsContext Context { get; }
    internal AbstractTlsContext ContextAdmin { get; }
    protected TlsPeer Peer { get; }
    public TlsServerProtocol(Stream stream);
    public TlsServerProtocol(Stream input, Stream output);
    public void Accept(TlsServer tlsServer);
    protected virtual void CleanupHandshake();
    protected virtual bool ExpectCertificateVerifyMessage();
    protected virtual ServerHello Generate13HelloRetryRequest(ClientHello clientHello);
    protected virtual ServerHello Generate13ServerHello(ClientHello clientHello, HandshakeMessageInput clientHelloMessage, bool afterHelloRetryRequest);
    protected virtual ServerHello GenerateServerHello(ClientHello clientHello, HandshakeMessageInput clientHelloMessage);
    protected virtual TlsContext get_Context();
    internal virtual AbstractTlsContext get_ContextAdmin();
    protected virtual TlsPeer get_Peer();
    protected virtual void Handle13HandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void HandleHandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void HandleAlertWarningMessage(short alertDescription);
    protected virtual void NotifyClientCertificate(Certificate clientCertificate);
    protected virtual void Receive13ClientCertificate(MemoryStream buf);
    protected void Receive13ClientCertificateVerify(MemoryStream buf);
    protected virtual void Receive13ClientFinished(MemoryStream buf);
    protected virtual void ReceiveCertificateMessage(MemoryStream buf);
    protected virtual void ReceiveCertificateVerifyMessage(MemoryStream buf);
    protected virtual ClientHello ReceiveClientHelloMessage(MemoryStream buf);
    protected virtual void ReceiveClientKeyExchangeMessage(MemoryStream buf);
    protected virtual void Send13EncryptedExtensionsMessage(IDictionary`2<int, Byte[]> serverExtensions);
    protected virtual void Send13ServerHelloCoda(ServerHello serverHello, bool afterHelloRetryRequest);
    protected virtual void SendCertificateRequestMessage(CertificateRequest certificateRequest);
    protected virtual void SendCertificateStatusMessage(CertificateStatus certificateStatus);
    protected virtual void SendHelloRequestMessage();
    protected virtual void SendNewSessionTicketMessage(NewSessionTicket newSessionTicket);
    protected virtual void SendServerHelloDoneMessage();
    protected virtual void SendServerHelloMessage(ServerHello serverHello);
    protected virtual void SendServerKeyExchangeMessage(Byte[] serverKeyExchange);
    protected virtual void Skip13ClientCertificate();
    protected virtual void Skip13ClientCertificateVerify();
}
public interface Org.BouncyCastle.Tls.TlsSession {
    public Byte[] SessionID { get; }
    public bool IsResumable { get; }
    public abstract virtual SessionParameters ExportSessionParameters();
    public abstract virtual Byte[] get_SessionID();
    public abstract virtual void Invalidate();
    public abstract virtual bool get_IsResumable();
}
internal class Org.BouncyCastle.Tls.TlsSessionImpl : object {
    private Byte[] m_sessionID;
    private SessionParameters m_sessionParameters;
    private bool m_resumable;
    public Byte[] SessionID { get; }
    public bool IsResumable { get; }
    internal TlsSessionImpl(Byte[] sessionID, SessionParameters sessionParameters);
    public sealed virtual SessionParameters ExportSessionParameters();
    public sealed virtual Byte[] get_SessionID();
    public sealed virtual void Invalidate();
    public sealed virtual bool get_IsResumable();
}
public interface Org.BouncyCastle.Tls.TlsSrpConfigVerifier {
    public abstract virtual bool Accept(TlsSrpConfig srpConfig);
}
public interface Org.BouncyCastle.Tls.TlsSrpIdentity {
    public abstract virtual Byte[] GetSrpIdentity();
    public abstract virtual Byte[] GetSrpPassword();
}
public interface Org.BouncyCastle.Tls.TlsSrpIdentityManager {
    public abstract virtual TlsSrpLoginParameters GetLoginParameters(Byte[] identity);
}
public class Org.BouncyCastle.Tls.TlsSrpKeyExchange : AbstractTlsKeyExchange {
    protected TlsSrpIdentity m_srpIdentity;
    protected TlsSrpConfigVerifier m_srpConfigVerifier;
    protected TlsCertificate m_serverCertificate;
    protected Byte[] m_srpSalt;
    protected TlsSrp6Client m_srpClient;
    protected TlsSrpLoginParameters m_srpLoginParameters;
    protected TlsCredentialedSigner m_serverCredentials;
    protected TlsSrp6Server m_srpServer;
    protected BigInteger m_srpPeerCredentials;
    public bool RequiresServerKeyExchange { get; }
    public TlsSrpKeyExchange(int keyExchange, TlsSrpIdentity srpIdentity, TlsSrpConfigVerifier srpConfigVerifier);
    public TlsSrpKeyExchange(int keyExchange, TlsSrpLoginParameters srpLoginParameters);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
    protected static BigInteger ValidatePublicValue(BigInteger N, BigInteger val);
}
public class Org.BouncyCastle.Tls.TlsSrpLoginParameters : object {
    protected Byte[] m_identity;
    protected TlsSrpConfig m_srpConfig;
    protected BigInteger m_verifier;
    protected Byte[] m_salt;
    public TlsSrpConfig Config { get; }
    public Byte[] Identity { get; }
    public Byte[] Salt { get; }
    public BigInteger Verifier { get; }
    public TlsSrpLoginParameters(Byte[] identity, TlsSrpConfig srpConfig, BigInteger verifier, Byte[] salt);
    public virtual TlsSrpConfig get_Config();
    public virtual Byte[] get_Identity();
    public virtual Byte[] get_Salt();
    public virtual BigInteger get_Verifier();
}
public abstract class Org.BouncyCastle.Tls.TlsSrpUtilities : object {
    public static void AddSrpExtension(IDictionary`2<int, Byte[]> extensions, Byte[] identity);
    public static Byte[] GetSrpExtension(IDictionary`2<int, Byte[]> extensions);
    public static Byte[] CreateSrpExtension(Byte[] identity);
    public static Byte[] ReadSrpExtension(Byte[] extensionData);
    public static BigInteger ReadSrpParameter(Stream input);
    public static void WriteSrpParameter(BigInteger x, Stream output);
    public static bool IsSrpCipherSuite(int cipherSuite);
}
public abstract class Org.BouncyCastle.Tls.TlsSrtpUtilities : object {
    public static void AddUseSrtpExtension(IDictionary`2<int, Byte[]> extensions, UseSrtpData useSrtpData);
    public static UseSrtpData GetUseSrtpExtension(IDictionary`2<int, Byte[]> extensions);
    public static Byte[] CreateUseSrtpExtension(UseSrtpData useSrtpData);
    public static UseSrtpData ReadUseSrtpExtension(Byte[] extensionData);
}
internal class Org.BouncyCastle.Tls.TlsStream : Stream {
    private TlsProtocol m_handler;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal TlsStream(TlsProtocol handler);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class Org.BouncyCastle.Tls.TlsTimeoutException : IOException {
    public TlsTimeoutException(string message);
    public TlsTimeoutException(string message, Exception innerException);
    protected TlsTimeoutException(SerializationInfo info, StreamingContext context);
}
public abstract class Org.BouncyCastle.Tls.TlsUtilities : object {
    private static Byte[] DowngradeTlsV11;
    private static Byte[] DowngradeTlsV12;
    private static IDictionary`2<string, SignatureAndHashAlgorithm> CertSigAlgOids;
    private static IList`1<SignatureAndHashAlgorithm> DefaultSupportedSigAlgs;
    public static Byte[] EmptyBytes;
    public static Int16[] EmptyShorts;
    public static Int32[] EmptyInts;
    public static Int64[] EmptyLongs;
    public static String[] EmptyStrings;
    internal static short MinimumHashStrict;
    internal static short MinimumHashPreferred;
    private static TlsUtilities();
    private static void AddCertSigAlgOid(IDictionary`2<string, SignatureAndHashAlgorithm> d, DerObjectIdentifier oid, SignatureAndHashAlgorithm sigAndHash);
    private static void AddCertSigAlgOid(IDictionary`2<string, SignatureAndHashAlgorithm> d, DerObjectIdentifier oid, short hashAlgorithm, short signatureAlgorithm);
    private static IDictionary`2<string, SignatureAndHashAlgorithm> CreateCertSigAlgOids();
    private static IList`1<SignatureAndHashAlgorithm> CreateDefaultSupportedSigAlgs();
    public static void CheckUint8(short i);
    public static void CheckUint8(int i);
    public static void CheckUint8(long i);
    public static void CheckUint16(int i);
    public static void CheckUint16(long i);
    public static void CheckUint24(int i);
    public static void CheckUint24(long i);
    public static void CheckUint32(long i);
    public static void CheckUint48(long i);
    public static void CheckUint64(long i);
    public static bool IsValidUint8(short i);
    public static bool IsValidUint8(int i);
    public static bool IsValidUint8(long i);
    public static bool IsValidUint16(int i);
    public static bool IsValidUint16(long i);
    public static bool IsValidUint24(int i);
    public static bool IsValidUint24(long i);
    public static bool IsValidUint32(long i);
    public static bool IsValidUint48(long i);
    public static bool IsValidUint64(long i);
    public static bool IsSsl(TlsContext context);
    public static bool IsTlsV10(ProtocolVersion version);
    public static bool IsTlsV10(TlsContext context);
    public static bool IsTlsV11(ProtocolVersion version);
    public static bool IsTlsV11(TlsContext context);
    public static bool IsTlsV12(ProtocolVersion version);
    public static bool IsTlsV12(TlsContext context);
    public static bool IsTlsV13(ProtocolVersion version);
    public static bool IsTlsV13(TlsContext context);
    public static void WriteUint8(short i, Stream output);
    public static void WriteUint8(int i, Stream output);
    public static void WriteUint8(short i, Byte[] buf, int offset);
    public static void WriteUint8(int i, Byte[] buf, int offset);
    public static void WriteUint16(int i, Stream output);
    public static void WriteUint16(int i, Byte[] buf, int offset);
    public static void WriteUint24(int i, Stream output);
    public static void WriteUint24(int i, Byte[] buf, int offset);
    public static void WriteUint32(long i, Stream output);
    public static void WriteUint32(long i, Byte[] buf, int offset);
    public static void WriteUint48(long i, Stream output);
    public static void WriteUint48(long i, Byte[] buf, int offset);
    public static void WriteUint64(long i, Stream output);
    public static void WriteUint64(long i, Byte[] buf, int offset);
    public static void WriteOpaque8(Byte[] buf, Stream output);
    public static void WriteOpaque8(Byte[] data, Byte[] buf, int off);
    public static void WriteOpaque16(Byte[] buf, Stream output);
    public static void WriteOpaque16(Byte[] data, Byte[] buf, int off);
    public static void WriteOpaque24(Byte[] buf, Stream output);
    public static void WriteOpaque24(Byte[] data, Byte[] buf, int off);
    public static void WriteUint8Array(Int16[] u8s, Stream output);
    public static void WriteUint8Array(Int16[] u8s, Byte[] buf, int offset);
    public static void WriteUint8ArrayWithUint8Length(Int16[] u8s, Stream output);
    public static void WriteUint8ArrayWithUint8Length(Int16[] u8s, Byte[] buf, int offset);
    public static void WriteUint16Array(Int32[] u16s, Stream output);
    public static void WriteUint16Array(Int32[] u16s, Byte[] buf, int offset);
    public static void WriteUint16ArrayWithUint8Length(Int32[] u16s, Byte[] buf, int offset);
    public static void WriteUint16ArrayWithUint16Length(Int32[] u16s, Stream output);
    public static void WriteUint16ArrayWithUint16Length(Int32[] u16s, Byte[] buf, int offset);
    public static Byte[] DecodeOpaque8(Byte[] buf);
    public static Byte[] DecodeOpaque8(Byte[] buf, int minLength);
    public static Byte[] DecodeOpaque16(Byte[] buf);
    public static Byte[] DecodeOpaque16(Byte[] buf, int minLength);
    public static short DecodeUint8(Byte[] buf);
    public static Int16[] DecodeUint8ArrayWithUint8Length(Byte[] buf);
    public static int DecodeUint16(Byte[] buf);
    public static Int32[] DecodeUint16ArrayWithUint8Length(Byte[] buf);
    public static long DecodeUint32(Byte[] buf);
    public static Byte[] EncodeOpaque8(Byte[] buf);
    public static Byte[] EncodeOpaque16(Byte[] buf);
    public static Byte[] EncodeOpaque24(Byte[] buf);
    public static Byte[] EncodeUint8(short u8);
    public static Byte[] EncodeUint8ArrayWithUint8Length(Int16[] u8s);
    public static Byte[] EncodeUint16(int u16);
    public static Byte[] EncodeUint16ArrayWithUint8Length(Int32[] u16s);
    public static Byte[] EncodeUint16ArrayWithUint16Length(Int32[] u16s);
    public static Byte[] EncodeUint24(int u24);
    public static Byte[] EncodeUint32(long u32);
    public static Byte[] EncodeVersion(ProtocolVersion version);
    public static int ReadInt32(Byte[] buf, int offset);
    public static short ReadUint8(Stream input);
    public static short ReadUint8(Byte[] buf, int offset);
    public static int ReadUint16(Stream input);
    public static int ReadUint16(Byte[] buf, int offset);
    public static int ReadUint24(Stream input);
    public static int ReadUint24(Byte[] buf, int offset);
    public static long ReadUint32(Stream input);
    public static long ReadUint32(Byte[] buf, int offset);
    public static long ReadUint48(Stream input);
    public static long ReadUint48(Byte[] buf, int offset);
    public static Byte[] ReadAllOrNothing(int length, Stream input);
    public static Byte[] ReadFully(int length, Stream input);
    public static void ReadFully(Byte[] buf, Stream input);
    public static Byte[] ReadOpaque8(Stream input);
    public static Byte[] ReadOpaque8(Stream input, int minLength);
    public static Byte[] ReadOpaque8(Stream input, int minLength, int maxLength);
    public static Byte[] ReadOpaque16(Stream input);
    public static Byte[] ReadOpaque16(Stream input, int minLength);
    public static Byte[] ReadOpaque24(Stream input);
    public static Byte[] ReadOpaque24(Stream input, int minLength);
    public static Int16[] ReadUint8Array(int count, Stream input);
    public static Int16[] ReadUint8ArrayWithUint8Length(Stream input, int minLength);
    public static Int32[] ReadUint16Array(int count, Stream input);
    public static ProtocolVersion ReadVersion(Byte[] buf, int offset);
    public static ProtocolVersion ReadVersion(Stream input);
    public static Asn1Object ReadAsn1Object(Byte[] encoding);
    public static void RequireDerEncoding(Asn1Encodable asn1, Byte[] encoding);
    public static void WriteGmtUnixTime(Byte[] buf, int offset);
    public static void WriteVersion(ProtocolVersion version, Stream output);
    public static void WriteVersion(ProtocolVersion version, Byte[] buf, int offset);
    public static void AddIfSupported(IList`1<SignatureAndHashAlgorithm> supportedAlgs, TlsCrypto crypto, SignatureAndHashAlgorithm alg);
    public static void AddIfSupported(IList`1<int> supportedGroups, TlsCrypto crypto, int namedGroup);
    public static void AddIfSupported(IList`1<int> supportedGroups, TlsCrypto crypto, Int32[] namedGroups);
    public static bool AddToSet(IList`1<T> s, T i);
    public static IList`1<SignatureAndHashAlgorithm> GetDefaultDssSignatureAlgorithms();
    public static IList`1<SignatureAndHashAlgorithm> GetDefaultECDsaSignatureAlgorithms();
    public static IList`1<SignatureAndHashAlgorithm> GetDefaultRsaSignatureAlgorithms();
    public static SignatureAndHashAlgorithm GetDefaultSignatureAlgorithm(short signatureAlgorithm);
    public static IList`1<SignatureAndHashAlgorithm> GetDefaultSignatureAlgorithms(short signatureAlgorithm);
    public static IList`1<SignatureAndHashAlgorithm> GetDefaultSupportedSignatureAlgorithms(TlsContext context);
    public static IList`1<SignatureAndHashAlgorithm> GetSupportedSignatureAlgorithms(TlsContext context, IList`1<SignatureAndHashAlgorithm> candidates);
    internal static SignatureAndHashAlgorithm GetSignatureAndHashAlgorithm(ProtocolVersion negotiatedVersion, TlsCredentialedSigner credentialedSigner);
    public static Byte[] GetExtensionData(IDictionary`2<int, Byte[]> extensions, int extensionType);
    public static bool HasExpectedEmptyExtensionData(IDictionary`2<int, Byte[]> extensions, int extensionType, short alertDescription);
    public static TlsSession ImportSession(Byte[] sessionID, SessionParameters sessionParameters);
    internal static bool IsExtendedMasterSecretOptionalDtls(ProtocolVersion[] activeProtocolVersions);
    internal static bool IsExtendedMasterSecretOptionalTls(ProtocolVersion[] activeProtocolVersions);
    public static bool IsNullOrContainsNull(Object[] array);
    public static bool IsNullOrEmpty(T[] array);
    public static bool IsNullOrEmpty(string s);
    public static bool IsNullOrEmpty(IList`1<T> v);
    public static bool IsSignatureAlgorithmsExtensionAllowed(ProtocolVersion version);
    public static short GetLegacyClientCertType(short signatureAlgorithm);
    public static short GetLegacySignatureAlgorithmClient(short clientCertificateType);
    public static short GetLegacySignatureAlgorithmClientCert(short clientCertificateType);
    public static short GetLegacySignatureAlgorithmServer(int keyExchangeAlgorithm);
    public static short GetLegacySignatureAlgorithmServerCert(int keyExchangeAlgorithm);
    public static IList`1<SignatureAndHashAlgorithm> GetLegacySupportedSignatureAlgorithms();
    public static void EncodeSupportedSignatureAlgorithms(IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms, Stream output);
    public static IList`1<SignatureAndHashAlgorithm> ParseSupportedSignatureAlgorithms(Stream input);
    public static void VerifySupportedSignatureAlgorithm(IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms, SignatureAndHashAlgorithm signatureAlgorithm);
    internal static void VerifySupportedSignatureAlgorithm(IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms, SignatureAndHashAlgorithm signatureAlgorithm, short alertDescription);
    public static bool ContainsSignatureAlgorithm(IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms, SignatureAndHashAlgorithm signatureAlgorithm);
    public static bool ContainsAnySignatureAlgorithm(IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms, short signatureAlgorithm);
    public static TlsSecret Prf(SecurityParameters securityParameters, TlsSecret secret, string asciiLabel, Byte[] seed, int length);
    public static Byte[] Clone(Byte[] data);
    public static String[] Clone(String[] s);
    public static bool ConstantTimeAreEqual(int len, Byte[] a, int aOff, Byte[] b, int bOff);
    public static Byte[] CopyOfRangeExact(Byte[] original, int from, int to);
    internal static Byte[] Concat(Byte[] a, Byte[] b);
    internal static Byte[] CalculateEndPointHash(TlsContext context, TlsCertificate certificate, Byte[] enc);
    internal static Byte[] CalculateEndPointHash(TlsContext context, TlsCertificate certificate, Byte[] enc, int encOff, int encLen);
    public static Byte[] CalculateExporterSeed(SecurityParameters securityParameters, Byte[] context);
    private static Byte[] CalculateFinishedHmac(SecurityParameters securityParameters, TlsSecret baseKey, Byte[] transcriptHash);
    private static Byte[] CalculateFinishedHmac(int prfCryptoHashAlgorithm, int prfHashLength, TlsSecret baseKey, Byte[] transcriptHash);
    internal static TlsSecret CalculateMasterSecret(TlsContext context, TlsSecret preMasterSecret);
    internal static Byte[] CalculatePskBinder(TlsCrypto crypto, bool isExternalPsk, int pskCryptoHashAlgorithm, TlsSecret earlySecret, Byte[] transcriptHash);
    internal static Byte[] CalculateVerifyData(TlsContext context, TlsHandshakeHash handshakeHash, bool isServer);
    internal static void Establish13PhaseSecrets(TlsContext context, TlsSecret pskEarlySecret, TlsSecret sharedSecret);
    private static void Establish13TrafficSecrets(TlsContext context, Byte[] transcriptHash, TlsSecret phaseSecret, string clientLabel, string serverLabel, RecordStream recordStream);
    internal static void Establish13PhaseApplication(TlsContext context, Byte[] serverFinishedTranscriptHash, RecordStream recordStream);
    internal static void Establish13PhaseEarly(TlsContext context, Byte[] clientHelloTranscriptHash, RecordStream recordStream);
    internal static void Establish13PhaseHandshake(TlsContext context, Byte[] serverHelloTranscriptHash, RecordStream recordStream);
    internal static void Update13TrafficSecretLocal(TlsContext context);
    internal static void Update13TrafficSecretPeer(TlsContext context);
    private static void Update13TrafficSecret(TlsContext context, bool forServer);
    private static TlsSecret Update13TrafficSecret(SecurityParameters securityParameters, TlsSecret secret);
    public static DerObjectIdentifier GetOidForHashAlgorithm(short hashAlgorithm);
    internal static int GetPrfAlgorithm(SecurityParameters securityParameters, int cipherSuite);
    internal static int GetPrfAlgorithm13(int cipherSuite);
    internal static Int32[] GetPrfAlgorithms13(Int32[] cipherSuites);
    internal static Byte[] CalculateSignatureHash(TlsContext context, SignatureAndHashAlgorithm algorithm, Byte[] extraSignatureInput, DigestInputBuffer buf);
    internal static void SendSignatureInput(TlsContext context, Byte[] extraSignatureInput, DigestInputBuffer buf, Stream output);
    internal static DigitallySigned GenerateCertificateVerifyClient(TlsClientContext clientContext, TlsCredentialedSigner clientAuthSigner, SignatureAndHashAlgorithm clientAuthAlgorithm, TlsStreamSigner clientAuthStreamSigner, TlsHandshakeHash handshakeHash);
    internal static DigitallySigned Generate13CertificateVerify(TlsContext context, TlsCredentialedSigner credentialedSigner, TlsHandshakeHash handshakeHash);
    private static Byte[] Generate13CertificateVerify(TlsCrypto crypto, TlsCredentialedSigner credentialedSigner, string contextString, TlsHandshakeHash handshakeHash, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    internal static void VerifyCertificateVerifyClient(TlsServerContext serverContext, CertificateRequest certificateRequest, DigitallySigned certificateVerify, TlsHandshakeHash handshakeHash);
    internal static void Verify13CertificateVerifyClient(TlsServerContext serverContext, TlsHandshakeHash handshakeHash, CertificateVerify certificateVerify);
    internal static void Verify13CertificateVerifyServer(TlsClientContext clientContext, TlsHandshakeHash handshakeHash, CertificateVerify certificateVerify);
    private static void Verify13CertificateVerify(IList`1<SignatureAndHashAlgorithm> supportedAlgorithms, string contextString, TlsHandshakeHash handshakeHash, TlsCertificate certificate, CertificateVerify certificateVerify);
    private static Byte[] GetCertificateVerifyHeader(string contextString);
    internal static void GenerateServerKeyExchangeSignature(TlsContext context, TlsCredentialedSigner credentials, Byte[] extraSignatureInput, DigestInputBuffer digestBuffer);
    internal static void VerifyServerKeyExchangeSignature(TlsContext context, Stream signatureInput, TlsCertificate serverCertificate, Byte[] extraSignatureInput, DigestInputBuffer digestBuffer);
    internal static void TrackHashAlgorithmClient(TlsHandshakeHash handshakeHash, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    internal static void TrackHashAlgorithms(TlsHandshakeHash handshakeHash, IList`1<SignatureAndHashAlgorithm> supportedSignatureAlgorithms);
    public static bool HasSigningCapability(short clientCertificateType);
    public static IList`1<T> VectorOfOne(T obj);
    public static int GetCipherType(int cipherSuite);
    public static int GetEncryptionAlgorithm(int cipherSuite);
    public static int GetEncryptionAlgorithmType(int encryptionAlgorithm);
    public static int GetKeyExchangeAlgorithm(int cipherSuite);
    public static IList`1<int> GetKeyExchangeAlgorithms(Int32[] cipherSuites);
    public static int GetMacAlgorithm(int cipherSuite);
    public static ProtocolVersion GetMinimumVersion(int cipherSuite);
    public static IList`1<int> GetNamedGroupRoles(Int32[] cipherSuites);
    public static IList`1<int> GetNamedGroupRoles(IList`1<int> keyExchangeAlgorithms);
    public static bool IsAeadCipherSuite(int cipherSuite);
    public static bool IsBlockCipherSuite(int cipherSuite);
    public static bool IsStreamCipherSuite(int cipherSuite);
    public static bool IsValidCipherSuiteForSignatureAlgorithms(int cipherSuite, IList`1<short> sigAlgs);
    internal static bool IsValidCipherSuiteSelection(Int32[] offeredCipherSuites, int cipherSuite);
    internal static bool IsValidKeyShareSelection(ProtocolVersion negotiatedVersion, Int32[] clientSupportedGroups, IDictionary`2<int, TlsAgreement> clientAgreements, int keyShareGroup);
    internal static bool IsValidSignatureAlgorithmForServerKeyExchange(short signatureAlgorithm, int keyExchangeAlgorithm);
    public static bool IsValidSignatureSchemeForServerKeyExchange(int signatureScheme, int keyExchangeAlgorithm);
    public static bool IsValidVersionForCipherSuite(int cipherSuite, ProtocolVersion version);
    public static SignatureAndHashAlgorithm ChooseSignatureAndHashAlgorithm(TlsContext context, IList`1<SignatureAndHashAlgorithm> sigHashAlgs, short signatureAlgorithm);
    public static SignatureAndHashAlgorithm ChooseSignatureAndHashAlgorithm(ProtocolVersion negotiatedVersion, IList`1<SignatureAndHashAlgorithm> sigHashAlgs, short signatureAlgorithm);
    public static IList`1<short> GetUsableSignatureAlgorithms(IList`1<SignatureAndHashAlgorithm> sigHashAlgs);
    public static int GetCommonCipherSuite13(ProtocolVersion negotiatedVersion, Int32[] peerCipherSuites, Int32[] localCipherSuites, bool useLocalOrder);
    public static Int32[] GetCommonCipherSuites(Int32[] peerCipherSuites, Int32[] localCipherSuites, bool useLocalOrder);
    public static Int32[] GetSupportedCipherSuites(TlsCrypto crypto, Int32[] suites);
    public static Int32[] GetSupportedCipherSuites(TlsCrypto crypto, Int32[] suites, int suitesOff, int suitesCount);
    public static bool IsSupportedCipherSuite(TlsCrypto crypto, int cipherSuite);
    public static bool IsSupportedKeyExchange(TlsCrypto crypto, int keyExchangeAlgorithm);
    internal static bool HasAnyRsaSigAlgs(TlsCrypto crypto);
    internal static Byte[] GetCurrentPrfHash(TlsHandshakeHash handshakeHash);
    private static TlsHash CreateHash(TlsCrypto crypto, short hashAlgorithm);
    private static TlsHash CreateHash(TlsCrypto crypto, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    private static TlsKeyExchange CreateKeyExchangeClient(TlsClient client, int keyExchange);
    private static TlsKeyExchange CreateKeyExchangeServer(TlsServer server, int keyExchange);
    internal static TlsKeyExchange InitKeyExchangeClient(TlsClientContext clientContext, TlsClient client);
    internal static TlsKeyExchange InitKeyExchangeServer(TlsServerContext serverContext, TlsServer server);
    internal static TlsCipher InitCipher(TlsContext context);
    public static void CheckPeerSigAlgs(TlsContext context, TlsCertificate[] peerCertPath);
    private static void CheckSigAlgOfClientCerts(TlsContext context, TlsCertificate[] clientCertPath);
    private static void CheckSigAlgOfServerCerts(TlsContext context, TlsCertificate[] serverCertPath);
    internal static void CheckTlsFeatures(Certificate serverCertificate, IDictionary`2<int, Byte[]> clientExtensions, IDictionary`2<int, Byte[]> serverExtensions);
    internal static void ProcessClientCertificate(TlsServerContext serverContext, Certificate clientCertificate, TlsKeyExchange keyExchange, TlsServer server);
    internal static void ProcessServerCertificate(TlsClientContext clientContext, CertificateStatus serverCertificateStatus, TlsKeyExchange keyExchange, TlsAuthentication clientAuthentication, IDictionary`2<int, Byte[]> clientExtensions, IDictionary`2<int, Byte[]> serverExtensions);
    internal static SignatureAndHashAlgorithm GetCertSigAndHashAlg(TlsCertificate subjectCert, TlsCertificate issuerCert);
    internal static CertificateRequest ValidateCertificateRequest(CertificateRequest certificateRequest, TlsKeyExchange keyExchange);
    internal static CertificateRequest NormalizeCertificateRequest(CertificateRequest certificateRequest, Int16[] validClientCertificateTypes);
    internal static bool Contains(Int32[] buf, int off, int len, int value);
    internal static bool ContainsAll(Int16[] container, Int16[] elements);
    internal static Int16[] RetainAll(Int16[] retainer, Int16[] elements);
    internal static Int16[] Truncate(Int16[] a, int n);
    internal static Int32[] Truncate(Int32[] a, int n);
    internal static TlsCredentialedAgreement RequireAgreementCredentials(TlsCredentials credentials);
    internal static TlsCredentialedDecryptor RequireDecryptorCredentials(TlsCredentials credentials);
    internal static TlsCredentialedSigner RequireSignerCredentials(TlsCredentials credentials);
    private static void CheckClientCertificateType(CertificateRequest certificateRequest, short clientCertificateType, short alertDescription);
    private static void CheckDowngradeMarker(Byte[] randomBlock, Byte[] downgradeMarker);
    internal static void CheckDowngradeMarker(ProtocolVersion version, Byte[] randomBlock);
    internal static void WriteDowngradeMarker(ProtocolVersion version, Byte[] randomBlock);
    internal static TlsAuthentication ReceiveServerCertificate(TlsClientContext clientContext, TlsClient client, MemoryStream buf, IDictionary`2<int, Byte[]> serverExtensions);
    internal static TlsAuthentication Receive13ServerCertificate(TlsClientContext clientContext, TlsClient client, MemoryStream buf, IDictionary`2<int, Byte[]> serverExtensions);
    internal static TlsAuthentication Skip13ServerCertificate(TlsClientContext clientContext);
    public static bool ContainsNonAscii(Byte[] bs);
    public static bool ContainsNonAscii(string s);
    internal static IDictionary`2<int, TlsAgreement> AddKeyShareToClientHello(TlsClientContext clientContext, TlsClient client, IDictionary`2<int, Byte[]> clientExtensions);
    internal static IDictionary`2<int, TlsAgreement> AddKeyShareToClientHelloRetry(TlsClientContext clientContext, IDictionary`2<int, Byte[]> clientExtensions, int keyShareGroup);
    private static void CollectKeyShares(TlsCrypto crypto, Int32[] supportedGroups, IList`1<int> keyShareGroups, IDictionary`2<int, TlsAgreement> clientAgreements, IList`1<KeyShareEntry> clientShares);
    internal static KeyShareEntry SelectKeyShare(IList`1<KeyShareEntry> clientShares, int keyShareGroup);
    internal static KeyShareEntry SelectKeyShare(TlsCrypto crypto, ProtocolVersion negotiatedVersion, IList`1<KeyShareEntry> clientShares, Int32[] clientSupportedGroups, Int32[] serverSupportedGroups);
    internal static int SelectKeyShareGroup(TlsCrypto crypto, ProtocolVersion negotiatedVersion, Int32[] clientSupportedGroups, Int32[] serverSupportedGroups);
    internal static Byte[] ReadEncryptedPms(TlsContext context, Stream input);
    internal static void WriteEncryptedPms(TlsContext context, Byte[] encryptedPms, Stream output);
    internal static Byte[] GetSessionID(TlsSession tlsSession);
    internal static void AdjustTranscriptForRetry(TlsHandshakeHash handshakeHash);
    internal static TlsCredentials EstablishClientCredentials(TlsAuthentication clientAuthentication, CertificateRequest certificateRequest);
    internal static TlsCredentialedSigner Establish13ClientCredentials(TlsAuthentication clientAuthentication, CertificateRequest certificateRequest);
    internal static void EstablishClientSigAlgs(SecurityParameters securityParameters, IDictionary`2<int, Byte[]> clientExtensions);
    internal static TlsCredentials EstablishServerCredentials(TlsServer server);
    internal static TlsCredentialedSigner Establish13ServerCredentials(TlsServer server);
    internal static void EstablishServerSigAlgs(SecurityParameters securityParameters, CertificateRequest certificateRequest);
    internal static TlsCredentials ValidateCredentials(TlsCredentials credentials);
    internal static TlsCredentialedSigner Validate13Credentials(TlsCredentials credentials);
    internal static void NegotiatedCipherSuite(SecurityParameters securityParameters, int cipherSuite);
    internal static void NegotiatedVersion(SecurityParameters securityParameters);
    internal static void NegotiatedVersionDtlsClient(TlsClientContext clientContext, TlsClient client);
    internal static void NegotiatedVersionDtlsServer(TlsServerContext serverContext);
    internal static void NegotiatedVersionTlsClient(TlsClientContext clientContext, TlsClient client);
    internal static void NegotiatedVersionTlsServer(TlsServerContext serverContext);
    internal static TlsSecret DeriveSecret(SecurityParameters securityParameters, TlsSecret secret, string label, Byte[] transcriptHash);
    internal static TlsSecret DeriveSecret(int prfCryptoHashAlgorithm, int prfHashLength, TlsSecret secret, string label, Byte[] transcriptHash);
    internal static TlsSecret GetSessionMasterSecret(TlsCrypto crypto, TlsSecret masterSecret);
    internal static bool IsPermittedExtensionType13(int handshakeType, int extensionType);
    internal static void CheckExtensionData13(IDictionary`2<int, Byte[]> extensions, int handshakeType, short alertDescription);
    public static TlsSecret GenerateEncryptedPreMasterSecret(TlsContext context, TlsEncryptor encryptor, Stream output);
    public static bool IsTimeout(SocketException e);
    internal static void AddPreSharedKeyToClientExtensions(TlsPsk[] psks, IDictionary`2<int, Byte[]> clientExtensions);
    internal static BindersConfig AddPreSharedKeyToClientHello(TlsClientContext clientContext, TlsClient client, IDictionary`2<int, Byte[]> clientExtensions, Int32[] offeredCipherSuites);
    internal static BindersConfig AddPreSharedKeyToClientHelloRetry(TlsClientContext clientContext, BindersConfig clientBinders, IDictionary`2<int, Byte[]> clientExtensions);
    internal static SelectedConfig SelectPreSharedKey(TlsServerContext serverContext, TlsServer server, IDictionary`2<int, Byte[]> clientHelloExtensions, HandshakeMessageInput clientHelloMessage, TlsHandshakeHash handshakeHash, bool afterHelloRetryRequest);
    internal static TlsSecret GetPskEarlySecret(TlsCrypto crypto, TlsPsk psk);
    internal static TlsSecret[] GetPskEarlySecrets(TlsCrypto crypto, TlsPsk[] psks);
    internal static TlsPskExternal[] GetPskExternalsClient(TlsClient client, Int32[] offeredCipherSuites);
    internal static IList`1<int> GetPskIndices(TlsPsk[] psks, int prfAlgorithm);
    internal static int GetHandshakeResendTimeMillis(TlsPeer tlsPeer);
}
public class Org.BouncyCastle.Tls.TrustedAuthority : object {
    private short m_identifierType;
    private object m_identifier;
    public short IdentifierType { get; }
    public object Identifier { get; }
    public X509Name X509Name { get; }
    public TrustedAuthority(short identifierType, object identifier);
    public short get_IdentifierType();
    public object get_Identifier();
    public Byte[] GetCertSha1Hash();
    public Byte[] GetKeySha1Hash();
    public X509Name get_X509Name();
    public void Encode(Stream output);
    public static TrustedAuthority Parse(Stream input);
    private void CheckCorrectType(short expectedIdentifierType);
    private static bool IsCorrectType(short identifierType, object identifier);
    private static bool IsSha1Hash(object identifier);
}
public class Org.BouncyCastle.Tls.UrlAndHash : object {
    private string m_url;
    private Byte[] m_sha1Hash;
    public string Url { get; }
    public Byte[] Sha1Hash { get; }
    public UrlAndHash(string url, Byte[] sha1Hash);
    public string get_Url();
    public Byte[] get_Sha1Hash();
    public void Encode(Stream output);
    public static UrlAndHash Parse(TlsContext context, Stream input);
}
public abstract class Org.BouncyCastle.Tls.UserMappingType : object {
    public static short upn_domain_hint;
}
public class Org.BouncyCastle.Tls.UseSrtpData : object {
    private Int32[] m_protectionProfiles;
    private Byte[] m_mki;
    public Int32[] ProtectionProfiles { get; }
    public Byte[] Mki { get; }
    public UseSrtpData(Int32[] protectionProfiles, Byte[] mki);
    public Int32[] get_ProtectionProfiles();
    public Byte[] get_Mki();
}
public class Org.BouncyCastle.Tsp.GenTimeAccuracy : object {
    private Accuracy accuracy;
    public int Seconds { get; }
    public int Millis { get; }
    public int Micros { get; }
    public GenTimeAccuracy(Accuracy accuracy);
    public int get_Seconds();
    public int get_Millis();
    public int get_Micros();
    private int GetTimeComponent(DerInteger time);
    public virtual string ToString();
}
public enum Org.BouncyCastle.Tsp.Resolution : Enum {
    public int value__;
    public static Resolution R_SECONDS;
    public static Resolution R_TENTHS_OF_SECONDS;
    public static Resolution R_HUNDREDTHS_OF_SECONDS;
    public static Resolution R_MILLISECONDS;
}
public class Org.BouncyCastle.Tsp.TimeStampRequest : X509ExtensionBase {
    private TimeStampReq req;
    private X509Extensions extensions;
    public int Version { get; }
    public string MessageImprintAlgOid { get; }
    public string ReqPolicy { get; }
    public BigInteger Nonce { get; }
    public bool CertReq { get; }
    internal X509Extensions Extensions { get; }
    public bool HasExtensions { get; }
    public TimeStampRequest(TimeStampReq req);
    public TimeStampRequest(Byte[] req);
    public TimeStampRequest(Stream input);
    private TimeStampRequest(Asn1InputStream str);
    public int get_Version();
    public string get_MessageImprintAlgOid();
    public Byte[] GetMessageImprintDigest();
    public string get_ReqPolicy();
    public BigInteger get_Nonce();
    public bool get_CertReq();
    public void Validate(IList`1<string> algorithms, IList`1<string> policies, IList`1<string> extensions);
    public Byte[] GetEncoded();
    internal X509Extensions get_Extensions();
    public virtual bool get_HasExtensions();
    public virtual X509Extension GetExtension(DerObjectIdentifier oid);
    public virtual IList`1<DerObjectIdentifier> GetExtensionOids();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Tsp.TimeStampRequestGenerator : object {
    private DerObjectIdentifier reqPolicy;
    private DerBoolean certReq;
    private Dictionary`2<DerObjectIdentifier, X509Extension> m_extensions;
    private List`1<DerObjectIdentifier> m_ordering;
    public void SetReqPolicy(string reqPolicy);
    public void SetCertReq(bool certReq);
    public virtual void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extValue);
    public virtual void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extValue);
    public TimeStampRequest Generate(string digestAlgorithm, Byte[] digest);
    public TimeStampRequest Generate(string digestAlgorithmOid, Byte[] digest, BigInteger nonce);
    public virtual TimeStampRequest Generate(DerObjectIdentifier digestAlgorithm, Byte[] digest);
    public virtual TimeStampRequest Generate(DerObjectIdentifier digestAlgorithm, Byte[] digest, BigInteger nonce);
}
public class Org.BouncyCastle.Tsp.TimeStampResponse : object {
    private TimeStampResp resp;
    private TimeStampToken timeStampToken;
    public int Status { get; }
    public TimeStampToken TimeStampToken { get; }
    public TimeStampResponse(TimeStampResp resp);
    public TimeStampResponse(Byte[] resp);
    public TimeStampResponse(Stream input);
    private static TimeStampResp readTimeStampResp(Asn1InputStream input);
    public int get_Status();
    public string GetStatusString();
    public PkiFailureInfo GetFailInfo();
    public TimeStampToken get_TimeStampToken();
    public void Validate(TimeStampRequest request);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Tsp.TimeStampResponseGenerator : object {
    private PkiStatus status;
    private Asn1EncodableVector statusStrings;
    private int failInfo;
    private TimeStampTokenGenerator tokenGenerator;
    private IList`1<string> acceptedAlgorithms;
    private IList`1<string> acceptedPolicies;
    private IList`1<string> acceptedExtensions;
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList`1<string> acceptedAlgorithms);
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList`1<string> acceptedAlgorithms, IList`1<string> acceptedPolicy);
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList`1<string> acceptedAlgorithms, IList`1<string> acceptedPolicies, IList`1<string> acceptedExtensions);
    private void AddStatusString(string statusString);
    private void SetFailInfoField(int field);
    private PkiStatusInfo GetPkiStatusInfo();
    public TimeStampResponse Generate(TimeStampRequest request, BigInteger serialNumber, Nullable`1<DateTime> genTime);
    public TimeStampResponse GenerateGrantedResponse(TimeStampRequest request, BigInteger serialNumber, Nullable`1<DateTime> genTime, string statusString, X509Extensions additionalExtensions);
    public TimeStampResponse GenerateFailResponse(PkiStatus status, int failInfoField, string statusString);
}
public class Org.BouncyCastle.Tsp.TimeStampToken : object {
    private CmsSignedData tsToken;
    private SignerInformation tsaSignerInfo;
    private TimeStampTokenInfo tstInfo;
    private CertID certID;
    public TimeStampTokenInfo TimeStampInfo { get; }
    public SignerID SignerID { get; }
    public AttributeTable SignedAttributes { get; }
    public AttributeTable UnsignedAttributes { get; }
    public TimeStampToken(ContentInfo contentInfo);
    public TimeStampToken(CmsSignedData signedData);
    public TimeStampTokenInfo get_TimeStampInfo();
    public SignerID get_SignerID();
    public AttributeTable get_SignedAttributes();
    public AttributeTable get_UnsignedAttributes();
    public IStore`1<X509V2AttributeCertificate> GetAttributeCertificates();
    public IStore`1<X509Certificate> GetCertificates();
    public IStore`1<X509Crl> GetCrls();
    public void Validate(X509Certificate cert);
    public CmsSignedData ToCmsSignedData();
    public Byte[] GetEncoded();
    public Byte[] GetEncoded(string encoding);
}
public class Org.BouncyCastle.Tsp.TimeStampTokenGenerator : object {
    private int accuracySeconds;
    private int accuracyMillis;
    private int accuracyMicros;
    private bool ordering;
    private GeneralName tsa;
    private DerObjectIdentifier tsaPolicyOID;
    private IStore`1<X509Certificate> x509Certs;
    private IStore`1<X509Crl> x509Crls;
    private IStore`1<X509V2AttributeCertificate> x509AttrCerts;
    private SignerInfoGenerator signerInfoGenerator;
    private IDigestFactory digestCalculator;
    private Resolution resolution;
    public Resolution Resolution { get; public set; }
    public TimeStampTokenGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, string tsaPolicyOID);
    public TimeStampTokenGenerator(SignerInfoGenerator signerInfoGen, IDigestFactory digestCalculator, DerObjectIdentifier tsaPolicy, bool isIssuerSerialIncluded);
    public TimeStampTokenGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, string tsaPolicyOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public Resolution get_Resolution();
    public void set_Resolution(Resolution value);
    internal static SignerInfoGenerator makeInfoGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void SetAttributeCertificates(IStore`1<X509V2AttributeCertificate> attributeCertificates);
    public void SetCertificates(IStore`1<X509Certificate> certificates);
    public void SetCrls(IStore`1<X509Crl> crls);
    public void SetAccuracySeconds(int accuracySeconds);
    public void SetAccuracyMillis(int accuracyMillis);
    public void SetAccuracyMicros(int accuracyMicros);
    public void SetOrdering(bool ordering);
    public void SetTsa(GeneralName tsa);
    public TimeStampToken Generate(TimeStampRequest request, BigInteger serialNumber, DateTime genTime);
    public TimeStampToken Generate(TimeStampRequest request, BigInteger serialNumber, DateTime genTime, X509Extensions additionalExtensions);
    private static DateTime WithResolution(DateTime dateTime, Resolution resolution);
}
public class Org.BouncyCastle.Tsp.TimeStampTokenInfo : object {
    private TstInfo tstInfo;
    private DateTime genTime;
    public bool IsOrdered { get; }
    public Accuracy Accuracy { get; }
    public DateTime GenTime { get; }
    public GenTimeAccuracy GenTimeAccuracy { get; }
    public string Policy { get; }
    public BigInteger SerialNumber { get; }
    public GeneralName Tsa { get; }
    public BigInteger Nonce { get; }
    public AlgorithmIdentifier HashAlgorithm { get; }
    public string MessageImprintAlgOid { get; }
    public TstInfo TstInfo { get; }
    public TimeStampTokenInfo(Byte[] tstInfoEncoding);
    public TimeStampTokenInfo(TstInfo tstInfo);
    private static TstInfo ParseTstInfo(Byte[] tstInfoEncoding);
    public bool get_IsOrdered();
    public Accuracy get_Accuracy();
    public DateTime get_GenTime();
    public GenTimeAccuracy get_GenTimeAccuracy();
    public string get_Policy();
    public BigInteger get_SerialNumber();
    public GeneralName get_Tsa();
    public BigInteger get_Nonce();
    public AlgorithmIdentifier get_HashAlgorithm();
    public string get_MessageImprintAlgOid();
    public Byte[] GetMessageImprintDigest();
    public Byte[] GetEncoded();
    public TstInfo get_TstInfo();
}
public static class Org.BouncyCastle.Tsp.TspAlgorithms : object {
    public static string MD5;
    public static string Sha1;
    public static string Sha224;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string RipeMD128;
    public static string RipeMD160;
    public static string RipeMD256;
    public static string Gost3411;
    public static string Gost3411_2012_256;
    public static string Gost3411_2012_512;
    public static string SM3;
    public static IList`1<string> Allowed;
    private static TspAlgorithms();
}
public class Org.BouncyCastle.Tsp.TspException : Exception {
    public TspException(string message);
    public TspException(string message, Exception innerException);
    protected TspException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Tsp.TspUtil : object {
    private static Dictionary`2<string, int> DigestLengths;
    private static Dictionary`2<string, string> DigestNames;
    private static TspUtil();
    public static IList`1<TimeStampToken> GetSignatureTimestamps(SignerInformation signerInfo);
    public static void ValidateCertificate(X509Certificate cert);
    internal static string GetDigestAlgName(string digestAlgOid);
    internal static int GetDigestLength(string digestAlgOid);
    internal static IDigest CreateDigestInstance(string digestAlgOID);
    internal static HashSet`1<DerObjectIdentifier> GetCriticalExtensionOids(X509Extensions extensions);
    internal static HashSet`1<DerObjectIdentifier> GetNonCriticalExtensionOids(X509Extensions extensions);
    internal static IList`1<DerObjectIdentifier> GetExtensionOids(X509Extensions extensions);
}
public class Org.BouncyCastle.Tsp.TspValidationException : TspException {
    protected int m_failureCode;
    public int FailureCode { get; }
    public TspValidationException(string message);
    public TspValidationException(string message, int failureCode);
    protected TspValidationException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public int get_FailureCode();
}
public static class Org.BouncyCastle.Utilities.Arrays : object {
    public static Byte[] EmptyBytes;
    public static Int32[] EmptyInts;
    private static Arrays();
    public static bool AreAllZeroes(Byte[] buf, int off, int len);
    public static bool AreEqual(Boolean[] a, Boolean[] b);
    public static bool AreEqual(Char[] a, Char[] b);
    public static bool AreEqual(Byte[] a, Byte[] b);
    public static bool AreEqual(Byte[] a, int aFromIndex, int aToIndex, Byte[] b, int bFromIndex, int bToIndex);
    [CLSCompliantAttribute("False")]
public static bool AreEqual(UInt64[] a, int aFromIndex, int aToIndex, UInt64[] b, int bFromIndex, int bToIndex);
    [ObsoleteAttribute("Use 'FixedTimeEquals' instead")]
public static bool ConstantTimeAreEqual(Byte[] a, Byte[] b);
    [ObsoleteAttribute("Use 'FixedTimeEquals' instead")]
public static bool ConstantTimeAreEqual(int len, Byte[] a, int aOff, Byte[] b, int bOff);
    public static bool FixedTimeEquals(Byte[] a, Byte[] b);
    public static bool FixedTimeEquals(int len, Byte[] a, int aOff, Byte[] b, int bOff);
    public static bool AreEqual(Int32[] a, Int32[] b);
    [CLSCompliantAttribute("False")]
public static bool AreEqual(UInt32[] a, UInt32[] b);
    public static bool AreEqual(Int64[] a, Int64[] b);
    [CLSCompliantAttribute("False")]
public static bool AreEqual(UInt64[] a, UInt64[] b);
    private static bool HaveSameContents(Boolean[] a, Boolean[] b);
    private static bool HaveSameContents(Char[] a, Char[] b);
    private static bool HaveSameContents(Byte[] a, Byte[] b);
    private static bool HaveSameContents(Int32[] a, Int32[] b);
    private static bool HaveSameContents(UInt32[] a, UInt32[] b);
    private static bool HaveSameContents(Int64[] a, Int64[] b);
    private static bool HaveSameContents(UInt64[] a, UInt64[] b);
    public static string ToString(Object[] a);
    public static int GetHashCode(Byte[] data);
    public static int GetHashCode(Byte[] data, int off, int len);
    public static int GetHashCode(Int32[] data);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt16[] data);
    public static int GetHashCode(Int32[] data, int off, int len);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt32[] data);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt32[] data, int off, int len);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt64[] data);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt64[] data, int off, int len);
    public static Boolean[] Clone(Boolean[] data);
    public static Byte[] Clone(Byte[] data);
    public static Int16[] Clone(Int16[] data);
    [CLSCompliantAttribute("False")]
public static UInt16[] Clone(UInt16[] data);
    public static Int32[] Clone(Int32[] data);
    [CLSCompliantAttribute("False")]
public static UInt32[] Clone(UInt32[] data);
    public static Int64[] Clone(Int64[] data);
    [CLSCompliantAttribute("False")]
public static UInt64[] Clone(UInt64[] data);
    public static Byte[] Clone(Byte[] data, Byte[] existing);
    [CLSCompliantAttribute("False")]
public static UInt64[] Clone(UInt64[] data, UInt64[] existing);
    public static bool Contains(Byte[] a, byte n);
    public static bool Contains(Int16[] a, short n);
    public static bool Contains(Int32[] a, int n);
    public static void Fill(Byte[] buf, byte b);
    [CLSCompliantAttribute("False")]
public static void Fill(UInt64[] buf, ulong b);
    public static void Fill(Byte[] buf, int from, int to, byte b);
    public static void Fill(T[] ts, T t);
    public static Byte[] CopyOf(Byte[] data, int newLength);
    public static Char[] CopyOf(Char[] data, int newLength);
    public static Int32[] CopyOf(Int32[] data, int newLength);
    [CLSCompliantAttribute("False")]
public static UInt32[] CopyOf(UInt32[] data, int newLength);
    public static Int64[] CopyOf(Int64[] data, int newLength);
    public static BigInteger[] CopyOf(BigInteger[] data, int newLength);
    public static Byte[] CopyOfRange(Byte[] data, int from, int to);
    public static Int32[] CopyOfRange(Int32[] data, int from, int to);
    public static Int64[] CopyOfRange(Int64[] data, int from, int to);
    public static BigInteger[] CopyOfRange(BigInteger[] data, int from, int to);
    private static int GetLength(int from, int to);
    public static Byte[] Append(Byte[] a, byte b);
    public static Int16[] Append(Int16[] a, short b);
    public static Int32[] Append(Int32[] a, int b);
    public static Byte[] Concatenate(Byte[] a, Byte[] b);
    [CLSCompliantAttribute("False")]
public static UInt16[] Concatenate(UInt16[] a, UInt16[] b);
    public static Byte[] ConcatenateAll(Byte[][] vs);
    public static Int32[] Concatenate(Int32[] a, Int32[] b);
    [CLSCompliantAttribute("False")]
public static UInt32[] Concatenate(UInt32[] a, UInt32[] b);
    public static Byte[] Prepend(Byte[] a, byte b);
    public static Int16[] Prepend(Int16[] a, short b);
    public static Int32[] Prepend(Int32[] a, int b);
    public static T[] Prepend(T[] a, T b);
    public static Byte[] Reverse(Byte[] a);
    public static Int32[] Reverse(Int32[] a);
    public static T[] ReverseInPlace(T[] array);
    public static void Clear(Byte[] data);
    public static void Clear(Int32[] data);
    public static bool IsNullOrContainsNull(Object[] array);
    public static bool IsNullOrEmpty(Byte[] array);
    public static bool IsNullOrEmpty(Object[] array);
}
public static class Org.BouncyCastle.Utilities.BigIntegers : object {
    public static BigInteger Zero;
    public static BigInteger One;
    private static int MaxIterations;
    private static BigIntegers();
    public static Byte[] AsUnsignedByteArray(BigInteger n);
    public static Byte[] AsUnsignedByteArray(int length, BigInteger n);
    public static void AsUnsignedByteArray(BigInteger n, Byte[] buf, int off, int len);
    public static BigInteger CreateRandomBigInteger(int bitLength, SecureRandom secureRandom);
    public static BigInteger CreateRandomInRange(BigInteger min, BigInteger max, SecureRandom random);
    public static BigInteger FromUnsignedByteArray(Byte[] buf);
    public static BigInteger FromUnsignedByteArray(Byte[] buf, int off, int length);
    public static int GetByteLength(BigInteger n);
    public static int GetUnsignedByteLength(BigInteger n);
    public static BigInteger ModOddInverse(BigInteger M, BigInteger X);
    public static BigInteger ModOddInverseVar(BigInteger M, BigInteger X);
}
public static class Org.BouncyCastle.Utilities.Bytes : object {
    public static int NumBits;
    public static int NumBytes;
    public static void Xor(int len, Byte[] x, Byte[] y, Byte[] z);
    public static void Xor(int len, Byte[] x, int xOff, Byte[] y, int yOff, Byte[] z, int zOff);
    public static void XorTo(int len, Byte[] x, Byte[] z);
    public static void XorTo(int len, Byte[] x, int xOff, Byte[] z, int zOff);
}
public class Org.BouncyCastle.Utilities.Bzip2.BZip2Constants : object {
    public static int baseBlockSize;
    public static int MAX_ALPHA_SIZE;
    public static int MAX_CODE_LEN;
    public static int MAX_CODE_LEN_GEN;
    public static int RUNA;
    public static int RUNB;
    public static int N_GROUPS;
    public static int G_SIZE;
    public static int N_ITERS;
    public static int MAX_SELECTORS;
    public static int NUM_OVERSHOOT_BYTES;
}
public class Org.BouncyCastle.Utilities.Bzip2.CBZip2InputStream : BaseInputStream {
    private int last;
    private int origPtr;
    private int blockSize100k;
    private int bsBuff;
    private int bsLive;
    private CRC m_blockCrc;
    private int nInUse;
    private Byte[] seqToUnseq;
    private Byte[] m_selectors;
    private Int32[] tt;
    private Byte[] ll8;
    private Int32[] unzftab;
    private Int32[][] limit;
    private Int32[][] basev;
    private Int32[][] perm;
    private Int32[] minLens;
    private Stream bsStream;
    private bool streamEnd;
    private int currentByte;
    private static int RAND_PART_B_STATE;
    private static int RAND_PART_C_STATE;
    private static int NO_RAND_PART_B_STATE;
    private static int NO_RAND_PART_C_STATE;
    private int currentState;
    private int m_expectedBlockCrc;
    private int m_expectedStreamCrc;
    private int m_streamCrc;
    private int i2;
    private int count;
    private int chPrev;
    private int ch2;
    private int i;
    private int tPos;
    private int rNToGo;
    private int rTPos;
    private int j2;
    private int z;
    public CBZip2InputStream(Stream zStream);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private void BeginBlock();
    private void EndBlock();
    protected void Detach(bool disposing);
    protected virtual void Dispose(bool disposing);
    private void ImplDisposing(bool disposeInput);
    private int BsGetBit();
    private int BsGetBits(int n);
    private int BsGetBitsSmall(int n);
    private int BsGetInt32();
    private long BsGetLong48();
    private void HbCreateDecodeTables(Int32[] limit, Int32[] basev, Int32[] perm, Byte[] length, int minLen, int maxLen, int alphaSize);
    private int RecvDecodingTables();
    private void GetAndMoveToFrontDecode();
    private int RequireByte();
    private void SetupRandPartA();
    private void SetupNoRandPartA();
    private void SetupRandPartB();
    private void SetupNoRandPartB();
    private void SetupRandPartC();
    private void SetupNoRandPartC();
    internal static Int32[][] CreateIntArray(int n1, int n2);
}
public class Org.BouncyCastle.Utilities.Bzip2.CBZip2InputStreamLeaveOpen : CBZip2InputStream {
    public CBZip2InputStreamLeaveOpen(Stream outStream);
    protected virtual void Dispose(bool disposing);
}
public class Org.BouncyCastle.Utilities.Bzip2.CBZip2OutputStream : BaseOutputStream {
    protected static int SETMASK;
    protected static int CLEARMASK;
    protected static int GREATER_ICOST;
    protected static int LESSER_ICOST;
    protected static int SMALL_THRESH;
    protected static int DEPTH_THRESH;
    internal static UInt16[] RNums;
    private static Int32[] Incs;
    private bool finished;
    private int count;
    private int origPtr;
    private int blockSize100k;
    private int allowableBlockSize;
    private bool blockRandomised;
    private IList`1<StackElem> blocksortStack;
    private int bsBuff;
    private int bsLivePos;
    private CRC m_blockCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Byte[] m_selectors;
    private Byte[] blockBytes;
    private UInt16[] quadrantShorts;
    private Int32[] zptr;
    private Int32[] szptr;
    private Int32[] ftab;
    private int nMTF;
    private Int32[] mtfFreq;
    private int workFactor;
    private int workDone;
    private int workLimit;
    private bool firstAttempt;
    private int currentByte;
    private int runLength;
    private int m_streamCrc;
    private bool closed;
    private Stream bsStream;
    public CBZip2OutputStream(Stream outStream);
    public CBZip2OutputStream(Stream outStream, int blockSize);
    private static CBZip2OutputStream();
    protected static void HbMakeCodeLengths(Byte[] len, Int32[] freq, int alphaSize, int maxLen);
    public virtual void WriteByte(byte value);
    private void WriteRun();
    protected void Detach(bool disposing);
    protected virtual void Dispose(bool disposing);
    private void ImplDisposing(bool disposeOutput);
    public void Finish();
    public virtual void Flush();
    private void InitBlock();
    private void EndBlock();
    private void EndCompression();
    private void HbAssignCodes(Int32[] code, Byte[] length, int minLen, int maxLen, int alphaSize);
    private void BsFinishedWithStream();
    private void BsPutBit(int v);
    private void BsPutBits(int n, int v);
    private void BsPutBitsSmall(int n, int v);
    private void BsPutInt32(int u);
    private void BsPutLong48(long u);
    private void SendMtfValues();
    private void MoveToFrontCodeAndSend();
    private void SimpleSort(int lo, int hi, int d);
    private void Vswap(int p1, int p2, int n);
    private int Med3(int a, int b, int c);
    private static void PushStackElem(IList`1<StackElem> stack, int stackCount, int ll, int hh, int dd);
    private void QSort3(int loSt, int hiSt, int dSt);
    private void MainSort();
    private void RandomiseBlock();
    private void DoReversibleTransformation();
    private bool FullGtU(int i1, int i2);
    private void GenerateMtfValues();
    internal static Byte[][] CreateByteArray(int n1, int n2);
}
public class Org.BouncyCastle.Utilities.Bzip2.CBZip2OutputStreamLeaveOpen : CBZip2OutputStream {
    public CBZip2OutputStreamLeaveOpen(Stream outStream);
    public CBZip2OutputStreamLeaveOpen(Stream outStream, int blockSize);
    protected virtual void Dispose(bool disposing);
}
internal class Org.BouncyCastle.Utilities.Bzip2.CRC : object {
    private static UInt32[] Crc32Table;
    private UInt32 m_value;
    private static CRC();
    internal void Initialise();
    internal int GetFinal();
    internal void Update(byte inCh);
    internal void UpdateRun(byte inCh, int runLength);
}
public abstract class Org.BouncyCastle.Utilities.Collections.CollectionUtilities : object {
    public static void CollectMatches(ICollection`1<T> matches, ISelector`1<T> selector, IEnumerable`1<IStore`1<T>> stores);
    public static IStore`1<T> CreateStore(IEnumerable`1<T> contents);
    public static T GetFirstOrNull(IEnumerable`1<T> e);
    public static T GetValueOrKey(IDictionary`2<T, T> d, T k);
    public static V GetValueOrNull(IDictionary`2<K, V> d, K k);
    public static IEnumerable`1<T> Proxy(IEnumerable`1<T> e);
    public static ICollection`1<T> ReadOnly(ICollection`1<T> c);
    public static IDictionary`2<K, V> ReadOnly(IDictionary`2<K, V> d);
    public static IList`1<T> ReadOnly(IList`1<T> l);
    public static ISet`1<T> ReadOnly(ISet`1<T> s);
    public static bool Remove(IDictionary`2<K, V> d, K k, V& v);
    public static T RequireNext(IEnumerator`1<T> e);
    public static string ToString(IEnumerable`1<T> c);
}
internal class Org.BouncyCastle.Utilities.Collections.EnumerableProxy`1 : object {
    private IEnumerable`1<T> m_target;
    internal EnumerableProxy`1(IEnumerable`1<T> target);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
}
public interface Org.BouncyCastle.Utilities.Collections.ISelector`1 {
    public abstract virtual bool Match(T candidate);
}
public interface Org.BouncyCastle.Utilities.Collections.IStore`1 {
    public abstract virtual IEnumerable`1<T> EnumerateMatches(ISelector`1<T> selector);
}
internal abstract class Org.BouncyCastle.Utilities.Collections.ReadOnlyCollection`1 : object {
    public bool IsReadOnly { get; }
    public int Count { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Remove(T item);
    public abstract virtual bool Contains(T item);
    public abstract virtual int get_Count();
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
internal class Org.BouncyCastle.Utilities.Collections.ReadOnlyCollectionProxy`1 : ReadOnlyCollection`1<T> {
    private ICollection`1<T> m_target;
    public int Count { get; }
    internal ReadOnlyCollectionProxy`1(ICollection`1<T> target);
    public virtual bool Contains(T item);
    public virtual int get_Count();
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual IEnumerator`1<T> GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal abstract class Org.BouncyCastle.Utilities.Collections.ReadOnlyDictionary`2 : object {
    public V Item { get; public set; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(K key, V value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Remove(K key);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public abstract virtual bool Contains(KeyValuePair`2<K, V> item);
    public abstract virtual bool ContainsKey(K key);
    public abstract virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public abstract virtual ICollection`1<K> get_Keys();
    public abstract virtual bool TryGetValue(K key, V& value);
    public abstract virtual ICollection`1<V> get_Values();
    protected abstract virtual V Lookup(K key);
}
internal class Org.BouncyCastle.Utilities.Collections.ReadOnlyDictionaryProxy`2 : ReadOnlyDictionary`2<K, V> {
    private IDictionary`2<K, V> m_target;
    public int Count { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    internal ReadOnlyDictionaryProxy`2(IDictionary`2<K, V> target);
    public virtual bool Contains(KeyValuePair`2<K, V> item);
    public virtual bool ContainsKey(K key);
    public virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public virtual ICollection`1<K> get_Keys();
    public virtual bool TryGetValue(K key, V& value);
    public virtual ICollection`1<V> get_Values();
    protected virtual V Lookup(K key);
}
[DefaultMemberAttribute("Item")]
internal abstract class Org.BouncyCastle.Utilities.Collections.ReadOnlyList`1 : object {
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator`1<T> GetEnumerator();
    public abstract virtual int IndexOf(T item);
    protected abstract virtual T Lookup(int index);
}
internal class Org.BouncyCastle.Utilities.Collections.ReadOnlyListProxy`1 : ReadOnlyList`1<T> {
    private IList`1<T> m_target;
    public int Count { get; }
    internal ReadOnlyListProxy`1(IList`1<T> target);
    public virtual int get_Count();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual IEnumerator`1<T> GetEnumerator();
    public virtual int IndexOf(T item);
    protected virtual T Lookup(int index);
}
internal abstract class Org.BouncyCastle.Utilities.Collections.ReadOnlySet`1 : object {
    public bool IsReadOnly { get; }
    public int Count { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual bool Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual bool Remove(T item);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator`1<T> GetEnumerator();
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
}
internal class Org.BouncyCastle.Utilities.Collections.ReadOnlySetProxy`1 : ReadOnlySet`1<T> {
    private ISet`1<T> m_target;
    public int Count { get; }
    internal ReadOnlySetProxy`1(ISet`1<T> target);
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual IEnumerator`1<T> GetEnumerator();
    public virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public virtual bool Overlaps(IEnumerable`1<T> other);
}
internal class Org.BouncyCastle.Utilities.Collections.StoreImpl`1 : object {
    private List`1<T> m_contents;
    internal StoreImpl`1(IEnumerable`1<T> e);
    [IteratorStateMachineAttribute("Org.BouncyCastle.Utilities.Collections.StoreImpl`1/<Org-BouncyCastle-Utilities-Collections-IStore<T>-EnumerateMatches>d__2")]
private sealed virtual override IEnumerable`1<T> Org.BouncyCastle.Utilities.Collections.IStore<T>.EnumerateMatches(ISelector`1<T> selector);
}
public static class Org.BouncyCastle.Utilities.Date.DateTimeUtilities : object {
    public static DateTime UnixEpoch;
    public static long MaxUnixMs;
    public static long MinUnixMs;
    private static DateTimeUtilities();
    public static long DateTimeToUnixMs(DateTime dateTime);
    public static DateTime UnixMsToDateTime(long unixMs);
    public static long CurrentUnixMs();
    public static DateTime WithPrecisionCentisecond(DateTime dateTime);
    public static DateTime WithPrecisionDecisecond(DateTime dateTime);
    public static DateTime WithPrecisionMillisecond(DateTime dateTime);
    public static DateTime WithPrecisionSecond(DateTime dateTime);
}
public class Org.BouncyCastle.Utilities.Encoders.Base64 : object {
    public static string ToBase64String(Byte[] data);
    public static string ToBase64String(Byte[] data, int off, int length);
    public static Byte[] Encode(Byte[] data);
    public static Byte[] Encode(Byte[] data, int off, int length);
    public static int Encode(Byte[] data, Stream outStream);
    public static int Encode(Byte[] data, int off, int length, Stream outStream);
    public static Byte[] Decode(Byte[] data);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStream);
}
public class Org.BouncyCastle.Utilities.Encoders.Base64Encoder : object {
    protected Byte[] encodingTable;
    protected byte padding;
    protected Byte[] decodingTable;
    protected void InitialiseDecodingTable();
    public int Encode(Byte[] inBuf, int inOff, int inLen, Byte[] outBuf, int outOff);
    public sealed virtual int Encode(Byte[] buf, int off, int len, Stream outStream);
    private bool Ignore(char c);
    public sealed virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    private int NextI(Byte[] data, int i, int finish);
    public sealed virtual int DecodeString(string data, Stream outStream);
    private int DecodeLastBlock(Stream outStream, char c1, char c2, char c3, char c4);
    private int NextI(string data, int i, int finish);
}
public class Org.BouncyCastle.Utilities.Encoders.BufferedDecoder : object {
    internal Byte[] buffer;
    internal int bufOff;
    internal ITranslator translator;
    public BufferedDecoder(ITranslator translator, int bufferSize);
    public int ProcessByte(byte input, Byte[] output, int outOff);
    public int ProcessBytes(Byte[] input, int inOff, int len, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.BufferedEncoder : object {
    internal Byte[] Buffer;
    internal int bufOff;
    internal ITranslator translator;
    public BufferedEncoder(ITranslator translator, int bufferSize);
    public int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public int ProcessBytes(Byte[] input, int inOff, int len, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.Hex : object {
    private static HexEncoder encoder;
    private static Hex();
    public static string ToHexString(Byte[] data);
    public static string ToHexString(Byte[] data, bool upperCase);
    public static string ToHexString(Byte[] data, int off, int length);
    public static string ToHexString(Byte[] data, int off, int length, bool upperCase);
    public static Byte[] Encode(Byte[] data);
    public static Byte[] Encode(Byte[] data, int off, int length);
    public static int Encode(Byte[] data, Stream outStream);
    public static int Encode(Byte[] data, int off, int length, Stream outStream);
    public static Byte[] Decode(Byte[] data);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStream);
    public static Byte[] DecodeStrict(string str);
    public static Byte[] DecodeStrict(string str, int off, int len);
}
public class Org.BouncyCastle.Utilities.Encoders.HexEncoder : object {
    private static Char[] CharsLower;
    private static Char[] CharsUpper;
    protected Byte[] encodingTable;
    protected Byte[] decodingTable;
    private static HexEncoder();
    protected void InitialiseDecodingTable();
    public int Encode(Byte[] inBuf, int inOff, int inLen, Byte[] outBuf, int outOff);
    public sealed virtual int Encode(Byte[] buf, int off, int len, Stream outStream);
    private static bool Ignore(char c);
    public sealed virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public sealed virtual int DecodeString(string data, Stream outStream);
    internal Byte[] DecodeStrict(string str, int off, int len);
}
public class Org.BouncyCastle.Utilities.Encoders.HexTranslator : object {
    private static Byte[] hexTable;
    private static HexTranslator();
    public sealed virtual int GetEncodedBlockSize();
    public sealed virtual int Encode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
    public sealed virtual int GetDecodedBlockSize();
    public sealed virtual int Decode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
}
public interface Org.BouncyCastle.Utilities.Encoders.IEncoder {
    public abstract virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int DecodeString(string data, Stream outStream);
}
public interface Org.BouncyCastle.Utilities.Encoders.ITranslator {
    public abstract virtual int GetEncodedBlockSize();
    public abstract virtual int Encode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
    public abstract virtual int GetDecodedBlockSize();
    public abstract virtual int Decode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.UrlBase64 : object {
    private static IEncoder encoder;
    private static UrlBase64();
    public static Byte[] Encode(Byte[] data);
    public static int Encode(Byte[] data, Stream outStr);
    public static Byte[] Decode(Byte[] data);
    public static int Decode(Byte[] data, Stream outStr);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStr);
}
public class Org.BouncyCastle.Utilities.Encoders.UrlBase64Encoder : Base64Encoder {
}
internal static class Org.BouncyCastle.Utilities.Enums : object {
    internal static TEnum GetEnumValue(string s);
    internal static TEnum[] GetEnumValues();
    internal static TEnum GetArbitraryValue();
}
public interface Org.BouncyCastle.Utilities.IEncodable {
    public abstract virtual Byte[] GetEncoded();
}
public interface Org.BouncyCastle.Utilities.IMemoable {
    public abstract virtual IMemoable Copy();
    public abstract virtual void Reset(IMemoable other);
}
public static class Org.BouncyCastle.Utilities.Integers : object {
    public static int NumBits;
    public static int NumBytes;
    private static Byte[] DeBruijnTZ;
    private static Integers();
    public static int HighestOneBit(int i);
    [CLSCompliantAttribute("False")]
public static UInt32 HighestOneBit(UInt32 i);
    public static int LowestOneBit(int i);
    [CLSCompliantAttribute("False")]
public static UInt32 LowestOneBit(UInt32 i);
    public static int NumberOfLeadingZeros(int i);
    public static int NumberOfTrailingZeros(int i);
    public static int PopCount(int i);
    [CLSCompliantAttribute("False")]
public static int PopCount(UInt32 u);
    public static int Reverse(int i);
    [CLSCompliantAttribute("False")]
public static UInt32 Reverse(UInt32 i);
    public static int ReverseBytes(int i);
    [CLSCompliantAttribute("False")]
public static UInt32 ReverseBytes(UInt32 i);
    public static int RotateLeft(int i, int distance);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateLeft(UInt32 i, int distance);
    public static int RotateRight(int i, int distance);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateRight(UInt32 i, int distance);
}
public abstract class Org.BouncyCastle.Utilities.IO.BaseInputStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public sealed virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public abstract class Org.BouncyCastle.Utilities.IO.BaseOutputStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer);
}
public static class Org.BouncyCastle.Utilities.IO.BinaryReaders : object {
    public static Byte[] ReadBytesFully(BinaryReader binaryReader, int count);
    public static short ReadInt16BigEndian(BinaryReader binaryReader);
    public static short ReadInt16LittleEndian(BinaryReader binaryReader);
    public static int ReadInt32BigEndian(BinaryReader binaryReader);
    public static int ReadInt32LittleEndian(BinaryReader binaryReader);
    public static long ReadInt64BigEndian(BinaryReader binaryReader);
    public static long ReadInt64LittleEndian(BinaryReader binaryReader);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16BigEndian(BinaryReader binaryReader);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16LittleEndian(BinaryReader binaryReader);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32BigEndian(BinaryReader binaryReader);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32LittleEndian(BinaryReader binaryReader);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64BigEndian(BinaryReader binaryReader);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64LittleEndian(BinaryReader binaryReader);
}
public static class Org.BouncyCastle.Utilities.IO.BinaryWriters : object {
    public static void WriteInt16BigEndian(BinaryWriter binaryWriter, short n);
    public static void WriteInt16LittleEndian(BinaryWriter binaryWriter, short n);
    public static void WriteInt32BigEndian(BinaryWriter binaryWriter, int n);
    public static void WriteInt32LittleEndian(BinaryWriter binaryWriter, int n);
    public static void WriteInt64BigEndian(BinaryWriter binaryWriter, long n);
    public static void WriteInt64LittleEndian(BinaryWriter binaryWriter, long n);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16BigEndian(BinaryWriter binaryWriter, ushort n);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16LittleEndian(BinaryWriter binaryWriter, ushort n);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32BigEndian(BinaryWriter binaryWriter, UInt32 n);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32LittleEndian(BinaryWriter binaryWriter, UInt32 n);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64BigEndian(BinaryWriter binaryWriter, ulong n);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64LittleEndian(BinaryWriter binaryWriter, ulong n);
}
internal class Org.BouncyCastle.Utilities.IO.BufferedFilterStream : FilterStream {
    internal BufferedFilterStream(Stream s);
    internal BufferedFilterStream(Stream s, int bufferSize);
}
internal static class Org.BouncyCastle.Utilities.IO.Compression.Bzip2 : object {
    internal static Stream CompressOutput(Stream stream, bool leaveOpen);
    internal static Stream DecompressInput(Stream stream, bool leaveOpen);
}
internal static class Org.BouncyCastle.Utilities.IO.Compression.Zip : object {
    internal static Stream CompressOutput(Stream stream, int zlibCompressionLevel, bool leaveOpen);
    internal static Stream DecompressInput(Stream stream, bool leaveOpen);
}
internal static class Org.BouncyCastle.Utilities.IO.Compression.ZLib : object {
    internal static Stream CompressOutput(Stream stream, int zlibCompressionLevel, bool leaveOpen);
    internal static Stream DecompressInput(Stream stream, bool leaveOpen);
}
public class Org.BouncyCastle.Utilities.IO.FilterStream : Stream {
    protected Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FilterStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected void Detach(bool disposing);
    protected virtual void Dispose(bool disposing);
}
internal class Org.BouncyCastle.Utilities.IO.LimitedInputStream : BaseInputStream {
    private Stream m_stream;
    private long m_limit;
    internal long CurrentLimit { get; }
    internal LimitedInputStream(Stream stream, long limit);
    internal long get_CurrentLimit();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemGenerationException : Exception {
    public PemGenerationException(string message);
    public PemGenerationException(string message, Exception innerException);
    protected PemGenerationException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemHeader : object {
    private string name;
    private string val;
    public string Name { get; }
    public string Value { get; }
    public PemHeader(string name, string val);
    public virtual string get_Name();
    public virtual string get_Value();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private int GetHashCode(string s);
    public virtual string ToString();
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemObject : object {
    private string m_type;
    private IList`1<PemHeader> m_headers;
    private Byte[] m_content;
    public string Type { get; }
    public IList`1<PemHeader> Headers { get; }
    public Byte[] Content { get; }
    public PemObject(string type, Byte[] content);
    public PemObject(string type, IList`1<PemHeader> headers, Byte[] content);
    public string get_Type();
    public IList`1<PemHeader> get_Headers();
    public Byte[] get_Content();
    public sealed virtual PemObject Generate();
}
public interface Org.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator {
    public abstract virtual PemObject Generate();
}
public interface Org.BouncyCastle.Utilities.IO.Pem.PemObjectParser {
    public abstract virtual object ParseObject(PemObject obj);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemReader : object {
    private static int LineLength;
    private TextReader m_reader;
    private MemoryStream m_buffer;
    private StreamWriter m_textBuffer;
    private Stack`1<int> m_pushback;
    public TextReader Reader { get; }
    public PemReader(TextReader reader);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public TextReader get_Reader();
    public PemObject ReadPemObject();
    private string BufferedString();
    private bool SeekDash();
    private bool SeekColon(int upTo);
    private bool ConsumeDash();
    private void SkipWhiteSpace();
    private bool Expect(string value);
    private bool BufferUntilStopChar(char stopChar, bool skipWhiteSpace);
    private void PushBack(int value);
    private int Read();
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemWriter : object {
    private static int LineLength;
    private TextWriter m_writer;
    private int m_nlLength;
    private Char[] m_buf;
    public TextWriter Writer { get; }
    public PemWriter(TextWriter writer);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public TextWriter get_Writer();
    public int GetOutputSize(PemObject obj);
    public void WriteObject(PemObjectGenerator objGen);
    private void WriteEncoded(Byte[] bytes);
    private void WritePreEncapsulationBoundary(string type);
    private void WritePostEncapsulationBoundary(string type);
}
public class Org.BouncyCastle.Utilities.IO.PushbackStream : FilterStream {
    private int m_buf;
    public PushbackStream(Stream s);
    [AsyncStateMachineAttribute("Org.BouncyCastle.Utilities.IO.PushbackStream/<CopyToAsync>d__2")]
public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Unread(int b);
}
public class Org.BouncyCastle.Utilities.IO.StreamOverflowException : IOException {
    public StreamOverflowException(string message);
    public StreamOverflowException(string message, Exception innerException);
    protected StreamOverflowException(SerializationInfo info, StreamingContext context);
}
public static class Org.BouncyCastle.Utilities.IO.Streams : object {
    private static int MaxStackAlloc;
    public static int DefaultBufferSize { get; }
    private static Streams();
    public static int get_DefaultBufferSize();
    public static void CopyTo(Stream source, Stream destination);
    public static void CopyTo(Stream source, Stream destination, int bufferSize);
    public static Task CopyToAsync(Stream source, Stream destination);
    public static Task CopyToAsync(Stream source, Stream destination, int bufferSize);
    public static Task CopyToAsync(Stream source, Stream destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Org.BouncyCastle.Utilities.IO.Streams/<CopyToAsync>d__8")]
public static Task CopyToAsync(Stream source, Stream destination, int bufferSize, CancellationToken cancellationToken);
    public static void Drain(Stream inStr);
    public static void PipeAll(Stream inStr, Stream outStr);
    public static void PipeAll(Stream inStr, Stream outStr, int bufferSize);
    public static long PipeAllLimited(Stream inStr, long limit, Stream outStr);
    public static long PipeAllLimited(Stream inStr, long limit, Stream outStr, int bufferSize);
    public static Byte[] ReadAll(Stream inStr);
    public static Byte[] ReadAll(MemoryStream inStr);
    public static Byte[] ReadAllLimited(Stream inStr, int limit);
    public static int ReadFully(Stream inStr, Byte[] buf);
    public static int ReadFully(Stream inStr, Byte[] buf, int off, int len);
    public static void ValidateBufferArguments(Byte[] buffer, int offset, int count);
    public static int WriteBufTo(MemoryStream buf, Byte[] output, int offset);
}
public class Org.BouncyCastle.Utilities.IO.TeeInputStream : BaseInputStream {
    private Stream input;
    private Stream tee;
    public TeeInputStream(Stream input, Stream tee);
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
}
public class Org.BouncyCastle.Utilities.IO.TeeOutputStream : BaseOutputStream {
    private Stream output;
    private Stream tee;
    public TeeOutputStream(Stream output, Stream tee);
    protected virtual void Dispose(bool disposing);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public static class Org.BouncyCastle.Utilities.Longs : object {
    public static int NumBits;
    public static int NumBytes;
    private static Byte[] DeBruijnTZ;
    private static Longs();
    public static long HighestOneBit(long i);
    [CLSCompliantAttribute("False")]
public static ulong HighestOneBit(ulong i);
    public static long LowestOneBit(long i);
    [CLSCompliantAttribute("False")]
public static ulong LowestOneBit(ulong i);
    public static int NumberOfLeadingZeros(long i);
    public static int NumberOfTrailingZeros(long i);
    public static long Reverse(long i);
    [CLSCompliantAttribute("False")]
public static ulong Reverse(ulong i);
    public static long ReverseBytes(long i);
    [CLSCompliantAttribute("False")]
public static ulong ReverseBytes(ulong i);
    public static long RotateLeft(long i, int distance);
    [CLSCompliantAttribute("False")]
public static ulong RotateLeft(ulong i, int distance);
    public static long RotateRight(long i, int distance);
    [CLSCompliantAttribute("False")]
public static ulong RotateRight(ulong i, int distance);
}
public class Org.BouncyCastle.Utilities.MemoableResetException : InvalidCastException {
    public MemoableResetException(string message);
    public MemoableResetException(string message, Exception innerException);
    protected MemoableResetException(SerializationInfo info, StreamingContext context);
}
public class Org.BouncyCastle.Utilities.Net.IPAddress : object {
    public static bool IsValid(string address);
    public static bool IsValidWithNetMask(string address);
    public static bool IsValidIPv4(string address);
    public static bool IsValidIPv4WithNetmask(string address);
    public static bool IsValidIPv6(string address);
    public static bool IsValidIPv6WithNetmask(string address);
    private static bool IsParseableIPv4Mask(string s);
    private static bool IsParseableIPv4Octet(string s, int pos, int end);
    private static bool IsParseableIPv6Mask(string s);
    private static bool IsParseableIPv6Segment(string s, int pos, int end);
    private static bool IsParseableDecimal(string s, int pos, int end, int maxLength, bool allowLeadingZero, int minValue, int maxValue);
    private static bool IsParseableHexadecimal(string s, int pos, int end, int maxLength, bool allowLeadingZero, int minValue, int maxValue);
    private static int GetDigitDecimal(string s, int pos);
    private static int GetDigitHexadecimal(string s, int pos);
}
public static class Org.BouncyCastle.Utilities.Objects : object {
    public static int GetHashCode(object obj);
    internal static TValue EnsureSingletonInitialized(TValue& value, TArg arg, Func`2<TArg, TValue> initialize);
}
internal static class Org.BouncyCastle.Utilities.Platform : object {
    private static CompareInfo InvariantCompareInfo;
    internal static bool Is64BitProcess { get; }
    private static Platform();
    internal static bool EqualsIgnoreCase(string a, string b);
    internal static string GetEnvironmentVariable(string variable);
    internal static int IndexOf(string source, char value);
    internal static int IndexOf(string source, string value);
    internal static int IndexOf(string source, char value, int startIndex);
    internal static int IndexOf(string source, string value, int startIndex);
    internal static bool get_Is64BitProcess();
    internal static int LastIndexOf(string source, string value);
    internal static bool StartsWith(string source, string prefix);
    internal static bool StartsWithIgnoreCase(string source, string prefix);
    internal static bool EndsWith(string source, string suffix);
    internal static string GetTypeName(object obj);
    internal static string GetTypeName(Type t);
}
public static class Org.BouncyCastle.Utilities.Shorts : object {
    public static int NumBits;
    public static int NumBytes;
    public static short ReverseBytes(short i);
    [CLSCompliantAttribute("False")]
public static ushort ReverseBytes(ushort i);
    public static short RotateLeft(short i, int distance);
    [CLSCompliantAttribute("False")]
public static ushort RotateLeft(ushort i, int distance);
    public static short RotateRight(short i, int distance);
    [CLSCompliantAttribute("False")]
public static ushort RotateRight(ushort i, int distance);
}
public static class Org.BouncyCastle.Utilities.Strings : object {
    internal static bool IsOneOf(string s, String[] candidates);
    public static string FromByteArray(Byte[] bs);
    public static Byte[] ToByteArray(Char[] cs);
    public static Byte[] ToByteArray(string s);
    public static string FromAsciiByteArray(Byte[] bytes);
    public static Byte[] ToAsciiByteArray(Char[] cs);
    public static Byte[] ToAsciiByteArray(string s);
    public static string FromUtf8ByteArray(Byte[] bytes);
    public static string FromUtf8ByteArray(Byte[] bytes, int index, int count);
    public static Byte[] ToUtf8ByteArray(Char[] cs);
    public static Byte[] ToUtf8ByteArray(string s);
}
internal class Org.BouncyCastle.Utilities.Zlib.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    internal long adler32(long adler, Byte[] buf, int index, int len);
}
public class Org.BouncyCastle.Utilities.Zlib.Deflate : object {
    private static int MAX_MEM_LEVEL;
    private static int Z_DEFAULT_COMPRESSION;
    private static int MAX_WBITS;
    private static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static Config[] config_table;
    private static String[] z_errmsg;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_FILTERED;
    private static int Z_HUFFMAN_ONLY;
    private static int Z_DEFAULT_STRATEGY;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    internal ZStream strm;
    internal int status;
    internal Byte[] pending_buf;
    internal int pending_out;
    internal int pending;
    internal int noheader;
    internal byte data_type;
    internal byte method;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal int max_chain_length;
    internal int max_lazy_match;
    internal int level;
    internal int strategy;
    internal int good_match;
    internal int nice_match;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree l_desc;
    internal Tree d_desc;
    internal Tree bl_desc;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    internal int l_buf;
    internal int lit_bufsize;
    internal int last_lit;
    internal int d_buf;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal UInt32 bi_buf;
    internal int bi_valid;
    private static Deflate();
    internal void lm_init();
    internal void tr_init();
    internal void init_block();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool smaller(Int16[] tree, int n, int m, Byte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    internal void put_byte(Byte[] p, int start, int len);
    internal void put_byte(byte c);
    internal void put_short(int w);
    internal void putShortMSB(int b);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int val, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void compress_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal int deflate_stored(int flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    internal void fill_window();
    internal int deflate_fast(int flush);
    internal int deflate_slow(int flush);
    internal int longest_match(int cur_match);
    internal int deflateInit(ZStream strm, int level, int bits);
    internal int deflateInit(ZStream strm, int level);
    internal int deflateInit2(ZStream strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int deflateReset(ZStream strm);
    internal int deflateEnd();
    internal int deflateParams(ZStream strm, int _level, int _strategy);
    internal int deflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal int deflate(ZStream strm, int flush);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfBlocks : object {
    private static int MANY;
    private static Int32[] inflate_mask;
    private static Int32[] border;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int TYPE;
    private static int LENS;
    private static int STORED;
    private static int TABLE;
    private static int BTREE;
    private static int DTREE;
    private static int CODES;
    private static int DRY;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InfCodes codes;
    private int last;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int read;
    internal int write;
    internal object checkfn;
    internal long check;
    internal InfTree inftree;
    internal InfBlocks(ZStream z, object checkfn, int w);
    private static InfBlocks();
    internal void reset(ZStream z, Int64[] c);
    internal int proc(ZStream z, int r);
    internal void free(ZStream z);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
    internal int inflate_flush(ZStream z, int r);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfCodes : object {
    private static Int32[] inflate_mask;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    private int mode;
    private int len;
    private Int32[] tree;
    private int tree_index;
    private int need;
    private int lit;
    private int get;
    private int dist;
    private byte lbits;
    private byte dbits;
    private Int32[] ltree;
    private int ltree_index;
    private Int32[] dtree;
    private int dtree_index;
    private static InfCodes();
    internal void init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, ZStream z);
    internal int proc(InfBlocks s, ZStream z, int r);
    internal void free(ZStream z);
    internal int inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class Org.BouncyCastle.Utilities.Zlib.Inflate : object {
    private static int MAX_WBITS;
    private static int PRESET_DICT;
    internal static int Z_NO_FLUSH;
    internal static int Z_PARTIAL_FLUSH;
    internal static int Z_SYNC_FLUSH;
    internal static int Z_FULL_FLUSH;
    internal static int Z_FINISH;
    private static int Z_DEFLATED;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int METHOD;
    private static int FLAG;
    private static int DICT4;
    private static int DICT3;
    private static int DICT2;
    private static int DICT1;
    private static int DICT0;
    private static int BLOCKS;
    private static int CHECK4;
    private static int CHECK3;
    private static int CHECK2;
    private static int CHECK1;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int method;
    internal Int64[] was;
    internal long need;
    internal int marker;
    internal int nowrap;
    internal int wbits;
    internal InfBlocks blocks;
    private static Byte[] mark;
    private static Inflate();
    internal int inflateReset(ZStream z);
    internal int inflateEnd(ZStream z);
    internal int inflateInit(ZStream z, int w);
    internal int inflate(ZStream z, int f);
    internal int inflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal int inflateSync(ZStream z);
    internal int inflateSyncPoint(ZStream z);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int fixed_bl;
    private static int fixed_bd;
    private static Int32[] fixed_tl;
    private static Int32[] fixed_td;
    private static Int32[] cplens;
    private static Int32[] cplext;
    private static Int32[] cpdist;
    private static Int32[] cpdext;
    private static int BMAX;
    private Int32[] hn;
    private Int32[] v;
    private Int32[] c;
    private Int32[] r;
    private Int32[] u;
    private Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
    private void initWorkArea(int vsize);
}
public class Org.BouncyCastle.Utilities.Zlib.JZlib : object {
    private static string _version;
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_NO_FLUSH;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_ERRNO;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_MEM_ERROR;
    public static int Z_BUF_ERROR;
    public static int Z_VERSION_ERROR;
    public static string version();
}
internal class Org.BouncyCastle.Utilities.Zlib.StaticTree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    internal StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class Org.BouncyCastle.Utilities.Zlib.Tree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree stat_desc;
    private static Tree();
    internal static int d_code(int dist);
    internal void gen_bitlen(Deflate s);
    internal void build_tree(Deflate s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
public class Org.BouncyCastle.Utilities.Zlib.ZInputStream : BaseInputStream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream input;
    protected bool closed;
    private bool nomoreinput;
    public int FlushMode { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZInputStream(Stream input);
    public ZInputStream(Stream input, bool nowrap);
    public ZInputStream(Stream input, ZStream z);
    public ZInputStream(Stream input, int level);
    public ZInputStream(Stream input, int level, bool nowrap);
    private static ZStream GetDefaultZStream(bool nowrap);
    protected void Detach(bool disposing);
    protected virtual void Dispose(bool disposing);
    private void ImplDisposing(bool disposeInput);
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
}
public class Org.BouncyCastle.Utilities.Zlib.ZInputStreamLeaveOpen : ZInputStream {
    public ZInputStreamLeaveOpen(Stream input);
    public ZInputStreamLeaveOpen(Stream input, bool nowrap);
    public ZInputStreamLeaveOpen(Stream input, ZStream z);
    public ZInputStreamLeaveOpen(Stream input, int level);
    public ZInputStreamLeaveOpen(Stream input, int level, bool nowrap);
    protected virtual void Dispose(bool disposing);
}
public class Org.BouncyCastle.Utilities.Zlib.ZOutputStream : BaseOutputStream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream output;
    protected bool closed;
    public int FlushMode { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZOutputStream(Stream output);
    public ZOutputStream(Stream output, bool nowrap);
    public ZOutputStream(Stream output, ZStream z);
    public ZOutputStream(Stream output, int level);
    public ZOutputStream(Stream output, int level, bool nowrap);
    private static ZStream GetDefaultZStream(bool nowrap);
    protected void Detach(bool disposing);
    protected virtual void Dispose(bool disposing);
    private void ImplDisposing(bool disposeOutput);
    public virtual void End();
    public virtual void Finish();
    public virtual void Flush();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class Org.BouncyCastle.Utilities.Zlib.ZOutputStreamLeaveOpen : ZOutputStream {
    public ZOutputStreamLeaveOpen(Stream output);
    public ZOutputStreamLeaveOpen(Stream output, bool nowrap);
    public ZOutputStreamLeaveOpen(Stream output, ZStream z);
    public ZOutputStreamLeaveOpen(Stream output, int level);
    public ZOutputStreamLeaveOpen(Stream output, int level, bool nowrap);
    protected virtual void Dispose(bool disposing);
}
public class Org.BouncyCastle.Utilities.Zlib.ZStream : object {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int MAX_MEM_LEVEL;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    public Byte[] next_in;
    public int next_in_index;
    public int avail_in;
    public long total_in;
    public Byte[] next_out;
    public int next_out_index;
    public int avail_out;
    public long total_out;
    public string msg;
    internal Deflate dstate;
    internal Inflate istate;
    internal int data_type;
    public long adler;
    internal Adler32 _adler;
    public int inflateInit();
    public int inflateInit(bool nowrap);
    public int inflateInit(int w);
    public int inflateInit(int w, bool nowrap);
    public int inflate(int f);
    public int inflateEnd();
    public int inflateSync();
    public int inflateSetDictionary(Byte[] dictionary, int dictLength);
    public int deflateInit(int level);
    public int deflateInit(int level, bool nowrap);
    public int deflateInit(int level, int bits);
    public int deflateInit(int level, int bits, bool nowrap);
    public int deflate(int flush);
    public int deflateEnd();
    public int deflateParams(int level, int strategy);
    public int deflateSetDictionary(Byte[] dictionary, int dictLength);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
    public void free();
}
public class Org.BouncyCastle.X509.AttributeCertificateHolder : object {
    internal Holder holder;
    public int DigestedObjectType { get; }
    public string DigestAlgorithm { get; }
    public string OtherObjectTypeID { get; }
    public BigInteger SerialNumber { get; }
    internal AttributeCertificateHolder(Asn1Sequence seq);
    public AttributeCertificateHolder(X509Name issuerName, BigInteger serialNumber);
    public AttributeCertificateHolder(X509Certificate cert);
    public AttributeCertificateHolder(X509Name principal);
    public AttributeCertificateHolder(int digestedObjectType, string digestAlgorithm, string otherObjectTypeID, Byte[] objectDigest);
    public int get_DigestedObjectType();
    public string get_DigestAlgorithm();
    public Byte[] GetObjectDigest();
    public string get_OtherObjectTypeID();
    private GeneralNames GenerateGeneralNames(X509Name principal);
    private bool MatchesDN(X509Name subject, GeneralNames targets);
    private Object[] GetNames(GeneralName[] names);
    private X509Name[] GetPrincipals(GeneralNames names);
    public X509Name[] GetEntityNames();
    public X509Name[] GetIssuer();
    public BigInteger get_SerialNumber();
    public sealed virtual object Clone();
    public sealed virtual bool Match(X509Certificate x509Cert);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.AttributeCertificateIssuer : object {
    internal Asn1Encodable form;
    public AttributeCertificateIssuer(AttCertIssuer issuer);
    public AttributeCertificateIssuer(X509Name principal);
    private Object[] GetNames();
    public X509Name[] GetPrincipals();
    private bool MatchesDN(X509Name subject, GeneralNames targets);
    public sealed virtual object Clone();
    public sealed virtual bool Match(X509Certificate x509Cert);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure : AuthorityKeyIdentifier {
    public AuthorityKeyIdentifierStructure(Asn1OctetString encodedValue);
    public AuthorityKeyIdentifierStructure(X509Certificate certificate);
    public AuthorityKeyIdentifierStructure(AsymmetricKeyParameter pubKey);
    private static Asn1Sequence FromCertificate(X509Certificate certificate);
    private static Asn1Sequence FromKey(AsymmetricKeyParameter pubKey);
}
public class Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure : SubjectKeyIdentifier {
    public SubjectKeyIdentifierStructure(Asn1OctetString encodedValue);
    public SubjectKeyIdentifierStructure(AsymmetricKeyParameter pubKey);
    private static Asn1OctetString FromPublicKey(AsymmetricKeyParameter pubKey);
}
public class Org.BouncyCastle.X509.Extension.X509ExtensionUtilities : object {
    public static Asn1Object FromExtensionValue(Asn1OctetString extensionValue);
    public static Asn1Object FromExtensionValue(IX509Extension extensions, DerObjectIdentifier oid);
}
public interface Org.BouncyCastle.X509.IX509Extension {
    public abstract virtual ISet`1<string> GetCriticalExtensionOids();
    public abstract virtual ISet`1<string> GetNonCriticalExtensionOids();
    public abstract virtual Asn1OctetString GetExtensionValue(DerObjectIdentifier oid);
}
internal class Org.BouncyCastle.X509.PemParser : object {
    private string _header1;
    private string _header2;
    private string _footer1;
    private string _footer2;
    internal PemParser(string type);
    private string ReadLine(Stream inStream);
    internal Asn1Sequence ReadPemObject(Stream inStream);
}
public class Org.BouncyCastle.X509.PrincipalUtilities : object {
    public static X509Name GetIssuerX509Principal(X509Certificate cert);
    public static X509Name GetSubjectX509Principal(X509Certificate cert);
    public static X509Name GetIssuerX509Principal(X509Crl crl);
}
public class Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector : object {
    private X509V2AttributeCertificate attributeCert;
    private Nullable`1<DateTime> attributeCertificateValid;
    private AttributeCertificateHolder holder;
    private AttributeCertificateIssuer issuer;
    private BigInteger serialNumber;
    private ISet`1<GeneralName> targetNames;
    private ISet`1<GeneralName> targetGroups;
    public X509V2AttributeCertificate AttributeCert { get; public set; }
    public Nullable`1<DateTime> AttributeCertificateValid { get; public set; }
    public AttributeCertificateHolder Holder { get; public set; }
    public AttributeCertificateIssuer Issuer { get; public set; }
    public BigInteger SerialNumber { get; public set; }
    private X509AttrCertStoreSelector(X509AttrCertStoreSelector o);
    public sealed virtual bool Match(X509V2AttributeCertificate attrCert);
    public sealed virtual object Clone();
    public X509V2AttributeCertificate get_AttributeCert();
    public void set_AttributeCert(X509V2AttributeCertificate value);
    public Nullable`1<DateTime> get_AttributeCertificateValid();
    public void set_AttributeCertificateValid(Nullable`1<DateTime> value);
    public AttributeCertificateHolder get_Holder();
    public void set_Holder(AttributeCertificateHolder value);
    public AttributeCertificateIssuer get_Issuer();
    public void set_Issuer(AttributeCertificateIssuer value);
    public BigInteger get_SerialNumber();
    public void set_SerialNumber(BigInteger value);
    public void AddTargetName(GeneralName name);
    public void AddTargetName(Byte[] name);
    public void SetTargetNames(IEnumerable`1<object> names);
    public IEnumerable`1<GeneralName> GetTargetNames();
    public void AddTargetGroup(GeneralName group);
    public void AddTargetGroup(Byte[] name);
    public void SetTargetGroups(IEnumerable`1<object> names);
    public IEnumerable`1<GeneralName> GetTargetGroups();
    private ISet`1<GeneralName> ExtractGeneralNames(IEnumerable`1<object> names);
}
public class Org.BouncyCastle.X509.Store.X509CertPairStoreSelector : object {
    private X509CertificatePair certPair;
    private X509CertStoreSelector forwardSelector;
    private X509CertStoreSelector reverseSelector;
    public X509CertificatePair CertPair { get; public set; }
    public X509CertStoreSelector ForwardSelector { get; public set; }
    public X509CertStoreSelector ReverseSelector { get; public set; }
    private X509CertPairStoreSelector(X509CertPairStoreSelector o);
    private static X509CertStoreSelector CloneSelector(X509CertStoreSelector s);
    public X509CertificatePair get_CertPair();
    public void set_CertPair(X509CertificatePair value);
    public X509CertStoreSelector get_ForwardSelector();
    public void set_ForwardSelector(X509CertStoreSelector value);
    public X509CertStoreSelector get_ReverseSelector();
    public void set_ReverseSelector(X509CertStoreSelector value);
    public sealed virtual bool Match(X509CertificatePair pair);
    public sealed virtual object Clone();
}
public class Org.BouncyCastle.X509.Store.X509CertStoreSelector : object {
    private Byte[] authorityKeyIdentifier;
    private int basicConstraints;
    private X509Certificate certificate;
    private Nullable`1<DateTime> certificateValid;
    private ISet`1<DerObjectIdentifier> extendedKeyUsage;
    private bool ignoreX509NameOrdering;
    private X509Name issuer;
    private Boolean[] keyUsage;
    private ISet`1<DerObjectIdentifier> policy;
    private Nullable`1<DateTime> privateKeyValid;
    private BigInteger serialNumber;
    private X509Name subject;
    private Byte[] subjectKeyIdentifier;
    private SubjectPublicKeyInfo subjectPublicKey;
    private DerObjectIdentifier subjectPublicKeyAlgID;
    public Byte[] AuthorityKeyIdentifier { get; public set; }
    public int BasicConstraints { get; public set; }
    public X509Certificate Certificate { get; public set; }
    public Nullable`1<DateTime> CertificateValid { get; public set; }
    public ISet`1<DerObjectIdentifier> ExtendedKeyUsage { get; public set; }
    public bool IgnoreX509NameOrdering { get; public set; }
    public X509Name Issuer { get; public set; }
    public Boolean[] KeyUsage { get; public set; }
    public ISet`1<DerObjectIdentifier> Policy { get; public set; }
    public Nullable`1<DateTime> PrivateKeyValid { get; public set; }
    public BigInteger SerialNumber { get; public set; }
    public X509Name Subject { get; public set; }
    public Byte[] SubjectKeyIdentifier { get; public set; }
    public SubjectPublicKeyInfo SubjectPublicKey { get; public set; }
    public DerObjectIdentifier SubjectPublicKeyAlgID { get; public set; }
    public X509CertStoreSelector(X509CertStoreSelector o);
    public virtual object Clone();
    public Byte[] get_AuthorityKeyIdentifier();
    public void set_AuthorityKeyIdentifier(Byte[] value);
    public int get_BasicConstraints();
    public void set_BasicConstraints(int value);
    public X509Certificate get_Certificate();
    public void set_Certificate(X509Certificate value);
    public Nullable`1<DateTime> get_CertificateValid();
    public void set_CertificateValid(Nullable`1<DateTime> value);
    public ISet`1<DerObjectIdentifier> get_ExtendedKeyUsage();
    public void set_ExtendedKeyUsage(ISet`1<DerObjectIdentifier> value);
    public bool get_IgnoreX509NameOrdering();
    public void set_IgnoreX509NameOrdering(bool value);
    public X509Name get_Issuer();
    public void set_Issuer(X509Name value);
    public Boolean[] get_KeyUsage();
    public void set_KeyUsage(Boolean[] value);
    public ISet`1<DerObjectIdentifier> get_Policy();
    public void set_Policy(ISet`1<DerObjectIdentifier> value);
    public Nullable`1<DateTime> get_PrivateKeyValid();
    public void set_PrivateKeyValid(Nullable`1<DateTime> value);
    public BigInteger get_SerialNumber();
    public void set_SerialNumber(BigInteger value);
    public X509Name get_Subject();
    public void set_Subject(X509Name value);
    public Byte[] get_SubjectKeyIdentifier();
    public void set_SubjectKeyIdentifier(Byte[] value);
    public SubjectPublicKeyInfo get_SubjectPublicKey();
    public void set_SubjectPublicKey(SubjectPublicKeyInfo value);
    public DerObjectIdentifier get_SubjectPublicKeyAlgID();
    public void set_SubjectPublicKeyAlgID(DerObjectIdentifier value);
    public virtual bool Match(X509Certificate c);
    internal static bool IssuersMatch(X509Name a, X509Name b);
    private static Boolean[] CopyBoolArray(Boolean[] b);
    private static ISet`1<T> CopySet(ISet`1<T> s);
    private static SubjectPublicKeyInfo GetSubjectPublicKey(X509Certificate c);
    private static bool MatchExtension(Byte[] b, X509Certificate c, DerObjectIdentifier oid);
}
public class Org.BouncyCastle.X509.Store.X509CrlStoreSelector : object {
    private X509Certificate certificateChecking;
    private Nullable`1<DateTime> dateAndTime;
    private IList`1<X509Name> issuers;
    private BigInteger maxCrlNumber;
    private BigInteger minCrlNumber;
    private X509V2AttributeCertificate attrCertChecking;
    private bool completeCrlEnabled;
    private bool deltaCrlIndicatorEnabled;
    private Byte[] issuingDistributionPoint;
    private bool issuingDistributionPointEnabled;
    private BigInteger maxBaseCrlNumber;
    public X509Certificate CertificateChecking { get; public set; }
    public Nullable`1<DateTime> DateAndTime { get; public set; }
    public IList`1<X509Name> Issuers { get; public set; }
    public BigInteger MaxCrlNumber { get; public set; }
    public BigInteger MinCrlNumber { get; public set; }
    public X509V2AttributeCertificate AttrCertChecking { get; public set; }
    public bool CompleteCrlEnabled { get; public set; }
    public bool DeltaCrlIndicatorEnabled { get; public set; }
    public Byte[] IssuingDistributionPoint { get; public set; }
    public bool IssuingDistributionPointEnabled { get; public set; }
    public BigInteger MaxBaseCrlNumber { get; public set; }
    public X509CrlStoreSelector(X509CrlStoreSelector o);
    public virtual object Clone();
    public X509Certificate get_CertificateChecking();
    public void set_CertificateChecking(X509Certificate value);
    public Nullable`1<DateTime> get_DateAndTime();
    public void set_DateAndTime(Nullable`1<DateTime> value);
    public IList`1<X509Name> get_Issuers();
    public void set_Issuers(IList`1<X509Name> value);
    public BigInteger get_MaxCrlNumber();
    public void set_MaxCrlNumber(BigInteger value);
    public BigInteger get_MinCrlNumber();
    public void set_MinCrlNumber(BigInteger value);
    public X509V2AttributeCertificate get_AttrCertChecking();
    public void set_AttrCertChecking(X509V2AttributeCertificate value);
    public bool get_CompleteCrlEnabled();
    public void set_CompleteCrlEnabled(bool value);
    public bool get_DeltaCrlIndicatorEnabled();
    public void set_DeltaCrlIndicatorEnabled(bool value);
    public Byte[] get_IssuingDistributionPoint();
    public void set_IssuingDistributionPoint(Byte[] value);
    public bool get_IssuingDistributionPointEnabled();
    public void set_IssuingDistributionPointEnabled(bool value);
    public BigInteger get_MaxBaseCrlNumber();
    public void set_MaxBaseCrlNumber(BigInteger value);
    public virtual bool Match(X509Crl c);
}
public static class Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory : object {
    public static SubjectPublicKeyInfo CreateSubjectPublicKeyInfo(AsymmetricKeyParameter publicKey);
    private static void ExtractBytes(Byte[] encKey, int offset, BigInteger bI);
    private static void ExtractBytes(Byte[] encKey, int size, int offSet, BigInteger bI);
}
public class Org.BouncyCastle.X509.X509AttrCertParser : object {
    private static PemParser PemAttrCertParser;
    private Asn1Set sData;
    private int sDataObjectCount;
    private Stream currentStream;
    private static X509AttrCertParser();
    private X509V2AttributeCertificate ReadDerCertificate(Asn1InputStream dIn);
    private X509V2AttributeCertificate GetCertificate();
    private X509V2AttributeCertificate ReadPemCertificate(Stream inStream);
    public X509V2AttributeCertificate ReadAttrCert(Byte[] input);
    public IList`1<X509V2AttributeCertificate> ReadAttrCerts(Byte[] input);
    public X509V2AttributeCertificate ReadAttrCert(Stream inStream);
    public IList`1<X509V2AttributeCertificate> ReadAttrCerts(Stream inStream);
}
public class Org.BouncyCastle.X509.X509Attribute : Asn1Encodable {
    private AttributeX509 attr;
    public string Oid { get; }
    internal X509Attribute(Asn1Encodable at);
    public X509Attribute(string oid, Asn1Encodable value);
    public X509Attribute(string oid, Asn1EncodableVector value);
    public string get_Oid();
    public Asn1Encodable[] GetValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.X509.X509Certificate : X509ExtensionBase {
    private X509CertificateStructure c;
    private string sigAlgName;
    private Byte[] sigAlgParams;
    private BasicConstraints basicConstraints;
    private Boolean[] keyUsage;
    private AsymmetricKeyParameter publicKeyValue;
    private CachedEncoding cachedEncoding;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hashValueSet;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) hashValue;
    public X509CertificateStructure CertificateStructure { get; }
    public bool IsValidNow { get; }
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public X509Name IssuerDN { get; }
    public X509Name SubjectDN { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public string SigAlgName { get; }
    public string SigAlgOid { get; }
    public DerBitString IssuerUniqueID { get; }
    public DerBitString SubjectUniqueID { get; }
    public X509Certificate(Byte[] certData);
    public X509Certificate(X509CertificateStructure c);
    public virtual X509CertificateStructure get_CertificateStructure();
    public virtual bool get_IsValidNow();
    public virtual bool IsValid(DateTime time);
    public virtual void CheckValidity();
    public virtual void CheckValidity(DateTime time);
    public virtual int get_Version();
    public virtual BigInteger get_SerialNumber();
    public virtual X509Name get_IssuerDN();
    public virtual X509Name get_SubjectDN();
    public virtual DateTime get_NotBefore();
    public virtual DateTime get_NotAfter();
    public virtual Byte[] GetTbsCertificate();
    public virtual Byte[] GetSignature();
    public virtual string get_SigAlgName();
    public virtual string get_SigAlgOid();
    public virtual Byte[] GetSigAlgParams();
    public virtual DerBitString get_IssuerUniqueID();
    public virtual DerBitString get_SubjectUniqueID();
    public virtual Boolean[] GetKeyUsage();
    public virtual IList`1<DerObjectIdentifier> GetExtendedKeyUsage();
    public virtual int GetBasicConstraints();
    public virtual GeneralNames GetIssuerAlternativeNameExtension();
    public virtual GeneralNames GetSubjectAlternativeNameExtension();
    public virtual IList`1<IList`1<object>> GetIssuerAlternativeNames();
    public virtual IList`1<IList`1<object>> GetSubjectAlternativeNames();
    protected virtual GeneralNames GetAlternativeNameExtension(DerObjectIdentifier oid);
    protected virtual IList`1<IList`1<object>> GetAlternativeNames(DerObjectIdentifier oid);
    protected virtual X509Extensions GetX509Extensions();
    public virtual AsymmetricKeyParameter GetPublicKey();
    public virtual Byte[] GetEncoded();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool IsSignatureValid(AsymmetricKeyParameter key);
    public virtual bool IsSignatureValid(IVerifierFactoryProvider verifierProvider);
    public virtual bool IsAlternativeSignatureValid(IVerifierFactoryProvider verifierProvider);
    public virtual void Verify(AsymmetricKeyParameter key);
    public virtual void Verify(IVerifierFactoryProvider verifierProvider);
    public virtual void VerifyAltSignature(IVerifierFactoryProvider verifierProvider);
    protected virtual void CheckSignature(IVerifierFactory verifier);
    protected virtual bool CheckSignatureValid(IVerifierFactory verifier);
    private CachedEncoding GetCachedEncoding();
    private static CachedEncoding CreateCachedEncoding(X509CertificateStructure c);
    private static AsymmetricKeyParameter CreatePublicKey(X509CertificateStructure c);
    private static bool IsAlgIDEqual(AlgorithmIdentifier id1, AlgorithmIdentifier id2);
}
public class Org.BouncyCastle.X509.X509CertificatePair : object {
    private X509Certificate m_forward;
    private X509Certificate m_reverse;
    public X509Certificate Forward { get; }
    public X509Certificate Reverse { get; }
    public X509CertificatePair(X509Certificate forward, X509Certificate reverse);
    public X509CertificatePair(CertificatePair pair);
    public CertificatePair GetCertificatePair();
    public Byte[] GetEncoded();
    public X509Certificate get_Forward();
    public X509Certificate get_Reverse();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.X509CertificateParser : object {
    private static PemParser PemCertParser;
    private Asn1Set sData;
    private int sDataObjectCount;
    private Stream currentStream;
    private static X509CertificateParser();
    private X509Certificate ReadDerCertificate(Asn1InputStream dIn);
    private X509Certificate ReadPemCertificate(Stream inStream);
    private X509Certificate GetCertificate();
    public X509Certificate ReadCertificate(Byte[] input);
    public IList`1<X509Certificate> ReadCertificates(Byte[] input);
    public X509Certificate ReadCertificate(Stream inStream);
    public IList`1<X509Certificate> ReadCertificates(Stream inStream);
    [IteratorStateMachineAttribute("Org.BouncyCastle.X509.X509CertificateParser/<ParseCertificates>d__11")]
public IEnumerable`1<X509Certificate> ParseCertificates(Stream inStream);
}
public class Org.BouncyCastle.X509.X509CertPairParser : object {
    private Stream currentStream;
    private X509CertificatePair ReadDerCrossCertificatePair(Stream inStream);
    public X509CertificatePair ReadCertPair(Byte[] input);
    public IList`1<X509CertificatePair> ReadCertPairs(Byte[] input);
    public X509CertificatePair ReadCertPair(Stream inStream);
    public IList`1<X509CertificatePair> ReadCertPairs(Stream inStream);
}
public class Org.BouncyCastle.X509.X509Crl : X509ExtensionBase {
    private CertificateList c;
    private string sigAlgName;
    private Byte[] sigAlgParams;
    private bool isIndirect;
    private CachedEncoding cachedEncoding;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hashValueSet;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) hashValue;
    public CertificateList CertificateList { get; }
    public int Version { get; }
    public X509Name IssuerDN { get; }
    public DateTime ThisUpdate { get; }
    public Nullable`1<DateTime> NextUpdate { get; }
    public string SigAlgName { get; }
    public string SigAlgOid { get; }
    protected bool IsIndirectCrl { get; }
    public X509Crl(Byte[] encoding);
    public X509Crl(CertificateList c);
    public virtual CertificateList get_CertificateList();
    protected virtual X509Extensions GetX509Extensions();
    public virtual bool IsSignatureValid(AsymmetricKeyParameter key);
    public virtual bool IsSignatureValid(IVerifierFactoryProvider verifierProvider);
    public virtual bool IsAlternativeSignatureValid(IVerifierFactoryProvider verifierProvider);
    public virtual void Verify(AsymmetricKeyParameter publicKey);
    public virtual void Verify(IVerifierFactoryProvider verifierProvider);
    public virtual void VerifyAltSignature(IVerifierFactoryProvider verifierProvider);
    protected virtual void CheckSignature(IVerifierFactory verifier);
    protected virtual bool CheckSignatureValid(IVerifierFactory verifier);
    public virtual int get_Version();
    public virtual X509Name get_IssuerDN();
    public virtual DateTime get_ThisUpdate();
    public virtual Nullable`1<DateTime> get_NextUpdate();
    private ISet`1<X509CrlEntry> LoadCrlEntries();
    public virtual X509CrlEntry GetRevokedCertificate(BigInteger serialNumber);
    public virtual ISet`1<X509CrlEntry> GetRevokedCertificates();
    public virtual Byte[] GetTbsCertList();
    public virtual Byte[] GetSignature();
    public virtual string get_SigAlgName();
    public virtual string get_SigAlgOid();
    public virtual Byte[] GetSigAlgParams();
    public virtual Byte[] GetEncoded();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool IsRevoked(X509Certificate cert);
    protected virtual bool get_IsIndirectCrl();
    private CachedEncoding GetCachedEncoding();
    private static CachedEncoding CreateCachedEncoding(CertificateList c);
}
public class Org.BouncyCastle.X509.X509CrlEntry : X509ExtensionBase {
    private CrlEntry c;
    private bool isIndirect;
    private X509Name previousCertificateIssuer;
    private X509Name certificateIssuer;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hashValueSet;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) hashValue;
    public BigInteger SerialNumber { get; }
    public DateTime RevocationDate { get; }
    public bool HasExtensions { get; }
    public X509CrlEntry(CrlEntry c);
    public X509CrlEntry(CrlEntry c, bool isIndirect, X509Name previousCertificateIssuer);
    private X509Name loadCertificateIssuer();
    public X509Name GetCertificateIssuer();
    protected virtual X509Extensions GetX509Extensions();
    public Byte[] GetEncoded();
    public BigInteger get_SerialNumber();
    public DateTime get_RevocationDate();
    public bool get_HasExtensions();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Org.BouncyCastle.X509.X509CrlParser : object {
    private static PemParser PemCrlParser;
    private Asn1Set sCrlData;
    private int sCrlDataObjectCount;
    private Stream currentCrlStream;
    [ObsoleteAttribute("Will be removed")]
public X509CrlParser(bool lazyAsn1);
    private static X509CrlParser();
    private X509Crl ReadDerCrl(Asn1InputStream dIn);
    private X509Crl ReadPemCrl(Stream inStream);
    private X509Crl GetCrl();
    public X509Crl ReadCrl(Byte[] input);
    public IList`1<X509Crl> ReadCrls(Byte[] input);
    public X509Crl ReadCrl(Stream inStream);
    public IList`1<X509Crl> ReadCrls(Stream inStream);
    [IteratorStateMachineAttribute("Org.BouncyCastle.X509.X509CrlParser/<ParseCrls>d__13")]
public IEnumerable`1<X509Crl> ParseCrls(Stream inStream);
}
public abstract class Org.BouncyCastle.X509.X509ExtensionBase : object {
    protected abstract virtual X509Extensions GetX509Extensions();
    protected virtual ISet`1<string> GetExtensionOids(bool critical);
    public virtual ISet`1<string> GetNonCriticalExtensionOids();
    public virtual ISet`1<string> GetCriticalExtensionOids();
    public virtual Asn1OctetString GetExtensionValue(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.X509.X509KeyUsage : Asn1Encodable {
    public static int DigitalSignature;
    public static int NonRepudiation;
    public static int KeyEncipherment;
    public static int DataEncipherment;
    public static int KeyAgreement;
    public static int KeyCertSign;
    public static int CrlSign;
    public static int EncipherOnly;
    public static int DecipherOnly;
    private int usage;
    public X509KeyUsage(int usage);
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.X509.X509SignatureUtilities : object {
    private static Asn1Null derNull;
    private static X509SignatureUtilities();
    internal static void SetSignatureParameters(ISigner signature, Asn1Encodable parameters);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
}
internal static class Org.BouncyCastle.X509.X509Utilities : object {
    private static Dictionary`2<string, DerObjectIdentifier> m_algorithms;
    private static Dictionary`2<string, Asn1Encodable> m_exParams;
    private static HashSet`1<DerObjectIdentifier> m_noParams;
    private static X509Utilities();
    internal static TResult CalculateResult(IStreamCalculator`1<TResult> streamCalculator, Asn1Encodable asn1Encodable);
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    internal static DerBitString CollectDerBitString(IBlockResult result);
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid, string algorithmName);
    internal static IEnumerable`1<string> GetAlgNames();
    internal static DerBitString GenerateBitString(IStreamCalculator`1<IBlockResult> streamCalculator, Asn1Encodable asn1Encodable);
    internal static DerBitString GenerateMac(IMacFactory macFactory, Asn1Encodable asn1Encodable);
    internal static DerBitString GenerateSignature(ISignatureFactory signatureFactory, Asn1Encodable asn1Encodable);
    internal static bool VerifySignature(IVerifierFactory verifierFactory, Asn1Encodable asn1Encodable, DerBitString signature);
    internal static Asn1TaggedObject TrimExtensions(int tagNo, X509Extensions exts);
}
public class Org.BouncyCastle.X509.X509V1CertificateGenerator : object {
    private V1TbsCertificateGenerator tbsGen;
    public IEnumerable`1<string> SignatureAlgNames { get; }
    public void Reset();
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetIssuerDN(X509Name issuer);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSubjectDN(X509Name subject);
    public void SetPublicKey(AsymmetricKeyParameter publicKey);
    public X509Certificate Generate(ISignatureFactory signatureFactory);
    public IEnumerable`1<string> get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V2AttributeCertificate : X509ExtensionBase {
    private AttributeCertificate cert;
    private DateTime notBefore;
    private DateTime notAfter;
    public AttributeCertificate AttributeCertificate { get; }
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public AttributeCertificateHolder Holder { get; }
    public AttributeCertificateIssuer Issuer { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public bool IsValidNow { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public X509V2AttributeCertificate(Stream encIn);
    public X509V2AttributeCertificate(Byte[] encoded);
    public X509V2AttributeCertificate(AttributeCertificate cert);
    private static AttributeCertificate GetObject(Stream input);
    public virtual AttributeCertificate get_AttributeCertificate();
    public virtual int get_Version();
    public virtual BigInteger get_SerialNumber();
    public virtual AttributeCertificateHolder get_Holder();
    public virtual AttributeCertificateIssuer get_Issuer();
    public virtual DateTime get_NotBefore();
    public virtual DateTime get_NotAfter();
    public virtual Boolean[] GetIssuerUniqueID();
    public virtual bool get_IsValidNow();
    public virtual bool IsValid(DateTime date);
    public virtual void CheckValidity();
    public virtual void CheckValidity(DateTime date);
    public virtual AlgorithmIdentifier get_SignatureAlgorithm();
    public virtual Byte[] GetSignature();
    public virtual bool IsSignatureValid(AsymmetricKeyParameter key);
    public virtual bool IsSignatureValid(IVerifierFactoryProvider verifierProvider);
    public virtual void Verify(AsymmetricKeyParameter key);
    public virtual void Verify(IVerifierFactoryProvider verifierProvider);
    protected virtual void CheckSignature(IVerifierFactory verifier);
    protected virtual bool CheckSignatureValid(IVerifierFactory verifier);
    public virtual Byte[] GetEncoded();
    protected virtual X509Extensions GetX509Extensions();
    public virtual X509Attribute[] GetAttributes();
    public virtual X509Attribute[] GetAttributes(string oid);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V2AttributeCertificateInfoGenerator acInfoGen;
    public IEnumerable`1<string> SignatureAlgNames { get; }
    public void Reset();
    public void SetHolder(AttributeCertificateHolder holder);
    public void SetIssuer(AttributeCertificateIssuer issuer);
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void AddAttribute(X509Attribute attribute);
    public void SetIssuerUniqueId(Boolean[] iui);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public X509V2AttributeCertificate Generate(ISignatureFactory signatureFactory);
    public IEnumerable`1<string> get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V2CrlGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V2TbsCertListGenerator tbsGen;
    public IEnumerable`1<string> SignatureAlgNames { get; }
    public X509V2CrlGenerator(X509Crl template);
    public X509V2CrlGenerator(CertificateList template);
    public void Reset();
    public void SetIssuerDN(X509Name issuer);
    public void SetThisUpdate(DateTime date);
    public void SetNextUpdate(DateTime date);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, int reason);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, int reason, DateTime invalidityDate);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, X509Extensions extensions);
    public void AddCrl(X509Crl other);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extensionValue);
    public X509Crl Generate(ISignatureFactory signatureFactory);
    public X509Crl Generate(ISignatureFactory signatureFactory, bool isCritical, ISignatureFactory altSignatureFactory);
    public IEnumerable`1<string> get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V3CertificateGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V3TbsCertificateGenerator tbsGen;
    public IEnumerable`1<string> SignatureAlgNames { get; }
    public X509V3CertificateGenerator(X509Certificate template);
    public X509V3CertificateGenerator(X509CertificateStructure template);
    public void Reset();
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetIssuerDN(X509Name issuer);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSubjectDN(X509Name subject);
    public void SetPublicKey(AsymmetricKeyParameter publicKey);
    public void SetSubjectUniqueID(Boolean[] uniqueID);
    public void SetIssuerUniqueID(Boolean[] uniqueID);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extensionValue);
    public void CopyAndAddExtension(string oid, bool critical, X509Certificate cert);
    public void CopyAndAddExtension(DerObjectIdentifier oid, bool critical, X509Certificate cert);
    public X509Certificate Generate(ISignatureFactory signatureFactory);
    public X509Certificate Generate(ISignatureFactory signatureFactory, bool isCritical, ISignatureFactory altSignatureFactory);
    public IEnumerable`1<string> get_SignatureAlgNames();
    private static DerBitString BooleanToBitString(Boolean[] id);
}
