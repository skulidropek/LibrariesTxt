[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public abstract class C5.ArrayBase`1 : SequencedBase`1<T> {
    protected T[] array;
    protected int offsetField;
    public IDirectedCollectionValue`1<T> Item { get; }
    protected ArrayBase`1(int capacity, IEqualityComparer`1<T> itemequalityComparer);
    protected virtual void Expand();
    protected virtual void Expand(int newcapacity, int newsize);
    protected virtual void InsertProtected(int i, T item);
    public virtual IDirectedCollectionValue`1<T> get_Item(int start, int count);
    public virtual void Clear();
    public virtual T[] ToArray();
    public virtual bool Check();
    public virtual IDirectedCollectionValue`1<T> Backwards();
    public virtual T Choose();
    [IteratorStateMachineAttribute("C5.ArrayBase`1/<GetEnumerator>d__13")]
public virtual IEnumerator`1<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.ArrayList`1 : ArrayBase`1<T> {
    private bool isValid;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayList`1<T> underlying;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakViewList`1<ArrayList`1<T>> views;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<ArrayList`1<T>> myWeakReference;
    private bool fIFO;
    private int Underlyingsize { get; }
    public EventType ListenableEvents { get; }
    public T First { get; }
    public T Last { get; }
    public bool FIFO { get; public set; }
    public bool IsFixedSize { get; }
    public T Item { get; public set; }
    public Speed IndexingSpeed { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<T> Underlying { get; }
    public int Offset { get; }
    public bool IsValid { get; }
    public Speed ContainsSpeed { get; }
    public bool AllowsDuplicates { get; }
    public bool DuplicatesByCounting { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    [ObsoleteAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ArrayList`1(IEqualityComparer`1<T> itemequalityComparer);
    public ArrayList`1(int capacity);
    public ArrayList`1(int capacity, IEqualityComparer`1<T> itemequalityComparer);
    private int get_Underlyingsize();
    public virtual EventType get_ListenableEvents();
    private bool Equals(T i1, T i2);
    private void AddToSize(int delta);
    protected virtual void Expand();
    protected virtual void Expand(int newcapacity, int newsize);
    protected virtual void UpdateCheck();
    private void ValidityCheck();
    protected virtual void ModifyCheck(int stamp);
    private int IndexOfInner(T item);
    private int LastIndexOfInner(T item);
    protected virtual void InsertProtected(int i, T item);
    private void BaseInsertInner(int i, T item);
    private T RemoveAtInner(int i);
    private void FixViewsAfterInsert(int added, int realInsertionIndex);
    private void FixViewsBeforeSingleRemove(int realRemovalIndex);
    private void FixViewsBeforeRemove(int start, int count);
    private MutualViewPosition ViewPosition(int otherOffset, int otherSize);
    private void DisposeOverlappingViews(bool reverse);
    public virtual T get_First();
    public virtual T get_Last();
    public virtual bool get_FIFO();
    public virtual void set_FIFO(bool value);
    public virtual bool get_IsFixedSize();
    public virtual T get_Item(int index);
    public virtual void set_Item(int index, T value);
    public virtual Speed get_IndexingSpeed();
    public virtual void Insert(int index, T item);
    public sealed virtual void Insert(IList`1<T> pointer, T item);
    public virtual void InsertAll(int index, IEnumerable`1<T> items);
    private void RaiseForInsertAll(int index, int added);
    public virtual void InsertFirst(T item);
    public virtual void InsertLast(T item);
    public virtual IList`1<T> FindAll(Func`2<T, bool> filter);
    public virtual IList`1<V> Map(Func`2<T, V> mapper);
    public virtual IList`1<V> Map(Func`2<T, V> mapper, IEqualityComparer`1<V> itemequalityComparer);
    private IList`1<V> Map(Func`2<T, V> mapper, ArrayList`1<V> res);
    public virtual T Remove();
    public virtual T RemoveFirst();
    public virtual T RemoveLast();
    public virtual IList`1<T> View(int start, int count);
    public virtual IList`1<T> ViewOf(T item);
    public virtual IList`1<T> LastViewOf(T item);
    public virtual IList`1<T> get_Underlying();
    public virtual int get_Offset();
    public virtual bool get_IsValid();
    public virtual IList`1<T> Slide(int offset);
    public virtual IList`1<T> Slide(int offset, int size);
    public virtual bool TrySlide(int offset);
    public virtual bool TrySlide(int offset, int size);
    public virtual IList`1<T> Span(IList`1<T> otherView);
    public virtual void Reverse();
    public sealed virtual bool IsSorted();
    public virtual bool IsSorted(IComparer`1<T> c);
    public virtual void Sort();
    public virtual void Sort(IComparer`1<T> comparer);
    public virtual void Shuffle();
    public virtual void Shuffle(Random rnd);
    public virtual int IndexOf(T item);
    public virtual int LastIndexOf(T item);
    public virtual T RemoveAt(int index);
    public virtual void RemoveInterval(int start, int count);
    private void RaiseForRemoveInterval(int start, int count);
    public virtual Speed get_ContainsSpeed();
    public virtual int GetUnsequencedHashCode();
    public virtual bool UnsequencedEquals(ICollection`1<T> that);
    public virtual bool Contains(T item);
    public virtual bool Find(T& item);
    public virtual bool Update(T item);
    public virtual bool Update(T item, T& olditem);
    public virtual bool FindOrAdd(T& item);
    public virtual bool UpdateOrAdd(T item);
    public virtual bool UpdateOrAdd(T item, T& olditem);
    public virtual bool Remove(T item);
    public virtual bool Remove(T item, T& removeditem);
    public virtual void RemoveAll(IEnumerable`1<T> items);
    public virtual void Clear();
    public virtual void RetainAll(IEnumerable`1<T> items);
    public virtual bool ContainsAll(IEnumerable`1<T> items);
    public virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public virtual void RemoveAllCopies(T item);
    public virtual bool Check();
    public virtual bool get_AllowsDuplicates();
    public virtual bool get_DuplicatesByCounting();
    public virtual bool Add(T item);
    public virtual void AddAll(IEnumerable`1<T> items);
    private void RaiseForAddAll(int start, int added);
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public virtual int get_Count();
    public virtual IEnumerator`1<T> GetEnumerator();
    public virtual void Push(T item);
    public virtual T Pop();
    public virtual void Enqueue(T item);
    public virtual T Dequeue();
    public virtual void Dispose();
    private void Dispose(bool disposingUnderlying);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array arr, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object o);
    private sealed virtual override bool System.Collections.IList.Contains(object o);
    private sealed virtual override int System.Collections.IList.IndexOf(object o);
    private sealed virtual override void System.Collections.IList.Insert(int index, object o);
    private sealed virtual override void System.Collections.IList.Remove(object o);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.C5Random : Random {
    private UInt32[] Q;
    private UInt32 c;
    private UInt32 i;
    public C5Random(long seed);
    [CLSCompliantAttribute("False")]
public C5Random(UInt32[] Q);
    private UInt32 Cmwc();
    public virtual double NextDouble();
    protected virtual double Sample();
    public virtual int Next();
    public virtual int Next(int max);
    public virtual int Next(int min, int max);
    public virtual void NextBytes(Byte[] buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.CircularQueue`1 : SequencedBase`1<T> {
    private int front;
    private int back;
    private T[] array;
    private bool forwards;
    private bool original;
    public EventType ListenableEvents { get; }
    public bool AllowsDuplicates { get; }
    public T Item { get; }
    public CircularQueue`1(int capacity);
    public virtual EventType get_ListenableEvents();
    private void Expand();
    public virtual bool get_AllowsDuplicates();
    public virtual T get_Item(int i);
    public virtual void Enqueue(T item);
    public virtual T Dequeue();
    public sealed virtual void Push(T item);
    public sealed virtual T Pop();
    public virtual T Choose();
    [IteratorStateMachineAttribute("C5.CircularQueue`1/<GetEnumerator>d__19")]
public virtual IEnumerator`1<T> GetEnumerator();
    public virtual IDirectedCollectionValue`1<T> Backwards();
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public virtual bool Check();
}
public class C5.ClearedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <Full>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public bool Full { get; }
    public int Count { get; }
    public ClearedEventArgs(bool full, int count);
    [CompilerGeneratedAttribute]
public bool get_Full();
    [CompilerGeneratedAttribute]
public int get_Count();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public class C5.ClearedRangeEventArgs : ClearedEventArgs {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Start>k__BackingField;
    public Nullable`1<int> Start { get; }
    public ClearedRangeEventArgs(bool full, int count, Nullable`1<int> start);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Start();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class C5.CollectionBase`1 : CollectionValueBase`1<T> {
    protected bool isReadOnlyBase;
    protected int stamp;
    protected int size;
    protected IEqualityComparer`1<T> itemequalityComparer;
    private int iUnSequencedHashCode;
    private int iUnSequencedHashCodeStamp;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Speed CountSpeed { get; }
    public IEqualityComparer`1<T> EqualityComparer { get; }
    public bool IsEmpty { get; }
    protected CollectionBase`1(IEqualityComparer`1<T> itemequalityComparer);
    protected void CheckRange(int start, int count);
    public static int ComputeHashCode(ICollectionValue`1<T> items, IEqualityComparer`1<T> itemequalityComparer);
    public static bool StaticEquals(ICollection`1<T> collection1, ICollection`1<T> collection2, IEqualityComparer`1<T> itemequalityComparer);
    public virtual int GetUnsequencedHashCode();
    public virtual bool UnsequencedEquals(ICollection`1<T> otherCollection);
    protected virtual void ModifyCheck(int thestamp);
    protected virtual void UpdateCheck();
    public virtual bool get_IsReadOnly();
    public virtual int get_Count();
    public virtual Speed get_CountSpeed();
    public virtual IEqualityComparer`1<T> get_EqualityComparer();
    public virtual bool get_IsEmpty();
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public class C5.CollectionChangedHandler`1 : MulticastDelegate {
    public CollectionChangedHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class C5.CollectionClearedHandler`1 : MulticastDelegate {
    public CollectionClearedHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, ClearedEventArgs eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, ClearedEventArgs eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class C5.CollectionModifiedException : Exception {
    [NullableContextAttribute("1")]
public CollectionModifiedException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class C5.CollectionValueBase`1 : EnumerableBase`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventBlock`1<T> eventBlock;
    public EventType ListenableEvents { get; }
    public EventType ActiveEvents { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public Speed CountSpeed { get; }
    public virtual EventType get_ListenableEvents();
    public virtual EventType get_ActiveEvents();
    private void CheckWillListen(EventType eventType);
    public virtual void add_CollectionChanged(CollectionChangedHandler`1<T> value);
    public virtual void remove_CollectionChanged(CollectionChangedHandler`1<T> value);
    protected virtual void RaiseCollectionChanged();
    public virtual void add_CollectionCleared(CollectionClearedHandler`1<T> value);
    public virtual void remove_CollectionCleared(CollectionClearedHandler`1<T> value);
    protected virtual void RaiseCollectionCleared(bool full, int count);
    protected virtual void RaiseCollectionCleared(bool full, int count, Nullable`1<int> offset);
    public virtual void add_ItemsAdded(ItemsAddedHandler`1<T> value);
    public virtual void remove_ItemsAdded(ItemsAddedHandler`1<T> value);
    protected virtual void RaiseItemsAdded(T item, int count);
    public virtual void add_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    public virtual void remove_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    protected virtual void RaiseItemsRemoved(T item, int count);
    public virtual void add_ItemInserted(ItemInsertedHandler`1<T> value);
    public virtual void remove_ItemInserted(ItemInsertedHandler`1<T> value);
    protected virtual void RaiseItemInserted(T item, int index);
    public virtual void add_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    public virtual void remove_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    protected virtual void RaiseItemRemovedAt(T item, int index);
    protected virtual void RaiseForSetThis(int index, T value, T item);
    protected virtual void RaiseForInsert(int i, T item);
    protected void RaiseForRemove(T item);
    protected void RaiseForRemove(T item, int count);
    protected void RaiseForRemoveAt(int index, T item);
    protected virtual void RaiseForUpdate(T newitem, T olditem);
    protected virtual void RaiseForUpdate(T newitem, T olditem, int count);
    protected virtual void RaiseForAdd(T item);
    protected virtual void RaiseForRemoveAll(ICollectionValue`1<T> wasRemoved);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual Speed get_CountSpeed();
    public virtual void CopyTo(T[] array, int index);
    public virtual T[] ToArray();
    public virtual void Apply(Action`1<T> action);
    public virtual bool Exists(Func`2<T, bool> predicate);
    public virtual bool Find(Func`2<T, bool> predicate, T& item);
    public virtual bool All(Func`2<T, bool> predicate);
    [IteratorStateMachineAttribute("C5.CollectionValueBase`1/<Filter>d__53")]
public virtual IEnumerable`1<T> Filter(Func`2<T, bool> predicate);
    public abstract virtual T Choose();
    public abstract virtual IEnumerator`1<T> GetEnumerator();
    public virtual bool Show(StringBuilder stringbuilder, Int32& rest, IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class C5.ComparerFactory`1 : object {
    public static IComparer`1<T> CreateComparer(Func`3<T, T, int> comparer);
    public static IEqualityComparer`1<T> CreateEqualityComparer(Func`3<T, T, bool> equals, Func`2<T, int> getHashCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class C5.ComparerZeroHashCodeEqualityComparer`1 : object {
    private IComparer`1<T> comparer;
    public ComparerZeroHashCodeEqualityComparer`1(IComparer`1<T> comparer);
    public sealed virtual int GetHashCode(T item);
    public sealed virtual bool Equals(T item1, T item2);
}
internal class C5.Debug : object {
    [CompilerGeneratedAttribute]
private static bool <UseDeterministicHashing>k__BackingField;
    internal static bool UseDeterministicHashing { get; internal set; }
    [CompilerGeneratedAttribute]
internal static bool get_UseDeterministicHashing();
    [CompilerGeneratedAttribute]
internal static void set_UseDeterministicHashing(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public abstract class C5.DictionaryBase`2 : CollectionValueBase`1<KeyValuePair`2<K, V>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ICollection`1<KeyValuePair`2<K, V>> pairs;
    private IEqualityComparer`1<K> keyequalityComparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ProxyEventBlock`1<KeyValuePair`2<K, V>> eventBlock;
    public EventType ListenableEvents { get; }
    public EventType ActiveEvents { get; }
    public IEqualityComparer`1<K> EqualityComparer { get; }
    public Speed ContainsSpeed { get; }
    public ICollectionValue`1<K> Keys { get; }
    public ICollectionValue`1<V> Values { get; }
    public Func`2<K, V> Func { get; }
    public V Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public Speed CountSpeed { get; }
    protected DictionaryBase`2(IEqualityComparer`1<K> keyequalityComparer);
    public virtual void add_CollectionChanged(CollectionChangedHandler`1<KeyValuePair`2<K, V>> value);
    public virtual void remove_CollectionChanged(CollectionChangedHandler`1<KeyValuePair`2<K, V>> value);
    public virtual void add_CollectionCleared(CollectionClearedHandler`1<KeyValuePair`2<K, V>> value);
    public virtual void remove_CollectionCleared(CollectionClearedHandler`1<KeyValuePair`2<K, V>> value);
    public virtual void add_ItemsAdded(ItemsAddedHandler`1<KeyValuePair`2<K, V>> value);
    public virtual void remove_ItemsAdded(ItemsAddedHandler`1<KeyValuePair`2<K, V>> value);
    public virtual void add_ItemsRemoved(ItemsRemovedHandler`1<KeyValuePair`2<K, V>> value);
    public virtual void remove_ItemsRemoved(ItemsRemovedHandler`1<KeyValuePair`2<K, V>> value);
    public virtual EventType get_ListenableEvents();
    public virtual EventType get_ActiveEvents();
    public virtual IEqualityComparer`1<K> get_EqualityComparer();
    public virtual void Add(K key, V value);
    [NullableContextAttribute("0")]
public virtual void AddAll(IEnumerable`1<KeyValuePair`2<L, W>> entries);
    public virtual bool Remove(K key);
    public virtual bool Remove(K key, V& value);
    public virtual void Clear();
    public virtual Speed get_ContainsSpeed();
    public virtual bool Contains(K key);
    public virtual bool ContainsAll(IEnumerable`1<H> keys);
    public virtual bool Find(K& key, V& value);
    public virtual bool Update(K key, V value);
    public virtual bool Update(K key, V value, V& oldvalue);
    public virtual bool FindOrAdd(K key, V& value);
    public virtual bool UpdateOrAdd(K key, V value);
    public virtual bool UpdateOrAdd(K key, V value, V& oldvalue);
    public virtual ICollectionValue`1<K> get_Keys();
    public virtual ICollectionValue`1<V> get_Values();
    public virtual Func`2<K, V> get_Func();
    public virtual V get_Item(K key);
    public virtual void set_Item(K key, V value);
    public virtual bool get_IsReadOnly();
    public virtual bool Check();
    public virtual bool get_IsEmpty();
    public virtual int get_Count();
    public virtual Speed get_CountSpeed();
    public virtual KeyValuePair`2<K, V> Choose();
    public virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public virtual bool Show(StringBuilder stringbuilder, Int32& rest, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
private V <get_Func>b__45_0(K k);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class C5.DirectedCollectionBase`1 : CollectionBase`1<T> {
    public Direction Direction { get; }
    protected DirectedCollectionBase`1(IEqualityComparer`1<T> itemequalityComparer);
    public virtual Direction get_Direction();
    public abstract virtual IDirectedCollectionValue`1<T> Backwards();
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public virtual bool FindLast(Func`2<T, bool> predicate, T& item);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class C5.DirectedCollectionValueBase`1 : CollectionValueBase`1<T> {
    public Direction Direction { get; }
    public virtual Direction get_Direction();
    [NullableContextAttribute("1")]
public abstract virtual IDirectedCollectionValue`1<T> Backwards();
    [NullableContextAttribute("1")]
private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    [NullableContextAttribute("1")]
public virtual bool FindLast(Func`2<T, bool> predicate, T& item);
}
public enum C5.Direction : Enum {
    public int value__;
    public static Direction Forwards;
    public static Direction Backwards;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class C5.DropMultiplicity`1 : MappedCollectionValue`2<KeyValuePair`2<K, int>, K> {
    public DropMultiplicity`1(ICollectionValue`1<KeyValuePair`2<K, int>> coll);
    public virtual K Map(KeyValuePair`2<K, int> kvp);
}
public class C5.DuplicateNotAllowedException : Exception {
    [NullableContextAttribute("1")]
public DuplicateNotAllowedException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class C5.EnumerableBase`1 : object {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
    protected static int CountItems(IEnumerable`1<T> items);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class C5.EqualityComparer`1 : object {
    private static IEqualityComparer`1<T> _default;
    private static Type SequencedCollectionEqualityComparer;
    private static Type UnsequencedCollectionEqualityComparer;
    public static IEqualityComparer`1<T> Default { get; }
    private static EqualityComparer`1();
    public static IEqualityComparer`1<T> get_Default();
    private static IEqualityComparer`1<T> CreateAndCache(Type equalityComparertype);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class C5.EventBlock`1 : object {
    internal EventType events;
    [CompilerGeneratedAttribute]
private CollectionChangedHandler`1<T> CollectionChangedInner;
    [CompilerGeneratedAttribute]
private CollectionClearedHandler`1<T> CollectionClearedInner;
    [CompilerGeneratedAttribute]
private ItemsAddedHandler`1<T> ItemsAddedInner;
    [CompilerGeneratedAttribute]
private ItemsRemovedHandler`1<T> ItemsRemovedInner;
    [CompilerGeneratedAttribute]
private ItemInsertedHandler`1<T> ItemInsertedInner;
    [CompilerGeneratedAttribute]
private ItemRemovedAtHandler`1<T> ItemRemovedAtInner;
    [CompilerGeneratedAttribute]
private void add_CollectionChangedInner(CollectionChangedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_CollectionChangedInner(CollectionChangedHandler`1<T> value);
    internal void add_CollectionChanged(CollectionChangedHandler`1<T> value);
    internal void remove_CollectionChanged(CollectionChangedHandler`1<T> value);
    internal void RaiseCollectionChanged(object sender);
    [CompilerGeneratedAttribute]
private void add_CollectionClearedInner(CollectionClearedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_CollectionClearedInner(CollectionClearedHandler`1<T> value);
    internal void add_CollectionCleared(CollectionClearedHandler`1<T> value);
    internal void remove_CollectionCleared(CollectionClearedHandler`1<T> value);
    internal void RaiseCollectionCleared(object sender, bool full, int count);
    internal void RaiseCollectionCleared(object sender, bool full, int count, Nullable`1<int> start);
    [CompilerGeneratedAttribute]
private void add_ItemsAddedInner(ItemsAddedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_ItemsAddedInner(ItemsAddedHandler`1<T> value);
    internal void add_ItemsAdded(ItemsAddedHandler`1<T> value);
    internal void remove_ItemsAdded(ItemsAddedHandler`1<T> value);
    internal void RaiseItemsAdded(object sender, T item, int count);
    [CompilerGeneratedAttribute]
private void add_ItemsRemovedInner(ItemsRemovedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_ItemsRemovedInner(ItemsRemovedHandler`1<T> value);
    internal void add_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    internal void remove_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    internal void RaiseItemsRemoved(object sender, T item, int count);
    [CompilerGeneratedAttribute]
private void add_ItemInsertedInner(ItemInsertedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_ItemInsertedInner(ItemInsertedHandler`1<T> value);
    internal void add_ItemInserted(ItemInsertedHandler`1<T> value);
    internal void remove_ItemInserted(ItemInsertedHandler`1<T> value);
    internal void RaiseItemInserted(object sender, T item, int index);
    [CompilerGeneratedAttribute]
private void add_ItemRemovedAtInner(ItemRemovedAtHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_ItemRemovedAtInner(ItemRemovedAtHandler`1<T> value);
    internal void add_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    internal void remove_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    internal void RaiseItemRemovedAt(object sender, T item, int index);
}
[FlagsAttribute]
public enum C5.EventType : Enum {
    public int value__;
    public static EventType None;
    public static EventType Changed;
    public static EventType Cleared;
    public static EventType Added;
    public static EventType Removed;
    public static EventType Basic;
    public static EventType Inserted;
    public static EventType RemovedAt;
    public static EventType All;
}
public class C5.FixedSizeCollectionException : Exception {
    [NullableContextAttribute("1")]
public FixedSizeCollectionException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.GuardedCollection`1 : GuardedCollectionValue`1<T> {
    private ICollection`1<T> collection;
    public bool IsReadOnly { get; }
    public Speed ContainsSpeed { get; }
    public bool AllowsDuplicates { get; }
    public IEqualityComparer`1<T> EqualityComparer { get; }
    public bool DuplicatesByCounting { get; }
    public bool IsEmpty { get; }
    public GuardedCollection`1(ICollection`1<T> collection);
    public virtual bool get_IsReadOnly();
    public virtual Speed get_ContainsSpeed();
    public virtual int GetUnsequencedHashCode();
    public virtual bool UnsequencedEquals(ICollection`1<T> that);
    public virtual bool Contains(T item);
    public virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public virtual bool ContainsAll(IEnumerable`1<T> items);
    public virtual bool Find(T& item);
    public virtual bool FindOrAdd(T& item);
    public virtual bool Update(T item);
    public virtual bool Update(T item, T& olditem);
    public virtual bool UpdateOrAdd(T item);
    public virtual bool UpdateOrAdd(T item, T& olditem);
    public virtual bool Remove(T item);
    public virtual bool Remove(T item, T& removeditem);
    public virtual void RemoveAllCopies(T item);
    public virtual void RemoveAll(IEnumerable`1<T> items);
    public virtual void Clear();
    public virtual void RetainAll(IEnumerable`1<T> items);
    public virtual bool Check();
    public virtual bool get_AllowsDuplicates();
    public virtual IEqualityComparer`1<T> get_EqualityComparer();
    public virtual bool get_DuplicatesByCounting();
    public virtual bool get_IsEmpty();
    public virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public virtual void AddAll(IEnumerable`1<T> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.GuardedCollectionValue`1 : GuardedEnumerable`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ProxyEventBlock`1<T> eventBlock;
    private ICollectionValue`1<T> collectionvalue;
    public EventType ListenableEvents { get; }
    public EventType ActiveEvents { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public Speed CountSpeed { get; }
    public GuardedCollectionValue`1(ICollectionValue`1<T> collectionvalue);
    public virtual EventType get_ListenableEvents();
    public virtual EventType get_ActiveEvents();
    public sealed virtual void add_CollectionChanged(CollectionChangedHandler`1<T> value);
    public sealed virtual void remove_CollectionChanged(CollectionChangedHandler`1<T> value);
    public sealed virtual void add_CollectionCleared(CollectionClearedHandler`1<T> value);
    public sealed virtual void remove_CollectionCleared(CollectionClearedHandler`1<T> value);
    public sealed virtual void add_ItemsAdded(ItemsAddedHandler`1<T> value);
    public sealed virtual void remove_ItemsAdded(ItemsAddedHandler`1<T> value);
    public sealed virtual void add_ItemInserted(ItemInsertedHandler`1<T> value);
    public sealed virtual void remove_ItemInserted(ItemInsertedHandler`1<T> value);
    public sealed virtual void add_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    public sealed virtual void remove_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    public sealed virtual void add_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    public sealed virtual void remove_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    public virtual bool get_IsEmpty();
    public virtual int get_Count();
    public virtual Speed get_CountSpeed();
    public virtual void CopyTo(T[] a, int i);
    public virtual T[] ToArray();
    public virtual void Apply(Action`1<T> a);
    public virtual bool Exists(Func`2<T, bool> filter);
    public virtual bool Find(Func`2<T, bool> filter, T& item);
    public virtual bool All(Func`2<T, bool> filter);
    public virtual IEnumerable`1<T> Filter(Func`2<T, bool> filter);
    public virtual T Choose();
    public sealed virtual bool Show(StringBuilder stringbuilder, Int32& rest, IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.GuardedDictionary`2 : GuardedCollectionValue`1<KeyValuePair`2<K, V>> {
    private IDictionary`2<K, V> dict;
    public IEqualityComparer`1<K> EqualityComparer { get; }
    public V Item { get; public set; }
    public bool IsReadOnly { get; }
    public ICollectionValue`1<K> Keys { get; }
    public ICollectionValue`1<V> Values { get; }
    public Func`2<K, V> Func { get; }
    public Speed ContainsSpeed { get; }
    public GuardedDictionary`2(IDictionary`2<K, V> dict);
    public sealed virtual IEqualityComparer`1<K> get_EqualityComparer();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollectionValue`1<K> get_Keys();
    public sealed virtual ICollectionValue`1<V> get_Values();
    public virtual Func`2<K, V> get_Func();
    public sealed virtual void Add(K key, V val);
    [NullableContextAttribute("0")]
public sealed virtual void AddAll(IEnumerable`1<KeyValuePair`2<L, W>> items);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool Remove(K key, V& val);
    public sealed virtual void Clear();
    public sealed virtual Speed get_ContainsSpeed();
    public sealed virtual bool Contains(K key);
    public sealed virtual bool ContainsAll(IEnumerable`1<H> keys);
    public sealed virtual bool Find(K& key, V& val);
    public sealed virtual bool Update(K key, V val);
    public sealed virtual bool Update(K key, V val, V& oldval);
    public sealed virtual bool FindOrAdd(K key, V& val);
    public sealed virtual bool UpdateOrAdd(K key, V val);
    public sealed virtual bool UpdateOrAdd(K key, V val, V& oldval);
    public sealed virtual bool Check();
    [CompilerGeneratedAttribute]
private V <get_Func>b__14_0(K k);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.GuardedDirectedCollectionValue`1 : GuardedCollectionValue`1<T> {
    private IDirectedCollectionValue`1<T> directedcollection;
    public Direction Direction { get; }
    public GuardedDirectedCollectionValue`1(IDirectedCollectionValue`1<T> directedcollection);
    public virtual IDirectedCollectionValue`1<T> Backwards();
    public virtual bool FindLast(Func`2<T, bool> predicate, T& item);
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public sealed virtual Direction get_Direction();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.GuardedDirectedEnumerable`1 : GuardedEnumerable`1<T> {
    private IDirectedEnumerable`1<T> directedenumerable;
    public Direction Direction { get; }
    public GuardedDirectedEnumerable`1(IDirectedEnumerable`1<T> directedenumerable);
    public sealed virtual IDirectedEnumerable`1<T> Backwards();
    public sealed virtual Direction get_Direction();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.GuardedEnumerable`1 : object {
    private IEnumerable`1<T> enumerable;
    public GuardedEnumerable`1(IEnumerable`1<T> enumerable);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.GuardedEnumerator`1 : object {
    private IEnumerator`1<T> enumerator;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public GuardedEnumerator`1(IEnumerator`1<T> enumerator);
    public sealed virtual bool MoveNext();
    public sealed virtual T get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.GuardedIndexedSorted`1 : GuardedSorted`1<T> {
    private IIndexedSorted`1<T> indexedsorted;
    public T Item { get; }
    public Speed IndexingSpeed { get; }
    public IDirectedCollectionValue`1<T> Item { get; }
    public GuardedIndexedSorted`1(IIndexedSorted`1<T> list);
    public sealed virtual IDirectedCollectionValue`1<T> RangeFrom(T bot);
    public sealed virtual IDirectedCollectionValue`1<T> RangeFromTo(T bot, T top);
    public sealed virtual IDirectedCollectionValue`1<T> RangeTo(T top);
    public sealed virtual int CountFrom(T bot);
    public sealed virtual int CountFromTo(T bot, T top);
    public sealed virtual int CountTo(T top);
    public sealed virtual IIndexedSorted`1<T> FindAll(Func`2<T, bool> f);
    public sealed virtual IIndexedSorted`1<V> Map(Func`2<T, V> m, IComparer`1<V> c);
    public sealed virtual T get_Item(int i);
    public virtual Speed get_IndexingSpeed();
    public sealed virtual IDirectedCollectionValue`1<T> get_Item(int start, int end);
    public sealed virtual int IndexOf(T item);
    public sealed virtual int LastIndexOf(T item);
    public sealed virtual T RemoveAt(int i);
    public sealed virtual void RemoveInterval(int start, int count);
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.GuardedList`1 : GuardedSequenced`1<T> {
    private IList`1<T> innerlist;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private GuardedList`1<T> underlying;
    private bool slidableView;
    public T First { get; }
    public T Last { get; }
    public bool FIFO { get; public set; }
    public bool IsFixedSize { get; }
    public T Item { get; public set; }
    public Speed IndexingSpeed { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<T> Underlying { get; }
    public int Offset { get; }
    public bool IsValid { get; }
    public IDirectedCollectionValue`1<T> Item { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    [ObsoleteAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public GuardedList`1(IList`1<T> list);
    private GuardedList`1(IList`1<T> list, GuardedList`1<T> underlying, bool slidableView);
    public sealed virtual T get_First();
    public sealed virtual T get_Last();
    public sealed virtual bool get_FIFO();
    public sealed virtual void set_FIFO(bool value);
    public virtual bool get_IsFixedSize();
    public sealed virtual T get_Item(int i);
    public sealed virtual void set_Item(int i, T value);
    public virtual Speed get_IndexingSpeed();
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void Insert(IList`1<T> pointer, T item);
    public sealed virtual void InsertFirst(T item);
    public sealed virtual void InsertLast(T item);
    public void InsertBefore(T item, T target);
    public void InsertAfter(T item, T target);
    public sealed virtual void InsertAll(int i, IEnumerable`1<T> items);
    public sealed virtual IList`1<T> FindAll(Func`2<T, bool> filter);
    public sealed virtual IList`1<V> Map(Func`2<T, V> mapper);
    public sealed virtual IList`1<V> Map(Func`2<T, V> mapper, IEqualityComparer`1<V> itemequalityComparer);
    public sealed virtual T Remove();
    public sealed virtual T RemoveFirst();
    public sealed virtual T RemoveLast();
    public sealed virtual IList`1<T> View(int start, int count);
    public sealed virtual IList`1<T> ViewOf(T item);
    public sealed virtual IList`1<T> LastViewOf(T item);
    public sealed virtual IList`1<T> get_Underlying();
    public sealed virtual int get_Offset();
    public virtual bool get_IsValid();
    public sealed virtual IList`1<T> Slide(int offset);
    public sealed virtual IList`1<T> Slide(int offset, int size);
    public sealed virtual bool TrySlide(int offset);
    public sealed virtual bool TrySlide(int offset, int size);
    public sealed virtual IList`1<T> Span(IList`1<T> otherView);
    public sealed virtual void Reverse();
    public void Reverse(int start, int count);
    public sealed virtual bool IsSorted();
    public sealed virtual bool IsSorted(IComparer`1<T> c);
    public sealed virtual void Sort();
    public sealed virtual void Sort(IComparer`1<T> c);
    public sealed virtual void Shuffle();
    public sealed virtual void Shuffle(Random rnd);
    public sealed virtual IDirectedCollectionValue`1<T> get_Item(int start, int end);
    public sealed virtual int IndexOf(T item);
    public sealed virtual int LastIndexOf(T item);
    public sealed virtual T RemoveAt(int i);
    public sealed virtual void RemoveInterval(int start, int count);
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public void Push(T item);
    public T Pop();
    public void Enqueue(T item);
    public T Dequeue();
    public sealed virtual void Dispose();
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array arr, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object o);
    private sealed virtual override bool System.Collections.IList.Contains(object o);
    private sealed virtual override int System.Collections.IList.IndexOf(object o);
    private sealed virtual override void System.Collections.IList.Insert(int index, object o);
    private sealed virtual override void System.Collections.IList.Remove(object o);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.GuardedQueue`1 : GuardedDirectedCollectionValue`1<T> {
    private IQueue`1<T> queue;
    public bool AllowsDuplicates { get; }
    public T Item { get; }
    public GuardedQueue`1(IQueue`1<T> queue);
    public sealed virtual bool get_AllowsDuplicates();
    public sealed virtual T get_Item(int i);
    public sealed virtual void Enqueue(T item);
    public sealed virtual T Dequeue();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.GuardedSequenced`1 : GuardedCollection`1<T> {
    private ISequenced`1<T> sequenced;
    public Direction Direction { get; }
    public GuardedSequenced`1(ISequenced`1<T> sorted);
    public sealed virtual int FindIndex(Func`2<T, bool> predicate);
    public sealed virtual int FindLastIndex(Func`2<T, bool> predicate);
    public sealed virtual int GetSequencedHashCode();
    public sealed virtual bool SequencedEquals(ISequenced`1<T> that);
    public virtual IDirectedCollectionValue`1<T> Backwards();
    public virtual bool FindLast(Func`2<T, bool> predicate, T& item);
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public sealed virtual Direction get_Direction();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.GuardedSorted`1 : GuardedSequenced`1<T> {
    private ISorted`1<T> sorted;
    public IComparer`1<T> Comparer { get; }
    public GuardedSorted`1(ISorted`1<T> sorted);
    public sealed virtual bool TryPredecessor(T item, T& res);
    public sealed virtual bool TrySuccessor(T item, T& res);
    public sealed virtual bool TryWeakPredecessor(T item, T& res);
    public sealed virtual bool TryWeakSuccessor(T item, T& res);
    public sealed virtual T Predecessor(T item);
    public sealed virtual T Successor(T item);
    public sealed virtual T WeakPredecessor(T item);
    public sealed virtual T WeakSuccessor(T item);
    public sealed virtual bool Cut(IComparable`1<T> c, T& low, Boolean& lval, T& high, Boolean& hval);
    public sealed virtual IDirectedEnumerable`1<T> RangeFrom(T bot);
    public sealed virtual IDirectedEnumerable`1<T> RangeFromTo(T bot, T top);
    public sealed virtual IDirectedEnumerable`1<T> RangeTo(T top);
    public sealed virtual IDirectedCollectionValue`1<T> RangeAll();
    public sealed virtual void AddSorted(IEnumerable`1<T> items);
    public sealed virtual void RemoveRangeFrom(T low);
    public sealed virtual void RemoveRangeFromTo(T low, T hi);
    public sealed virtual void RemoveRangeTo(T hi);
    public sealed virtual T FindMin();
    public sealed virtual T DeleteMin();
    public sealed virtual T FindMax();
    public sealed virtual T DeleteMax();
    public sealed virtual IComparer`1<T> get_Comparer();
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.GuardedSortedDictionary`2 : GuardedDictionary`2<K, V> {
    private ISortedDictionary`2<K, V> sorteddict;
    public IComparer`1<K> Comparer { get; }
    public ISorted`1<K> Keys { get; }
    public GuardedSortedDictionary`2(ISortedDictionary`2<K, V> sorteddict);
    public sealed virtual IComparer`1<K> get_Comparer();
    public sealed virtual ISorted`1<K> get_Keys();
    public sealed virtual bool TryPredecessor(K key, KeyValuePair`2& res);
    public sealed virtual bool TrySuccessor(K key, KeyValuePair`2& res);
    public sealed virtual bool TryWeakPredecessor(K key, KeyValuePair`2& res);
    public sealed virtual bool TryWeakSuccessor(K key, KeyValuePair`2& res);
    public sealed virtual KeyValuePair`2<K, V> Predecessor(K key);
    public sealed virtual KeyValuePair`2<K, V> Successor(K key);
    public sealed virtual KeyValuePair`2<K, V> WeakPredecessor(K key);
    public sealed virtual KeyValuePair`2<K, V> WeakSuccessor(K key);
    public sealed virtual KeyValuePair`2<K, V> FindMin();
    public sealed virtual KeyValuePair`2<K, V> DeleteMin();
    public sealed virtual KeyValuePair`2<K, V> FindMax();
    public sealed virtual KeyValuePair`2<K, V> DeleteMax();
    public sealed virtual bool Cut(IComparable`1<K> c, KeyValuePair`2& lowEntry, Boolean& lowIsValid, KeyValuePair`2& highEntry, Boolean& highIsValid);
    public sealed virtual IDirectedEnumerable`1<KeyValuePair`2<K, V>> RangeFrom(K bot);
    public sealed virtual IDirectedEnumerable`1<KeyValuePair`2<K, V>> RangeFromTo(K bot, K top);
    public sealed virtual IDirectedEnumerable`1<KeyValuePair`2<K, V>> RangeTo(K top);
    public sealed virtual IDirectedCollectionValue`1<KeyValuePair`2<K, V>> RangeAll();
    public sealed virtual void AddSorted(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public sealed virtual void RemoveRangeFrom(K low);
    public sealed virtual void RemoveRangeFromTo(K low, K hi);
    public sealed virtual void RemoveRangeTo(K hi);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.HashBag`1 : CollectionBase`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<KeyValuePair`2<T, int>> dict;
    public EventType ListenableEvents { get; }
    public Speed ContainsSpeed { get; }
    public bool AllowsDuplicates { get; }
    public bool DuplicatesByCounting { get; }
    public HashBag`1(IEqualityComparer`1<T> itemequalityComparer);
    public HashBag`1(int capacity, IEqualityComparer`1<T> itemequalityComparer);
    public HashBag`1(int capacity, double fill, IEqualityComparer`1<T> itemequalityComparer);
    public virtual EventType get_ListenableEvents();
    public virtual Speed get_ContainsSpeed();
    public virtual bool Contains(T item);
    public virtual bool Find(T& item);
    public virtual bool Update(T item);
    public virtual bool Update(T item, T& olditem);
    public virtual bool FindOrAdd(T& item);
    public virtual bool UpdateOrAdd(T item);
    public virtual bool UpdateOrAdd(T item, T& olditem);
    public virtual bool Remove(T item);
    public virtual bool Remove(T item, T& removeditem);
    public virtual void RemoveAll(IEnumerable`1<T> items);
    public virtual void Clear();
    public virtual void RetainAll(IEnumerable`1<T> items);
    public virtual bool ContainsAll(IEnumerable`1<T> items);
    public virtual T[] ToArray();
    public virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public virtual void RemoveAllCopies(T item);
    public virtual void CopyTo(T[] array, int index);
    public virtual bool get_AllowsDuplicates();
    public virtual bool get_DuplicatesByCounting();
    public virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private void Add(T& item);
    public virtual void AddAll(IEnumerable`1<T> items);
    public virtual T Choose();
    [IteratorStateMachineAttribute("C5.HashBag`1/<GetEnumerator>d__37")]
public virtual IEnumerator`1<T> GetEnumerator();
    public virtual bool Check();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.HashDictionary`2 : DictionaryBase`2<K, V> {
    [NullableContextAttribute("1")]
public HashDictionary`2(IEqualityComparer`1<K> keyequalityComparer);
    [NullableContextAttribute("1")]
public HashDictionary`2(int capacity, double fill, IEqualityComparer`1<K> keyequalityComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.HashedArrayList`1 : ArrayBase`1<T> {
    private bool isValid;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashedArrayList`1<T> underlying;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakViewList`1<HashedArrayList`1<T>> views;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<HashedArrayList`1<T>> myWeakReference;
    private bool fIFO;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<KeyValuePair`2<T, int>> itemIndex;
    private int UnderlyingSize { get; }
    public EventType ListenableEvents { get; }
    public T First { get; }
    public T Last { get; }
    public bool FIFO { get; public set; }
    public bool IsFixedSize { get; }
    public T Item { get; public set; }
    public Speed IndexingSpeed { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<T> Underlying { get; }
    public int Offset { get; }
    public bool IsValid { get; }
    public Speed ContainsSpeed { get; }
    public bool AllowsDuplicates { get; }
    public bool DuplicatesByCounting { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    [ObsoleteAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public HashedArrayList`1(IEqualityComparer`1<T> itemequalityComparer);
    public HashedArrayList`1(int capacity);
    public HashedArrayList`1(int capacity, IEqualityComparer`1<T> itemequalityComparer);
    private int get_UnderlyingSize();
    public virtual EventType get_ListenableEvents();
    private bool Equals(T i1, T i2);
    private void AddToSize(int delta);
    protected virtual void Expand();
    protected virtual void Expand(int newcapacity, int newsize);
    protected virtual void UpdateCheck();
    private void ValidityCheck();
    protected virtual void ModifyCheck(int stamp);
    private int IndexOfInner(T item);
    private int LastIndexOfInner(T item);
    protected virtual void InsertProtected(int i, T item);
    private void InsertBase(int i, T item);
    private T RemoveAtInternal(int i);
    private void ReIndex(int start);
    private void ReIndex(int start, int end);
    private void FixViewsAfterInsert(int added, int realInsertionIndex);
    private void FixViewsBeforeSingleRemove(int realRemovalIndex);
    private void FixViewsBeforeRemove(int start, int count);
    private MutualViewPosition ViewPosition(int otherOffset, int otherSize);
    private void DisposeOverlappingViews(bool reverse);
    public virtual T get_First();
    public virtual T get_Last();
    public virtual bool get_FIFO();
    public virtual void set_FIFO(bool value);
    public virtual bool get_IsFixedSize();
    public virtual T get_Item(int index);
    public virtual void set_Item(int index, T value);
    public virtual Speed get_IndexingSpeed();
    public virtual void Insert(int index, T item);
    public sealed virtual void Insert(IList`1<T> pointer, T item);
    public virtual void InsertAll(int index, IEnumerable`1<T> items);
    private void RaiseForInsertAll(int index, int added);
    public virtual void InsertFirst(T item);
    public virtual void InsertLast(T item);
    public virtual IList`1<T> FindAll(Func`2<T, bool> filter);
    public virtual IList`1<V> Map(Func`2<T, V> mapper);
    public virtual IList`1<V> Map(Func`2<T, V> mapper, IEqualityComparer`1<V> itemequalityComparer);
    private IList`1<V> Map(Func`2<T, V> mapper, HashedArrayList`1<V> res);
    public virtual T Remove();
    public virtual T RemoveFirst();
    public virtual T RemoveLast();
    public virtual IList`1<T> View(int start, int count);
    public virtual IList`1<T> ViewOf(T item);
    public virtual IList`1<T> LastViewOf(T item);
    public virtual IList`1<T> get_Underlying();
    public virtual int get_Offset();
    public virtual bool get_IsValid();
    public virtual IList`1<T> Slide(int offset);
    public virtual IList`1<T> Slide(int offset, int size);
    public virtual bool TrySlide(int offset);
    public virtual bool TrySlide(int offset, int size);
    public virtual IList`1<T> Span(IList`1<T> otherView);
    public virtual void Reverse();
    public sealed virtual bool IsSorted();
    public virtual bool IsSorted(IComparer`1<T> c);
    public virtual void Sort();
    public virtual void Sort(IComparer`1<T> comparer);
    public virtual void Shuffle();
    public virtual void Shuffle(Random rnd);
    public virtual int IndexOf(T item);
    public virtual int LastIndexOf(T item);
    public virtual T RemoveAt(int index);
    public virtual void RemoveInterval(int start, int count);
    private void RaiseForRemoveInterval(int start, int count);
    public virtual Speed get_ContainsSpeed();
    public virtual int GetUnsequencedHashCode();
    public virtual bool UnsequencedEquals(ICollection`1<T> that);
    public virtual bool Contains(T item);
    public virtual bool Find(T& item);
    public virtual bool Update(T item);
    public virtual bool Update(T item, T& olditem);
    public virtual bool FindOrAdd(T& item);
    public virtual bool UpdateOrAdd(T item);
    public virtual bool UpdateOrAdd(T item, T& olditem);
    public virtual bool Remove(T item);
    public virtual bool Remove(T item, T& removeditem);
    public virtual void RemoveAll(IEnumerable`1<T> items);
    public virtual void Clear();
    public virtual void RetainAll(IEnumerable`1<T> items);
    public virtual bool ContainsAll(IEnumerable`1<T> items);
    public virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public virtual void RemoveAllCopies(T item);
    public virtual bool Check();
    public virtual bool get_AllowsDuplicates();
    public virtual bool get_DuplicatesByCounting();
    public virtual bool Add(T item);
    public virtual void AddAll(IEnumerable`1<T> items);
    private void RaiseForAddAll(int start, int added);
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public virtual int get_Count();
    public virtual IEnumerator`1<T> GetEnumerator();
    public virtual void Dispose();
    private void Dispose(bool disposingUnderlying);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array arr, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object o);
    private sealed virtual override bool System.Collections.IList.Contains(object o);
    private sealed virtual override int System.Collections.IList.IndexOf(object o);
    private sealed virtual override void System.Collections.IList.Insert(int index, object o);
    private sealed virtual override void System.Collections.IList.Remove(object o);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.HashedLinkedList`1 : SequencedBase`1<T> {
    private bool fIFO;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<T> startsentinel;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<T> endsentinel;
    private Nullable`1<int> offset;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashedLinkedList`1<T> underlying;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakViewList`1<HashedLinkedList`1<T>> views;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<HashedLinkedList`1<T>> myWeakReference;
    private bool isValid;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashDictionary`2<T, Node<T>> dict;
    private int taggroups;
    private static int wordsize;
    private static int lobits;
    private static int hibits;
    private static int losize;
    private static int hisize;
    public EventType ListenableEvents { get; }
    private int Taggroups { get; private set; }
    public T First { get; }
    public T Last { get; }
    public bool FIFO { get; public set; }
    public bool IsFixedSize { get; }
    public T Item { get; public set; }
    public Speed IndexingSpeed { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<T> Underlying { get; }
    public bool IsValid { get; }
    public int Offset { get; }
    public IDirectedCollectionValue`1<T> Item { get; }
    public Speed ContainsSpeed { get; }
    public int Count { get; }
    public bool AllowsDuplicates { get; }
    public bool DuplicatesByCounting { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    [ObsoleteAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public HashedLinkedList`1(IEqualityComparer`1<T> itemequalityComparer);
    public virtual EventType get_ListenableEvents();
    private int get_Taggroups();
    private void set_Taggroups(int value);
    protected virtual void UpdateCheck();
    private void Validitycheck();
    protected virtual void ModifyCheck(int stamp);
    private bool Contains(T item, Node& node);
    private bool Find(T item, Node& node, Int32& index);
    private bool InsideView(Node<T> node);
    private Node<T> Get(int pos);
    private int Dist(int pos, Int32& nearest, Int32[] positions);
    private Node<T> Get(int pos, Int32[] positions, Node[] nodes);
    private void GetPair(int p1, int p2, Node& n1, Node& n2, Int32[] positions, Node[] nodes);
    private void Insert(Node<T> succ, T item);
    private void InsertNode(bool updateViews, Node<T> succ, Node<T> newnode);
    private T Remove(Node<T> node);
    private bool DictRemove(T item, Node& node);
    private void FixViewsAfterInsert(Node<T> succ, Node<T> pred, int added);
    private void FixViewsBeforeSingleRemove(Node<T> node);
    private MutualViewPosition ViewPosition(HashedLinkedList`1<T> otherView);
    private void DisposeOverlappingViews(bool reverse);
    private TagGroup<T> GetTagGroup(Node<T> pred, Node<T> succ, Int32& lowbound, Int32& highbound);
    private void SetTag(Node<T> node);
    private void RemoveFromTagGroup(Node<T> node);
    private void SplitTagGroup(TagGroup<T> taggroup);
    private void RedistributeTagGroups(TagGroup<T> taggroup);
    public virtual void Dispose();
    private void Dispose(bool disposingUnderlying);
    public virtual T get_First();
    public virtual T get_Last();
    public virtual bool get_FIFO();
    public virtual void set_FIFO(bool value);
    public virtual bool get_IsFixedSize();
    public virtual T get_Item(int index);
    public virtual void set_Item(int index, T value);
    public virtual Speed get_IndexingSpeed();
    public virtual void Insert(int i, T item);
    public sealed virtual void Insert(IList`1<T> pointer, T item);
    public virtual void InsertAll(int i, IEnumerable`1<T> items);
    private void InsertAll(int i, IEnumerable`1<T> items, bool insertion);
    private void RaiseForInsertAll(Node<T> node, int i, int added, bool insertion);
    public virtual void InsertFirst(T item);
    public virtual void InsertLast(T item);
    public sealed virtual IList`1<V> Map(Func`2<T, V> mapper);
    public sealed virtual IList`1<V> Map(Func`2<T, V> mapper, IEqualityComparer`1<V> equalityComparer);
    private IList`1<V> Map(Func`2<T, V> mapper, HashedLinkedList`1<V> retval);
    public virtual T Remove();
    public virtual T RemoveFirst();
    public virtual T RemoveLast();
    public virtual IList`1<T> View(int start, int count);
    public virtual IList`1<T> ViewOf(T item);
    public virtual IList`1<T> LastViewOf(T item);
    public virtual IList`1<T> get_Underlying();
    public virtual bool get_IsValid();
    public virtual int get_Offset();
    public sealed virtual IList`1<T> Slide(int offset);
    public sealed virtual IList`1<T> Slide(int offset, int size);
    public virtual bool TrySlide(int offset);
    public virtual bool TrySlide(int offset, int size);
    public virtual IList`1<T> Span(IList`1<T> otherView);
    public virtual void Reverse();
    private void MirrorViewSentinelsForReverse(Position[] positions, Int32& poslow, Int32& poshigh, Node<T> a, Node<T> b, int i);
    public sealed virtual bool IsSorted();
    public virtual bool IsSorted(IComparer`1<T> c);
    public virtual void Sort();
    public virtual void Sort(IComparer`1<T> c);
    private static Node<T> MergeRuns(Node<T> run1, Node<T> run2, IComparer`1<T> c);
    public virtual void Shuffle();
    public virtual void Shuffle(Random rnd);
    public sealed virtual IDirectedCollectionValue`1<T> get_Item(int start, int count);
    public virtual int IndexOf(T item);
    public virtual int LastIndexOf(T item);
    public virtual T RemoveAt(int i);
    public virtual void RemoveInterval(int start, int count);
    private void RaiseForRemoveInterval(int start, int count);
    public virtual int GetSequencedHashCode();
    public virtual bool SequencedEquals(ISequenced`1<T> that);
    public virtual IDirectedCollectionValue`1<T> Backwards();
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public virtual Speed get_ContainsSpeed();
    public virtual int GetUnsequencedHashCode();
    public virtual bool UnsequencedEquals(ICollection`1<T> that);
    public virtual bool Contains(T item);
    public virtual bool Find(T& item);
    public virtual bool Update(T item);
    public virtual bool Update(T item, T& olditem);
    public virtual bool FindOrAdd(T& item);
    public virtual bool UpdateOrAdd(T item);
    public virtual bool UpdateOrAdd(T item, T& olditem);
    public virtual bool Remove(T item);
    public virtual bool Remove(T item, T& removeditem);
    public virtual void RemoveAll(IEnumerable`1<T> items);
    public virtual void Clear();
    private void ClearInnner();
    public virtual void RetainAll(IEnumerable`1<T> items);
    public virtual bool ContainsAll(IEnumerable`1<T> items);
    public sealed virtual IList`1<T> FindAll(Func`2<T, bool> filter);
    public virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public virtual void RemoveAllCopies(T item);
    public virtual int get_Count();
    public virtual T Choose();
    public virtual IEnumerable`1<T> Filter(Func`2<T, bool> filter);
    [IteratorStateMachineAttribute("C5.HashedLinkedList`1/<GetEnumerator>d__141")]
public virtual IEnumerator`1<T> GetEnumerator();
    public virtual bool Add(T item);
    public virtual bool get_AllowsDuplicates();
    public virtual bool get_DuplicatesByCounting();
    public virtual void AddAll(IEnumerable`1<T> items);
    private bool CheckViews();
    private string TheItem(Node<T> node);
    public virtual bool Check();
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array arr, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object o);
    private sealed virtual override bool System.Collections.IList.Contains(object o);
    private sealed virtual override int System.Collections.IList.IndexOf(object o);
    private sealed virtual override void System.Collections.IList.Insert(int index, object o);
    private sealed virtual override void System.Collections.IList.Remove(object o);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.HashSet`1 : CollectionBase`1<T> {
    [NullableAttribute("0")]
private static Feature<T> features;
    private int indexmask;
    private int bits;
    private int bitsc;
    private int origbits;
    private int lastchosen;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Bucket[] table;
    private double fillfactor;
    private int resizethreshhold;
    private static Random Random;
    private UInt32 _randomhashfactor;
    [NullableAttribute("0")]
public static Feature<T> Features { get; }
    public EventType ListenableEvents { get; }
    public Speed ContainsSpeed { get; }
    public bool AllowsDuplicates { get; }
    public bool DuplicatesByCounting { get; }
    public HashSet`1(IEqualityComparer`1<T> itemequalityComparer);
    public HashSet`1(int capacity, IEqualityComparer`1<T> itemequalityComparer);
    public HashSet`1(int capacity, double fill, IEqualityComparer`1<T> itemequalityComparer);
    private static HashSet`1();
    [NullableContextAttribute("0")]
public static Feature<T> get_Features();
    public virtual EventType get_ListenableEvents();
    private bool Equals(T i1, T i2);
    private int GetHashCode(T item);
    private int Hv2i(int hashval);
    private void Expand();
    private void Resize(int bits);
    private bool SearchOrAdd(T& item, bool add, bool update, bool raise);
    private bool Remove(T& item);
    private void ClearInner();
    public virtual Speed get_ContainsSpeed();
    public virtual bool Contains(T item);
    public virtual bool Find(T& item);
    public virtual bool Update(T item);
    public virtual bool Update(T item, T& olditem);
    public virtual bool FindOrAdd(T& item);
    public virtual bool UpdateOrAdd(T item);
    public virtual bool UpdateOrAdd(T item, T& olditem);
    public virtual bool Remove(T item);
    public virtual bool Remove(T item, T& removeditem);
    public virtual void RemoveAll(IEnumerable`1<T> items);
    public virtual void Clear();
    public virtual void RetainAll(IEnumerable`1<T> items);
    public virtual bool ContainsAll(IEnumerable`1<T> items);
    public virtual T[] ToArray();
    public virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public virtual void RemoveAllCopies(T item);
    public virtual T Choose();
    [IteratorStateMachineAttribute("C5.HashSet`1/<GetEnumerator>d__50")]
public virtual IEnumerator`1<T> GetEnumerator();
    public virtual bool get_AllowsDuplicates();
    public virtual bool get_DuplicatesByCounting();
    public virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public virtual void AddAll(IEnumerable`1<T> items);
    public virtual bool Check();
    public ISortedDictionary`2<int, int> BucketCostDistribution();
}
[NullableContextAttribute("1")]
public interface C5.ICollection`1 {
    public Speed ContainsSpeed { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual Speed get_ContainsSpeed();
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool Add(T item);
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual int GetUnsequencedHashCode();
    public abstract virtual bool UnsequencedEquals(ICollection`1<T> otherCollection);
    public abstract virtual bool Contains(T item);
    public abstract virtual int ContainsCount(T item);
    public abstract virtual ICollectionValue`1<T> UniqueItems();
    public abstract virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public abstract virtual bool ContainsAll(IEnumerable`1<T> items);
    public abstract virtual bool Find(T& item);
    public abstract virtual bool FindOrAdd(T& item);
    public abstract virtual bool Update(T item);
    public abstract virtual bool Update(T item, T& olditem);
    public abstract virtual bool UpdateOrAdd(T item);
    public abstract virtual bool UpdateOrAdd(T item, T& olditem);
    public abstract virtual bool Remove(T item);
    public abstract virtual bool Remove(T item, T& removeditem);
    public abstract virtual void RemoveAllCopies(T item);
    public abstract virtual void RemoveAll(IEnumerable`1<T> items);
    public abstract virtual void Clear();
    public abstract virtual void RetainAll(IEnumerable`1<T> items);
}
[NullableContextAttribute("1")]
public interface C5.ICollectionValue`1 {
    public EventType ListenableEvents { get; }
    public EventType ActiveEvents { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public Speed CountSpeed { get; }
    public abstract virtual EventType get_ListenableEvents();
    public abstract virtual EventType get_ActiveEvents();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionChanged(CollectionChangedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionChanged(CollectionChangedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionCleared(CollectionClearedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionCleared(CollectionClearedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemsAdded(ItemsAddedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemsAdded(ItemsAddedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemInserted(ItemInsertedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemInserted(ItemInsertedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual Speed get_CountSpeed();
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual T[] ToArray();
    public abstract virtual void Apply(Action`1<T> action);
    public abstract virtual bool Exists(Func`2<T, bool> predicate);
    public abstract virtual bool Find(Func`2<T, bool> predicate, T& item);
    public abstract virtual bool All(Func`2<T, bool> predicate);
    public abstract virtual T Choose();
    public abstract virtual IEnumerable`1<T> Filter(Func`2<T, bool> filter);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface C5.IDictionary`2 {
    public IEqualityComparer`1<K> EqualityComparer { get; }
    public V Item { get; public set; }
    public bool IsReadOnly { get; }
    public ICollectionValue`1<K> Keys { get; }
    public ICollectionValue`1<V> Values { get; }
    public Func`2<K, V> Func { get; }
    public Speed ContainsSpeed { get; }
    public abstract virtual IEqualityComparer`1<K> get_EqualityComparer();
    public abstract virtual V get_Item(K key);
    public abstract virtual void set_Item(K key, V value);
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual ICollectionValue`1<K> get_Keys();
    public abstract virtual ICollectionValue`1<V> get_Values();
    public abstract virtual Func`2<K, V> get_Func();
    public abstract virtual void Add(K key, V val);
    [NullableContextAttribute("0")]
public abstract virtual void AddAll(IEnumerable`1<KeyValuePair`2<U, W>> entries);
    public abstract virtual Speed get_ContainsSpeed();
    public abstract virtual bool ContainsAll(IEnumerable`1<H> items);
    public abstract virtual bool Remove(K key);
    public abstract virtual bool Remove(K key, V& val);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(K key);
    public abstract virtual bool Find(K& key, V& val);
    public abstract virtual bool Update(K key, V val);
    public abstract virtual bool Update(K key, V val, V& oldval);
    public abstract virtual bool FindOrAdd(K key, V& val);
    public abstract virtual bool UpdateOrAdd(K key, V val);
    public abstract virtual bool UpdateOrAdd(K key, V val, V& oldval);
    public abstract virtual bool Check();
}
public interface C5.IDirectedCollectionValue`1 {
    [NullableContextAttribute("1")]
public abstract virtual IDirectedCollectionValue`1<T> Backwards();
    [NullableContextAttribute("1")]
public abstract virtual bool FindLast(Func`2<T, bool> predicate, T& item);
}
public interface C5.IDirectedEnumerable`1 {
    public Direction Direction { get; }
    [NullableContextAttribute("1")]
public abstract virtual IDirectedEnumerable`1<T> Backwards();
    public abstract virtual Direction get_Direction();
}
[NullableContextAttribute("1")]
public interface C5.IExtensible`1 {
    public bool IsReadOnly { get; }
    public bool AllowsDuplicates { get; }
    public IEqualityComparer`1<T> EqualityComparer { get; }
    public bool DuplicatesByCounting { get; }
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_AllowsDuplicates();
    public abstract virtual IEqualityComparer`1<T> get_EqualityComparer();
    public abstract virtual bool get_DuplicatesByCounting();
    public abstract virtual bool Add(T item);
    public abstract virtual void AddAll(IEnumerable`1<T> items);
    public abstract virtual bool Check();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface C5.IIndexed`1 {
    public int Count { get; }
    public Speed IndexingSpeed { get; }
    public IDirectedCollectionValue`1<T> Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual Speed get_IndexingSpeed();
    public abstract virtual IDirectedCollectionValue`1<T> get_Item(int start, int count);
    public abstract virtual int IndexOf(T item);
    public abstract virtual int LastIndexOf(T item);
    public abstract virtual int FindIndex(Func`2<T, bool> predicate);
    public abstract virtual int FindLastIndex(Func`2<T, bool> predicate);
    public abstract virtual T RemoveAt(int index);
    public abstract virtual void RemoveInterval(int start, int count);
}
[NullableContextAttribute("1")]
public interface C5.IIndexedSorted`1 {
    public abstract virtual int CountFrom(T bot);
    public abstract virtual int CountFromTo(T bot, T top);
    public abstract virtual int CountTo(T top);
    public abstract virtual IDirectedCollectionValue`1<T> RangeFrom(T bot);
    public abstract virtual IDirectedCollectionValue`1<T> RangeFromTo(T bot, T top);
    public abstract virtual IDirectedCollectionValue`1<T> RangeTo(T top);
    public abstract virtual IIndexedSorted`1<T> FindAll(Func`2<T, bool> predicate);
    public abstract virtual IIndexedSorted`1<V> Map(Func`2<T, V> mapper, IComparer`1<V> comparer);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface C5.IList`1 {
    public T First { get; }
    public T Last { get; }
    public bool FIFO { get; public set; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<T> Underlying { get; }
    public int Offset { get; }
    public bool IsValid { get; }
    public abstract virtual T get_First();
    public abstract virtual T get_Last();
    public abstract virtual bool get_FIFO();
    public abstract virtual void set_FIFO(bool value);
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual bool Remove(T item);
    public abstract virtual int IndexOf(T item);
    public abstract virtual T RemoveAt(int index);
    public abstract virtual void Insert(IList`1<T> pointer, T item);
    public abstract virtual void InsertFirst(T item);
    public abstract virtual void InsertLast(T item);
    public abstract virtual void InsertAll(int index, IEnumerable`1<T> items);
    public abstract virtual IList`1<T> FindAll(Func`2<T, bool> filter);
    public abstract virtual IList`1<V> Map(Func`2<T, V> mapper);
    public abstract virtual IList`1<V> Map(Func`2<T, V> mapper, IEqualityComparer`1<V> equalityComparer);
    public abstract virtual T Remove();
    public abstract virtual T RemoveFirst();
    public abstract virtual T RemoveLast();
    public abstract virtual IList`1<T> View(int start, int count);
    public abstract virtual IList`1<T> ViewOf(T item);
    public abstract virtual IList`1<T> LastViewOf(T item);
    public abstract virtual IList`1<T> get_Underlying();
    public abstract virtual int get_Offset();
    public abstract virtual bool get_IsValid();
    public abstract virtual IList`1<T> Slide(int offset);
    public abstract virtual IList`1<T> Slide(int offset, int size);
    public abstract virtual bool TrySlide(int offset);
    public abstract virtual bool TrySlide(int offset, int size);
    public abstract virtual IList`1<T> Span(IList`1<T> otherView);
    public abstract virtual void Reverse();
    public abstract virtual bool IsSorted();
    public abstract virtual bool IsSorted(IComparer`1<T> comparer);
    public abstract virtual void Sort();
    public abstract virtual void Sort(IComparer`1<T> comparer);
    public abstract virtual void Shuffle();
    public abstract virtual void Shuffle(Random rnd);
}
public class C5.IncompatibleViewException : Exception {
    [NullableContextAttribute("1")]
public IncompatibleViewException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class C5.InternalComparer`1 : object {
    private Func`3<T, T, int> _compare;
    public InternalComparer`1(Func`3<T, T, int> compare);
    public sealed virtual int Compare(T x, T y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class C5.InternalEqualityComparer`1 : object {
    private Func`3<T, T, bool> _equals;
    private Func`2<T, int> _getHashCode;
    public InternalEqualityComparer`1(Func`3<T, T, bool> equals, Func`2<T, int> getHashCode);
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
public class C5.InternalException : Exception {
    [NullableContextAttribute("1")]
internal InternalException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.IntervalHeap`1 : CollectionValueBase`1<T> {
    private int stamp;
    private IComparer`1<T> comparer;
    private IEqualityComparer`1<T> itemequalityComparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Interval[] heap;
    private int size;
    public EventType ListenableEvents { get; }
    public IComparer`1<T> Comparer { get; }
    public bool IsReadOnly { get; }
    public bool AllowsDuplicates { get; }
    public IEqualityComparer`1<T> EqualityComparer { get; }
    public bool DuplicatesByCounting { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public Speed CountSpeed { get; }
    public T Item { get; public set; }
    public IntervalHeap`1(IComparer`1<T> comparer);
    public IntervalHeap`1(int capacity);
    public IntervalHeap`1(int capacity, IComparer`1<T> comparer);
    private IntervalHeap`1(int capacity, IComparer`1<T> comparer, IEqualityComparer`1<T> itemequalityComparer);
    public virtual EventType get_ListenableEvents();
    private void SwapFirstWithLast(int cell1, int cell2);
    private void SwapLastWithLast(int cell1, int cell2);
    private void SwapFirstWithFirst(int cell1, int cell2);
    private bool HeapifyMin(int cell);
    private bool HeapifyMax(int cell);
    private void BubbleUpMin(int i);
    private void BubbleUpMax(int i);
    public sealed virtual T FindMin();
    public sealed virtual T DeleteMin();
    public sealed virtual T FindMax();
    public sealed virtual T DeleteMax();
    public sealed virtual IComparer`1<T> get_Comparer();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_AllowsDuplicates();
    public virtual IEqualityComparer`1<T> get_EqualityComparer();
    public virtual bool get_DuplicatesByCounting();
    public sealed virtual bool Add(T item);
    private bool Add(Handle<T> itemhandle, T item);
    private void UpdateLast(int cell, T item, Handle<T> handle);
    private void UpdateFirst(int cell, T item, Handle<T> handle);
    public sealed virtual void AddAll(IEnumerable`1<T> items);
    public virtual bool get_IsEmpty();
    public virtual int get_Count();
    public virtual Speed get_CountSpeed();
    public virtual T Choose();
    [IteratorStateMachineAttribute("C5.IntervalHeap`1/<GetEnumerator>d__46")]
public virtual IEnumerator`1<T> GetEnumerator();
    private bool Check(int i, T min, T max);
    public sealed virtual bool Check();
    public sealed virtual T get_Item(IPriorityQueueHandle`1<T> handle);
    public sealed virtual void set_Item(IPriorityQueueHandle`1<T> handle, T value);
    public sealed virtual bool Find(IPriorityQueueHandle`1<T> handle, T& item);
    public sealed virtual bool Add(IPriorityQueueHandle`1& handle, T item);
    public sealed virtual T Delete(IPriorityQueueHandle`1<T> handle);
    private Handle<T> CheckHandle(IPriorityQueueHandle`1<T> handle, Int32& cell, Boolean& isfirst);
    public sealed virtual T Replace(IPriorityQueueHandle`1<T> handle, T item);
    public sealed virtual T FindMin(IPriorityQueueHandle`1& handle);
    public sealed virtual T FindMax(IPriorityQueueHandle`1& handle);
    public sealed virtual T DeleteMin(IPriorityQueueHandle`1& handle);
    public sealed virtual T DeleteMax(IPriorityQueueHandle`1& handle);
}
public class C5.InvalidPriorityQueueHandleException : Exception {
    [NullableContextAttribute("1")]
public InvalidPriorityQueueHandleException(string message);
}
public interface C5.IPersistentSorted`1 {
    [NullableContextAttribute("1")]
public abstract virtual ISorted`1<T> Snapshot();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface C5.IPriorityQueue`1 {
    public IComparer`1<T> Comparer { get; }
    public T Item { get; public set; }
    public abstract virtual T FindMin();
    public abstract virtual T DeleteMin();
    public abstract virtual T FindMax();
    public abstract virtual T DeleteMax();
    public abstract virtual IComparer`1<T> get_Comparer();
    public abstract virtual T get_Item(IPriorityQueueHandle`1<T> handle);
    public abstract virtual void set_Item(IPriorityQueueHandle`1<T> handle, T value);
    public abstract virtual bool Find(IPriorityQueueHandle`1<T> handle, T& item);
    public abstract virtual bool Add(IPriorityQueueHandle`1& handle, T item);
    public abstract virtual T Delete(IPriorityQueueHandle`1<T> handle);
    public abstract virtual T Replace(IPriorityQueueHandle`1<T> handle, T item);
    public abstract virtual T FindMin(IPriorityQueueHandle`1& handle);
    public abstract virtual T FindMax(IPriorityQueueHandle`1& handle);
    public abstract virtual T DeleteMin(IPriorityQueueHandle`1& handle);
    public abstract virtual T DeleteMax(IPriorityQueueHandle`1& handle);
}
[NullableContextAttribute("2")]
public interface C5.IPriorityQueueHandle`1 {
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface C5.IQueue`1 {
    public bool AllowsDuplicates { get; }
    public T Item { get; }
    public abstract virtual bool get_AllowsDuplicates();
    public abstract virtual T get_Item(int index);
    public abstract virtual void Enqueue(T item);
    public abstract virtual T Dequeue();
}
public interface C5.ISequenced`1 {
    public abstract virtual int GetSequencedHashCode();
    [NullableContextAttribute("1")]
public abstract virtual bool SequencedEquals(ISequenced`1<T> otherCollection);
}
public interface C5.IShowable {
    [NullableContextAttribute("1")]
public abstract virtual bool Show(StringBuilder stringbuilder, Int32& rest, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
public interface C5.ISorted`1 {
    public IComparer`1<T> Comparer { get; }
    public abstract virtual T FindMin();
    public abstract virtual T DeleteMin();
    public abstract virtual T FindMax();
    public abstract virtual T DeleteMax();
    public abstract virtual IComparer`1<T> get_Comparer();
    public abstract virtual bool TryPredecessor(T item, T& res);
    public abstract virtual bool TrySuccessor(T item, T& res);
    public abstract virtual bool TryWeakPredecessor(T item, T& res);
    public abstract virtual bool TryWeakSuccessor(T item, T& res);
    public abstract virtual T Predecessor(T item);
    public abstract virtual T Successor(T item);
    public abstract virtual T WeakPredecessor(T item);
    public abstract virtual T WeakSuccessor(T item);
    public abstract virtual bool Cut(IComparable`1<T> cutFunction, T& low, Boolean& lowIsValid, T& high, Boolean& highIsValid);
    public abstract virtual IDirectedEnumerable`1<T> RangeFrom(T bot);
    public abstract virtual IDirectedEnumerable`1<T> RangeFromTo(T bot, T top);
    public abstract virtual IDirectedEnumerable`1<T> RangeTo(T top);
    public abstract virtual IDirectedCollectionValue`1<T> RangeAll();
    public abstract virtual void AddSorted(IEnumerable`1<T> items);
    public abstract virtual void RemoveRangeFrom(T low);
    public abstract virtual void RemoveRangeFromTo(T low, T hi);
    public abstract virtual void RemoveRangeTo(T hi);
}
[NullableContextAttribute("1")]
public interface C5.ISortedDictionary`2 {
    public ISorted`1<K> Keys { get; }
    public IComparer`1<K> Comparer { get; }
    public abstract virtual ISorted`1<K> get_Keys();
    public abstract virtual KeyValuePair`2<K, V> FindMin();
    public abstract virtual KeyValuePair`2<K, V> DeleteMin();
    public abstract virtual KeyValuePair`2<K, V> FindMax();
    public abstract virtual KeyValuePair`2<K, V> DeleteMax();
    public abstract virtual IComparer`1<K> get_Comparer();
    public abstract virtual bool TryPredecessor(K key, KeyValuePair`2& res);
    public abstract virtual bool TrySuccessor(K key, KeyValuePair`2& res);
    public abstract virtual bool TryWeakPredecessor(K key, KeyValuePair`2& res);
    public abstract virtual bool TryWeakSuccessor(K key, KeyValuePair`2& res);
    public abstract virtual KeyValuePair`2<K, V> Predecessor(K key);
    public abstract virtual KeyValuePair`2<K, V> Successor(K key);
    public abstract virtual KeyValuePair`2<K, V> WeakPredecessor(K key);
    public abstract virtual KeyValuePair`2<K, V> WeakSuccessor(K key);
    public abstract virtual bool Cut(IComparable`1<K> cutFunction, KeyValuePair`2& lowEntry, Boolean& lowIsValid, KeyValuePair`2& highEntry, Boolean& highIsValid);
    public abstract virtual IDirectedEnumerable`1<KeyValuePair`2<K, V>> RangeFrom(K bot);
    public abstract virtual IDirectedEnumerable`1<KeyValuePair`2<K, V>> RangeFromTo(K lowerBound, K upperBound);
    public abstract virtual IDirectedEnumerable`1<KeyValuePair`2<K, V>> RangeTo(K top);
    public abstract virtual IDirectedCollectionValue`1<KeyValuePair`2<K, V>> RangeAll();
    public abstract virtual void AddSorted(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public abstract virtual void RemoveRangeFrom(K low);
    public abstract virtual void RemoveRangeFromTo(K low, K hi);
    public abstract virtual void RemoveRangeTo(K hi);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface C5.IStack`1 {
    public bool AllowsDuplicates { get; }
    public T Item { get; }
    public abstract virtual bool get_AllowsDuplicates();
    public abstract virtual T get_Item(int index);
    public abstract virtual void Push(T item);
    public abstract virtual T Pop();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.ItemAtEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public T Item { get; }
    public int Index { get; }
    public ItemAtEventArgs`1(T item, int index);
    [CompilerGeneratedAttribute]
public T get_Item();
    [CompilerGeneratedAttribute]
public int get_Index();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.ItemCountEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public T Item { get; }
    public int Count { get; }
    public ItemCountEventArgs`1(T item, int count);
    [CompilerGeneratedAttribute]
public T get_Item();
    [CompilerGeneratedAttribute]
public int get_Count();
    public virtual string ToString();
}
public class C5.ItemInsertedHandler`1 : MulticastDelegate {
    public ItemInsertedHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, ItemAtEventArgs`1<T> eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, ItemAtEventArgs`1<T> eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class C5.ItemRemovedAtHandler`1 : MulticastDelegate {
    public ItemRemovedAtHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, ItemAtEventArgs`1<T> eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, ItemAtEventArgs`1<T> eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class C5.ItemsAddedHandler`1 : MulticastDelegate {
    public ItemsAddedHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, ItemCountEventArgs`1<T> eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, ItemCountEventArgs`1<T> eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class C5.ItemsRemovedHandler`1 : MulticastDelegate {
    public ItemsRemovedHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, ItemCountEventArgs`1<T> eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, ItemCountEventArgs`1<T> eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.KeyValuePairComparer`2 : object {
    private IComparer`1<K> comparer;
    public KeyValuePairComparer`2(IComparer`1<K> comparer);
    public sealed virtual int Compare(KeyValuePair`2<K, V> entry1, KeyValuePair`2<K, V> entry2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.KeyValuePairEqualityComparer`2 : object {
    private IEqualityComparer`1<K> keyequalityComparer;
    public KeyValuePairEqualityComparer`2(IEqualityComparer`1<K> keyequalityComparer);
    public sealed virtual int GetHashCode(KeyValuePair`2<K, V> entry);
    public sealed virtual bool Equals(KeyValuePair`2<K, V> entry1, KeyValuePair`2<K, V> entry2);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.LinkedList`1 : SequencedBase`1<T> {
    private bool fIFO;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<T> startsentinel;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<T> endsentinel;
    private int offset;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LinkedList`1<T> underlying;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakViewList`1<LinkedList`1<T>> views;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<LinkedList`1<T>> myWeakReference;
    private bool isValid;
    public EventType ListenableEvents { get; }
    public T First { get; }
    public T Last { get; }
    public bool FIFO { get; public set; }
    public bool IsFixedSize { get; }
    public T Item { get; public set; }
    public Speed IndexingSpeed { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<T> Underlying { get; }
    public bool IsValid { get; }
    public int Offset { get; }
    public IDirectedCollectionValue`1<T> Item { get; }
    public Speed ContainsSpeed { get; }
    public int Count { get; }
    public bool AllowsDuplicates { get; }
    public bool DuplicatesByCounting { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    [ObsoleteAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public LinkedList`1(IEqualityComparer`1<T> itemequalityComparer);
    public virtual EventType get_ListenableEvents();
    private bool Equals(T i1, T i2);
    protected virtual void UpdateCheck();
    private void ValidityCheck();
    protected virtual void ModifyCheck(int stamp);
    private bool Contains(T item, Node& node);
    private bool Find(T item, Node& node, Int32& index);
    private bool DnIf(T item, Node& node, Int32& index);
    private Node<T> Get(int pos);
    private int Dist(int pos, Int32& nearest, Int32[] positions);
    private Node<T> Get(int pos, Int32[] positions, Node[] nodes);
    private void GetPair(int p1, int p2, Node& n1, Node& n2, Int32[] positions, Node[] nodes);
    private Node<T> Insert(int index, Node<T> succ, T item);
    private T Remove(Node<T> node, int index);
    private void FixViewsAfterInsert(Node<T> succ, Node<T> pred, int added, int realInsertionIndex);
    private void FixViewsBeforeSingleRemove(Node<T> node, int realRemovalIndex);
    private void FixViewsBeforeRemove(int start, int count, Node<T> first, Node<T> last);
    private MutualViewPosition ViewPosition(LinkedList`1<T> otherView);
    private void DisposeOverlappingViews(bool reverse);
    public virtual void Dispose();
    private void Dispose(bool disposingUnderlying);
    public virtual T get_First();
    public virtual T get_Last();
    public virtual bool get_FIFO();
    public virtual void set_FIFO(bool value);
    public virtual bool get_IsFixedSize();
    public virtual T get_Item(int index);
    public virtual void set_Item(int index, T value);
    public virtual Speed get_IndexingSpeed();
    public virtual void Insert(int i, T item);
    public sealed virtual void Insert(IList`1<T> pointer, T item);
    public virtual void InsertAll(int i, IEnumerable`1<T> items);
    private void InsertAll(int i, IEnumerable`1<T> items, bool insertion);
    private void RaiseForInsertAll(Node<T> node, int i, int added, bool insertion);
    public virtual void InsertFirst(T item);
    public virtual void InsertLast(T item);
    public sealed virtual IList`1<V> Map(Func`2<T, V> mapper);
    public sealed virtual IList`1<V> Map(Func`2<T, V> mapper, IEqualityComparer`1<V> equalityComparer);
    private IList`1<V> Map(Func`2<T, V> mapper, LinkedList`1<V> retval);
    public virtual T Remove();
    public virtual T RemoveFirst();
    public virtual T RemoveLast();
    public virtual IList`1<T> View(int start, int count);
    public virtual IList`1<T> ViewOf(T item);
    public virtual IList`1<T> LastViewOf(T item);
    public virtual IList`1<T> get_Underlying();
    public virtual bool get_IsValid();
    public virtual int get_Offset();
    public sealed virtual IList`1<T> Slide(int offset);
    public sealed virtual IList`1<T> Slide(int offset, int size);
    public virtual bool TrySlide(int offset);
    public virtual bool TrySlide(int offset, int size);
    public virtual IList`1<T> Span(IList`1<T> otherView);
    public virtual void Reverse();
    private void MirrorViewSentinelsForReverse(Position[] positions, Int32& poslow, Int32& poshigh, Node<T> a, Node<T> b, int i);
    public sealed virtual bool IsSorted();
    public virtual bool IsSorted(IComparer`1<T> c);
    public virtual void Sort();
    public virtual void Sort(IComparer`1<T> c);
    private static Node<T> MergeRuns(Node<T> run1, Node<T> run2, IComparer`1<T> c);
    public virtual void Shuffle();
    public virtual void Shuffle(Random rnd);
    public sealed virtual IDirectedCollectionValue`1<T> get_Item(int start, int count);
    public virtual int IndexOf(T item);
    public virtual int LastIndexOf(T item);
    public virtual T RemoveAt(int i);
    public virtual void RemoveInterval(int start, int count);
    private void RaiseForRemoveInterval(int start, int count);
    public virtual int GetSequencedHashCode();
    public virtual bool SequencedEquals(ISequenced`1<T> that);
    public virtual IDirectedCollectionValue`1<T> Backwards();
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public virtual Speed get_ContainsSpeed();
    public virtual int GetUnsequencedHashCode();
    public virtual bool UnsequencedEquals(ICollection`1<T> that);
    public virtual bool Contains(T item);
    public virtual bool Find(T& item);
    public virtual bool Update(T item);
    public virtual bool Update(T item, T& olditem);
    public virtual bool FindOrAdd(T& item);
    public virtual bool UpdateOrAdd(T item);
    public virtual bool UpdateOrAdd(T item, T& olditem);
    public virtual bool Remove(T item);
    public virtual bool Remove(T item, T& removeditem);
    public virtual void RemoveAll(IEnumerable`1<T> items);
    public virtual void Clear();
    private void ClearInner();
    public virtual void RetainAll(IEnumerable`1<T> items);
    public virtual bool ContainsAll(IEnumerable`1<T> items);
    public sealed virtual IList`1<T> FindAll(Func`2<T, bool> filter);
    public virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public virtual void RemoveAllCopies(T item);
    public virtual int get_Count();
    public virtual T Choose();
    public virtual IEnumerable`1<T> Filter(Func`2<T, bool> filter);
    [IteratorStateMachineAttribute("C5.LinkedList`1/<GetEnumerator>d__125")]
public virtual IEnumerator`1<T> GetEnumerator();
    public virtual bool Add(T item);
    public virtual bool get_AllowsDuplicates();
    public virtual bool get_DuplicatesByCounting();
    public virtual void AddAll(IEnumerable`1<T> items);
    public sealed virtual void Push(T item);
    public sealed virtual T Pop();
    public virtual void Enqueue(T item);
    public virtual T Dequeue();
    private bool CheckViews();
    public virtual bool Check();
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array arr, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object o);
    private sealed virtual override bool System.Collections.IList.Contains(object o);
    private sealed virtual override int System.Collections.IList.IndexOf(object o);
    private sealed virtual override void System.Collections.IList.Insert(int index, object o);
    private sealed virtual override void System.Collections.IList.Remove(object o);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class C5.Logger : object {
    [CompilerGeneratedAttribute]
private static Action`1<string> <Log>k__BackingField;
    public static Action`1<string> Log { get; public set; }
    private static Logger();
    [CompilerGeneratedAttribute]
public static Action`1<string> get_Log();
    [CompilerGeneratedAttribute]
public static void set_Log(Action`1<string> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class C5.MappedCollectionValue`2 : CollectionValueBase`1<V> {
    private ICollectionValue`1<T> collectionValue;
    public bool IsEmpty { get; }
    public int Count { get; }
    public Speed CountSpeed { get; }
    protected MappedCollectionValue`2(ICollectionValue`1<T> collectionValue);
    public abstract virtual V Map(T item);
    public virtual V Choose();
    public virtual bool get_IsEmpty();
    public virtual int get_Count();
    public virtual Speed get_CountSpeed();
    [IteratorStateMachineAttribute("C5.MappedCollectionValue`2/<GetEnumerator>d__10")]
public virtual IEnumerator`1<V> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class C5.MappedDirectedCollectionValue`2 : DirectedCollectionValueBase`1<V> {
    private IDirectedCollectionValue`1<T> directedCollectionValue;
    public bool IsEmpty { get; }
    public int Count { get; }
    public Speed CountSpeed { get; }
    public Direction Direction { get; }
    protected MappedDirectedCollectionValue`2(IDirectedCollectionValue`1<T> directedCollectionValue);
    public abstract virtual V Map(T item);
    public virtual V Choose();
    public virtual bool get_IsEmpty();
    public virtual int get_Count();
    public virtual Speed get_CountSpeed();
    public virtual IDirectedCollectionValue`1<V> Backwards();
    [IteratorStateMachineAttribute("C5.MappedDirectedCollectionValue`2/<GetEnumerator>d__11")]
public virtual IEnumerator`1<V> GetEnumerator();
    public virtual Direction get_Direction();
    private sealed virtual override IDirectedEnumerable`1<V> C5.IDirectedEnumerable<V>.Backwards();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class C5.MappedDirectedEnumerable`2 : EnumerableBase`1<V> {
    private IDirectedEnumerable`1<T> directedenumerable;
    public Direction Direction { get; }
    public MappedDirectedEnumerable`2(IDirectedEnumerable`1<T> directedenumerable);
    public abstract virtual V Map(T item);
    public sealed virtual IDirectedEnumerable`1<V> Backwards();
    [IteratorStateMachineAttribute("C5.MappedDirectedEnumerable`2/<GetEnumerator>d__4")]
public virtual IEnumerator`1<V> GetEnumerator();
    public sealed virtual Direction get_Direction();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class C5.MultiplicityOne`1 : MappedCollectionValue`2<K, KeyValuePair`2<K, int>> {
    public MultiplicityOne`1(ICollectionValue`1<K> coll);
    public virtual KeyValuePair`2<K, int> Map(K k);
}
internal enum C5.MutualViewPosition : Enum {
    public int value__;
    public static MutualViewPosition Contains;
    public static MutualViewPosition ContainedIn;
    public static MutualViewPosition NonOverlapping;
    public static MutualViewPosition Overlapping;
}
public class C5.NoSuchItemException : Exception {
    [NullableContextAttribute("1")]
public NoSuchItemException(string message);
}
public class C5.NotAViewException : Exception {
    [NullableContextAttribute("1")]
public NotAViewException(string message);
}
public class C5.NotComparableException : Exception {
    [NullableContextAttribute("1")]
public NotComparableException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class C5.ProxyEventBlock`1 : object {
    private ICollectionValue`1<T> proxy;
    private ICollectionValue`1<T> real;
    [CompilerGeneratedAttribute]
private CollectionChangedHandler`1<T> CollectionChangedInner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private CollectionChangedHandler`1<T> collectionChangedProxy;
    [CompilerGeneratedAttribute]
private CollectionClearedHandler`1<T> CollectionClearedInner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private CollectionClearedHandler`1<T> collectionClearedProxy;
    [CompilerGeneratedAttribute]
private ItemsAddedHandler`1<T> ItemsAddedInner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ItemsAddedHandler`1<T> itemsAddedProxy;
    [CompilerGeneratedAttribute]
private ItemInsertedHandler`1<T> ItemInsertedInner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ItemInsertedHandler`1<T> itemInsertedProxy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ItemsRemovedHandler`1<T> ItemsRemovedInner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ItemsRemovedHandler`1<T> itemsRemovedProxy;
    [CompilerGeneratedAttribute]
private ItemRemovedAtHandler`1<T> ItemRemovedAtInner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ItemRemovedAtHandler`1<T> itemRemovedAtProxy;
    internal ProxyEventBlock`1(ICollectionValue`1<T> proxy, ICollectionValue`1<T> real);
    [CompilerGeneratedAttribute]
private void add_CollectionChangedInner(CollectionChangedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_CollectionChangedInner(CollectionChangedHandler`1<T> value);
    internal void add_CollectionChanged(CollectionChangedHandler`1<T> value);
    internal void remove_CollectionChanged(CollectionChangedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void add_CollectionClearedInner(CollectionClearedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_CollectionClearedInner(CollectionClearedHandler`1<T> value);
    internal void add_CollectionCleared(CollectionClearedHandler`1<T> value);
    internal void remove_CollectionCleared(CollectionClearedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void add_ItemsAddedInner(ItemsAddedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_ItemsAddedInner(ItemsAddedHandler`1<T> value);
    internal void add_ItemsAdded(ItemsAddedHandler`1<T> value);
    internal void remove_ItemsAdded(ItemsAddedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void add_ItemInsertedInner(ItemInsertedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_ItemInsertedInner(ItemInsertedHandler`1<T> value);
    internal void add_ItemInserted(ItemInsertedHandler`1<T> value);
    internal void remove_ItemInserted(ItemInsertedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void add_ItemsRemovedInner(ItemsRemovedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_ItemsRemovedInner(ItemsRemovedHandler`1<T> value);
    internal void add_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    internal void remove_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void add_ItemRemovedAtInner(ItemRemovedAtHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void remove_ItemRemovedAtInner(ItemRemovedAtHandler`1<T> value);
    internal void add_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    internal void remove_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    [CompilerGeneratedAttribute]
private void <add_CollectionChanged>b__8_0(object sender);
    [CompilerGeneratedAttribute]
private void <add_CollectionCleared>b__15_0(object sender, ClearedEventArgs e);
    [CompilerGeneratedAttribute]
private void <add_ItemsAdded>b__22_0(object sender, ItemCountEventArgs`1<T> e);
    [CompilerGeneratedAttribute]
private void <add_ItemInserted>b__29_0(object sender, ItemAtEventArgs`1<T> e);
    [CompilerGeneratedAttribute]
private void <add_ItemsRemoved>b__36_0(object sender, ItemCountEventArgs`1<T> e);
    [CompilerGeneratedAttribute]
private void <add_ItemRemovedAt>b__43_0(object sender, ItemAtEventArgs`1<T> e);
}
public class C5.ReadOnlyCollectionException : Exception {
    [NullableContextAttribute("1")]
public ReadOnlyCollectionException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class C5.SequencedBase`1 : DirectedCollectionBase`1<T> {
    private int iSequencedHashCode;
    private int iSequencedHashCodeStamp;
    private static int HASHFACTOR;
    public Direction Direction { get; }
    protected SequencedBase`1(IEqualityComparer`1<T> itemequalityComparer);
    public static int ComputeHashCode(ISequenced`1<T> items, IEqualityComparer`1<T> itemequalityComparer);
    public static bool StaticEquals(ISequenced`1<T> collection1, ISequenced`1<T> collection2, IEqualityComparer`1<T> itemequalityComparer);
    public virtual int GetSequencedHashCode();
    public virtual bool SequencedEquals(ISequenced`1<T> otherCollection);
    public abstract virtual IEnumerator`1<T> GetEnumerator();
    public virtual Direction get_Direction();
    public sealed virtual int FindIndex(Func`2<T, bool> predicate);
    public sealed virtual int FindLastIndex(Func`2<T, bool> predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.SequencedCollectionEqualityComparer`2 : object {
    private static SequencedCollectionEqualityComparer`2<T, W> cached;
    public static SequencedCollectionEqualityComparer`2<T, W> Default { get; }
    public static SequencedCollectionEqualityComparer`2<T, W> get_Default();
    public sealed virtual int GetHashCode(T collection);
    public sealed virtual bool Equals(T collection1, T collection2);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class C5.Showing : object {
    public static bool Show(object obj, StringBuilder stringbuilder, Int32& rest, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static string ShowString(IShowable showable, string format, IFormatProvider formatProvider);
    private static int MaxLength(string format);
    [NullableContextAttribute("1")]
public static bool ShowCollectionValue(ICollectionValue`1<T> items, StringBuilder stringbuilder, Int32& rest, IFormatProvider formatProvider);
    public static bool ShowDictionary(IDictionary`2<K, V> dictionary, StringBuilder stringbuilder, Int32& rest, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.SortedArray`1 : ArrayBase`1<T> {
    private IComparer`1<T> _comparer;
    public EventType ListenableEvents { get; }
    public Speed ContainsSpeed { get; }
    public bool AllowsDuplicates { get; }
    public bool DuplicatesByCounting { get; }
    public IComparer`1<T> Comparer { get; }
    public T Item { get; }
    public Speed IndexingSpeed { get; }
    public SortedArray`1(int capacity);
    public SortedArray`1(IComparer`1<T> comparer);
    public SortedArray`1(int capacity, IComparer`1<T> comparer);
    public SortedArray`1(int capacity, IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    public virtual EventType get_ListenableEvents();
    private bool BinarySearch(T item, Int32& middle);
    private int IndexOfInner(T item);
    public sealed virtual int CountFrom(T bot);
    public sealed virtual int CountFromTo(T bot, T top);
    public sealed virtual int CountTo(T top);
    public sealed virtual IDirectedCollectionValue`1<T> RangeFrom(T bot);
    public sealed virtual IDirectedCollectionValue`1<T> RangeFromTo(T bot, T top);
    public sealed virtual IDirectedCollectionValue`1<T> RangeTo(T top);
    public sealed virtual IIndexedSorted`1<T> FindAll(Func`2<T, bool> f);
    public sealed virtual IIndexedSorted`1<V> Map(Func`2<T, V> m, IComparer`1<V> c);
    public sealed virtual bool TryPredecessor(T item, T& res);
    public sealed virtual bool TrySuccessor(T item, T& res);
    public sealed virtual bool TryWeakPredecessor(T item, T& res);
    public sealed virtual bool TryWeakSuccessor(T item, T& res);
    public sealed virtual T Predecessor(T item);
    public sealed virtual T Successor(T item);
    public sealed virtual T WeakPredecessor(T item);
    public sealed virtual T WeakSuccessor(T item);
    public sealed virtual bool Cut(IComparable`1<T> c, T& low, Boolean& lowIsValid, T& high, Boolean& highIsValid);
    private sealed virtual override IDirectedEnumerable`1<T> C5.ISorted<T>.RangeFrom(T bot);
    private sealed virtual override IDirectedEnumerable`1<T> C5.ISorted<T>.RangeFromTo(T bot, T top);
    private sealed virtual override IDirectedEnumerable`1<T> C5.ISorted<T>.RangeTo(T top);
    public sealed virtual IDirectedCollectionValue`1<T> RangeAll();
    public sealed virtual void AddSorted(IEnumerable`1<T> items);
    public sealed virtual void RemoveRangeFrom(T low);
    public sealed virtual void RemoveRangeFromTo(T low, T hi);
    public sealed virtual void RemoveRangeTo(T hi);
    private void RaiseForRemoveRange(T[] removed);
    public sealed virtual Speed get_ContainsSpeed();
    public virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Find(T& item);
    public sealed virtual bool FindOrAdd(T& item);
    public sealed virtual bool Update(T item);
    public sealed virtual bool Update(T item, T& olditem);
    public sealed virtual bool UpdateOrAdd(T item);
    public sealed virtual bool UpdateOrAdd(T item, T& olditem);
    public sealed virtual bool Remove(T item);
    public sealed virtual bool Remove(T item, T& removeditem);
    public sealed virtual void RemoveAll(IEnumerable`1<T> items);
    public sealed virtual void RetainAll(IEnumerable`1<T> items);
    public sealed virtual bool ContainsAll(IEnumerable`1<T> items);
    public sealed virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public sealed virtual void RemoveAllCopies(T item);
    public virtual bool Check();
    public sealed virtual bool get_AllowsDuplicates();
    public virtual bool get_DuplicatesByCounting();
    public sealed virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void AddAll(IEnumerable`1<T> items);
    private void RaiseForAddAll(T[] addedItems, int numAdded);
    public sealed virtual T FindMin();
    public sealed virtual T DeleteMin();
    public sealed virtual T FindMax();
    public sealed virtual T DeleteMax();
    public sealed virtual IComparer`1<T> get_Comparer();
    public sealed virtual T get_Item(int i);
    public virtual Speed get_IndexingSpeed();
    public sealed virtual int IndexOf(T item);
    public sealed virtual int LastIndexOf(T item);
    public sealed virtual T RemoveAt(int i);
    public sealed virtual void RemoveInterval(int start, int count);
    private void RaiseForRemoveInterval(int count);
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class C5.SortedArrayDictionary`2 : SortedDictionaryBase`2<K, V> {
    public SortedArrayDictionary`2(IComparer`1<K> comparer);
    public SortedArrayDictionary`2(IComparer`1<K> comparer, IEqualityComparer`1<K> equalityComparer);
    public SortedArrayDictionary`2(int capacity, IComparer`1<K> comparer, IEqualityComparer`1<K> equalityComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class C5.SortedDictionaryBase`2 : DictionaryBase`2<K, V> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ISorted`1<KeyValuePair`2<K, V>> sortedpairs;
    private IComparer`1<K> keycomparer;
    public IComparer`1<K> Comparer { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISorted`1<K> Keys { get; }
    protected SortedDictionaryBase`2(IComparer`1<K> keycomparer, IEqualityComparer`1<K> keyequalityComparer);
    public sealed virtual IComparer`1<K> get_Comparer();
    public sealed virtual ISorted`1<K> get_Keys();
    public sealed virtual bool TryPredecessor(K key, KeyValuePair`2& res);
    public sealed virtual bool TrySuccessor(K key, KeyValuePair`2& res);
    public sealed virtual bool TryWeakPredecessor(K key, KeyValuePair`2& res);
    public sealed virtual bool TryWeakSuccessor(K key, KeyValuePair`2& res);
    public sealed virtual KeyValuePair`2<K, V> Predecessor(K key);
    public sealed virtual KeyValuePair`2<K, V> Successor(K key);
    public sealed virtual KeyValuePair`2<K, V> WeakPredecessor(K key);
    public sealed virtual KeyValuePair`2<K, V> WeakSuccessor(K key);
    public sealed virtual KeyValuePair`2<K, V> FindMin();
    public sealed virtual KeyValuePair`2<K, V> DeleteMin();
    public sealed virtual KeyValuePair`2<K, V> FindMax();
    public sealed virtual KeyValuePair`2<K, V> DeleteMax();
    public sealed virtual bool Cut(IComparable`1<K> cutter, KeyValuePair`2& lowEntry, Boolean& lowIsValid, KeyValuePair`2& highEntry, Boolean& highIsValid);
    public sealed virtual IDirectedEnumerable`1<KeyValuePair`2<K, V>> RangeFrom(K bot);
    public sealed virtual IDirectedEnumerable`1<KeyValuePair`2<K, V>> RangeFromTo(K bot, K top);
    public sealed virtual IDirectedEnumerable`1<KeyValuePair`2<K, V>> RangeTo(K top);
    public sealed virtual IDirectedCollectionValue`1<KeyValuePair`2<K, V>> RangeAll();
    public sealed virtual void AddSorted(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public sealed virtual void RemoveRangeFrom(K lowKey);
    public sealed virtual void RemoveRangeFromTo(K lowKey, K highKey);
    public sealed virtual void RemoveRangeTo(K highKey);
    public virtual bool Show(StringBuilder stringbuilder, Int32& rest, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.Sorting : object {
    public static void IntroSort(T[] array, int start, int count, IComparer`1<T> comparer);
    public static void IntroSort(T[] array);
    public static void InsertionSort(T[] array, int start, int count, IComparer`1<T> comparer);
    public static void HeapSort(T[] array, int start, int count, IComparer`1<T> comparer);
}
public enum C5.Speed : Enum {
    public short value__;
    public static Speed PotentiallyInfinite;
    public static Speed Linear;
    public static Speed Log;
    public static Speed Constant;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.TreeBag`1 : SequencedBase`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<T> root;
    private int blackdepth;
    [CompilerGeneratedAttribute]
private int <UniqueCount>k__BackingField;
    [NullableAttribute("2")]
private Int32[] dirs;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node[] path;
    private bool isSnapShot;
    private int generation;
    private bool isValid;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SnapRef<T> snapList;
    private bool _disposed;
    public int UniqueCount { get; private set; }
    public EventType ListenableEvents { get; }
    public bool AllowsDuplicates { get; }
    public bool DuplicatesByCounting { get; }
    public Speed ContainsSpeed { get; }
    public T Item { get; }
    public Speed IndexingSpeed { get; }
    public IDirectedCollectionValue`1<T> Item { get; }
    public IComparer`1<T> Comparer { get; }
    private int MaxSnapId { get; }
    public TreeBag`1(IComparer`1<T> comparer);
    public TreeBag`1(IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    [CompilerGeneratedAttribute]
public int get_UniqueCount();
    [CompilerGeneratedAttribute]
private void set_UniqueCount(int value);
    public virtual EventType get_ListenableEvents();
    private Node<T> Left(Node<T> n);
    private Node<T> Right(Node<T> n);
    private void StackCheck();
    [IteratorStateMachineAttribute("C5.TreeBag`1/<GetEnumerator>d__24")]
private IEnumerator`1<T> GetEnumerator(Node<T> node, int origstamp);
    public virtual T Choose();
    public virtual IEnumerator`1<T> GetEnumerator();
    private bool AddIterative(T item, T& founditem, bool update, Boolean& wasfound);
    public sealed virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private bool Add(T item, T& j);
    public sealed virtual void AddAll(IEnumerable`1<T> items);
    public sealed virtual void AddSorted(IEnumerable`1<T> items);
    private static Node<T> MakeTreer(Node& rest, int blackheight, int maxred, int red);
    private void AddSorted(IEnumerable`1<T> items, bool raise);
    public sealed virtual bool get_AllowsDuplicates();
    public virtual bool get_DuplicatesByCounting();
    public sealed virtual Speed get_ContainsSpeed();
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Find(T& item);
    public sealed virtual bool FindOrAdd(T& item);
    public sealed virtual bool Update(T item);
    public sealed virtual bool Update(T item, T& olditem);
    public sealed virtual bool UpdateOrAdd(T item);
    public sealed virtual bool UpdateOrAdd(T item, T& olditem);
    public sealed virtual bool Remove(T item);
    public sealed virtual bool Remove(T item, T& removeditem);
    private bool RemoveIterative(T& item, bool all, Int32& wasRemoved);
    private bool RemoveIterativePhase2(Node<T> cursor, int level);
    public sealed virtual void Clear();
    private void ClearInner();
    public sealed virtual void RemoveAll(IEnumerable`1<T> items);
    public sealed virtual void RetainAll(IEnumerable`1<T> items);
    public sealed virtual bool ContainsAll(IEnumerable`1<T> items);
    public sealed virtual IIndexedSorted`1<T> FindAll(Func`2<T, bool> filter);
    public sealed virtual IIndexedSorted`1<V> Map(Func`2<T, V> mapper, IComparer`1<V> c);
    public sealed virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public sealed virtual void RemoveAllCopies(T item);
    private Node<T> FindNode(int i);
    public sealed virtual T get_Item(int i);
    public virtual Speed get_IndexingSpeed();
    public sealed virtual int IndexOf(T item);
    private int IndexOf(T item, Int32& upper);
    public sealed virtual int LastIndexOf(T item);
    public sealed virtual T RemoveAt(int i);
    private T RemoveAtInner(int i);
    private void RespliceBag(int level, Node<T> cursor);
    public sealed virtual void RemoveInterval(int start, int count);
    public sealed virtual IDirectedCollectionValue`1<T> get_Item(int start, int count);
    public virtual IDirectedCollectionValue`1<T> Backwards();
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public sealed virtual IComparer`1<T> get_Comparer();
    public sealed virtual T FindMin();
    public sealed virtual T DeleteMin();
    private T DeleteMinInner();
    public sealed virtual T FindMax();
    public sealed virtual T DeleteMax();
    private T DeleteMaxInner();
    public sealed virtual bool TryPredecessor(T item, T& res);
    public sealed virtual bool TrySuccessor(T item, T& res);
    public sealed virtual bool TryWeakPredecessor(T item, T& res);
    public sealed virtual bool TryWeakSuccessor(T item, T& res);
    public sealed virtual T Predecessor(T item);
    public sealed virtual T WeakPredecessor(T item);
    public sealed virtual T Successor(T item);
    public sealed virtual T WeakSuccessor(T item);
    public sealed virtual IDirectedCollectionValue`1<T> RangeFrom(T bot);
    public sealed virtual IDirectedCollectionValue`1<T> RangeFromTo(T bot, T top);
    public sealed virtual IDirectedCollectionValue`1<T> RangeTo(T top);
    public sealed virtual IDirectedCollectionValue`1<T> RangeAll();
    private sealed virtual override IDirectedEnumerable`1<T> C5.ISorted<T>.RangeFrom(T bot);
    private sealed virtual override IDirectedEnumerable`1<T> C5.ISorted<T>.RangeFromTo(T bot, T top);
    private sealed virtual override IDirectedEnumerable`1<T> C5.ISorted<T>.RangeTo(T top);
    private int CountTo(T item, bool strict);
    public sealed virtual bool Cut(IComparable`1<T> c, T& low, Boolean& lowIsValid, T& high, Boolean& highIsValid);
    public sealed virtual int CountFrom(T bot);
    public sealed virtual int CountFromTo(T bot, T top);
    public sealed virtual int CountTo(T top);
    public sealed virtual void RemoveRangeFrom(T low);
    public sealed virtual void RemoveRangeFromTo(T low, T hi);
    public sealed virtual void RemoveRangeTo(T hi);
    private int get_MaxSnapId();
    private int FindLastLiveSnapShot();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private void SnapDispose();
    public sealed virtual ISorted`1<T> Snapshot();
    private void MiniDump(Node<T> n, string space);
    public void Dump();
    public void Dump(string msg);
    private void Dump(string msg, string err);
    private bool Massert(bool b, Node<T> n, string m);
    private bool RbMiniCheck(Node<T> n, bool redp, T& min, T& max, Int32& blackheight);
    private bool RbMiniSnapCheck(Node<T> n, Int32& size, T& min, T& max);
    public bool Check(string name);
    public sealed virtual bool Check();
    private bool CheckInner();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class C5.TreeDictionary`2 : SortedDictionaryBase`2<K, V> {
    [NullableContextAttribute("1")]
public TreeDictionary`2(IComparer`1<K> comparer);
    [NullableContextAttribute("1")]
private TreeDictionary`2(IComparer`1<K> comparer, IEqualityComparer`1<K> equalityComparer);
    public IEnumerable`1<KeyValuePair`2<K, V>> Snapshot();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class C5.TreeSet`1 : SequencedBase`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<T> root;
    private int blackdepth;
    [NullableAttribute("2")]
private Int32[] dirs;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node[] path;
    private bool isSnapShot;
    private int generation;
    private bool isValid;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SnapRef<T> snapList;
    public EventType ListenableEvents { get; }
    public bool AllowsDuplicates { get; }
    public bool DuplicatesByCounting { get; }
    public Speed ContainsSpeed { get; }
    public T Item { get; }
    public Speed IndexingSpeed { get; }
    public IDirectedCollectionValue`1<T> Item { get; }
    public IComparer`1<T> Comparer { get; }
    private int MaxSnapId { get; }
    public TreeSet`1(IComparer`1<T> comparer);
    public TreeSet`1(IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    public virtual EventType get_ListenableEvents();
    private Node<T> Left(Node<T> n);
    private Node<T> Right(Node<T> n);
    private void StackCheck();
    [IteratorStateMachineAttribute("C5.TreeSet`1/<GetEnumerator>d__20")]
private IEnumerator`1<T> GetEnumerator(Node<T> node, int origstamp);
    public virtual T Choose();
    public virtual IEnumerator`1<T> GetEnumerator();
    private bool AddIterative(T item, T& founditem, bool update, Boolean& wasfound);
    public sealed virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private bool Add(T item, T& j);
    public sealed virtual void AddAll(IEnumerable`1<T> items);
    public sealed virtual void AddSorted(IEnumerable`1<T> items);
    private static Node<T> MakeTreer(Node& rest, int blackheight, int maxred, int red);
    private void AddSorted(IEnumerable`1<T> items, bool safe, bool raise);
    public sealed virtual bool get_AllowsDuplicates();
    public virtual bool get_DuplicatesByCounting();
    public sealed virtual Speed get_ContainsSpeed();
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Find(T& item);
    public sealed virtual bool FindOrAdd(T& item);
    public sealed virtual bool Update(T item);
    public sealed virtual bool Update(T item, T& olditem);
    public sealed virtual bool UpdateOrAdd(T item);
    public sealed virtual bool UpdateOrAdd(T item, T& olditem);
    public sealed virtual bool Remove(T item);
    public sealed virtual bool Remove(T item, T& removeditem);
    private bool RemoveIterative(T& item, Int32& wasRemoved);
    private bool RemoveIterativePhase2(Node<T> cursor, int level);
    public sealed virtual void Clear();
    private void ClearInner();
    public sealed virtual void RemoveAll(IEnumerable`1<T> items);
    public sealed virtual void RetainAll(IEnumerable`1<T> items);
    public sealed virtual bool ContainsAll(IEnumerable`1<T> items);
    public sealed virtual IIndexedSorted`1<T> FindAll(Func`2<T, bool> filter);
    public sealed virtual IIndexedSorted`1<V> Map(Func`2<T, V> mapper, IComparer`1<V> c);
    public sealed virtual int ContainsCount(T item);
    public virtual ICollectionValue`1<T> UniqueItems();
    public virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public sealed virtual void RemoveAllCopies(T item);
    private Node<T> FindNode(int i);
    public sealed virtual T get_Item(int i);
    public virtual Speed get_IndexingSpeed();
    public sealed virtual int IndexOf(T item);
    private int IndexOf(T item, Int32& upper);
    public sealed virtual int LastIndexOf(T item);
    public sealed virtual T RemoveAt(int i);
    private T RemoveAtInner(int i);
    public sealed virtual void RemoveInterval(int start, int count);
    public sealed virtual IDirectedCollectionValue`1<T> get_Item(int start, int count);
    public virtual IDirectedCollectionValue`1<T> Backwards();
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public sealed virtual IComparer`1<T> get_Comparer();
    public sealed virtual T FindMin();
    public sealed virtual T DeleteMin();
    private T DeleteMinInner();
    public sealed virtual T FindMax();
    public sealed virtual T DeleteMax();
    private T DeleteMaxInner();
    public sealed virtual bool TryPredecessor(T item, T& res);
    public sealed virtual bool TrySuccessor(T item, T& res);
    public sealed virtual bool TryWeakPredecessor(T item, T& res);
    public sealed virtual bool TryWeakSuccessor(T item, T& res);
    public sealed virtual T Predecessor(T item);
    public sealed virtual T WeakPredecessor(T item);
    public sealed virtual T Successor(T item);
    public sealed virtual T WeakSuccessor(T item);
    public sealed virtual IDirectedCollectionValue`1<T> RangeFrom(T bot);
    public sealed virtual IDirectedCollectionValue`1<T> RangeFromTo(T bot, T top);
    public sealed virtual IDirectedCollectionValue`1<T> RangeTo(T top);
    public sealed virtual IDirectedCollectionValue`1<T> RangeAll();
    private sealed virtual override IDirectedEnumerable`1<T> C5.ISorted<T>.RangeFrom(T bot);
    private sealed virtual override IDirectedEnumerable`1<T> C5.ISorted<T>.RangeFromTo(T bot, T top);
    private sealed virtual override IDirectedEnumerable`1<T> C5.ISorted<T>.RangeTo(T top);
    private int CountTo(T item, bool strict);
    public sealed virtual bool Cut(IComparable`1<T> c, T& low, Boolean& lowIsValid, T& high, Boolean& highIsValid);
    public sealed virtual int CountFrom(T bot);
    public sealed virtual int CountFromTo(T bot, T top);
    public sealed virtual int CountTo(T top);
    public sealed virtual void RemoveRangeFrom(T low);
    public sealed virtual void RemoveRangeFromTo(T low, T hi);
    public sealed virtual void RemoveRangeTo(T hi);
    private int get_MaxSnapId();
    private int FindLastLiveSnapShot();
    public sealed virtual void Dispose();
    private void SnapDispose();
    public sealed virtual ISorted`1<T> Snapshot();
    private void MiniDump(Node<T> n, string space);
    public void Dump();
    public void Dump(string msg);
    private void Dump(string msg, string err);
    private bool Massert(bool b, Node<T> n, string m);
    private bool RbMiniCheck(Node<T> n, bool redp, T& min, T& max, Int32& blackheight);
    private bool RbMiniSnapCheck(Node<T> n, Int32& size, T& min, T& max);
    public bool Check(string name);
    public sealed virtual bool Check();
    private bool CheckInner();
}
public class C5.UnlistenableEventException : Exception {
    [NullableContextAttribute("1")]
public UnlistenableEventException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class C5.UnsequencedCollectionEqualityComparer`2 : object {
    private static UnsequencedCollectionEqualityComparer`2<T, W> cached;
    public static UnsequencedCollectionEqualityComparer`2<T, W> Default { get; }
    public static UnsequencedCollectionEqualityComparer`2<T, W> get_Default();
    public sealed virtual int GetHashCode(T collection);
    public sealed virtual bool Equals(T collection1, T collection2);
}
public class C5.ViewDisposedException : Exception {
    [NullableContextAttribute("1")]
public ViewDisposedException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class C5.WeakViewList`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<V> start;
    internal Node<V> Add(V view);
    internal void Remove(Node<V> n);
    [IteratorStateMachineAttribute("C5.WeakViewList`1/<GetEnumerator>d__4")]
public IEnumerator`1<V> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class C5.WrappedArray`1 : object {
    private ArrayList`1<T> innerlist;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WrappedArray`1<T> underlying;
    public T First { get; }
    public T Last { get; }
    public T Item { get; public set; }
    public bool FIFO { get; public set; }
    public bool IsFixedSize { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<T> Underlying { get; }
    public int Offset { get; }
    public bool IsValid { get; }
    public Speed IndexingSpeed { get; }
    public IDirectedCollectionValue`1<T> Item { get; }
    public Speed ContainsSpeed { get; }
    public bool IsReadOnly { get; }
    public bool AllowsDuplicates { get; }
    public IEqualityComparer`1<T> EqualityComparer { get; }
    public bool DuplicatesByCounting { get; }
    public EventType ListenableEvents { get; }
    public EventType ActiveEvents { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public Speed CountSpeed { get; }
    public Direction Direction { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    [ObsoleteAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public WrappedArray`1(T[] wrappedarray);
    private WrappedArray`1(ArrayList`1<T> arraylist, WrappedArray`1<T> underlying);
    public sealed virtual T get_First();
    public sealed virtual T get_Last();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual IList`1<T> FindAll(Func`2<T, bool> filter);
    public sealed virtual IList`1<V> Map(Func`2<T, V> mapper);
    public sealed virtual IList`1<V> Map(Func`2<T, V> mapper, IEqualityComparer`1<V> equalityComparer);
    public sealed virtual bool get_FIFO();
    public sealed virtual void set_FIFO(bool value);
    public virtual bool get_IsFixedSize();
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void Insert(IList`1<T> pointer, T item);
    public sealed virtual void InsertFirst(T item);
    public sealed virtual void InsertLast(T item);
    public sealed virtual void InsertAll(int i, IEnumerable`1<T> items);
    public sealed virtual T Remove();
    public sealed virtual T RemoveFirst();
    public sealed virtual T RemoveLast();
    public sealed virtual IList`1<T> View(int start, int count);
    public sealed virtual IList`1<T> ViewOf(T item);
    public sealed virtual IList`1<T> LastViewOf(T item);
    public sealed virtual IList`1<T> get_Underlying();
    public sealed virtual int get_Offset();
    public sealed virtual bool get_IsValid();
    public sealed virtual IList`1<T> Slide(int offset);
    public sealed virtual IList`1<T> Slide(int offset, int size);
    public sealed virtual bool TrySlide(int offset);
    public sealed virtual bool TrySlide(int offset, int size);
    public sealed virtual IList`1<T> Span(IList`1<T> otherView);
    public sealed virtual void Reverse();
    public sealed virtual bool IsSorted();
    public sealed virtual bool IsSorted(IComparer`1<T> comparer);
    public sealed virtual void Sort();
    public sealed virtual void Sort(IComparer`1<T> comparer);
    public sealed virtual void Shuffle();
    public sealed virtual void Shuffle(Random rnd);
    public sealed virtual Speed get_IndexingSpeed();
    public sealed virtual IDirectedCollectionValue`1<T> get_Item(int start, int count);
    public sealed virtual int IndexOf(T item);
    public sealed virtual int LastIndexOf(T item);
    public sealed virtual int FindIndex(Func`2<T, bool> predicate);
    public sealed virtual int FindLastIndex(Func`2<T, bool> predicate);
    public sealed virtual T RemoveAt(int i);
    public sealed virtual void RemoveInterval(int start, int count);
    public sealed virtual int GetSequencedHashCode();
    public sealed virtual bool SequencedEquals(ISequenced`1<T> that);
    public sealed virtual Speed get_ContainsSpeed();
    public sealed virtual int GetUnsequencedHashCode();
    public sealed virtual bool UnsequencedEquals(ICollection`1<T> that);
    public sealed virtual bool Contains(T item);
    public sealed virtual int ContainsCount(T item);
    public sealed virtual ICollectionValue`1<T> UniqueItems();
    public sealed virtual ICollectionValue`1<KeyValuePair`2<T, int>> ItemMultiplicities();
    public sealed virtual bool ContainsAll(IEnumerable`1<T> items);
    public sealed virtual bool Find(T& item);
    public sealed virtual bool FindOrAdd(T& item);
    public sealed virtual bool Update(T item);
    public sealed virtual bool Update(T item, T& olditem);
    public sealed virtual bool UpdateOrAdd(T item);
    public sealed virtual bool UpdateOrAdd(T item, T& olditem);
    public sealed virtual bool Remove(T item);
    public sealed virtual bool Remove(T item, T& removeditem);
    public sealed virtual void RemoveAllCopies(T item);
    public sealed virtual void RemoveAll(IEnumerable`1<T> items);
    public sealed virtual void Clear();
    public sealed virtual void RetainAll(IEnumerable`1<T> items);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_AllowsDuplicates();
    public sealed virtual IEqualityComparer`1<T> get_EqualityComparer();
    public sealed virtual bool get_DuplicatesByCounting();
    public sealed virtual bool Add(T item);
    public sealed virtual void AddAll(IEnumerable`1<T> items);
    public sealed virtual bool Check();
    public virtual EventType get_ListenableEvents();
    public virtual EventType get_ActiveEvents();
    public sealed virtual void add_CollectionChanged(CollectionChangedHandler`1<T> value);
    public sealed virtual void remove_CollectionChanged(CollectionChangedHandler`1<T> value);
    public sealed virtual void add_CollectionCleared(CollectionClearedHandler`1<T> value);
    public sealed virtual void remove_CollectionCleared(CollectionClearedHandler`1<T> value);
    public sealed virtual void add_ItemsAdded(ItemsAddedHandler`1<T> value);
    public sealed virtual void remove_ItemsAdded(ItemsAddedHandler`1<T> value);
    public sealed virtual void add_ItemInserted(ItemInsertedHandler`1<T> value);
    public sealed virtual void remove_ItemInserted(ItemInsertedHandler`1<T> value);
    public sealed virtual void add_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    public sealed virtual void remove_ItemsRemoved(ItemsRemovedHandler`1<T> value);
    public sealed virtual void add_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    public sealed virtual void remove_ItemRemovedAt(ItemRemovedAtHandler`1<T> value);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual Speed get_CountSpeed();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual T[] ToArray();
    public sealed virtual void Apply(Action`1<T> action);
    public sealed virtual bool Exists(Func`2<T, bool> predicate);
    public sealed virtual bool Find(Func`2<T, bool> predicate, T& item);
    public sealed virtual bool All(Func`2<T, bool> predicate);
    public sealed virtual T Choose();
    public sealed virtual IEnumerable`1<T> Filter(Func`2<T, bool> filter);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual bool Show(StringBuilder stringbuilder, Int32& rest, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual IDirectedCollectionValue`1<T> Backwards();
    public sealed virtual bool FindLast(Func`2<T, bool> predicate, T& item);
    private sealed virtual override IDirectedEnumerable`1<T> C5.IDirectedEnumerable<T>.Backwards();
    public sealed virtual Direction get_Direction();
    public sealed virtual void Dispose();
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array arr, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object o);
    private sealed virtual override bool System.Collections.IList.Contains(object o);
    private sealed virtual override int System.Collections.IList.IndexOf(object o);
    private sealed virtual override void System.Collections.IList.Insert(int index, object o);
    private sealed virtual override void System.Collections.IList.Remove(object o);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
