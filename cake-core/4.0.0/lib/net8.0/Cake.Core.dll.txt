public class Cake.Core.AfterSetupEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ICakeContext <Context>k__BackingField;
    public ICakeContext Context { get; }
    public AfterSetupEventArgs(ICakeContext context);
    [CompilerGeneratedAttribute]
public ICakeContext get_Context();
}
public class Cake.Core.AfterTaskSetupEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITaskSetupContext <TaskSetupContext>k__BackingField;
    public ITaskSetupContext TaskSetupContext { get; }
    public AfterTaskSetupEventArgs(ITaskSetupContext taskSetupContext);
    [CompilerGeneratedAttribute]
public ITaskSetupContext get_TaskSetupContext();
}
public class Cake.Core.AfterTaskTeardownEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITaskTeardownContext <TaskTeardownContext>k__BackingField;
    public ITaskTeardownContext TaskTeardownContext { get; }
    public AfterTaskTeardownEventArgs(ITaskTeardownContext taskTeardownContext);
    [CompilerGeneratedAttribute]
public ITaskTeardownContext get_TaskTeardownContext();
}
public class Cake.Core.AfterTeardownEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITeardownContext <TeardownContext>k__BackingField;
    public ITeardownContext TeardownContext { get; }
    public AfterTeardownEventArgs(ITeardownContext teardownContext);
    [CompilerGeneratedAttribute]
public ITeardownContext get_TeardownContext();
}
public abstract class Cake.Core.Annotations.CakeAliasAttribute : Attribute {
}
[AttributeUsageAttribute("68")]
public class Cake.Core.Annotations.CakeAliasCategoryAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public CakeAliasCategoryAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("64")]
public class Cake.Core.Annotations.CakeMethodAliasAttribute : CakeAliasAttribute {
}
[AttributeUsageAttribute("1")]
public class Cake.Core.Annotations.CakeModuleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ModuleType>k__BackingField;
    public Type ModuleType { get; }
    public CakeModuleAttribute(Type moduleType);
    [CompilerGeneratedAttribute]
public Type get_ModuleType();
}
[AttributeUsageAttribute("69")]
public class Cake.Core.Annotations.CakeNamespaceImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    public string Namespace { get; }
    public CakeNamespaceImportAttribute(string namespace);
    [CompilerGeneratedAttribute]
public string get_Namespace();
}
[AttributeUsageAttribute("64")]
public class Cake.Core.Annotations.CakePropertyAliasAttribute : CakeAliasAttribute {
    [CompilerGeneratedAttribute]
private bool <Cache>k__BackingField;
    public bool Cache { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Cache();
    [CompilerGeneratedAttribute]
public void set_Cache(bool value);
}
[CompilerGeneratedAttribute]
internal class Cake.Core.Annotations.NamespaceDoc : object {
}
public class Cake.Core.BeforeSetupEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ICakeContext <Context>k__BackingField;
    public ICakeContext Context { get; }
    public BeforeSetupEventArgs(ICakeContext context);
    [CompilerGeneratedAttribute]
public ICakeContext get_Context();
}
public class Cake.Core.BeforeTaskSetupEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITaskSetupContext <TaskSetupContext>k__BackingField;
    public ITaskSetupContext TaskSetupContext { get; }
    public BeforeTaskSetupEventArgs(ITaskSetupContext taskSetupContext);
    [CompilerGeneratedAttribute]
public ITaskSetupContext get_TaskSetupContext();
}
public class Cake.Core.BeforeTaskTeardownEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITaskTeardownContext <TaskTeardownContext>k__BackingField;
    public ITaskTeardownContext TaskTeardownContext { get; }
    public BeforeTaskTeardownEventArgs(ITaskTeardownContext taskTeardownContext);
    [CompilerGeneratedAttribute]
public ITaskTeardownContext get_TaskTeardownContext();
}
public class Cake.Core.BeforeTeardownEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITeardownContext <TeardownContext>k__BackingField;
    public ITeardownContext TeardownContext { get; }
    public BeforeTeardownEventArgs(ITeardownContext teardownContext);
    [CompilerGeneratedAttribute]
public ITeardownContext get_TeardownContext();
}
[ExtensionAttribute]
public static class Cake.Core.ByteArrayExtensions : object {
    [ExtensionAttribute]
public static bool StartsWith(Byte[] value, Byte[] prefix);
}
public class Cake.Core.CakeArguments : object {
    private Dictionary`2<string, List`1<string>> _arguments;
    public CakeArguments(ILookup`2<string, string> arguments);
    public sealed virtual bool HasArgument(string name);
    public sealed virtual ICollection`1<string> GetArguments(string name);
    public sealed virtual IDictionary`2<string, ICollection`1<string>> GetArguments();
}
[ExtensionAttribute]
public static class Cake.Core.CakeArgumentsExtensions : object {
    [ExtensionAttribute]
public static string GetArgument(ICakeArguments arguments, string name);
}
[ExtensionAttribute]
public static class Cake.Core.CakeConfigurationExtensions : object {
    [ExtensionAttribute]
public static DirectoryPath GetToolPath(ICakeConfiguration configuration, DirectoryPath defaultRoot, ICakeEnvironment environment);
    [ExtensionAttribute]
public static DirectoryPath GetModulePath(ICakeConfiguration configuration, DirectoryPath defaultRoot, ICakeEnvironment environment);
}
public class Cake.Core.CakeConsole : object {
    private Lazy`1<bool> _supportAnsiEscapeCodes;
    public ConsoleColor ForegroundColor { get; public set; }
    public ConsoleColor BackgroundColor { get; public set; }
    public bool SupportAnsiEscapeCodes { get; }
    public CakeConsole(ICakeEnvironment environment);
    public sealed virtual ConsoleColor get_ForegroundColor();
    public sealed virtual void set_ForegroundColor(ConsoleColor value);
    public sealed virtual ConsoleColor get_BackgroundColor();
    public sealed virtual void set_BackgroundColor(ConsoleColor value);
    public sealed virtual bool get_SupportAnsiEscapeCodes();
    public sealed virtual void Write(string format, Object[] arg);
    public sealed virtual void WriteLine(string format, Object[] arg);
    public sealed virtual void WriteError(string format, Object[] arg);
    public sealed virtual void WriteErrorLine(string format, Object[] arg);
    public sealed virtual void ResetColor();
}
public class Cake.Core.CakeContext : object {
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private ICakeEnvironment <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private IGlobber <Globber>k__BackingField;
    [CompilerGeneratedAttribute]
private ICakeLog <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private ICakeArguments <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IProcessRunner <ProcessRunner>k__BackingField;
    [CompilerGeneratedAttribute]
private IRegistry <Registry>k__BackingField;
    [CompilerGeneratedAttribute]
private IToolLocator <Tools>k__BackingField;
    [CompilerGeneratedAttribute]
private ICakeDataResolver <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private ICakeConfiguration <Configuration>k__BackingField;
    public IFileSystem FileSystem { get; }
    public ICakeEnvironment Environment { get; }
    public IGlobber Globber { get; }
    public ICakeLog Log { get; }
    public ICakeArguments Arguments { get; }
    public IProcessRunner ProcessRunner { get; }
    public IRegistry Registry { get; }
    public IToolLocator Tools { get; }
    public ICakeDataResolver Data { get; }
    public ICakeConfiguration Configuration { get; }
    public CakeContext(IFileSystem fileSystem, ICakeEnvironment environment, IGlobber globber, ICakeLog log, ICakeArguments arguments, IProcessRunner processRunner, IRegistry registry, IToolLocator tools, ICakeDataService data, ICakeConfiguration configuration);
    [CompilerGeneratedAttribute]
public sealed virtual IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
public sealed virtual ICakeEnvironment get_Environment();
    [CompilerGeneratedAttribute]
public sealed virtual IGlobber get_Globber();
    [CompilerGeneratedAttribute]
public sealed virtual ICakeLog get_Log();
    [CompilerGeneratedAttribute]
public sealed virtual ICakeArguments get_Arguments();
    [CompilerGeneratedAttribute]
public sealed virtual IProcessRunner get_ProcessRunner();
    [CompilerGeneratedAttribute]
public sealed virtual IRegistry get_Registry();
    [CompilerGeneratedAttribute]
public sealed virtual IToolLocator get_Tools();
    [CompilerGeneratedAttribute]
public sealed virtual ICakeDataResolver get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual ICakeConfiguration get_Configuration();
}
public abstract class Cake.Core.CakeContextAdapter : object {
    private ICakeContext _context;
    public IFileSystem FileSystem { get; }
    public ICakeEnvironment Environment { get; }
    public IGlobber Globber { get; }
    public ICakeLog Log { get; }
    public ICakeArguments Arguments { get; }
    public IProcessRunner ProcessRunner { get; }
    public IRegistry Registry { get; }
    public IToolLocator Tools { get; }
    public ICakeDataResolver Data { get; }
    public ICakeConfiguration Configuration { get; }
    protected CakeContextAdapter(ICakeContext context);
    public virtual IFileSystem get_FileSystem();
    public virtual ICakeEnvironment get_Environment();
    public virtual IGlobber get_Globber();
    public virtual ICakeLog get_Log();
    public virtual ICakeArguments get_Arguments();
    public virtual IProcessRunner get_ProcessRunner();
    public virtual IRegistry get_Registry();
    public virtual IToolLocator get_Tools();
    public virtual ICakeDataResolver get_Data();
    public virtual ICakeConfiguration get_Configuration();
}
public class Cake.Core.CakeDataService : object {
    private Dictionary`2<Type, object> _data;
    public sealed virtual TData Get();
    public sealed virtual void Add(TData value);
}
public class Cake.Core.CakeEngine : object {
    private ICakeLog _log;
    private List`1<CakeTask> _tasks;
    private CakeEngineActions _actions;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeSetupEventArgs> BeforeSetup;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterSetupEventArgs> AfterSetup;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeTeardownEventArgs> BeforeTeardown;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterTeardownEventArgs> AfterTeardown;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeTaskSetupEventArgs> BeforeTaskSetup;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterTaskSetupEventArgs> AfterTaskSetup;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeTaskTeardownEventArgs> BeforeTaskTeardown;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterTaskTeardownEventArgs> AfterTaskTeardown;
    public IReadOnlyList`1<ICakeTaskInfo> Tasks { get; }
    public CakeEngine(ICakeDataService data, ICakeLog log);
    public sealed virtual IReadOnlyList`1<ICakeTaskInfo> get_Tasks();
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeSetup(EventHandler`1<BeforeSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeSetup(EventHandler`1<BeforeSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AfterSetup(EventHandler`1<AfterSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AfterSetup(EventHandler`1<AfterSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeTeardown(EventHandler`1<BeforeTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeTeardown(EventHandler`1<BeforeTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AfterTeardown(EventHandler`1<AfterTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AfterTeardown(EventHandler`1<AfterTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeTaskSetup(EventHandler`1<BeforeTaskSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeTaskSetup(EventHandler`1<BeforeTaskSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AfterTaskSetup(EventHandler`1<AfterTaskSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AfterTaskSetup(EventHandler`1<AfterTaskSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeTaskTeardown(EventHandler`1<BeforeTaskTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeTaskTeardown(EventHandler`1<BeforeTaskTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AfterTaskTeardown(EventHandler`1<AfterTaskTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AfterTaskTeardown(EventHandler`1<AfterTaskTeardownEventArgs> value);
    public sealed virtual CakeTaskBuilder RegisterTask(string name);
    public sealed virtual void RegisterSetupAction(Action`1<ISetupContext> action);
    public sealed virtual void RegisterSetupAction(Func`2<ISetupContext, TData> action);
    public sealed virtual void RegisterTeardownAction(Action`1<ITeardownContext> action);
    public sealed virtual void RegisterTeardownAction(Action`2<ITeardownContext, TData> action);
    public sealed virtual void RegisterTaskSetupAction(Action`1<ITaskSetupContext> action);
    public sealed virtual void RegisterTaskSetupAction(Action`2<ITaskSetupContext, TData> action);
    public sealed virtual void RegisterTaskTeardownAction(Action`1<ITaskTeardownContext> action);
    public sealed virtual void RegisterTaskTeardownAction(Action`2<ITaskTeardownContext, TData> action);
    [AsyncStateMachineAttribute("Cake.Core.CakeEngine/<RunTargetAsync>d__39")]
public sealed virtual Task`1<CakeReport> RunTargetAsync(ICakeContext context, IExecutionStrategy strategy, ExecutionSettings settings);
    [AsyncStateMachineAttribute("Cake.Core.CakeEngine/<RunTarget>d__40")]
private Task RunTarget(ICakeContext context, IExecutionStrategy strategy, CakeTask[] orderedTasks, string target, bool exclusive, Stopwatch stopWatch, CakeReport report);
    [AsyncStateMachineAttribute("Cake.Core.CakeEngine/<RunTask>d__41")]
private Task RunTask(ICakeContext context, IExecutionStrategy strategy, CakeTask task, string target, Stopwatch stopWatch, CakeReport report);
    private void PerformSetup(ICakeContext context, IExecutionStrategy strategy, CakeTask[] orderedTasks, string target, Stopwatch stopWatch, CakeReport report);
    private static bool ShouldTaskExecute(ICakeContext context, CakeTask task, CakeTaskCriteria criteria, bool isTarget);
    [AsyncStateMachineAttribute("Cake.Core.CakeEngine/<ExecuteTaskAsync>d__44")]
private Task ExecuteTaskAsync(ICakeContext context, IExecutionStrategy strategy, Stopwatch stopWatch, CakeTask task, CakeReport report);
    private void PerformTaskSetup(ICakeContext context, IExecutionStrategy strategy, ICakeTaskInfo task, bool skipped);
    private void PerformTaskTeardown(ICakeContext context, IExecutionStrategy strategy, ICakeTaskInfo task, TimeSpan duration, bool skipped, Exception taskException);
    private void SkipTask(ICakeContext context, IExecutionStrategy strategy, CakeTask task, CakeReport report, CakeTaskCriteria criteria);
    private static bool IsDelegatedTask(CakeTask task);
    [AsyncStateMachineAttribute("Cake.Core.CakeEngine/<ReportErrorsAsync>d__49")]
private static Task ReportErrorsAsync(IExecutionStrategy strategy, Func`2<Exception, Task> errorReporter, Exception taskException);
    [AsyncStateMachineAttribute("Cake.Core.CakeEngine/<HandleErrorsAsync>d__50")]
private Task HandleErrorsAsync(IExecutionStrategy strategy, Func`3<Exception, ICakeContext, Task> errorHandler, Exception exception, ICakeContext context);
    private void PerformTeardown(IExecutionStrategy strategy, ICakeContext context, Stopwatch stopWatch, CakeReport report, bool exceptionWasThrown, Exception thrownException);
    private void ProcessTeardownExceptions(List`1<Exception> exceptions, bool exceptionWasThrown);
    private void PublishEvent(EventHandler`1<T> eventHandler, T eventArgs);
}
public class Cake.Core.CakeEngineActions : object {
    private ICakeDataService _data;
    private HashSet`1<Type> _dataTypes;
    private List`1<Action> _validations;
    [CompilerGeneratedAttribute]
private List`1<Action`1<ISetupContext>> <Setups>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Action`1<ITeardownContext>> <Teardowns>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ITaskSetupContext> <TaskSetup>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ITaskTeardownContext> <TaskTeardown>k__BackingField;
    public List`1<Action`1<ISetupContext>> Setups { get; }
    public List`1<Action`1<ITeardownContext>> Teardowns { get; }
    public Action`1<ITaskSetupContext> TaskSetup { get; private set; }
    public Action`1<ITaskTeardownContext> TaskTeardown { get; private set; }
    public CakeEngineActions(ICakeDataService data);
    [CompilerGeneratedAttribute]
public List`1<Action`1<ISetupContext>> get_Setups();
    [CompilerGeneratedAttribute]
public List`1<Action`1<ITeardownContext>> get_Teardowns();
    [CompilerGeneratedAttribute]
public Action`1<ITaskSetupContext> get_TaskSetup();
    [CompilerGeneratedAttribute]
private void set_TaskSetup(Action`1<ITaskSetupContext> value);
    [CompilerGeneratedAttribute]
public Action`1<ITaskTeardownContext> get_TaskTeardown();
    [CompilerGeneratedAttribute]
private void set_TaskTeardown(Action`1<ITaskTeardownContext> value);
    public void RegisterSetup(Action`1<ISetupContext> action);
    public void RegisterSetup(Func`2<ISetupContext, TData> action);
    public void RegisterTeardown(Action`1<ITeardownContext> action);
    public void RegisterTeardown(Action`2<ITeardownContext, TData> action);
    public void RegisterTaskSetup(Action`1<ITaskSetupContext> action);
    public void RegisterTaskSetup(Action`2<ITaskSetupContext, TData> action);
    public void RegisterTaskTeardown(Action`1<ITaskTeardownContext> action);
    public void RegisterTaskTeardown(Action`2<ITaskTeardownContext, TData> action);
    public void Validate();
    private static void EnsureNotRegistered(object value, string type);
    private void RegisterValidationOfDataType(string type);
}
public class Cake.Core.CakeEnvironment : object {
    [CompilerGeneratedAttribute]
private DirectoryPath <UserHomeDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryPath <ApplicationRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private ICakePlatform <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private ICakeRuntime <Runtime>k__BackingField;
    public DirectoryPath WorkingDirectory { get; public set; }
    public DirectoryPath UserHomeDirectory { get; }
    public DirectoryPath ApplicationRoot { get; }
    public ICakePlatform Platform { get; }
    public ICakeRuntime Runtime { get; }
    public CakeEnvironment(ICakePlatform platform, ICakeRuntime runtime);
    public sealed virtual DirectoryPath get_WorkingDirectory();
    public sealed virtual void set_WorkingDirectory(DirectoryPath value);
    [CompilerGeneratedAttribute]
public sealed virtual DirectoryPath get_UserHomeDirectory();
    [CompilerGeneratedAttribute]
public sealed virtual DirectoryPath get_ApplicationRoot();
    [CompilerGeneratedAttribute]
public sealed virtual ICakePlatform get_Platform();
    [CompilerGeneratedAttribute]
public sealed virtual ICakeRuntime get_Runtime();
    public sealed virtual DirectoryPath GetSpecialPath(SpecialPath path);
    public sealed virtual string GetEnvironmentVariable(string variable);
    public sealed virtual IDictionary`2<string, string> GetEnvironmentVariables();
    private static void SetWorkingDirectory(DirectoryPath path);
}
[ExtensionAttribute]
public static class Cake.Core.CakeEnvironmentExtensions : object {
    private static Regex _regex;
    private static CakeEnvironmentExtensions();
    [ExtensionAttribute]
public static string ExpandEnvironmentVariables(ICakeEnvironment environment, string text);
}
public class Cake.Core.CakeException : Exception {
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    public int ExitCode { get; }
    public CakeException(string message);
    public CakeException(string message, Exception innerException);
    public CakeException(int exitCode);
    public CakeException(int exitCode, string message);
    public CakeException(int exitCode, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_ExitCode();
}
public class Cake.Core.CakePlatform : object {
    [CompilerGeneratedAttribute]
private PlatformFamily <Family>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Is64Bit>k__BackingField;
    public PlatformFamily Family { get; }
    public bool Is64Bit { get; }
    [CompilerGeneratedAttribute]
public sealed virtual PlatformFamily get_Family();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Is64Bit();
}
[ExtensionAttribute]
public static class Cake.Core.CakePlatformExtensions : object {
    [ExtensionAttribute]
public static bool IsWindows(ICakePlatform platform);
    [ExtensionAttribute]
public static bool IsUnix(ICakePlatform platform);
    [ExtensionAttribute]
public static bool IsOSX(ICakePlatform platform);
    [ExtensionAttribute]
public static bool IsLinux(ICakePlatform platform);
}
public class Cake.Core.CakeReport : object {
    private List`1<CakeReportEntry> _report;
    public bool IsEmpty { get; }
    public bool get_IsEmpty();
    public void Add(string task, TimeSpan span);
    public void Add(string task, CakeReportEntryCategory category, TimeSpan span);
    public void AddSkipped(string task, string skippedMessage);
    public void AddFailed(string task, TimeSpan span);
    public void AddDelegated(string task, TimeSpan span);
    public void Add(string task, string skippedMessage, CakeReportEntryCategory category, TimeSpan span, CakeTaskExecutionStatus executionStatus);
    public sealed virtual IEnumerator`1<CakeReportEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Cake.Core.CakeReportEntry : object {
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SkippedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private CakeReportEntryCategory <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private CakeTaskExecutionStatus <ExecutionStatus>k__BackingField;
    public string TaskName { get; }
    public string SkippedMessage { get; }
    public CakeReportEntryCategory Category { get; }
    public TimeSpan Duration { get; }
    public CakeTaskExecutionStatus ExecutionStatus { get; }
    public CakeReportEntry(string taskName, string skippedMessage, CakeReportEntryCategory category, TimeSpan duration);
    public CakeReportEntry(string taskName, string skippedMessage, CakeReportEntryCategory category, TimeSpan duration, CakeTaskExecutionStatus executionStatus);
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public string get_SkippedMessage();
    [CompilerGeneratedAttribute]
public CakeReportEntryCategory get_Category();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public CakeTaskExecutionStatus get_ExecutionStatus();
}
public enum Cake.Core.CakeReportEntryCategory : Enum {
    public int value__;
    public static CakeReportEntryCategory Task;
    public static CakeReportEntryCategory Setup;
    public static CakeReportEntryCategory Teardown;
}
public class Cake.Core.CakeReportPrinter : object {
    private IConsole _console;
    private ICakeContext _context;
    public CakeReportPrinter(IConsole console, ICakeContext context);
    public sealed virtual void Write(CakeReport report);
    public sealed virtual void WriteStep(string name, Verbosity verbosity);
    public sealed virtual void WriteLifeCycleStep(string name, Verbosity verbosity);
    public sealed virtual void WriteSkippedStep(string name, Verbosity verbosity);
    private bool ShouldWriteTask(CakeReportEntry item);
    private string FormatDuration(CakeReportEntry item);
    private static ConsoleColor GetItemForegroundColor(CakeReportEntry item);
    private static string FormatTime(TimeSpan time);
    private static TimeSpan GetTotalTime(IEnumerable`1<CakeReportEntry> entries);
}
public class Cake.Core.CakeRuntime : object {
    [CompilerGeneratedAttribute]
private FrameworkName <BuiltFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private Runtime <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <CakeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCoreClr>k__BackingField;
    public FrameworkName BuiltFramework { get; }
    public Runtime Runtime { get; }
    public Version CakeVersion { get; }
    public bool IsCoreClr { get; }
    [CompilerGeneratedAttribute]
public sealed virtual FrameworkName get_BuiltFramework();
    [CompilerGeneratedAttribute]
public sealed virtual Runtime get_Runtime();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_CakeVersion();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCoreClr();
}
public class Cake.Core.CakeTask : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CakeTaskDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CakeTaskDependency> <Dependees>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CakeTaskCriteria> <Criterias>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<Exception, ICakeContext, Task> <ErrorHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Exception, Task> <ErrorReporter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ICakeContext, Task> <FinallyHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Func`2<ICakeContext, Task>> <Actions>k__BackingField;
    [CompilerGeneratedAttribute]
private Queue`1<Action`1<ICakeContext>> <DelayedActions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeferExceptions>k__BackingField;
    public string Name { get; }
    public string Description { get; public set; }
    public List`1<CakeTaskDependency> Dependencies { get; }
    public List`1<CakeTaskDependency> Dependees { get; }
    public List`1<CakeTaskCriteria> Criterias { get; }
    public Func`3<Exception, ICakeContext, Task> ErrorHandler { get; public set; }
    public Func`2<Exception, Task> ErrorReporter { get; public set; }
    public Func`2<ICakeContext, Task> FinallyHandler { get; public set; }
    public List`1<Func`2<ICakeContext, Task>> Actions { get; }
    public Queue`1<Action`1<ICakeContext>> DelayedActions { get; }
    public bool DeferExceptions { get; public set; }
    private IReadOnlyList`1<CakeTaskDependency> Cake.Core.ICakeTaskInfo.Dependencies { get; }
    private IReadOnlyList`1<CakeTaskDependency> Cake.Core.ICakeTaskInfo.Dependees { get; }
    public CakeTask(string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public List`1<CakeTaskDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public List`1<CakeTaskDependency> get_Dependees();
    [CompilerGeneratedAttribute]
public List`1<CakeTaskCriteria> get_Criterias();
    [CompilerGeneratedAttribute]
public Func`3<Exception, ICakeContext, Task> get_ErrorHandler();
    [CompilerGeneratedAttribute]
public void set_ErrorHandler(Func`3<Exception, ICakeContext, Task> value);
    [CompilerGeneratedAttribute]
public Func`2<Exception, Task> get_ErrorReporter();
    [CompilerGeneratedAttribute]
public void set_ErrorReporter(Func`2<Exception, Task> value);
    [CompilerGeneratedAttribute]
public Func`2<ICakeContext, Task> get_FinallyHandler();
    [CompilerGeneratedAttribute]
public void set_FinallyHandler(Func`2<ICakeContext, Task> value);
    [CompilerGeneratedAttribute]
public List`1<Func`2<ICakeContext, Task>> get_Actions();
    [CompilerGeneratedAttribute]
public Queue`1<Action`1<ICakeContext>> get_DelayedActions();
    [CompilerGeneratedAttribute]
public bool get_DeferExceptions();
    [CompilerGeneratedAttribute]
public void set_DeferExceptions(bool value);
    private sealed virtual override IReadOnlyList`1<CakeTaskDependency> Cake.Core.ICakeTaskInfo.get_Dependencies();
    private sealed virtual override IReadOnlyList`1<CakeTaskDependency> Cake.Core.ICakeTaskInfo.get_Dependees();
    [AsyncStateMachineAttribute("Cake.Core.CakeTask/<Execute>d__43")]
public Task Execute(ICakeContext context);
}
public class Cake.Core.CakeTaskBuilder : object {
    [CompilerGeneratedAttribute]
private CakeTask <Target>k__BackingField;
    public ICakeTaskInfo Task { get; }
    internal CakeTask Target { get; }
    public CakeTaskBuilder(CakeTask task);
    public ICakeTaskInfo get_Task();
    [CompilerGeneratedAttribute]
internal CakeTask get_Target();
}
public class Cake.Core.CakeTaskBuilder`1 : object {
    [CompilerGeneratedAttribute]
private CakeTaskBuilder <Builder>k__BackingField;
    public ICakeTaskInfo Task { get; }
    public CakeTaskBuilder Builder { get; }
    internal CakeTask Target { get; }
    public CakeTaskBuilder`1(CakeTaskBuilder builder);
    public CakeTaskBuilder`1(CakeTask task);
    public ICakeTaskInfo get_Task();
    [CompilerGeneratedAttribute]
public CakeTaskBuilder get_Builder();
    internal CakeTask get_Target();
}
[ExtensionAttribute]
public static class Cake.Core.CakeTaskBuilderExtensions : object {
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, bool criteria);
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, bool criteria, string message);
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, Func`1<bool> criteria);
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, Func`1<bool> criteria, string message);
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, Func`2<ICakeContext, bool> criteria);
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, Func`2<ICakeContext, bool> criteria, string message);
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, Func`2<TData, bool> criteria);
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, Func`2<TData, bool> criteria, string message);
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, Func`3<ICakeContext, TData, bool> criteria);
    [ExtensionAttribute]
public static CakeTaskBuilder WithCriteria(CakeTaskBuilder builder, Func`3<ICakeContext, TData, bool> criteria, string message);
    [ExtensionAttribute]
public static CakeTaskBuilder IsDependentOn(CakeTaskBuilder builder, string name);
    [ExtensionAttribute]
public static CakeTaskBuilder IsDependentOn(CakeTaskBuilder builder, CakeTaskBuilder other);
    [ExtensionAttribute]
public static CakeTaskBuilder IsDependeeOf(CakeTaskBuilder builder, string name);
    [ExtensionAttribute]
public static CakeTaskBuilder IsDependeeOf(CakeTaskBuilder builder, CakeTaskBuilder other);
    [ExtensionAttribute]
public static CakeTaskBuilder DeferOnError(CakeTaskBuilder builder);
    [ExtensionAttribute]
public static CakeTaskBuilder ContinueOnError(CakeTaskBuilder builder);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Action errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Func`1<Task> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Action`1<Exception> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Func`2<Exception, Task> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Action`2<Exception, ICakeContext> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Func`3<Exception, ICakeContext, Task> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Action`1<TData> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Func`2<TData, Task> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Action`2<Exception, TData> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Func`3<Exception, TData, Task> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Action`3<Exception, ICakeContext, TData> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder OnError(CakeTaskBuilder builder, Func`4<Exception, ICakeContext, TData, Task> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder Finally(CakeTaskBuilder builder, Action finallyHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder Finally(CakeTaskBuilder builder, Func`1<Task> finallyHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder Finally(CakeTaskBuilder builder, Action`1<ICakeContext> finallyHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder Finally(CakeTaskBuilder builder, Func`2<ICakeContext, Task> finallyHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder Finally(CakeTaskBuilder builder, Action`2<ICakeContext, TData> finallyHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder Finally(CakeTaskBuilder builder, Func`3<ICakeContext, TData, Task> finallyHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder ReportError(CakeTaskBuilder builder, Action`1<Exception> errorReporter);
    [ExtensionAttribute]
public static CakeTaskBuilder ReportError(CakeTaskBuilder builder, Func`2<Exception, Task> errorReporter);
    [ExtensionAttribute]
public static CakeTaskBuilder Does(CakeTaskBuilder builder, Action action);
    [ExtensionAttribute]
public static CakeTaskBuilder Does(CakeTaskBuilder builder, Action`1<TData> action);
    [ExtensionAttribute]
public static CakeTaskBuilder Does(CakeTaskBuilder builder, Func`1<Task> func);
    [ExtensionAttribute]
public static CakeTaskBuilder Does(CakeTaskBuilder builder, Action`1<ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder Does(CakeTaskBuilder builder, Func`2<ICakeContext, Task> func);
    [ExtensionAttribute]
public static CakeTaskBuilder Does(CakeTaskBuilder builder, Func`2<TData, Task> func);
    [ExtensionAttribute]
public static CakeTaskBuilder Does(CakeTaskBuilder builder, Action`2<ICakeContext, TData> action);
    [ExtensionAttribute]
public static CakeTaskBuilder Does(CakeTaskBuilder builder, Func`3<ICakeContext, TData, Task> func);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, IEnumerable`1<TItem> items, Action`1<TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, IEnumerable`1<TItem> items, Action`2<TData, TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, IEnumerable`1<TItem> items, Action`3<TData, TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, IEnumerable`1<TItem> items, Action`2<TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`1<IEnumerable`1<TItem>> itemsFunc, Action`1<TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`2<ICakeContext, IEnumerable`1<TItem>> itemsFunc, Action`1<TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`1<IEnumerable`1<TItem>> itemsFunc, Action`2<TData, TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`1<IEnumerable`1<TItem>> itemsFunc, Action`3<TData, TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`1<IEnumerable`1<TItem>> itemsFunc, Action`2<TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`2<ICakeContext, IEnumerable`1<TItem>> itemsFunc, Action`2<TData, TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`2<TData, IEnumerable`1<TItem>> itemsFunc, Action`3<TData, TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`2<ICakeContext, IEnumerable`1<TItem>> itemsFunc, Action`3<TData, TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`2<TData, IEnumerable`1<TItem>> itemsFunc, Action`2<TData, TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`2<TData, IEnumerable`1<TItem>> itemsFunc, Action`2<TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`2<TData, IEnumerable`1<TItem>> itemsFunc, Action`1<TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`3<TData, ICakeContext, IEnumerable`1<TItem>> itemsFunc, Action`3<TData, TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`3<TData, ICakeContext, IEnumerable`1<TItem>> itemsFunc, Action`2<TData, TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`3<TData, ICakeContext, IEnumerable`1<TItem>> itemsFunc, Action`2<TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`3<TData, ICakeContext, IEnumerable`1<TItem>> itemsFunc, Action`1<TItem> action);
    [ExtensionAttribute]
public static CakeTaskBuilder DoesForEach(CakeTaskBuilder builder, Func`2<ICakeContext, IEnumerable`1<TItem>> itemsFunc, Action`2<TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder Description(CakeTaskBuilder builder, string description);
}
[ExtensionAttribute]
public static class Cake.Core.CakeTaskBuilderOfTExtensions : object {
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> WithCriteria(CakeTaskBuilder`1<TData> builder, Func`3<ICakeContext, TData, bool> criteria);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> WithCriteria(CakeTaskBuilder`1<TData> builder, Func`3<ICakeContext, TData, bool> criteria, string message);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> IsDependeeOf(CakeTaskBuilder`1<TData> builder, string name);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> IsDependeeOf(CakeTaskBuilder`1<TData> builder, CakeTaskBuilder`1<TData> other);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> IsDependentOn(CakeTaskBuilder`1<TData> builder, string name);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> IsDependentOn(CakeTaskBuilder`1<TData> builder, CakeTaskBuilder`1<TData> other);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> IsDependentOn(CakeTaskBuilder`1<TData> builder, CakeTaskBuilder other);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> ContinueOnError(CakeTaskBuilder`1<TData> builder);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> DeferOnError(CakeTaskBuilder`1<TData> builder);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> OnError(CakeTaskBuilder`1<TData> builder, Action`3<Exception, ICakeContext, TData> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> ReportError(CakeTaskBuilder`1<TData> builder, Action`1<Exception> errorReporter);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> OnError(CakeTaskBuilder`1<TData> builder, Func`4<Exception, ICakeContext, TData, Task> errorHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> Finally(CakeTaskBuilder`1<TData> builder, Func`3<ICakeContext, TData, Task> finallyHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> Finally(CakeTaskBuilder`1<TData> builder, Action`2<ICakeContext, TData> finallyHandler);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> Does(CakeTaskBuilder`1<TData> builder, Action`2<ICakeContext, TData> action);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> Does(CakeTaskBuilder`1<TData> builder, Func`3<ICakeContext, TData, Task> action);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> DoesForEach(CakeTaskBuilder`1<TData> builder, Func`3<TData, ICakeContext, IEnumerable`1<TItem>> itemsFunc, Action`3<TData, TItem, ICakeContext> action);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> DoesForEach(CakeTaskBuilder`1<TData> builder, IEnumerable`1<TItem> items, Action`3<TData, TItem, ICakeContext> action);
    [ExtensionAttribute]
internal static CakeTaskBuilder`1<TData> Process(CakeTaskBuilder`1<TData> builder, Action`1<CakeTaskBuilder> action);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> Of(CakeTaskBuilder builder);
    [ExtensionAttribute]
public static CakeTaskBuilder`1<TData> Description(CakeTaskBuilder`1<TData> builder, string description);
}
public class Cake.Core.CakeTaskCriteria : object {
    [CompilerGeneratedAttribute]
private bool <CausedSkippingOfTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ICakeContext, bool> <Predicate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public bool CausedSkippingOfTask { get; public set; }
    public Func`2<ICakeContext, bool> Predicate { get; }
    public string Message { get; }
    public CakeTaskCriteria(Func`2<ICakeContext, bool> predicate, string message);
    [CompilerGeneratedAttribute]
public bool get_CausedSkippingOfTask();
    [CompilerGeneratedAttribute]
public void set_CausedSkippingOfTask(bool value);
    [CompilerGeneratedAttribute]
public Func`2<ICakeContext, bool> get_Predicate();
    [CompilerGeneratedAttribute]
public string get_Message();
}
public class Cake.Core.CakeTaskDependency : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public string Name { get; }
    public bool Required { get; }
    public CakeTaskDependency(string name, bool required);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Required();
}
public enum Cake.Core.CakeTaskExecutionStatus : Enum {
    public int value__;
    public static CakeTaskExecutionStatus Executed;
    public static CakeTaskExecutionStatus Delegated;
    public static CakeTaskExecutionStatus Skipped;
    public static CakeTaskExecutionStatus Failed;
}
[ExtensionAttribute]
public static class Cake.Core.CakeTaskExtensions : object {
    [ExtensionAttribute]
public static void AddDependency(CakeTask task, string name, bool required);
    [ExtensionAttribute]
public static void AddDependee(CakeTask task, string name, bool required);
    [ExtensionAttribute]
public static void AddCriteria(CakeTask task, Func`2<ICakeContext, bool> predicate, string message);
    [ExtensionAttribute]
public static void SetErrorHandler(CakeTask task, Action`2<Exception, ICakeContext> errorHandler);
    [ExtensionAttribute]
public static void SetErrorHandler(CakeTask task, Func`3<Exception, ICakeContext, Task> errorHandler);
    [ExtensionAttribute]
public static void SetErrorReporter(CakeTask task, Action`1<Exception> errorReporter);
    [ExtensionAttribute]
public static void SetErrorReporter(CakeTask task, Func`2<Exception, Task> errorReporter);
    [ExtensionAttribute]
public static void SetFinallyHandler(CakeTask task, Action finallyHandler);
    [ExtensionAttribute]
public static void SetFinallyHandler(CakeTask task, Func`1<Task> finallyHandler);
    [ExtensionAttribute]
public static void SetFinallyHandler(CakeTask task, Action`1<ICakeContext> finallyHandler);
    [ExtensionAttribute]
public static void SetFinallyHandler(CakeTask task, Func`2<ICakeContext, Task> finallyHandler);
    [ExtensionAttribute]
public static void AddAction(CakeTask task, Func`2<ICakeContext, Task> action);
    [ExtensionAttribute]
public static void AddDelayedAction(CakeTask task, Action`1<ICakeContext> action);
    [ExtensionAttribute]
public static void SetDeferExceptions(CakeTask task, bool value);
}
[ExtensionAttribute]
public static class Cake.Core.Composition.ContainerRegistrarExtensions : object {
    [ExtensionAttribute]
public static ICakeRegistrationBuilder RegisterType(ICakeContainerRegistrar registrar);
    [ExtensionAttribute]
public static ICakeRegistrationBuilder As(ICakeRegistrationBuilder builder);
}
public interface Cake.Core.Composition.ICakeContainerRegistrar {
    public abstract virtual ICakeRegistrationBuilder RegisterType(Type type);
    public abstract virtual ICakeRegistrationBuilder RegisterInstance(TImplementation instance);
}
public interface Cake.Core.Composition.ICakeModule {
    public abstract virtual void Register(ICakeContainerRegistrar registrar);
}
public interface Cake.Core.Composition.ICakeRegistrationBuilder {
    public abstract virtual ICakeRegistrationBuilder As(Type type);
    public abstract virtual ICakeRegistrationBuilder AsSelf();
    public abstract virtual ICakeRegistrationBuilder Singleton();
    public abstract virtual ICakeRegistrationBuilder Transient();
}
public class Cake.Core.Configuration.CakeConfiguration : object {
    private Dictionary`2<string, string> _lookup;
    public CakeConfiguration(IDictionary`2<string, string> lookup);
    public sealed virtual string GetValue(string key);
}
public class Cake.Core.Configuration.CakeConfigurationProvider : object {
    private IFileSystem _fileSystem;
    private ICakeEnvironment _environment;
    public CakeConfigurationProvider(IFileSystem fileSystem, ICakeEnvironment environment);
    public ICakeConfiguration CreateConfiguration(DirectoryPath path, IDictionary`2<string, string> arguments);
    public ICakeConfiguration CreateConfiguration(DirectoryPath path, IEnumerable`1<KeyValuePair`2<string, string>> baseConfiguration, IDictionary`2<string, string> arguments);
}
public interface Cake.Core.Configuration.ICakeConfiguration {
    public abstract virtual string GetValue(string key);
}
internal static class Cake.Core.Configuration.KeyNormalizer : object {
    public static string Normalize(string key);
}
internal class Cake.Core.Configuration.Parser.ConfigurationParser : object {
    private IFileSystem _fileSystem;
    private ICakeEnvironment _environment;
    public ConfigurationParser(IFileSystem fileSystem, ICakeEnvironment environment);
    public IDictionary`2<string, string> Read(FilePath path);
    private static IDictionary`2<string, string> Read(ICakeEnvironment environment, string text);
    private static string ParseSection(ConfigurationTokenStream tokens);
    private static KeyValuePair`2<string, string> ParseKeyAndValue(ConfigurationTokenStream tokens, string section);
    private static bool ContainsWhiteSpace(string text);
}
internal class Cake.Core.Configuration.Parser.ConfigurationToken : object {
    [CompilerGeneratedAttribute]
private ConfigurationTokenKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public ConfigurationTokenKind Kind { get; }
    public string Value { get; }
    public ConfigurationToken(ConfigurationTokenKind kind, string value);
    [CompilerGeneratedAttribute]
public ConfigurationTokenKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Value();
}
internal static class Cake.Core.Configuration.Parser.ConfigurationTokenizer : object {
    public static ConfigurationTokenStream Tokenize(string text);
    private static ConfigurationToken Tokenize(StringReader reader);
    private static void EatWhitespace(TextReader reader);
    private static void SkipComment(StringReader reader);
    private static ConfigurationToken ReadSection(StringReader reader);
    private static ConfigurationToken ReadValue(StringReader reader);
}
internal enum Cake.Core.Configuration.Parser.ConfigurationTokenKind : Enum {
    public int value__;
    public static ConfigurationTokenKind Section;
    public static ConfigurationTokenKind Value;
    public static ConfigurationTokenKind Equals;
}
[DefaultMemberAttribute("Item")]
internal class Cake.Core.Configuration.Parser.ConfigurationTokenStream : object {
    private List`1<ConfigurationToken> _tokens;
    private int _position;
    public ConfigurationToken Current { get; }
    public ConfigurationToken Item { get; }
    public int Count { get; }
    public ConfigurationTokenStream(IEnumerable`1<ConfigurationToken> tokens);
    public ConfigurationToken get_Current();
    public sealed virtual ConfigurationToken get_Item(int index);
    public sealed virtual int get_Count();
    public ConfigurationToken Peek();
    public ConfigurationToken Expect(ConfigurationTokenKind tokenType, string message);
    public ConfigurationToken Consume();
    public sealed virtual IEnumerator`1<ConfigurationToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class Cake.Core.ConsoleExtensions : object {
    [ExtensionAttribute]
public static void WriteLine(IConsole console);
    [ExtensionAttribute]
public static void WriteErrorLine(IConsole console);
}
internal static class Cake.Core.Constants : object {
    public static ConsoleColor DefaultConsoleColor;
    public static Version LatestBreakingChange;
    public static Version LatestPotentialBreakingChange;
    private static Constants();
}
public class Cake.Core.DefaultExecutionStrategy : object {
    private ICakeLog _log;
    private ICakeReportPrinter _reportPrinter;
    public DefaultExecutionStrategy(ICakeLog log, ICakeReportPrinter reportPrinter);
    public sealed virtual void PerformSetup(Action`1<ISetupContext> action, ISetupContext context);
    public sealed virtual void PerformTeardown(Action`1<ITeardownContext> action, ITeardownContext teardownContext);
    [AsyncStateMachineAttribute("Cake.Core.DefaultExecutionStrategy/<ExecuteAsync>d__5")]
public sealed virtual Task ExecuteAsync(CakeTask task, ICakeContext context);
    public sealed virtual void Skip(CakeTask task, CakeTaskCriteria criteria);
    [AsyncStateMachineAttribute("Cake.Core.DefaultExecutionStrategy/<ReportErrorsAsync>d__7")]
public sealed virtual Task ReportErrorsAsync(Func`2<Exception, Task> action, Exception exception);
    [AsyncStateMachineAttribute("Cake.Core.DefaultExecutionStrategy/<HandleErrorsAsync>d__8")]
public sealed virtual Task HandleErrorsAsync(Func`3<Exception, ICakeContext, Task> action, Exception exception, ICakeContext context);
    [AsyncStateMachineAttribute("Cake.Core.DefaultExecutionStrategy/<InvokeFinallyAsync>d__9")]
public sealed virtual Task InvokeFinallyAsync(Func`2<ICakeContext, Task> action, ICakeContext context);
    public sealed virtual void PerformTaskSetup(Action`1<ITaskSetupContext> action, ITaskSetupContext taskSetupContext);
    public sealed virtual void PerformTaskTeardown(Action`1<ITaskTeardownContext> action, ITaskTeardownContext taskTeardownContext);
}
internal class Cake.Core.Diagnostics.AnsiConsoleRenderer : object {
    private static string ResetEscapeCode;
    private IConsole _console;
    private IDictionary`2<LogLevel, ConsolePalette> _palette;
    private IDictionary`2<ConsoleColor, string> _ansiLookup;
    private IDictionary`2<ConsoleColor, string> _ansiBackgroundLookup;
    public AnsiConsoleRenderer(IConsole console);
    public sealed virtual void Render(LogLevel level, string format, Object[] args);
    private string GetColorEscapeCode(FormatToken token, ConsolePalette palette);
}
internal static class Cake.Core.Diagnostics.AnsiDetector : object {
    private static Regex[] _regexes;
    private static Regex _teamCityVersionWithAnsiSupportRegEx;
    private static AnsiDetector();
    public static bool SupportsAnsi(ICakeEnvironment environment);
}
public class Cake.Core.Diagnostics.CakeBuildLog : object {
    private IConsole _console;
    private object _lock;
    private IConsoleRenderer _renderer;
    [CompilerGeneratedAttribute]
private Verbosity <Verbosity>k__BackingField;
    public Verbosity Verbosity { get; public set; }
    public CakeBuildLog(IConsole console, Verbosity verbosity);
    [CompilerGeneratedAttribute]
public sealed virtual Verbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(Verbosity value);
    public sealed virtual void Write(Verbosity verbosity, LogLevel level, string format, Object[] args);
}
public class Cake.Core.Diagnostics.CakeDebugger : object {
    private ICakeLog _log;
    public CakeDebugger(ICakeLog log);
    public sealed virtual void WaitForAttach(TimeSpan timeout);
}
internal class Cake.Core.Diagnostics.ConsolePalette : object {
    [CompilerGeneratedAttribute]
private ConsoleColor <Background>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleColor <Foreground>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleColor <ArgumentBackground>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleColor <ArgumentForeground>k__BackingField;
    public ConsoleColor Background { get; public set; }
    public ConsoleColor Foreground { get; public set; }
    public ConsoleColor ArgumentBackground { get; public set; }
    public ConsoleColor ArgumentForeground { get; public set; }
    public ConsolePalette(ConsoleColor background, ConsoleColor foreground, ConsoleColor argumentBackground, ConsoleColor argumentForeground);
    [CompilerGeneratedAttribute]
public ConsoleColor get_Background();
    [CompilerGeneratedAttribute]
public void set_Background(ConsoleColor value);
    [CompilerGeneratedAttribute]
public ConsoleColor get_Foreground();
    [CompilerGeneratedAttribute]
public void set_Foreground(ConsoleColor value);
    [CompilerGeneratedAttribute]
public ConsoleColor get_ArgumentBackground();
    [CompilerGeneratedAttribute]
public void set_ArgumentBackground(ConsoleColor value);
    [CompilerGeneratedAttribute]
public ConsoleColor get_ArgumentForeground();
    [CompilerGeneratedAttribute]
public void set_ArgumentForeground(ConsoleColor value);
    public static IDictionary`2<LogLevel, ConsolePalette> CreateLookup(IConsole console);
}
internal class Cake.Core.Diagnostics.ConsoleRenderer : object {
    private IConsole _console;
    private IDictionary`2<LogLevel, ConsolePalette> _palette;
    public ConsoleRenderer(IConsole console);
    public sealed virtual void Render(LogLevel level, string format, Object[] args);
    private void SetPalette(FormatToken token, ConsolePalette palette, bool colorize);
}
internal class Cake.Core.Diagnostics.Formatting.CharReader : object {
    private Char[] chars;
    private int length;
    private int position;
    public CharReader(string s);
    public int Read();
    public int Peek();
    [IteratorStateMachineAttribute("Cake.Core.Diagnostics.Formatting.CharReader/<Peek>d__6")]
public IEnumerable`1<char> Peek(int count);
}
internal static class Cake.Core.Diagnostics.Formatting.FormatParser : object {
    [IteratorStateMachineAttribute("Cake.Core.Diagnostics.Formatting.FormatParser/<Parse>d__0")]
public static IEnumerable`1<FormatToken> Parse(string format);
    private static bool PeakTwo(CharReader reader, Char& character, Char& next);
    private static FormatToken ParseProperty(CharReader reader);
    private static FormatToken ParseText(CharReader reader);
    private static bool IsNumeric(string value);
}
internal abstract class Cake.Core.Diagnostics.Formatting.FormatToken : object {
    public abstract virtual string Render(Object[] args);
}
internal class Cake.Core.Diagnostics.Formatting.LiteralToken : FormatToken {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public LiteralToken(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    public virtual string Render(Object[] args);
}
internal class Cake.Core.Diagnostics.Formatting.PropertyToken : FormatToken {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public string Format { get; }
    public int Position { get; }
    public PropertyToken(int position, string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public int get_Position();
    public virtual string Render(Object[] args);
}
public interface Cake.Core.Diagnostics.ICakeDebugger {
    public abstract virtual void WaitForAttach(TimeSpan timeout);
}
public interface Cake.Core.Diagnostics.ICakeLog {
    public Verbosity Verbosity { get; public set; }
    public abstract virtual Verbosity get_Verbosity();
    public abstract virtual void set_Verbosity(Verbosity value);
    public abstract virtual void Write(Verbosity verbosity, LogLevel level, string format, Object[] args);
}
internal interface Cake.Core.Diagnostics.IConsoleRenderer {
    public abstract virtual void Render(LogLevel level, string format, Object[] args);
}
public class Cake.Core.Diagnostics.LogAction : MulticastDelegate {
    public LogAction(object object, IntPtr method);
    public virtual void Invoke(LogActionEntry actionEntry);
    public virtual IAsyncResult BeginInvoke(LogActionEntry actionEntry, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Cake.Core.Diagnostics.LogActionEntry : MulticastDelegate {
    public LogActionEntry(object object, IntPtr method);
    public virtual void Invoke(string format, Object[] args);
    public virtual IAsyncResult BeginInvoke(string format, Object[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class Cake.Core.Diagnostics.LogExtensions : object {
    [ExtensionAttribute]
public static void Error(ICakeLog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Error(ICakeLog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Error(ICakeLog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
public static void Error(ICakeLog log, LogAction logAction);
    [ExtensionAttribute]
public static void Error(ICakeLog log, object value);
    [ExtensionAttribute]
public static void Error(ICakeLog log, string value);
    [ExtensionAttribute]
public static void Warning(ICakeLog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Warning(ICakeLog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Warning(ICakeLog log, LogAction logAction);
    [ExtensionAttribute]
public static void Warning(ICakeLog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
public static void Warning(ICakeLog log, object value);
    [ExtensionAttribute]
public static void Warning(ICakeLog log, string value);
    [ExtensionAttribute]
public static void Information(ICakeLog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Information(ICakeLog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Information(ICakeLog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
public static void Information(ICakeLog log, LogAction logAction);
    [ExtensionAttribute]
public static void Information(ICakeLog log, object value);
    [ExtensionAttribute]
public static void Information(ICakeLog log, string value);
    [ExtensionAttribute]
public static void Verbose(ICakeLog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Verbose(ICakeLog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Verbose(ICakeLog log, LogAction logAction);
    [ExtensionAttribute]
public static void Verbose(ICakeLog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
public static void Verbose(ICakeLog log, object value);
    [ExtensionAttribute]
public static void Verbose(ICakeLog log, string value);
    [ExtensionAttribute]
public static void Debug(ICakeLog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Debug(ICakeLog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Debug(ICakeLog log, LogAction logAction);
    [ExtensionAttribute]
public static void Debug(ICakeLog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
public static void Debug(ICakeLog log, object value);
    [ExtensionAttribute]
public static void Debug(ICakeLog log, string value);
    [ExtensionAttribute]
public static void Write(ICakeLog log, Verbosity verbosity, LogLevel level, LogAction logAction);
    [ExtensionAttribute]
public static IDisposable QuietVerbosity(ICakeLog log);
    [ExtensionAttribute]
public static IDisposable MinimalVerbosity(ICakeLog log);
    [ExtensionAttribute]
public static IDisposable NormalVerbosity(ICakeLog log);
    [ExtensionAttribute]
public static IDisposable VerboseVerbosity(ICakeLog log);
    [ExtensionAttribute]
public static IDisposable DiagnosticVerbosity(ICakeLog log);
    [ExtensionAttribute]
public static IDisposable WithVerbosity(ICakeLog log, Verbosity verbosity);
}
public enum Cake.Core.Diagnostics.LogLevel : Enum {
    public int value__;
    public static LogLevel Fatal;
    public static LogLevel Error;
    public static LogLevel Warning;
    public static LogLevel Information;
    public static LogLevel Verbose;
    public static LogLevel Debug;
}
[CompilerGeneratedAttribute]
internal class Cake.Core.Diagnostics.NamespaceDoc : object {
}
public class Cake.Core.Diagnostics.NullLog : object {
    public Verbosity Verbosity { get; public set; }
    public sealed virtual Verbosity get_Verbosity();
    public sealed virtual void set_Verbosity(Verbosity value);
    public sealed virtual void Write(Verbosity verbosity, LogLevel level, string format, Object[] args);
}
public enum Cake.Core.Diagnostics.Verbosity : Enum {
    public int value__;
    public static Verbosity Quiet;
    public static Verbosity Minimal;
    public static Verbosity Normal;
    public static Verbosity Verbose;
    public static Verbosity Diagnostic;
}
[ExtensionAttribute]
public static class Cake.Core.DirectoryExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IDirectory> GetDirectories(IDirectory directory, string filter, SearchScope scope, Func`2<IFileSystemInfo, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<IDirectory> GetDirectories(IDirectory directory, string filter, SearchScope scope, Func`2<IFileSystemInfo, bool> predicate, Action`1<IFileSystemInfo> action);
    [ExtensionAttribute]
public static IEnumerable`1<IFile> GetFiles(IDirectory directory, string filter, SearchScope scope, Func`2<IFileSystemInfo, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<IFile> GetFiles(IDirectory directory, string filter, SearchScope scope, Func`2<IFileSystemInfo, bool> predicate, Action`1<IFileSystemInfo> action);
    private static bool Filter(IFileSystemInfo entry, Func`2<IFileSystemInfo, bool> wherePredicate, Action`1<IFileSystemInfo> predicateFiltered);
}
public static class Cake.Core.Disposable : object {
    public static IDisposable Empty;
    private static Disposable();
    public static IDisposable Create(Action disposer);
}
[ExtensionAttribute]
public static class Cake.Core.EnumerableStringExtensions : object {
    [ExtensionAttribute]
public static ProcessArgumentBuilder ToProcessArguments(IEnumerable`1<string> values);
    [ExtensionAttribute]
public static ProcessArgumentBuilder ToProcessArgumentsQuoted(IEnumerable`1<string> values);
}
public class Cake.Core.ExecutionSettings : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclusive>k__BackingField;
    public IEnumerable`1<string> Targets { get; private set; }
    public bool Exclusive { get; private set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Targets();
    [CompilerGeneratedAttribute]
private void set_Targets(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_Exclusive();
    [CompilerGeneratedAttribute]
private void set_Exclusive(bool value);
    public ExecutionSettings SetTarget(string target);
    public ExecutionSettings SetTargets(IEnumerable`1<string> targets);
    public ExecutionSettings UseExclusiveTarget();
}
public class Cake.Core.Graph.CakeGraph : object {
    private List`1<string> _nodes;
    private List`1<CakeGraphEdge> _edges;
    public IReadOnlyList`1<string> Nodes { get; }
    public IReadOnlyList`1<CakeGraphEdge> Edges { get; }
    public IReadOnlyList`1<string> get_Nodes();
    public IReadOnlyList`1<CakeGraphEdge> get_Edges();
    public void Add(string node);
    public void Connect(string start, string end);
    public bool Exist(string name);
    public IEnumerable`1<string> Traverse(string target);
    private void Traverse(string node, ICollection`1<string> result, ISet`1<string> visited);
}
public static class Cake.Core.Graph.CakeGraphBuilder : object {
    public static CakeGraph Build(IReadOnlyCollection`1<ICakeTaskInfo> tasks);
}
public class Cake.Core.Graph.CakeGraphEdge : object {
    [CompilerGeneratedAttribute]
private string <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private string <End>k__BackingField;
    public string Start { get; }
    public string End { get; }
    public CakeGraphEdge(string start, string end);
    [CompilerGeneratedAttribute]
public string get_Start();
    [CompilerGeneratedAttribute]
public string get_End();
}
[ExtensionAttribute]
internal static class Cake.Core.HashSetExtensions : object {
    [ExtensionAttribute]
public static void AddRange(HashSet`1<T> set, IEnumerable`1<T> items);
}
public interface Cake.Core.ICakeArguments {
    public abstract virtual bool HasArgument(string name);
    public abstract virtual ICollection`1<string> GetArguments(string name);
    public abstract virtual IDictionary`2<string, ICollection`1<string>> GetArguments();
}
public interface Cake.Core.ICakeContext {
    public IFileSystem FileSystem { get; }
    public ICakeEnvironment Environment { get; }
    public IGlobber Globber { get; }
    public ICakeLog Log { get; }
    public ICakeArguments Arguments { get; }
    public IProcessRunner ProcessRunner { get; }
    public IRegistry Registry { get; }
    public IToolLocator Tools { get; }
    public ICakeDataResolver Data { get; }
    public ICakeConfiguration Configuration { get; }
    public abstract virtual IFileSystem get_FileSystem();
    public abstract virtual ICakeEnvironment get_Environment();
    public abstract virtual IGlobber get_Globber();
    public abstract virtual ICakeLog get_Log();
    public abstract virtual ICakeArguments get_Arguments();
    public abstract virtual IProcessRunner get_ProcessRunner();
    public abstract virtual IRegistry get_Registry();
    public abstract virtual IToolLocator get_Tools();
    public abstract virtual ICakeDataResolver get_Data();
    public abstract virtual ICakeConfiguration get_Configuration();
}
public interface Cake.Core.ICakeDataResolver {
    public abstract virtual TData Get();
}
public interface Cake.Core.ICakeDataService {
    public abstract virtual void Add(TData value);
}
public interface Cake.Core.ICakeEngine {
    public IReadOnlyList`1<ICakeTaskInfo> Tasks { get; }
    public abstract virtual IReadOnlyList`1<ICakeTaskInfo> get_Tasks();
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeSetup(EventHandler`1<BeforeSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeSetup(EventHandler`1<BeforeSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterSetup(EventHandler`1<AfterSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterSetup(EventHandler`1<AfterSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeTeardown(EventHandler`1<BeforeTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeTeardown(EventHandler`1<BeforeTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterTeardown(EventHandler`1<AfterTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterTeardown(EventHandler`1<AfterTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeTaskSetup(EventHandler`1<BeforeTaskSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeTaskSetup(EventHandler`1<BeforeTaskSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterTaskSetup(EventHandler`1<AfterTaskSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterTaskSetup(EventHandler`1<AfterTaskSetupEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeTaskTeardown(EventHandler`1<BeforeTaskTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeTaskTeardown(EventHandler`1<BeforeTaskTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterTaskTeardown(EventHandler`1<AfterTaskTeardownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterTaskTeardown(EventHandler`1<AfterTaskTeardownEventArgs> value);
    public abstract virtual CakeTaskBuilder RegisterTask(string name);
    public abstract virtual void RegisterSetupAction(Action`1<ISetupContext> action);
    public abstract virtual void RegisterSetupAction(Func`2<ISetupContext, TData> action);
    public abstract virtual void RegisterTeardownAction(Action`1<ITeardownContext> action);
    public abstract virtual void RegisterTeardownAction(Action`2<ITeardownContext, TData> action);
    public abstract virtual Task`1<CakeReport> RunTargetAsync(ICakeContext context, IExecutionStrategy strategy, ExecutionSettings settings);
    public abstract virtual void RegisterTaskSetupAction(Action`1<ITaskSetupContext> action);
    public abstract virtual void RegisterTaskSetupAction(Action`2<ITaskSetupContext, TData> action);
    public abstract virtual void RegisterTaskTeardownAction(Action`1<ITaskTeardownContext> action);
    public abstract virtual void RegisterTaskTeardownAction(Action`2<ITaskTeardownContext, TData> action);
}
public interface Cake.Core.ICakeEnvironment {
    public DirectoryPath WorkingDirectory { get; public set; }
    public DirectoryPath UserHomeDirectory { get; }
    public DirectoryPath ApplicationRoot { get; }
    public ICakePlatform Platform { get; }
    public ICakeRuntime Runtime { get; }
    public abstract virtual DirectoryPath get_WorkingDirectory();
    public abstract virtual void set_WorkingDirectory(DirectoryPath value);
    public virtual DirectoryPath get_UserHomeDirectory();
    public abstract virtual DirectoryPath get_ApplicationRoot();
    public abstract virtual DirectoryPath GetSpecialPath(SpecialPath path);
    public abstract virtual string GetEnvironmentVariable(string variable);
    public abstract virtual IDictionary`2<string, string> GetEnvironmentVariables();
    public abstract virtual ICakePlatform get_Platform();
    public abstract virtual ICakeRuntime get_Runtime();
}
public interface Cake.Core.ICakePlatform {
    public PlatformFamily Family { get; }
    public bool Is64Bit { get; }
    public abstract virtual PlatformFamily get_Family();
    public abstract virtual bool get_Is64Bit();
}
public interface Cake.Core.ICakeReportPrinter {
    public abstract virtual void Write(CakeReport report);
    public abstract virtual void WriteLifeCycleStep(string name, Verbosity verbosity);
    public abstract virtual void WriteStep(string name, Verbosity verbosity);
    public abstract virtual void WriteSkippedStep(string name, Verbosity verbosity);
}
public interface Cake.Core.ICakeRuntime {
    public FrameworkName BuiltFramework { get; }
    public Runtime Runtime { get; }
    public Version CakeVersion { get; }
    public bool IsCoreClr { get; }
    public abstract virtual FrameworkName get_BuiltFramework();
    public abstract virtual Runtime get_Runtime();
    public abstract virtual Version get_CakeVersion();
    public abstract virtual bool get_IsCoreClr();
}
public interface Cake.Core.ICakeTaskInfo {
    public string Name { get; }
    public string Description { get; }
    public IReadOnlyList`1<CakeTaskDependency> Dependencies { get; }
    public IReadOnlyList`1<CakeTaskDependency> Dependees { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Description();
    public abstract virtual IReadOnlyList`1<CakeTaskDependency> get_Dependencies();
    public abstract virtual IReadOnlyList`1<CakeTaskDependency> get_Dependees();
}
public interface Cake.Core.IConsole {
    public ConsoleColor ForegroundColor { get; public set; }
    public ConsoleColor BackgroundColor { get; public set; }
    public bool SupportAnsiEscapeCodes { get; }
    public abstract virtual ConsoleColor get_ForegroundColor();
    public abstract virtual void set_ForegroundColor(ConsoleColor value);
    public abstract virtual ConsoleColor get_BackgroundColor();
    public abstract virtual void set_BackgroundColor(ConsoleColor value);
    public abstract virtual bool get_SupportAnsiEscapeCodes();
    public abstract virtual void Write(string format, Object[] arg);
    public abstract virtual void WriteLine(string format, Object[] arg);
    public abstract virtual void WriteError(string format, Object[] arg);
    public abstract virtual void WriteErrorLine(string format, Object[] arg);
    public abstract virtual void ResetColor();
}
public interface Cake.Core.IExecutionStrategy {
    public abstract virtual void PerformSetup(Action`1<ISetupContext> action, ISetupContext context);
    public abstract virtual void PerformTeardown(Action`1<ITeardownContext> action, ITeardownContext teardownContext);
    public abstract virtual Task ExecuteAsync(CakeTask task, ICakeContext context);
    public abstract virtual void Skip(CakeTask task, CakeTaskCriteria criteria);
    public abstract virtual Task ReportErrorsAsync(Func`2<Exception, Task> action, Exception exception);
    public abstract virtual Task HandleErrorsAsync(Func`3<Exception, ICakeContext, Task> action, Exception exception, ICakeContext context);
    public abstract virtual Task InvokeFinallyAsync(Func`2<ICakeContext, Task> action, ICakeContext context);
    public abstract virtual void PerformTaskSetup(Action`1<ITaskSetupContext> action, ITaskSetupContext taskSetupContext);
    public abstract virtual void PerformTaskTeardown(Action`1<ITaskTeardownContext> action, ITaskTeardownContext taskTeardownContext);
}
[CompilerGeneratedAttribute]
internal class Cake.Core.IO.Arguments.NamespaceDoc : object {
}
public class Cake.Core.IO.Arguments.QuotedArgument : object {
    private IProcessArgument _argument;
    public QuotedArgument(IProcessArgument argument);
    public sealed virtual string Render();
    public sealed virtual string RenderSafe();
    public virtual string ToString();
}
public class Cake.Core.IO.Arguments.SecretArgument : object {
    private IProcessArgument _argument;
    public SecretArgument(IProcessArgument argument);
    public sealed virtual string Render();
    public sealed virtual string RenderSafe();
    public virtual string ToString();
}
public class Cake.Core.IO.Arguments.SwitchArgument : object {
    private string _switch;
    private IProcessArgument _argument;
    private string _separator;
    public SwitchArgument(string switch, IProcessArgument argument, string separator);
    public sealed virtual string Render();
    public sealed virtual string RenderSafe();
    public virtual string ToString();
}
public class Cake.Core.IO.Arguments.TextArgument : object {
    private string _text;
    public TextArgument(string text);
    public sealed virtual string Render();
    public sealed virtual string RenderSafe();
    public virtual string ToString();
}
internal class Cake.Core.IO.ConsoleMode : object {
    private static int STD_OUTPUT_HANDLE;
    private Nullable`1<UInt32> _previousConsoleMode;
    [CompilerGeneratedAttribute]
private static ConsoleMode <None>k__BackingField;
    public static ConsoleMode None { get; }
    public ConsoleMode(UInt32 consoleMode);
    private static ConsoleMode();
    [CompilerGeneratedAttribute]
public static ConsoleMode get_None();
    public static ConsoleMode GetCurrent(ICakeEnvironment environment);
    public void Reset();
    private static IntPtr GetStdHandle(int nStdHandle);
    private static bool GetConsoleMode(IntPtr hConsoleHandle, UInt32& lpMode);
    private static bool SetConsoleMode(IntPtr hConsoleHandle, UInt32 dwMode);
}
internal class Cake.Core.IO.Directory : object {
    private DirectoryInfo _directory;
    [CompilerGeneratedAttribute]
private DirectoryPath <Path>k__BackingField;
    public DirectoryPath Path { get; }
    private Path Cake.Core.IO.IFileSystemInfo.Path { get; }
    public bool Exists { get; }
    public bool Hidden { get; }
    public DateTime LastWriteTime { get; }
    public Directory(DirectoryPath path);
    [CompilerGeneratedAttribute]
public sealed virtual DirectoryPath get_Path();
    private sealed virtual override Path Cake.Core.IO.IFileSystemInfo.get_Path();
    public sealed virtual bool get_Exists();
    public sealed virtual bool get_Hidden();
    public DateTime get_LastWriteTime();
    public sealed virtual void Create();
    public sealed virtual void Move(DirectoryPath destination);
    public sealed virtual void Delete(bool recursive);
    public sealed virtual IEnumerable`1<IDirectory> GetDirectories(string filter, SearchScope scope);
    public sealed virtual IEnumerable`1<IFile> GetFiles(string filter, SearchScope scope);
}
[TypeConverterAttribute("Cake.Core.IO.DirectoryPathConverter")]
public class Cake.Core.IO.DirectoryPath : Path {
    public DirectoryPath(string path);
    public string GetDirectoryName();
    public FilePath GetFilePath(FilePath path);
    public DirectoryPath GetParent();
    public FilePath CombineWithFilePath(FilePath path);
    public DirectoryPath Combine(DirectoryPath path);
    public sealed virtual DirectoryPath MakeAbsolute(DirectoryPath path);
    public sealed virtual DirectoryPath MakeAbsolute(ICakeEnvironment environment);
    public sealed virtual DirectoryPath Collapse();
    public static DirectoryPath op_Implicit(string path);
    public static DirectoryPath FromString(string path);
    public sealed virtual DirectoryPath GetRelativePath(DirectoryPath to);
    public FilePath GetRelativePath(FilePath to);
    public sealed virtual bool Equals(DirectoryPath other);
    public virtual bool Equals(object other);
    public static bool op_Equality(DirectoryPath directoryPath, DirectoryPath otherDirectoryPath);
    public static bool op_Inequality(DirectoryPath directoryPath, DirectoryPath otherDirectoryPath);
    public virtual int GetHashCode();
    public sealed virtual int Compare(DirectoryPath x, DirectoryPath y);
}
public class Cake.Core.IO.DirectoryPathCollection : object {
    private HashSet`1<DirectoryPath> _paths;
    [CompilerGeneratedAttribute]
private PathComparer <Comparer>k__BackingField;
    public int Count { get; }
    internal PathComparer Comparer { get; }
    public DirectoryPathCollection(PathComparer comparer);
    public DirectoryPathCollection(IEnumerable`1<DirectoryPath> paths);
    public DirectoryPathCollection(IEnumerable`1<DirectoryPath> paths, PathComparer comparer);
    public int get_Count();
    [CompilerGeneratedAttribute]
internal PathComparer get_Comparer();
    public bool Add(DirectoryPath path);
    public void Add(IEnumerable`1<DirectoryPath> paths);
    public bool Remove(DirectoryPath path);
    public void Remove(IEnumerable`1<DirectoryPath> paths);
    public static DirectoryPathCollection op_Addition(DirectoryPathCollection collection, DirectoryPath path);
    public static DirectoryPathCollection op_Addition(DirectoryPathCollection collection, IEnumerable`1<DirectoryPath> paths);
    public static DirectoryPathCollection op_Subtraction(DirectoryPathCollection collection, DirectoryPath path);
    public static DirectoryPathCollection op_Subtraction(DirectoryPathCollection collection, IEnumerable`1<DirectoryPath> paths);
    public sealed virtual IEnumerator`1<DirectoryPath> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Cake.Core.IO.DirectoryPathConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class Cake.Core.IO.File : object {
    private FileInfo _file;
    [CompilerGeneratedAttribute]
private FilePath <Path>k__BackingField;
    public FilePath Path { get; }
    private Path Cake.Core.IO.IFileSystemInfo.Path { get; }
    public bool Exists { get; }
    public bool Hidden { get; }
    public DateTime LastWriteTime { get; }
    public long Length { get; }
    public FileAttributes Attributes { get; public set; }
    public File(FilePath path);
    [CompilerGeneratedAttribute]
public sealed virtual FilePath get_Path();
    private sealed virtual override Path Cake.Core.IO.IFileSystemInfo.get_Path();
    public sealed virtual bool get_Exists();
    public sealed virtual bool get_Hidden();
    public DateTime get_LastWriteTime();
    public sealed virtual long get_Length();
    public sealed virtual FileAttributes get_Attributes();
    public sealed virtual void set_Attributes(FileAttributes value);
    public sealed virtual void Copy(FilePath destination, bool overwrite);
    public sealed virtual void Move(FilePath destination);
    public sealed virtual void Delete();
    public sealed virtual Stream Open(FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    public sealed virtual IFile SetCreationTime(DateTime creationTime);
    public sealed virtual IFile SetCreationTimeUtc(DateTime creationTimeUtc);
    public sealed virtual IFile SetLastAccessTime(DateTime lastAccessTime);
    public sealed virtual IFile SetLastAccessTimeUtc(DateTime lastAccessTimeUtc);
    public sealed virtual IFile SetLastWriteTime(DateTime lastWriteTime);
    public sealed virtual IFile SetLastWriteTimeUtc(DateTime lastWriteTimeUtc);
}
[ExtensionAttribute]
public static class Cake.Core.IO.FileExtensions : object {
    [ExtensionAttribute]
public static Stream Open(IFile file, FileMode mode);
    [ExtensionAttribute]
public static Stream Open(IFile file, FileMode mode, FileAccess access);
    [ExtensionAttribute]
public static Stream OpenRead(IFile file);
    [ExtensionAttribute]
public static Stream OpenWrite(IFile file);
    [ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(IFile file, Encoding encoding);
    [ExtensionAttribute]
public static bool IsClrAssembly(IFile file);
}
[TypeConverterAttribute("Cake.Core.IO.FilePathConverter")]
public class Cake.Core.IO.FilePath : Path {
    public bool HasExtension { get; }
    public FilePath(string path);
    public bool get_HasExtension();
    public DirectoryPath GetDirectory();
    public FilePath GetFilename();
    public FilePath GetFilenameWithoutExtension();
    public string GetExtension();
    public FilePath ChangeExtension(string extension);
    public FilePath AppendExtension(string extension);
    public sealed virtual FilePath MakeAbsolute(ICakeEnvironment environment);
    public sealed virtual FilePath MakeAbsolute(DirectoryPath path);
    public sealed virtual FilePath Collapse();
    public static FilePath op_Implicit(string path);
    public static FilePath FromString(string path);
    public DirectoryPath GetRelativePath(DirectoryPath to);
    public sealed virtual FilePath GetRelativePath(FilePath to);
    public sealed virtual bool Equals(FilePath other);
    public virtual bool Equals(object other);
    public static bool op_Equality(FilePath filePath, FilePath otherFilePath);
    public static bool op_Inequality(FilePath filePath, FilePath otherFilePath);
    public virtual int GetHashCode();
    public sealed virtual int Compare(FilePath x, FilePath y);
}
public class Cake.Core.IO.FilePathCollection : object {
    private HashSet`1<FilePath> _paths;
    [CompilerGeneratedAttribute]
private PathComparer <Comparer>k__BackingField;
    public int Count { get; }
    internal PathComparer Comparer { get; }
    public FilePathCollection(PathComparer comparer);
    public FilePathCollection(IEnumerable`1<FilePath> paths);
    public FilePathCollection(IEnumerable`1<FilePath> paths, PathComparer comparer);
    public int get_Count();
    [CompilerGeneratedAttribute]
internal PathComparer get_Comparer();
    public bool Add(FilePath path);
    public void Add(IEnumerable`1<FilePath> paths);
    public bool Remove(FilePath path);
    public void Remove(IEnumerable`1<FilePath> paths);
    public static FilePathCollection op_Addition(FilePathCollection collection, FilePath path);
    public static FilePathCollection op_Addition(FilePathCollection collection, IEnumerable`1<FilePath> paths);
    public static FilePathCollection op_Subtraction(FilePathCollection collection, FilePath path);
    public static FilePathCollection op_Subtraction(FilePathCollection collection, IEnumerable`1<FilePath> paths);
    public sealed virtual IEnumerator`1<FilePath> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Cake.Core.IO.FilePathConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class Cake.Core.IO.FileSystem : object {
    public sealed virtual IFile GetFile(FilePath path);
    public sealed virtual IDirectory GetDirectory(DirectoryPath path);
}
[ExtensionAttribute]
public static class Cake.Core.IO.FileSystemExtensions : object {
    [ExtensionAttribute]
public static bool Exist(IFileSystem fileSystem, FilePath path);
    [ExtensionAttribute]
public static bool Exist(IFileSystem fileSystem, DirectoryPath path);
}
public class Cake.Core.IO.Globber : object {
    private GlobParser _parser;
    private GlobVisitor _visitor;
    private PathComparer _comparer;
    private ICakeEnvironment _environment;
    public Globber(IFileSystem fileSystem, ICakeEnvironment environment);
    public sealed virtual IEnumerable`1<Path> Match(GlobPattern pattern, GlobberSettings settings);
}
[ExtensionAttribute]
public static class Cake.Core.IO.GlobberExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<FilePath> GetFiles(IGlobber globber, GlobPattern pattern);
    [ExtensionAttribute]
public static IEnumerable`1<DirectoryPath> GetDirectories(IGlobber globber, GlobPattern pattern);
    [ExtensionAttribute]
public static IEnumerable`1<Path> Match(IGlobber globber, GlobPattern pattern);
    [ExtensionAttribute]
public static IEnumerable`1<FilePath> GetFiles(IGlobber globber, string pattern);
    [ExtensionAttribute]
public static IEnumerable`1<DirectoryPath> GetDirectories(IGlobber globber, string pattern);
    [ExtensionAttribute]
public static IEnumerable`1<Path> Match(IGlobber globber, string pattern);
}
public class Cake.Core.IO.GlobberSettings : object {
    [CompilerGeneratedAttribute]
private Func`2<IDirectory, bool> <Predicate>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IFile, bool> <FilePredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsCaseSensitive>k__BackingField;
    public Func`2<IDirectory, bool> Predicate { get; public set; }
    public Func`2<IFile, bool> FilePredicate { get; public set; }
    public Nullable`1<bool> IsCaseSensitive { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<IDirectory, bool> get_Predicate();
    [CompilerGeneratedAttribute]
public void set_Predicate(Func`2<IDirectory, bool> value);
    [CompilerGeneratedAttribute]
public Func`2<IFile, bool> get_FilePredicate();
    [CompilerGeneratedAttribute]
public void set_FilePredicate(Func`2<IFile, bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public void set_IsCaseSensitive(Nullable`1<bool> value);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
internal abstract class Cake.Core.IO.Globbing.GlobNode : object {
    [CompilerGeneratedAttribute]
private GlobNode <Next>k__BackingField;
    public GlobNode Next { get; internal set; }
    [CompilerGeneratedAttribute]
public GlobNode get_Next();
    [CompilerGeneratedAttribute]
internal void set_Next(GlobNode value);
    public abstract virtual void Accept(GlobVisitor visitor, GlobVisitorContext context);
}
internal static class Cake.Core.IO.Globbing.GlobNodeRewriter : object {
    public static GlobNode Rewrite(GlobPattern pattern, IEnumerable`1<GlobNode> nodes);
    private static GlobNode RewriteUncRoot(GlobPattern pattern, GlobNode root);
    private static GlobNode CreateLinkedList(IEnumerable`1<GlobNode> nodes);
    [IteratorStateMachineAttribute("Cake.Core.IO.Globbing.GlobNodeRewriter/<RewriteSingleWildcards>d__3")]
private static IEnumerable`1<GlobNode> RewriteSingleWildcards(IEnumerable`1<GlobNode> nodes);
}
internal static class Cake.Core.IO.Globbing.GlobNodeValidator : object {
    public static void Validate(GlobPattern pattern, GlobNode node);
}
internal class Cake.Core.IO.Globbing.GlobParser : object {
    private ICakeEnvironment _environment;
    public GlobParser(ICakeEnvironment environment);
    public GlobNode Parse(GlobPattern pattern, GlobberSettings settings);
    private GlobNode Parse(GlobParserContext context);
    private GlobNode ParseRoot(GlobParserContext context);
    private static GlobNode ParseNode(GlobParserContext context);
    private static PathSegment ParsePathSegment(GlobParserContext context);
    private static PathSegment ParseText(GlobParserContext context);
    private static PathSegment ParseWildcard(GlobParserContext context);
    private static PathSegment ParseBracketWildcard(GlobParserContext context);
    private static BraceExpansionSegment ParseBraceExpansion(GlobParserContext context);
}
internal class Cake.Core.IO.Globbing.GlobParserContext : object {
    private GlobTokenBuffer _buffer;
    [CompilerGeneratedAttribute]
private GlobPattern <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private GlobToken <CurrentToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexOptions <Options>k__BackingField;
    public GlobPattern Pattern { get; }
    public int TokenCount { get; }
    public GlobToken CurrentToken { get; private set; }
    public RegexOptions Options { get; }
    public GlobParserContext(GlobPattern pattern, GlobTokenBuffer buffer, bool caseSensitive);
    [CompilerGeneratedAttribute]
public GlobPattern get_Pattern();
    public int get_TokenCount();
    [CompilerGeneratedAttribute]
public GlobToken get_CurrentToken();
    [CompilerGeneratedAttribute]
private void set_CurrentToken(GlobToken value);
    [CompilerGeneratedAttribute]
public RegexOptions get_Options();
    public GlobToken Peek();
    public GlobToken Accept();
    public GlobToken Accept(GlobTokenKind[] kind);
    [CompilerGeneratedAttribute]
private bool <Accept>b__16_0(GlobTokenKind k);
}
[DebuggerDisplayAttribute("{Value,nq} ({Kind,nq})")]
internal class Cake.Core.IO.Globbing.GlobToken : object {
    [CompilerGeneratedAttribute]
private GlobTokenKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public GlobTokenKind Kind { get; }
    public string Value { get; }
    public GlobToken(GlobTokenKind kind, string value);
    [CompilerGeneratedAttribute]
public GlobTokenKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Value();
}
internal class Cake.Core.IO.Globbing.GlobTokenBuffer : object {
    private Queue`1<GlobToken> _tokens;
    public int Count { get; }
    public GlobTokenBuffer(IEnumerable`1<GlobToken> tokens);
    public int get_Count();
    public GlobToken Peek();
    public GlobToken Read();
}
internal static class Cake.Core.IO.Globbing.GlobTokenizer : object {
    public static GlobTokenBuffer Tokenize(GlobPattern input);
    private static GlobTokenBuffer Tokenize(StringReader reader);
    private static GlobToken ReadToken(StringReader reader);
    private static GlobToken ReadScope(StringReader reader, GlobTokenKind kind, char first, char last);
}
internal enum Cake.Core.IO.Globbing.GlobTokenKind : Enum {
    public int value__;
    public static GlobTokenKind Wildcard;
    public static GlobTokenKind CharacterWildcard;
    public static GlobTokenKind PathSeparator;
    public static GlobTokenKind Text;
    public static GlobTokenKind WindowsRoot;
    public static GlobTokenKind Parent;
    public static GlobTokenKind Current;
    public static GlobTokenKind BracketWildcard;
    public static GlobTokenKind BraceExpansion;
}
internal class Cake.Core.IO.Globbing.GlobVisitor : object {
    private IFileSystem _fileSystem;
    private ICakeEnvironment _environment;
    public GlobVisitor(IFileSystem fileSystem, ICakeEnvironment environment);
    public IEnumerable`1<IFileSystemInfo> Walk(GlobNode node, GlobberSettings settings);
    public void VisitRecursiveWildcardSegment(RecursiveWildcardNode node, GlobVisitorContext context);
    public void VisitRelativeRoot(RelativeRootNode node, GlobVisitorContext context);
    public void VisitSegment(PathNode node, GlobVisitorContext context);
    public void VisitUnixRoot(UnixRootNode node, GlobVisitorContext context);
    public void VisitUncRoot(UncRootNode node, GlobVisitorContext context);
    public void VisitWildcardSegmentNode(WildcardNode node, GlobVisitorContext context);
    public void VisitWindowsRoot(WindowsRootNode node, GlobVisitorContext context);
    public void VisitParent(ParentDirectoryNode node, GlobVisitorContext context);
    public void VisitCurrent(CurrentDirectoryNode node, GlobVisitorContext context);
    private static IEnumerable`1<IFileSystemInfo> FindCandidates(DirectoryPath path, MatchableNode node, GlobVisitorContext context, SearchScope option, bool includeFiles, bool includeDirectories);
}
internal class Cake.Core.IO.Globbing.GlobVisitorContext : object {
    private List`1<string> _pathParts;
    private Func`2<IDirectory, bool> _directoryPredicate;
    private Func`2<IFile, bool> _filePredicate;
    [CompilerGeneratedAttribute]
private DirectoryPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private ICakeEnvironment <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IFileSystemInfo> <Results>k__BackingField;
    internal DirectoryPath Path { get; private set; }
    public IFileSystem FileSystem { get; }
    public ICakeEnvironment Environment { get; }
    public List`1<IFileSystemInfo> Results { get; }
    public GlobVisitorContext(IFileSystem fileSystem, ICakeEnvironment environment, Func`2<IDirectory, bool> directoryPredicate, Func`2<IFile, bool> filePredicate);
    [CompilerGeneratedAttribute]
internal DirectoryPath get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(DirectoryPath value);
    [CompilerGeneratedAttribute]
public IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
public ICakeEnvironment get_Environment();
    [CompilerGeneratedAttribute]
public List`1<IFileSystemInfo> get_Results();
    public void AddResult(IFileSystemInfo path);
    public void Push(string path);
    public string Pop();
    private DirectoryPath GenerateFullPath();
    public bool ShouldTraverse(IDirectory info);
    public bool ShouldInclude(IFile file);
}
[DebuggerDisplayAttribute(".")]
internal class Cake.Core.IO.Globbing.Nodes.CurrentDirectoryNode : GlobNode {
    [DebuggerStepThroughAttribute]
public virtual void Accept(GlobVisitor visitor, GlobVisitorContext context);
}
internal abstract class Cake.Core.IO.Globbing.Nodes.MatchableNode : GlobNode {
    public abstract virtual bool IsMatch(string value);
}
[DebuggerDisplayAttribute("..")]
internal class Cake.Core.IO.Globbing.Nodes.ParentDirectoryNode : GlobNode {
    [DebuggerStepThroughAttribute]
public virtual void Accept(GlobVisitor visitor, GlobVisitorContext context);
}
[DebuggerDisplayAttribute("{GetPath(),nq}")]
internal class Cake.Core.IO.Globbing.Nodes.PathNode : MatchableNode {
    private Regex _regex;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PathSegment> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIdentifier>k__BackingField;
    public IReadOnlyList`1<PathSegment> Segments { get; }
    public bool IsIdentifier { get; }
    public PathNode(List`1<PathSegment> tokens, RegexOptions options);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PathSegment> get_Segments();
    [CompilerGeneratedAttribute]
public bool get_IsIdentifier();
    public virtual bool IsMatch(string value);
    public string GetPath();
    [DebuggerStepThroughAttribute]
public virtual void Accept(GlobVisitor globber, GlobVisitorContext context);
    private static Regex CreateRegex(List`1<PathSegment> tokens, RegexOptions options);
}
[DebuggerDisplayAttribute("**")]
internal class Cake.Core.IO.Globbing.Nodes.RecursiveWildcardNode : MatchableNode {
    [DebuggerStepThroughAttribute]
public virtual void Accept(GlobVisitor globber, GlobVisitorContext context);
    public virtual bool IsMatch(string value);
}
[DebuggerDisplayAttribute("./")]
internal class Cake.Core.IO.Globbing.Nodes.RelativeRootNode : GlobNode {
    [DebuggerStepThroughAttribute]
public virtual void Accept(GlobVisitor globber, GlobVisitorContext context);
}
internal class Cake.Core.IO.Globbing.Nodes.Segments.BraceExpansionSegment : PathSegment {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Regex>k__BackingField;
    public string Value { get; }
    public string Regex { get; }
    public BraceExpansionSegment(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Value();
    [CompilerGeneratedAttribute]
public virtual string get_Regex();
}
internal class Cake.Core.IO.Globbing.Nodes.Segments.BracketWildcardSegment : PathSegment {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public string Regex { get; }
    public BracketWildcardSegment(string content);
    [CompilerGeneratedAttribute]
public virtual string get_Value();
    public virtual string get_Regex();
}
internal class Cake.Core.IO.Globbing.Nodes.Segments.CharacterWildcardSegment : PathSegment {
    public string Value { get; }
    public string Regex { get; }
    public virtual string get_Value();
    public virtual string get_Regex();
}
internal abstract class Cake.Core.IO.Globbing.Nodes.Segments.PathSegment : object {
    public string Regex { get; }
    public string Value { get; }
    public abstract virtual string get_Regex();
    public abstract virtual string get_Value();
}
internal class Cake.Core.IO.Globbing.Nodes.Segments.TextSegment : PathSegment {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Regex>k__BackingField;
    public string Value { get; }
    public string Regex { get; }
    public TextSegment(string text);
    [CompilerGeneratedAttribute]
public virtual string get_Value();
    [CompilerGeneratedAttribute]
public virtual string get_Regex();
}
internal class Cake.Core.IO.Globbing.Nodes.Segments.WildcardSegment : PathSegment {
    public string Value { get; }
    public string Regex { get; }
    public virtual string get_Value();
    public virtual string get_Regex();
}
[DebuggerDisplayAttribute("\\")]
internal class Cake.Core.IO.Globbing.Nodes.UncRootNode : GlobNode {
    [CompilerGeneratedAttribute]
private string <Server>k__BackingField;
    public string Server { get; }
    public UncRootNode(string server);
    [CompilerGeneratedAttribute]
public string get_Server();
    [DebuggerStepThroughAttribute]
public virtual void Accept(GlobVisitor visitor, GlobVisitorContext context);
}
[DebuggerDisplayAttribute("/")]
internal class Cake.Core.IO.Globbing.Nodes.UnixRootNode : GlobNode {
    [DebuggerStepThroughAttribute]
public virtual void Accept(GlobVisitor visitor, GlobVisitorContext context);
}
[DebuggerDisplayAttribute("*")]
internal class Cake.Core.IO.Globbing.Nodes.WildcardNode : MatchableNode {
    [DebuggerStepThroughAttribute]
public virtual void Accept(GlobVisitor visitor, GlobVisitorContext context);
    public virtual bool IsMatch(string value);
}
[DebuggerDisplayAttribute("{Drive,nq}:")]
internal class Cake.Core.IO.Globbing.Nodes.WindowsRootNode : GlobNode {
    [CompilerGeneratedAttribute]
private string <Drive>k__BackingField;
    public string Drive { get; }
    public WindowsRootNode(string drive);
    [CompilerGeneratedAttribute]
public string get_Drive();
    [DebuggerStepThroughAttribute]
public virtual void Accept(GlobVisitor visitor, GlobVisitorContext context);
}
public class Cake.Core.IO.GlobPattern : object {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public string Pattern { get; }
    public GlobPattern(string pattern);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    public static GlobPattern op_Implicit(string pattern);
    public static string op_Implicit(GlobPattern pattern);
    public static GlobPattern FromString(string pattern);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public interface Cake.Core.IO.IDirectory {
    public DirectoryPath Path { get; }
    public abstract virtual DirectoryPath get_Path();
    public abstract virtual void Create();
    public abstract virtual void Move(DirectoryPath destination);
    public abstract virtual void Delete(bool recursive);
    public abstract virtual IEnumerable`1<IDirectory> GetDirectories(string filter, SearchScope scope);
    public abstract virtual IEnumerable`1<IFile> GetFiles(string filter, SearchScope scope);
}
public interface Cake.Core.IO.IFile {
    public FilePath Path { get; }
    public long Length { get; }
    public FileAttributes Attributes { get; public set; }
    public abstract virtual FilePath get_Path();
    public abstract virtual long get_Length();
    public abstract virtual FileAttributes get_Attributes();
    public abstract virtual void set_Attributes(FileAttributes value);
    public abstract virtual void Copy(FilePath destination, bool overwrite);
    public abstract virtual void Move(FilePath destination);
    public abstract virtual void Delete();
    public abstract virtual Stream Open(FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    public virtual IFile SetCreationTime(DateTime creationTime);
    public virtual IFile SetCreationTimeUtc(DateTime creationTimeUtc);
    public virtual IFile SetLastAccessTime(DateTime lastAccessTime);
    public virtual IFile SetLastAccessTimeUtc(DateTime lastAccessTimeUtc);
    public virtual IFile SetLastWriteTime(DateTime lastWriteTime);
    public virtual IFile SetLastWriteTimeUtc(DateTime lastWriteTimeUtc);
}
public interface Cake.Core.IO.IFileSystem {
    public abstract virtual IFile GetFile(FilePath path);
    public abstract virtual IDirectory GetDirectory(DirectoryPath path);
}
public interface Cake.Core.IO.IFileSystemInfo {
    public Path Path { get; }
    public bool Exists { get; }
    public bool Hidden { get; }
    public abstract virtual Path get_Path();
    public abstract virtual bool get_Exists();
    public abstract virtual bool get_Hidden();
}
public interface Cake.Core.IO.IGlobber {
    public abstract virtual IEnumerable`1<Path> Match(GlobPattern pattern, GlobberSettings settings);
}
public interface Cake.Core.IO.IPath`1 {
    public string FullPath { get; }
    public bool IsRelative { get; }
    public bool IsUNC { get; }
    public char Separator { get; }
    public String[] Segments { get; }
    public abstract virtual string get_FullPath();
    public abstract virtual bool get_IsRelative();
    public abstract virtual bool get_IsUNC();
    public abstract virtual char get_Separator();
    public abstract virtual String[] get_Segments();
    public abstract virtual string ToString();
    public abstract virtual T MakeAbsolute(ICakeEnvironment environment);
    public abstract virtual T MakeAbsolute(DirectoryPath path);
    public abstract virtual T Collapse();
    public abstract virtual T GetRelativePath(T to);
}
public interface Cake.Core.IO.IProcess {
    public abstract virtual void WaitForExit();
    public abstract virtual bool WaitForExit(int milliseconds);
    public abstract virtual int GetExitCode();
    public abstract virtual IEnumerable`1<string> GetStandardError();
    public abstract virtual IEnumerable`1<string> GetStandardOutput();
    public abstract virtual void Kill();
}
public interface Cake.Core.IO.IProcessArgument {
    public abstract virtual string Render();
    public abstract virtual string RenderSafe();
}
public interface Cake.Core.IO.IProcessRunner {
    public abstract virtual IProcess Start(FilePath filePath, ProcessSettings settings);
}
public interface Cake.Core.IO.IRegistry {
    public IRegistryKey CurrentUser { get; }
    public IRegistryKey LocalMachine { get; }
    public IRegistryKey ClassesRoot { get; }
    public IRegistryKey Users { get; }
    public IRegistryKey PerformanceData { get; }
    public IRegistryKey CurrentConfig { get; }
    public abstract virtual IRegistryKey get_CurrentUser();
    public abstract virtual IRegistryKey get_LocalMachine();
    public abstract virtual IRegistryKey get_ClassesRoot();
    public abstract virtual IRegistryKey get_Users();
    public abstract virtual IRegistryKey get_PerformanceData();
    public abstract virtual IRegistryKey get_CurrentConfig();
}
public interface Cake.Core.IO.IRegistryKey {
    public abstract virtual String[] GetSubKeyNames();
    public abstract virtual IRegistryKey OpenKey(string name);
    public abstract virtual object GetValue(string name);
}
[CompilerGeneratedAttribute]
internal class Cake.Core.IO.NamespaceDoc : object {
}
public interface Cake.Core.IO.NuGet.INuGetToolResolver {
    public abstract virtual FilePath ResolvePath();
}
[CompilerGeneratedAttribute]
internal class Cake.Core.IO.NuGet.NamespaceDoc : object {
}
public class Cake.Core.IO.NuGet.NuGetToolResolver : object {
    private IFileSystem _fileSystem;
    private ICakeEnvironment _environment;
    private IToolLocator _tools;
    private IFile _cachedPath;
    private static FilePath[] _unixSystemPaths;
    private static NuGetToolResolver();
    public NuGetToolResolver(IFileSystem fileSystem, ICakeEnvironment environment, IToolLocator tools);
    public sealed virtual FilePath ResolvePath();
}
public abstract class Cake.Core.IO.Path : object {
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRelative>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUNC>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Segments>k__BackingField;
    public string FullPath { get; }
    public bool IsRelative { get; }
    public bool IsUNC { get; }
    public char Separator { get; }
    public String[] Segments { get; }
    protected Path(string path);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullPath();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRelative();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUNC();
    [CompilerGeneratedAttribute]
public sealed virtual char get_Separator();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Segments();
    public virtual string ToString();
}
internal static class Cake.Core.IO.PathCollapser : object {
    public static string Collapse(Path path);
}
public class Cake.Core.IO.PathCollection : object {
    private HashSet`1<Path> _paths;
    [CompilerGeneratedAttribute]
private PathComparer <Comparer>k__BackingField;
    public int Count { get; }
    internal PathComparer Comparer { get; }
    public PathCollection(PathComparer comparer);
    public PathCollection(IEnumerable`1<Path> paths);
    public PathCollection(IEnumerable`1<Path> paths, PathComparer comparer);
    public int get_Count();
    [CompilerGeneratedAttribute]
internal PathComparer get_Comparer();
    public bool Add(Path path);
    public void Add(IEnumerable`1<Path> paths);
    public bool Remove(Path path);
    public void Remove(IEnumerable`1<Path> paths);
    public static PathCollection op_Addition(PathCollection collection, Path path);
    public static PathCollection op_Addition(PathCollection collection, IEnumerable`1<Path> paths);
    public static PathCollection op_Subtraction(PathCollection collection, Path path);
    public static PathCollection op_Subtraction(PathCollection collection, IEnumerable`1<Path> paths);
    public sealed virtual IEnumerator`1<Path> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Cake.Core.IO.PathComparer : object {
    public static PathComparer Default;
    private StringComparer _stringComparer;
    [CompilerGeneratedAttribute]
private bool <IsCaseSensitive>k__BackingField;
    public bool IsCaseSensitive { get; }
    private static PathComparer();
    public PathComparer(bool isCaseSensitive);
    public PathComparer(ICakeEnvironment environment);
    [CompilerGeneratedAttribute]
public bool get_IsCaseSensitive();
    public sealed virtual bool Equals(Path x, Path y);
    public sealed virtual int GetHashCode(Path obj);
    public sealed virtual int Compare(Path x, Path y);
}
[ExtensionAttribute]
public static class Cake.Core.IO.PathExtensions : object {
    [ExtensionAttribute]
public static FilePath ExpandEnvironmentVariables(FilePath path, ICakeEnvironment environment);
    [ExtensionAttribute]
public static DirectoryPath ExpandEnvironmentVariables(DirectoryPath path, ICakeEnvironment environment);
}
internal static class Cake.Core.IO.PathHelper : object {
    private static char Backslash;
    private static char Slash;
    private static string UncPrefix;
    private static bool _isWindows;
    private static PathHelper();
    public static string Combine(String[] paths);
    public static string Combine(string first, string second);
    public static bool HasExtension(FilePath path);
    public static string GetDirectoryName(FilePath path);
    public static string GetFileName(FilePath path);
    public static string GetFileNameWithoutExtension(FilePath path);
    public static string ChangeExtension(FilePath path, string extension);
    public static string RemoveExtension(FilePath path);
    public static bool IsPathRooted(string path);
}
public class Cake.Core.IO.ProcessArgumentBuilder : object {
    private List`1<IProcessArgument> _tokens;
    public int Count { get; }
    public sealed virtual int get_Count();
    public void Clear();
    public void Append(IProcessArgument argument);
    public void Prepend(IProcessArgument argument);
    public void AppendRange(IEnumerable`1<IProcessArgument> arguments);
    public void PrependRange(IEnumerable`1<IProcessArgument> arguments);
    public string Render();
    public string RenderSafe();
    public string FilterUnsafe(string source);
    public static ProcessArgumentBuilder op_Implicit(string value);
    public static ProcessArgumentBuilder FromString(string value);
    public static ProcessArgumentBuilder FromStringQuoted(string value);
    public static ProcessArgumentBuilder FromStrings(IEnumerable`1<string> values);
    public static ProcessArgumentBuilder FromStringsQuoted(IEnumerable`1<string> values);
    private sealed virtual override IEnumerator`1<IProcessArgument> System.Collections.Generic.IEnumerable<Cake.Core.IO.IProcessArgument>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Cake.Core.IO.ProcessRunner : object {
    private IFileSystem _fileSystem;
    private ICakeEnvironment _environment;
    private ICakeLog _log;
    private IToolLocator _tools;
    private ICakeConfiguration _configuration;
    private bool _noMonoCoersion;
    private bool _showCommandLine;
    public ProcessRunner(IFileSystem fileSystem, ICakeEnvironment environment, ICakeLog log, IToolLocator tools, ICakeConfiguration configuration);
    public sealed virtual IProcess Start(FilePath filePath, ProcessSettings settings);
    internal ProcessStartInfo GetProcessStartInfo(FilePath filePath, ProcessSettings settings, Func`2& filterUnsafe);
    private static void SubscribeStandardError(Process process, ProcessWrapper processWrapper);
    private static void SubscribeStandardOutput(Process process, ProcessWrapper processWrapper);
}
public class Cake.Core.IO.ProcessSettings : object {
    [CompilerGeneratedAttribute]
private ProcessArgumentBuilder <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryPath <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RedirectStandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RedirectStandardOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, string> <RedirectedStandardErrorHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, string> <RedirectedStandardOutputHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Silent>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <EnvironmentVariables>k__BackingField;
    public ProcessArgumentBuilder Arguments { get; public set; }
    public DirectoryPath WorkingDirectory { get; public set; }
    public bool NoWorkingDirectory { get; public set; }
    public bool RedirectStandardError { get; public set; }
    public bool RedirectStandardOutput { get; public set; }
    public Func`2<string, string> RedirectedStandardErrorHandler { get; public set; }
    public Func`2<string, string> RedirectedStandardOutputHandler { get; public set; }
    public Nullable`1<int> Timeout { get; public set; }
    public bool Silent { get; public set; }
    public IDictionary`2<string, string> EnvironmentVariables { get; public set; }
    [CompilerGeneratedAttribute]
public ProcessArgumentBuilder get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(ProcessArgumentBuilder value);
    [CompilerGeneratedAttribute]
public DirectoryPath get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(DirectoryPath value);
    [CompilerGeneratedAttribute]
public bool get_NoWorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_NoWorkingDirectory(bool value);
    [CompilerGeneratedAttribute]
public bool get_RedirectStandardError();
    [CompilerGeneratedAttribute]
public void set_RedirectStandardError(bool value);
    [CompilerGeneratedAttribute]
public bool get_RedirectStandardOutput();
    [CompilerGeneratedAttribute]
public void set_RedirectStandardOutput(bool value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_RedirectedStandardErrorHandler();
    [CompilerGeneratedAttribute]
public void set_RedirectedStandardErrorHandler(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_RedirectedStandardOutputHandler();
    [CompilerGeneratedAttribute]
public void set_RedirectedStandardOutputHandler(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_Silent();
    [CompilerGeneratedAttribute]
public void set_Silent(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(IDictionary`2<string, string> value);
}
internal class Cake.Core.IO.ProcessWrapper : object {
    private Process _process;
    private ICakeLog _log;
    private Func`2<string, string> _filterError;
    private Func`2<string, string> _filterOutput;
    private ConcurrentQueue`1<string> _consoleErrorQueue;
    private ConcurrentQueue`1<string> _consoleOutputQueue;
    private Func`2<string, string> _standardOutputHandler;
    private Func`2<string, string> _standardErrorHandler;
    public ProcessWrapper(Process process, ICakeLog log, Func`2<string, string> filterOutput, Func`2<string, string> standardOutputHandler, Func`2<string, string> filterError, Func`2<string, string> standardErrorHandler);
    public sealed virtual void WaitForExit();
    public sealed virtual bool WaitForExit(int milliseconds);
    public sealed virtual int GetExitCode();
    internal void StandardErrorReceived(string standardError);
    [IteratorStateMachineAttribute("Cake.Core.IO.ProcessWrapper/<GetStandardError>d__13")]
public sealed virtual IEnumerable`1<string> GetStandardError();
    internal void StandardOutputReceived(string standardOutput);
    [IteratorStateMachineAttribute("Cake.Core.IO.ProcessWrapper/<GetStandardOutput>d__15")]
public sealed virtual IEnumerable`1<string> GetStandardOutput();
    public sealed virtual void Kill();
    public sealed virtual void Dispose();
}
internal static class Cake.Core.IO.RelativePathResolver : object {
    public static DirectoryPath Resolve(DirectoryPath from, DirectoryPath to);
}
public enum Cake.Core.IO.SearchScope : Enum {
    public int value__;
    public static SearchScope Current;
    public static SearchScope Recursive;
}
public enum Cake.Core.IO.SpecialPath : Enum {
    public int value__;
    public static SpecialPath ApplicationData;
    public static SpecialPath CommonApplicationData;
    public static SpecialPath LocalApplicationData;
    public static SpecialPath ProgramFiles;
    public static SpecialPath ProgramFilesX86;
    public static SpecialPath Windows;
    public static SpecialPath LocalTemp;
    public static SpecialPath UserProfile;
}
public class Cake.Core.IO.WindowsRegistry : object {
    public IRegistryKey CurrentUser { get; }
    public IRegistryKey LocalMachine { get; }
    public IRegistryKey ClassesRoot { get; }
    public IRegistryKey Users { get; }
    public IRegistryKey PerformanceData { get; }
    public IRegistryKey CurrentConfig { get; }
    public sealed virtual IRegistryKey get_CurrentUser();
    public sealed virtual IRegistryKey get_LocalMachine();
    public sealed virtual IRegistryKey get_ClassesRoot();
    public sealed virtual IRegistryKey get_Users();
    public sealed virtual IRegistryKey get_PerformanceData();
    public sealed virtual IRegistryKey get_CurrentConfig();
}
internal class Cake.Core.IO.WindowsRegistryKey : object {
    private RegistryKey _key;
    private bool _disposed;
    public WindowsRegistryKey(RegistryKey key);
    public sealed virtual void Dispose();
    public sealed virtual String[] GetSubKeyNames();
    public sealed virtual IRegistryKey OpenKey(string name);
    public sealed virtual object GetValue(string name);
}
public interface Cake.Core.ISetupContext {
    public ICakeTaskInfo TargetTask { get; }
    public IReadOnlyCollection`1<ICakeTaskInfo> TasksToExecute { get; }
    public abstract virtual ICakeTaskInfo get_TargetTask();
    public abstract virtual IReadOnlyCollection`1<ICakeTaskInfo> get_TasksToExecute();
}
public interface Cake.Core.ITaskSetupContext {
    public ICakeTaskInfo Task { get; }
    public abstract virtual ICakeTaskInfo get_Task();
}
public interface Cake.Core.ITaskTeardownContext {
    public ICakeTaskInfo Task { get; }
    public TimeSpan Duration { get; }
    public bool Skipped { get; }
    public bool Successful { get; }
    public Exception ThrownException { get; }
    public abstract virtual ICakeTaskInfo get_Task();
    public abstract virtual TimeSpan get_Duration();
    public abstract virtual bool get_Skipped();
    public abstract virtual bool get_Successful();
    public abstract virtual Exception get_ThrownException();
}
public interface Cake.Core.ITeardownContext {
    public bool Successful { get; }
    public Exception ThrownException { get; }
    public abstract virtual bool get_Successful();
    public abstract virtual Exception get_ThrownException();
}
[ExtensionAttribute]
public static class Cake.Core.MethodInfoExtensions : object {
    [ExtensionAttribute]
public static string GetSignature(MethodInfo method, bool includeMethodNamespace, bool includeParameterNamespace);
    [ExtensionAttribute]
public static string GetFullName(MethodInfo method);
    [ExtensionAttribute]
public static string GetNamespace(MethodInfo method);
}
public class Cake.Core.Modules.CoreModule : object {
    public sealed virtual void Register(ICakeContainerRegistrar registrar);
}
[CompilerGeneratedAttribute]
internal class Cake.Core.NamespaceDoc : object {
}
public interface Cake.Core.Packaging.IPackageInstaller {
    public abstract virtual bool CanInstall(PackageReference package, PackageType type);
    public abstract virtual IReadOnlyCollection`1<IFile> Install(PackageReference package, PackageType type, DirectoryPath path);
}
public class Cake.Core.Packaging.PackageReference : object {
    [CompilerGeneratedAttribute]
private string <OriginalString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Package>k__BackingField;
    public string OriginalString { get; }
    public string Scheme { get; }
    public Uri Address { get; }
    public IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> Parameters { get; }
    public string Package { get; }
    public PackageReference(string uri);
    public PackageReference(Uri uri);
    [CompilerGeneratedAttribute]
public string get_OriginalString();
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public Uri get_Address();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> get_Parameters();
    [CompilerGeneratedAttribute]
public string get_Package();
}
public enum Cake.Core.Packaging.PackageType : Enum {
    public int value__;
    public static PackageType Unspecified;
    public static PackageType Addin;
    public static PackageType Tool;
    public static PackageType Module;
}
public enum Cake.Core.PlatformFamily : Enum {
    public int value__;
    public static PlatformFamily Unknown;
    public static PlatformFamily Windows;
    public static PlatformFamily Linux;
    public static PlatformFamily OSX;
}
internal static class Cake.Core.Polyfill.AssemblyHelper : object {
    private static int RTLD_NOW;
    private static string dlopen;
    private static bool _useLoadUnixLibrary1;
    private static bool _useLoadUnixLibrary2;
    private static bool _useLoadMacOsLibrary;
    public static Assembly GetExecutingAssembly();
    public static Assembly LoadAssembly(AssemblyName assemblyName);
    public static Assembly LoadAssembly(ICakeEnvironment environment, IFileSystem fileSystem, ICakeLog log, FilePath path);
    private static void LogNativeLoad(ICakeLog log, string loadUnixLibrary, FilePath path);
    private static IntPtr LoadUnixLibrary1(string path, int flags);
    private static IntPtr LoadUnixLibrary2(string path, int flags);
    private static IntPtr LoadMacOSLibrary(string path, int flags);
    private static IntPtr LoadWindowsLibrary(string path);
    private static void LoadUnixLibrary(Func`3<string, int, IntPtr> dlOpen, FilePath path);
    private static bool TryLoadUnixLibrary(Func`3<string, int, IntPtr> dlOpen, FilePath path, Boolean& result);
}
internal static class Cake.Core.Polyfill.EnvironmentHelper : object {
    private static FrameworkName NetStandardFramework;
    private static Nullable`1<bool> _isCoreClr;
    private static FrameworkName netCoreAppFramwork;
    private static EnvironmentHelper();
    public static bool Is64BitOperativeSystem();
    public static PlatformFamily GetPlatformFamily();
    public static bool IsCoreClr();
    public static bool IsWindows(PlatformFamily family);
    public static bool IsUnix();
    public static bool IsUnix(PlatformFamily family);
    public static bool IsOSX(PlatformFamily family);
    public static bool IsLinux(PlatformFamily family);
    public static Runtime GetRuntime();
    public static FrameworkName GetBuiltFramework();
}
internal static class Cake.Core.Polyfill.Native : object {
}
internal static class Cake.Core.Polyfill.ProcessHelper : object {
    public static void SetEnvironmentVariable(ProcessStartInfo info, string key, string value);
}
public enum Cake.Core.Polyfill.Runtime : Enum {
    public int value__;
    public static Runtime Clr;
    public static Runtime CoreClr;
}
internal static class Cake.Core.Polyfill.SpecialPathHelper : object {
    public static DirectoryPath GetFolderPath(ICakePlatform platform, SpecialPath path);
    private static string GetXPlatFolderPath(ICakePlatform platform, SpecialPath path);
}
[ExtensionAttribute]
public static class Cake.Core.ProcessArgumentListExtensions : object {
    [ExtensionAttribute]
public static ProcessArgumentBuilder Append(ProcessArgumentBuilder builder, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder Prepend(ProcessArgumentBuilder builder, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder Append(ProcessArgumentBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static ProcessArgumentBuilder Prepend(ProcessArgumentBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendQuoted(ProcessArgumentBuilder builder, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependQuoted(ProcessArgumentBuilder builder, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendQuoted(ProcessArgumentBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependQuoted(ProcessArgumentBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendQuoted(ProcessArgumentBuilder builder, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependQuoted(ProcessArgumentBuilder builder, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSecret(ProcessArgumentBuilder builder, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSecret(ProcessArgumentBuilder builder, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSecret(ProcessArgumentBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSecret(ProcessArgumentBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSecret(ProcessArgumentBuilder builder, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSecret(ProcessArgumentBuilder builder, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendQuotedSecret(ProcessArgumentBuilder builder, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependQuotedSecret(ProcessArgumentBuilder builder, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendQuotedSecret(ProcessArgumentBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependQuotedSecret(ProcessArgumentBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendQuotedSecret(ProcessArgumentBuilder builder, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependQuotedSecret(ProcessArgumentBuilder builder, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitch(ProcessArgumentBuilder builder, string switch, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitch(ProcessArgumentBuilder builder, string switch, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitch(ProcessArgumentBuilder builder, string switch, string separator, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitch(ProcessArgumentBuilder builder, string switch, string separator, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchQuoted(ProcessArgumentBuilder builder, string switch, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchQuoted(ProcessArgumentBuilder builder, string switch, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchQuoted(ProcessArgumentBuilder builder, string switch, string separator, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchQuoted(ProcessArgumentBuilder builder, string switch, string separator, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchQuoted(ProcessArgumentBuilder builder, string switch, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchQuoted(ProcessArgumentBuilder builder, string switch, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchQuoted(ProcessArgumentBuilder builder, string switch, string separator, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchQuoted(ProcessArgumentBuilder builder, string switch, string separator, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchSecret(ProcessArgumentBuilder builder, string switch, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchSecret(ProcessArgumentBuilder builder, string switch, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchSecret(ProcessArgumentBuilder builder, string switch, string separator, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchSecret(ProcessArgumentBuilder builder, string switch, string separator, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchSecret(ProcessArgumentBuilder builder, string switch, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchSecret(ProcessArgumentBuilder builder, string switch, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchSecret(ProcessArgumentBuilder builder, string switch, string separator, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchSecret(ProcessArgumentBuilder builder, string switch, string separator, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchQuotedSecret(ProcessArgumentBuilder builder, string switch, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchQuotedSecret(ProcessArgumentBuilder builder, string switch, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendSwitchQuotedSecret(ProcessArgumentBuilder builder, string switch, string separator, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependSwitchQuotedSecret(ProcessArgumentBuilder builder, string switch, string separator, string text);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendQuotedSecret(ProcessArgumentBuilder builder, string switch, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependQuotedSecret(ProcessArgumentBuilder builder, string switch, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder AppendQuotedSecret(ProcessArgumentBuilder builder, string switch, string separator, IProcessArgument argument);
    [ExtensionAttribute]
public static ProcessArgumentBuilder PrependQuotedSecret(ProcessArgumentBuilder builder, string switch, string separator, IProcessArgument argument);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(ProcessArgumentBuilder builder);
    [ExtensionAttribute]
public static void CopyTo(ProcessArgumentBuilder source, ProcessArgumentBuilder target);
}
[ExtensionAttribute]
public static class Cake.Core.ProcessRunnerExtensions : object {
    [ExtensionAttribute]
public static IProcess Start(IProcessRunner processRunner, FilePath filePath);
}
[ExtensionAttribute]
public static class Cake.Core.ProcessSettingsExtensions : object {
    [ExtensionAttribute]
public static ProcessSettings WithArguments(ProcessSettings settings, Action`1<ProcessArgumentBuilder> arguments);
    [ExtensionAttribute]
public static ProcessSettings UseWorkingDirectory(ProcessSettings settings, DirectoryPath path);
    [ExtensionAttribute]
public static ProcessSettings SetRedirectedStandardOutputHandler(ProcessSettings settings, Func`2<string, string> handler);
    [ExtensionAttribute]
public static ProcessSettings SetRedirectedStandardErrorHandler(ProcessSettings settings, Func`2<string, string> handler);
    [ExtensionAttribute]
public static ProcessSettings SetRedirectStandardOutput(ProcessSettings settings, bool redirect);
    [ExtensionAttribute]
public static ProcessSettings SetRedirectStandardError(ProcessSettings settings, bool redirect);
    [ExtensionAttribute]
public static ProcessSettings SetTimeout(ProcessSettings settings, int timeout);
}
public class Cake.Core.Reflection.AssemblyLoader : object {
    private ICakeEnvironment _environment;
    private IFileSystem _fileSystem;
    private IAssemblyVerifier _verifier;
    private ICakeLog _log;
    public AssemblyLoader(ICakeEnvironment environment, IFileSystem fileSystem, IAssemblyVerifier verifier, ICakeLog log);
    public sealed virtual Assembly Load(AssemblyName assemblyName);
    public sealed virtual Assembly Load(FilePath path, bool verify);
}
public class Cake.Core.Reflection.AssemblyVerifier : object {
    private ICakeLog _log;
    private bool _skipVerification;
    public AssemblyVerifier(ICakeConfiguration configuration, ICakeLog log);
    public sealed virtual void Verify(Assembly assembly);
}
public interface Cake.Core.Reflection.IAssemblyLoader {
    public abstract virtual Assembly Load(AssemblyName assemblyName);
    public abstract virtual Assembly Load(FilePath path, bool verify);
}
public interface Cake.Core.Reflection.IAssemblyVerifier {
    public abstract virtual void Verify(Assembly assembly);
}
internal class Cake.Core.Reflection.SimpleAssemblyComparer : object {
    public sealed virtual bool Equals(Assembly x, Assembly y);
    public sealed virtual int GetHashCode(Assembly obj);
}
public interface Cake.Core.Scripting.Analysis.IScriptAnalyzer {
    public abstract virtual ScriptAnalyzerResult Analyze(FilePath path, ScriptAnalyzerSettings settings);
}
public interface Cake.Core.Scripting.Analysis.IScriptAnalyzerContext {
    public FilePath Root { get; }
    public IScriptInformation Current { get; }
    public abstract virtual FilePath get_Root();
    public abstract virtual IScriptInformation get_Current();
    public abstract virtual void Analyze(FilePath scriptPath);
    public abstract virtual void AddScriptLine(string line);
    public abstract virtual void AddScriptError(string error);
}
public interface Cake.Core.Scripting.Analysis.IScriptInformation {
    public FilePath Path { get; }
    public IList`1<IScriptInformation> Includes { get; }
    public IList`1<string> References { get; }
    public IList`1<string> Namespaces { get; }
    public IList`1<string> UsingAliases { get; }
    public IList`1<string> UsingStaticDirectives { get; }
    public IList`1<string> Defines { get; }
    public IList`1<PackageReference> Tools { get; }
    public IList`1<PackageReference> Addins { get; }
    public IList`1<PackageReference> Modules { get; }
    public abstract virtual FilePath get_Path();
    public abstract virtual IList`1<IScriptInformation> get_Includes();
    public abstract virtual IList`1<string> get_References();
    public abstract virtual IList`1<string> get_Namespaces();
    public abstract virtual IList`1<string> get_UsingAliases();
    public abstract virtual IList`1<string> get_UsingStaticDirectives();
    public abstract virtual IList`1<string> get_Defines();
    public abstract virtual IList`1<PackageReference> get_Tools();
    public abstract virtual IList`1<PackageReference> get_Addins();
    public abstract virtual IList`1<PackageReference> get_Modules();
}
public class Cake.Core.Scripting.Analysis.ScriptAnalyzer : object {
    private IFileSystem _fileSystem;
    private ICakeEnvironment _environment;
    private ICakeLog _log;
    private LineProcessor[] _defaultProcessors;
    private LineProcessor[] _moduleProcessors;
    public ScriptAnalyzer(IFileSystem fileSystem, ICakeEnvironment environment, ICakeLog log, IEnumerable`1<ILoadDirectiveProvider> providers);
    public sealed virtual ScriptAnalyzerResult Analyze(FilePath path, ScriptAnalyzerSettings settings);
    private void ModuleAnalyzeCallback(IScriptAnalyzerContext context);
    private void AnalyzeCallback(IScriptAnalyzerContext context);
    private IEnumerable`1<string> ReadLines(FilePath path);
}
internal class Cake.Core.Scripting.Analysis.ScriptAnalyzerContext : object {
    private Action`1<IScriptAnalyzerContext> _callback;
    private IFileSystem _fileSystem;
    private ICakeEnvironment _environment;
    private ICakeLog _log;
    private FilePath _script;
    private Stack`1<ScriptInformation> _stack;
    private List`1<string> _lines;
    private HashSet`1<FilePath> _processedScripts;
    private List`1<ScriptAnalyzerError> _errors;
    private ScriptInformation _current;
    public FilePath Root { get; }
    public IScriptInformation Current { get; }
    public IReadOnlyList`1<string> Lines { get; }
    public IReadOnlyList`1<ScriptAnalyzerError> Errors { get; }
    public ScriptAnalyzerContext(IFileSystem fileSystem, ICakeEnvironment environment, ICakeLog log, Action`1<IScriptAnalyzerContext> callback, FilePath script);
    public sealed virtual FilePath get_Root();
    public sealed virtual IScriptInformation get_Current();
    public IReadOnlyList`1<string> get_Lines();
    public IReadOnlyList`1<ScriptAnalyzerError> get_Errors();
    public sealed virtual void Analyze(FilePath path);
    public sealed virtual void AddScriptLine(string line);
    public sealed virtual void AddScriptError(string error);
    public void Push(FilePath path);
    public void Pop();
    private void InsertLineDirective();
}
public class Cake.Core.Scripting.Analysis.ScriptAnalyzerError : object {
    [CompilerGeneratedAttribute]
private FilePath <File>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public FilePath File { get; }
    public int Line { get; }
    public string Message { get; }
    public ScriptAnalyzerError(FilePath file, int line, string message);
    [CompilerGeneratedAttribute]
public FilePath get_File();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public string get_Message();
}
public enum Cake.Core.Scripting.Analysis.ScriptAnalyzerMode : Enum {
    public int value__;
    public static ScriptAnalyzerMode Everything;
    public static ScriptAnalyzerMode Modules;
}
public class Cake.Core.Scripting.Analysis.ScriptAnalyzerResult : object {
    private HashSet`1<string> _references;
    private HashSet`1<string> _namespaces;
    private HashSet`1<string> _usingAliases;
    private HashSet`1<string> _usingStaticDirectives;
    private HashSet`1<string> _defines;
    [CompilerGeneratedAttribute]
private IScriptInformation <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<PackageReference> <Addins>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<PackageReference> <Tools>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<PackageReference> <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ScriptAnalyzerError> <Errors>k__BackingField;
    public IScriptInformation Script { get; }
    public IReadOnlyList`1<string> Lines { get; }
    public ISet`1<string> References { get; }
    public ISet`1<string> Namespaces { get; }
    public ISet`1<string> UsingAliases { get; }
    public ISet`1<string> UsingStaticDirectives { get; }
    public ISet`1<string> Defines { get; }
    public HashSet`1<PackageReference> Addins { get; }
    public HashSet`1<PackageReference> Tools { get; }
    public HashSet`1<PackageReference> Modules { get; }
    public bool Succeeded { get; }
    public IReadOnlyList`1<ScriptAnalyzerError> Errors { get; }
    public ScriptAnalyzerResult(IScriptInformation script, IReadOnlyList`1<string> lines, IReadOnlyList`1<ScriptAnalyzerError> errors);
    [CompilerGeneratedAttribute]
public IScriptInformation get_Script();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Lines();
    public ISet`1<string> get_References();
    public ISet`1<string> get_Namespaces();
    public ISet`1<string> get_UsingAliases();
    public ISet`1<string> get_UsingStaticDirectives();
    public ISet`1<string> get_Defines();
    [CompilerGeneratedAttribute]
public HashSet`1<PackageReference> get_Addins();
    [CompilerGeneratedAttribute]
public HashSet`1<PackageReference> get_Tools();
    [CompilerGeneratedAttribute]
public HashSet`1<PackageReference> get_Modules();
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ScriptAnalyzerError> get_Errors();
    [IteratorStateMachineAttribute("Cake.Core.Scripting.Analysis.ScriptAnalyzerResult/<Collect>d__37`1")]
private static IEnumerable`1<T> Collect(IScriptInformation script, Func`2<IScriptInformation, IEnumerable`1<T>> collector);
}
public class Cake.Core.Scripting.Analysis.ScriptAnalyzerSettings : object {
    [CompilerGeneratedAttribute]
private ScriptAnalyzerMode <Mode>k__BackingField;
    public ScriptAnalyzerMode Mode { get; public set; }
    [CompilerGeneratedAttribute]
public ScriptAnalyzerMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(ScriptAnalyzerMode value);
}
internal class Cake.Core.Scripting.Analysis.ScriptInformation : object {
    [CompilerGeneratedAttribute]
private FilePath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IScriptInformation> <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <UsingAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <UsingStaticDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Defines>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageReference> <Addins>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageReference> <Tools>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageReference> <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Lines>k__BackingField;
    public FilePath Path { get; }
    public IList`1<IScriptInformation> Includes { get; }
    public IList`1<string> References { get; }
    public IList`1<string> UsingAliases { get; }
    public IList`1<string> Namespaces { get; }
    public IList`1<string> UsingStaticDirectives { get; }
    public IList`1<string> Defines { get; }
    public IList`1<PackageReference> Addins { get; }
    public IList`1<PackageReference> Tools { get; }
    public IList`1<PackageReference> Modules { get; }
    public IList`1<string> Lines { get; }
    public ScriptInformation(FilePath path);
    [CompilerGeneratedAttribute]
public sealed virtual FilePath get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IScriptInformation> get_Includes();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_References();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_UsingAliases();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_Namespaces();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_UsingStaticDirectives();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_Defines();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<PackageReference> get_Addins();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<PackageReference> get_Tools();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<PackageReference> get_Modules();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Lines();
}
internal class Cake.Core.Scripting.CodeGen.GenericParameterConstraintEmitter : object {
    internal static string Emit(MethodInfo method);
    internal static void BuildGenericConstraints(MethodInfo method, StringBuilder builder);
}
public static class Cake.Core.Scripting.CodeGen.MethodAliasGenerator : object {
    private static SHA256 _hasher;
    private static MethodAliasGenerator();
    public static string Generate(MethodInfo method);
    public static string Generate(MethodInfo method, String& hash);
    private static string GetReturnType(MethodInfo method);
    [IteratorStateMachineAttribute("Cake.Core.Scripting.CodeGen.MethodAliasGenerator/<GetProxyParameters>d__4")]
private static IEnumerable`1<string> GetProxyParameters(IEnumerable`1<ParameterInfo> parameters, bool includeType);
    private static void BuildGenericArguments(MethodInfo method, StringBuilder builder);
    private static string GetObsoleteMessage(MethodInfo method, ObsoleteAttribute attribute);
}
internal class Cake.Core.Scripting.CodeGen.ParameterEmitter : object {
    private static Type[] Exclusions;
    private static ParameterFormatter _parameterFormatter;
    private static HashSet`1<Type> _numericTypes;
    private static ParameterEmitter();
    internal static string Emit(ParameterInfo parameter, bool includeType);
    [IteratorStateMachineAttribute("Cake.Core.Scripting.CodeGen.ParameterEmitter/<BuildParameterTokens>d__3")]
private static IEnumerable`1<string> BuildParameterTokens(ParameterInfo parameter, bool includeType);
    private static string NormalizeCustomAttributeTypedArgument(CustomAttributeTypedArgument arg);
    private static string BuildDefaultParameterValueToken(ParameterInfo parameter);
    private static string BuildParameterValueToken(Type type, object value);
    private static bool IsNumeric(Type myType);
}
internal class Cake.Core.Scripting.CodeGen.ParameterFormatter : object {
    private HashSet`1<string> _keywords;
    internal string FormatName(ParameterInfo parameterInfo);
    internal string FormatName(string parameterName);
}
public static class Cake.Core.Scripting.CodeGen.PropertyAliasGenerator : object {
    private static SHA256 SHA256;
    private static PropertyAliasGenerator();
    public static string Generate(MethodInfo method);
    public static string Generate(MethodInfo method, String& hash);
    private static void ValidateMethod(MethodInfo method);
    private static void ValidateMethodParameters(MethodInfo method);
    private static string GenerateCode(MethodInfo method, String& hash);
    private static string GenerateCommonInitalCode(MethodInfo method, StringBuilder& builder);
    private static string GenerateCachedCode(MethodInfo method, String& hash);
    private static void AddObsoleteAttribute(StringBuilder builder, ObsoleteAttribute obsolete);
    private static string GetReturnType(MethodInfo method);
}
public interface Cake.Core.Scripting.IReferenceAssemblyResolver {
    public abstract virtual Assembly[] GetReferenceAssemblies();
}
public interface Cake.Core.Scripting.IScriptAliasFinder {
    public abstract virtual IReadOnlyList`1<ScriptAlias> FindAliases(IEnumerable`1<Assembly> assemblies);
}
public interface Cake.Core.Scripting.IScriptConventions {
    public abstract virtual IReadOnlyList`1<string> GetDefaultNamespaces();
    public abstract virtual IReadOnlyList`1<Assembly> GetDefaultAssemblies(DirectoryPath root);
    public abstract virtual IReadOnlyList`1<string> GetDefaultDefines();
}
public interface Cake.Core.Scripting.IScriptEngine {
    public abstract virtual IScriptSession CreateSession(IScriptHost host);
}
public interface Cake.Core.Scripting.IScriptHost {
    public ICakeContext Context { get; }
    public IReadOnlyList`1<ICakeTaskInfo> Tasks { get; }
    public ExecutionSettings Settings { get; }
    public abstract virtual ICakeContext get_Context();
    public abstract virtual IReadOnlyList`1<ICakeTaskInfo> get_Tasks();
    public abstract virtual ExecutionSettings get_Settings();
    public abstract virtual CakeTaskBuilder Task(string name);
    public virtual CakeTaskBuilder`1<TData> TaskOf(string name);
    public abstract virtual void Setup(Action`1<ISetupContext> action);
    public abstract virtual void Setup(Func`2<ISetupContext, TData> action);
    public abstract virtual void Teardown(Action`1<ITeardownContext> action);
    public abstract virtual void Teardown(Action`2<ITeardownContext, TData> action);
    public abstract virtual void TaskSetup(Action`1<ITaskSetupContext> action);
    public abstract virtual void TaskSetup(Action`2<ITaskSetupContext, TData> action);
    public abstract virtual void TaskTeardown(Action`1<ITaskTeardownContext> action);
    public abstract virtual void TaskTeardown(Action`2<ITaskTeardownContext, TData> action);
    public abstract virtual CakeReport RunTarget(string target);
    public abstract virtual Task`1<CakeReport> RunTargetAsync(string target);
    public abstract virtual CakeReport RunTargets(IEnumerable`1<string> targets);
    public abstract virtual Task`1<CakeReport> RunTargetsAsync(IEnumerable`1<string> targets);
}
public interface Cake.Core.Scripting.IScriptProcessor {
    public abstract virtual IReadOnlyList`1<FilePath> InstallAddins(IReadOnlyCollection`1<PackageReference> addins, DirectoryPath installPath);
    public abstract virtual void InstallTools(IReadOnlyCollection`1<PackageReference> tools, DirectoryPath installPath);
    public abstract virtual void InstallModules(IReadOnlyCollection`1<PackageReference> modules, DirectoryPath installPath);
}
public interface Cake.Core.Scripting.IScriptRunner {
    public abstract virtual void Run(IScriptHost host, FilePath scriptPath);
}
public interface Cake.Core.Scripting.IScriptSession {
    public abstract virtual void AddReference(FilePath path);
    public abstract virtual void AddReference(Assembly assembly);
    public abstract virtual void ImportNamespace(string namespace);
    public abstract virtual void Execute(Script script);
}
[CompilerGeneratedAttribute]
internal class Cake.Core.Scripting.NamespaceDoc : object {
}
internal class Cake.Core.Scripting.Processors.AddInDirectiveProcessor : UriDirectiveProcessor {
    protected virtual IEnumerable`1<string> GetDirectiveNames();
    protected virtual void AddToContext(IScriptAnalyzerContext context, Uri uri);
}
internal class Cake.Core.Scripting.Processors.BreakDirectiveProcessor : LineProcessor {
    public virtual bool Process(IScriptAnalyzerContext context, string line, String& replacement);
}
internal class Cake.Core.Scripting.Processors.DefineDirectiveProcessor : LineProcessor {
    public virtual bool Process(IScriptAnalyzerContext context, string line, String& replacement);
}
internal abstract class Cake.Core.Scripting.Processors.LineProcessor : object {
    public abstract virtual bool Process(IScriptAnalyzerContext analyzer, string line, String& replacement);
    protected static String[] Split(string line);
}
internal class Cake.Core.Scripting.Processors.LoadDirectiveProcessor : UriDirectiveProcessor {
    private IEnumerable`1<ILoadDirectiveProvider> _providers;
    public LoadDirectiveProcessor(IEnumerable`1<ILoadDirectiveProvider> providers);
    protected virtual IEnumerable`1<string> GetDirectiveNames();
    protected virtual Uri CreateUriFromLegacyFormat(String[] tokens);
    protected virtual void AddToContext(IScriptAnalyzerContext context, Uri uri);
}
internal class Cake.Core.Scripting.Processors.Loading.FileLoadDirectiveProvider : object {
    private IGlobber _globber;
    private ICakeLog _log;
    public FileLoadDirectiveProvider(IGlobber globber, ICakeLog log);
    public sealed virtual bool CanLoad(IScriptAnalyzerContext context, LoadReference reference);
    public sealed virtual void Load(IScriptAnalyzerContext context, LoadReference reference);
}
public interface Cake.Core.Scripting.Processors.Loading.ILoadDirectiveProvider {
    public abstract virtual bool CanLoad(IScriptAnalyzerContext context, LoadReference reference);
    public abstract virtual void Load(IScriptAnalyzerContext context, LoadReference reference);
}
public class Cake.Core.Scripting.Processors.Loading.LoadReference : object {
    [CompilerGeneratedAttribute]
private string <OriginalString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> <Parameters>k__BackingField;
    public string OriginalString { get; }
    public string Scheme { get; }
    public Uri Address { get; }
    public IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> Parameters { get; }
    public LoadReference(Uri uri);
    [CompilerGeneratedAttribute]
public string get_OriginalString();
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public Uri get_Address();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> get_Parameters();
}
internal class Cake.Core.Scripting.Processors.ModuleDirectiveProcessor : UriDirectiveProcessor {
    protected virtual IEnumerable`1<string> GetDirectiveNames();
    protected virtual void AddToContext(IScriptAnalyzerContext context, Uri uri);
}
[CompilerGeneratedAttribute]
internal class Cake.Core.Scripting.Processors.NamespaceDoc : object {
}
internal class Cake.Core.Scripting.Processors.ReferenceDirectiveProcessor : LineProcessor {
    private IFileSystem _fileSystem;
    private ICakeEnvironment _environment;
    public ReferenceDirectiveProcessor(IFileSystem fileSystem, ICakeEnvironment environment);
    public virtual bool Process(IScriptAnalyzerContext context, string line, String& replacement);
}
internal class Cake.Core.Scripting.Processors.ShebangProcessor : LineProcessor {
    public virtual bool Process(IScriptAnalyzerContext processor, string line, String& replacement);
}
internal class Cake.Core.Scripting.Processors.ToolDirectiveProcessor : UriDirectiveProcessor {
    protected virtual IEnumerable`1<string> GetDirectiveNames();
    protected virtual void AddToContext(IScriptAnalyzerContext context, Uri uri);
}
internal abstract class Cake.Core.Scripting.Processors.UriDirectiveProcessor : LineProcessor {
    private Regex _uriPrefixPattern;
    protected abstract virtual IEnumerable`1<string> GetDirectiveNames();
    protected abstract virtual void AddToContext(IScriptAnalyzerContext context, Uri uri);
    public sealed virtual bool Process(IScriptAnalyzerContext context, string line, String& replacement);
    private Uri ParseUriFromTokens(String[] tokens);
    private bool IsUriFromLegacyPattern(String[] tokens);
    protected virtual Uri CreateUriFromLegacyFormat(String[] tokens);
}
internal class Cake.Core.Scripting.Processors.UsingStatementProcessor : LineProcessor {
    public virtual bool Process(IScriptAnalyzerContext context, string line, String& replacement);
}
public class Cake.Core.Scripting.Script : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IList`1<string>> <ExcludedNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ScriptAlias> <Aliases>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <UsingAliasDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <UsingStaticDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Defines>k__BackingField;
    public IReadOnlyList`1<string> Namespaces { get; }
    public IDictionary`2<string, IList`1<string>> ExcludedNamespaces { get; }
    public IReadOnlyList`1<string> Lines { get; }
    public IReadOnlyList`1<ScriptAlias> Aliases { get; }
    public IReadOnlyList`1<string> UsingAliasDirectives { get; }
    public IReadOnlyList`1<string> UsingStaticDirectives { get; }
    public IReadOnlyList`1<string> Defines { get; }
    public Script(IEnumerable`1<string> namespaces, IEnumerable`1<string> lines, IEnumerable`1<ScriptAlias> aliases, IEnumerable`1<string> usingAliasDirectives, IEnumerable`1<string> usingStaticDirectives, IEnumerable`1<string> defines);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Namespaces();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IList`1<string>> get_ExcludedNamespaces();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Lines();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ScriptAlias> get_Aliases();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_UsingAliasDirectives();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_UsingStaticDirectives();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Defines();
}
public class Cake.Core.Scripting.ScriptAlias : object {
    private List`1<string> _namespaces;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptAliasType <Type>k__BackingField;
    public string Name { get; }
    public MethodInfo Method { get; }
    public ScriptAliasType Type { get; }
    public IReadOnlyList`1<string> Namespaces { get; }
    public ScriptAlias(MethodInfo method, ScriptAliasType type, ISet`1<string> namespaces);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public ScriptAliasType get_Type();
    public IReadOnlyList`1<string> get_Namespaces();
}
public class Cake.Core.Scripting.ScriptAliasFinder : object {
    private ICakeLog _log;
    public ScriptAliasFinder(ICakeLog log);
    public sealed virtual IReadOnlyList`1<ScriptAlias> FindAliases(IEnumerable`1<Assembly> assemblies);
    private ScriptAlias CreateAlias(Tuple`2<MethodInfo, ScriptAliasType> alias);
    [IteratorStateMachineAttribute("Cake.Core.Scripting.ScriptAliasFinder/<GetAliasMethods>d__4")]
private static IEnumerable`1<Tuple`2<MethodInfo, ScriptAliasType>> GetAliasMethods(Type type);
    private static ScriptAliasType GetScriptAliasType(MethodInfo method);
}
public enum Cake.Core.Scripting.ScriptAliasType : Enum {
    public int value__;
    public static ScriptAliasType Unknown;
    public static ScriptAliasType Method;
    public static ScriptAliasType Property;
}
public class Cake.Core.Scripting.ScriptConventions : object {
    private IFileSystem _fileSystem;
    private IAssemblyLoader _loader;
    private ICakeRuntime _runtime;
    private IReferenceAssemblyResolver _referenceAssemblyResolver;
    public ScriptConventions(IFileSystem fileSystem, IAssemblyLoader loader, ICakeRuntime runtime, IReferenceAssemblyResolver referenceAssemblyResolver);
    public sealed virtual IReadOnlyList`1<string> GetDefaultNamespaces();
    public sealed virtual IReadOnlyList`1<Assembly> GetDefaultAssemblies(DirectoryPath root);
    public sealed virtual IReadOnlyList`1<string> GetDefaultDefines();
    private string GetFrameworkDefine();
    private List`1<Assembly> LoadCakeAssemblies(DirectoryPath root);
    private static String[] GetCakeAssemblyNames();
}
public abstract class Cake.Core.Scripting.ScriptHost : object {
    [CompilerGeneratedAttribute]
private ICakeEngine <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private ICakeContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionSettings <Settings>k__BackingField;
    protected ICakeEngine Engine { get; }
    public ICakeContext Context { get; }
    public ExecutionSettings Settings { get; }
    public IReadOnlyList`1<ICakeTaskInfo> Tasks { get; }
    protected ScriptHost(ICakeEngine engine, ICakeContext context);
    [CompilerGeneratedAttribute]
protected ICakeEngine get_Engine();
    [CompilerGeneratedAttribute]
public sealed virtual ICakeContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual ExecutionSettings get_Settings();
    public sealed virtual IReadOnlyList`1<ICakeTaskInfo> get_Tasks();
    public sealed virtual CakeTaskBuilder Task(string name);
    public sealed virtual CakeTaskBuilder`1<TData> TaskOf(string name);
    public sealed virtual void Setup(Action`1<ISetupContext> action);
    public sealed virtual void Setup(Func`2<ISetupContext, TData> action);
    public sealed virtual void Teardown(Action`1<ITeardownContext> action);
    public sealed virtual void Teardown(Action`2<ITeardownContext, TData> action);
    public sealed virtual void TaskSetup(Action`1<ITaskSetupContext> action);
    public sealed virtual void TaskSetup(Action`2<ITaskSetupContext, TData> action);
    public sealed virtual void TaskTeardown(Action`1<ITaskTeardownContext> action);
    public sealed virtual void TaskTeardown(Action`2<ITaskTeardownContext, TData> action);
    public sealed virtual CakeReport RunTarget(string target);
    public abstract virtual Task`1<CakeReport> RunTargetAsync(string target);
    public sealed virtual CakeReport RunTargets(IEnumerable`1<string> targets);
    public abstract virtual Task`1<CakeReport> RunTargetsAsync(IEnumerable`1<string> targets);
}
public class Cake.Core.Scripting.ScriptProcessor : object {
    private ICakeEnvironment _environment;
    private ICakeLog _log;
    private IToolLocator _tools;
    private List`1<IPackageInstaller> _installers;
    private bool _skipPackageVersionCheck;
    public ScriptProcessor(IFileSystem fileSystem, ICakeEnvironment environment, ICakeLog log, IToolLocator tools, IEnumerable`1<IPackageInstaller> installers, ICakeConfiguration configuration);
    public sealed virtual IReadOnlyList`1<FilePath> InstallAddins(IReadOnlyCollection`1<PackageReference> addins, DirectoryPath installPath);
    public sealed virtual void InstallTools(IReadOnlyCollection`1<PackageReference> tools, DirectoryPath installPath);
    public sealed virtual void InstallModules(IReadOnlyCollection`1<PackageReference> modules, DirectoryPath installPath);
    private IPackageInstaller GetInstaller(PackageReference package, PackageType type);
    private void InstallPackages(IReadOnlyCollection`1<PackageReference> modules, DirectoryPath installPath, PackageType packageType);
    private void CheckPackageVersion(PackageReference packageReference, string directiveName);
}
public class Cake.Core.Scripting.ScriptRunner : object {
    private ICakeEnvironment _environment;
    private ICakeLog _log;
    private ICakeConfiguration _configuration;
    private IScriptEngine _engine;
    private IScriptAliasFinder _aliasFinder;
    private IScriptAnalyzer _analyzer;
    private IScriptProcessor _processor;
    private IScriptConventions _conventions;
    private IAssemblyLoader _assemblyLoader;
    public ScriptRunner(ICakeEnvironment environment, ICakeLog log, ICakeConfiguration configuration, IScriptEngine engine, IScriptAliasFinder aliasFinder, IScriptAnalyzer analyzer, IScriptProcessor processor, IScriptConventions conventions, IAssemblyLoader assemblyLoader);
    public sealed virtual void Run(IScriptHost host, FilePath scriptPath);
    private DirectoryPath GetToolPath(DirectoryPath root);
    private DirectoryPath GetAddinPath(DirectoryPath root);
}
public class Cake.Core.SetupContext : CakeContextAdapter {
    [CompilerGeneratedAttribute]
private ICakeTaskInfo <TargetTask>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ICakeTaskInfo> <TasksToExecute>k__BackingField;
    public ICakeTaskInfo TargetTask { get; }
    public IReadOnlyCollection`1<ICakeTaskInfo> TasksToExecute { get; }
    public SetupContext(ICakeContext context, ICakeTaskInfo targetTask, IEnumerable`1<ICakeTaskInfo> tasksToExecute);
    [CompilerGeneratedAttribute]
public sealed virtual ICakeTaskInfo get_TargetTask();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<ICakeTaskInfo> get_TasksToExecute();
}
[ExtensionAttribute]
public static class Cake.Core.StringExtensions : object {
    [ExtensionAttribute]
public static string Quote(string value);
    [ExtensionAttribute]
public static string UnQuote(string value);
    [ExtensionAttribute]
public static String[] SplitLines(string content);
    [ExtensionAttribute]
public static string NormalizeLineEndings(string value);
    [ExtensionAttribute]
private static bool IsQuoted(string value);
}
public class Cake.Core.TaskSetupContext : CakeContextAdapter {
    [CompilerGeneratedAttribute]
private ICakeTaskInfo <Task>k__BackingField;
    public ICakeTaskInfo Task { get; }
    public TaskSetupContext(ICakeContext context, ICakeTaskInfo task);
    [CompilerGeneratedAttribute]
public sealed virtual ICakeTaskInfo get_Task();
}
public class Cake.Core.TaskTeardownContext : CakeContextAdapter {
    [CompilerGeneratedAttribute]
private ICakeTaskInfo <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ThrownException>k__BackingField;
    public ICakeTaskInfo Task { get; }
    public TimeSpan Duration { get; }
    public bool Skipped { get; }
    public bool Successful { get; }
    public Exception ThrownException { get; }
    public TaskTeardownContext(ICakeContext context, ICakeTaskInfo task, TimeSpan duration, bool skipped, Exception throwException);
    [CompilerGeneratedAttribute]
public sealed virtual ICakeTaskInfo get_Task();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Skipped();
    public sealed virtual bool get_Successful();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_ThrownException();
}
public class Cake.Core.TeardownContext : CakeContextAdapter {
    [CompilerGeneratedAttribute]
private Exception <ThrownException>k__BackingField;
    public bool Successful { get; }
    public Exception ThrownException { get; }
    public TeardownContext(ICakeContext context, Exception throwException);
    public sealed virtual bool get_Successful();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_ThrownException();
}
public interface Cake.Core.Text.ITextTransformationTemplate {
    public abstract virtual void Register(string key, object value);
    public abstract virtual string Render();
}
[CompilerGeneratedAttribute]
internal class Cake.Core.Text.NamespaceDoc : object {
}
public static class Cake.Core.Text.QuoteAwareStringSplitter : object {
    public static IEnumerable`1<string> Split(string text);
    [IteratorStateMachineAttribute("Cake.Core.Text.QuoteAwareStringSplitter/<Split>d__1")]
private static IEnumerable`1<string> Split(StringReader reader);
    private static string ReadQuote(StringReader reader);
    private static string Read(StringReader reader);
}
public class Cake.Core.Text.TextTransformationTemplate : object {
    private Dictionary`2<string, object> _tokens;
    private string _template;
    private string _keyExpression;
    private static String[] _regexTokens;
    public TextTransformationTemplate(string template);
    public TextTransformationTemplate(string template, Tuple`2<string, string> placeholder);
    private static TextTransformationTemplate();
    public sealed virtual void Register(string key, object value);
    public sealed virtual string Render();
    private static string CreateKeyExpression(Tuple`2<string, string> placeholder);
    private string Replace(Match match);
    private static string EscapeRegexCharacters(string text);
}
public interface Cake.Core.Tooling.IToolLocator {
    public abstract virtual void RegisterFile(FilePath path);
    public abstract virtual FilePath Resolve(string tool);
    public abstract virtual FilePath Resolve(IEnumerable`1<string> toolExeNames);
}
public interface Cake.Core.Tooling.IToolRepository {
    public abstract virtual void Register(FilePath path);
    public abstract virtual IEnumerable`1<FilePath> Resolve(string tool);
}
public interface Cake.Core.Tooling.IToolResolutionStrategy {
    public abstract virtual FilePath Resolve(IToolRepository repository, string tool);
    public abstract virtual FilePath Resolve(IToolRepository repository, IEnumerable`1<string> toolExeNames);
}
[CompilerGeneratedAttribute]
internal class Cake.Core.Tooling.NamespaceDoc : object {
}
public abstract class Cake.Core.Tooling.Tool`1 : object {
    private ICakeEnvironment _environment;
    private IFileSystem _fileSystem;
    private IToolLocator _tools;
    private IProcessRunner _processRunner;
    protected Tool`1(IFileSystem fileSystem, ICakeEnvironment environment, IProcessRunner processRunner, IToolLocator tools);
    protected void Run(TSettings settings, ProcessArgumentBuilder arguments);
    protected void Run(TSettings settings, ProcessArgumentBuilder arguments, ProcessSettings processSettings, Action`1<IProcess> postAction);
    protected virtual void ProcessExitCode(int exitCode);
    protected IProcess RunProcess(TSettings settings, ProcessArgumentBuilder arguments);
    protected IProcess RunProcess(TSettings settings, ProcessArgumentBuilder arguments, ProcessSettings processSettings);
    protected abstract virtual string GetToolName();
    protected virtual IEnumerable`1<string> GetToolExecutableNames(TSettings settings);
    protected abstract virtual IEnumerable`1<string> GetToolExecutableNames();
    protected virtual DirectoryPath GetWorkingDirectory(TSettings settings);
    protected virtual IEnumerable`1<FilePath> GetAlternativeToolPaths(TSettings settings);
    protected virtual IDictionary`2<string, string> GetEnvironmentVariables(TSettings settings);
    protected FilePath GetToolPath(TSettings settings);
    private FilePath GetToolPathUsingToolService(TSettings settings);
}
public class Cake.Core.Tooling.ToolLocator : object {
    private ICakeEnvironment _environment;
    private IToolRepository _repository;
    private IToolResolutionStrategy _strategy;
    public ToolLocator(ICakeEnvironment environment, IToolRepository repository, IToolResolutionStrategy strategy);
    public sealed virtual void RegisterFile(FilePath path);
    public sealed virtual FilePath Resolve(string tool);
    public sealed virtual FilePath Resolve(IEnumerable`1<string> toolExeNames);
}
public class Cake.Core.Tooling.ToolRepository : object {
    private ICakeEnvironment _environment;
    private Dictionary`2<string, List`1<FilePath>> _paths;
    private PathComparer _comparer;
    public ToolRepository(ICakeEnvironment environment);
    public sealed virtual void Register(FilePath path);
    public sealed virtual IEnumerable`1<FilePath> Resolve(string tool);
}
public class Cake.Core.Tooling.ToolResolutionStrategy : object {
    private static Regex _windowsExtRegex;
    private IFileSystem _fileSystem;
    private ICakeEnvironment _environment;
    private IGlobber _globber;
    private ICakeConfiguration _configuration;
    private ICakeLog _log;
    private object _lock;
    private List`1<DirectoryPath> _path;
    public ToolResolutionStrategy(IFileSystem fileSystem, ICakeEnvironment environment, IGlobber globber, ICakeConfiguration configuration, ICakeLog log);
    private static ToolResolutionStrategy();
    public sealed virtual FilePath Resolve(IToolRepository repository, string tool);
    public sealed virtual FilePath Resolve(IToolRepository repository, IEnumerable`1<string> toolExeNames);
    private bool HasPlatformAffinity(string tool);
    private static FilePath LookInRegistrations(IToolRepository repository, string tool);
    private FilePath LookInToolsDirectory(string tool);
    private FilePath LookInPath(string tool);
    private DirectoryPath GetToolsDirectory();
    private List`1<DirectoryPath> GetPathDirectories();
}
public class Cake.Core.Tooling.ToolSettings : object {
    [CompilerGeneratedAttribute]
private FilePath <ToolPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ToolTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryPath <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ProcessArgumentBuilder, ProcessArgumentBuilder> <ArgumentCustomization>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<int, bool> <HandleExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IProcess> <PostAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ProcessSettings> <SetupProcessSettings>k__BackingField;
    public FilePath ToolPath { get; public set; }
    public Nullable`1<TimeSpan> ToolTimeout { get; public set; }
    public DirectoryPath WorkingDirectory { get; public set; }
    public bool NoWorkingDirectory { get; public set; }
    public Func`2<ProcessArgumentBuilder, ProcessArgumentBuilder> ArgumentCustomization { get; public set; }
    public IDictionary`2<string, string> EnvironmentVariables { get; public set; }
    public Func`2<int, bool> HandleExitCode { get; public set; }
    public Action`1<IProcess> PostAction { get; public set; }
    public Action`1<ProcessSettings> SetupProcessSettings { get; public set; }
    [CompilerGeneratedAttribute]
public FilePath get_ToolPath();
    [CompilerGeneratedAttribute]
public void set_ToolPath(FilePath value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_ToolTimeout();
    [CompilerGeneratedAttribute]
public void set_ToolTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public DirectoryPath get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(DirectoryPath value);
    [CompilerGeneratedAttribute]
public bool get_NoWorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_NoWorkingDirectory(bool value);
    [CompilerGeneratedAttribute]
public Func`2<ProcessArgumentBuilder, ProcessArgumentBuilder> get_ArgumentCustomization();
    [CompilerGeneratedAttribute]
public void set_ArgumentCustomization(Func`2<ProcessArgumentBuilder, ProcessArgumentBuilder> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Func`2<int, bool> get_HandleExitCode();
    [CompilerGeneratedAttribute]
public void set_HandleExitCode(Func`2<int, bool> value);
    [CompilerGeneratedAttribute]
public Action`1<IProcess> get_PostAction();
    [CompilerGeneratedAttribute]
public void set_PostAction(Action`1<IProcess> value);
    [CompilerGeneratedAttribute]
public Action`1<ProcessSettings> get_SetupProcessSettings();
    [CompilerGeneratedAttribute]
public void set_SetupProcessSettings(Action`1<ProcessSettings> value);
}
[ExtensionAttribute]
public static class Cake.Core.Tooling.ToolSettingsExtensions : object {
    [ExtensionAttribute]
public static T WithToolSettings(T toolSettings, Action`1<T> toolSettingsAction);
    [ExtensionAttribute]
public static T WithToolPath(T toolSettings, FilePath toolPath);
    [ExtensionAttribute]
public static T WithToolTimeout(T toolSettings, TimeSpan toolTimeout);
    [ExtensionAttribute]
public static T WithWorkingDirectory(T toolSettings, DirectoryPath workingDirectory);
    [ExtensionAttribute]
public static T WithNoWorkingDirectory(T toolSettings, bool noWorkingDirectory);
    [ExtensionAttribute]
public static T WithArgumentCustomization(T toolSettings, Func`2<ProcessArgumentBuilder, ProcessArgumentBuilder> argumentCustomization);
    [ExtensionAttribute]
public static T WithEnvironmentVariable(T toolSettings, string key, string value);
    [ExtensionAttribute]
public static T WithHandleExitCode(T toolSettings, Func`2<int, bool> handleExitCode);
    [ExtensionAttribute]
public static T WithPostAction(T toolSettings, Action`1<IProcess> postAction);
    [ExtensionAttribute]
public static T WithSetupProcessSettings(T toolSettings, Action`1<ProcessSettings> setupProcessSettings);
    [ExtensionAttribute]
public static T WithExpectedExitCode(T toolSettings, int expectExitCode);
}
[ExtensionAttribute]
public static class Cake.Core.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsStatic(Type type);
    [ExtensionAttribute]
public static string GetFullName(Type type, bool includeNamespace);
    [ExtensionAttribute]
public static bool IsSubclassOfRawGeneric(Type toCheck, Type generic);
    [ExtensionAttribute]
private static string GetGenericTypeName(Type type, bool includeNamespace);
    [ExtensionAttribute]
private static bool IsGenericType(Type type, Type& genericType);
    [ExtensionAttribute]
private static string GetGenericTypeArguments(Type type, bool includeNamespace);
}
[ExtensionAttribute]
public static class Cake.Core.UriExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> GetQueryString(Uri uri);
}
