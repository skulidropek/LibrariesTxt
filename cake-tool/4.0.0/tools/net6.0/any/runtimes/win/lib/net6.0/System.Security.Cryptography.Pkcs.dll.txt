internal static class FxResources.System.Security.Cryptography.Pkcs.SR : object {
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
internal abstract class Internal.Cryptography.DecryptorPal : object {
    [CompilerGeneratedAttribute]
private RecipientInfoCollection <RecipientInfos>k__BackingField;
    public RecipientInfoCollection RecipientInfos { get; }
    internal DecryptorPal(RecipientInfoCollection recipientInfos);
    [CompilerGeneratedAttribute]
public RecipientInfoCollection get_RecipientInfos();
    public abstract virtual ContentInfo TryDecrypt(RecipientInfo recipientInfo, X509Certificate2 cert, AsymmetricAlgorithm privateKey, X509Certificate2Collection originatorCerts, X509Certificate2Collection extraStore, Exception& exception);
    public abstract virtual void Dispose();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [UnsupportedOSPlatformGuardAttribute("ios")]
[UnsupportedOSPlatformGuardAttribute("tvos")]
public static bool IsDSASupported { get; }
    [UnsupportedOSPlatformGuardAttribute("android")]
public static bool IsRC2Supported { get; }
    public static bool get_IsDSASupported();
    public static bool get_IsRC2Supported();
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
public static int GetPaddingSize(SymmetricAlgorithm algorithm, CipherMode mode, int feedbackSizeInBits);
    [ExtensionAttribute]
internal static bool TryCopyToDestination(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
internal abstract class Internal.Cryptography.KeyAgreeRecipientInfoPal : RecipientInfoPal {
    public DateTime Date { get; }
    public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
    public CryptographicAttributeObject OtherKeyAttribute { get; }
    public abstract virtual DateTime get_Date();
    public abstract virtual SubjectIdentifierOrKey get_OriginatorIdentifierOrKey();
    public abstract virtual CryptographicAttributeObject get_OtherKeyAttribute();
}
internal static class Internal.Cryptography.KeyLengths : object {
    public static int Rc2_40Bit;
    public static int Rc2_56Bit;
    public static int Rc2_64Bit;
    public static int Rc2_128Bit;
    public static int Rc4Max_128Bit;
    public static int Des_64Bit;
    public static int TripleDes_192Bit;
    public static int DefaultKeyLengthForRc2AndRc4;
}
internal abstract class Internal.Cryptography.KeyTransRecipientInfoPal : RecipientInfoPal {
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.AnyOS.AsnHelpers : object {
    [ExtensionAttribute]
internal static SubjectIdentifierOrKey ToSubjectIdentifierOrKey(OriginatorIdentifierOrKeyAsn originator);
    [ExtensionAttribute]
internal static AlgorithmIdentifier ToPresentationObject(AlgorithmIdentifierAsn asn);
}
internal class Internal.Cryptography.Pal.AnyOS.ManagedPkcsPal : PkcsPal {
    public virtual void AddCertsFromStoreForDecryption(X509Certificate2Collection certs);
    public virtual Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate);
    public virtual T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent);
    public virtual T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent);
    private T GetPrivateKey(X509Certificate2 certificate);
    private static SymmetricAlgorithm OpenAlgorithm(AlgorithmIdentifierAsn contentEncryptionAlgorithm);
    private static SymmetricAlgorithm OpenAlgorithm(AlgorithmIdentifier algorithmIdentifier);
    private static SymmetricAlgorithm OpenAlgorithm(string algorithmIdentifier);
    public virtual Oid GetEncodedMessageType(ReadOnlySpan`1<byte> encodedMessage);
    public virtual DecryptorPal Decode(ReadOnlySpan`1<byte> encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    private static Byte[] CopyContent(ReadOnlySpan`1<byte> encodedMessage);
    public virtual Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes);
    private Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes, Byte[] encryptedContent, Byte[] cek, Byte[] parameterBytes);
    private Byte[] EncryptContent(ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, Byte[]& cek, Byte[]& parameterBytes);
    public virtual Exception CreateRecipientsNotFoundException();
    public virtual Exception CreateRecipientInfosAfterEncryptException();
    public virtual Exception CreateDecryptAfterEncryptException();
    public virtual Exception CreateDecryptTwiceException();
    private static Exception CreateInvalidMessageTypeException();
    private KeyTransRecipientInfoAsn MakeKtri(Byte[] cek, CmsRecipient recipient, Boolean& v0Recipient);
    private static Byte[] DecryptKey(RSA privateKey, RSAEncryptionPadding encryptionPadding, ReadOnlySpan`1<byte> encryptedKey, Exception& exception);
}
internal enum Internal.Cryptography.Pal.Windows.AlgId : Enum {
    public int value__;
    public static AlgId CALG_RSA_KEYX;
    public static AlgId CALG_DH_SF;
    public static AlgId CALG_DH_EPHEM;
    public static AlgId CALG_RC2;
    public static AlgId CALG_RC4;
    public static AlgId CALG_DES;
    public static AlgId CALG_3DES;
}
internal class Internal.Cryptography.Pal.Windows.DecryptorPalWindows : DecryptorPal {
    private SafeCryptMsgHandle _hCryptMsg;
    private AlgorithmIdentifierAsn _contentEncryptionAlgorithm;
    private DecryptorPalWindows(SafeCryptMsgHandle hCryptMsg, RecipientInfoCollection recipientInfos, AlgorithmIdentifierAsn contentEncryptionAlgorithm);
    public sealed virtual void Dispose();
    internal static DecryptorPalWindows Decode(ReadOnlySpan`1<byte> encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    private static RecipientInfoCollection CreateRecipientInfos(SafeCryptMsgHandle hCryptMsg);
    private static IEnumerable`1<RecipientInfo> ToRecipientInfosForThisIndex(SafeHandle pCmsgCmsRecipientInfoMemory, int index);
    public sealed virtual ContentInfo TryDecrypt(RecipientInfo recipientInfo, X509Certificate2 cert, AsymmetricAlgorithm privateKey, X509Certificate2Collection originatorCerts, X509Certificate2Collection extraStore, Exception& exception);
    private static Exception TryGetKeySpecForCertificate(X509Certificate2 cert, CryptKeySpec& keySpec);
    private Exception TryDecryptTrans(KeyTransRecipientInfo recipientInfo, SafeProvOrNCryptKeyHandle hKey, CryptKeySpec keySpec);
    private Exception TryDecryptAgree(KeyAgreeRecipientInfo keyAgreeRecipientInfo, SafeProvOrNCryptKeyHandle hKey, CryptKeySpec keySpec, X509Certificate2Collection originatorCerts, X509Certificate2Collection extraStore);
    private Exception TryExecuteDecryptAgree(CMSG_CTRL_KEY_AGREE_DECRYPT_PARA& decryptPara);
}
internal class Internal.Cryptography.Pal.Windows.HeapBlockRetainer : object {
    private List`1<object> _mustLive;
    private List`1<SafeHeapAllocHandle> _blocks;
    public IntPtr Alloc(int cbSize);
    public IntPtr Alloc(int howMany, int cbElement);
    public IntPtr AllocAsciiString(string s);
    public IntPtr AllocBytes(Byte[] data);
    public void KeepAlive(object o);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.Windows.HelpersWindows : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(ErrorCode errorCode);
    [ExtensionAttribute]
public static string ToStringAnsi(IntPtr psz);
    [ExtensionAttribute]
public static Byte[] GetMsgParamAsByteArray(SafeCryptMsgHandle hCryptMsg, CryptMsgParamType paramType, int index);
    [ExtensionAttribute]
public static SafeHandle GetMsgParamAsMemory(SafeCryptMsgHandle hCryptMsg, CryptMsgParamType paramType, int index);
    [ExtensionAttribute]
public static Byte[] ToByteArray(DATA_BLOB blob);
    [ExtensionAttribute]
public static CryptMsgType GetMessageType(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static int GetVersion(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static ContentInfo GetContentInfo(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static X509Certificate2Collection GetOriginatorCerts(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static AlgId ToAlgId(string oidValue);
    [ExtensionAttribute]
public static SafeCertContextHandle CreateCertContextHandle(X509Certificate2 cert);
    [ExtensionAttribute]
public static Byte[] GetSubjectKeyIdentifer(SafeCertContextHandle hCertContext);
    [ExtensionAttribute]
public static SubjectIdentifier ToSubjectIdentifier(CERT_ID certId);
    [ExtensionAttribute]
public static SubjectIdentifierOrKey ToSubjectIdentifierOrKey(CERT_ID certId);
    [ExtensionAttribute]
public static SubjectIdentifierOrKey ToSubjectIdentifierOrKey(CERT_PUBLIC_KEY_INFO publicKeyInfo);
    [ExtensionAttribute]
public static AlgorithmIdentifier ToAlgorithmIdentifier(CRYPT_ALGORITHM_IDENTIFIER cryptAlgorithmIdentifer);
    [ExtensionAttribute]
public static CryptographicAttributeObjectCollection GetUnprotectedAttributes(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static CspParameters GetProvParameters(SafeProvOrNCryptKeyHandle handle);
    private static string GetStringProvParam(SafeProvOrNCryptKeyHandle handle, CryptProvParam dwParam, Span`1& buf, Byte[]& rented, int clearLen);
    private static CryptographicAttributeObjectCollection ToCryptographicAttributeObjectCollection(CRYPT_ATTRIBUTES* pCryptAttributes);
    private static void AddCryptAttribute(CryptographicAttributeObjectCollection collection, CRYPT_ATTRIBUTE* pCryptAttribute);
}
internal class Internal.Cryptography.Pal.Windows.KeyAgreeRecipientInfoPalWindows : KeyAgreeRecipientInfoPal {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubIndex>k__BackingField;
    private SafeHandle _pCmsgCmsRecipientInfoMemory;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
    public DateTime Date { get; }
    public CryptographicAttributeObject OtherKeyAttribute { get; }
    internal int Index { get; }
    internal int SubIndex { get; }
    internal KeyAgreeRecipientInfoPalWindows(SafeHandle pCmsgCmsRecipientInfoMemory, int index, int subIndex);
    public sealed virtual int get_Version();
    public sealed virtual SubjectIdentifier get_RecipientIdentifier();
    public sealed virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public sealed virtual Byte[] get_EncryptedKey();
    public sealed virtual SubjectIdentifierOrKey get_OriginatorIdentifierOrKey();
    public sealed virtual DateTime get_Date();
    public sealed virtual CryptographicAttributeObject get_OtherKeyAttribute();
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal int get_SubIndex();
    internal T WithCmsgCmsRecipientInfo(KeyAgreeReceiver`1<T> receiver);
    [CompilerGeneratedAttribute]
private SubjectIdentifier <get_RecipientIdentifier>b__4_0(CMSG_KEY_AGREE_RECIPIENT_INFO* recipient);
    [CompilerGeneratedAttribute]
private Byte[] <get_EncryptedKey>b__8_0(CMSG_KEY_AGREE_RECIPIENT_INFO* recipient);
    [CompilerGeneratedAttribute]
private DateTime <get_Date>b__12_0(CMSG_KEY_AGREE_RECIPIENT_INFO* recipient);
    [CompilerGeneratedAttribute]
private CryptographicAttributeObject <get_OtherKeyAttribute>b__14_0(CMSG_KEY_AGREE_RECIPIENT_INFO* recipient);
}
internal class Internal.Cryptography.Pal.Windows.KeyTransRecipientInfoPalWindows : KeyTransRecipientInfoPal {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    private SafeHandle _pCmsgCmsRecipientInfoMemory;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    internal int Index { get; }
    internal KeyTransRecipientInfoPalWindows(SafeHandle pCmsgCmsRecipientInfoMemory, int index);
    public sealed virtual int get_Version();
    public sealed virtual SubjectIdentifier get_RecipientIdentifier();
    public sealed virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public sealed virtual Byte[] get_EncryptedKey();
    [CompilerGeneratedAttribute]
internal int get_Index();
    private T WithCmsgCmsRecipientInfo(KeyTransReceiver`1<T> receiver);
}
internal class Internal.Cryptography.Pal.Windows.PkcsPalWindows : PkcsPal {
    public sealed virtual DecryptorPal Decode(ReadOnlySpan`1<byte> encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    public sealed virtual Oid GetEncodedMessageType(ReadOnlySpan`1<byte> encodedMessage);
    public sealed virtual void AddCertsFromStoreForDecryption(X509Certificate2Collection certs);
    public sealed virtual Exception CreateRecipientsNotFoundException();
    public sealed virtual Exception CreateRecipientInfosAfterEncryptException();
    public sealed virtual Exception CreateDecryptAfterEncryptException();
    public sealed virtual Exception CreateDecryptTwiceException();
    public sealed virtual Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate);
    public virtual T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent);
    public virtual T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent);
    private T GetPrivateKey(X509Certificate2 certificate, bool silent, bool preferNCrypt);
    internal static SafeProvOrNCryptKeyHandle GetCertificatePrivateKey(X509Certificate2 cert, bool silent, bool preferNCrypt, CryptKeySpec& keySpec, Exception& exception);
    public sealed virtual Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes);
    private static void ReencodeIfUsingIndefiniteLengthEncodingOnOuterStructure(Byte[]& encodedContent);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.PkcsHelpers : object {
    private static bool s_oidIsInitOnceOnly;
    private static PkcsHelpers();
    private static bool DetectInitOnlyOid();
    internal static HashAlgorithmName GetDigestAlgorithm(Oid oid);
    internal static HashAlgorithmName GetDigestAlgorithm(string oidValue, bool forVerification);
    internal static string GetOidFromHashAlgorithm(HashAlgorithmName algName);
    [ExtensionAttribute]
public static Byte[] Resize(Byte[] a, int size);
    public static void RemoveAt(T[]& arr, int idx);
    public static AttributeAsn[] NormalizeAttributeSet(AttributeAsn[] setItems, Action`1<Byte[]> encodedValueProcessor);
    internal static Byte[] EncodeContentInfo(ReadOnlyMemory`1<byte> content, string contentType, AsnEncodingRules ruleSet);
    [ExtensionAttribute]
public static CmsRecipientCollection DeepCopy(CmsRecipientCollection recipients);
    [ExtensionAttribute]
public static Byte[] UnicodeToOctetString(string s);
    [ExtensionAttribute]
public static string OctetStringToUnicode(Byte[] octets);
    public static X509Certificate2Collection GetStoreCertificates(StoreName storeName, StoreLocation storeLocation, bool openExistingOnly);
    [ExtensionAttribute]
public static X509Certificate2 TryFindMatchingCertificate(X509Certificate2Collection certs, SubjectIdentifier recipientIdentifier);
    internal static bool AreByteArraysEqual(Byte[] ba1, Byte[] ba2);
    [ExtensionAttribute]
internal static Byte[] ToSkiBytes(string skiString);
    [ExtensionAttribute]
public static string ToSkiString(Byte[] skiBytes);
    [ExtensionAttribute]
public static string ToBigEndianHex(ReadOnlySpan`1<byte> bytes);
    [ExtensionAttribute]
internal static Byte[] ToSerialBytes(string serialString);
    [ExtensionAttribute]
public static string ToSerialString(Byte[] serialBytes);
    private static string ToUpperHexString(ReadOnlySpan`1<byte> ba);
    [ExtensionAttribute]
private static Byte[] UpperHexStringToByteArray(string normalizedString);
    private static byte UpperHexCharToNybble(char c);
    public static Pkcs9AttributeObject CreateBestPkcs9AttributeObjectAvailable(Oid oid, Byte[] encodedAttribute);
    private static T Upgrade(Pkcs9AttributeObject basicAttribute);
    [ExtensionAttribute]
internal static Byte[] OneShot(ICryptoTransform transform, Byte[] data);
    [ExtensionAttribute]
internal static Byte[] OneShot(ICryptoTransform transform, Byte[] data, int offset, int length);
    public static void EnsureSingleBerValue(ReadOnlySpan`1<byte> source);
    public static int FirstBerValueLength(ReadOnlySpan`1<byte> source);
    public static ReadOnlyMemory`1<byte> DecodeOctetStringAsMemory(ReadOnlyMemory`1<byte> encodedOctetString);
    public static Byte[] DecodeOctetString(ReadOnlyMemory`1<byte> encodedOctets);
    public static Byte[] EncodeOctetString(Byte[] octets);
    public static Byte[] EncodeUtcTime(DateTime utcTime);
    public static DateTime DecodeUtcTime(Byte[] encodedUtcTime);
    public static string DecodeOid(ReadOnlySpan`1<byte> encodedOid);
    public static bool TryGetRsaOaepEncryptionPadding(Nullable`1<ReadOnlyMemory`1<byte>> parameters, RSAEncryptionPadding& rsaEncryptionPadding, Exception& exception);
    [ExtensionAttribute]
public static Oid CopyOid(Oid oid);
}
internal abstract class Internal.Cryptography.PkcsPal : object {
    private protected static Byte[] s_rsaOaepSha1Parameters;
    private protected static Byte[] s_rsaOaepSha256Parameters;
    private protected static Byte[] s_rsaOaepSha384Parameters;
    private protected static Byte[] s_rsaOaepSha512Parameters;
    private protected static Byte[] s_rsaPkcsParameters;
    private static PkcsPal s_instance;
    public static PkcsPal Instance { get; }
    private static PkcsPal();
    public abstract virtual Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes);
    public abstract virtual DecryptorPal Decode(ReadOnlySpan`1<byte> encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    public abstract virtual Oid GetEncodedMessageType(ReadOnlySpan`1<byte> encodedMessage);
    public abstract virtual void AddCertsFromStoreForDecryption(X509Certificate2Collection certs);
    public abstract virtual Exception CreateRecipientsNotFoundException();
    public abstract virtual Exception CreateRecipientInfosAfterEncryptException();
    public abstract virtual Exception CreateDecryptAfterEncryptException();
    public abstract virtual Exception CreateDecryptTwiceException();
    public abstract virtual Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate);
    public abstract virtual T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent);
    public abstract virtual T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent);
    public static PkcsPal get_Instance();
}
internal abstract class Internal.Cryptography.RecipientInfoPal : object {
    public Byte[] EncryptedKey { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public int Version { get; }
    public abstract virtual Byte[] get_EncryptedKey();
    public abstract virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public abstract virtual SubjectIdentifier get_RecipientIdentifier();
    public abstract virtual int get_Version();
}
internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Win32.SafeHandles.SafeCertContextHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeCertContextHandle(IntPtr handle);
    internal CERT_CONTEXT* DangerousGetCertContext();
    public sealed virtual bool get_IsInvalid();
    protected sealed virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeCryptMsgHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected sealed virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
internal class Microsoft.Win32.SafeHandles.SafeHeapAllocHandle : SafeBuffer {
    private static IntPtr s_hHeap;
    private static SafeHeapAllocHandle();
    internal static SafeHeapAllocHandle Alloc(int size);
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class Microsoft.Win32.SafeHandles.SafeProvOrNCryptKeyHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeProvOrNCryptKeyHandle(IntPtr handle, bool ownsHandle);
    public sealed virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeProvOrNCryptKeyHandleUwp : SafeProvOrNCryptKeyHandle {
    private bool _isNcrypt;
    private SafeHandle _parentHandle;
    internal SafeProvOrNCryptKeyHandleUwp(IntPtr handle, SafeHandle parentHandle);
    internal SafeProvOrNCryptKeyHandleUwp(IntPtr handle, bool ownsHandle, bool isNcrypt);
    protected sealed virtual bool ReleaseHandle();
}
internal class System.Buffers.PointerMemoryManager`1 : MemoryManager`1<T> {
    private Void* _pointer;
    private int _length;
    internal PointerMemoryManager`1(Void* pointer, int length);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Formats.Asn1.AsnValueReader : ValueType {
    private static Byte[] s_singleByte;
    private ReadOnlySpan`1<byte> _span;
    private AsnEncodingRules _ruleSet;
    internal bool HasData { get; }
    internal AsnValueReader(ReadOnlySpan`1<byte> span, AsnEncodingRules ruleSet);
    private static AsnValueReader();
    internal bool get_HasData();
    internal void ThrowIfNotEmpty();
    internal Asn1Tag PeekTag();
    internal ReadOnlySpan`1<byte> PeekEncodedValue();
    internal ReadOnlySpan`1<byte> ReadEncodedValue();
    internal bool ReadBoolean(Nullable`1<Asn1Tag> expectedTag);
    internal BigInteger ReadInteger(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadInt32(Int32& value, Nullable`1<Asn1Tag> expectedTag);
    internal ReadOnlySpan`1<byte> ReadIntegerBytes(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadPrimitiveBitString(Int32& unusedBitCount, ReadOnlySpan`1& value, Nullable`1<Asn1Tag> expectedTag);
    internal Byte[] ReadBitString(Int32& unusedBitCount, Nullable`1<Asn1Tag> expectedTag);
    internal TFlagsEnum ReadNamedBitListValue(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadPrimitiveOctetString(ReadOnlySpan`1& value, Nullable`1<Asn1Tag> expectedTag);
    internal Byte[] ReadOctetString(Nullable`1<Asn1Tag> expectedTag);
    internal string ReadObjectIdentifier(Nullable`1<Asn1Tag> expectedTag);
    internal AsnValueReader ReadSequence(Nullable`1<Asn1Tag> expectedTag);
    internal AsnValueReader ReadSetOf(Nullable`1<Asn1Tag> expectedTag);
    internal DateTimeOffset ReadUtcTime(Nullable`1<Asn1Tag> expectedTag);
    internal DateTimeOffset ReadGeneralizedTime(Nullable`1<Asn1Tag> expectedTag);
    internal string ReadCharacterString(UniversalTagNumber encodingType, Nullable`1<Asn1Tag> expectedTag);
}
[ExtensionAttribute]
internal static class System.Formats.Asn1.AsnWriterExtensions : object {
    [ExtensionAttribute]
internal static void WriteEncodedValueForCrypto(AsnWriter writer, ReadOnlySpan`1<byte> value);
    [ExtensionAttribute]
internal static void WriteObjectIdentifierForCrypto(AsnWriter writer, string value);
    [ExtensionAttribute]
internal static ArraySegment`1<byte> RentAndEncode(AsnWriter writer);
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal static class System.Obsoletions : object {
    internal static string SharedUrlFormat;
    internal static string SystemTextEncodingUTF7Message;
    internal static string SystemTextEncodingUTF7DiagId;
    internal static string PrincipalPermissionAttributeMessage;
    internal static string PrincipalPermissionAttributeDiagId;
    internal static string CodeAccessSecurityMessage;
    internal static string CodeAccessSecurityDiagId;
    internal static string ConstrainedExecutionRegionMessage;
    internal static string ConstrainedExecutionRegionDiagId;
    internal static string GlobalAssemblyCacheMessage;
    internal static string GlobalAssemblyCacheDiagId;
    internal static string ThreadAbortMessage;
    internal static string ThreadAbortDiagId;
    internal static string DefaultCryptoAlgorithmsMessage;
    internal static string DefaultCryptoAlgorithmsDiagId;
    internal static string CreatePdbGeneratorMessage;
    internal static string CreatePdbGeneratorDiagId;
    internal static string AuthenticationManagerMessage;
    internal static string AuthenticationManagerDiagId;
    internal static string RemotingApisMessage;
    internal static string RemotingApisDiagId;
    internal static string BinaryFormatterMessage;
    internal static string BinaryFormatterDiagId;
    internal static string CodeBaseMessage;
    internal static string CodeBaseDiagId;
    internal static string EscapeUriStringMessage;
    internal static string EscapeUriStringDiagId;
    internal static string WebRequestMessage;
    internal static string WebRequestDiagId;
    internal static string DisablePrivateReflectionAttributeMessage;
    internal static string DisablePrivateReflectionAttributeDiagId;
    internal static string GetContextInfoMessage;
    internal static string GetContextInfoDiagId;
    internal static string StrongNameKeyPairMessage;
    internal static string StrongNameKeyPairDiagId;
    internal static string ReflectionOnlyLoadingMessage;
    internal static string ReflectionOnlyLoadingDiagId;
    internal static string RuntimeEnvironmentMessage;
    internal static string RuntimeEnvironmentDiagId;
    internal static string JsonSerializerOptionsIgnoreNullValuesMessage;
    internal static string JsonSerializerOptionsIgnoreNullValuesDiagId;
    internal static string DerivedCryptographicTypesMessage;
    internal static string DerivedCryptographicTypesDiagId;
    internal static string RijndaelMessage;
    internal static string RijndaelDiagId;
    internal static string RNGCryptoServiceProviderMessage;
    internal static string RNGCryptoServiceProviderDiagId;
    internal static string AppDomainCreateUnloadMessage;
    internal static string AppDomainCreateUnloadDiagId;
    internal static string SuppressIldasmAttributeMessage;
    internal static string SuppressIldasmAttributeDiagId;
    internal static string X509CertificateImmutableMessage;
    internal static string X509CertificateImmutableDiagId;
    internal static string PublicKeyPropertyMessage;
    internal static string PublicKeyPropertyDiagId;
    internal static string X509CertificatePrivateKeyMessage;
    internal static string X509CertificatePrivateKeyDiagId;
    internal static string ProduceLegacyHmacValuesMessage;
    internal static string ProduceLegacyHmacValuesDiagId;
    internal static string UseManagedSha1Message;
    internal static string UseManagedSha1DiagId;
    internal static string CryptoConfigEncodeOIDMessage;
    internal static string CryptoConfigEncodeOIDDiagId;
    internal static string CorruptedStateRecoveryMessage;
    internal static string CorruptedStateRecoveryDiagId;
    internal static string Rfc2898CryptDeriveKeyMessage;
    internal static string Rfc2898CryptDeriveKeyDiagId;
    internal static string CmsSignerCspParamsCtorMessage;
    internal static string CmsSignerCspParamsCtorDiagId;
    internal static string SignerInfoCounterSigMessage;
    internal static string SignerInfoCounterSigDiagId;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
internal class System.Security.Cryptography.Asn1.AlgorithmIdentifierAsn : ValueType {
    internal string Algorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Parameters;
    internal static ReadOnlyMemory`1<byte> ExplicitDerNull;
    private static AlgorithmIdentifierAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static AlgorithmIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static AlgorithmIdentifierAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    internal bool Equals(AlgorithmIdentifierAsn& other);
    [IsReadOnlyAttribute]
internal bool HasNullEquivalentParameters();
    internal static bool RepresentsNull(Nullable`1<ReadOnlyMemory`1<byte>> parameters);
}
internal class System.Security.Cryptography.Asn1.AttributeAsn : ValueType {
    internal string AttrType;
    internal ReadOnlyMemory`1[] AttrValues;
    public AttributeAsn(AsnEncodedData attribute);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static AttributeAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static AttributeAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.DigestInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn DigestAlgorithm;
    internal ReadOnlyMemory`1<byte> Digest;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static DigestInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static DigestInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, DigestInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, DigestInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, DigestInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.DirectoryStringAsn : ValueType {
    internal string TeletexString;
    internal string PrintableString;
    internal Nullable`1<ReadOnlyMemory`1<byte>> UniversalString;
    internal string Utf8String;
    internal string BmpString;
    internal void Encode(AsnWriter writer);
    internal static DirectoryStringAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, DirectoryStringAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, DirectoryStringAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.EdiPartyNameAsn : ValueType {
    internal Nullable`1<DirectoryStringAsn> NameAssigner;
    internal DirectoryStringAsn PartyName;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EdiPartyNameAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EdiPartyNameAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EdiPartyNameAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EdiPartyNameAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EdiPartyNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.EncryptedPrivateKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn EncryptionAlgorithm;
    internal ReadOnlyMemory`1<byte> EncryptedData;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EncryptedPrivateKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncryptedPrivateKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.GeneralNameAsn : ValueType {
    internal Nullable`1<OtherNameAsn> OtherName;
    internal string Rfc822Name;
    internal string DnsName;
    internal Nullable`1<ReadOnlyMemory`1<byte>> X400Address;
    internal Nullable`1<ReadOnlyMemory`1<byte>> DirectoryName;
    internal Nullable`1<EdiPartyNameAsn> EdiPartyName;
    internal string Uri;
    internal Nullable`1<ReadOnlyMemory`1<byte>> IPAddress;
    internal string RegisteredId;
    internal void Encode(AsnWriter writer);
    internal static GeneralNameAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, GeneralNameAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, GeneralNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.OaepParamsAsn : ValueType {
    internal AlgorithmIdentifierAsn HashFunc;
    internal AlgorithmIdentifierAsn MaskGenFunc;
    internal AlgorithmIdentifierAsn PSourceFunc;
    private static ReadOnlySpan`1<byte> DefaultHashFunc { get; }
    private static ReadOnlySpan`1<byte> DefaultMaskGenFunc { get; }
    private static ReadOnlySpan`1<byte> DefaultPSourceFunc { get; }
    private static ReadOnlySpan`1<byte> get_DefaultHashFunc();
    private static ReadOnlySpan`1<byte> get_DefaultMaskGenFunc();
    private static ReadOnlySpan`1<byte> get_DefaultPSourceFunc();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OaepParamsAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OaepParamsAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, OaepParamsAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OaepParamsAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OaepParamsAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.OtherNameAsn : ValueType {
    internal string TypeId;
    internal ReadOnlyMemory`1<byte> Value;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OtherNameAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OtherNameAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, OtherNameAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherNameAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PBEParameter : ValueType {
    internal ReadOnlyMemory`1<byte> Salt;
    internal int IterationCount;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PBEParameter Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBEParameter Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PBEParameter& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBEParameter& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBEParameter& decoded);
}
internal class System.Security.Cryptography.Asn1.PBES2Params : ValueType {
    internal AlgorithmIdentifierAsn KeyDerivationFunc;
    internal AlgorithmIdentifierAsn EncryptionScheme;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PBES2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBES2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PBES2Params& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBES2Params& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBES2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2Params : ValueType {
    internal Pbkdf2SaltChoice Salt;
    internal int IterationCount;
    internal Nullable`1<int> KeyLength;
    internal AlgorithmIdentifierAsn Prf;
    private static ReadOnlySpan`1<byte> DefaultPrf { get; }
    private static ReadOnlySpan`1<byte> get_DefaultPrf();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Pbkdf2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Pbkdf2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2Params& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Pbkdf2Params& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Pbkdf2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2SaltChoice : ValueType {
    internal Nullable`1<ReadOnlyMemory`1<byte>> Specified;
    internal Nullable`1<AlgorithmIdentifierAsn> OtherSource;
    internal void Encode(AsnWriter writer);
    internal static Pbkdf2SaltChoice Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2SaltChoice& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2SaltChoice& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.CertBagAsn : ValueType {
    internal string CertId;
    internal ReadOnlyMemory`1<byte> CertValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static CertBagAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static CertBagAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CertBagAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertBagAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertBagAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.MacData : ValueType {
    internal DigestInfoAsn Mac;
    internal ReadOnlyMemory`1<byte> MacSalt;
    internal int IterationCount;
    private static ReadOnlySpan`1<byte> DefaultIterationCount { get; }
    private static ReadOnlySpan`1<byte> get_DefaultIterationCount();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static MacData Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static MacData Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, MacData& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, MacData& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, MacData& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.PfxAsn : ValueType {
    internal int Version;
    internal ContentInfoAsn AuthSafe;
    internal Nullable`1<MacData> MacData;
    internal bool VerifyMac(ReadOnlySpan`1<char> macPassword, ReadOnlySpan`1<byte> authSafeContents);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PfxAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PfxAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PfxAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PfxAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PfxAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.SafeBagAsn : ValueType {
    internal string BagId;
    internal ReadOnlyMemory`1<byte> BagValue;
    internal AttributeAsn[] BagAttributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SafeBagAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SafeBagAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SafeBagAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SafeBagAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SafeBagAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs7.ContentInfoAsn : ValueType {
    internal string ContentType;
    internal ReadOnlyMemory`1<byte> Content;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static ContentInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static ContentInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ContentInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ContentInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs7.EncryptedContentInfoAsn : ValueType {
    internal string ContentType;
    internal AlgorithmIdentifierAsn ContentEncryptionAlgorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> EncryptedContent;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EncryptedContentInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncryptedContentInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EncryptedContentInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedContentInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs7.EncryptedDataAsn : ValueType {
    internal int Version;
    internal EncryptedContentInfoAsn EncryptedContentInfo;
    internal AttributeAsn[] UnprotectedAttributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EncryptedDataAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncryptedDataAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EncryptedDataAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedDataAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedDataAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PrivateKeyInfoAsn : ValueType {
    internal int Version;
    internal AlgorithmIdentifierAsn PrivateKeyAlgorithm;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal AttributeAsn[] Attributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PrivateKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PrivateKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PssParamsAsn : ValueType {
    internal AlgorithmIdentifierAsn HashAlgorithm;
    internal AlgorithmIdentifierAsn MaskGenAlgorithm;
    internal int SaltLength;
    internal int TrailerField;
    private static ReadOnlySpan`1<byte> DefaultHashAlgorithm { get; }
    private static ReadOnlySpan`1<byte> DefaultMaskGenAlgorithm { get; }
    private static ReadOnlySpan`1<byte> DefaultSaltLength { get; }
    private static ReadOnlySpan`1<byte> DefaultTrailerField { get; }
    private static ReadOnlySpan`1<byte> get_DefaultHashAlgorithm();
    private static ReadOnlySpan`1<byte> get_DefaultMaskGenAlgorithm();
    private static ReadOnlySpan`1<byte> get_DefaultSaltLength();
    private static ReadOnlySpan`1<byte> get_DefaultTrailerField();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PssParamsAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PssParamsAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PssParamsAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PssParamsAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PssParamsAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Rc2CbcParameters : ValueType {
    internal int Rc2Version;
    internal ReadOnlyMemory`1<byte> Iv;
    private static Byte[] s_rc2EkbEncoding;
    internal Rc2CbcParameters(ReadOnlyMemory`1<byte> iv, int keySize);
    private static Rc2CbcParameters();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rc2CbcParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rc2CbcParameters Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Rc2CbcParameters& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rc2CbcParameters& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rc2CbcParameters& decoded);
    internal int GetEffectiveKeyBits();
}
internal class System.Security.Cryptography.Asn1.SubjectPublicKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn Algorithm;
    internal ReadOnlyMemory`1<byte> SubjectPublicKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SubjectPublicKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SubjectPublicKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.X509ExtensionAsn : ValueType {
    internal string ExtnId;
    internal bool Critical;
    internal ReadOnlyMemory`1<byte> ExtnValue;
    private static ReadOnlySpan`1<byte> DefaultCritical { get; }
    public X509ExtensionAsn(X509Extension extension);
    private static ReadOnlySpan`1<byte> get_DefaultCritical();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static X509ExtensionAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static X509ExtensionAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, X509ExtensionAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, X509ExtensionAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, X509ExtensionAsn& decoded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptographicAttributeObject : object {
    [CompilerGeneratedAttribute]
private AsnEncodedDataCollection <Values>k__BackingField;
    private Oid _oid;
    public Oid Oid { get; }
    public AsnEncodedDataCollection Values { get; }
    public CryptographicAttributeObject(Oid oid);
    public CryptographicAttributeObject(Oid oid, AsnEncodedDataCollection values);
    public Oid get_Oid();
    [CompilerGeneratedAttribute]
public AsnEncodedDataCollection get_Values();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.CryptographicAttributeObjectCollection : object {
    private List`1<CryptographicAttributeObject> _list;
    public CryptographicAttributeObject Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public CryptographicAttributeObjectCollection(CryptographicAttributeObject attribute);
    public int Add(AsnEncodedData asnEncodedData);
    public int Add(CryptographicAttributeObject attribute);
    internal void AddWithoutMerge(CryptographicAttributeObject attribute);
    public void Remove(CryptographicAttributeObject attribute);
    public CryptographicAttributeObject get_Item(int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public CryptographicAttributeObjectEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(CryptographicAttributeObject[] array, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptographicAttributeObjectEnumerator : object {
    private CryptographicAttributeObjectCollection _attributes;
    private int _current;
    public CryptographicAttributeObject Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal CryptographicAttributeObjectEnumerator(CryptographicAttributeObjectCollection attributes);
    public CryptographicAttributeObject get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal static class System.Security.Cryptography.CryptoPool : object {
    internal static int ClearAll;
    internal static Byte[] Rent(int minimumLength);
    internal static void Return(ArraySegment`1<byte> arraySegment);
    internal static void Return(Byte[] array, int clearSize);
}
internal static class System.Security.Cryptography.KdfWorkLimiter : object {
    [ThreadStaticAttribute]
private static State t_state;
    internal static void SetIterationLimit(ulong workLimit);
    internal static bool WasWorkLimitExceeded();
    internal static void ResetIterationLimit();
    internal static void RecordIterations(int workCount);
    internal static void RecordIterations(long workCount);
}
internal static class System.Security.Cryptography.KeyFormatHelper : object {
    internal static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static AsnWriter WritePkcs8(AsnWriter algorithmIdentifierWriter, AsnWriter privateKeyWriter, AsnWriter attributesWriter);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    private static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<char> newPassword, PbeParameters pbeParameters);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<byte> newPasswordBytes, PbeParameters pbeParameters);
}
internal static class System.Security.Cryptography.Oids : object {
    internal static string Rc2Cbc;
    internal static string Rc4;
    internal static string TripleDesCbc;
    internal static string DesCbc;
    internal static string Aes128Cbc;
    internal static string Aes192Cbc;
    internal static string Aes256Cbc;
    internal static string Dsa;
    internal static string Rsa;
    internal static string RsaOaep;
    internal static string RsaPss;
    internal static string RsaPkcs1Md5;
    internal static string RsaPkcs1Sha1;
    internal static string RsaPkcs1Sha256;
    internal static string RsaPkcs1Sha384;
    internal static string RsaPkcs1Sha512;
    internal static string Esdh;
    internal static string EcDiffieHellman;
    internal static string DiffieHellman;
    internal static string DiffieHellmanPkcs3;
    internal static string SigningTime;
    internal static string ContentType;
    internal static string DocumentDescription;
    internal static string MessageDigest;
    internal static string CounterSigner;
    internal static string SigningCertificate;
    internal static string SigningCertificateV2;
    internal static string DocumentName;
    internal static string LocalKeyId;
    internal static string EnrollCertTypeExtension;
    internal static string UserPrincipalName;
    internal static string CertificateTemplate;
    internal static string ApplicationCertPolicies;
    internal static string AuthorityInformationAccess;
    internal static string OcspEndpoint;
    internal static string CertificateAuthorityIssuers;
    internal static string Pkcs9ExtensionRequest;
    internal static string CmsRc2Wrap;
    internal static string Cms3DesWrap;
    internal static string Pkcs7Data;
    internal static string Pkcs7Signed;
    internal static string Pkcs7Enveloped;
    internal static string Pkcs7SignedEnveloped;
    internal static string Pkcs7Hashed;
    internal static string Pkcs7Encrypted;
    internal static string Md5;
    internal static string Sha1;
    internal static string Sha256;
    internal static string Sha384;
    internal static string Sha512;
    internal static string DsaWithSha1;
    internal static string DsaWithSha256;
    internal static string DsaWithSha384;
    internal static string DsaWithSha512;
    internal static string EcPrimeField;
    internal static string EcChar2Field;
    internal static string EcChar2TrinomialBasis;
    internal static string EcChar2PentanomialBasis;
    internal static string EcPublicKey;
    internal static string ECDsaWithSha1;
    internal static string ECDsaWithSha256;
    internal static string ECDsaWithSha384;
    internal static string ECDsaWithSha512;
    internal static string Mgf1;
    internal static string PSpecified;
    internal static string NoSignature;
    internal static string CommonName;
    internal static string Organization;
    internal static string OrganizationalUnit;
    internal static string EmailAddress;
    internal static string BasicConstraints;
    internal static string SubjectKeyIdentifier;
    internal static string KeyUsage;
    internal static string SubjectAltName;
    internal static string IssuerAltName;
    internal static string BasicConstraints2;
    internal static string CrlDistributionPoints;
    internal static string CertPolicies;
    internal static string AnyCertPolicy;
    internal static string CertPolicyMappings;
    internal static string CertPolicyConstraints;
    internal static string EnhancedKeyUsage;
    internal static string InhibitAnyPolicyExtension;
    internal static string TstInfo;
    internal static string TimeStampingPurpose;
    private static string Pkcs12Prefix;
    private static string Pkcs12PbePrefix;
    internal static string Pkcs12PbeWithShaAnd3Key3Des;
    internal static string Pkcs12PbeWithShaAnd2Key3Des;
    internal static string Pkcs12PbeWithShaAnd128BitRC2;
    internal static string Pkcs12PbeWithShaAnd40BitRC2;
    private static string Pkcs12BagTypesPrefix;
    internal static string Pkcs12KeyBag;
    internal static string Pkcs12ShroudedKeyBag;
    internal static string Pkcs12CertBag;
    internal static string Pkcs12CrlBag;
    internal static string Pkcs12SecretBag;
    internal static string Pkcs12SafeContentsBag;
    internal static string Pkcs12X509CertBagType;
    internal static string Pkcs12SdsiCertBagType;
    private static string Pkcs5Prefix;
    internal static string PbeWithMD5AndDESCBC;
    internal static string PbeWithMD5AndRC2CBC;
    internal static string PbeWithSha1AndDESCBC;
    internal static string PbeWithSha1AndRC2CBC;
    internal static string Pbkdf2;
    internal static string PasswordBasedEncryptionScheme2;
    private static string RsaDsiDigestAlgorithmPrefix;
    internal static string HmacWithSha1;
    internal static string HmacWithSha256;
    internal static string HmacWithSha384;
    internal static string HmacWithSha512;
    internal static string secp256r1;
    internal static string secp384r1;
    internal static string secp521r1;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _rsaOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _ecPublicKeyOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _tripleDesCbcOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _aes256CbcOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _secp256r1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _secp384r1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _secp521r1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _sha256Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _pkcs7DataOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _contentTypeOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _documentDescriptionOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _documentNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _localKeyIdOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _messageDigestOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _signingTimeOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _pkcs9ExtensionRequestOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _basicConstraints2Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _enhancedKeyUsageOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _keyUsageOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _subjectKeyIdentifierOid;
    internal static Oid RsaOid { get; }
    internal static Oid EcPublicKeyOid { get; }
    internal static Oid TripleDesCbcOid { get; }
    internal static Oid Aes256CbcOid { get; }
    internal static Oid secp256r1Oid { get; }
    internal static Oid secp384r1Oid { get; }
    internal static Oid secp521r1Oid { get; }
    internal static Oid Sha256Oid { get; }
    internal static Oid Pkcs7DataOid { get; }
    internal static Oid ContentTypeOid { get; }
    internal static Oid DocumentDescriptionOid { get; }
    internal static Oid DocumentNameOid { get; }
    internal static Oid LocalKeyIdOid { get; }
    internal static Oid MessageDigestOid { get; }
    internal static Oid SigningTimeOid { get; }
    internal static Oid Pkcs9ExtensionRequestOid { get; }
    internal static Oid BasicConstraints2Oid { get; }
    internal static Oid EnhancedKeyUsageOid { get; }
    internal static Oid KeyUsageOid { get; }
    internal static Oid SubjectKeyIdentifierOid { get; }
    internal static Oid get_RsaOid();
    internal static Oid get_EcPublicKeyOid();
    internal static Oid get_TripleDesCbcOid();
    internal static Oid get_Aes256CbcOid();
    internal static Oid get_secp256r1Oid();
    internal static Oid get_secp384r1Oid();
    internal static Oid get_secp521r1Oid();
    internal static Oid get_Sha256Oid();
    internal static Oid get_Pkcs7DataOid();
    internal static Oid get_ContentTypeOid();
    internal static Oid get_DocumentDescriptionOid();
    internal static Oid get_DocumentNameOid();
    internal static Oid get_LocalKeyIdOid();
    internal static Oid get_MessageDigestOid();
    internal static Oid get_SigningTimeOid();
    internal static Oid get_Pkcs9ExtensionRequestOid();
    internal static Oid get_BasicConstraints2Oid();
    internal static Oid get_EnhancedKeyUsageOid();
    internal static Oid get_KeyUsageOid();
    internal static Oid get_SubjectKeyIdentifierOid();
    private static Oid InitializeOid(string oidValue);
}
internal static class System.Security.Cryptography.PasswordBasedEncryption : object {
    internal static int IterationLimit;
    private static CryptographicException AlgorithmKdfRequiresChars(string algId);
    internal static void ValidatePbeParameters(PbeParameters pbeParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes);
    internal static int Decrypt(AlgorithmIdentifierAsn& algorithmIdentifier, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    internal static void InitiateEncryption(PbeParameters pbeParameters, SymmetricAlgorithm& cipher, String& hmacOid, String& encryptionAlgorithmOid, Boolean& isPkcs12);
    internal static int Encrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, SymmetricAlgorithm cipher, bool isPkcs12, AsnWriter source, PbeParameters pbeParameters, ReadOnlySpan`1<byte> salt, Byte[] destination, Span`1<byte> ivDest);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static SymmetricAlgorithm OpenCipher(AlgorithmIdentifierAsn encryptionScheme, Nullable`1<int> requestedKeyLength, Span`1& iv);
    private static void ReadIvParameter(Nullable`1<ReadOnlyMemory`1<byte>> encryptionSchemeParameters, int length, Span`1& iv);
    private static Rfc2898DeriveBytes OpenPbkdf2(ReadOnlySpan`1<byte> password, Nullable`1<ReadOnlyMemory`1<byte>> parameters, Nullable`1& requestedKeyLength);
    private static int Pbes1Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, IncrementalHash hasher, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pkcs12PbeDecrypt(AlgorithmIdentifierAsn algorithmIdentifier, ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Decrypt(SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static void Pbkdf1(IncrementalHash hasher, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterationCount, Span`1<byte> dk);
    internal static void WritePbeAlgorithmIdentifier(AsnWriter writer, bool isPkcs12, string encryptionAlgorithmOid, Span`1<byte> salt, int iterationCount, string hmacOid, Span`1<byte> iv);
    internal static int NormalizeIterationCount(int iterationCount, Nullable`1<int> iterationLimit);
    private static RC2 CreateRC2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.AlgorithmIdentifier : object {
    [CompilerGeneratedAttribute]
private Oid <Oid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Parameters>k__BackingField;
    public Oid Oid { get; public set; }
    public int KeyLength { get; public set; }
    public Byte[] Parameters { get; public set; }
    public AlgorithmIdentifier(Oid oid);
    public AlgorithmIdentifier(Oid oid, int keyLength);
    [CompilerGeneratedAttribute]
public Oid get_Oid();
    [CompilerGeneratedAttribute]
public void set_Oid(Oid value);
    [CompilerGeneratedAttribute]
public int get_KeyLength();
    [CompilerGeneratedAttribute]
public void set_KeyLength(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(Byte[] value);
}
internal class System.Security.Cryptography.Pkcs.Asn1.CadesIssuerSerial : ValueType {
    internal GeneralNameAsn[] Issuer;
    internal ReadOnlyMemory`1<byte> SerialNumber;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static CadesIssuerSerial Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static CadesIssuerSerial Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CadesIssuerSerial& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CadesIssuerSerial& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CadesIssuerSerial& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.CertificateChoiceAsn : ValueType {
    internal Nullable`1<ReadOnlyMemory`1<byte>> Certificate;
    internal Nullable`1<ReadOnlyMemory`1<byte>> ExtendedCertificate;
    internal Nullable`1<ReadOnlyMemory`1<byte>> AttributeCertificateV1;
    internal Nullable`1<ReadOnlyMemory`1<byte>> AttributeCertificateV2;
    internal Nullable`1<OtherCertificateFormat> OtherCertificateFormat;
    internal void Encode(AsnWriter writer);
    internal static CertificateChoiceAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CertificateChoiceAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CertificateChoiceAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EncapsulatedContentInfoAsn : ValueType {
    internal string ContentType;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Content;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EncapsulatedContentInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncapsulatedContentInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EncapsulatedContentInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncapsulatedContentInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncapsulatedContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EnvelopedDataAsn : ValueType {
    internal int Version;
    internal Nullable`1<OriginatorInfoAsn> OriginatorInfo;
    internal RecipientInfoAsn[] RecipientInfos;
    internal EncryptedContentInfoAsn EncryptedContentInfo;
    internal AttributeAsn[] UnprotectedAttributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EnvelopedDataAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EnvelopedDataAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EnvelopedDataAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EnvelopedDataAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EnvelopedDataAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EssCertId : ValueType {
    internal ReadOnlyMemory`1<byte> Hash;
    internal Nullable`1<CadesIssuerSerial> IssuerSerial;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EssCertId Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EssCertId Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EssCertId& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EssCertId& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EssCertId& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EssCertIdV2 : ValueType {
    internal AlgorithmIdentifierAsn HashAlgorithm;
    internal ReadOnlyMemory`1<byte> Hash;
    internal Nullable`1<CadesIssuerSerial> IssuerSerial;
    private static ReadOnlySpan`1<byte> DefaultHashAlgorithm { get; }
    private static ReadOnlySpan`1<byte> get_DefaultHashAlgorithm();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EssCertIdV2 Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EssCertIdV2 Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EssCertIdV2& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EssCertIdV2& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EssCertIdV2& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.IssuerAndSerialNumberAsn : ValueType {
    internal ReadOnlyMemory`1<byte> Issuer;
    internal ReadOnlyMemory`1<byte> SerialNumber;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static IssuerAndSerialNumberAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static IssuerAndSerialNumberAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, IssuerAndSerialNumberAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, IssuerAndSerialNumberAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, IssuerAndSerialNumberAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.KeyAgreeRecipientIdentifierAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    internal Nullable`1<RecipientKeyIdentifier> RKeyId;
    internal void Encode(AsnWriter writer);
    internal static KeyAgreeRecipientIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, KeyAgreeRecipientIdentifierAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, KeyAgreeRecipientIdentifierAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.KeyAgreeRecipientInfoAsn : ValueType {
    internal int Version;
    internal OriginatorIdentifierOrKeyAsn Originator;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Ukm;
    internal AlgorithmIdentifierAsn KeyEncryptionAlgorithm;
    internal RecipientEncryptedKeyAsn[] RecipientEncryptedKeys;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static KeyAgreeRecipientInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static KeyAgreeRecipientInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, KeyAgreeRecipientInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, KeyAgreeRecipientInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, KeyAgreeRecipientInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.KeyTransRecipientInfoAsn : ValueType {
    internal int Version;
    internal RecipientIdentifierAsn Rid;
    internal AlgorithmIdentifierAsn KeyEncryptionAlgorithm;
    internal ReadOnlyMemory`1<byte> EncryptedKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static KeyTransRecipientInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static KeyTransRecipientInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, KeyTransRecipientInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, KeyTransRecipientInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, KeyTransRecipientInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.MessageImprint : ValueType {
    internal AlgorithmIdentifierAsn HashAlgorithm;
    internal ReadOnlyMemory`1<byte> HashedMessage;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static MessageImprint Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static MessageImprint Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, MessageImprint& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, MessageImprint& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, MessageImprint& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.OriginatorIdentifierOrKeyAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier;
    internal Nullable`1<OriginatorPublicKeyAsn> OriginatorKey;
    internal void Encode(AsnWriter writer);
    internal static OriginatorIdentifierOrKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, OriginatorIdentifierOrKeyAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, OriginatorIdentifierOrKeyAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.OriginatorInfoAsn : ValueType {
    internal CertificateChoiceAsn[] CertificateSet;
    internal ReadOnlyMemory`1[] RevocationInfoChoices;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OriginatorInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OriginatorInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, OriginatorInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OriginatorInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OriginatorInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.OriginatorPublicKeyAsn : ValueType {
    internal AlgorithmIdentifierAsn Algorithm;
    internal ReadOnlyMemory`1<byte> PublicKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OriginatorPublicKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OriginatorPublicKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, OriginatorPublicKeyAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OriginatorPublicKeyAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OriginatorPublicKeyAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.OtherCertificateFormat : ValueType {
    internal string OtherCertFormat;
    internal ReadOnlyMemory`1<byte> OtherCert;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OtherCertificateFormat Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OtherCertificateFormat Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, OtherCertificateFormat& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherCertificateFormat& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherCertificateFormat& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.OtherKeyAttributeAsn : ValueType {
    internal string KeyAttrId;
    internal Nullable`1<ReadOnlyMemory`1<byte>> KeyAttr;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OtherKeyAttributeAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OtherKeyAttributeAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, OtherKeyAttributeAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherKeyAttributeAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherKeyAttributeAsn& decoded);
}
[FlagsAttribute]
internal enum System.Security.Cryptography.Pkcs.Asn1.PkiFailureInfo : Enum {
    public int value__;
    public static PkiFailureInfo None;
    public static PkiFailureInfo BadAlg;
    public static PkiFailureInfo BadMessageCheck;
    public static PkiFailureInfo BadRequest;
    public static PkiFailureInfo BadTime;
    public static PkiFailureInfo BadCertId;
    public static PkiFailureInfo BadDataFormat;
    public static PkiFailureInfo WrongAuthority;
    public static PkiFailureInfo IncorrectData;
    public static PkiFailureInfo MissingTimeStamp;
    public static PkiFailureInfo BadPop;
    public static PkiFailureInfo CertRevoked;
    public static PkiFailureInfo CertConfirmed;
    public static PkiFailureInfo WrongIntegrity;
    public static PkiFailureInfo BadRecipientNonce;
    public static PkiFailureInfo TimeNotAvailable;
    public static PkiFailureInfo UnacceptedPolicy;
    public static PkiFailureInfo UnacceptedExtension;
    public static PkiFailureInfo AddInfoNotAvailable;
    public static PkiFailureInfo BadSenderNonce;
    public static PkiFailureInfo BadCertTemplate;
    public static PkiFailureInfo SignerNotTrusted;
    public static PkiFailureInfo TransactionIdInUse;
    public static PkiFailureInfo UnsupportedVersion;
    public static PkiFailureInfo NotAuthorized;
    public static PkiFailureInfo SystemUnavail;
    public static PkiFailureInfo SystemFailure;
    public static PkiFailureInfo DuplicateCertReq;
}
internal enum System.Security.Cryptography.Pkcs.Asn1.PkiStatus : Enum {
    public int value__;
    public static PkiStatus Granted;
    public static PkiStatus GrantedWithMods;
    public static PkiStatus Rejection;
    public static PkiStatus Waiting;
    public static PkiStatus RevocationWarning;
    public static PkiStatus RevocationNotification;
    public static PkiStatus KeyUpdateWarning;
}
internal class System.Security.Cryptography.Pkcs.Asn1.PkiStatusInfo : ValueType {
    internal int Status;
    internal Nullable`1<ReadOnlyMemory`1<byte>> StatusString;
    internal Nullable`1<PkiFailureInfo> FailInfo;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PkiStatusInfo Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PkiStatusInfo Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PkiStatusInfo& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PkiStatusInfo& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PkiStatusInfo& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.PolicyInformation : ValueType {
    internal string PolicyIdentifier;
    internal PolicyQualifierInfo[] PolicyQualifiers;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PolicyInformation Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PolicyInformation Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PolicyInformation& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PolicyInformation& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PolicyInformation& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.PolicyQualifierInfo : ValueType {
    internal string PolicyQualifierId;
    internal ReadOnlyMemory`1<byte> Qualifier;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PolicyQualifierInfo Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PolicyQualifierInfo Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PolicyQualifierInfo& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PolicyQualifierInfo& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PolicyQualifierInfo& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientEncryptedKeyAsn : ValueType {
    internal KeyAgreeRecipientIdentifierAsn Rid;
    internal ReadOnlyMemory`1<byte> EncryptedKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static RecipientEncryptedKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RecipientEncryptedKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, RecipientEncryptedKeyAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, RecipientEncryptedKeyAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, RecipientEncryptedKeyAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientIdentifierAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier;
    internal void Encode(AsnWriter writer);
    internal static RecipientIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, RecipientIdentifierAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, RecipientIdentifierAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientInfoAsn : ValueType {
    internal Nullable`1<KeyTransRecipientInfoAsn> Ktri;
    internal Nullable`1<KeyAgreeRecipientInfoAsn> Kari;
    internal void Encode(AsnWriter writer);
    internal static RecipientInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, RecipientInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, RecipientInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientKeyIdentifier : ValueType {
    internal ReadOnlyMemory`1<byte> SubjectKeyIdentifier;
    internal Nullable`1<DateTimeOffset> Date;
    internal Nullable`1<OtherKeyAttributeAsn> Other;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static RecipientKeyIdentifier Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RecipientKeyIdentifier Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, RecipientKeyIdentifier& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, RecipientKeyIdentifier& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, RecipientKeyIdentifier& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161Accuracy : ValueType {
    internal Nullable`1<int> Seconds;
    internal Nullable`1<int> Millis;
    internal Nullable`1<int> Micros;
    internal long TotalMicros { get; }
    internal Rfc3161Accuracy(long accuracyInMicroseconds);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rfc3161Accuracy Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rfc3161Accuracy Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Rfc3161Accuracy& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rfc3161Accuracy& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rfc3161Accuracy& decoded);
    internal long get_TotalMicros();
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161TimeStampReq : ValueType {
    internal int Version;
    internal MessageImprint MessageImprint;
    internal string ReqPolicy;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Nonce;
    internal bool CertReq;
    internal X509ExtensionAsn[] Extensions;
    private static ReadOnlySpan`1<byte> DefaultCertReq { get; }
    private static ReadOnlySpan`1<byte> get_DefaultCertReq();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rfc3161TimeStampReq Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rfc3161TimeStampReq Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Rfc3161TimeStampReq& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rfc3161TimeStampReq& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rfc3161TimeStampReq& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161TimeStampResp : ValueType {
    internal PkiStatusInfo Status;
    internal Nullable`1<ReadOnlyMemory`1<byte>> TimeStampToken;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rfc3161TimeStampResp Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rfc3161TimeStampResp Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Rfc3161TimeStampResp& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rfc3161TimeStampResp& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rfc3161TimeStampResp& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161TstInfo : ValueType {
    internal int Version;
    internal string Policy;
    internal MessageImprint MessageImprint;
    internal ReadOnlyMemory`1<byte> SerialNumber;
    internal DateTimeOffset GenTime;
    internal Nullable`1<Rfc3161Accuracy> Accuracy;
    internal bool Ordering;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Nonce;
    internal Nullable`1<GeneralNameAsn> Tsa;
    internal X509ExtensionAsn[] Extensions;
    private static ReadOnlySpan`1<byte> DefaultOrdering { get; }
    private static ReadOnlySpan`1<byte> get_DefaultOrdering();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rfc3161TstInfo Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rfc3161TstInfo Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Rfc3161TstInfo& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rfc3161TstInfo& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rfc3161TstInfo& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SecretBagAsn : ValueType {
    internal string SecretTypeId;
    internal ReadOnlyMemory`1<byte> SecretValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SecretBagAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SecretBagAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SecretBagAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SecretBagAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SecretBagAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SignedDataAsn : ValueType {
    internal int Version;
    internal AlgorithmIdentifierAsn[] DigestAlgorithms;
    internal EncapsulatedContentInfoAsn EncapContentInfo;
    internal CertificateChoiceAsn[] CertificateSet;
    internal ReadOnlyMemory`1[] Crls;
    internal SignerInfoAsn[] SignerInfos;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SignedDataAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SignedDataAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SignedDataAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SignedDataAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SignedDataAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SignerIdentifierAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier;
    internal void Encode(AsnWriter writer);
    internal static SignerIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SignerIdentifierAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SignerIdentifierAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SignerInfoAsn : ValueType {
    internal int Version;
    internal SignerIdentifierAsn Sid;
    internal AlgorithmIdentifierAsn DigestAlgorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SignedAttributes;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> SignatureValue;
    internal AttributeAsn[] UnsignedAttributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SignerInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SignerInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SignerInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SignerInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SignerInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SigningCertificateAsn : ValueType {
    internal EssCertId[] Certs;
    internal PolicyInformation[] Policies;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SigningCertificateAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SigningCertificateAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SigningCertificateAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SigningCertificateAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SigningCertificateAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SigningCertificateV2Asn : ValueType {
    internal EssCertIdV2[] Certs;
    internal PolicyInformation[] Policies;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SigningCertificateV2Asn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SigningCertificateV2Asn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SigningCertificateV2Asn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SigningCertificateV2Asn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SigningCertificateV2Asn& decoded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.CmsRecipient : object {
    [CompilerGeneratedAttribute]
private RSAEncryptionPadding <RSAEncryptionPadding>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectIdentifierType <RecipientIdentifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [NullableAttribute("2")]
public RSAEncryptionPadding RSAEncryptionPadding { get; }
    public SubjectIdentifierType RecipientIdentifierType { get; }
    public X509Certificate2 Certificate { get; }
    public CmsRecipient(X509Certificate2 certificate);
    public CmsRecipient(X509Certificate2 certificate, RSAEncryptionPadding rsaEncryptionPadding);
    public CmsRecipient(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate, RSAEncryptionPadding rsaEncryptionPadding);
    public CmsRecipient(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RSAEncryptionPadding get_RSAEncryptionPadding();
    [CompilerGeneratedAttribute]
public SubjectIdentifierType get_RecipientIdentifierType();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    private static void ValidateRSACertificate(X509Certificate2 certificate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.Pkcs.CmsRecipientCollection : object {
    private List`1<CmsRecipient> _recipients;
    public CmsRecipient Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public CmsRecipientCollection(CmsRecipient recipient);
    public CmsRecipientCollection(SubjectIdentifierType recipientIdentifierType, X509Certificate2Collection certificates);
    public CmsRecipient get_Item(int index);
    public sealed virtual int get_Count();
    public int Add(CmsRecipient recipient);
    public void Remove(CmsRecipient recipient);
    public CmsRecipientEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(CmsRecipient[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.CmsRecipientEnumerator : object {
    private CmsRecipientCollection _recipients;
    private int _current;
    public CmsRecipient Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal CmsRecipientEnumerator(CmsRecipientCollection recipients);
    public CmsRecipient get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal abstract class System.Security.Cryptography.Pkcs.CmsSignature : object {
    private static Dictionary`2<string, CmsSignature> s_lookup;
    private static CmsSignature();
    private static void PrepareRegistrationRsa(Dictionary`2<string, CmsSignature> lookup);
    private static void PrepareRegistrationDsa(Dictionary`2<string, CmsSignature> lookup);
    private static void PrepareRegistrationECDsa(Dictionary`2<string, CmsSignature> lookup);
    protected abstract virtual bool VerifyKeyType(AsymmetricAlgorithm key);
    internal abstract virtual bool VerifySignature(ReadOnlySpan`1<byte> valueHash, ReadOnlyMemory`1<byte> signature, string digestAlgorithmOid, HashAlgorithmName digestAlgorithmName, Nullable`1<ReadOnlyMemory`1<byte>> signatureParameters, X509Certificate2 certificate);
    protected abstract virtual bool Sign(ReadOnlySpan`1<byte> dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, AsymmetricAlgorithm key, bool silent, String& signatureAlgorithm, Byte[]& signatureValue);
    internal static CmsSignature ResolveAndVerifyKeyType(string signatureAlgorithmOid, AsymmetricAlgorithm key);
    internal static bool Sign(ReadOnlySpan`1<byte> dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, AsymmetricAlgorithm key, bool silent, String& oid, ReadOnlyMemory`1& signatureValue);
    private static bool DsaDerToIeee(ReadOnlyMemory`1<byte> derSignature, Span`1<byte> ieeeSignature);
    private static Byte[] DsaIeeeToDer(ReadOnlySpan`1<byte> ieeeSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.CmsSigner : object {
    private static Oid s_defaultAlgorithm;
    private SubjectIdentifierType _signerIdentifierType;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private AsymmetricAlgorithm <PrivateKey>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private Oid <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509IncludeOption <IncludeOption>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <SignedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <UnsignedAttributes>k__BackingField;
    [NullableAttribute("2")]
public X509Certificate2 Certificate { get; public set; }
    [NullableAttribute("2")]
public AsymmetricAlgorithm PrivateKey { get; public set; }
    public X509Certificate2Collection Certificates { get; private set; }
    public Oid DigestAlgorithm { get; public set; }
    public X509IncludeOption IncludeOption { get; public set; }
    public CryptographicAttributeObjectCollection SignedAttributes { get; private set; }
    public CryptographicAttributeObjectCollection UnsignedAttributes { get; private set; }
    public SubjectIdentifierType SignerIdentifierType { get; public set; }
    public CmsSigner(SubjectIdentifierType signerIdentifierType);
    [NullableContextAttribute("2")]
public CmsSigner(X509Certificate2 certificate);
    [ObsoleteAttribute("CmsSigner(CspParameters) is obsolete and is not supported. Use an alternative constructor instead.")]
public CmsSigner(CspParameters parameters);
    [NullableContextAttribute("2")]
public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate);
    [NullableContextAttribute("2")]
public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate, AsymmetricAlgorithm privateKey);
    private static CmsSigner();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Certificate(X509Certificate2 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AsymmetricAlgorithm get_PrivateKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PrivateKey(AsymmetricAlgorithm value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_Certificates();
    [CompilerGeneratedAttribute]
private void set_Certificates(X509Certificate2Collection value);
    [CompilerGeneratedAttribute]
public Oid get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DigestAlgorithm(Oid value);
    [CompilerGeneratedAttribute]
public X509IncludeOption get_IncludeOption();
    [CompilerGeneratedAttribute]
public void set_IncludeOption(X509IncludeOption value);
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_SignedAttributes();
    [CompilerGeneratedAttribute]
private void set_SignedAttributes(CryptographicAttributeObjectCollection value);
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_UnsignedAttributes();
    [CompilerGeneratedAttribute]
private void set_UnsignedAttributes(CryptographicAttributeObjectCollection value);
    public SubjectIdentifierType get_SignerIdentifierType();
    public void set_SignerIdentifierType(SubjectIdentifierType value);
    internal void CheckCertificateValue();
    internal SignerInfoAsn Sign(ReadOnlyMemory`1<byte> data, string contentTypeOid, bool silent, X509Certificate2Collection& chainCerts);
    internal static List`1<AttributeAsn> BuildAttributes(CryptographicAttributeObjectCollection attributes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.ContentInfo : object {
    [CompilerGeneratedAttribute]
private Oid <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Content>k__BackingField;
    public Oid ContentType { get; }
    public Byte[] Content { get; }
    public ContentInfo(Byte[] content);
    public ContentInfo(Oid contentType, Byte[] content);
    [CompilerGeneratedAttribute]
public Oid get_ContentType();
    [CompilerGeneratedAttribute]
public Byte[] get_Content();
    public static Oid GetContentType(Byte[] encodedMessage);
    [NullableContextAttribute("0")]
public static Oid GetContentType(ReadOnlySpan`1<byte> encodedMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.EnvelopedCms : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentInfo <ContentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <ContentEncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <UnprotectedAttributes>k__BackingField;
    private DecryptorPal _decryptorPal;
    private Byte[] _encodedMessage;
    private LastCall _lastCall;
    public int Version { get; private set; }
    public ContentInfo ContentInfo { get; private set; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; private set; }
    public X509Certificate2Collection Certificates { get; private set; }
    public CryptographicAttributeObjectCollection UnprotectedAttributes { get; private set; }
    public RecipientInfoCollection RecipientInfos { get; }
    public EnvelopedCms(ContentInfo contentInfo);
    public EnvelopedCms(ContentInfo contentInfo, AlgorithmIdentifier encryptionAlgorithm);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    [CompilerGeneratedAttribute]
public ContentInfo get_ContentInfo();
    [CompilerGeneratedAttribute]
private void set_ContentInfo(ContentInfo value);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    [CompilerGeneratedAttribute]
private void set_ContentEncryptionAlgorithm(AlgorithmIdentifier value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_Certificates();
    [CompilerGeneratedAttribute]
private void set_Certificates(X509Certificate2Collection value);
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_UnprotectedAttributes();
    [CompilerGeneratedAttribute]
private void set_UnprotectedAttributes(CryptographicAttributeObjectCollection value);
    public RecipientInfoCollection get_RecipientInfos();
    public void Encrypt(CmsRecipient recipient);
    public void Encrypt(CmsRecipientCollection recipients);
    public Byte[] Encode();
    public void Decode(Byte[] encodedMessage);
    [NullableContextAttribute("0")]
public void Decode(ReadOnlySpan`1<byte> encodedMessage);
    public void Decrypt();
    public void Decrypt(RecipientInfo recipientInfo);
    public void Decrypt(RecipientInfo recipientInfo, X509Certificate2Collection extraStore);
    public void Decrypt(X509Certificate2Collection extraStore);
    public void Decrypt(RecipientInfo recipientInfo, AsymmetricAlgorithm privateKey);
    private void DecryptContent(RecipientInfoCollection recipientInfos, X509Certificate2Collection extraStore);
    private void CheckStateForDecryption();
    private void SetContentInfo(ContentInfo contentInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo : RecipientInfo {
    private SubjectIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRecipientIdentifier;
    private AlgorithmIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyEncryptionAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEncryptedKey;
    private SubjectIdentifierOrKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOriginatorIdentifierKey;
    private Nullable`1<DateTime> _lazyDate;
    private CryptographicAttributeObject modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOtherKeyAttribute;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
    public DateTime Date { get; }
    [NullableAttribute("2")]
public CryptographicAttributeObject OtherKeyAttribute { get; }
    private KeyAgreeRecipientInfoPal Pal { get; }
    internal KeyAgreeRecipientInfo(KeyAgreeRecipientInfoPal pal);
    public virtual int get_Version();
    public virtual SubjectIdentifier get_RecipientIdentifier();
    public virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public virtual Byte[] get_EncryptedKey();
    public SubjectIdentifierOrKey get_OriginatorIdentifierOrKey();
    public DateTime get_Date();
    [NullableContextAttribute("2")]
public CryptographicAttributeObject get_OtherKeyAttribute();
    private KeyAgreeRecipientInfoPal get_Pal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.KeyTransRecipientInfo : RecipientInfo {
    private SubjectIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRecipientIdentifier;
    private AlgorithmIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyEncryptionAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEncryptedKey;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    private KeyTransRecipientInfoPal Pal { get; }
    internal KeyTransRecipientInfo(KeyTransRecipientInfoPal pal);
    public virtual int get_Version();
    public virtual SubjectIdentifier get_RecipientIdentifier();
    public virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public virtual Byte[] get_EncryptedKey();
    private KeyTransRecipientInfoPal get_Pal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Pkcs12Builder : object {
    private ReadOnlyMemory`1<byte> _sealedData;
    private List`1<ContentInfoAsn> _contents;
    public bool IsSealed { get; }
    public bool get_IsSealed();
    public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, Byte[] passwordBytes, PbeParameters pbeParameters);
    public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, string password, PbeParameters pbeParameters);
    public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public void AddSafeContentsUnencrypted(Pkcs12SafeContents safeContents);
    public Byte[] Encode();
    [NullableContextAttribute("2")]
public void SealWithMac(string password, HashAlgorithmName hashAlgorithm, int iterationCount);
    [NullableContextAttribute("0")]
public void SealWithMac(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount);
    public void SealWithoutIntegrity();
    [NullableContextAttribute("0")]
public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.Pkcs.Pkcs12CertBag : Pkcs12SafeBag {
    private Oid _certTypeOid;
    private CertBagAsn _decoded;
    [CompilerGeneratedAttribute]
private bool <IsX509Certificate>k__BackingField;
    public bool IsX509Certificate { get; }
    public ReadOnlyMemory`1<byte> EncodedCertificate { get; }
    private Pkcs12CertBag(ReadOnlyMemory`1<byte> encodedBagValue, CertBagAsn decoded);
    public Pkcs12CertBag(Oid certificateType, ReadOnlyMemory`1<byte> encodedCertificate);
    internal Pkcs12CertBag(X509Certificate2 cert);
    [CompilerGeneratedAttribute]
public bool get_IsX509Certificate();
    [NullableContextAttribute("1")]
public Oid GetCertificateType();
    public ReadOnlyMemory`1<byte> get_EncodedCertificate();
    [NullableContextAttribute("1")]
public X509Certificate2 GetCertificate();
    private static Byte[] EncodeBagValue(Oid certificateType, ReadOnlyMemory`1<byte> encodedCertificate);
    private static Byte[] EncodeBagValue(string certificateType, ReadOnlyMemory`1<byte> encodedCertificate);
    internal static Pkcs12CertBag DecodeValue(ReadOnlyMemory`1<byte> bagValue);
}
public enum System.Security.Cryptography.Pkcs.Pkcs12ConfidentialityMode : Enum {
    public int value__;
    public static Pkcs12ConfidentialityMode Unknown;
    public static Pkcs12ConfidentialityMode None;
    public static Pkcs12ConfidentialityMode Password;
    public static Pkcs12ConfidentialityMode PublicKey;
}
public class System.Security.Cryptography.Pkcs.Pkcs12Info : object {
    private PfxAsn _decoded;
    private ReadOnlyMemory`1<byte> _authSafeContents;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Pkcs12SafeContents> <AuthenticatedSafe>k__BackingField;
    [CompilerGeneratedAttribute]
private Pkcs12IntegrityMode <IntegrityMode>k__BackingField;
    [NullableAttribute("1")]
public ReadOnlyCollection`1<Pkcs12SafeContents> AuthenticatedSafe { get; private set; }
    public Pkcs12IntegrityMode IntegrityMode { get; private set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Pkcs12SafeContents> get_AuthenticatedSafe();
    [CompilerGeneratedAttribute]
private void set_AuthenticatedSafe(ReadOnlyCollection`1<Pkcs12SafeContents> value);
    [CompilerGeneratedAttribute]
public Pkcs12IntegrityMode get_IntegrityMode();
    [CompilerGeneratedAttribute]
private void set_IntegrityMode(Pkcs12IntegrityMode value);
    [NullableContextAttribute("2")]
public bool VerifyMac(string password);
    public bool VerifyMac(ReadOnlySpan`1<char> password);
    public static Pkcs12Info Decode(ReadOnlyMemory`1<byte> encodedBytes, Int32& bytesConsumed, bool skipCopy);
}
public enum System.Security.Cryptography.Pkcs.Pkcs12IntegrityMode : Enum {
    public int value__;
    public static Pkcs12IntegrityMode Unknown;
    public static Pkcs12IntegrityMode None;
    public static Pkcs12IntegrityMode Password;
    public static Pkcs12IntegrityMode PublicKey;
}
internal static class System.Security.Cryptography.Pkcs.Pkcs12Kdf : object {
    private static byte CipherKeyId;
    private static byte IvId;
    private static byte MacKeyId;
    private static ValueTuple`3[] s_uvLookup;
    private static Pkcs12Kdf();
    internal static void DeriveCipherKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveIV(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveMacKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void Derive(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, byte id, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void AddPlusOne(Span`1<byte> into, Span`1<byte> addend);
    private static void CircularCopy(ReadOnlySpan`1<byte> bytes, Span`1<byte> destination);
    private static void CircularCopyUtf16BE(ReadOnlySpan`1<char> password, Span`1<byte> destination);
}
public class System.Security.Cryptography.Pkcs.Pkcs12KeyBag : Pkcs12SafeBag {
    public ReadOnlyMemory`1<byte> Pkcs8PrivateKey { get; }
    public Pkcs12KeyBag(ReadOnlyMemory`1<byte> pkcs8PrivateKey, bool skipCopy);
    public ReadOnlyMemory`1<byte> get_Pkcs8PrivateKey();
}
public abstract class System.Security.Cryptography.Pkcs.Pkcs12SafeBag : object {
    private string _bagIdValue;
    private Oid _bagOid;
    private CryptographicAttributeObjectCollection _attributes;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <EncodedBagValue>k__BackingField;
    public ReadOnlyMemory`1<byte> EncodedBagValue { get; }
    [NullableAttribute("1")]
public CryptographicAttributeObjectCollection Attributes { get; internal set; }
    protected Pkcs12SafeBag(string bagIdValue, ReadOnlyMemory`1<byte> encodedBagValue, bool skipCopy);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_EncodedBagValue();
    [NullableContextAttribute("1")]
public CryptographicAttributeObjectCollection get_Attributes();
    internal void set_Attributes(CryptographicAttributeObjectCollection value);
    [NullableContextAttribute("1")]
public Byte[] Encode();
    [NullableContextAttribute("1")]
public Oid GetBagId();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    internal void EncodeTo(AsnWriter writer);
    private AsnWriter EncodeToNewWriter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Pkcs12SafeContents : object {
    private ReadOnlyMemory`1<byte> _encrypted;
    private List`1<Pkcs12SafeBag> _bags;
    [CompilerGeneratedAttribute]
private Pkcs12ConfidentialityMode <ConfidentialityMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public Pkcs12ConfidentialityMode ConfidentialityMode { get; private set; }
    public bool IsReadOnly { get; }
    internal Pkcs12SafeContents(ReadOnlyMemory`1<byte> serialized);
    internal Pkcs12SafeContents(ContentInfoAsn contentInfoAsn);
    [CompilerGeneratedAttribute]
public Pkcs12ConfidentialityMode get_ConfidentialityMode();
    [CompilerGeneratedAttribute]
private void set_ConfidentialityMode(Pkcs12ConfidentialityMode value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    public void AddSafeBag(Pkcs12SafeBag safeBag);
    public Pkcs12CertBag AddCertificate(X509Certificate2 certificate);
    public Pkcs12KeyBag AddKeyUnencrypted(AsymmetricAlgorithm key);
    public Pkcs12SafeContentsBag AddNestedContents(Pkcs12SafeContents safeContents);
    public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, Byte[] passwordBytes, PbeParameters pbeParameters);
    public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, string password, PbeParameters pbeParameters);
    public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public Pkcs12SecretBag AddSecret(Oid secretType, ReadOnlyMemory`1<byte> secretValue);
    [NullableContextAttribute("2")]
public void Decrypt(Byte[] passwordBytes);
    [NullableContextAttribute("0")]
public void Decrypt(ReadOnlySpan`1<byte> passwordBytes);
    [NullableContextAttribute("2")]
public void Decrypt(string password);
    [NullableContextAttribute("0")]
public void Decrypt(ReadOnlySpan`1<char> password);
    private void Decrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes);
    public IEnumerable`1<Pkcs12SafeBag> GetBags();
    private static List`1<Pkcs12SafeBag> ReadBags(ReadOnlyMemory`1<byte> serialized);
    internal Byte[] Encrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    internal AsnWriter Encode();
    internal ContentInfoAsn EncodeToContentInfo();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Pkcs12SafeContentsBag : Pkcs12SafeBag {
    [CompilerGeneratedAttribute]
private Pkcs12SafeContents <SafeContents>k__BackingField;
    public Pkcs12SafeContents SafeContents { get; private set; }
    private Pkcs12SafeContentsBag(ReadOnlyMemory`1<byte> encoded);
    [CompilerGeneratedAttribute]
public Pkcs12SafeContents get_SafeContents();
    [CompilerGeneratedAttribute]
private void set_SafeContents(Pkcs12SafeContents value);
    internal static Pkcs12SafeContentsBag Create(Pkcs12SafeContents copyFrom);
    internal static Pkcs12SafeContentsBag Decode(ReadOnlyMemory`1<byte> encodedValue);
}
public class System.Security.Cryptography.Pkcs.Pkcs12SecretBag : Pkcs12SafeBag {
    private Oid _secretTypeOid;
    private SecretBagAsn _decoded;
    public ReadOnlyMemory`1<byte> SecretValue { get; }
    private Pkcs12SecretBag(ReadOnlyMemory`1<byte> encodedBagValue);
    internal Pkcs12SecretBag(Oid secretTypeOid, ReadOnlyMemory`1<byte> secretValue);
    private Pkcs12SecretBag(SecretBagAsn secretBagAsn, ReadOnlyMemory`1<byte> encodedBagValue);
    public ReadOnlyMemory`1<byte> get_SecretValue();
    [NullableContextAttribute("1")]
public Oid GetSecretType();
    private static Byte[] EncodeBagValue(Oid secretTypeOid, ReadOnlyMemory`1& secretValue);
    internal static Pkcs12SecretBag DecodeValue(ReadOnlyMemory`1<byte> bagValue);
}
public class System.Security.Cryptography.Pkcs.Pkcs12ShroudedKeyBag : Pkcs12SafeBag {
    public ReadOnlyMemory`1<byte> EncryptedPkcs8PrivateKey { get; }
    public Pkcs12ShroudedKeyBag(ReadOnlyMemory`1<byte> encryptedPkcs8PrivateKey, bool skipCopy);
    public ReadOnlyMemory`1<byte> get_EncryptedPkcs8PrivateKey();
}
public class System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo : object {
    [CompilerGeneratedAttribute]
private Oid <AlgorithmId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReadOnlyMemory`1<byte>> <AlgorithmParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <PrivateKeyBytes>k__BackingField;
    [NullableAttribute("1")]
public Oid AlgorithmId { get; }
    public Nullable`1<ReadOnlyMemory`1<byte>> AlgorithmParameters { get; }
    [NullableAttribute("1")]
public CryptographicAttributeObjectCollection Attributes { get; }
    public ReadOnlyMemory`1<byte> PrivateKeyBytes { get; }
    public Pkcs8PrivateKeyInfo(Oid algorithmId, Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlyMemory`1<byte> privateKey, bool skipCopies);
    private Pkcs8PrivateKeyInfo(Oid algorithmId, Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlyMemory`1<byte> privateKey, CryptographicAttributeObjectCollection attributes);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Oid get_AlgorithmId();
    [CompilerGeneratedAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> get_AlgorithmParameters();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_Attributes();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_PrivateKeyBytes();
    [NullableContextAttribute("1")]
public static Pkcs8PrivateKeyInfo Create(AsymmetricAlgorithm privateKey);
    public static Pkcs8PrivateKeyInfo Decode(ReadOnlyMemory`1<byte> source, Int32& bytesRead, bool skipCopy);
    [NullableContextAttribute("1")]
public Byte[] Encode();
    [NullableContextAttribute("1")]
public Byte[] Encrypt(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public Byte[] Encrypt(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryEncrypt(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryEncrypt(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public static Pkcs8PrivateKeyInfo DecryptAndDecode(ReadOnlySpan`1<char> password, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    public static Pkcs8PrivateKeyInfo DecryptAndDecode(ReadOnlySpan`1<byte> passwordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private AsnWriter WritePkcs8();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Pkcs9AttributeObject : AsnEncodedData {
    [NullableAttribute("2")]
public Oid Oid { get; }
    public Pkcs9AttributeObject(string oid, Byte[] encodedData);
    public Pkcs9AttributeObject(Oid oid, Byte[] encodedData);
    public Pkcs9AttributeObject(AsnEncodedData asnEncodedData);
    internal Pkcs9AttributeObject(Oid oid);
    [NullableContextAttribute("2")]
public Oid get_Oid();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Pkcs9ContentType : Pkcs9AttributeObject {
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazyContentType;
    public Oid ContentType { get; }
    public Oid get_ContentType();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Oid Decode(Byte[] rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription : Pkcs9AttributeObject {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDocumentDescription;
    public string DocumentDescription { get; }
    public Pkcs9DocumentDescription(string documentDescription);
    public Pkcs9DocumentDescription(Byte[] encodedDocumentDescription);
    public string get_DocumentDescription();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static string Decode(Byte[] rawData);
    private static Byte[] Encode(string documentDescription);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Pkcs9DocumentName : Pkcs9AttributeObject {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDocumentName;
    public string DocumentName { get; }
    public Pkcs9DocumentName(string documentName);
    public Pkcs9DocumentName(Byte[] encodedDocumentName);
    public string get_DocumentName();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static string Decode(Byte[] rawData);
    private static Byte[] Encode(string documentName);
}
public class System.Security.Cryptography.Pkcs.Pkcs9LocalKeyId : Pkcs9AttributeObject {
    private Byte[] _lazyKeyId;
    public ReadOnlyMemory`1<byte> KeyId { get; }
    [NullableContextAttribute("1")]
public Pkcs9LocalKeyId(Byte[] keyId);
    public Pkcs9LocalKeyId(ReadOnlySpan`1<byte> keyId);
    public ReadOnlyMemory`1<byte> get_KeyId();
    [NullableContextAttribute("1")]
public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] Decode(Byte[] rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Pkcs9MessageDigest : Pkcs9AttributeObject {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMessageDigest;
    public Byte[] MessageDigest { get; }
    internal Pkcs9MessageDigest(ReadOnlySpan`1<byte> signatureDigest);
    public Byte[] get_MessageDigest();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] Decode(Byte[] rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Pkcs9SigningTime : Pkcs9AttributeObject {
    private Nullable`1<DateTime> _lazySigningTime;
    public DateTime SigningTime { get; }
    public Pkcs9SigningTime(DateTime signingTime);
    public Pkcs9SigningTime(Byte[] encodedSigningTime);
    public DateTime get_SigningTime();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static DateTime Decode(Byte[] rawData);
    private static Byte[] Encode(DateTime signingTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.PublicKeyInfo : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <KeyValue>k__BackingField;
    public AlgorithmIdentifier Algorithm { get; }
    public Byte[] KeyValue { get; }
    internal PublicKeyInfo(AlgorithmIdentifier algorithm, Byte[] keyValue);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_Algorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_KeyValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.Pkcs.RecipientInfo : object {
    [CompilerGeneratedAttribute]
private RecipientInfoType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private RecipientInfoPal <Pal>k__BackingField;
    public RecipientInfoType Type { get; }
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    internal RecipientInfoPal Pal { get; }
    internal RecipientInfo(RecipientInfoType type, RecipientInfoPal pal);
    [CompilerGeneratedAttribute]
public RecipientInfoType get_Type();
    public abstract virtual int get_Version();
    public abstract virtual SubjectIdentifier get_RecipientIdentifier();
    public abstract virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public abstract virtual Byte[] get_EncryptedKey();
    [CompilerGeneratedAttribute]
internal RecipientInfoPal get_Pal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.Pkcs.RecipientInfoCollection : object {
    private RecipientInfo[] _recipientInfos;
    public RecipientInfo Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal RecipientInfoCollection(RecipientInfo recipientInfo);
    internal RecipientInfoCollection(ICollection`1<RecipientInfo> recipientInfos);
    public RecipientInfo get_Item(int index);
    public sealed virtual int get_Count();
    public RecipientInfoEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(RecipientInfo[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.RecipientInfoEnumerator : object {
    private RecipientInfoCollection _recipientInfos;
    private int _current;
    public RecipientInfo Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal RecipientInfoEnumerator(RecipientInfoCollection RecipientInfos);
    public RecipientInfo get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.Pkcs.RecipientInfoType : Enum {
    public int value__;
    public static RecipientInfoType Unknown;
    public static RecipientInfoType KeyTransport;
    public static RecipientInfoType KeyAgreement;
}
internal enum System.Security.Cryptography.Pkcs.Rfc3161RequestResponseStatus : Enum {
    public int value__;
    public static Rfc3161RequestResponseStatus Unknown;
    public static Rfc3161RequestResponseStatus Accepted;
    public static Rfc3161RequestResponseStatus DoesNotParse;
    public static Rfc3161RequestResponseStatus RequestFailed;
    public static Rfc3161RequestResponseStatus HashMismatch;
    public static Rfc3161RequestResponseStatus VersionTooNew;
    public static Rfc3161RequestResponseStatus NonceMismatch;
    public static Rfc3161RequestResponseStatus RequestedCertificatesMissing;
    public static Rfc3161RequestResponseStatus UnexpectedCertificates;
}
public class System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest : object {
    private Byte[] _encodedBytes;
    private Rfc3161TimeStampReq _parsedData;
    private Oid _hashAlgorithmId;
    private Oid _requestedPolicyId;
    public int Version { get; }
    [NullableAttribute("1")]
public Oid HashAlgorithmId { get; }
    [NullableAttribute("2")]
public Oid RequestedPolicyId { get; }
    public bool RequestSignerCertificate { get; }
    public bool HasExtensions { get; }
    public int get_Version();
    public ReadOnlyMemory`1<byte> GetMessageHash();
    [NullableContextAttribute("1")]
public Oid get_HashAlgorithmId();
    [NullableContextAttribute("2")]
public Oid get_RequestedPolicyId();
    public bool get_RequestSignerCertificate();
    public Nullable`1<ReadOnlyMemory`1<byte>> GetNonce();
    public bool get_HasExtensions();
    [NullableContextAttribute("1")]
public X509ExtensionCollection GetExtensions();
    public Rfc3161TimestampToken ProcessResponse(ReadOnlyMemory`1<byte> responseBytes, Int32& bytesConsumed);
    private bool ProcessResponse(ReadOnlyMemory`1<byte> source, Rfc3161TimestampToken& token, Rfc3161RequestResponseStatus& status, Int32& bytesConsumed, bool shouldThrow);
    [NullableContextAttribute("1")]
public Byte[] Encode();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static Rfc3161TimestampRequest CreateFromSignerInfo(SignerInfo signerInfo, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static Rfc3161TimestampRequest CreateFromData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory`1<byte> hash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory`1<byte> hash, Oid hashAlgorithmId, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static bool TryDecode(ReadOnlyMemory`1<byte> encodedBytes, Rfc3161TimestampRequest& request, Int32& bytesConsumed);
    private Rfc3161RequestResponseStatus ValidateResponse(Rfc3161TimestampToken token, bool shouldThrow);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.Rfc3161TimestampToken : object {
    private SignedCms _parsedDocument;
    private SignerInfo _signerInfo;
    private Nullable`1<EssCertId> _essCertId;
    private Nullable`1<EssCertIdV2> _essCertIdV2;
    [CompilerGeneratedAttribute]
private Rfc3161TimestampTokenInfo <TokenInfo>k__BackingField;
    [NullableAttribute("1")]
public Rfc3161TimestampTokenInfo TokenInfo { get; private set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Rfc3161TimestampTokenInfo get_TokenInfo();
    [CompilerGeneratedAttribute]
private void set_TokenInfo(Rfc3161TimestampTokenInfo value);
    [NullableContextAttribute("1")]
public SignedCms AsSignedCms();
    private X509Certificate2 GetSignerCertificate(X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForData(ReadOnlySpan`1<byte> data, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForHash(ReadOnlySpan`1<byte> hash, HashAlgorithmName hashAlgorithm, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForHash(ReadOnlySpan`1<byte> hash, Oid hashAlgorithmId, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForSignerInfo(SignerInfo signerInfo, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    internal bool VerifyHash(ReadOnlySpan`1<byte> hash, string hashAlgorithmId);
    private bool VerifyData(ReadOnlySpan`1<byte> data);
    private static bool CheckCertificate(X509Certificate2 tsaCertificate, SignerInfo signer, Nullable`1& certId, Nullable`1& certId2, Rfc3161TimestampTokenInfo tokenInfo);
    [NullableContextAttribute("0")]
public static bool TryDecode(ReadOnlyMemory`1<byte> encodedBytes, Rfc3161TimestampToken& token, Int32& bytesConsumed);
    private static bool IssuerAndSerialMatch(CadesIssuerSerial issuerSerial, string issuerDirectoryName, string serialNumber);
    private static bool IssuerAndSerialMatch(CadesIssuerSerial issuerSerial, ReadOnlySpan`1<byte> issuerDirectoryName, ReadOnlySpan`1<byte> serialNumber);
    private static bool CertMatchesIds(X509Certificate2 signerCert, Nullable`1& certId, Nullable`1& certId2);
    private static bool TryGetCertIds(SignerInfo signer, Nullable`1& certId, Nullable`1& certId2);
}
public class System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo : object {
    private Byte[] _encodedBytes;
    private Rfc3161TstInfo _parsedData;
    private Oid _policyOid;
    private Oid _hashAlgorithmId;
    private Nullable`1<ReadOnlyMemory`1<byte>> _tsaNameBytes;
    public int Version { get; }
    [NullableAttribute("1")]
public Oid PolicyId { get; }
    [NullableAttribute("1")]
public Oid HashAlgorithmId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public bool IsOrdering { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampTokenInfo(Oid policyId, Oid hashAlgorithmId, ReadOnlyMemory`1<byte> messageHash, ReadOnlyMemory`1<byte> serialNumber, DateTimeOffset timestamp, Nullable`1<long> accuracyInMicroseconds, bool isOrdering, Nullable`1<ReadOnlyMemory`1<byte>> nonce, Nullable`1<ReadOnlyMemory`1<byte>> timestampAuthorityName, X509ExtensionCollection extensions);
    private Rfc3161TimestampTokenInfo(Byte[] copiedBytes, Rfc3161TstInfo tstInfo);
    public int get_Version();
    [NullableContextAttribute("1")]
public Oid get_PolicyId();
    [NullableContextAttribute("1")]
public Oid get_HashAlgorithmId();
    public ReadOnlyMemory`1<byte> GetMessageHash();
    public ReadOnlyMemory`1<byte> GetSerialNumber();
    public DateTimeOffset get_Timestamp();
    public Nullable`1<long> get_AccuracyInMicroseconds();
    public bool get_IsOrdering();
    public Nullable`1<ReadOnlyMemory`1<byte>> GetNonce();
    public bool get_HasExtensions();
    public Nullable`1<ReadOnlyMemory`1<byte>> GetTimestampAuthorityName();
    [NullableContextAttribute("1")]
public X509ExtensionCollection GetExtensions();
    [NullableContextAttribute("1")]
public Byte[] Encode();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryDecode(ReadOnlyMemory`1<byte> encodedBytes, Rfc3161TimestampTokenInfo& timestampTokenInfo, Int32& bytesConsumed);
    private static bool TryDecode(ReadOnlyMemory`1<byte> source, bool ownsMemory, Rfc3161TstInfo& tstInfo, Int32& bytesConsumed, Byte[]& copiedBytes);
    private static Byte[] Encode(Oid policyId, Oid hashAlgorithmId, ReadOnlyMemory`1<byte> messageHash, ReadOnlyMemory`1<byte> serialNumber, DateTimeOffset timestamp, bool isOrdering, Nullable`1<long> accuracyInMicroseconds, Nullable`1<ReadOnlyMemory`1<byte>> nonce, Nullable`1<ReadOnlyMemory`1<byte>> tsaName, X509ExtensionCollection extensions);
}
internal class System.Security.Cryptography.Pkcs.SignedAttributesSet : ValueType {
    internal AttributeAsn[] SignedAttributes;
    internal void Encode(AsnWriter writer);
    internal static SignedAttributesSet Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SignedAttributesSet& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SignedAttributesSet& decoded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.SignedCms : object {
    private SignedDataAsn _signedData;
    private bool _hasData;
    private SubjectIdentifierType _signerIdentifierType;
    private Memory`1<byte> _heldData;
    private Nullable`1<ReadOnlyMemory`1<byte>> _heldContent;
    private bool _hasPkcs7Content;
    private string _contentType;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentInfo <ContentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Detached>k__BackingField;
    public int Version { get; private set; }
    public ContentInfo ContentInfo { get; private set; }
    public bool Detached { get; private set; }
    public X509Certificate2Collection Certificates { get; }
    public SignerInfoCollection SignerInfos { get; }
    public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo, bool detached);
    public SignedCms(SubjectIdentifierType signerIdentifierType);
    public SignedCms(ContentInfo contentInfo);
    public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo);
    public SignedCms(ContentInfo contentInfo, bool detached);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    [CompilerGeneratedAttribute]
public ContentInfo get_ContentInfo();
    [CompilerGeneratedAttribute]
private void set_ContentInfo(ContentInfo value);
    [CompilerGeneratedAttribute]
public bool get_Detached();
    [CompilerGeneratedAttribute]
private void set_Detached(bool value);
    public X509Certificate2Collection get_Certificates();
    public SignerInfoCollection get_SignerInfos();
    public Byte[] Encode();
    public void Decode(Byte[] encodedMessage);
    [NullableContextAttribute("0")]
public void Decode(ReadOnlySpan`1<byte> encodedMessage);
    internal static ReadOnlyMemory`1<byte> GetContent(ReadOnlyMemory`1<byte> wrappedContent, string contentType);
    public void ComputeSignature();
    public void ComputeSignature(CmsSigner signer);
    public void ComputeSignature(CmsSigner signer, bool silent);
    public void RemoveSignature(int index);
    public void RemoveSignature(SignerInfo signerInfo);
    internal ReadOnlySpan`1<byte> GetHashableContentSpan();
    internal void Reencode();
    private void UpdateMetadata();
    private void ConsiderDigestAddition(AlgorithmIdentifierAsn candidate);
    private void ConsiderDigestRemoval(AlgorithmIdentifierAsn candidate);
    internal void UpdateCertificatesFromAddition(X509Certificate2Collection newCerts);
    public void CheckSignature(bool verifySignatureOnly);
    public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly);
    private static void CheckSignatures(SignerInfoCollection signers, X509Certificate2Collection extraStore, bool verifySignatureOnly);
    public void CheckHash();
    internal SignedDataAsn& GetRawData();
    public void AddCertificate(X509Certificate2 certificate);
    public void RemoveCertificate(X509Certificate2 certificate);
    private static ContentInfo MakeEmptyContentInfo();
    [CompilerGeneratedAttribute]
internal static Byte[] <Decode>g__CopyContent|26_0(ReadOnlySpan`1<byte> encodedMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.SignerInfo : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectIdentifier <SignerIdentifier>k__BackingField;
    private string _digestAlgorithm;
    private AttributeAsn[] _signedAttributes;
    private Nullable`1<ReadOnlyMemory`1<byte>> _signedAttributesMemory;
    private string _signatureAlgorithm;
    private Nullable`1<ReadOnlyMemory`1<byte>> _signatureAlgorithmParameters;
    private ReadOnlyMemory`1<byte> _signature;
    private AttributeAsn[] _unsignedAttributes;
    private SignedCms _document;
    private X509Certificate2 _signerCertificate;
    private SignerInfo _parentSignerInfo;
    private CryptographicAttributeObjectCollection _parsedSignedAttrs;
    private CryptographicAttributeObjectCollection _parsedUnsignedAttrs;
    public int Version { get; }
    public SubjectIdentifier SignerIdentifier { get; }
    public CryptographicAttributeObjectCollection SignedAttributes { get; }
    public CryptographicAttributeObjectCollection UnsignedAttributes { get; }
    [NullableAttribute("2")]
public X509Certificate2 Certificate { get; }
    public SignerInfoCollection CounterSignerInfos { get; }
    public Oid DigestAlgorithm { get; }
    public Oid SignatureAlgorithm { get; }
    internal SignerInfo(SignerInfoAsn& parsedData, SignedCms ownerDocument);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public SubjectIdentifier get_SignerIdentifier();
    public CryptographicAttributeObjectCollection get_SignedAttributes();
    public CryptographicAttributeObjectCollection get_UnsignedAttributes();
    internal ReadOnlyMemory`1<byte> GetSignatureMemory();
    public Byte[] GetSignature();
    [NullableContextAttribute("2")]
public X509Certificate2 get_Certificate();
    public SignerInfoCollection get_CounterSignerInfos();
    public Oid get_DigestAlgorithm();
    public Oid get_SignatureAlgorithm();
    private void WithSelfInfo(WithSelfInfoDelegate action);
    public void AddUnsignedAttribute(AsnEncodedData unsignedAttribute);
    private static void AddUnsignedAttribute(SignerInfoAsn& mySigner, AsnEncodedData unsignedAttribute);
    public void RemoveUnsignedAttribute(AsnEncodedData unsignedAttribute);
    private static void RemoveUnsignedAttribute(SignerInfoAsn& mySigner, AsnEncodedData unsignedAttribute);
    private SignerInfoCollection GetCounterSigners(AttributeAsn[] unsignedAttrs);
    [ObsoleteAttribute("ComputeCounterSignature without specifying a CmsSigner is obsolete and is not supported. Use the overload that accepts a CmsSigner.")]
public void ComputeCounterSignature();
    public void ComputeCounterSignature(CmsSigner signer);
    public void RemoveCounterSignature(int index);
    public void RemoveCounterSignature(SignerInfo counterSignerInfo);
    public void CheckSignature(bool verifySignatureOnly);
    public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly);
    public void CheckHash();
    private bool CheckHash(bool compatMode);
    private X509Certificate2 FindSignerCertificate();
    private static X509Certificate2 FindSignerCertificate(SubjectIdentifier signerIdentifier, X509Certificate2Collection extraStore);
    private IncrementalHash PrepareDigest(bool compatMode);
    private void Verify(X509Certificate2Collection extraStore, X509Certificate2 certificate, bool verifySignatureOnly);
    private bool VerifySignature(CmsSignature signatureProcessor, X509Certificate2 certificate, bool compatMode);
    private HashAlgorithmName GetDigestAlgorithm();
    internal static CryptographicAttributeObjectCollection MakeAttributeCollection(AttributeAsn[] attributes);
    private static CryptographicAttributeObject MakeAttribute(AttributeAsn attribute);
    private static int FindAttributeIndexByOid(AttributeAsn[] attributes, Oid oid, int startIndex);
    private static int FindAttributeValueIndexByEncodedData(ReadOnlyMemory`1[] attributeValues, ReadOnlySpan`1<byte> asnEncodedData, Boolean& isOnlyValue);
    private static ValueTuple`2<int, int> FindAttributeLocation(AttributeAsn[] attributes, AsnEncodedData attribute, Boolean& isOnlyValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.Pkcs.SignerInfoCollection : object {
    private SignerInfo[] _signerInfos;
    public SignerInfo Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal SignerInfoCollection(SignerInfo[] signerInfos);
    internal SignerInfoCollection(SignerInfoAsn[] signedDataSignerInfos, SignedCms ownerDocument);
    public SignerInfo get_Item(int index);
    public sealed virtual int get_Count();
    public SignerInfoEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(SignerInfo[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private static int FindIndexForSigner(SignerInfo[] signerInfos, SignerInfo signer);
    internal int FindIndexForSigner(SignerInfo signer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.SignerInfoEnumerator : object {
    private SignerInfoCollection _signerInfos;
    private int _position;
    public SignerInfo Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal SignerInfoEnumerator(SignerInfoCollection signerInfos);
    public SignerInfo get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.SubjectIdentifier : object {
    private static string DummySignerSubjectName;
    internal static Byte[] DummySignerEncodedValue;
    [CompilerGeneratedAttribute]
private SubjectIdentifierType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public SubjectIdentifierType Type { get; }
    public object Value { get; }
    internal SubjectIdentifier(SubjectIdentifierType type, object value);
    internal SubjectIdentifier(SignerIdentifierAsn signerIdentifierAsn);
    internal SubjectIdentifier(Nullable`1<IssuerAndSerialNumberAsn> issuerAndSerialNumber, Nullable`1<ReadOnlyMemory`1<byte>> subjectKeyIdentifier);
    private static SubjectIdentifier();
    [CompilerGeneratedAttribute]
public SubjectIdentifierType get_Type();
    [CompilerGeneratedAttribute]
public object get_Value();
    [NullableContextAttribute("1")]
public bool MatchesCertificate(X509Certificate2 certificate);
    internal bool IsEquivalentTo(SubjectIdentifier other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey : object {
    [CompilerGeneratedAttribute]
private SubjectIdentifierOrKeyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public SubjectIdentifierOrKeyType Type { get; }
    public object Value { get; }
    internal SubjectIdentifierOrKey(SubjectIdentifierOrKeyType type, object value);
    [CompilerGeneratedAttribute]
public SubjectIdentifierOrKeyType get_Type();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public enum System.Security.Cryptography.Pkcs.SubjectIdentifierOrKeyType : Enum {
    public int value__;
    public static SubjectIdentifierOrKeyType Unknown;
    public static SubjectIdentifierOrKeyType IssuerAndSerialNumber;
    public static SubjectIdentifierOrKeyType SubjectKeyIdentifier;
    public static SubjectIdentifierOrKeyType PublicKeyInfo;
}
public enum System.Security.Cryptography.Pkcs.SubjectIdentifierType : Enum {
    public int value__;
    public static SubjectIdentifierType Unknown;
    public static SubjectIdentifierType IssuerAndSerialNumber;
    public static SubjectIdentifierType SubjectKeyIdentifier;
    public static SubjectIdentifierType NoSignature;
}
internal class System.Security.Cryptography.SafeHashHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private SafeProvHandle _parent;
    internal static SafeHashHandle InvalidHandle { get; }
    internal void SetParent(SafeProvHandle parent);
    internal static SafeHashHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeKeyHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private int _keySpec;
    private bool _fPublicOnly;
    private SafeProvHandle _parent;
    internal int KeySpec { get; internal set; }
    internal bool PublicOnly { get; internal set; }
    internal static SafeKeyHandle InvalidHandle { get; }
    internal int get_KeySpec();
    internal void set_KeySpec(int value);
    internal bool get_PublicOnly();
    internal void set_PublicOnly(bool value);
    internal void SetParent(SafeProvHandle parent);
    internal static SafeKeyHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeProvHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private string _containerName;
    private string _providerName;
    private int _type;
    private UInt32 _flags;
    private bool _fPersistKeyInCsp;
    internal string ContainerName { get; internal set; }
    internal string ProviderName { get; internal set; }
    internal int Types { get; internal set; }
    internal UInt32 Flags { get; internal set; }
    internal bool PersistKeyInCsp { get; internal set; }
    internal static SafeProvHandle InvalidHandle { get; }
    internal string get_ContainerName();
    internal void set_ContainerName(string value);
    internal string get_ProviderName();
    internal void set_ProviderName(string value);
    internal int get_Types();
    internal void set_Types(int value);
    internal UInt32 get_Flags();
    internal void set_Flags(UInt32 value);
    internal bool get_PersistKeyInCsp();
    internal void set_PersistKeyInCsp(bool value);
    internal static SafeProvHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Xml.X509IssuerSerial : ValueType {
    [CompilerGeneratedAttribute]
private string <IssuerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerialNumber>k__BackingField;
    public string IssuerName { get; public set; }
    public string SerialNumber { get; public set; }
    internal X509IssuerSerial(string issuerName, string serialNumber);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_IssuerName();
    [CompilerGeneratedAttribute]
public void set_IssuerName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_SerialNumber();
    [CompilerGeneratedAttribute]
public void set_SerialNumber(string value);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_EmptyOrNullString_Named { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_EncodeDestinationTooSmall { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string Cryptography_AlgKdfRequiresChars { get; }
    internal static string Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum { get; }
    internal static string Cryptography_Asn_NamedBitListRequiresFlagsEnum { get; }
    internal static string Cryptography_Asn_NamedBitListValueTooBig { get; }
    internal static string Cryptography_Asn_UniversalValueIsFixed { get; }
    internal static string Cryptography_Asn_UnusedBitCountRange { get; }
    internal static string Cryptography_AsnWriter_EncodeUnbalancedStack { get; }
    internal static string Cryptography_AsnWriter_PopWrongTag { get; }
    internal static string Cryptography_BadHashValue { get; }
    internal static string Cryptography_BadSignature { get; }
    internal static string Cryptography_Cms_CannotDetermineSignatureAlgorithm { get; }
    internal static string Cryptography_Cms_IncompleteCertChain { get; }
    internal static string Cryptography_Cms_Invalid_Originator_Identifier_Choice { get; }
    internal static string Cryptography_Cms_Invalid_Subject_Identifier_Type { get; }
    internal static string Cryptography_Cms_InvalidMessageType { get; }
    internal static string Cryptography_Cms_InvalidSignerHashForSignatureAlg { get; }
    internal static string Cryptography_Cms_Key_Agree_Date_Not_Available { get; }
    internal static string Cryptography_Cms_MessageNotEncrypted { get; }
    internal static string Cryptography_Cms_MessageNotSigned { get; }
    internal static string Cryptography_Cms_MissingAuthenticatedAttribute { get; }
    internal static string Cryptography_Cms_NoCounterCounterSigner { get; }
    internal static string Cryptography_Cms_NoRecipients { get; }
    internal static string Cryptography_Cms_NoSignerCert { get; }
    internal static string Cryptography_Cms_NoSignerCertSilent { get; }
    internal static string Cryptography_Cms_NoSignerAtIndex { get; }
    internal static string Cryptography_Cms_RecipientNotFound { get; }
    internal static string Cryptography_Cms_RecipientType_NotSupported { get; }
    internal static string Cryptography_Cms_Sign_Empty_Content { get; }
    internal static string Cryptography_Cms_Sign_No_Signature_First_Signer { get; }
    internal static string Cryptography_Cms_SignerNotFound { get; }
    internal static string Cryptography_Cms_Signing_RequiresPrivateKey { get; }
    internal static string Cryptography_Cms_Ktri_RSARequired { get; }
    internal static string Cryptography_Cms_Recipient_RSARequired_RSAPaddingModeSupplied { get; }
    internal static string Cryptography_Cms_TrustFailure { get; }
    internal static string Cryptography_Cms_UnknownAlgorithm { get; }
    internal static string Cryptography_Cms_UnknownKeySpec { get; }
    internal static string Cryptography_Cms_WrongKeyUsage { get; }
    internal static string Cryptography_NotValidPublicOrPrivateKey { get; }
    internal static string Cryptography_Pkcs12_CannotProcessEncryptedSafeContents { get; }
    internal static string Cryptography_Pkcs12_CertBagNotX509 { get; }
    internal static string Cryptography_Pkcs12_PfxIsSealed { get; }
    internal static string Cryptography_Pkcs12_PfxMustBeSealed { get; }
    internal static string Cryptography_Pkcs12_SafeContentsIsEncrypted { get; }
    internal static string Cryptography_Pkcs12_SafeContentsIsReadOnly { get; }
    internal static string Cryptography_Pkcs12_WrongModeForDecrypt { get; }
    internal static string Cryptography_Pkcs12_WrongModeForVerify { get; }
    internal static string Cryptography_Pkcs_InvalidSignatureParameters { get; }
    internal static string Cryptography_Pkcs8_EncryptedReadFailed { get; }
    internal static string Cryptography_Pkcs9_AttributeMismatch { get; }
    internal static string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed { get; }
    internal static string Cryptography_Pkcs_PssParametersMissing { get; }
    internal static string Cryptography_Pkcs_PssParametersHashMismatch { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfHashMismatch { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfNotSupported { get; }
    internal static string Cryptography_Pkcs_PssParametersSaltMismatch { get; }
    internal static string Cryptography_TimestampReq_BadNonce { get; }
    internal static string Cryptography_TimestampReq_BadResponse { get; }
    internal static string Cryptography_TimestampReq_Failure { get; }
    internal static string Cryptography_TimestampReq_NoCertFound { get; }
    internal static string Cryptography_TimestampReq_UnexpectedCertFound { get; }
    internal static string InvalidOperation_DuplicateItemNotAllowed { get; }
    internal static string InvalidOperation_WrongOidInAsnCollection { get; }
    internal static string PlatformNotSupported_CryptographyPkcs { get; }
    internal static string Cryptography_AlgorithmNotSupported { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static string Cryptography_UnknownAlgorithmIdentifier { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_WriteEncodedValue_OneValueAtATime { get; }
    internal static string Cryptography_Cms_NoAttributeFound { get; }
    internal static string Cryptography_Cms_NoCertificateFound { get; }
    internal static string Cryptography_Cms_CertificateAlreadyInCollection { get; }
    internal static string Cryptography_Cms_InvalidSymmetricKey { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_EmptyOrNullString_Named();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_EncodeDestinationTooSmall();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Argument_InvalidValue();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_Cryptography_AlgKdfRequiresChars();
    internal static string get_Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum();
    internal static string get_Cryptography_Asn_NamedBitListRequiresFlagsEnum();
    internal static string get_Cryptography_Asn_NamedBitListValueTooBig();
    internal static string get_Cryptography_Asn_UniversalValueIsFixed();
    internal static string get_Cryptography_Asn_UnusedBitCountRange();
    internal static string get_Cryptography_AsnWriter_EncodeUnbalancedStack();
    internal static string get_Cryptography_AsnWriter_PopWrongTag();
    internal static string get_Cryptography_BadHashValue();
    internal static string get_Cryptography_BadSignature();
    internal static string get_Cryptography_Cms_CannotDetermineSignatureAlgorithm();
    internal static string get_Cryptography_Cms_IncompleteCertChain();
    internal static string get_Cryptography_Cms_Invalid_Originator_Identifier_Choice();
    internal static string get_Cryptography_Cms_Invalid_Subject_Identifier_Type();
    internal static string get_Cryptography_Cms_InvalidMessageType();
    internal static string get_Cryptography_Cms_InvalidSignerHashForSignatureAlg();
    internal static string get_Cryptography_Cms_Key_Agree_Date_Not_Available();
    internal static string get_Cryptography_Cms_MessageNotEncrypted();
    internal static string get_Cryptography_Cms_MessageNotSigned();
    internal static string get_Cryptography_Cms_MissingAuthenticatedAttribute();
    internal static string get_Cryptography_Cms_NoCounterCounterSigner();
    internal static string get_Cryptography_Cms_NoRecipients();
    internal static string get_Cryptography_Cms_NoSignerCert();
    internal static string get_Cryptography_Cms_NoSignerCertSilent();
    internal static string get_Cryptography_Cms_NoSignerAtIndex();
    internal static string get_Cryptography_Cms_RecipientNotFound();
    internal static string get_Cryptography_Cms_RecipientType_NotSupported();
    internal static string get_Cryptography_Cms_Sign_Empty_Content();
    internal static string get_Cryptography_Cms_Sign_No_Signature_First_Signer();
    internal static string get_Cryptography_Cms_SignerNotFound();
    internal static string get_Cryptography_Cms_Signing_RequiresPrivateKey();
    internal static string get_Cryptography_Cms_Ktri_RSARequired();
    internal static string get_Cryptography_Cms_Recipient_RSARequired_RSAPaddingModeSupplied();
    internal static string get_Cryptography_Cms_TrustFailure();
    internal static string get_Cryptography_Cms_UnknownAlgorithm();
    internal static string get_Cryptography_Cms_UnknownKeySpec();
    internal static string get_Cryptography_Cms_WrongKeyUsage();
    internal static string get_Cryptography_NotValidPublicOrPrivateKey();
    internal static string get_Cryptography_Pkcs12_CannotProcessEncryptedSafeContents();
    internal static string get_Cryptography_Pkcs12_CertBagNotX509();
    internal static string get_Cryptography_Pkcs12_PfxIsSealed();
    internal static string get_Cryptography_Pkcs12_PfxMustBeSealed();
    internal static string get_Cryptography_Pkcs12_SafeContentsIsEncrypted();
    internal static string get_Cryptography_Pkcs12_SafeContentsIsReadOnly();
    internal static string get_Cryptography_Pkcs12_WrongModeForDecrypt();
    internal static string get_Cryptography_Pkcs12_WrongModeForVerify();
    internal static string get_Cryptography_Pkcs_InvalidSignatureParameters();
    internal static string get_Cryptography_Pkcs8_EncryptedReadFailed();
    internal static string get_Cryptography_Pkcs9_AttributeMismatch();
    internal static string get_Cryptography_Pkcs9_MultipleSigningTimeNotAllowed();
    internal static string get_Cryptography_Pkcs_PssParametersMissing();
    internal static string get_Cryptography_Pkcs_PssParametersHashMismatch();
    internal static string get_Cryptography_Pkcs_PssParametersMgfHashMismatch();
    internal static string get_Cryptography_Pkcs_PssParametersMgfNotSupported();
    internal static string get_Cryptography_Pkcs_PssParametersSaltMismatch();
    internal static string get_Cryptography_TimestampReq_BadNonce();
    internal static string get_Cryptography_TimestampReq_BadResponse();
    internal static string get_Cryptography_TimestampReq_Failure();
    internal static string get_Cryptography_TimestampReq_NoCertFound();
    internal static string get_Cryptography_TimestampReq_UnexpectedCertFound();
    internal static string get_InvalidOperation_DuplicateItemNotAllowed();
    internal static string get_InvalidOperation_WrongOidInAsnCollection();
    internal static string get_PlatformNotSupported_CryptographyPkcs();
    internal static string get_Cryptography_AlgorithmNotSupported();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Invalid_IA5String();
    internal static string get_Cryptography_UnknownAlgorithmIdentifier();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_WriteEncodedValue_OneValueAtATime();
    internal static string get_Cryptography_Cms_NoAttributeFound();
    internal static string get_Cryptography_Cms_NoCertificateFound();
    internal static string get_Cryptography_Cms_CertificateAlreadyInCollection();
    internal static string get_Cryptography_Cms_InvalidSymmetricKey();
}
