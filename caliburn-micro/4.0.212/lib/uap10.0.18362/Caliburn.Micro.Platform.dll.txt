public static class Caliburn.Micro.Action : object {
    private static ILog Log;
    public static DependencyProperty TargetProperty;
    public static DependencyProperty TargetWithoutContextProperty;
    private static Action();
    public static void SetTarget(DependencyObject d, object target);
    public static object GetTarget(DependencyObject d);
    public static void SetTargetWithoutContext(DependencyObject d, object target);
    public static object GetTargetWithoutContext(DependencyObject d);
    public static bool HasTargetSet(DependencyObject element);
    public static void Invoke(object target, string methodName, DependencyObject view, FrameworkElement source, object eventArgs, Object[] parameters);
    private static void OnTargetWithoutContextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnTargetChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SetTargetCore(DependencyPropertyChangedEventArgs e, DependencyObject d, bool setContext);
}
[DefaultMemberAttribute("Item")]
public class Caliburn.Micro.ActionExecutionContext : object {
    private WeakReference message;
    private WeakReference source;
    private WeakReference target;
    private WeakReference view;
    private Dictionary`2<string, object> values;
    public Func`1<bool> CanExecute;
    public object EventArgs;
    public MethodInfo Method;
    [CompilerGeneratedAttribute]
private EventHandler Disposing;
    public ActionMessage Message { get; public set; }
    public FrameworkElement Source { get; public set; }
    public object Target { get; public set; }
    public DependencyObject View { get; public set; }
    public object Item { get; public set; }
    public ActionMessage get_Message();
    public void set_Message(ActionMessage value);
    public FrameworkElement get_Source();
    public void set_Source(FrameworkElement value);
    public object get_Target();
    public void set_Target(object value);
    public DependencyObject get_View();
    public void set_View(DependencyObject value);
    public object get_Item(string key);
    public void set_Item(string key, object value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public void add_Disposing(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposing(EventHandler value);
}
[ContentPropertyAttribute]
public class Caliburn.Micro.ActionMessage : TriggerAction`1<FrameworkElement> {
    private static ILog Log;
    private ActionExecutionContext context;
    internal static DependencyProperty HandlerProperty;
    public static bool EnforceGuardsDuringInvocation;
    public static bool ThrowsExceptions;
    public static DependencyProperty MethodNameProperty;
    public static DependencyProperty ParametersProperty;
    [CompilerGeneratedAttribute]
private EventHandler Detaching;
    public static Action`1<ActionExecutionContext> InvokeAction;
    public static Func`2<ActionExecutionContext, bool> ApplyAvailabilityEffect;
    public static Func`3<ActionMessage, object, MethodInfo> GetTargetMethod;
    public static Action`1<ActionExecutionContext> SetMethodBinding;
    public static Action`1<ActionExecutionContext> PrepareContext;
    public static Func`2<MethodInfo, IEnumerable`1<string>> BuildPossibleGuardNames;
    public string MethodName { get; public set; }
    public AttachedCollection`1<Parameter> Parameters { get; }
    private static ActionMessage();
    public string get_MethodName();
    public void set_MethodName(string value);
    public sealed virtual AttachedCollection`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public void add_Detaching(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Detaching(EventHandler value);
    protected virtual void OnAttached();
    private void ElementUnloaded(object sender, RoutedEventArgs e);
    private static void HandlerPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDetaching();
    private void ElementLoaded(object sender, RoutedEventArgs e);
    private void UpdateContext();
    protected virtual void Invoke(object eventArgs);
    public virtual void UpdateAvailability();
    private bool UpdateAvailabilityCore();
    public virtual string ToString();
    private static MethodInfo TryFindGuardMethod(ActionExecutionContext context, IEnumerable`1<string> possibleGuardNames);
    private static MethodInfo GetMethodInfo(Type t, string methodName);
    [CompilerGeneratedAttribute]
private void <OnAttached>b__16_0(Parameter x);
}
internal class Caliburn.Micro.Activator : MulticastDelegate {
    public Activator(object object, IntPtr method);
    public virtual object Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class Caliburn.Micro.AddToCollection : MulticastDelegate {
    public AddToCollection(object object, IntPtr method);
    public virtual void Invoke(object instance, object item);
    public virtual IAsyncResult BeginInvoke(object instance, object item, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Caliburn.Micro.AddToDictionary : MulticastDelegate {
    public AddToDictionary(object object, IntPtr method);
    public virtual void Invoke(object instance, object key, object item);
    public virtual IAsyncResult BeginInvoke(object instance, object key, object item, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Caliburn.Micro.AppManifestHelper : object {
    [AsyncStateMachineAttribute("Caliburn.Micro.AppManifestHelper/<GetManifestVisualElementsAsync>d__0")]
public static Task`1<VisualElement> GetManifestVisualElementsAsync();
}
public class Caliburn.Micro.AttachedCollection`1 : DependencyObjectCollection {
    private DependencyObject associatedObject;
    public DependencyObject AssociatedObject { get; }
    public sealed virtual void Attach(DependencyObject dependencyObject);
    public sealed virtual void Detach();
    public sealed virtual DependencyObject get_AssociatedObject();
    protected virtual void OnItemAdded(DependencyObject item);
    protected virtual void OnItemRemoved(DependencyObject item);
    private void OnVectorChanged(IObservableVector`1<DependencyObject> sender, IVectorChangedEventArgs event);
    [CompilerGeneratedAttribute]
private void <Attach>b__2_0(IAttachedObject x);
}
public static class Caliburn.Micro.Bind : object {
    public static DependencyProperty ModelProperty;
    public static DependencyProperty ModelWithoutContextProperty;
    internal static DependencyProperty NoContextProperty;
    public static DependencyProperty AtDesignTimeProperty;
    private static DependencyProperty DataContextProperty;
    private static Bind();
    public static object GetModelWithoutContext(DependencyObject dependencyObject);
    public static void SetModelWithoutContext(DependencyObject dependencyObject, object value);
    public static object GetModel(DependencyObject dependencyObject);
    public static void SetModel(DependencyObject dependencyObject, object value);
    private static void ModelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ModelWithoutContextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public static bool GetAtDesignTime(DependencyObject dependencyObject);
    public static void SetAtDesignTime(DependencyObject dependencyObject, bool value);
    private static void AtDesignTimeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DataContextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
[ExtensionAttribute]
public static class Caliburn.Micro.BindingScope : object {
    private static List`1<ChildResolver> ChildResolvers;
    private static Dictionary`2<Type, object> NonResolvableChildTypes;
    public static Func`2<DependencyObject, IEnumerable`1<FrameworkElement>> GetNamedElements;
    public static Func`2<DependencyObject, DependencyObject> GetVisualParent;
    public static Func`2<ScopeNamingRoute, IEnumerable`1<FrameworkElement>> FindNamedDescendants;
    public static Func`2<DependencyObject, ScopeNamingRoute> FindScopeNamingRoute;
    private static BindingScope();
    [ExtensionAttribute]
public static FrameworkElement FindName(IEnumerable`1<FrameworkElement> elementsToSearch, string name);
    public static ChildResolver AddChildResolver(Func`2<Type, bool> filter, Func`2<DependencyObject, IEnumerable`1<DependencyObject>> resolver);
    public static ChildResolver AddChildResolver(Func`2<T, IEnumerable`1<DependencyObject>> resolver);
    public static bool RemoveChildResolver(ChildResolver resolver);
    [IteratorStateMachineAttribute("Caliburn.Micro.BindingScope/<ResolveFlyoutBase>d__10")]
private static IEnumerable`1<DependencyObject> ResolveFlyoutBase(FlyoutBase flyoutBase);
    [IteratorStateMachineAttribute("Caliburn.Micro.BindingScope/<ResolveMenuFlyoutItems>d__11")]
private static IEnumerable`1<DependencyObject> ResolveMenuFlyoutItems(MenuFlyoutItemBase item);
    [IteratorStateMachineAttribute("Caliburn.Micro.BindingScope/<ResolveCommandBar>d__12")]
private static IEnumerable`1<DependencyObject> ResolveCommandBar(CommandBar commandBar);
    [IteratorStateMachineAttribute("Caliburn.Micro.BindingScope/<ResolveHub>d__13")]
private static IEnumerable`1<DependencyObject> ResolveHub(Hub hub);
}
public class Caliburn.Micro.BooleanToVisibilityConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, string language);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, string language);
}
public class Caliburn.Micro.CachingFrameAdapter : FrameAdapter {
    private static ILog Log;
    private Frame frame;
    private List`1<object> viewModelBackStack;
    private List`1<object> viewModelForwardStack;
    public IList`1<PageStackEntry> BackStack { get; }
    public IList`1<PageStackEntry> ForwardStack { get; }
    public CachingFrameAdapter(Frame frame, bool treatViewAsLoaded);
    private static CachingFrameAdapter();
    protected virtual void OnNavigating(object sender, NavigatingCancelEventArgs e);
    [AsyncStateMachineAttribute("Caliburn.Micro.CachingFrameAdapter/<OnNavigated>d__6")]
protected virtual void OnNavigated(object sender, NavigationEventArgs e);
    private static T PopOffStack(IList`1<T> stack);
    public virtual IList`1<PageStackEntry> get_BackStack();
    public virtual IList`1<PageStackEntry> get_ForwardStack();
    private static void ApplyCollectionChanges(NotifyCollectionChangedEventArgs e, IList`1<object> viewModels, IList`1<PageStackEntry> frameEntries);
    [CompilerGeneratedAttribute]
private void <get_BackStack>b__9_0(object s, NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
private void <get_ForwardStack>b__11_0(object s, NotifyCollectionChangedEventArgs e);
}
public abstract class Caliburn.Micro.CaliburnApplication : Application {
    private bool isInitialized;
    [CompilerGeneratedAttribute]
private Frame <RootFrame>k__BackingField;
    protected Frame RootFrame { get; private set; }
    [CompilerGeneratedAttribute]
protected Frame get_RootFrame();
    [CompilerGeneratedAttribute]
private void set_RootFrame(Frame value);
    protected virtual void StartDesignTime();
    protected virtual void StartRuntime();
    protected void Initialize();
    protected virtual void OnWindowCreated(WindowCreatedEventArgs args);
    protected virtual void PrepareApplication();
    protected virtual void Configure();
    protected virtual IEnumerable`1<Assembly> SelectAssemblies();
    protected virtual object GetInstance(Type service, string key);
    protected virtual IEnumerable`1<object> GetAllInstances(Type service);
    protected virtual void BuildUp(object instance);
    protected virtual void OnResuming(object sender, object e);
    protected virtual void OnSuspending(object sender, SuspendingEventArgs e);
    protected virtual void OnUnhandledException(object sender, UnhandledExceptionEventArgs e);
    protected virtual Frame CreateApplicationFrame();
    protected virtual void PrepareViewFirst();
    protected virtual void PrepareViewFirst(Frame rootFrame);
    protected void DisplayRootView(Type viewType, object paramter);
    protected void DisplayRootView(object parameter);
    [AsyncStateMachineAttribute("Caliburn.Micro.CaliburnApplication/<DisplayRootViewForAsync>d__23")]
protected Task DisplayRootViewForAsync(Type viewModelType, CancellationToken cancellationToken);
    protected Task DisplayRootViewForAsync(Type viewModelType);
    protected Task DisplayRootViewForAsync(CancellationToken cancellationToken);
    protected Task DisplayRootViewForAsync();
}
public class Caliburn.Micro.ChildResolver : object {
    private Func`2<Type, bool> filter;
    private Func`2<DependencyObject, IEnumerable`1<DependencyObject>> resolver;
    public ChildResolver(Func`2<Type, bool> filter, Func`2<DependencyObject, IEnumerable`1<DependencyObject>> resolver);
    public bool CanResolve(Type type);
    public IEnumerable`1<DependencyObject> Resolve(DependencyObject obj);
}
public class Caliburn.Micro.ChildResolver`1 : ChildResolver {
    public ChildResolver`1(Func`2<T, IEnumerable`1<DependencyObject>> resolver);
}
[ExtensionAttribute]
public static class Caliburn.Micro.ConventionManager : object {
    private static ILog Log;
    public static IValueConverter BooleanToVisibilityConverter;
    public static bool IncludeStaticProperties;
    public static bool OverwriteContent;
    public static DataTemplate DefaultItemTemplate;
    public static DataTemplate DefaultHeaderTemplate;
    private static Dictionary`2<Type, ElementConvention> ElementConventions;
    public static Func`2<string, string> Singularize;
    public static Func`2<string, IEnumerable`1<string>> DerivePotentialSelectionNames;
    public static Action`6<Type, string, PropertyInfo, FrameworkElement, ElementConvention, DependencyProperty> SetBinding;
    public static Action`2<Binding, PropertyInfo> ApplyBindingMode;
    public static Action`3<Binding, Type, PropertyInfo> ApplyValidation;
    public static Action`3<Binding, DependencyProperty, PropertyInfo> ApplyValueConverter;
    public static Action`3<Binding, ElementConvention, PropertyInfo> ApplyStringFormat;
    public static Action`4<DependencyProperty, DependencyObject, Binding, PropertyInfo> ApplyUpdateSourceTrigger;
    public static Action`4<FrameworkElement, DependencyProperty, Type, string> ConfigureSelectedItem;
    public static Func`6<FrameworkElement, DependencyProperty, Type, string, Binding, bool> ConfigureSelectedItemBinding;
    private static ConventionManager();
    public static ElementConvention AddElementConvention(DependencyProperty bindableProperty, string parameterProperty, string eventName);
    public static ElementConvention AddElementConvention(ElementConvention convention);
    public static ElementConvention GetElementConvention(Type elementType);
    public static bool HasBinding(FrameworkElement element, DependencyProperty property);
    public static bool SetBindingWithoutBindingOverwrite(Type viewModelType, string path, PropertyInfo property, FrameworkElement element, ElementConvention convention, DependencyProperty bindableProperty);
    public static bool SetBindingWithoutBindingOrValueOverwrite(Type viewModelType, string path, PropertyInfo property, FrameworkElement element, ElementConvention convention, DependencyProperty bindableProperty);
    public static void ApplyItemTemplate(ItemsControl itemsControl, PropertyInfo property);
    public static void ApplyHeaderTemplate(FrameworkElement element, DependencyProperty headerTemplateProperty, DependencyProperty headerTemplateSelectorProperty, Type viewModelType);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyCaseInsensitive(Type type, string propertyName);
}
public static class Caliburn.Micro.DependencyPropertyHelper : object {
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, object defaultValue, PropertyChangedCallback propertyChangedCallback);
}
[ExtensionAttribute]
public static class Caliburn.Micro.DispatcherTaskExtensions : object {
    [AsyncStateMachineAttribute("Caliburn.Micro.DispatcherTaskExtensions/<RunTaskAsync>d__0`1")]
[ExtensionAttribute]
public static Task`1<T> RunTaskAsync(CoreDispatcher dispatcher, Func`1<Task`1<T>> func, CoreDispatcherPriority priority);
    [AsyncStateMachineAttribute("Caliburn.Micro.DispatcherTaskExtensions/<RunTaskAsync>d__1")]
[ExtensionAttribute]
public static Task RunTaskAsync(CoreDispatcher dispatcher, Func`1<Task> func, CoreDispatcherPriority priority);
}
public class Caliburn.Micro.ElementConvention : object {
    public Type ElementType;
    public Func`2<DependencyObject, DependencyProperty> GetBindableProperty;
    public Func`1<IBehavior> CreateTrigger;
    public string ParameterProperty;
    public Func`6<Type, string, PropertyInfo, FrameworkElement, ElementConvention, bool> ApplyBinding;
}
public class Caliburn.Micro.FrameAdapter : object {
    private SystemNavigationManager navigationManager;
    private static ILog Log;
    private static string FrameStateKey;
    private static string ParameterKey;
    private Frame frame;
    private bool treatViewAsLoaded;
    [CompilerGeneratedAttribute]
private NavigatingCancelEventHandler ExternalNavigatingHandler;
    [CompilerGeneratedAttribute]
private object <CurrentParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<BackRequestedEventArgs> BackRequested;
    protected object CurrentParameter { get; protected set; }
    public Type SourcePageType { get; public set; }
    public Type CurrentSourcePageType { get; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    public IList`1<PageStackEntry> BackStack { get; }
    public IList`1<PageStackEntry> ForwardStack { get; }
    public FrameAdapter(Frame frame, bool treatViewAsLoaded);
    private static FrameAdapter();
    [CompilerGeneratedAttribute]
private void add_ExternalNavigatingHandler(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_ExternalNavigatingHandler(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
protected object get_CurrentParameter();
    [CompilerGeneratedAttribute]
protected void set_CurrentParameter(object value);
    [AsyncStateMachineAttribute("Caliburn.Micro.FrameAdapter/<OnNavigating>d__14")]
protected virtual void OnNavigating(object sender, NavigatingCancelEventArgs e);
    [AsyncStateMachineAttribute("Caliburn.Micro.FrameAdapter/<OnNavigated>d__15")]
protected virtual void OnNavigated(object sender, NavigationEventArgs e);
    [AsyncStateMachineAttribute("Caliburn.Micro.FrameAdapter/<BindViewModel>d__16")]
protected virtual Task BindViewModel(DependencyObject view, object viewModel);
    protected virtual void TryInjectParameters(object viewModel, object parameter);
    protected virtual bool CanCloseOnNavigating(object sender, NavigatingCancelEventArgs e);
    public sealed virtual void add_Navigated(NavigatedEventHandler value);
    public sealed virtual void remove_Navigated(NavigatedEventHandler value);
    public sealed virtual void add_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void remove_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    public virtual Type get_SourcePageType();
    public virtual void set_SourcePageType(Type value);
    public virtual Type get_CurrentSourcePageType();
    public virtual bool Navigate(Type sourcePageType);
    public virtual bool Navigate(Type sourcePageType, object parameter);
    public virtual void GoForward();
    public virtual void GoBack();
    public virtual bool get_CanGoForward();
    public virtual bool get_CanGoBack();
    public virtual IList`1<PageStackEntry> get_BackStack();
    public virtual IList`1<PageStackEntry> get_ForwardStack();
    public virtual bool SuspendState();
    [AsyncStateMachineAttribute("Caliburn.Micro.FrameAdapter/<ResumeStateAsync>d__49")]
public virtual Task`1<bool> ResumeStateAsync();
    [CompilerGeneratedAttribute]
public sealed virtual void add_BackRequested(EventHandler`1<BackRequestedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BackRequested(EventHandler`1<BackRequestedEventArgs> value);
    protected virtual void OnBackRequested(BackRequestedEventArgs e);
    private void OnBackRequested(object sender, BackRequestedEventArgs e);
    private static ApplicationDataContainer GetSettingsContainer();
    public sealed virtual void Dispose();
}
internal class Caliburn.Micro.Getter : MulticastDelegate {
    public Getter(object object, IntPtr method);
    public virtual object Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public interface Caliburn.Micro.IAttachedObject {
    public DependencyObject AssociatedObject { get; }
    public abstract virtual void Attach(DependencyObject dependencyObject);
    public abstract virtual void Detach();
    public abstract virtual DependencyObject get_AssociatedObject();
}
public interface Caliburn.Micro.IHaveParameters {
    public AttachedCollection`1<Parameter> Parameters { get; }
    public abstract virtual AttachedCollection`1<Parameter> get_Parameters();
}
public interface Caliburn.Micro.INavigationService {
    public Type SourcePageType { get; public set; }
    public Type CurrentSourcePageType { get; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    public IList`1<PageStackEntry> BackStack { get; }
    public IList`1<PageStackEntry> ForwardStack { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    public abstract virtual Type get_SourcePageType();
    public abstract virtual void set_SourcePageType(Type value);
    public abstract virtual Type get_CurrentSourcePageType();
    public abstract virtual bool get_CanGoForward();
    public abstract virtual bool get_CanGoBack();
    public abstract virtual bool Navigate(Type sourcePageType);
    public abstract virtual bool Navigate(Type sourcePageType, object parameter);
    public abstract virtual void GoForward();
    public abstract virtual void GoBack();
    public abstract virtual IList`1<PageStackEntry> get_BackStack();
    public abstract virtual IList`1<PageStackEntry> get_ForwardStack();
    [CompilerGeneratedAttribute]
public abstract virtual void add_BackRequested(EventHandler`1<BackRequestedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BackRequested(EventHandler`1<BackRequestedEventArgs> value);
    public abstract virtual bool SuspendState();
    public abstract virtual Task`1<bool> ResumeStateAsync();
}
public interface Caliburn.Micro.ISharingService {
    public abstract virtual void ShowShareUI();
}
public interface Caliburn.Micro.ISupportSharing {
    public abstract virtual void OnShareRequested(DataRequest dataRequest);
}
public static class Caliburn.Micro.Message : object {
    internal static DependencyProperty HandlerProperty;
    private static DependencyProperty MessageTriggersProperty;
    public static DependencyProperty AttachProperty;
    private static Message();
    public static void SetHandler(DependencyObject d, object value);
    public static object GetHandler(DependencyObject d);
    public static void SetAttach(DependencyObject d, string attachText);
    public static string GetAttach(DependencyObject d);
    private static void OnAttachChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
public static class Caliburn.Micro.MessageBinder : object {
    public static Dictionary`2<string, Func`2<ActionExecutionContext, object>> SpecialValues;
    public static Dictionary`2<Type, Func`3<object, object, object>> CustomConverters;
    public static Func`4<string, Type, ActionExecutionContext, object> EvaluateParameter;
    private static MessageBinder();
    public static Object[] DetermineParameters(ActionExecutionContext context, ParameterInfo[] requiredParameters);
    public static object CoerceValue(Type destinationType, object providedValue, object context);
    public static object GetDefaultValue(Type type);
}
public class Caliburn.Micro.NavigateHelper`1 : object {
    private Dictionary`2<string, string> queryString;
    private INavigationService navigationService;
    public NavigateHelper`1<TViewModel> WithParam(Expression`1<Func`2<TViewModel, TValue>> property, TValue value);
    public NavigateHelper`1<TViewModel> AttachTo(INavigationService navigationService);
    public void Navigate();
    public Uri BuildUri();
    private string BuildQueryString();
}
[ExtensionAttribute]
public static class Caliburn.Micro.NavigationExtensions : object {
    [ExtensionAttribute]
public static bool Navigate(INavigationService navigationService, object parameter);
    [ExtensionAttribute]
public static bool NavigateToViewModel(INavigationService navigationService, Type viewModelType, object parameter);
    [ExtensionAttribute]
public static bool NavigateToViewModel(INavigationService navigationService, object parameter);
    [ExtensionAttribute]
[ObsoleteAttribute("Use For instead of UriFor")]
public static NavigateHelper`1<TViewModel> UriFor(INavigationService navigationService);
    [ExtensionAttribute]
public static NavigateHelper`1<TViewModel> For(INavigationService navigationService);
}
public class Caliburn.Micro.Parameter : DependencyObject {
    private DependencyObject associatedObject;
    private WeakReference owner;
    public static DependencyProperty ValueProperty;
    public object Value { get; public set; }
    private DependencyObject Caliburn.Micro.IAttachedObject.AssociatedObject { get; }
    protected ActionMessage Owner { get; protected set; }
    private static Parameter();
    public object get_Value();
    public void set_Value(object value);
    private sealed virtual override DependencyObject Caliburn.Micro.IAttachedObject.get_AssociatedObject();
    protected ActionMessage get_Owner();
    protected void set_Owner(ActionMessage value);
    private sealed virtual override void Caliburn.Micro.IAttachedObject.Attach(DependencyObject dependencyObject);
    private sealed virtual override void Caliburn.Micro.IAttachedObject.Detach();
    internal void MakeAwareOf(ActionMessage owner);
    private static void OnValueChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
public static class Caliburn.Micro.Parser : object {
    private static Regex LongFormatRegularExpression;
    private static ILog Log;
    public static Func`3<DependencyObject, string, IBehavior> CreateTrigger;
    public static Func`3<DependencyObject, string, IAction> InterpretMessageText;
    public static Func`3<DependencyObject, string, Parameter> CreateParameter;
    private static Parser();
    public static IEnumerable`1<IBehavior> Parse(DependencyObject target, string text);
    private static void AddActionToTrigger(DependencyObject target, IAction message, IBehavior trigger);
    public static IAction CreateMessage(DependencyObject target, string messageText);
    public static void BindParameter(FrameworkElement target, Parameter parameter, string elementName, string path, BindingMode bindingMode);
}
internal class Caliburn.Micro.Setter : MulticastDelegate {
    public Setter(object object, IntPtr method);
    public virtual void Invoke(object instance, object value);
    public virtual IAsyncResult BeginInvoke(object instance, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Caliburn.Micro.SharingService : object {
    private DataTransferManager transferManager;
    public sealed virtual void ShowShareUI();
    protected virtual void OnDataRequested(DataTransferManager sender, DataRequestedEventArgs args);
    protected virtual FrameworkElement GetCurrentView();
}
public abstract class Caliburn.Micro.TriggerAction`1 : DependencyObject {
    public static DependencyProperty AssociatedObjectProperty;
    public FrameworkElement AssociatedObject { get; public set; }
    private static TriggerAction`1();
    public FrameworkElement get_AssociatedObject();
    public void set_AssociatedObject(FrameworkElement value);
    protected abstract virtual void Invoke(object parmeter);
    public virtual object Execute(object sender, object parameter);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private static void OnAssociatedObjectChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
public static class Caliburn.Micro.View : object {
    private static ILog Log;
    private static string DefaultContentPropertyName;
    public static DependencyProperty IsLoadedProperty;
    public static DependencyProperty IsScopeRootProperty;
    public static DependencyProperty ApplyConventionsProperty;
    public static DependencyProperty ContextProperty;
    public static DependencyProperty ModelProperty;
    public static DependencyProperty IsGeneratedProperty;
    public static Func`2<object, object> GetFirstNonGeneratedView;
    private static Nullable`1<bool> inDesignMode;
    public static bool InDesignMode { get; }
    private static View();
    public static bool ExecuteOnLoad(FrameworkElement element, RoutedEventHandler handler);
    public static void ExecuteOnUnload(FrameworkElement element, RoutedEventHandler handler);
    public static bool IsElementLoaded(FrameworkElement element);
    public static void ExecuteOnLayoutUpdated(FrameworkElement element, EventHandler`1<object> handler);
    public static Nullable`1<bool> GetApplyConventions(DependencyObject d);
    public static void SetApplyConventions(DependencyObject d, Nullable`1<bool> value);
    public static void SetModel(DependencyObject d, object value);
    public static object GetModel(DependencyObject d);
    public static object GetContext(DependencyObject d);
    public static void SetContext(DependencyObject d, object value);
    private static void OnModelChanged(DependencyObject targetLocation, DependencyPropertyChangedEventArgs args);
    private static void OnContextChanged(DependencyObject targetLocation, DependencyPropertyChangedEventArgs e);
    private static bool SetContentProperty(object targetLocation, object view);
    private static bool SetContentPropertyCore(object targetLocation, object view);
    private static string GetContentPropertyName(Type type);
    public static bool get_InDesignMode();
}
public static class Caliburn.Micro.ViewLocator : object {
    private static ILog Log;
    private static string defaultSubNsViews;
    private static string defaultSubNsViewModels;
    private static bool useNameSuffixesInMappings;
    private static string nameFormat;
    private static string viewModelSuffix;
    private static List`1<string> ViewSuffixList;
    private static bool includeViewSuffixInVmNames;
    public static NameTransformer NameTransformer;
    public static string ContextSeparator;
    public static Func`2<Type, UIElement> GetOrCreateViewType;
    public static Func`2<string, string> ModifyModelTypeAtDesignTime;
    public static Func`3<string, object, IEnumerable`1<string>> TransformName;
    public static Func`4<Type, DependencyObject, object, Type> LocateTypeForModelType;
    public static Func`4<Type, DependencyObject, object, UIElement> LocateForModelType;
    public static Func`4<object, DependencyObject, object, UIElement> LocateForModel;
    public static Func`3<Type, Type, string> DeterminePackUriFromType;
    private static ViewLocator();
    public static void ConfigureTypeMappings(TypeMappingConfiguration config);
    private static void SetAllDefaults();
    public static void AddDefaultTypeMapping(string viewSuffix);
    public static void RegisterViewSuffix(string viewSuffix);
    public static void AddTypeMapping(string nsSourceReplaceRegEx, string nsSourceFilterRegEx, String[] nsTargetsRegEx, string viewSuffix);
    public static void AddTypeMapping(string nsSourceReplaceRegEx, string nsSourceFilterRegEx, string nsTargetRegEx, string viewSuffix);
    public static void AddNamespaceMapping(string nsSource, String[] nsTargets, string viewSuffix);
    public static void AddNamespaceMapping(string nsSource, string nsTarget, string viewSuffix);
    public static void AddSubNamespaceMapping(string nsSource, String[] nsTargets, string viewSuffix);
    public static void AddSubNamespaceMapping(string nsSource, string nsTarget, string viewSuffix);
    public static void InitializeComponent(object element);
}
public static class Caliburn.Micro.ViewModelBinder : object {
    private static string AsyncSuffix;
    private static ILog Log;
    public static bool ApplyConventionsByDefault;
    public static DependencyProperty ConventionsAppliedProperty;
    public static Func`3<IEnumerable`1<FrameworkElement>, Type, IEnumerable`1<FrameworkElement>> BindProperties;
    public static Func`3<IEnumerable`1<FrameworkElement>, Type, IEnumerable`1<FrameworkElement>> BindActions;
    public static Action`2<IEnumerable`1<FrameworkElement>, Type> HandleUnmatchedElements;
    public static Action`3<object, DependencyObject, object> Bind;
    private static ViewModelBinder();
    public static bool ShouldApplyConventions(FrameworkElement view);
    private static bool IsAsyncMethod(MethodInfo method);
}
public static class Caliburn.Micro.ViewModelLocator : object {
    private static string DefaultViewSuffix;
    private static ILog Log;
    private static string defaultSubNsViews;
    private static string defaultSubNsViewModels;
    private static bool useNameSuffixesInMappings;
    private static string nameFormat;
    private static string viewModelSuffix;
    private static List`1<string> ViewSuffixList;
    private static bool includeViewSuffixInVmNames;
    public static NameTransformer NameTransformer;
    public static string InterfaceCaptureGroupName;
    public static Func`3<string, bool, IEnumerable`1<string>> TransformName;
    public static Func`3<Type, bool, Type> LocateTypeForViewType;
    public static Func`2<Type, object> LocateForViewType;
    public static Func`2<object, object> LocateForView;
    private static ViewModelLocator();
    public static void ConfigureTypeMappings(TypeMappingConfiguration config);
    private static void SetAllDefaults();
    public static void AddDefaultTypeMapping(string viewSuffix);
    public static void AddTypeMapping(string nsSourceReplaceRegEx, string nsSourceFilterRegEx, String[] nsTargetsRegEx, string viewSuffix);
    public static void AddTypeMapping(string nsSourceReplaceRegEx, string nsSourceFilterRegEx, string nsTargetRegEx, string viewSuffix);
    public static void AddNamespaceMapping(string nsSource, String[] nsTargets, string viewSuffix);
    public static void AddNamespaceMapping(string nsSource, string nsTarget, string viewSuffix);
    public static void AddSubNamespaceMapping(string nsSource, String[] nsTargets, string viewSuffix);
    public static void AddSubNamespaceMapping(string nsSource, string nsTarget, string viewSuffix);
    public static string MakeInterface(string typeName);
}
internal class Caliburn.Micro.VisualElement : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LogoUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SmallLogoUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackgroundColorAsString>k__BackingField;
    public string DisplayName { get; public set; }
    public string Description { get; public set; }
    public Uri LogoUri { get; public set; }
    public Uri SmallLogoUri { get; public set; }
    public string BackgroundColorAsString { get; public set; }
    public Color BackgroundColor { get; }
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Uri get_LogoUri();
    [CompilerGeneratedAttribute]
public void set_LogoUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_SmallLogoUri();
    [CompilerGeneratedAttribute]
public void set_SmallLogoUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_BackgroundColorAsString();
    [CompilerGeneratedAttribute]
public void set_BackgroundColorAsString(string value);
    public Color get_BackgroundColor();
    private static Color ToColor(string hexValue);
}
public class Caliburn.Micro.WinRTContainer : SimpleContainer {
    public void RegisterWinRTServices();
    public INavigationService RegisterNavigationService(Frame rootFrame, bool treatViewAsLoaded, bool cacheViewModels);
    public ISharingService RegisterSharingService();
}
internal class Caliburn.Micro.XamlMember : object {
    private XamlTypeInfoProvider _provider;
    private string _name;
    private bool _isAttachable;
    private bool _isDependencyProperty;
    private bool _isReadOnly;
    private string _typeName;
    private string _targetTypeName;
    [CompilerGeneratedAttribute]
private Getter <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private Setter <Setter>k__BackingField;
    public string Name { get; }
    public IXamlType Type { get; }
    public IXamlType TargetType { get; }
    public bool IsAttachable { get; }
    public bool IsDependencyProperty { get; }
    public bool IsReadOnly { get; }
    public Getter Getter { get; public set; }
    public Setter Setter { get; public set; }
    public XamlMember(XamlTypeInfoProvider provider, string name, string typeName);
    public sealed virtual string get_Name();
    public sealed virtual IXamlType get_Type();
    public void SetTargetTypeName(string targetTypeName);
    public sealed virtual IXamlType get_TargetType();
    public void SetIsAttachable();
    public sealed virtual bool get_IsAttachable();
    public void SetIsDependencyProperty();
    public sealed virtual bool get_IsDependencyProperty();
    public void SetIsReadOnly();
    public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public Getter get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(Getter value);
    public sealed virtual object GetValue(object instance);
    [CompilerGeneratedAttribute]
public Setter get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(Setter value);
    public sealed virtual void SetValue(object instance, object value);
}
public class Caliburn.Micro.XamlMetadataProvider : object {
    private XamlTypeInfoProvider provider;
    public sealed virtual IXamlType GetXamlType(Type type);
    public sealed virtual IXamlType GetXamlType(string typeName);
    public sealed virtual XmlnsDefinition[] GetXmlnsDefinitions();
}
public class Caliburn.Micro.XamlPlatformProvider : object {
    private CoreDispatcher dispatcher;
    private static DependencyProperty PreviouslyAttachedProperty;
    public bool PropertyChangeNotificationsOnUIThread { get; }
    public bool InDesignMode { get; }
    private static XamlPlatformProvider();
    public virtual bool get_PropertyChangeNotificationsOnUIThread();
    public virtual bool get_InDesignMode();
    private void ValidateDispatcher();
    private bool CheckAccess();
    public virtual void BeginOnUIThread(Action action);
    public virtual Task OnUIThreadAsync(Func`1<Task> action);
    public virtual void OnUIThread(Action action);
    public virtual object GetFirstNonGeneratedView(object view);
    public virtual void ExecuteOnFirstLoad(object view, Action`1<object> handler);
    public virtual void ExecuteOnLayoutUpdated(object view, Action`1<object> handler);
    public virtual Func`2<CancellationToken, Task> GetViewCloseAction(object viewModel, ICollection`1<object> views, Nullable`1<bool> dialogResult);
}
internal class Caliburn.Micro.XamlSystemBaseType : object {
    private string _fullName;
    private Type _underlyingType;
    public string FullName { get; }
    public Type UnderlyingType { get; }
    public IXamlType BaseType { get; }
    public IXamlMember ContentProperty { get; }
    public bool IsArray { get; }
    public bool IsCollection { get; }
    public bool IsConstructible { get; }
    public bool IsDictionary { get; }
    public bool IsMarkupExtension { get; }
    public bool IsBindable { get; }
    public IXamlType ItemType { get; }
    public IXamlType KeyType { get; }
    public XamlSystemBaseType(string fullName, Type underlyingType);
    public sealed virtual string get_FullName();
    public sealed virtual Type get_UnderlyingType();
    public virtual IXamlType get_BaseType();
    public virtual IXamlMember get_ContentProperty();
    public virtual IXamlMember GetMember(string name);
    public virtual bool get_IsArray();
    public virtual bool get_IsCollection();
    public virtual bool get_IsConstructible();
    public virtual bool get_IsDictionary();
    public virtual bool get_IsMarkupExtension();
    public virtual bool get_IsBindable();
    public virtual IXamlType get_ItemType();
    public virtual IXamlType get_KeyType();
    public virtual object ActivateInstance();
    public virtual void AddToMap(object instance, object key, object item);
    public virtual void AddToVector(object instance, object item);
    public virtual void RunInitializer();
    public virtual object CreateFromString(string input);
}
internal class Caliburn.Micro.XamlTypeInfoProvider : object {
    private Dictionary`2<string, IXamlType> _xamlTypes;
    private Dictionary`2<string, IXamlMember> _xamlMembers;
    private Dictionary`2<Type, string> _xamlTypeToStandardName;
    public IXamlType GetXamlTypeByType(Type type);
    public IXamlType GetXamlTypeByName(string typeName);
    public IXamlMember GetMemberByLongName(string longMemberName);
    private void AddToMapOfTypeToStandardName(Type t, string str);
    private IXamlType CreateXamlType(string typeName);
    private object get_1_View_Model(object instance);
    private void set_1_View_Model(object instance, object value);
    private IXamlMember CreateXamlMember(string longMemberName);
}
internal class Caliburn.Micro.XamlUserType : XamlSystemBaseType {
    private XamlTypeInfoProvider _provider;
    private IXamlType _baseType;
    private bool _isArray;
    private bool _isMarkupExtension;
    private bool _isBindable;
    private string _contentPropertyName;
    private string _itemTypeName;
    private string _keyTypeName;
    private Dictionary`2<string, string> _memberNames;
    private Dictionary`2<string, object> _enumValues;
    [CompilerGeneratedAttribute]
private Activator <Activator>k__BackingField;
    [CompilerGeneratedAttribute]
private AddToCollection <CollectionAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private AddToDictionary <DictionaryAdd>k__BackingField;
    public IXamlType BaseType { get; }
    public bool IsArray { get; }
    public bool IsCollection { get; }
    public bool IsConstructible { get; }
    public bool IsDictionary { get; }
    public bool IsMarkupExtension { get; }
    public bool IsBindable { get; }
    public IXamlMember ContentProperty { get; }
    public IXamlType ItemType { get; }
    public IXamlType KeyType { get; }
    public Activator Activator { get; public set; }
    public AddToCollection CollectionAdd { get; public set; }
    public AddToDictionary DictionaryAdd { get; public set; }
    public XamlUserType(XamlTypeInfoProvider provider, string fullName, Type fullType, IXamlType baseType);
    public virtual IXamlType get_BaseType();
    public virtual bool get_IsArray();
    public virtual bool get_IsCollection();
    public virtual bool get_IsConstructible();
    public virtual bool get_IsDictionary();
    public virtual bool get_IsMarkupExtension();
    public virtual bool get_IsBindable();
    public virtual IXamlMember get_ContentProperty();
    public virtual IXamlType get_ItemType();
    public virtual IXamlType get_KeyType();
    public virtual IXamlMember GetMember(string name);
    public virtual object ActivateInstance();
    public virtual void AddToMap(object instance, object key, object item);
    public virtual void AddToVector(object instance, object item);
    public virtual void RunInitializer();
    public virtual object CreateFromString(string input);
    [CompilerGeneratedAttribute]
public Activator get_Activator();
    [CompilerGeneratedAttribute]
public void set_Activator(Activator value);
    [CompilerGeneratedAttribute]
public AddToCollection get_CollectionAdd();
    [CompilerGeneratedAttribute]
public void set_CollectionAdd(AddToCollection value);
    [CompilerGeneratedAttribute]
public AddToDictionary get_DictionaryAdd();
    [CompilerGeneratedAttribute]
public void set_DictionaryAdd(AddToDictionary value);
    public void SetContentPropertyName(string contentPropertyName);
    public void SetIsArray();
    public void SetIsMarkupExtension();
    public void SetIsBindable();
    public void SetItemTypeName(string itemTypeName);
    public void SetKeyTypeName(string keyTypeName);
    public void AddMemberName(string shortName);
    public void AddEnumValue(string name, object value);
}
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
