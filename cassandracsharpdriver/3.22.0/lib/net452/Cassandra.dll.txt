public class Cassandra.AesColumnEncryptionPolicy : BaseColumnEncryptionPolicy`1<AesKeyAndIV> {
    public static int IVLength;
    private static Byte[] EmptyArray;
    private static AesColumnEncryptionPolicy();
    public virtual Byte[] EncryptWithKey(AesKeyAndIV key, Byte[] objBytes);
    public virtual Byte[] DecryptWithKey(AesKeyAndIV key, Byte[] encryptedBytes);
    public virtual void AddColumn(string ks, string table, string col, AesKeyAndIV key, ColumnTypeCode typeCode, IColumnInfo columnTypeInfo);
    public virtual void AddColumn(string ks, string table, string col, AesKeyAndIV key, ColumnTypeCode typeCode);
}
public class Cassandra.AggregateMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyspaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnDesc[] <ArgumentTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StateFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnDesc <StateType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FinalFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InitialCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnDesc <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deterministic>k__BackingField;
    public string Name { get; internal set; }
    public string KeyspaceName { get; internal set; }
    public String[] Signature { get; internal set; }
    public ColumnDesc[] ArgumentTypes { get; internal set; }
    public string StateFunction { get; internal set; }
    public ColumnDesc StateType { get; internal set; }
    public string FinalFunction { get; internal set; }
    public string InitialCondition { get; internal set; }
    public ColumnDesc ReturnType { get; internal set; }
    public bool Deterministic { get; internal set; }
    public AggregateMetadata(string name, string keyspaceName, String[] signature, ColumnDesc[] argumentTypes, string stateFunction, ColumnDesc stateType, string finalFunction, string initialCondition, ColumnDesc returnType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_KeyspaceName();
    [CompilerGeneratedAttribute]
internal void set_KeyspaceName(string value);
    [CompilerGeneratedAttribute]
public String[] get_Signature();
    [CompilerGeneratedAttribute]
internal void set_Signature(String[] value);
    [CompilerGeneratedAttribute]
public ColumnDesc[] get_ArgumentTypes();
    [CompilerGeneratedAttribute]
internal void set_ArgumentTypes(ColumnDesc[] value);
    [CompilerGeneratedAttribute]
public string get_StateFunction();
    [CompilerGeneratedAttribute]
internal void set_StateFunction(string value);
    [CompilerGeneratedAttribute]
public ColumnDesc get_StateType();
    [CompilerGeneratedAttribute]
internal void set_StateType(ColumnDesc value);
    [CompilerGeneratedAttribute]
public string get_FinalFunction();
    [CompilerGeneratedAttribute]
internal void set_FinalFunction(string value);
    [CompilerGeneratedAttribute]
public string get_InitialCondition();
    [CompilerGeneratedAttribute]
internal void set_InitialCondition(string value);
    [CompilerGeneratedAttribute]
public ColumnDesc get_ReturnType();
    [CompilerGeneratedAttribute]
internal void set_ReturnType(ColumnDesc value);
    [CompilerGeneratedAttribute]
public bool get_Deterministic();
    [CompilerGeneratedAttribute]
internal void set_Deterministic(bool value);
}
public class Cassandra.AlreadyExistsException : QueryValidationException {
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Table>k__BackingField;
    public string Keyspace { get; private set; }
    public string Table { get; private set; }
    public bool WasTableCreation { get; }
    public AlreadyExistsException(string keyspace, string table);
    [CompilerGeneratedAttribute]
public string get_Keyspace();
    [CompilerGeneratedAttribute]
private void set_Keyspace(string value);
    [CompilerGeneratedAttribute]
public string get_Table();
    [CompilerGeneratedAttribute]
private void set_Table(string value);
    public bool get_WasTableCreation();
    private static string MakeMsg(string keyspace, string table);
}
internal class Cassandra.AlreadyExistsInfo : object {
    public string Ks;
    public string Table;
}
public class Cassandra.AtomicMonotonicTimestampGenerator : object {
    public static int DefaultWarningThreshold;
    public static int DefaultMinLogInterval;
    protected static long TicksPerMicrosecond;
    protected static long UnixEpochTicks;
    internal static Logger Logger;
    private int _warningThresholdMicros;
    private long _minLogInterval;
    private Logger _logger;
    private long _lastWarning;
    private long _lastValue;
    public AtomicMonotonicTimestampGenerator(int warningThreshold, int minLogInterval);
    internal AtomicMonotonicTimestampGenerator(int warningThreshold, int minLogInterval, Logger logger);
    private static AtomicMonotonicTimestampGenerator();
    protected virtual long GetTimestamp();
    public sealed virtual long Next();
    private long GenerateNext(long lastValue);
    private void OnDrift(long timestamp, long lastTimestamp);
}
public class Cassandra.AtomicMonotonicWinApiTimestampGenerator : AtomicMonotonicTimestampGenerator {
    public AtomicMonotonicWinApiTimestampGenerator(int warningThreshold, int minLogInterval);
    internal AtomicMonotonicWinApiTimestampGenerator(int warningThreshold, int minLogInterval, Logger logger);
    private static void GetSystemTimePreciseAsFileTime(Int64& filetime);
    protected sealed virtual long GetTimestamp();
}
public class Cassandra.AuthenticationException : DriverException {
    [CompilerGeneratedAttribute]
private IPEndPoint <Host>k__BackingField;
    public IPEndPoint Host { get; private set; }
    public AuthenticationException(string message);
    public AuthenticationException(string message, IPEndPoint host);
    [CompilerGeneratedAttribute]
public IPEndPoint get_Host();
    [CompilerGeneratedAttribute]
private void set_Host(IPEndPoint value);
}
public abstract class Cassandra.BaseColumnEncryptionPolicy`1 : object {
    private ConcurrentDictionary`2<ColMetadataKey<TKey>, ColumnEncryptionMetadata> _colData;
    public sealed virtual Byte[] Encrypt(object key, Byte[] objBytes);
    public sealed virtual Byte[] Decrypt(object key, Byte[] encryptedBytes);
    public abstract virtual Byte[] EncryptWithKey(TKey key, Byte[] objBytes);
    public abstract virtual Byte[] DecryptWithKey(TKey key, Byte[] encryptedBytes);
    public virtual void AddColumn(string ks, string table, string col, TKey key, ColumnTypeCode typeCode, IColumnInfo columnTypeInfo);
    public virtual void AddColumn(string ks, string table, string col, TKey key, ColumnTypeCode typeCode);
    public virtual Nullable`1<ColumnEncryptionMetadata> GetColumnEncryptionMetadata(string ks, string table, string col);
}
public class Cassandra.BatchStatement : Statement {
    private static Logger Logger;
    private List`1<Statement> _queries;
    private BatchType _batchType;
    private RoutingKey _routingKey;
    private Object[] _routingValues;
    private string _keyspace;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    public BatchType BatchType { get; }
    public bool IsEmpty { get; }
    internal List`1<Statement> Queries { get; }
    public RoutingKey RoutingKey { get; }
    public string Keyspace { get; }
    internal ISerializer Serializer { get; internal set; }
    public IEnumerable`1<IStatement> Statements { get; }
    private static BatchStatement();
    public BatchType get_BatchType();
    public bool get_IsEmpty();
    internal List`1<Statement> get_Queries();
    public virtual RoutingKey get_RoutingKey();
    public virtual string get_Keyspace();
    private IStatement GetRoutingStatement(ISerializer serializer);
    [CompilerGeneratedAttribute]
internal ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
internal void set_Serializer(ISerializer value);
    public BatchStatement SetRoutingKey(RoutingKey[] routingKeyComponents);
    public BatchStatement SetRoutingValues(Object[] keys);
    public BatchStatement Add(Statement statement);
    public BatchStatement SetBatchType(BatchType batchType);
    internal virtual IQueryRequest CreateBatchRequest(ISerializer serializer);
    public BatchStatement SetKeyspace(string name);
    public IEnumerable`1<IStatement> get_Statements();
}
public enum Cassandra.BatchType : Enum {
    public int value__;
    public static BatchType Logged;
    public static BatchType Unlogged;
    public static BatchType Counter;
}
internal static class Cassandra.BeConverter : object {
    public static Byte[] GetBytes(short value);
    public static Byte[] GetBytes(ushort value);
    public static Byte[] GetBytes(int value);
    public static Byte[] GetBytes(long value);
    public static Byte[] GetBytes(double value);
    public static Byte[] GetBytes(float value);
    public static short ToInt16(Byte[] value, int offset);
    public static ushort ToUInt16(Byte[] value);
    public static int ToInt32(Byte[] value, int offset);
    public static long ToInt64(Byte[] value, int offset);
    public static double ToDouble(Byte[] value, int offset);
    public static float ToSingle(Byte[] value, int offset);
}
public class Cassandra.BigIntegerTypeAdapter : object {
    public sealed virtual Type GetDataType();
    public sealed virtual object ConvertFrom(Byte[] decimalBuf);
    public sealed virtual Byte[] ConvertTo(object value);
}
internal class Cassandra.BoolSwitch : object {
    private int _val;
    public bool TryTake();
    public bool IsTaken();
}
public class Cassandra.BoundStatement : Statement {
    private static Logger Logger;
    private PreparedStatement _preparedStatement;
    private RoutingKey _routingKey;
    private string _keyspace;
    public PreparedStatement PreparedStatement { get; }
    public RoutingKey RoutingKey { get; }
    public string Keyspace { get; }
    public BoundStatement(PreparedStatement statement);
    private static BoundStatement();
    public PreparedStatement get_PreparedStatement();
    public virtual RoutingKey get_RoutingKey();
    public virtual string get_Keyspace();
    public BoundStatement SetRoutingKey(RoutingKey[] routingKeyComponents);
    internal virtual void SetValues(Object[] values, ISerializer serializer);
    private Object[] ValidateValues(Object[] values, ISerializer serializer);
    internal virtual IQueryRequest CreateBatchRequest(ISerializer serializer);
    internal void CalculateRoutingKey(ISerializer serializer, bool useNamedParameters, Int32[] routingIndexes, String[] routingNames, Object[] valuesByPosition, Object[] rawValues);
    public virtual string ToString();
}
public class Cassandra.Builder : object {
    public static string DefaultApplicationName;
    private static Logger Logger;
    private List`1<object> _contactPoints;
    private static int DefaultQueryAbortTimeout;
    private PoolingOptions _poolingOptions;
    private SocketOptions _socketOptions;
    private IAuthInfoProvider _authInfoProvider;
    private IAuthProvider _authProvider;
    private CompressionType _compression;
    private IFrameCompressor _customCompressor;
    private string _defaultKeyspace;
    private ILoadBalancingPolicy _loadBalancingPolicy;
    private ITimestampGenerator _timestampGenerator;
    private IColumnEncryptionPolicy _columnEncryptionPolicy;
    private int _port;
    private int _queryAbortTimeout;
    private QueryOptions _queryOptions;
    private IReconnectionPolicy _reconnectionPolicy;
    private IRetryPolicy _retryPolicy;
    private SSLOptions _sslOptions;
    private bool _withoutRowSetBuffering;
    private IAddressTranslator _addressTranslator;
    private ISpeculativeExecutionPolicy _speculativeExecutionPolicy;
    private ProtocolVersion _maxProtocolVersion;
    private TypeSerializerDefinitions _typeSerializerDefinitions;
    private bool _noCompact;
    private int _maxSchemaAgreementWaitSeconds;
    private IReadOnlyDictionary`2<string, IExecutionProfile> _profiles;
    private MetadataSyncOptions _metadataSyncOptions;
    private IEndPointResolver _endPointResolver;
    private IDriverMetricsProvider _driverMetricsProvider;
    private IRequestTracker _requestTracker;
    private DriverMetricsOptions _metricsOptions;
    private MonitorReportingOptions _monitorReportingOptions;
    private string _sessionName;
    private string _bundlePath;
    private bool _addedSsl;
    private bool _addedContactPoints;
    private bool _addedAuth;
    private bool _addedLbp;
    private Nullable`1<bool> _keepContactPointsUnresolved;
    private Nullable`1<bool> _allowBetaProtocolVersions;
    [CompilerGeneratedAttribute]
private string <ApplicationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ClusterId>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphOptions <GraphOptions>k__BackingField;
    public string ApplicationVersion { get; private set; }
    public string ApplicationName { get; private set; }
    public Nullable`1<Guid> ClusterId { get; private set; }
    public GraphOptions GraphOptions { get; private set; }
    public PoolingOptions PoolingOptions { get; }
    public SocketOptions SocketOptions { get; }
    public ICollection`1<IPEndPoint> ContactPoints { get; }
    internal Builder(ILoadBalancingPolicy lbp, IRetryPolicy retryPolicy);
    private static Builder();
    [CompilerGeneratedAttribute]
public string get_ApplicationVersion();
    [CompilerGeneratedAttribute]
private void set_ApplicationVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
private void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ClusterId();
    [CompilerGeneratedAttribute]
private void set_ClusterId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public GraphOptions get_GraphOptions();
    [CompilerGeneratedAttribute]
private void set_GraphOptions(GraphOptions value);
    public PoolingOptions get_PoolingOptions();
    public SocketOptions get_SocketOptions();
    public sealed virtual ICollection`1<IPEndPoint> get_ContactPoints();
    public sealed virtual Configuration GetConfiguration();
    private void SetLegacySettingsFromDefaultProfile();
    private GraphOptions GetGraphOptions();
    private Policies GetPolicies();
    public Builder WithClusterId(Guid id);
    public Builder WithApplicationName(string name);
    public Builder WithApplicationVersion(string version);
    public Builder WithGraphOptions(GraphOptions options);
    public Builder WithPort(int port);
    public Builder WithQueryOptions(QueryOptions options);
    public Builder WithCompression(CompressionType compression);
    public Builder WithCustomCompressor(IFrameCompressor compressor);
    public Builder AddContactPoint(string address);
    public Builder AddContactPoint(IPAddress address);
    public Builder AddContactPoint(IPEndPoint address);
    public Builder AddContactPoints(String[] addresses);
    public Builder AddContactPoints(IEnumerable`1<string> addresses);
    public Builder AddContactPoints(IPAddress[] addresses);
    public Builder AddContactPoints(IEnumerable`1<IPAddress> addresses);
    public Builder AddContactPoints(IPEndPoint[] addresses);
    public Builder AddContactPoints(IEnumerable`1<IPEndPoint> addresses);
    private Builder AddMultipleContactPointsInternal(IEnumerable`1<object> contactPoints);
    private Builder AddSingleContactPointInternal(object contactPoint);
    public Builder WithUnresolvedContactPoints(bool keepContactPointsUnresolved);
    public Builder WithBetaProtocolVersions();
    public Builder WithLoadBalancingPolicy(ILoadBalancingPolicy policy);
    public Builder WithReconnectionPolicy(IReconnectionPolicy policy);
    public Builder WithRetryPolicy(IRetryPolicy policy);
    public Builder WithSpeculativeExecutionPolicy(ISpeculativeExecutionPolicy policy);
    public Builder WithColumnEncryptionPolicy(IColumnEncryptionPolicy policy);
    public Builder WithTimestampGenerator(ITimestampGenerator generator);
    public Builder WithConnectionString(string connectionString);
    public Builder WithCredentials(string username, string password);
    public Builder WithAuthProvider(IAuthProvider authProvider);
    public Builder WithoutRowSetBuffering();
    public Builder WithQueryTimeout(int queryAbortTimeout);
    public Builder WithDefaultKeyspace(string defaultKeyspace);
    public Builder WithSocketOptions(SocketOptions value);
    public Builder WithPoolingOptions(PoolingOptions value);
    public Builder WithSSL();
    public Builder WithSSL(SSLOptions sslOptions);
    public Builder WithAddressTranslator(IAddressTranslator addressTranslator);
    public Builder WithMaxProtocolVersion(byte version);
    public Builder WithMaxProtocolVersion(ProtocolVersion version);
    public Builder WithNoCompact();
    public Builder WithTypeSerializers(TypeSerializerDefinitions definitions);
    internal Builder WithEndPointResolver(IEndPointResolver endPointResolver);
    public Builder WithMaxSchemaAgreementWaitSeconds(int maxSchemaAgreementWaitSeconds);
    public Builder WithMetrics(IDriverMetricsProvider driverMetricsProvider);
    public Builder WithMetrics(IDriverMetricsProvider driverMetricsProvider, DriverMetricsOptions metricsOptions);
    public Builder WithRequestTracker(IRequestTracker requestTracker);
    public Builder WithExecutionProfiles(Action`1<IExecutionProfileOptions> profileOptionsBuilder);
    public Builder WithMetadataSyncOptions(MetadataSyncOptions metadataSyncOptions);
    public Builder WithSessionName(string sessionName);
    public Builder WithCloudSecureConnectionBundle(string bundlePath);
    public Builder WithMonitorReporting(bool enabled);
    internal Builder WithMonitorReporting(MonitorReportingOptions options);
    public Cluster Build();
    private Builder SetContactPoints(IEnumerable`1<object> contactPoints);
    private Builder ConfigureCloudCluster(string bundlePath);
    private Builder ConfigureCloudCluster(SecureConnectionBundle bundle);
}
public class Cassandra.BusyPoolException : DriverException {
    [CompilerGeneratedAttribute]
private IPEndPoint <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRequestsPerConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectionLength>k__BackingField;
    public IPEndPoint Address { get; }
    public int MaxRequestsPerConnection { get; }
    public int ConnectionLength { get; }
    public BusyPoolException(IPEndPoint address, int maxRequestsPerConnection, int connectionLength);
    [CompilerGeneratedAttribute]
public IPEndPoint get_Address();
    [CompilerGeneratedAttribute]
public int get_MaxRequestsPerConnection();
    [CompilerGeneratedAttribute]
public int get_ConnectionLength();
    private static string GetMessage(IPEndPoint address, int maxRequestsPerConnection, int connectionLength);
    private static string GetMessage(IConnectionEndPoint endPoint, int maxRequestsPerConnection, int connectionLength);
}
public class Cassandra.CassandraConnectionStringBuilder : DbConnectionStringBuilder {
    public string ClusterName { get; public set; }
    public string DefaultKeyspace { get; public set; }
    public int Port { get; public set; }
    public String[] ContactPoints { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public CassandraConnectionStringBuilder(string connectionString);
    public string get_ClusterName();
    public void set_ClusterName(string value);
    public string get_DefaultKeyspace();
    public void set_DefaultKeyspace(string value);
    public int get_Port();
    public void set_Port(int value);
    public String[] get_ContactPoints();
    public void set_ContactPoints(String[] value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    public Builder ApplyToBuilder(Builder builder);
    public Builder MakeClusterBuilder();
    private T DefaultIfNotExists(string name, T def);
    private T ThrowIfNotExists(string name);
}
internal class Cassandra.CassandraEventArgs : EventArgs {
}
internal class Cassandra.CassandraEventHandler : MulticastDelegate {
    public CassandraEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CassandraEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CassandraEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum Cassandra.CassandraEventType : Enum {
    public int value__;
    public static CassandraEventType TopologyChange;
    public static CassandraEventType StatusChange;
    public static CassandraEventType SchemaChange;
}
public class Cassandra.ClientOptions : object {
    public static int DefaultQueryAbortTimeout;
    private string _defaultKeyspace;
    private int _queryAbortTimeout;
    private bool _withoutRowSetBuffering;
    public bool WithoutRowSetBuffering { get; }
    public int QueryAbortTimeout { get; }
    public string DefaultKeyspace { get; }
    public ClientOptions(bool withoutRowSetBuffering, int queryAbortTimeout, string defaultKeyspace);
    public bool get_WithoutRowSetBuffering();
    public int get_QueryAbortTimeout();
    public string get_DefaultKeyspace();
}
public class Cassandra.Cluster : object {
    private static string DefaultVersionString;
    private static string DefaultProductString;
    private static ProtocolVersion _maxProtocolVersion;
    internal static Logger Logger;
    private CopyOnWriteList`1<IInternalSession> _connectedSessions;
    private IControlConnection _controlConnection;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initialized;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _initException;
    private SemaphoreSlim _initLock;
    private long _sessionCounter;
    private Metadata _metadata;
    private IProtocolEventDebouncer _protocolEventDebouncer;
    private IReadOnlyList`1<ILoadBalancingPolicy> _loadBalancingPolicies;
    [CompilerGeneratedAttribute]
private Action`1<Host> HostAdded;
    [CompilerGeneratedAttribute]
private Action`1<Host> HostRemoved;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<Byte[], PreparedStatement> <Cassandra.SessionManagement.IInternalCluster.PreparedQueries>k__BackingField;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    internal IInternalCluster InternalRef { get; }
    private ConcurrentDictionary`2<Byte[], PreparedStatement> Cassandra.SessionManagement.IInternalCluster.PreparedQueries { get; }
    public static int MaxProtocolVersion { get; public set; }
    public Configuration Configuration { get; private set; }
    public Metadata Metadata { get; }
    private Cluster(IEnumerable`1<object> contactPoints, Configuration configuration);
    private static Cluster();
    [CompilerGeneratedAttribute]
public sealed virtual void add_HostAdded(Action`1<Host> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_HostAdded(Action`1<Host> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_HostRemoved(Action`1<Host> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_HostRemoved(Action`1<Host> value);
    internal IInternalCluster get_InternalRef();
    private sealed virtual override IControlConnection Cassandra.SessionManagement.IInternalCluster.GetControlConnection();
    private sealed virtual override IEnumerable`1<IInternalSession> Cassandra.SessionManagement.IInternalCluster.GetConnectedSessions();
    [CompilerGeneratedAttribute]
private sealed virtual override ConcurrentDictionary`2<Byte[], PreparedStatement> Cassandra.SessionManagement.IInternalCluster.get_PreparedQueries();
    public static Cluster BuildFrom(IInitializer initializer);
    internal static Cluster BuildFrom(IInitializer initializer, IReadOnlyList`1<object> nonIpEndPointContactPoints);
    internal static Cluster BuildFrom(IInitializer initializer, IReadOnlyList`1<object> nonIpEndPointContactPoints, Configuration config);
    public static Builder Builder();
    public static int get_MaxProtocolVersion();
    public static void set_MaxProtocolVersion(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Configuration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(Configuration value);
    public sealed virtual Metadata get_Metadata();
    [AsyncStateMachineAttribute("Cassandra.Cluster/<Init>d__40")]
private Task Init();
    private void InitializeHostDistances();
    private static string GetAssemblyInfoString();
    private static string GetAssemblyProduct(Assembly assembly);
    private static string GetAssemblyVersion(Assembly assembly);
    private sealed virtual override IReadOnlyDictionary`2<IContactPoint, IEnumerable`1<IConnectionEndPoint>> Cassandra.SessionManagement.IInternalCluster.GetResolvedEndpoints();
    public sealed virtual ICollection`1<Host> AllHosts();
    public sealed virtual ISession Connect();
    public sealed virtual Task`1<ISession> ConnectAsync();
    public sealed virtual ISession Connect(string keyspace);
    [AsyncStateMachineAttribute("Cassandra.Cluster/<ConnectAsync>d__50")]
public sealed virtual Task`1<ISession> ConnectAsync(string keyspace);
    private string GetNewSessionName();
    private long GetAndIncrementSessionCounter();
    private void SetMetadataDependentOptions();
    public ISession ConnectAndCreateDefaultKeyspaceIfNotExists(Dictionary`2<string, string> replication, bool durableWrites);
    private sealed virtual override bool Cassandra.SessionManagement.IInternalCluster.AnyOpenConnections(Host host);
    public sealed virtual void Dispose();
    public sealed virtual Host GetHost(IPEndPoint address);
    public sealed virtual ICollection`1<Host> GetReplicas(Byte[] partitionKey);
    public sealed virtual ICollection`1<Host> GetReplicas(string keyspace, Byte[] partitionKey);
    private void OnHostRemoved(Host h);
    private void OnHostAdded(Host h);
    [AsyncStateMachineAttribute("Cassandra.Cluster/<OnHostUp>d__62")]
private void OnHostUp(Host h);
    public sealed virtual bool RefreshSchema(string keyspace, string table);
    public sealed virtual Task`1<bool> RefreshSchemaAsync(string keyspace, string table);
    public sealed virtual void Shutdown(int timeoutMs);
    [AsyncStateMachineAttribute("Cassandra.Cluster/<ShutdownAsync>d__66")]
public sealed virtual Task ShutdownAsync(int timeoutMs);
    private sealed virtual override HostDistance Cassandra.SessionManagement.IInternalCluster.RetrieveAndSetDistance(Host host);
    [AsyncStateMachineAttribute("Cassandra.Cluster/<Cassandra-SessionManagement-IInternalCluster-Prepare>d__68")]
private sealed virtual override Task`1<PreparedStatement> Cassandra.SessionManagement.IInternalCluster.Prepare(IInternalSession session, ISerializerManager serializerManager, InternalPrepareRequest request);
    private sealed virtual override void Cassandra.SessionManagement.IInternalCluster.RemoveSession(IInternalSession session);
    [AsyncStateMachineAttribute("Cassandra.Cluster/<ReprepareAllQueries>d__70")]
private Task ReprepareAllQueries(Host host);
    [CompilerGeneratedAttribute]
private void <Init>b__40_0(Task t);
}
[DefaultMemberAttribute("Item")]
internal class Cassandra.Collections.ArrayBackedList`1 : object {
    private T[] _items;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ArrayBackedList`1(T[] items);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
internal class Cassandra.Collections.ByteArrayComparer : object {
    public sealed virtual bool Equals(Byte[] a, Byte[] b);
    public sealed virtual int GetHashCode(Byte[] key);
}
[DefaultMemberAttribute("Item")]
internal class Cassandra.Collections.CopyOnWriteDictionary`2 : object {
    private static Dictionary`2<TKey, TValue> Empty;
    private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _map;
    private object _writeLock;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public CopyOnWriteDictionary`2(IDictionary`2<TKey, TValue> toCopy);
    private static CopyOnWriteDictionary`2();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual TValue GetOrAdd(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryRemove(TKey key, TValue& value);
    public sealed virtual TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public sealed virtual TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public sealed virtual TValue CompareAndUpdate(TKey key, Func`3<TKey, TValue, bool> compareFunc, Func`3<TKey, TValue, TValue> updateValueFactory);
    private void CloneMapAndAddUnsafe(TKey key, TValue value);
    private void CloneMapAndUpdateUnsafe(TKey key, TValue value);
    private bool CloneMapAndRemoveUnsafe(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
}
internal class Cassandra.Collections.CopyOnWriteList`1 : object {
    private static T[] Empty;
    private T[] modreq(System.Runtime.CompilerServices.IsVolatile) _array;
    private object _writeLock;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private static CopyOnWriteList`1();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public int AddNew(T item);
    public void AddRange(T[] items);
    public sealed virtual void Clear();
    public T[] ClearAndGet();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public Tuple`2<bool, int> RemoveAndCount(T item);
    public T[] GetSnapshot();
}
internal interface Cassandra.Collections.IThreadSafeDictionary`2 {
    public abstract virtual TValue GetOrAdd(TKey key, TValue value);
    public abstract virtual bool TryRemove(TKey key, TValue& value);
    public abstract virtual TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public abstract virtual TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public abstract virtual TValue CompareAndUpdate(TKey key, Func`3<TKey, TValue, bool> compareFunc, Func`3<TKey, TValue, TValue> updateValueFactory);
}
internal class Cassandra.Collections.OrderedHashSet`1 : object {
    private HashSet`1<T> _set;
    private LinkedList`1<T> _list;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
}
internal class Cassandra.Collections.ReadOnlyCollection`1 : object {
    private ICollection`1<T> _items;
    public int Count { get; }
    internal ReadOnlyCollection`1(ICollection`1<T> items);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public class Cassandra.ColumnDesc : object {
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Table>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnTypeCode <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IColumnInfo <TypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReversed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFrozen>k__BackingField;
    public string Keyspace { get; public set; }
    public string Name { get; public set; }
    public string Table { get; public set; }
    public ColumnTypeCode TypeCode { get; public set; }
    public IColumnInfo TypeInfo { get; public set; }
    public bool IsStatic { get; public set; }
    internal bool IsReversed { get; internal set; }
    internal bool IsFrozen { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Keyspace();
    [CompilerGeneratedAttribute]
public void set_Keyspace(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Table();
    [CompilerGeneratedAttribute]
public void set_Table(string value);
    [CompilerGeneratedAttribute]
public ColumnTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
public void set_TypeCode(ColumnTypeCode value);
    [CompilerGeneratedAttribute]
public IColumnInfo get_TypeInfo();
    [CompilerGeneratedAttribute]
public void set_TypeInfo(IColumnInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
public void set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsReversed();
    [CompilerGeneratedAttribute]
internal void set_IsReversed(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsFrozen();
    [CompilerGeneratedAttribute]
internal void set_IsFrozen(bool value);
}
public class Cassandra.ColumnEncryptionInvalidTypeError : DriverException {
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnTypeCode <ColumnSchemaTypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DeserializedValue>k__BackingField;
    public string ColumnName { get; }
    public ColumnTypeCode ColumnSchemaTypeCode { get; }
    public object DeserializedValue { get; }
    public ColumnEncryptionInvalidTypeError(string column, ColumnTypeCode typeCode, object deserializedValue);
    [CompilerGeneratedAttribute]
public string get_ColumnName();
    [CompilerGeneratedAttribute]
public ColumnTypeCode get_ColumnSchemaTypeCode();
    [CompilerGeneratedAttribute]
public object get_DeserializedValue();
}
public class Cassandra.ColumnEncryptionMetadata : ValueType {
    [CompilerGeneratedAttribute]
private ColumnTypeCode <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IColumnInfo <TypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public ColumnTypeCode TypeCode { get; }
    public IColumnInfo TypeInfo { get; }
    public object Key { get; }
    public ColumnEncryptionMetadata(ColumnTypeCode typeCode, object key);
    public ColumnEncryptionMetadata(ColumnTypeCode typeCode, IColumnInfo typeInfo, object key);
    [CompilerGeneratedAttribute]
public ColumnTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
public IColumnInfo get_TypeInfo();
    [CompilerGeneratedAttribute]
public object get_Key();
    public sealed virtual bool Equals(ColumnEncryptionMetadata other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ColumnEncryptionMetadata left, ColumnEncryptionMetadata right);
    public static bool op_Inequality(ColumnEncryptionMetadata left, ColumnEncryptionMetadata right);
}
public enum Cassandra.ColumnTypeCode : Enum {
    public int value__;
    public static ColumnTypeCode Custom;
    public static ColumnTypeCode Ascii;
    public static ColumnTypeCode Bigint;
    public static ColumnTypeCode Blob;
    public static ColumnTypeCode Boolean;
    public static ColumnTypeCode Counter;
    public static ColumnTypeCode Decimal;
    public static ColumnTypeCode Double;
    public static ColumnTypeCode Float;
    public static ColumnTypeCode Int;
    public static ColumnTypeCode Text;
    public static ColumnTypeCode Timestamp;
    public static ColumnTypeCode Uuid;
    public static ColumnTypeCode Varchar;
    public static ColumnTypeCode Varint;
    public static ColumnTypeCode Timeuuid;
    public static ColumnTypeCode Inet;
    public static ColumnTypeCode Date;
    public static ColumnTypeCode Time;
    public static ColumnTypeCode SmallInt;
    public static ColumnTypeCode TinyInt;
    public static ColumnTypeCode Duration;
    public static ColumnTypeCode List;
    public static ColumnTypeCode Map;
    public static ColumnTypeCode Set;
    public static ColumnTypeCode Udt;
    public static ColumnTypeCode Tuple;
}
internal class Cassandra.Compression.LZ4Compressor : object {
    public sealed virtual Stream Decompress(Stream stream);
}
internal class Cassandra.Compression.SnappyCompressor : object {
    public sealed virtual Stream Decompress(Stream stream);
}
internal class Cassandra.Compression.WrappedStream : Stream {
    private Stream _stream;
    private long _length;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal WrappedStream(Stream stream, long length);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public enum Cassandra.CompressionType : Enum {
    public int value__;
    public static CompressionType NoCompression;
    public static CompressionType Snappy;
    public static CompressionType LZ4;
}
public class Cassandra.Configuration : object {
    internal static string DefaultExecutionProfileName;
    internal static string DefaultSessionName;
    [CompilerGeneratedAttribute]
private Policies <Policies>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketOptions <SocketOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ProtocolOptions <ProtocolOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private PoolingOptions <PoolingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientOptions <ClientOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryOptions <QueryOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IAuthProvider <AuthProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IAuthInfoProvider <AuthInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IAddressTranslator <AddressTranslator>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IExecutionProfile> <ExecutionProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepContactPointsUnresolved>k__BackingField;
    [CompilerGeneratedAttribute]
private HashedWheelTimer <Timer>k__BackingField;
    [CompilerGeneratedAttribute]
private RecyclableMemoryStreamManager <BufferPool>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITypeSerializer> <TypeSerializers>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataSyncOptions <MetadataSyncOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IStartupOptionsFactory <StartupOptionsFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ISessionFactory <SessionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestOptionsMapper <RequestOptionsMapper>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestHandlerFactory <RequestHandlerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IHostConnectionPoolFactory <HostConnectionPoolFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestExecutionFactory <RequestExecutionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IConnectionFactory <ConnectionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IControlConnectionFactory <ControlConnectionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrepareHandlerFactory <PrepareHandlerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ITimerFactory <TimerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IEndPointResolver <EndPointResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IDnsResolver <DnsResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataRequestHandler <MetadataRequestHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITopologyRefresherFactory <TopologyRefresherFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ISchemaParserFactory <SchemaParserFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ISupportedOptionsInitializerFactory <SupportedOptionsInitializerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IProtocolVersionNegotiator <ProtocolVersionNegotiator>k__BackingField;
    [CompilerGeneratedAttribute]
private IServerEventsSubscriber <ServerEventsSubscriber>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverMetricsProvider <MetricsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private DriverMetricsOptions <MetricsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MetricsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IObserverFactoryBuilder <ObserverFactoryBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplicationNameWasGenerated>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ClusterId>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphOptions <GraphOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowBetaProtocolVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IRequestOptions> <RequestOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private MonitorReportingOptions <MonitorReportingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsSupportVerifier <InsightsSupportVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsClientFactory <InsightsClientFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IContactPointParser <ContactPointParser>k__BackingField;
    [CompilerGeneratedAttribute]
private IServerNameResolver <ServerNameResolver>k__BackingField;
    public Policies Policies { get; }
    public SocketOptions SocketOptions { get; private set; }
    public ProtocolOptions ProtocolOptions { get; private set; }
    public PoolingOptions PoolingOptions { get; }
    public ClientOptions ClientOptions { get; private set; }
    public QueryOptions QueryOptions { get; private set; }
    internal IAuthProvider AuthProvider { get; private set; }
    internal IAuthInfoProvider AuthInfoProvider { get; private set; }
    public IAddressTranslator AddressTranslator { get; private set; }
    public IReadOnlyDictionary`2<string, IExecutionProfile> ExecutionProfiles { get; }
    public bool KeepContactPointsUnresolved { get; }
    internal HashedWheelTimer Timer { get; private set; }
    internal RecyclableMemoryStreamManager BufferPool { get; private set; }
    internal IEnumerable`1<ITypeSerializer> TypeSerializers { get; internal set; }
    internal MetadataSyncOptions MetadataSyncOptions { get; }
    internal IStartupOptionsFactory StartupOptionsFactory { get; }
    internal ISessionFactory SessionFactory { get; }
    internal IRequestOptionsMapper RequestOptionsMapper { get; }
    internal IRequestHandlerFactory RequestHandlerFactory { get; }
    internal IHostConnectionPoolFactory HostConnectionPoolFactory { get; }
    internal IRequestExecutionFactory RequestExecutionFactory { get; }
    internal IConnectionFactory ConnectionFactory { get; }
    internal IControlConnectionFactory ControlConnectionFactory { get; }
    internal IPrepareHandlerFactory PrepareHandlerFactory { get; }
    internal ITimerFactory TimerFactory { get; }
    internal IEndPointResolver EndPointResolver { get; }
    internal IDnsResolver DnsResolver { get; }
    internal IMetadataRequestHandler MetadataRequestHandler { get; }
    internal ITopologyRefresherFactory TopologyRefresherFactory { get; }
    internal ISchemaParserFactory SchemaParserFactory { get; }
    internal ISupportedOptionsInitializerFactory SupportedOptionsInitializerFactory { get; }
    internal IProtocolVersionNegotiator ProtocolVersionNegotiator { get; }
    internal IServerEventsSubscriber ServerEventsSubscriber { get; }
    internal IDriverMetricsProvider MetricsProvider { get; }
    internal DriverMetricsOptions MetricsOptions { get; }
    internal string SessionName { get; }
    internal bool MetricsEnabled { get; }
    internal IObserverFactoryBuilder ObserverFactoryBuilder { get; }
    internal static string DefaultApplicationVersion { get; }
    internal static string FallbackApplicationName { get; }
    public string ApplicationVersion { get; }
    public string ApplicationName { get; }
    public bool ApplicationNameWasGenerated { get; }
    public Guid ClusterId { get; }
    public GraphOptions GraphOptions { get; protected set; }
    public bool AllowBetaProtocolVersions { get; }
    internal IReadOnlyDictionary`2<string, IRequestOptions> RequestOptions { get; }
    public MonitorReportingOptions MonitorReportingOptions { get; }
    internal IInsightsSupportVerifier InsightsSupportVerifier { get; }
    internal IInsightsClientFactory InsightsClientFactory { get; }
    internal IRequestOptions DefaultRequestOptions { get; }
    internal static IInsightsSupportVerifier DefaultInsightsSupportVerifier { get; }
    internal static IInsightsClientFactory DefaultInsightsClientFactory { get; }
    internal static IInsightsMessageFactory`1<InsightsStartupData> DefaultInsightsStartupMessageFactory { get; }
    internal static IInsightsMessageFactory`1<InsightsStatusData> DefaultInsightsStatusMessageFactory { get; }
    internal static IInsightsMetadataFactory DefaultInsightsMetadataFactory { get; }
    internal static InsightsInfoProvidersCollection DefaultInsightsInfoProvidersCollection { get; }
    internal IContactPointParser ContactPointParser { get; }
    internal IServerNameResolver ServerNameResolver { get; }
    internal Configuration(Policies policies, ProtocolOptions protocolOptions, PoolingOptions poolingOptions, SocketOptions socketOptions, ClientOptions clientOptions, IAuthProvider authProvider, IAuthInfoProvider authInfoProvider, QueryOptions queryOptions, IAddressTranslator addressTranslator, IReadOnlyDictionary`2<string, IExecutionProfile> executionProfiles, MetadataSyncOptions metadataSyncOptions, IEndPointResolver endPointResolver, IDriverMetricsProvider driverMetricsProvider, DriverMetricsOptions metricsOptions, string sessionName, GraphOptions graphOptions, Nullable`1<Guid> clusterId, string appVersion, string appName, MonitorReportingOptions monitorReportingOptions, TypeSerializerDefinitions typeSerializerDefinitions, Nullable`1<bool> keepContactPointsUnresolved, Nullable`1<bool> allowBetaProtocolVersions, ISessionFactory sessionFactory, IRequestOptionsMapper requestOptionsMapper, IStartupOptionsFactory startupOptionsFactory, IInsightsSupportVerifier insightsSupportVerifier, IRequestHandlerFactory requestHandlerFactory, IHostConnectionPoolFactory hostConnectionPoolFactory, IRequestExecutionFactory requestExecutionFactory, IConnectionFactory connectionFactory, IControlConnectionFactory controlConnectionFactory, IPrepareHandlerFactory prepareHandlerFactory, ITimerFactory timerFactory, IInsightsClientFactory insightsClientFactory, IContactPointParser contactPointParser, IServerNameResolver serverNameResolver, IDnsResolver dnsResolver, IMetadataRequestHandler metadataRequestHandler, ITopologyRefresherFactory topologyRefresherFactory, ISchemaParserFactory schemaParserFactory, ISupportedOptionsInitializerFactory supportedOptionsInitializerFactory, IProtocolVersionNegotiator protocolVersionNegotiator, IServerEventsSubscriber serverEventsSubscriber, IRequestTracker requestTracker);
    [CompilerGeneratedAttribute]
public Policies get_Policies();
    [CompilerGeneratedAttribute]
public SocketOptions get_SocketOptions();
    [CompilerGeneratedAttribute]
private void set_SocketOptions(SocketOptions value);
    [CompilerGeneratedAttribute]
public ProtocolOptions get_ProtocolOptions();
    [CompilerGeneratedAttribute]
private void set_ProtocolOptions(ProtocolOptions value);
    [CompilerGeneratedAttribute]
public PoolingOptions get_PoolingOptions();
    [CompilerGeneratedAttribute]
public ClientOptions get_ClientOptions();
    [CompilerGeneratedAttribute]
private void set_ClientOptions(ClientOptions value);
    [CompilerGeneratedAttribute]
public QueryOptions get_QueryOptions();
    [CompilerGeneratedAttribute]
private void set_QueryOptions(QueryOptions value);
    [CompilerGeneratedAttribute]
internal IAuthProvider get_AuthProvider();
    [CompilerGeneratedAttribute]
private void set_AuthProvider(IAuthProvider value);
    [CompilerGeneratedAttribute]
internal IAuthInfoProvider get_AuthInfoProvider();
    [CompilerGeneratedAttribute]
private void set_AuthInfoProvider(IAuthInfoProvider value);
    [CompilerGeneratedAttribute]
public IAddressTranslator get_AddressTranslator();
    [CompilerGeneratedAttribute]
private void set_AddressTranslator(IAddressTranslator value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IExecutionProfile> get_ExecutionProfiles();
    [CompilerGeneratedAttribute]
public bool get_KeepContactPointsUnresolved();
    [CompilerGeneratedAttribute]
internal HashedWheelTimer get_Timer();
    [CompilerGeneratedAttribute]
private void set_Timer(HashedWheelTimer value);
    [CompilerGeneratedAttribute]
internal RecyclableMemoryStreamManager get_BufferPool();
    [CompilerGeneratedAttribute]
private void set_BufferPool(RecyclableMemoryStreamManager value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<ITypeSerializer> get_TypeSerializers();
    [CompilerGeneratedAttribute]
internal void set_TypeSerializers(IEnumerable`1<ITypeSerializer> value);
    [CompilerGeneratedAttribute]
internal MetadataSyncOptions get_MetadataSyncOptions();
    [CompilerGeneratedAttribute]
internal IStartupOptionsFactory get_StartupOptionsFactory();
    [CompilerGeneratedAttribute]
internal ISessionFactory get_SessionFactory();
    [CompilerGeneratedAttribute]
internal IRequestOptionsMapper get_RequestOptionsMapper();
    [CompilerGeneratedAttribute]
internal IRequestHandlerFactory get_RequestHandlerFactory();
    [CompilerGeneratedAttribute]
internal IHostConnectionPoolFactory get_HostConnectionPoolFactory();
    [CompilerGeneratedAttribute]
internal IRequestExecutionFactory get_RequestExecutionFactory();
    [CompilerGeneratedAttribute]
internal IConnectionFactory get_ConnectionFactory();
    [CompilerGeneratedAttribute]
internal IControlConnectionFactory get_ControlConnectionFactory();
    [CompilerGeneratedAttribute]
internal IPrepareHandlerFactory get_PrepareHandlerFactory();
    [CompilerGeneratedAttribute]
internal ITimerFactory get_TimerFactory();
    [CompilerGeneratedAttribute]
internal IEndPointResolver get_EndPointResolver();
    [CompilerGeneratedAttribute]
internal IDnsResolver get_DnsResolver();
    [CompilerGeneratedAttribute]
internal IMetadataRequestHandler get_MetadataRequestHandler();
    [CompilerGeneratedAttribute]
internal ITopologyRefresherFactory get_TopologyRefresherFactory();
    [CompilerGeneratedAttribute]
internal ISchemaParserFactory get_SchemaParserFactory();
    [CompilerGeneratedAttribute]
internal ISupportedOptionsInitializerFactory get_SupportedOptionsInitializerFactory();
    [CompilerGeneratedAttribute]
internal IProtocolVersionNegotiator get_ProtocolVersionNegotiator();
    [CompilerGeneratedAttribute]
internal IServerEventsSubscriber get_ServerEventsSubscriber();
    [CompilerGeneratedAttribute]
internal IDriverMetricsProvider get_MetricsProvider();
    [CompilerGeneratedAttribute]
internal DriverMetricsOptions get_MetricsOptions();
    [CompilerGeneratedAttribute]
internal string get_SessionName();
    [CompilerGeneratedAttribute]
internal bool get_MetricsEnabled();
    [CompilerGeneratedAttribute]
internal IObserverFactoryBuilder get_ObserverFactoryBuilder();
    internal static string get_DefaultApplicationVersion();
    internal static string get_FallbackApplicationName();
    [CompilerGeneratedAttribute]
public string get_ApplicationVersion();
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
public bool get_ApplicationNameWasGenerated();
    [CompilerGeneratedAttribute]
public Guid get_ClusterId();
    [CompilerGeneratedAttribute]
public GraphOptions get_GraphOptions();
    [CompilerGeneratedAttribute]
protected void set_GraphOptions(GraphOptions value);
    [CompilerGeneratedAttribute]
public bool get_AllowBetaProtocolVersions();
    [CompilerGeneratedAttribute]
internal IReadOnlyDictionary`2<string, IRequestOptions> get_RequestOptions();
    [CompilerGeneratedAttribute]
public MonitorReportingOptions get_MonitorReportingOptions();
    [CompilerGeneratedAttribute]
internal IInsightsSupportVerifier get_InsightsSupportVerifier();
    [CompilerGeneratedAttribute]
internal IInsightsClientFactory get_InsightsClientFactory();
    internal IRequestOptions get_DefaultRequestOptions();
    internal static IInsightsSupportVerifier get_DefaultInsightsSupportVerifier();
    internal static IInsightsClientFactory get_DefaultInsightsClientFactory();
    internal static IInsightsMessageFactory`1<InsightsStartupData> get_DefaultInsightsStartupMessageFactory();
    internal static IInsightsMessageFactory`1<InsightsStatusData> get_DefaultInsightsStatusMessageFactory();
    internal static IInsightsMetadataFactory get_DefaultInsightsMetadataFactory();
    internal static InsightsInfoProvidersCollection get_DefaultInsightsInfoProvidersCollection();
    [CompilerGeneratedAttribute]
internal IContactPointParser get_ContactPointParser();
    [CompilerGeneratedAttribute]
internal IServerNameResolver get_ServerNameResolver();
    private IReadOnlyDictionary`2<string, IExecutionProfile> BuildExecutionProfilesDictionary(IReadOnlyDictionary`2<string, IExecutionProfile> executionProfiles, IReadOnlyDictionary`2<string, IRequestOptions> requestOptions);
    internal PoolingOptions GetOrCreatePoolingOptions(ProtocolVersion protocolVersion);
    internal Nullable`1<int> GetHeartBeatInterval();
    internal void SetDefaultConsistencyLevel(ConsistencyLevel consistencyLevel);
}
internal class Cassandra.Connections.Connection : object {
    private static int WriteStateInit;
    private static int WriteStateRunning;
    private static int WriteStateClosed;
    private static string StreamReadTag;
    private static string StreamWriteTag;
    private static Logger Logger;
    private IStartupRequestFactory _startupRequestFactory;
    private ITcpSocket _tcpSocket;
    private long _disposed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isClosed;
    private Timer _idleTimer;
    private long _timedOutOperations;
    private ConcurrentStack`1<short> _freeOperations;
    private ConcurrentDictionary`2<short, OperationState> _pendingOperations;
    private ConcurrentQueue`1<OperationState> _writeQueue;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _keyspace;
    private TaskCompletionSource`1<bool> _keyspaceSwitchTcs;
    private Byte[] _minHeaderBuffer;
    private ISerializer _serializer;
    private int _frameHeaderSize;
    private MemoryStream _readStream;
    private FrameHeader _receivingHeader;
    private int _writeState;
    private int _inFlight;
    private IConnectionObserver _connectionObserver;
    private bool _timerEnabled;
    private int _heartBeatInterval;
    [CompilerGeneratedAttribute]
private CassandraEventHandler CassandraEventResponse;
    [CompilerGeneratedAttribute]
private Action`1<Exception> OnIdleRequestException;
    [CompilerGeneratedAttribute]
private Action WriteCompleted;
    [CompilerGeneratedAttribute]
private Action`1<IConnection> Closing;
    private static string IdleQuery;
    private static long CoalescingThreshold;
    [CompilerGeneratedAttribute]
private IFrameCompressor <Compressor>k__BackingField;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    public ISerializer Serializer { get; }
    public IFrameCompressor Compressor { get; public set; }
    public IConnectionEndPoint EndPoint { get; }
    public IPEndPoint LocalAddress { get; }
    public int WriteQueueLength { get; }
    public int PendingOperationsMapLength { get; }
    public int InFlight { get; }
    public bool HasPendingOperations { get; }
    public int TimedOutOperations { get; }
    public bool IsDisposed { get; }
    public string Keyspace { get; }
    public ProtocolOptions Options { get; }
    public Configuration Configuration { get; public set; }
    internal Connection(ISerializer serializer, IConnectionEndPoint endPoint, Configuration configuration, IStartupRequestFactory startupRequestFactory, IConnectionObserver connectionObserver);
    private static Connection();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CassandraEventResponse(CassandraEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CassandraEventResponse(CassandraEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnIdleRequestException(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnIdleRequestException(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_WriteCompleted(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_WriteCompleted(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closing(Action`1<IConnection> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closing(Action`1<IConnection> value);
    public sealed virtual ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
public sealed virtual IFrameCompressor get_Compressor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Compressor(IFrameCompressor value);
    public sealed virtual IConnectionEndPoint get_EndPoint();
    public sealed virtual IPEndPoint get_LocalAddress();
    public sealed virtual int get_WriteQueueLength();
    public sealed virtual int get_PendingOperationsMapLength();
    public virtual int get_InFlight();
    public virtual bool get_HasPendingOperations();
    public virtual int get_TimedOutOperations();
    public sealed virtual bool get_IsDisposed();
    public sealed virtual string get_Keyspace();
    public sealed virtual ProtocolOptions get_Options();
    [CompilerGeneratedAttribute]
public Configuration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(Configuration value);
    private void IncrementInFlight();
    private void DecrementInFlight();
    public sealed virtual int GetMaxConcurrentRequests(ISerializer serializer);
    [AsyncStateMachineAttribute("Cassandra.Connections.Connection/<StartAuthenticationFlow>d__75")]
private Task`1<Response> StartAuthenticationFlow(string name);
    [AsyncStateMachineAttribute("Cassandra.Connections.Connection/<Authenticate>d__76")]
private Task`1<Response> Authenticate(Byte[] token, IAuthenticator authenticator);
    private void CloseInternal(Exception ex, Nullable`1<SocketError> socketError, bool dispose);
    private void OnSocketError(Exception ex, Nullable`1<SocketError> socketError);
    public virtual void Dispose();
    public sealed virtual void Close();
    private void InternalDispose();
    private Task EventHandler(IRequestError error, Response response, long timestamp);
    private void IdleTimeoutHandler(object state);
    [AsyncStateMachineAttribute("Cassandra.Connections.Connection/<Open>d__84")]
public sealed virtual Task`1<Response> Open();
    [AsyncStateMachineAttribute("Cassandra.Connections.Connection/<DoOpen>d__85")]
public Task`1<Response> DoOpen();
    private void ReadHandler(Byte[] buffer, int bytesReceived);
    internal bool ReadParse(Byte[] buffer, int length);
    private FrameHeader ReadHeader(Byte[] buffer, Int32& offset, int length, int headerLength, ProtocolVersion version);
    private void StoreReadState(FrameHeader header, MemoryStream stream, Byte[] buffer, int offset, int length, bool hasReadFromStream);
    private Func`3<MemoryStream, long, Task> CreateResponseAction(ResultMetadata resultMetadata, ISerializer serializer, FrameHeader header, Func`4<IRequestError, Response, long, Task> callback);
    private static bool InvokeReadCallbacks(MemoryStream stream, ICollection`1<Func`3<MemoryStream, long, Task>> operationCallbacks, long timestamp);
    private Task`1<Response> Startup();
    public sealed virtual Task`1<Response> Send(IRequest request, int timeoutMillis);
    public sealed virtual Task`1<Response> Send(IRequest request);
    public sealed virtual OperationState Send(IRequest request, Func`3<IRequestError, Response, Task> callback, int timeoutMillis);
    public sealed virtual OperationState Send(IRequest request, Func`3<IRequestError, Response, Task> callback);
    private void RunWriteQueue();
    private long GetTimestamp();
    private void RunWriteQueueAction();
    protected internal virtual OperationState RemoveFromPending(short streamId);
    [AsyncStateMachineAttribute("Cassandra.Connections.Connection/<SetKeyspace>d__101")]
public sealed virtual Task`1<bool> SetKeyspace(string value);
    private void OnTimeout(object stateObj);
    protected virtual void WriteCompletedHandler();
    [CompilerGeneratedAttribute]
private Task <IdleTimeoutHandler>b__83_0(IRequestError error, Response response);
    [CompilerGeneratedAttribute]
private Task <OnTimeout>b__102_0();
}
internal class Cassandra.Connections.ConnectionEndPoint : object {
    private IServerNameResolver _serverNameResolver;
    [CompilerGeneratedAttribute]
private IContactPoint <ContactPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <SocketIpEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointFriendlyName>k__BackingField;
    public IContactPoint ContactPoint { get; }
    public IPEndPoint SocketIpEndPoint { get; }
    public string EndpointFriendlyName { get; }
    public ConnectionEndPoint(IPEndPoint hostIpEndPoint, IServerNameResolver serverNameResolver, IContactPoint contactPoint);
    [CompilerGeneratedAttribute]
public sealed virtual IContactPoint get_ContactPoint();
    [CompilerGeneratedAttribute]
public sealed virtual IPEndPoint get_SocketIpEndPoint();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EndpointFriendlyName();
    public sealed virtual Task`1<string> GetServerNameAsync();
    public virtual string ToString();
    public sealed virtual IPEndPoint GetHostIpEndPointWithFallback();
    public sealed virtual IPEndPoint GetHostIpEndPoint();
    public sealed virtual bool Equals(IConnectionEndPoint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private string <GetServerNameAsync>b__11_0();
}
internal class Cassandra.Connections.ConnectionFactory : object {
    public sealed virtual IConnection Create(ISerializer serializer, IConnectionEndPoint endPoint, Configuration configuration, IConnectionObserver connectionObserver);
    public sealed virtual IConnection CreateUnobserved(ISerializer serializer, IConnectionEndPoint endPoint, Configuration configuration);
}
internal class Cassandra.Connections.Control.ContactPointParser : object {
    private IDnsResolver _dnsResolver;
    private ProtocolOptions _protocolOptions;
    private IServerNameResolver _serverNameResolver;
    private bool _keepContactPointsUnresolved;
    public ContactPointParser(IDnsResolver dnsResolver, ProtocolOptions protocolOptions, IServerNameResolver serverNameResolver, bool keepContactPointsUnresolved);
    public sealed virtual IEnumerable`1<IContactPoint> ParseContactPoints(IEnumerable`1<object> providedContactPoints);
}
internal class Cassandra.Connections.Control.ControlConnection : object {
    private static int StateRunning;
    private static int StateDisposed;
    private IInternalCluster _cluster;
    private Metadata _metadata;
    private Host modreq(System.Runtime.CompilerServices.IsVolatile) _host;
    private IConnectionEndPoint modreq(System.Runtime.CompilerServices.IsVolatile) _currentConnectionEndPoint;
    private IConnection modreq(System.Runtime.CompilerServices.IsVolatile) _connection;
    internal static Logger Logger;
    private Configuration _config;
    private IReconnectionPolicy _reconnectionPolicy;
    private IReconnectionSchedule _reconnectionSchedule;
    private Timer _reconnectionTimer;
    private int _refreshFlag;
    private Task`1<IConnection> _reconnectTask;
    private ISerializerManager _serializer;
    private IProtocolEventDebouncer _eventDebouncer;
    private IEnumerable`1<IContactPoint> _contactPoints;
    private ITopologyRefresher _topologyRefresher;
    private ISupportedOptionsInitializer _supportedOptionsInitializer;
    private long _state;
    private bool IsShutdown { get; }
    public ProtocolVersion ProtocolVersion { get; }
    public Host Host { get; internal set; }
    public IConnectionEndPoint EndPoint { get; }
    public IPEndPoint LocalAddress { get; }
    public ISerializerManager Serializer { get; }
    internal ControlConnection(IInternalCluster cluster, IProtocolEventDebouncer eventDebouncer, ProtocolVersion initialProtocolVersion, Configuration config, Metadata metadata, IEnumerable`1<IContactPoint> contactPoints);
    private static ControlConnection();
    private bool get_IsShutdown();
    public sealed virtual ProtocolVersion get_ProtocolVersion();
    public sealed virtual Host get_Host();
    internal void set_Host(Host value);
    public sealed virtual IConnectionEndPoint get_EndPoint();
    public sealed virtual IPEndPoint get_LocalAddress();
    public sealed virtual ISerializerManager get_Serializer();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<InitAsync>d__35")]
public sealed virtual Task InitAsync();
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<InitialContactPointResolutionAsync>d__36")]
private Task InitialContactPointResolutionAsync();
    private bool TotalConnectivityLoss();
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<ResolveContactPoint>d__38")]
private Task`1<IEnumerable`1<IConnectionEndPoint>> ResolveContactPoint(IContactPoint contactPoint, bool refresh);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<ResolveHostContactPointOrConnectionEndpointAsync>d__39")]
private Task`1<IEnumerable`1<IConnectionEndPoint>> ResolveHostContactPointOrConnectionEndpointAsync(ConcurrentDictionary`2<IContactPoint, object> attemptedContactPoints, Host host, bool refreshContactPoints, bool refreshEndpoints);
    [IteratorStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<ContactPointResolutionTasksEnumerable>d__40")]
private IEnumerable`1<Task`1<IEnumerable`1<IConnectionEndPoint>>> ContactPointResolutionTasksEnumerable(ConcurrentDictionary`2<IContactPoint, object> attemptedContactPoints, bool refresh);
    [IteratorStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<AllHostsEndPointResolutionTasksEnumerable>d__41")]
private IEnumerable`1<Task`1<IEnumerable`1<IConnectionEndPoint>>> AllHostsEndPointResolutionTasksEnumerable(ConcurrentDictionary`2<IContactPoint, object> attemptedContactPoints, ConcurrentDictionary`2<Host, object> attemptedHosts, bool isInitializing, bool refreshContactPoints, bool refreshEndpoints);
    [IteratorStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<DefaultLbpHostsEnumerable>d__42")]
private IEnumerable`1<Task`1<IEnumerable`1<IConnectionEndPoint>>> DefaultLbpHostsEnumerable(ConcurrentDictionary`2<IContactPoint, object> attemptedContactPoints, ConcurrentDictionary`2<Host, object> attemptedHosts, bool isInitializing, bool refreshContactPoints, bool refreshEndpoints);
    private bool IsHostValid(Host host, bool initializing);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<Connect>d__44")]
private Task Connect(bool isInitializing);
    private void ReconnectEventHandler(object state);
    internal void OnConnectionClosing(IConnection connection);
    private void OnIdleRequestException(IConnection c, Exception ex);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<ReconnectFireAndForget>d__48")]
private void ReconnectFireAndForget(IConnection closedConnection);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<Reconnect>d__49")]
internal Task`1<IConnection> Reconnect(IConnection closedConnection);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<Refresh>d__50")]
private Task Refresh();
    public void Shutdown();
    private void Unsubscribe(Host h, IConnection c);
    private void Subscribe(Host h, IConnection c);
    private void OnHostDown(Host h);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<OnConnectionCassandraEvent>d__55")]
private void OnConnectionCassandraEvent(object sender, CassandraEventArgs e);
    public sealed virtual Task HandleSchemaChangeEvent(SchemaChangeEventArgs ssc, bool processNow);
    private void HandleStatusChangeEvent(StatusChangeEventArgs e);
    private IPEndPoint TranslateAddress(IPEndPoint value);
    private void SetCurrentConnectionEndpoint(Host host, IConnectionEndPoint endPoint);
    private bool SetCurrentConnection(IConnection connection, Host host, IConnectionEndPoint endPoint);
    public sealed virtual IEnumerable`1<IRow> Query(string cqlQuery, bool retry);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<QueryAsync>d__62")]
public sealed virtual Task`1<IEnumerable`1<IRow>> QueryAsync(string cqlQuery, bool retry);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<SendQueryRequestAsync>d__63")]
public sealed virtual Task`1<Response> SendQueryRequestAsync(string cqlQuery, bool retry, QueryProtocolOptions queryProtocolOptions);
    public sealed virtual Task`1<Response> UnsafeSendQueryRequestAsync(string cqlQuery, QueryProtocolOptions queryProtocolOptions);
    [IteratorStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<GetHostEnumerable>d__65")]
private IEnumerable`1<Host> GetHostEnumerable();
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ControlConnection/<HandleKeyspaceRefreshLaterAsync>d__66")]
public sealed virtual Task HandleKeyspaceRefreshLaterAsync(string keyspace);
    public sealed virtual Task ScheduleKeyspaceRefreshAsync(string keyspace, bool processNow);
    private Task ScheduleObjectRefreshAsync(string keyspace, bool processNow, Func`1<Task> handler);
    private Task ScheduleHostsRefreshAsync();
    public sealed virtual Task ScheduleAllKeyspacesRefreshAsync(bool processNow);
    [CompilerGeneratedAttribute]
private bool <TotalConnectivityLoss>b__37_1(Host h);
    [CompilerGeneratedAttribute]
private Task <ScheduleAllKeyspacesRefreshAsync>b__70_0();
}
internal class Cassandra.Connections.Control.ControlConnectionFactory : object {
    public sealed virtual IControlConnection Create(IInternalCluster cluster, IProtocolEventDebouncer protocolEventDebouncer, ProtocolVersion initialProtocolVersion, Configuration config, Metadata metadata, IEnumerable`1<IContactPoint> contactPoints);
}
internal interface Cassandra.Connections.Control.IContactPoint {
    public bool CanBeResolved { get; }
    public string StringRepresentation { get; }
    public abstract virtual bool get_CanBeResolved();
    public abstract virtual string get_StringRepresentation();
    public abstract virtual Task`1<IEnumerable`1<IConnectionEndPoint>> GetConnectionEndPointsAsync(bool refreshCache);
}
internal interface Cassandra.Connections.Control.IContactPointParser {
    public abstract virtual IEnumerable`1<IContactPoint> ParseContactPoints(IEnumerable`1<object> providedContactPoints);
}
internal interface Cassandra.Connections.Control.IControlConnection {
    public Host Host { get; }
    public abstract virtual Host get_Host();
    public abstract virtual Task InitAsync();
    public abstract virtual Task HandleSchemaChangeEvent(SchemaChangeEventArgs ssc, bool processNow);
    public abstract virtual Task HandleKeyspaceRefreshLaterAsync(string keyspace);
    public abstract virtual Task ScheduleKeyspaceRefreshAsync(string keyspace, bool processNow);
    public abstract virtual Task ScheduleAllKeyspacesRefreshAsync(bool processNow);
}
internal interface Cassandra.Connections.Control.IControlConnectionFactory {
    public abstract virtual IControlConnection Create(IInternalCluster cluster, IProtocolEventDebouncer protocolEventDebouncer, ProtocolVersion initialProtocolVersion, Configuration config, Metadata metadata, IEnumerable`1<IContactPoint> contactPoints);
}
internal interface Cassandra.Connections.Control.IMetadataRequestHandler {
    public abstract virtual Task`1<Response> SendMetadataRequestAsync(IConnection connection, ISerializer serializer, string cqlQuery, QueryProtocolOptions queryProtocolOptions);
    public abstract virtual Task`1<Response> UnsafeSendQueryRequestAsync(IConnection connection, ISerializer serializer, string cqlQuery, QueryProtocolOptions queryProtocolOptions);
    public abstract virtual IEnumerable`1<IRow> GetRowSet(Response response);
}
internal class Cassandra.Connections.Control.IpLiteralContactPoint : object {
    private IPEndPoint _ipEndPoint;
    private ProtocolOptions _protocolOptions;
    private IPAddress _ipAddress;
    private IServerNameResolver _serverNameResolver;
    public bool CanBeResolved { get; }
    public string StringRepresentation { get; }
    public IpLiteralContactPoint(IPEndPoint ipEndPoint, IServerNameResolver serverNameResolver);
    public IpLiteralContactPoint(IPAddress ipAddress, ProtocolOptions protocolOptions, IServerNameResolver serverNameResolver);
    public sealed virtual bool get_CanBeResolved();
    public sealed virtual string get_StringRepresentation();
    public virtual string ToString();
    private bool TypedEquals(IpLiteralContactPoint other);
    public sealed virtual bool Equals(IContactPoint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Task`1<IEnumerable`1<IConnectionEndPoint>> GetConnectionEndPointsAsync(bool refreshCache);
}
internal interface Cassandra.Connections.Control.IProtocolVersionNegotiator {
    public abstract virtual Task`1<IConnection> ChangeProtocolVersion(Configuration config, ISerializerManager serializer, ProtocolVersion nextVersion, IConnection previousConnection, UnsupportedProtocolVersionException ex, Nullable`1<ProtocolVersion> previousVersion);
    public abstract virtual Task`1<IConnection> NegotiateVersionAsync(Configuration config, Metadata metadata, IConnection connection, ISerializerManager serializer);
}
internal interface Cassandra.Connections.Control.IServerEventsSubscriber {
    public abstract virtual Task SubscribeToServerEvents(IConnection connection, CassandraEventHandler handler);
}
internal interface Cassandra.Connections.Control.ISupportedOptionsInitializer {
    public abstract virtual Task ApplySupportedOptionsAsync(IConnection connection);
}
internal interface Cassandra.Connections.Control.ISupportedOptionsInitializerFactory {
    public abstract virtual ISupportedOptionsInitializer Create(Metadata metadata);
}
internal interface Cassandra.Connections.Control.ITopologyRefresher {
    public abstract virtual Task`1<Host> RefreshNodeListAsync(IConnectionEndPoint currentEndPoint, IConnection connection, ISerializer serializer);
}
internal interface Cassandra.Connections.Control.ITopologyRefresherFactory {
    public abstract virtual ITopologyRefresher Create(Metadata metadata, Configuration config);
}
internal class Cassandra.Connections.Control.MetadataRequestHandler : object {
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.MetadataRequestHandler/<SendMetadataRequestAsync>d__0")]
public sealed virtual Task`1<Response> SendMetadataRequestAsync(IConnection connection, ISerializer serializer, string cqlQuery, QueryProtocolOptions queryProtocolOptions);
    public sealed virtual Task`1<Response> UnsafeSendQueryRequestAsync(IConnection connection, ISerializer serializer, string cqlQuery, QueryProtocolOptions queryProtocolOptions);
    public sealed virtual IEnumerable`1<IRow> GetRowSet(Response response);
}
internal class Cassandra.Connections.Control.ProtocolVersionNegotiator : object {
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ProtocolVersionNegotiator/<NegotiateVersionAsync>d__0")]
public sealed virtual Task`1<IConnection> NegotiateVersionAsync(Configuration config, Metadata metadata, IConnection connection, ISerializerManager serializer);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ProtocolVersionNegotiator/<ChangeProtocolVersion>d__1")]
public sealed virtual Task`1<IConnection> ChangeProtocolVersion(Configuration config, ISerializerManager serializer, ProtocolVersion nextVersion, IConnection previousConnection, UnsupportedProtocolVersionException ex, Nullable`1<ProtocolVersion> previousVersion);
}
internal class Cassandra.Connections.Control.ServerEventsSubscriber : object {
    private static CassandraEventType CassandraEventTypes;
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.ServerEventsSubscriber/<SubscribeToServerEvents>d__1")]
public sealed virtual Task SubscribeToServerEvents(IConnection connection, CassandraEventHandler handler);
}
internal class Cassandra.Connections.Control.SniContactPoint : object {
    private ISniEndPointResolver _resolver;
    public bool CanBeResolved { get; }
    public string StringRepresentation { get; }
    public SniContactPoint(ISniEndPointResolver resolver);
    public sealed virtual bool get_CanBeResolved();
    public virtual string ToString();
    public sealed virtual string get_StringRepresentation();
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.SniContactPoint/<GetConnectionEndPointsAsync>d__7")]
public sealed virtual Task`1<IEnumerable`1<IConnectionEndPoint>> GetConnectionEndPointsAsync(bool refreshCache);
    private bool TypedEquals(SniContactPoint other);
    public sealed virtual bool Equals(IContactPoint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Cassandra.Connections.Control.SupportedOptionsInitializer : object {
    private static string SupportedProductTypeKey;
    private static string SupportedDbaas;
    private Metadata _metadata;
    public SupportedOptionsInitializer(Metadata metadata);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.SupportedOptionsInitializer/<ApplySupportedOptionsAsync>d__4")]
public sealed virtual Task ApplySupportedOptionsAsync(IConnection connection);
    private void ApplyProductTypeOption(IDictionary`2<string, String[]> options);
}
internal class Cassandra.Connections.Control.SupportedOptionsInitializerFactory : object {
    public sealed virtual ISupportedOptionsInitializer Create(Metadata metadata);
}
internal class Cassandra.Connections.Control.TopologyRefresher : object {
    private static string SelectPeers;
    private static string SelectPeersV2;
    private static string SelectLocal;
    private static IPAddress BindAllAddress;
    private Configuration _config;
    private Metadata _metadata;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isPeersV2;
    public TopologyRefresher(Metadata metadata, Configuration config);
    private static TopologyRefresher();
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.TopologyRefresher/<RefreshNodeListAsync>d__8")]
public sealed virtual Task`1<Host> RefreshNodeListAsync(IConnectionEndPoint currentEndPoint, IConnection connection, ISerializer serializer);
    private Task`1<Response> SendSystemLocalRequestAsync(IConnection connection, ISerializer serializer);
    private Task`1<PeersResponse> SendSystemPeersRequestAsync(bool isPeersV2, IConnection connection, ISerializer serializer);
    [AsyncStateMachineAttribute("Cassandra.Connections.Control.TopologyRefresher/<GetPeersResponseAsync>d__11")]
private Task`1<PeersResponse> GetPeersResponseAsync(bool isPeersV2, Task`1<Response> peersRequest, IConnection connection, ISerializer serializer);
    private Host GetAndUpdateLocalHost(IConnectionEndPoint endPoint, IRow row);
    private void UpdatePeersInfo(bool isPeersV2, IEnumerable`1<IRow> peersRs, Host currentHost);
    internal IPEndPoint GetRpcEndPoint(bool isPeersV2, IRow row, IAddressTranslator translator, int defaultPort);
    private IPAddress GetRpcAddressFromPeersV2(IRow row);
    private IPAddress GetRpcAddressFromLocalPeersV1(IRow row);
    private Nullable`1<int> GetRpcPortFromPeersV2(IRow row);
}
internal class Cassandra.Connections.Control.TopologyRefresherFactory : object {
    public sealed virtual ITopologyRefresher Create(Metadata metadata, Configuration config);
}
internal class Cassandra.Connections.DnsResolver : object {
    public sealed virtual Task`1<IPHostEntry> GetHostEntryAsync(string name);
}
internal class Cassandra.Connections.EndPointResolver : object {
    private IServerNameResolver _serverNameResolver;
    public EndPointResolver(IServerNameResolver serverNameResolver);
    public sealed virtual Task`1<IConnectionEndPoint> GetConnectionEndPointAsync(Host host, bool refreshCache);
}
internal class Cassandra.Connections.HostConnectionPool : object {
    private static Logger Logger;
    private static int ConnectionIndexOverflow;
    private static long BetweenResizeDelay;
    private Configuration _config;
    private ISerializerManager _serializerManager;
    private IObserverFactory _observerFactory;
    private CopyOnWriteList`1<IConnection> _connections;
    private HashedWheelTimer _timer;
    private SemaphoreSlim _allConnectionClosedEventLock;
    private Host _host;
    private IReconnectionSchedule modreq(System.Runtime.CompilerServices.IsVolatile) _reconnectionSchedule;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _expectedConnectionLength;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _maxInflightThresholdToConsiderResizing;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _maxConnectionLength;
    private ITimeout modreq(System.Runtime.CompilerServices.IsVolatile) _resizingEndTimeout;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _canCreateForeground;
    private int _poolResizing;
    private int _state;
    private ITimeout _newConnectionTimeout;
    private TaskCompletionSource`1<IConnection> _connectionOpenTcs;
    private int _connectionIndex;
    private int _maxRequestsPerConnection;
    private PoolingOptions _poolingOptions;
    [CompilerGeneratedAttribute]
private Action`2<Host, HostConnectionPool> AllConnectionClosed;
    public bool HasConnections { get; }
    public int OpenConnections { get; }
    public int InFlight { get; }
    private bool IsClosing { get; }
    public IConnection[] ConnectionsSnapshot { get; }
    public HostConnectionPool(Host host, Configuration config, ISerializerManager serializerManager, IObserverFactory observerFactory);
    private static HostConnectionPool();
    [CompilerGeneratedAttribute]
public sealed virtual void add_AllConnectionClosed(Action`2<Host, HostConnectionPool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AllConnectionClosed(Action`2<Host, HostConnectionPool> value);
    public sealed virtual bool get_HasConnections();
    public sealed virtual int get_OpenConnections();
    public sealed virtual int get_InFlight();
    private bool get_IsClosing();
    public sealed virtual IConnection[] get_ConnectionsSnapshot();
    [AsyncStateMachineAttribute("Cassandra.Connections.HostConnectionPool/<BorrowConnectionAsync>d__38")]
public sealed virtual Task`1<IConnection> BorrowConnectionAsync();
    public sealed virtual IConnection BorrowExistingConnection();
    private IConnection BorrowLeastBusyConnection(IConnection[] connections);
    private void CancelNewConnectionTimeout(ITimeout newTimeout);
    public sealed virtual void CheckHealth(IConnection c);
    public sealed virtual void Remove(IConnection c);
    public void ConsiderResizingPool(int inFlight);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Cassandra.Connections.HostConnectionPool/<DoCreateAndOpen>d__46")]
public virtual Task`1<IConnection> DoCreateAndOpen(bool isReconnection);
    public sealed virtual void OnHostRemoved();
    public static IConnection MinInFlight(IConnection[] connections, Int32& connectionIndex, int inFlightThreshold, Int32& inFlight);
    internal void OnConnectionClosing(IConnection c);
    private void OnDistanceChanged(HostDistance previousDistance, HostDistance distance);
    private void DrainConnections(Action afterDrainHandler);
    private void DrainConnectionsTimer(IConnection[] connections, Action afterDrainHandler, int steps);
    public void OnHostUp(Host h);
    private void OnHostDown(Host h);
    private void OnIdleRequestException(IConnection c, Exception ex);
    public sealed virtual void ScheduleReconnection(bool immediate);
    private void SetNewConnectionTimeout(IReconnectionSchedule schedule);
    private void StartCreatingConnection(IReconnectionSchedule schedule);
    [AsyncStateMachineAttribute("Cassandra.Connections.HostConnectionPool/<CreateOrScheduleReconnectAsync>d__59")]
private Task CreateOrScheduleReconnectAsync(IReconnectionSchedule schedule);
    [AsyncStateMachineAttribute("Cassandra.Connections.HostConnectionPool/<CreateOpenConnection>d__60")]
private Task`1<IConnection> CreateOpenConnection(bool satisfyWithAnOpenConnection, bool isReconnection);
    private Task`1<IConnection> FinishOpen(TaskCompletionSource`1<IConnection> tcs, bool preventForeground, Exception ex, IConnection c);
    private static SocketException GetNotConnectedException();
    [AsyncStateMachineAttribute("Cassandra.Connections.HostConnectionPool/<EnsureCreate>d__63")]
public Task`1<IConnection[]> EnsureCreate();
    private IConnection[] GetExistingConnections();
    public sealed virtual void SetDistance(HostDistance distance);
    public sealed virtual void MarkAsDownAndScheduleReconnection();
    public sealed virtual Task`1<IConnection> GetConnectionFromHostAsync(IDictionary`2<IPEndPoint, Exception> triedHosts, Func`1<string> getKeyspaceFunc);
    public sealed virtual Task`1<IConnection> GetExistingConnectionFromHostAsync(IDictionary`2<IPEndPoint, Exception> triedHosts, Func`1<string> getKeyspaceFunc);
    [AsyncStateMachineAttribute("Cassandra.Connections.HostConnectionPool/<GetConnectionFromHostAsync>d__69")]
private Task`1<IConnection> GetConnectionFromHostAsync(IDictionary`2<IPEndPoint, Exception> triedHosts, Func`1<string> getKeyspaceFunc, bool createIfNeeded);
    [AsyncStateMachineAttribute("Cassandra.Connections.HostConnectionPool/<Warmup>d__70")]
public sealed virtual Task Warmup();
    [CompilerGeneratedAttribute]
private void <ConsiderResizingPool>b__44_0(object _);
    [CompilerGeneratedAttribute]
private void <OnHostRemoved>b__47_0();
    [CompilerGeneratedAttribute]
private void <OnDistanceChanged>b__50_0();
}
internal class Cassandra.Connections.HostConnectionPoolFactory : object {
    public sealed virtual IHostConnectionPool Create(Host host, Configuration config, ISerializerManager serializerManager, IObserverFactory observerFactory);
}
internal class Cassandra.Connections.HostnameContactPoint : object {
    private IDnsResolver _dns;
    private ProtocolOptions _protocolOptions;
    private IServerNameResolver _serverNameResolver;
    private string _hostname;
    private IEnumerable`1 modreq(System.Runtime.CompilerServices.IsVolatile) _cachedEndpoints;
    private bool _keepContactPointsUnresolved;
    public bool CanBeResolved { get; }
    public string StringRepresentation { get; }
    public HostnameContactPoint(IDnsResolver dnsResolver, ProtocolOptions protocolOptions, IServerNameResolver serverNameResolver, bool keepContactPointsUnresolved, string hostname);
    public sealed virtual bool get_CanBeResolved();
    public sealed virtual string get_StringRepresentation();
    public virtual string ToString();
    public sealed virtual Task`1<IEnumerable`1<IConnectionEndPoint>> GetConnectionEndPointsAsync(bool refreshCache);
    [AsyncStateMachineAttribute("Cassandra.Connections.HostnameContactPoint/<ResolveContactPointAsync>d__13")]
private Task`1<IEnumerable`1<IConnectionEndPoint>> ResolveContactPointAsync(bool refreshCache);
    private bool TypedEquals(HostnameContactPoint other);
    public sealed virtual bool Equals(IContactPoint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private ConnectionEndPoint <ResolveContactPointAsync>b__13_1(IPAddress resolvedAddress);
}
internal interface Cassandra.Connections.IConnection {
    public ISerializer Serializer { get; }
    public IFrameCompressor Compressor { get; public set; }
    public IConnectionEndPoint EndPoint { get; }
    public IPEndPoint LocalAddress { get; }
    public int WriteQueueLength { get; }
    public int PendingOperationsMapLength { get; }
    public int InFlight { get; }
    public bool HasPendingOperations { get; }
    public int TimedOutOperations { get; }
    public bool IsDisposed { get; }
    public string Keyspace { get; }
    public ProtocolOptions Options { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_CassandraEventResponse(CassandraEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CassandraEventResponse(CassandraEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnIdleRequestException(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnIdleRequestException(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WriteCompleted(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WriteCompleted(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closing(Action`1<IConnection> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closing(Action`1<IConnection> value);
    public abstract virtual ISerializer get_Serializer();
    public abstract virtual IFrameCompressor get_Compressor();
    public abstract virtual void set_Compressor(IFrameCompressor value);
    public abstract virtual IConnectionEndPoint get_EndPoint();
    public abstract virtual IPEndPoint get_LocalAddress();
    public abstract virtual int get_WriteQueueLength();
    public abstract virtual int get_PendingOperationsMapLength();
    public abstract virtual int get_InFlight();
    public abstract virtual bool get_HasPendingOperations();
    public abstract virtual int get_TimedOutOperations();
    public abstract virtual bool get_IsDisposed();
    public abstract virtual string get_Keyspace();
    public abstract virtual int GetMaxConcurrentRequests(ISerializer serializer);
    public abstract virtual ProtocolOptions get_Options();
    public abstract virtual Task`1<Response> Open();
    public abstract virtual Task`1<Response> Send(IRequest request, int timeoutMillis);
    public abstract virtual OperationState Send(IRequest request, Func`3<IRequestError, Response, Task> callback, int timeoutMillis);
    public abstract virtual Task`1<Response> Send(IRequest request);
    public abstract virtual OperationState Send(IRequest request, Func`3<IRequestError, Response, Task> callback);
    public abstract virtual Task`1<bool> SetKeyspace(string value);
    public abstract virtual void Close();
}
internal interface Cassandra.Connections.IConnectionEndPoint {
    public IContactPoint ContactPoint { get; }
    public IPEndPoint SocketIpEndPoint { get; }
    public string EndpointFriendlyName { get; }
    public abstract virtual IContactPoint get_ContactPoint();
    public abstract virtual IPEndPoint get_SocketIpEndPoint();
    public abstract virtual string get_EndpointFriendlyName();
    public abstract virtual Task`1<string> GetServerNameAsync();
    public abstract virtual IPEndPoint GetHostIpEndPointWithFallback();
    public abstract virtual IPEndPoint GetHostIpEndPoint();
}
internal interface Cassandra.Connections.IConnectionFactory {
    public abstract virtual IConnection Create(ISerializer serializer, IConnectionEndPoint endPoint, Configuration configuration, IConnectionObserver connectionObserver);
    public abstract virtual IConnection CreateUnobserved(ISerializer serializer, IConnectionEndPoint endPoint, Configuration configuration);
}
internal interface Cassandra.Connections.IDnsResolver {
    public abstract virtual Task`1<IPHostEntry> GetHostEntryAsync(string name);
}
internal interface Cassandra.Connections.IEndPointResolver {
    public abstract virtual Task`1<IConnectionEndPoint> GetConnectionEndPointAsync(Host host, bool refreshCache);
}
internal interface Cassandra.Connections.IHostConnectionPool {
    public int OpenConnections { get; }
    public int InFlight { get; }
    public bool HasConnections { get; }
    public IConnection[] ConnectionsSnapshot { get; }
    public abstract virtual int get_OpenConnections();
    public abstract virtual int get_InFlight();
    public abstract virtual bool get_HasConnections();
    [CompilerGeneratedAttribute]
public abstract virtual void add_AllConnectionClosed(Action`2<Host, HostConnectionPool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AllConnectionClosed(Action`2<Host, HostConnectionPool> value);
    public abstract virtual IConnection[] get_ConnectionsSnapshot();
    public abstract virtual Task`1<IConnection> BorrowConnectionAsync();
    public abstract virtual IConnection BorrowExistingConnection();
    public abstract virtual void SetDistance(HostDistance distance);
    public abstract virtual void CheckHealth(IConnection connection);
    public abstract virtual void Remove(IConnection c);
    public abstract virtual void ScheduleReconnection(bool immediate);
    public abstract virtual Task Warmup();
    public abstract virtual void OnHostRemoved();
    public abstract virtual void MarkAsDownAndScheduleReconnection();
    public abstract virtual Task`1<IConnection> GetConnectionFromHostAsync(IDictionary`2<IPEndPoint, Exception> triedHosts, Func`1<string> getKeyspaceFunc);
    public abstract virtual Task`1<IConnection> GetExistingConnectionFromHostAsync(IDictionary`2<IPEndPoint, Exception> triedHosts, Func`1<string> getKeyspaceFunc);
}
internal interface Cassandra.Connections.IHostConnectionPoolFactory {
    public abstract virtual IHostConnectionPool Create(Host host, Configuration config, ISerializerManager serializer, IObserverFactory observerFactory);
}
internal interface Cassandra.Connections.IRequestError {
    public Exception Exception { get; }
    public bool IsServerError { get; }
    public bool Unsent { get; }
    public abstract virtual Exception get_Exception();
    public abstract virtual bool get_IsServerError();
    public abstract virtual bool get_Unsent();
}
internal interface Cassandra.Connections.IServerNameResolver {
    public abstract virtual string GetServerName(IPEndPoint socketIpEndPoint);
}
internal interface Cassandra.Connections.ISniEndPointResolver {
    public abstract virtual Task`1<IPEndPoint> GetNextEndPointAsync(bool refreshCache);
    public abstract virtual Task`1<SniOptions> GetSniOptionsAsync(bool refreshSniOptions);
    public abstract virtual string GetStaticIdentifier();
}
internal interface Cassandra.Connections.ISniOptionsProvider {
    public abstract virtual Task`1<SniOptions> GetAsync(bool refresh);
    public abstract virtual bool IsInitialized();
    public abstract virtual string GetStaticIdentifier();
}
internal interface Cassandra.Connections.ITcpSocket {
    public IConnectionEndPoint EndPoint { get; }
    public SocketOptions Options { get; }
    public SSLOptions SSLOptions { get; public set; }
    public abstract virtual IConnectionEndPoint get_EndPoint();
    public abstract virtual SocketOptions get_Options();
    public abstract virtual SSLOptions get_SSLOptions();
    public abstract virtual void set_SSLOptions(SSLOptions value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Read(Action`2<Byte[], int> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Read(Action`2<Byte[], int> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WriteCompleted(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WriteCompleted(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closing(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closing(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Error(Action`2<Exception, Nullable`1<SocketError>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Error(Action`2<Exception, Nullable`1<SocketError>> value);
    public abstract virtual IPEndPoint GetLocalIpEndPoint();
    public abstract virtual Task`1<bool> Connect();
    public abstract virtual void Write(RecyclableMemoryStream stream, Action onBufferFlush);
}
internal class Cassandra.Connections.RequestError : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unsent>k__BackingField;
    public Exception Exception { get; }
    public bool IsServerError { get; }
    public bool Unsent { get; }
    private RequestError(Exception ex, bool isServerError, bool unsent);
    public static IRequestError CreateServerError(ErrorResponse response);
    public static IRequestError CreateServerError(Exception ex);
    public static IRequestError CreateClientError(Exception ex, bool unsent);
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsServerError();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Unsent();
}
internal class Cassandra.Connections.ServerNameResolver : object {
    private ProtocolOptions _protocolOptions;
    public ServerNameResolver(ProtocolOptions protocolOptions);
    public sealed virtual string GetServerName(IPEndPoint socketIpEndPoint);
}
internal class Cassandra.Connections.SingleThreadedResolver : object {
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _currentTask;
    [CompilerGeneratedAttribute]
private SemaphoreSlim <RefreshSemaphoreSlim>k__BackingField;
    public SemaphoreSlim RefreshSemaphoreSlim { get; }
    [CompilerGeneratedAttribute]
public SemaphoreSlim get_RefreshSemaphoreSlim();
    [AsyncStateMachineAttribute("Cassandra.Connections.SingleThreadedResolver/<RefreshIfNeededAsync>d__4")]
public Task RefreshIfNeededAsync(Func`1<bool> refreshNeeded, Func`1<Task> refreshFunc);
}
internal class Cassandra.Connections.SniConnectionEndPoint : object {
    private string _serverName;
    private IPEndPoint _hostIpEndPoint;
    [CompilerGeneratedAttribute]
private IContactPoint <ContactPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <SocketIpEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointFriendlyName>k__BackingField;
    public IContactPoint ContactPoint { get; }
    public IPEndPoint SocketIpEndPoint { get; }
    public string EndpointFriendlyName { get; }
    public SniConnectionEndPoint(IPEndPoint socketIpEndPoint, string serverName, IContactPoint contactPoint);
    public SniConnectionEndPoint(IPEndPoint socketIpEndPoint, IPEndPoint hostIpEndPoint, string serverName, IContactPoint contactPoint);
    [CompilerGeneratedAttribute]
public sealed virtual IContactPoint get_ContactPoint();
    [CompilerGeneratedAttribute]
public sealed virtual IPEndPoint get_SocketIpEndPoint();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EndpointFriendlyName();
    public virtual string ToString();
    public sealed virtual Task`1<string> GetServerNameAsync();
    public sealed virtual IPEndPoint GetHostIpEndPointWithFallback();
    public sealed virtual IPEndPoint GetHostIpEndPoint();
    public sealed virtual bool Equals(IConnectionEndPoint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Cassandra.Connections.SniEndPointResolver : object {
    private static Logger Logger;
    private IDnsResolver _dns;
    private IRandom _random;
    private SingleThreadedResolver _proxyDnsResolver;
    private ISniOptionsProvider _sniOptionsProvider;
    private IReadOnlyList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _resolvedProxyEndPoints;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _index;
    private IPEndPoint modreq(System.Runtime.CompilerServices.IsVolatile) _endPoint;
    internal SniEndPointResolver(ISniOptionsProvider sniOptionsProvider, IDnsResolver dns, IRandom rand);
    public SniEndPointResolver(ISniOptionsProvider sniOptionsProvider, IDnsResolver dns);
    private static SniEndPointResolver();
    [AsyncStateMachineAttribute("Cassandra.Connections.SniEndPointResolver/<GetConnectionEndPointAsync>d__10")]
public sealed virtual Task`1<IConnectionEndPoint> GetConnectionEndPointAsync(Host host, bool refreshCache);
    [AsyncStateMachineAttribute("Cassandra.Connections.SniEndPointResolver/<RefreshAsync>d__11")]
public Task`1<SniOptions> RefreshAsync(bool refreshSniOptions, bool refreshCache);
    [AsyncStateMachineAttribute("Cassandra.Connections.SniEndPointResolver/<GetNextEndPointAsync>d__12")]
public sealed virtual Task`1<IPEndPoint> GetNextEndPointAsync(bool refreshCache);
    public sealed virtual Task`1<SniOptions> GetSniOptionsAsync(bool refreshSniOptions);
    public sealed virtual string GetStaticIdentifier();
    [AsyncStateMachineAttribute("Cassandra.Connections.SniEndPointResolver/<UnsafeRefreshProxyEndpointsAsync>d__15")]
private Task UnsafeRefreshProxyEndpointsAsync(SniOptions sniOptions);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SniEndPointResolver other);
    public virtual int GetHashCode();
    public static bool op_Equality(SniEndPointResolver left, SniEndPointResolver right);
    public static bool op_Inequality(SniEndPointResolver left, SniEndPointResolver right);
}
internal class Cassandra.Connections.TcpSocket : object {
    public static Logger Logger;
    private Socket _socket;
    private SocketAsyncEventArgs _receiveSocketEvent;
    private SocketAsyncEventArgs _sendSocketEvent;
    private Byte[] _receiveBuffer;
    private Action _writeFlushCallback;
    private Stream modreq(System.Runtime.CompilerServices.IsVolatile) _socketStream;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isClosing;
    [CompilerGeneratedAttribute]
private IConnectionEndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private SSLOptions <SSLOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Byte[], int> Read;
    [CompilerGeneratedAttribute]
private Action WriteCompleted;
    [CompilerGeneratedAttribute]
private Action Closing;
    [CompilerGeneratedAttribute]
private Action`2<Exception, Nullable`1<SocketError>> Error;
    public IConnectionEndPoint EndPoint { get; protected set; }
    public SocketOptions Options { get; protected set; }
    public SSLOptions SSLOptions { get; public set; }
    public TcpSocket(IConnectionEndPoint endPoint, SocketOptions options, SSLOptions sslOptions);
    private static TcpSocket();
    [CompilerGeneratedAttribute]
public sealed virtual IConnectionEndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
protected void set_EndPoint(IConnectionEndPoint value);
    [CompilerGeneratedAttribute]
public sealed virtual SocketOptions get_Options();
    [CompilerGeneratedAttribute]
protected void set_Options(SocketOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual SSLOptions get_SSLOptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SSLOptions(SSLOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Read(Action`2<Byte[], int> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Read(Action`2<Byte[], int> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_WriteCompleted(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_WriteCompleted(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closing(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closing(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Error(Action`2<Exception, Nullable`1<SocketError>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Error(Action`2<Exception, Nullable`1<SocketError>> value);
    public sealed virtual IPEndPoint GetLocalIpEndPoint();
    [AsyncStateMachineAttribute("Cassandra.Connections.TcpSocket/<Connect>d__34")]
public sealed virtual Task`1<bool> Connect();
    private void OnConnectComplete(TaskCompletionSource`1<bool> tcs, SocketAsyncEventArgs e);
    [AsyncStateMachineAttribute("Cassandra.Connections.TcpSocket/<ConnectSsl>d__36")]
private Task`1<bool> ConnectSsl();
    protected virtual void ReceiveAsync();
    protected virtual void OnError(Exception ex, Nullable`1<SocketError> socketError);
    protected void OnReceiveCompleted(object sender, SocketAsyncEventArgs e);
    protected void OnReceiveStreamCallback(Task`1<int> readTask);
    private void HandleStreamException(Exception ex);
    protected void OnSendCompleted(object sender, SocketAsyncEventArgs e);
    protected void OnSendStreamCallback(Task writeTask);
    protected void OnClosing();
    private void OnWriteFlushed();
    public sealed virtual void Write(RecyclableMemoryStream stream, Action onBufferFlush);
    public sealed virtual void Dispose();
}
public enum Cassandra.ConsistencyLevel : Enum {
    public int value__;
    public static ConsistencyLevel Any;
    public static ConsistencyLevel One;
    public static ConsistencyLevel Two;
    public static ConsistencyLevel Three;
    public static ConsistencyLevel Quorum;
    public static ConsistencyLevel All;
    public static ConsistencyLevel LocalQuorum;
    public static ConsistencyLevel EachQuorum;
    public static ConsistencyLevel Serial;
    public static ConsistencyLevel LocalSerial;
    public static ConsistencyLevel LocalOne;
}
public class Cassandra.ConstantReconnectionPolicy : object {
    private long _delayMs;
    public long ConstantDelayMs { get; }
    public ConstantReconnectionPolicy(long constantDelayMs);
    public long get_ConstantDelayMs();
    public sealed virtual IReconnectionSchedule NewSchedule();
}
public class Cassandra.ConstantSpeculativeExecutionPolicy : object {
    [CompilerGeneratedAttribute]
private long <Delay>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSpeculativeExecutions>k__BackingField;
    public long Delay { get; }
    public int MaxSpeculativeExecutions { get; }
    public ConstantSpeculativeExecutionPolicy(long delay, int maxSpeculativeExecutions);
    [CompilerGeneratedAttribute]
public long get_Delay();
    [CompilerGeneratedAttribute]
public int get_MaxSpeculativeExecutions();
    public sealed virtual void Dispose();
    public sealed virtual void Initialize(ICluster cluster);
    public sealed virtual ISpeculativeExecutionPlan NewPlan(string keyspace, IStatement statement);
}
public class Cassandra.CqlColumn : ColumnDesc {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public int Index { get; public set; }
    public Type Type { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
}
internal static class Cassandra.CqlQueryTools : object {
    public static string SelectSchemaPeers;
    public static string SelectSchemaLocal;
    private static Regex IdentifierRx;
    private static String[] HexStringTable;
    private static CqlQueryTools();
    public static string CqlIdentifier(string id);
    public static string QuoteIdentifier(string id);
    public static string GetCreateKeyspaceCql(string keyspace, Dictionary`2<string, string> replication, bool durableWrites, bool ifNotExists);
    public static string GetUseKeyspaceCql(string keyspace);
    public static string GetDropKeyspaceCql(string keyspace, bool ifExists);
    public static string ToHex(Byte[] value);
}
[DefaultMemberAttribute("Item")]
public class Cassandra.CqlVector`1 : object {
    private static T[] Empty;
    private T[] _array;
    public T Item { get; public set; }
    public int Count { get; }
    private object Cassandra.IInternalCqlVector.Item { get; private set; }
    public CqlVector`1(T[] elements);
    private static CqlVector`1();
    public static CqlVector`1<T> New(int dimensions);
    public static CqlVector`1<T> New(T[] arr);
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public T[] AsArray();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CqlVector`1<T> left, CqlVector`1<T> right);
    public static bool op_Inequality(CqlVector`1<T> left, CqlVector`1<T> right);
    public static T[] op_Explicit(CqlVector`1<T> v);
    public static CqlVector`1<T> op_Implicit(T[] a);
    private static bool Equals(CqlVector`1<T> one, CqlVector`1<T> other);
    private sealed virtual override object Cassandra.IInternalCqlVector.get_Item(int index);
    private sealed virtual override void Cassandra.IInternalCqlVector.set_Item(int index, object value);
    private sealed virtual override Type Cassandra.IInternalCqlVector.GetSubType();
    private sealed virtual override void Cassandra.IInternalCqlVector.SetArray(object array);
    private sealed virtual override Array Cassandra.IInternalCqlVector.GetArray();
}
public class Cassandra.CustomColumnInfo : object {
    [CompilerGeneratedAttribute]
private string <CustomTypeName>k__BackingField;
    public string CustomTypeName { get; public set; }
    public CustomColumnInfo(string name);
    [CompilerGeneratedAttribute]
public string get_CustomTypeName();
    [CompilerGeneratedAttribute]
public void set_CustomTypeName(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Cassandra.Data.CqlBatchTransaction : DbTransaction {
    private List`1<CqlCommand> commands;
    internal CqlConnection CqlConnection;
    protected DbConnection DbConnection { get; }
    public IsolationLevel IsolationLevel { get; }
    public CqlBatchTransaction(CqlConnection cqlConnection);
    protected virtual DbConnection get_DbConnection();
    public virtual IsolationLevel get_IsolationLevel();
    public void Append(CqlCommand cmd);
    public virtual void Commit();
    public virtual void Rollback();
}
public class Cassandra.Data.CqlCommand : DbCommand {
    internal CqlConnection CqlConnection;
    internal CqlBatchTransaction CqlTransaction;
    private string _commandText;
    private ConsistencyLevel _consistencyLevel;
    private static Regex RegexParseParameterName;
    private PreparedStatement _preparedStatement;
    private CqlParameterCollection _parameters;
    public string CommandText { get; public set; }
    public ConsistencyLevel ConsistencyLevel { get; public set; }
    public bool IsPrepared { get; }
    public CqlParameterCollection Parameters { get; }
    public int CommandTimeout { get; public set; }
    public CommandType CommandType { get; public set; }
    protected DbConnection DbConnection { get; protected set; }
    protected DbParameterCollection DbParameterCollection { get; }
    protected DbTransaction DbTransaction { get; protected set; }
    public bool DesignTimeVisible { get; public set; }
    public UpdateRowSource UpdatedRowSource { get; public set; }
    private static CqlCommand();
    public virtual void Cancel();
    public virtual string get_CommandText();
    public virtual void set_CommandText(string value);
    public ConsistencyLevel get_ConsistencyLevel();
    public void set_ConsistencyLevel(ConsistencyLevel value);
    public bool get_IsPrepared();
    public CqlParameterCollection get_Parameters();
    public virtual int get_CommandTimeout();
    public virtual void set_CommandTimeout(int value);
    public virtual CommandType get_CommandType();
    public virtual void set_CommandType(CommandType value);
    protected virtual DbParameter CreateDbParameter();
    protected virtual DbConnection get_DbConnection();
    protected virtual void set_DbConnection(DbConnection value);
    protected virtual DbParameterCollection get_DbParameterCollection();
    protected virtual DbTransaction get_DbTransaction();
    protected virtual void set_DbTransaction(DbTransaction value);
    public virtual bool get_DesignTimeVisible();
    public virtual void set_DesignTimeVisible(bool value);
    protected virtual DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
    public virtual int ExecuteNonQuery();
    public virtual object ExecuteScalar();
    public virtual void Prepare();
    private Object[] GetParameterValues();
    public virtual UpdateRowSource get_UpdatedRowSource();
    public virtual void set_UpdatedRowSource(UpdateRowSource value);
}
internal class Cassandra.Data.CqlCommandBuilder : DbCommandBuilder {
    protected virtual void ApplyParameterInfo(DbParameter parameter, DataRow row, StatementType statementType, bool whereClause);
    protected virtual string GetParameterName(string parameterName);
    protected virtual string GetParameterName(int parameterOrdinal);
    protected virtual string GetParameterPlaceholder(int parameterOrdinal);
    protected virtual void SetRowUpdatingHandler(DbDataAdapter adapter);
}
public class Cassandra.Data.CqlConnection : DbConnection {
    private CassandraConnectionStringBuilder _connectionStringBuilder;
    private static ConcurrentDictionary`2<string, Cluster> _clusters;
    private Cluster _managedCluster;
    private ConnectionState _connectionState;
    private CqlBatchTransaction _currentTransaction;
    protected internal ISession ManagedConnection;
    public string ConnectionString { get; public set; }
    public string DataSource { get; }
    public string Database { get; }
    protected DbProviderFactory DbProviderFactory { get; }
    public string ServerVersion { get; }
    public ConnectionState State { get; }
    public CqlConnection(string connectionString);
    private static CqlConnection();
    internal void ClearDbTransaction();
    protected virtual DbTransaction BeginDbTransaction(IsolationLevel isolationLevel);
    public virtual void ChangeDatabase(string databaseName);
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual string get_ConnectionString();
    public virtual void set_ConnectionString(string value);
    protected virtual DbCommand CreateDbCommand();
    public virtual string get_DataSource();
    public virtual string get_Database();
    protected virtual DbProviderFactory get_DbProviderFactory();
    public virtual void Open();
    protected virtual void OnBuildingCluster(Builder builder);
    protected virtual Cluster CreateCluster(CassandraConnectionStringBuilder connectionStringBuilder);
    protected virtual ISession CreatedSession(string keyspace);
    protected internal virtual PreparedStatement CreatePreparedStatement(string cqlQuery);
    public virtual string get_ServerVersion();
    public virtual ConnectionState get_State();
    public sealed virtual object Clone();
}
public class Cassandra.Data.CqlDataAdapter : DbDataAdapter {
}
public class Cassandra.Data.CqlParameter : DbParameter {
    private string _name;
    private bool _isNullable;
    private object _value;
    [CompilerGeneratedAttribute]
private DbType <DbType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private DataRowVersion <SourceVersion>k__BackingField;
    public DbType DbType { get; public set; }
    public ParameterDirection Direction { get; public set; }
    public bool IsNullable { get; public set; }
    public string ParameterName { get; public set; }
    public string SourceColumn { get; public set; }
    public DataRowVersion SourceVersion { get; public set; }
    public object Value { get; public set; }
    public int Size { get; public set; }
    public bool SourceColumnNullMapping { get; public set; }
    public CqlParameter(string name);
    public CqlParameter(string name, object value);
    [CompilerGeneratedAttribute]
public virtual DbType get_DbType();
    [CompilerGeneratedAttribute]
public virtual void set_DbType(DbType value);
    public virtual ParameterDirection get_Direction();
    public virtual void set_Direction(ParameterDirection value);
    public virtual bool get_IsNullable();
    public virtual void set_IsNullable(bool value);
    public virtual string get_ParameterName();
    public virtual void set_ParameterName(string value);
    [CompilerGeneratedAttribute]
public virtual string get_SourceColumn();
    [CompilerGeneratedAttribute]
public virtual void set_SourceColumn(string value);
    [CompilerGeneratedAttribute]
public virtual DataRowVersion get_SourceVersion();
    [CompilerGeneratedAttribute]
public virtual void set_SourceVersion(DataRowVersion value);
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual int get_Size();
    public virtual void set_Size(int value);
    public virtual bool get_SourceColumnNullMapping();
    public virtual void set_SourceColumnNullMapping(bool value);
    public virtual void ResetDbType();
    private void SetParameterName(string name);
}
public class Cassandra.Data.CqlParameterCollection : DbParameterCollection {
    private List`1<CqlParameter> _parameters;
    private object _syncLock;
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public virtual int get_Count();
    public virtual object get_SyncRoot();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual int Add(object value);
    public int Add(CqlParameter parameter);
    public CqlParameter Add(string name, object value);
    public virtual bool Contains(object value);
    public virtual void Clear();
    public virtual int IndexOf(object value);
    public virtual void Insert(int index, object value);
    public virtual void Remove(object value);
    public virtual void RemoveAt(int index);
    public virtual void RemoveAt(string parameterName);
    protected virtual void SetParameter(int index, DbParameter value);
    protected virtual void SetParameter(string parameterName, DbParameter value);
    public virtual int IndexOf(string parameterName);
    public virtual IEnumerator GetEnumerator();
    protected virtual DbParameter GetParameter(int index);
    protected virtual DbParameter GetParameter(string parameterName);
    public virtual bool Contains(string value);
    public virtual void CopyTo(Array array, int index);
    public virtual void AddRange(Array values);
    private void SetParameter(string parameterName, CqlParameter value);
    private void SetParameter(int index, CqlParameter value);
    private int GetIndex(string parameterName);
    private CqlParameter GetCqlParameter(string parameterName);
}
public class Cassandra.Data.CqlProviderFactory : DbProviderFactory {
    public static CqlProviderFactory Instance;
    public bool CanCreateDataSourceEnumerator { get; }
    private static CqlProviderFactory();
    public virtual CqlProviderFactory GetInstance();
    public virtual DbCommand CreateCommand();
    public virtual DbConnection CreateConnection();
    public virtual DbConnectionStringBuilder CreateConnectionStringBuilder();
    public virtual DbParameter CreateParameter();
    public virtual bool get_CanCreateDataSourceEnumerator();
    public virtual DbCommandBuilder CreateCommandBuilder();
    public virtual DbDataAdapter CreateDataAdapter();
    public virtual DbDataSourceEnumerator CreateDataSourceEnumerator();
    public virtual CodeAccessPermission CreatePermission(PermissionState state);
}
[DefaultMemberAttribute("Item")]
public class Cassandra.Data.CqlReader : DbDataReader {
    private Dictionary`2<string, int> colidx;
    private IEnumerator`1<Row> enumerRows;
    private RowSet popul;
    private IEnumerable`1<Row> enumRows;
    public int Depth { get; }
    public int FieldCount { get; }
    public bool HasRows { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public object Item { get; }
    public object Item { get; }
    internal CqlReader(RowSet rows);
    public virtual int get_Depth();
    public virtual int get_FieldCount();
    public virtual bool get_HasRows();
    public virtual bool get_IsClosed();
    public virtual int get_RecordsAffected();
    public virtual object get_Item(string name);
    public virtual object get_Item(int ordinal);
    public virtual void Close();
    public virtual DataTable GetSchemaTable();
    public virtual bool GetBoolean(int ordinal);
    public virtual byte GetByte(int ordinal);
    public virtual long GetBytes(int ordinal, long dataOffset, Byte[] buffer, int bufferOffset, int length);
    public virtual char GetChar(int ordinal);
    public virtual long GetChars(int ordinal, long dataOffset, Char[] buffer, int bufferOffset, int length);
    public virtual string GetDataTypeName(int ordinal);
    public virtual DateTime GetDateTime(int ordinal);
    public virtual decimal GetDecimal(int ordinal);
    public virtual double GetDouble(int ordinal);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetFieldType(int ordinal);
    public virtual float GetFloat(int ordinal);
    public virtual Guid GetGuid(int ordinal);
    public virtual short GetInt16(int ordinal);
    public virtual int GetInt32(int ordinal);
    public virtual long GetInt64(int ordinal);
    public virtual string GetName(int ordinal);
    public virtual int GetOrdinal(string name);
    public virtual string GetString(int ordinal);
    public virtual object GetValue(int ordinal);
    public virtual int GetValues(Object[] values);
    public virtual bool IsDBNull(int ordinal);
    public virtual bool NextResult();
    public virtual bool Read();
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead.")]
[AttributeUsageAttribute("12")]
public class Cassandra.Data.Linq.AllowFilteringAttribute : Attribute {
}
public abstract class Cassandra.Data.Linq.Batch : Statement {
    private IMetricsManager _metricsManager;
    protected ISession _session;
    protected BatchType _batchType;
    protected Nullable`1<DateTimeOffset> _timestamp;
    [CompilerGeneratedAttribute]
private int <QueryAbortTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryTrace <QueryTrace>k__BackingField;
    protected int QueryAbortTimeout { get; private set; }
    public bool IsEmpty { get; }
    public RoutingKey RoutingKey { get; }
    public QueryTrace QueryTrace { get; private set; }
    public string Keyspace { get; }
    internal Batch(ISession session, BatchType batchType);
    [CompilerGeneratedAttribute]
protected int get_QueryAbortTimeout();
    [CompilerGeneratedAttribute]
private void set_QueryAbortTimeout(int value);
    public abstract virtual bool get_IsEmpty();
    public virtual RoutingKey get_RoutingKey();
    [CompilerGeneratedAttribute]
public QueryTrace get_QueryTrace();
    [CompilerGeneratedAttribute]
private void set_QueryTrace(QueryTrace value);
    public virtual string get_Keyspace();
    public abstract virtual void Append(CqlCommand cqlCommand);
    public Batch SetConsistencyLevel(Nullable`1<ConsistencyLevel> consistencyLevel);
    public Batch SetTimestamp(DateTimeOffset timestamp);
    public Batch Append(IEnumerable`1<CqlCommand> cqlCommands);
    public void Execute();
    public void Execute(string executionProfile);
    protected abstract virtual Task`1<RowSet> InternalExecuteAsync();
    protected abstract virtual Task`1<RowSet> InternalExecuteAsync(string executionProfile);
    public Task ExecuteAsync();
    public Task ExecuteAsync(string executionProfile);
    public IAsyncResult BeginExecute(AsyncCallback callback, object state);
    public void EndExecute(IAsyncResult ar);
    protected string BatchTypeString();
    internal T WaitToCompleteWithMetrics(Task`1<T> task, int timeout);
}
internal class Cassandra.Data.Linq.BatchV1 : Batch {
    private StringBuilder _batchScript;
    public bool IsEmpty { get; }
    internal BatchV1(ISession session, BatchType batchType);
    public virtual bool get_IsEmpty();
    public virtual void Append(CqlCommand cqlCommand);
    protected virtual Task`1<RowSet> InternalExecuteAsync();
    protected virtual Task`1<RowSet> InternalExecuteAsync(string executionProfile);
    private string GetCql();
    public virtual string ToString();
}
internal class Cassandra.Data.Linq.BatchV2 : Batch {
    private BatchStatement _batchScript;
    public bool IsEmpty { get; }
    internal BatchV2(ISession session, BatchType batchType);
    public virtual bool get_IsEmpty();
    public virtual void Append(CqlCommand cqlCommand);
    protected virtual Task`1<RowSet> InternalExecuteAsync();
    protected virtual Task`1<RowSet> InternalExecuteAsync(string executionProfile);
    public virtual string ToString();
}
internal class Cassandra.Data.Linq.ClientProjectionCqlQuery`2 : CqlQuery`1<TResult> {
    private Expression`1<Func`2<TSource, TResult>> _projectionExpression;
    private bool _canCompile;
    private CqlQuery`1<TSource> _source;
    internal ClientProjectionCqlQuery`2(Expression expression, CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, TResult>> projectionExpression, bool canCompile);
    internal virtual IEnumerable`1<TResult> AdaptResult(string cql, RowSet rs);
    [IteratorStateMachineAttribute("Cassandra.Data.Linq.ClientProjectionCqlQuery`2/<YieldFromFirst>d__5")]
private static IEnumerable`1<TResult> YieldFromFirst(IEnumerator`1<TResult> enumerator, bool hasFirstItem);
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead.")]
[AttributeUsageAttribute("384")]
public class Cassandra.Data.Linq.ClusteringKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SortOrder <ClusteringSortOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [ObsoleteAttribute("Use ClusteringSortOrder instead")]
public string ClusteringOrder { get; public set; }
    public SortOrder ClusteringSortOrder { get; public set; }
    public int Index { get; public set; }
    public string Name { get; public set; }
    public ClusteringKeyAttribute(int index);
    public ClusteringKeyAttribute(int index, SortOrder order);
    [ObsoleteAttribute("Use SortOrder instead")]
public ClusteringKeyAttribute(int index, string order);
    public string get_ClusteringOrder();
    public void set_ClusteringOrder(string value);
    private void SetOrder(string value);
    [CompilerGeneratedAttribute]
public SortOrder get_ClusteringSortOrder();
    [CompilerGeneratedAttribute]
public void set_ClusteringSortOrder(SortOrder value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead.")]
[AttributeUsageAttribute("384")]
public class Cassandra.Data.Linq.ColumnAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public ColumnAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead. TableAttributes contains most of the properties at table level.")]
[AttributeUsageAttribute("12")]
public class Cassandra.Data.Linq.CompactStorageAttribute : Attribute {
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead.")]
[AttributeUsageAttribute("384")]
public class Cassandra.Data.Linq.CounterAttribute : Attribute {
}
public class Cassandra.Data.Linq.CqlArgumentException : ArgumentException {
    internal CqlArgumentException(string message);
}
public abstract class Cassandra.Data.Linq.CqlCommand : SimpleStatement {
    private Expression _expression;
    private StatementFactory _statementFactory;
    protected Nullable`1<DateTimeOffset> _timestamp;
    protected Nullable`1<int> _ttl;
    private QueryTrace _queryTrace;
    private IMetricsManager _metricsManager;
    [CompilerGeneratedAttribute]
private int <QueryAbortTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private PocoData <PocoData>k__BackingField;
    [CompilerGeneratedAttribute]
private ITable <Table>k__BackingField;
    protected int QueryAbortTimeout { get; private set; }
    internal PocoData PocoData { get; }
    internal ITable Table { get; }
    internal IInternalStatement InternalRef { get; }
    public string QueryString { get; }
    public Object[] QueryValues { get; }
    private StatementFactory Cassandra.Data.Linq.IInternalStatement.StatementFactory { get; }
    public Expression Expression { get; }
    public QueryTrace QueryTrace { get; protected set; }
    internal CqlCommand(Expression expression, ITable table, StatementFactory stmtFactory, PocoData pocoData);
    [CompilerGeneratedAttribute]
protected int get_QueryAbortTimeout();
    [CompilerGeneratedAttribute]
private void set_QueryAbortTimeout(int value);
    [CompilerGeneratedAttribute]
internal PocoData get_PocoData();
    [CompilerGeneratedAttribute]
internal ITable get_Table();
    internal IInternalStatement get_InternalRef();
    public virtual string get_QueryString();
    public virtual Object[] get_QueryValues();
    private sealed virtual override StatementFactory Cassandra.Data.Linq.IInternalStatement.get_StatementFactory();
    public Expression get_Expression();
    public QueryTrace get_QueryTrace();
    protected void set_QueryTrace(QueryTrace value);
    protected internal abstract virtual string GetCql(Object[]& values);
    public void Execute();
    public RowSet Execute(string executionProfile);
    public void SetQueryTrace(QueryTrace trace);
    public CqlCommand SetConsistencyLevel(Nullable`1<ConsistencyLevel> consistencyLevel);
    public CqlCommand SetSerialConsistencyLevel(ConsistencyLevel consistencyLevel);
    public CqlCommand SetTTL(int seconds);
    public CqlCommand SetTimestamp(DateTimeOffset timestamp);
    protected void InitializeStatement();
    public sealed virtual ITable GetTable();
    public Task`1<RowSet> ExecuteAsync();
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.CqlCommand/<ExecuteAsync>d__41")]
public Task`1<RowSet> ExecuteAsync(string executionProfile);
    public virtual IAsyncResult BeginExecute(AsyncCallback callback, object state);
    public virtual void EndExecute(IAsyncResult ar);
    internal T WaitToCompleteWithMetrics(Task`1<T> task, int timeout);
}
public class Cassandra.Data.Linq.CqlConditionalCommand`1 : CqlCommand {
    private MapperFactory _mapperFactory;
    private CqlCommand _origin;
    internal CqlConditionalCommand`1(CqlCommand origin, MapperFactory mapperFactory);
    protected internal virtual string GetCql(Object[]& values);
    public Task`1<AppliedInfo`1<TEntity>> ExecuteAsync();
    public AppliedInfo`1<TEntity> Execute();
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.CqlConditionalCommand`1/<ExecuteAsync>d__6")]
public Task`1<AppliedInfo`1<TEntity>> ExecuteAsync(string executionProfile);
    public AppliedInfo`1<TEntity> Execute(string executionProfile);
    public CqlConditionalCommand`1<TEntity> SetConsistencyLevel(Nullable`1<ConsistencyLevel> consistencyLevel);
    public CqlConditionalCommand`1<TEntity> SetSerialConsistencyLevel(ConsistencyLevel consistencyLevel);
    public CqlConditionalCommand`1<TEntity> SetTTL(int seconds);
    public CqlConditionalCommand`1<TEntity> SetTimestamp(DateTimeOffset timestamp);
    public virtual string ToString();
}
public class Cassandra.Data.Linq.CqlDelete : CqlCommand {
    private bool _ifExists;
    internal CqlDelete(Expression expression, ITable table, StatementFactory stmtFactory, PocoData pocoData);
    public CqlDelete IfExists();
    protected internal virtual string GetCql(Object[]& values);
    public virtual string ToString();
}
internal class Cassandra.Data.Linq.CqlExpressionVisitor : ExpressionVisitor {
    private static int DefaultQueryStringCapacity;
    private static int DefaultClauseParameterCapacity;
    private static string Utf8MaxValue;
    private static HashSet`1<ExpressionType> CqlUnsupTags;
    private VisitingParam`1<string> _currentBindingName;
    private IList`1<IConditionItem> _conditions;
    private VisitingParam`1<ParsePhase> _parsePhase;
    private PocoData _pocoData;
    private bool _allowFiltering;
    private int _limit;
    private static ICqlIdentifierHelper CqlIdentifierHelper;
    private IList`1<Tuple`3<PocoColumn, object, ExpressionType>> _projections;
    private IList`1<Tuple`2<string, bool>> _orderBy;
    private IList`1<string> _groupBy;
    private IList`1<string> _selectFields;
    private IList`1<IConditionItem> _where;
    private IList`1<IConditionItem> _ifClause;
    private string _tableName;
    private string _keyspaceName;
    private bool _isSelectQuery;
    public CqlExpressionVisitor(PocoData pocoData, string tableName, string keyspaceName);
    private static CqlExpressionVisitor();
    public string GetSelect(Expression expression, Object[]& values);
    private void GenerateConditions(IList`1<IConditionItem> conditions, string clause, StringBuilder query, IList`1<object> parameters, Expression expression);
    public string GetDelete(Expression expression, Object[]& values, Nullable`1<DateTimeOffset> timestamp, bool ifExists);
    public string GetUpdate(Expression expression, Object[]& values, Nullable`1<int> ttl, Nullable`1<DateTimeOffset> timestamp, MapperFactory mapperFactory);
    public string GetCount(Expression expression, Object[]& values);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitNew(NewExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private Expression FillSelectFunction(ParsePhase phase, MethodCallExpression node);
    private Expression AddProjection(Expression node, PocoColumn column);
    private Expression EvaluateConditionFunction(MethodCallExpression node);
    private void EvaluateContainsMethod(MethodCallExpression node);
    private void EvaluateCompositeColumn(Expression expression);
    private bool EvaluateOperatorMethod(MethodCallExpression node);
    private static Expression DropNullableConversion(Expression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    private void FillBooleanCondition(MemberExpression node, IConditionItem condition, Nullable`1<bool> value);
    private bool IsBoolMember(Expression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    private Expression FillCondition(MemberExpression node);
    private Expression FillSelectProjection(MemberExpression node);
    private Expression FillUpdateProjection(MemberExpression node);
    private Expression FillOrderBy(MemberExpression node);
    private Expression FillGroupBy(MemberExpression node);
    private static object GetClosureValue(MemberExpression node);
    private static object GetFieldValue(MemberExpression node);
    private static object GetPropertyValue(MemberExpression node);
    [CompilerGeneratedAttribute]
private string <GetSelect>b__21_0(PocoColumn c);
    [CompilerGeneratedAttribute]
private string <GetSelect>b__21_1(string c);
    [CompilerGeneratedAttribute]
private string <GetSelect>b__21_2(Tuple`2<string, bool> item);
}
public class Cassandra.Data.Linq.CqlFunction : object {
    [CompilerGeneratedAttribute]
private Object[] <Values>k__BackingField;
    internal Object[] Values { get; private set; }
    [CompilerGeneratedAttribute]
internal Object[] get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(Object[] value);
    public static CqlFunction MaxTimeUuid(DateTimeOffset value);
    public static CqlFunction MinTimeUuid(DateTimeOffset value);
    public static CqlFunction Token(object key);
    public static CqlFunction Token(object key1, object key2);
    public static CqlFunction Token(object key1, object key2, object key3);
    public static CqlFunction Token(object key1, object key2, object key3, object key4);
    public static Nullable`1<long> WriteTime(object key);
    public static bool op_Equality(CqlFunction a, object b);
    public static bool op_Equality(object b, CqlFunction a);
    public static bool op_Equality(CqlFunction b, CqlFunction a);
    public static bool op_Inequality(CqlFunction a, object b);
    public static bool op_Inequality(object b, CqlFunction a);
    public static bool op_Inequality(CqlFunction b, CqlFunction a);
    public static bool op_LessThanOrEqual(CqlFunction a, object b);
    public static bool op_LessThanOrEqual(object b, CqlFunction a);
    public static bool op_LessThanOrEqual(CqlFunction b, CqlFunction a);
    public static bool op_GreaterThanOrEqual(CqlFunction a, object b);
    public static bool op_GreaterThanOrEqual(object b, CqlFunction a);
    public static bool op_GreaterThanOrEqual(CqlFunction b, CqlFunction a);
    public static bool op_LessThan(CqlFunction a, object b);
    public static bool op_LessThan(object a, CqlFunction b);
    public static bool op_LessThan(CqlFunction a, CqlFunction b);
    public static bool op_GreaterThan(CqlFunction a, object b);
    public static bool op_GreaterThan(object b, CqlFunction a);
    public static bool op_GreaterThan(CqlFunction a, CqlFunction b);
    public static bool op_Equality(CqlFunction a, Guid b);
    public static bool op_Equality(Guid b, CqlFunction a);
    public static bool op_Inequality(CqlFunction a, Guid b);
    public static bool op_Inequality(Guid b, CqlFunction a);
    public static bool op_LessThanOrEqual(CqlFunction a, Guid b);
    public static bool op_GreaterThanOrEqual(CqlFunction a, Guid b);
    public static bool op_GreaterThan(CqlFunction a, Guid b);
    public static bool op_LessThan(CqlFunction a, Guid b);
    public static bool op_LessThanOrEqual(Guid b, CqlFunction a);
    public static bool op_GreaterThanOrEqual(Guid b, CqlFunction a);
    public static bool op_LessThan(Guid b, CqlFunction a);
    public static bool op_GreaterThan(Guid b, CqlFunction a);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static object ToObject(CqlFunction value);
    public static Guid op_Implicit(CqlFunction value);
}
public class Cassandra.Data.Linq.CqlInsert`1 : CqlCommand {
    private static ICqlIdentifierHelper CqlIdentifierHelper;
    private TEntity _entity;
    private bool _ifNotExists;
    private MapperFactory _mapperFactory;
    private bool _insertNulls;
    internal CqlInsert`1(TEntity entity, bool insertNulls, ITable table, StatementFactory stmtFactory, MapperFactory mapperFactory);
    private static CqlInsert`1();
    public CqlConditionalCommand`1<TEntity> IfNotExists();
    protected internal virtual string GetCql(Object[]& values);
    internal string GetCqlAndValues(Object[]& values);
    public virtual string ToString();
}
public class Cassandra.Data.Linq.CqlLinqNotSupportedException : NotSupportedException {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; private set; }
    internal CqlLinqNotSupportedException(Expression expression, ParsePhase parsePhase);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(Expression value);
}
internal class Cassandra.Data.Linq.CqlMthHelps : object {
    internal static MethodInfo SelectMi;
    internal static MethodInfo WhereMi;
    internal static MethodInfo GroupByMi;
    internal static MethodInfo UpdateIfMi;
    internal static MethodInfo UpdateIfExistsMi;
    internal static MethodInfo UpdateIfNotExistsMi;
    internal static MethodInfo DeleteIfMi;
    internal static MethodInfo FirstMi;
    internal static MethodInfo First_ForCQLTableMi;
    internal static MethodInfo FirstOrDefaultMi;
    internal static MethodInfo FirstOrDefault_ForCQLTableMi;
    internal static MethodInfo TakeMi;
    internal static MethodInfo AllowFilteringMi;
    internal static MethodInfo CountMi;
    internal static MethodInfo OrderByMi;
    internal static MethodInfo OrderByDescendingMi;
    internal static MethodInfo ThenByMi;
    internal static MethodInfo ThenByDescendingMi;
    private static CqlMthHelps();
    internal static object Select(object a, object b);
    internal static object Where(object a, object b);
    internal static object UpdateIf(object a, object b);
    internal static object UpdateIfExists(object a);
    internal static object UpdateIfNotExists(object a);
    internal static object DeleteIf(object a, object b);
    internal static object First(object a, int b);
    internal static object FirstOrDefault(object a, int b);
    internal static object Take(object a, int b);
    internal static object AllowFiltering(object a);
    internal static object Count(object a);
    internal static object OrderBy(object a, object b);
    internal static object GroupBy(object a, object b);
    internal static object OrderByDescending(object a, object b);
    internal static object ThenBy(object a, object b);
    internal static object ThenByDescending(object a, object b);
    public static object First(ITable a, int b, object c);
    public static object FirstOrDefault(ITable a, int b, object c);
}
[ExtensionAttribute]
public static class Cassandra.Data.Linq.CqlOperator : object {
    public static T Append(T value);
    public static T Prepend(T value);
    public static T SubstractAssign(T value);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> SubstractAssign(Dictionary`2<TKey, TValue> map, TKey[] value);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> SubstractAssign(IDictionary`2<TKey, TValue> map, TKey[] value);
    [ExtensionAttribute]
public static SortedDictionary`2<TKey, TValue> SubstractAssign(SortedDictionary`2<TKey, TValue> map, TKey[] value);
}
public class Cassandra.Data.Linq.CqlQuery`1 : CqlQueryBase`1<TEntity> {
    public IQueryProvider Provider { get; }
    internal CqlQuery`1(Expression expression, ITable table, MapperFactory mapperFactory, StatementFactory stmtFactory, PocoData pocoData);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IQueryProvider get_Provider();
    public sealed virtual IEnumerator`1<TEntity> GetEnumerator();
    public CqlQuery`1<TEntity> SetConsistencyLevel(Nullable`1<ConsistencyLevel> consistencyLevel);
    public CqlQuery`1<TEntity> SetSerialConsistencyLevel(ConsistencyLevel consistencyLevel);
    public CqlQuery`1<TEntity> SetPageSize(int pageSize);
    public CqlQuery`1<TEntity> SetPagingState(Byte[] pagingState);
    protected virtual string GetCql(Object[]& values);
    public Task`1<IPage`1<TEntity>> ExecutePagedAsync();
    public IPage`1<TEntity> ExecutePaged();
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.CqlQuery`1/<ExecutePagedAsync>d__13")]
public Task`1<IPage`1<TEntity>> ExecutePagedAsync(string executionProfile);
    public IPage`1<TEntity> ExecutePaged(string executionProfile);
    public virtual string ToString();
}
public abstract class Cassandra.Data.Linq.CqlQueryBase`1 : Statement {
    private QueryTrace _queryTrace;
    private IMetricsManager _metricsManager;
    [CompilerGeneratedAttribute]
private int <QueryAbortTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private ITable <Table>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private MapperFactory <MapperFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementFactory <StatementFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private PocoData <PocoData>k__BackingField;
    protected int QueryAbortTimeout { get; private set; }
    internal ITable Table { get; private set; }
    public Expression Expression { get; private set; }
    public Type ElementType { get; }
    public QueryTrace QueryTrace { get; protected set; }
    internal MapperFactory MapperFactory { get; internal set; }
    internal StatementFactory StatementFactory { get; internal set; }
    private StatementFactory Cassandra.Data.Linq.IInternalStatement.StatementFactory { get; }
    internal PocoData PocoData { get; internal set; }
    public RoutingKey RoutingKey { get; }
    public string Keyspace { get; }
    internal CqlQueryBase`1(Expression expression, ITable table, MapperFactory mapperFactory, StatementFactory stmtFactory, PocoData pocoData);
    [CompilerGeneratedAttribute]
protected int get_QueryAbortTimeout();
    [CompilerGeneratedAttribute]
private void set_QueryAbortTimeout(int value);
    [CompilerGeneratedAttribute]
internal ITable get_Table();
    [CompilerGeneratedAttribute]
private void set_Table(ITable value);
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(Expression value);
    public sealed virtual Type get_ElementType();
    public QueryTrace get_QueryTrace();
    protected void set_QueryTrace(QueryTrace value);
    [CompilerGeneratedAttribute]
internal MapperFactory get_MapperFactory();
    [CompilerGeneratedAttribute]
internal void set_MapperFactory(MapperFactory value);
    [CompilerGeneratedAttribute]
internal StatementFactory get_StatementFactory();
    [CompilerGeneratedAttribute]
internal void set_StatementFactory(StatementFactory value);
    private sealed virtual override StatementFactory Cassandra.Data.Linq.IInternalStatement.get_StatementFactory();
    [CompilerGeneratedAttribute]
internal PocoData get_PocoData();
    [CompilerGeneratedAttribute]
internal void set_PocoData(PocoData value);
    public virtual RoutingKey get_RoutingKey();
    public virtual string get_Keyspace();
    internal void InternalInitialize(Expression expression, ITable table, MapperFactory mapperFactory, StatementFactory stmtFactory, PocoData pocoData);
    public sealed virtual ITable GetTable();
    protected abstract virtual string GetCql(Object[]& values);
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.CqlQueryBase`1/<InternalExecuteWithProfileAsync>d__42")]
protected Task`1<RowSet> InternalExecuteWithProfileAsync(string executionProfile, string cqlQuery, Object[] values);
    internal virtual IEnumerable`1<TEntity> AdaptResult(string cql, RowSet rs);
    public Task`1<IEnumerable`1<TEntity>> ExecuteAsync();
    public IEnumerable`1<TEntity> Execute();
    public Task`1<IEnumerable`1<TEntity>> ExecuteAsync(string executionProfile);
    public IEnumerable`1<TEntity> Execute(string executionProfile);
    public IAsyncResult BeginExecute(AsyncCallback callback, object state);
    public IEnumerable`1<TEntity> EndExecute(IAsyncResult ar);
    private IEnumerable`1<TEntity> ExecuteCqlQuery(string executionProfile);
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.CqlQueryBase`1/<ExecuteCqlQueryAsync>d__51")]
private Task`1<IEnumerable`1<TEntity>> ExecuteCqlQueryAsync(string executionProfile);
    internal T WaitToCompleteWithMetrics(Task`1<T> task, int timeout);
}
[ExtensionAttribute]
public static class Cassandra.Data.Linq.CqlQueryExtensions : object {
    [ExtensionAttribute]
internal static void CopyQueryPropertiesTo(IStatement src, IStatement dst);
    [ExtensionAttribute]
public static CqlQuery`1<TResult> Select(CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static CqlQuery`1<TResult> Select(CqlQuery`1<IGrouping`2<TGroup, TSource>> source, Expression`1<Func`2<IGrouping`2<TGroup, TSource>, TResult>> selector);
    [ExtensionAttribute]
public static CqlQuery`1<TSource> Where(CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static CqlQuery`1<IGrouping`2<TKey, TSource>> GroupBy(CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, TKey>> predicate);
    [ExtensionAttribute]
public static CqlScalar`1<long> Count(CqlQuery`1<TSource> source);
    [ExtensionAttribute]
public static CqlQuerySingleElement`1<TSource> First(Table`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static CqlQuerySingleElement`1<TSource> FirstOrDefault(Table`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static CqlQuerySingleElement`1<TSource> First(CqlQuery`1<TSource> source);
    [ExtensionAttribute]
public static CqlQuerySingleElement`1<TSource> FirstOrDefault(CqlQuery`1<TSource> source);
    [ExtensionAttribute]
public static CqlDelete Delete(CqlQuery`1<TSource> source);
    [ExtensionAttribute]
public static CqlConditionalCommand`1<TSource> DeleteIf(CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static CqlUpdate Update(CqlQuery`1<TSource> source);
    [ExtensionAttribute]
public static CqlConditionalCommand`1<TSource> UpdateIf(CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static CqlConditionalCommand`1<TSource> UpdateIfExists(CqlQuery`1<TSource> source);
    [ExtensionAttribute]
public static CqlQuery`1<TSource> Take(CqlQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static CqlQuery`1<TSource> AllowFiltering(CqlQuery`1<TSource> source);
    [ExtensionAttribute]
public static CqlQuery`1<TSource> OrderBy(CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static CqlQuery`1<TSource> OrderByDescending(CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, TKey>> func);
    [ExtensionAttribute]
public static CqlQuery`1<TSource> ThenBy(CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, TKey>> func);
    [ExtensionAttribute]
public static CqlQuery`1<TSource> ThenByDescending(CqlQuery`1<TSource> source, Expression`1<Func`2<TSource, TKey>> func);
}
public class Cassandra.Data.Linq.CqlQuerySingleElement`1 : CqlQueryBase`1<TEntity> {
    internal CqlQuerySingleElement`1(Expression expression, CqlQuery`1<TEntity> source);
    protected virtual string GetCql(Object[]& values);
    public virtual string ToString();
    public CqlQuerySingleElement`1<TEntity> SetConsistencyLevel(Nullable`1<ConsistencyLevel> consistencyLevel);
    public CqlQuerySingleElement`1<TEntity> SetSerialConsistencyLevel(ConsistencyLevel consistencyLevel);
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.CqlQuerySingleElement`1/<ExecuteAsync>d__5")]
public Task`1<TEntity> ExecuteAsync();
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.CqlQuerySingleElement`1/<ExecuteAsync>d__6")]
public Task`1<TEntity> ExecuteAsync(string executionProfile);
    public IAsyncResult BeginExecute(AsyncCallback callback, object state);
    public TEntity EndExecute(IAsyncResult ar);
    public TEntity Execute();
    public TEntity Execute(string executionProfile);
}
[ExtensionAttribute]
internal static class Cassandra.Data.Linq.CqlQueryTools : object {
    private static Regex IdentifierRx;
    private static String[] HexStringTable;
    internal static DateTimeOffset UnixStart;
    private static Dictionary`2<Type, string> CQLTypeNames;
    private static CqlQueryTools();
    [ExtensionAttribute]
public static string CqlIdentifier(string id);
    [ExtensionAttribute]
public static string QuoteIdentifier(string id);
    [ExtensionAttribute]
public static string ToHex(Byte[] value);
    public static string Encode(string str);
    public static string Encode(bool val);
    public static string Encode(Byte[] val);
    public static string Encode(double val);
    public static string Encode(float val);
    public static string Encode(decimal val);
    public static string Encode(DateTimeOffset val);
    private static string GetCqlTypeFromType(Type tpy);
}
public class Cassandra.Data.Linq.CqlScalar`1 : CqlQueryBase`1<TEntity> {
    internal CqlScalar`1(Expression expression, ITable table, StatementFactory stmtFactory, PocoData pocoData);
    public TEntity Execute();
    public TEntity Execute(string executionProfile);
    public CqlScalar`1<TEntity> SetConsistencyLevel(Nullable`1<ConsistencyLevel> consistencyLevel);
    protected virtual string GetCql(Object[]& values);
    public virtual string ToString();
    public Task`1<TEntity> ExecuteAsync();
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.CqlScalar`1/<ExecuteAsync>d__7")]
public Task`1<TEntity> ExecuteAsync(string executionProfile);
    public IAsyncResult BeginExecute(AsyncCallback callback, object state);
    public TEntity EndExecute(IAsyncResult ar);
}
public class Cassandra.Data.Linq.CqlToken : object {
    public Object[] Values;
    private CqlToken(Object[] v);
    public static CqlToken Create(T v);
    public static CqlToken Create(T1 v1, T2 v2);
    public static CqlToken Create(T1 v1, T2 v2, T3 v3);
    public static CqlToken Create(T1 v1, T2 v2, T3 v3, T4 v4);
    public static CqlToken Create(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5);
    public static CqlToken Create(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6);
    public virtual int GetHashCode();
    public static bool op_Equality(CqlToken a, object b);
    public static bool op_Inequality(CqlToken a, object b);
    public static bool op_LessThanOrEqual(CqlToken a, object b);
    public static bool op_GreaterThanOrEqual(CqlToken a, object b);
    public static bool op_LessThan(CqlToken a, object b);
    public static bool op_GreaterThan(CqlToken a, object b);
    public static bool op_Inequality(CqlToken a, CqlToken b);
    public virtual bool Equals(object obj);
    public static bool op_Equality(CqlToken a, CqlToken b);
    public static bool op_LessThanOrEqual(CqlToken a, CqlToken b);
    public static bool op_GreaterThanOrEqual(CqlToken a, CqlToken b);
    public static bool op_LessThan(CqlToken a, CqlToken b);
    public static bool op_GreaterThan(CqlToken a, CqlToken b);
}
public class Cassandra.Data.Linq.CqlUpdate : CqlCommand {
    private MapperFactory _mapperFactory;
    internal CqlUpdate(Expression expression, ITable table, StatementFactory stmtFactory, PocoData pocoData, MapperFactory mapperFactory);
    protected internal virtual string GetCql(Object[]& values);
    public virtual string ToString();
}
internal class Cassandra.Data.Linq.ExpressionParsing.BinaryConditionItem : object {
    private static Dictionary`2<ExpressionType, string> CqlTags;
    private static Dictionary`2<ExpressionType, ExpressionType> InvertedOperations;
    private static ExpressionType InOperator;
    private static ICqlIdentifierHelper CqlIdentifierHelper;
    private List`1<PocoColumn> _columns;
    private List`1<object> _parameters;
    private Nullable`1<ExpressionType> _operator;
    private bool _allowMultipleColumns;
    private bool _allowMultipleParameters;
    private string _leftFunction;
    private string _rightFunction;
    private bool _isCompareTo;
    private bool _isYoda;
    public PocoColumn Column { get; }
    private static BinaryConditionItem();
    public sealed virtual PocoColumn get_Column();
    public void SetInClause(IEnumerable values);
    private string GetCqlOperator();
    public sealed virtual IConditionItem SetOperator(ExpressionType expressionType);
    public sealed virtual IConditionItem SetParameter(object value);
    public sealed virtual IConditionItem SetColumn(PocoColumn column);
    public sealed virtual IConditionItem AllowMultipleColumns();
    public sealed virtual IConditionItem AllowMultipleParameters();
    public sealed virtual IConditionItem SetFunctionName(string name);
    public sealed virtual void ToCql(PocoData pocoData, StringBuilder query, IList`1<object> parameters);
    private void ChangeParameterType();
    private void ToCqlColumns(PocoData pocoData, StringBuilder query, string functionName);
    private void ToCqlParameters(StringBuilder query, string functionName);
    public sealed virtual IConditionItem SetAsCompareTo();
    public static bool IsSupported(ExpressionType operatorType);
}
internal class Cassandra.Data.Linq.ExpressionParsing.ExistsConditionItem : object {
    private bool _positive;
    public PocoColumn Column { get; }
    public ExistsConditionItem(bool positive);
    public sealed virtual PocoColumn get_Column();
    public sealed virtual IConditionItem SetOperator(ExpressionType expressionType);
    public sealed virtual IConditionItem SetParameter(object value);
    public sealed virtual IConditionItem SetColumn(PocoColumn column);
    public sealed virtual IConditionItem AllowMultipleColumns();
    public sealed virtual IConditionItem AllowMultipleParameters();
    public sealed virtual IConditionItem SetFunctionName(string name);
    public sealed virtual IConditionItem SetAsCompareTo();
    public sealed virtual void ToCql(PocoData pocoData, StringBuilder query, IList`1<object> parameters);
}
internal interface Cassandra.Data.Linq.ExpressionParsing.IConditionItem {
    public PocoColumn Column { get; }
    public abstract virtual PocoColumn get_Column();
    public abstract virtual IConditionItem SetOperator(ExpressionType expressionType);
    public abstract virtual IConditionItem SetParameter(object value);
    public abstract virtual IConditionItem SetColumn(PocoColumn column);
    public abstract virtual IConditionItem AllowMultipleColumns();
    public abstract virtual IConditionItem AllowMultipleParameters();
    public abstract virtual IConditionItem SetFunctionName(string name);
    public abstract virtual IConditionItem SetAsCompareTo();
    public abstract virtual void ToCql(PocoData pocoData, StringBuilder query, IList`1<object> parameters);
}
internal interface Cassandra.Data.Linq.IClientProjectionCqlQuery {
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead.")]
[AttributeUsageAttribute("384")]
public class Cassandra.Data.Linq.IgnoreAttribute : Attribute {
}
internal interface Cassandra.Data.Linq.IInternalStatement {
    public StatementFactory StatementFactory { get; }
    public abstract virtual ITable GetTable();
    public abstract virtual StatementFactory get_StatementFactory();
}
public interface Cassandra.Data.Linq.ITable {
    public string Name { get; }
    public string KeyspaceName { get; }
    public abstract virtual void Create();
    public abstract virtual Type GetEntityType();
    public abstract virtual string get_Name();
    public abstract virtual string get_KeyspaceName();
    public abstract virtual ISession GetSession();
    public abstract virtual TableType GetTableType();
}
[ObsoleteAttribute]
internal class Cassandra.Data.Linq.LinqAttributeBasedColumnDefinition : object {
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberInfoType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ColumnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExplicitlyDefined>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SecondaryIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFrozen>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFrozenKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFrozenValue>k__BackingField;
    public MemberInfo MemberInfo { get; private set; }
    public Type MemberInfoType { get; private set; }
    public string ColumnName { get; private set; }
    public Type ColumnType { get; private set; }
    public bool Ignore { get; private set; }
    public bool IsExplicitlyDefined { get; private set; }
    public bool SecondaryIndex { get; private set; }
    public bool IsCounter { get; private set; }
    public bool IsStatic { get; private set; }
    public bool IsFrozen { get; private set; }
    public bool HasFrozenKey { get; private set; }
    public bool HasFrozenValue { get; private set; }
    public LinqAttributeBasedColumnDefinition(FieldInfo fieldInfo);
    public LinqAttributeBasedColumnDefinition(PropertyInfo propertyInfo);
    private LinqAttributeBasedColumnDefinition(MemberInfo memberInfo);
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_MemberInfo();
    [CompilerGeneratedAttribute]
private void set_MemberInfo(MemberInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MemberInfoType();
    [CompilerGeneratedAttribute]
private void set_MemberInfoType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    [CompilerGeneratedAttribute]
private void set_ColumnName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ColumnType();
    [CompilerGeneratedAttribute]
private void set_ColumnType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Ignore();
    [CompilerGeneratedAttribute]
private void set_Ignore(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsExplicitlyDefined();
    [CompilerGeneratedAttribute]
private void set_IsExplicitlyDefined(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SecondaryIndex();
    [CompilerGeneratedAttribute]
private void set_SecondaryIndex(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCounter();
    [CompilerGeneratedAttribute]
private void set_IsCounter(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStatic();
    [CompilerGeneratedAttribute]
private void set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFrozen();
    [CompilerGeneratedAttribute]
private void set_IsFrozen(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasFrozenKey();
    [CompilerGeneratedAttribute]
private void set_HasFrozenKey(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasFrozenValue();
    [CompilerGeneratedAttribute]
private void set_HasFrozenValue(bool value);
    private static bool HasAttribute(MemberInfo memberInfo, Type attributeType);
}
[ObsoleteAttribute]
internal class Cassandra.Data.Linq.LinqAttributeBasedTypeDefinition : object {
    private static BindingFlags PublicInstanceBindingFlags;
    [CompilerGeneratedAttribute]
private Type <PocoType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyspaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PartitionKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Tuple`2[] <ClusteringKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompactStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowFiltering>k__BackingField;
    public Type PocoType { get; }
    public string TableName { get; }
    public string KeyspaceName { get; }
    public bool ExplicitColumns { get; }
    public String[] PartitionKeys { get; }
    public Tuple`2[] ClusteringKeys { get; }
    public bool CaseSensitive { get; }
    public bool CompactStorage { get; }
    public bool AllowFiltering { get; }
    public LinqAttributeBasedTypeDefinition(Type type, string tableName, string keyspaceName);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_PocoType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TableName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyspaceName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ExplicitColumns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PartitionKeys();
    [CompilerGeneratedAttribute]
public sealed virtual Tuple`2[] get_ClusteringKeys();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CompactStorage();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowFiltering();
    internal static ITypeDefinition DetermineAttributes(Type type);
    public sealed virtual IColumnDefinition GetColumnDefinition(FieldInfo field);
    public sealed virtual IColumnDefinition GetColumnDefinition(PropertyInfo property);
}
internal enum Cassandra.Data.Linq.ParsePhase : Enum {
    public int value__;
    public static ParsePhase None;
    public static ParsePhase Select;
    public static ParsePhase Condition;
    public static ParsePhase SelectBinding;
    public static ParsePhase Take;
    public static ParsePhase OrderBy;
    public static ParsePhase OrderByDescending;
    public static ParsePhase GroupBy;
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead.")]
[AttributeUsageAttribute("384")]
public class Cassandra.Data.Linq.PartitionKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; public set; }
    public PartitionKeyAttribute(int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead.")]
[AttributeUsageAttribute("384")]
public class Cassandra.Data.Linq.SecondaryIndexAttribute : Attribute {
}
[ExtensionAttribute]
public static class Cassandra.Data.Linq.SessionExtensions : object {
    [ExtensionAttribute]
public static Table`1<TEntity> GetTable(ISession session, string tableName, string keyspaceName);
    [ExtensionAttribute]
public static Batch CreateBatch(ISession session);
    [ExtensionAttribute]
public static Batch CreateBatch(ISession session, BatchType batchType);
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead.")]
[AttributeUsageAttribute("384")]
public class Cassandra.Data.Linq.StaticColumnAttribute : Attribute {
}
public class Cassandra.Data.Linq.Table`1 : CqlQuery`1<TEntity> {
    private ISession _session;
    private string _name;
    private string _keyspaceName;
    public string Name { get; }
    public string KeyspaceName { get; }
    public Table`1(ISession session, MappingConfiguration config, string tableName, string keyspaceName);
    public Table`1(ISession session, MappingConfiguration config, string tableName);
    public Table`1(ISession session, MappingConfiguration config);
    public Table`1(ISession session);
    public sealed virtual string get_Name();
    public sealed virtual string get_KeyspaceName();
    public sealed virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    private sealed virtual override IQueryable System.Linq.IQueryProvider.CreateQuery(Expression expression);
    private sealed virtual override TResult System.Linq.IQueryProvider.Execute(Expression expression);
    private sealed virtual override object System.Linq.IQueryProvider.Execute(Expression expression);
    public sealed virtual Type GetEntityType();
    public sealed virtual void Create();
    public void CreateIfNotExists();
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.Table`1/<CreateAsync>d__18")]
public Task CreateAsync();
    [AsyncStateMachineAttribute("Cassandra.Data.Linq.Table`1/<CreateIfNotExistsAsync>d__19")]
public Task CreateIfNotExistsAsync();
    public sealed virtual ISession GetSession();
    public sealed virtual TableType GetTableType();
    public CqlInsert`1<TEntity> Insert(TEntity entity);
    public CqlInsert`1<TEntity> Insert(TEntity entity, bool insertNulls);
}
[ObsoleteAttribute("Linq attributes are deprecated, use mapping attributes defined in Cassandra.Mapping.Attributes instead.")]
[AttributeUsageAttribute("12")]
public class Cassandra.Data.Linq.TableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    public string Name { get; public set; }
    public bool CaseSensitive { get; public set; }
    public TableAttribute(string name, bool caseSensitive);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public void set_CaseSensitive(bool value);
}
[FlagsAttribute]
public enum Cassandra.Data.Linq.TableType : Enum {
    public int value__;
    public static TableType Standard;
    public static TableType Counter;
    public static TableType All;
}
internal class Cassandra.Data.Linq.VisitingParam`1 : object {
    private Stack`1<T> _clauses;
    private T _defaultValue;
    public VisitingParam`1(T defaultValue);
    public IDisposable Set(T val);
    public T Get();
}
public abstract class Cassandra.DataCollectionMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TableColumn[] <TableColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, TableColumn> <ColumnsByName>k__BackingField;
    [CompilerGeneratedAttribute]
private TableColumn[] <PartitionKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Tuple`2[] <ClusteringKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOptions <Options>k__BackingField;
    public string Name { get; protected set; }
    public TableColumn[] TableColumns { get; protected set; }
    public IDictionary`2<string, TableColumn> ColumnsByName { get; protected set; }
    public TableColumn[] PartitionKeys { get; protected set; }
    public Tuple`2[] ClusteringKeys { get; protected set; }
    public TableOptions Options { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public TableColumn[] get_TableColumns();
    [CompilerGeneratedAttribute]
protected void set_TableColumns(TableColumn[] value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, TableColumn> get_ColumnsByName();
    [CompilerGeneratedAttribute]
protected void set_ColumnsByName(IDictionary`2<string, TableColumn> value);
    [CompilerGeneratedAttribute]
public TableColumn[] get_PartitionKeys();
    [CompilerGeneratedAttribute]
protected void set_PartitionKeys(TableColumn[] value);
    [CompilerGeneratedAttribute]
public Tuple`2[] get_ClusteringKeys();
    [CompilerGeneratedAttribute]
protected void set_ClusteringKeys(Tuple`2[] value);
    [CompilerGeneratedAttribute]
public TableOptions get_Options();
    [CompilerGeneratedAttribute]
protected void set_Options(TableOptions value);
    internal void SetValues(IDictionary`2<string, TableColumn> columns, TableColumn[] partitionKeys, Tuple`2[] clusteringKeys, TableOptions options);
}
internal abstract class Cassandra.DataStax.Auth.BaseDseAuthenticator : object {
    private string _name;
    private static string DseAuthenticatorName;
    protected BaseDseAuthenticator(string name);
    protected abstract virtual Byte[] GetMechanism();
    protected abstract virtual Byte[] GetInitialServerChallenge();
    public virtual Byte[] InitialResponse();
    public abstract virtual Byte[] EvaluateChallenge(Byte[] challenge);
    protected bool IsDseAuthenticator();
}
public class Cassandra.DataStax.Auth.DseGssapiAuthProvider : object {
    private static Byte[] Mechanism;
    private static Byte[] InitialServerChallenge;
    private string _name;
    private string _service;
    private Func`2<IPEndPoint, string> _hostNameResolver;
    public DseGssapiAuthProvider(string service, Func`2<IPEndPoint, string> hostNameResolver);
    private static DseGssapiAuthProvider();
    public sealed virtual IAuthenticator NewAuthenticator(IPEndPoint host);
    public sealed virtual void SetName(string name);
    public static string UseIpResolver(IPEndPoint endpoint);
    public static string ReverseDnsResolver(IPEndPoint endpoint);
}
public class Cassandra.DataStax.Auth.DsePlainTextAuthProvider : object {
    private static Byte[] Mechanism;
    private static Byte[] InitialServerChallenge;
    private string _password;
    private string _authorizationId;
    private string _name;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    internal string Username { get; }
    public DsePlainTextAuthProvider(string username, string password);
    public DsePlainTextAuthProvider(string username, string password, string authorizationId);
    private static DsePlainTextAuthProvider();
    [CompilerGeneratedAttribute]
internal string get_Username();
    public sealed virtual IAuthenticator NewAuthenticator(IPEndPoint host);
    public sealed virtual void SetName(string name);
}
internal static class Cassandra.DataStax.Auth.GssapiClientFactory : object {
    internal static IGssapiClient CreateNew();
}
internal interface Cassandra.DataStax.Auth.IGssapiClient {
    public abstract virtual void Init(string service, string host);
    public abstract virtual Byte[] EvaluateChallenge(Byte[] challenge);
}
internal enum Cassandra.DataStax.Auth.Sspi.Buffers.BufferType : Enum {
    public int value__;
    public static BufferType Empty;
    public static BufferType Data;
    public static BufferType Token;
    public static BufferType Parameters;
    public static BufferType Missing;
    public static BufferType Extra;
    public static BufferType Trailer;
    public static BufferType Header;
    public static BufferType Padding;
    public static BufferType Stream;
    public static BufferType ChannelBindings;
    public static BufferType TargetHost;
    public static BufferType ReadOnlyFlag;
    public static BufferType ReadOnlyWithChecksum;
}
internal class Cassandra.DataStax.Auth.Sspi.Buffers.SecureBuffer : object {
    [CompilerGeneratedAttribute]
private BufferType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public BufferType Type { get; public set; }
    public Byte[] Buffer { get; public set; }
    public int Length { get; internal set; }
    public SecureBuffer(Byte[] buffer, BufferType type);
    [CompilerGeneratedAttribute]
public BufferType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(BufferType value);
    [CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
public void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
internal void set_Length(int value);
}
internal class Cassandra.DataStax.Auth.Sspi.Buffers.SecureBufferAdapter : CriticalFinalizerObject {
    private bool disposed;
    private IList`1<SecureBuffer> buffers;
    private GCHandle descriptorHandle;
    private GCHandle bufferCarrierHandle;
    private GCHandle[] bufferHandles;
    private SecureBufferDescInternal descriptor;
    private SecureBufferInternal[] bufferCarrier;
    public IntPtr Handle { get; }
    public SecureBufferAdapter(SecureBuffer buffer);
    public SecureBufferAdapter(IList`1<SecureBuffer> buffers);
    [ReliabilityContractAttribute("3", "2")]
protected virtual override void Finalize();
    public IntPtr get_Handle();
    public sealed virtual void Dispose();
    [ReliabilityContractAttribute("3", "2")]
private void Dispose(bool disposing);
}
internal enum Cassandra.DataStax.Auth.Sspi.Buffers.SecureBufferDataRep : Enum {
    public int value__;
    public static SecureBufferDataRep Native;
    public static SecureBufferDataRep Network;
}
internal class Cassandra.DataStax.Auth.Sspi.Buffers.SecureBufferDescInternal : ValueType {
    public int Version;
    public int NumBuffers;
    public IntPtr Buffers;
    public static int ApiVersion;
}
internal class Cassandra.DataStax.Auth.Sspi.Buffers.SecureBufferInternal : ValueType {
    public int Count;
    public BufferType Type;
    public IntPtr Buffer;
}
internal static class Cassandra.DataStax.Auth.Sspi.ByteWriter : object {
    public static void WriteInt16_BE(short value, Byte[] buffer, int position);
    public static void WriteInt32_BE(int value, Byte[] buffer, int position);
    public static short ReadInt16_BE(Byte[] buffer, int position);
    public static int ReadInt32_BE(Byte[] buffer, int position);
}
internal class Cassandra.DataStax.Auth.Sspi.Contexts.ClientContext : Context {
    private ContextAttrib requestedAttribs;
    private ContextAttrib finalAttribs;
    private string serverPrinc;
    public ClientContext(ClientCredential cred, string serverPrinc, ContextAttrib requestedAttribs);
    public SecurityStatus Init(Byte[] serverToken, Byte[]& outToken);
}
internal abstract class Cassandra.DataStax.Auth.Sspi.Contexts.Context : object {
    private static UInt32 WrapNoEncrypt;
    [CompilerGeneratedAttribute]
private bool <Initialized>k__BackingField;
    [CompilerGeneratedAttribute]
private Credential <Credential>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeContextHandle <ContextHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expiry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    public bool Initialized { get; private set; }
    protected Credential Credential { get; private set; }
    public SafeContextHandle ContextHandle { get; private set; }
    public DateTime Expiry { get; private set; }
    public bool Disposed { get; private set; }
    protected Context(Credential cred);
    [CompilerGeneratedAttribute]
public bool get_Initialized();
    [CompilerGeneratedAttribute]
private void set_Initialized(bool value);
    [CompilerGeneratedAttribute]
protected Credential get_Credential();
    [CompilerGeneratedAttribute]
private void set_Credential(Credential value);
    [CompilerGeneratedAttribute]
public SafeContextHandle get_ContextHandle();
    [CompilerGeneratedAttribute]
private void set_ContextHandle(SafeContextHandle value);
    [CompilerGeneratedAttribute]
public DateTime get_Expiry();
    [CompilerGeneratedAttribute]
private void set_Expiry(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    protected void Initialize(DateTime expiry);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public Byte[] Encrypt(Byte[] input);
    public Byte[] Decrypt(Byte[] input);
    private SecPkgContext_Sizes QueryBufferSizes();
    private void CheckLifecycle();
}
[FlagsAttribute]
internal enum Cassandra.DataStax.Auth.Sspi.Contexts.ContextAttrib : Enum {
    public int value__;
    public static ContextAttrib Zero;
    public static ContextAttrib Delegate;
    public static ContextAttrib MutualAuth;
    public static ContextAttrib ReplayDetect;
    public static ContextAttrib SequenceDetect;
    public static ContextAttrib Confidentiality;
    public static ContextAttrib UseSessionKey;
    public static ContextAttrib AllocateMemory;
    public static ContextAttrib Connection;
    public static ContextAttrib InitExtendedError;
    public static ContextAttrib AcceptExtendedError;
    public static ContextAttrib InitStream;
    public static ContextAttrib AcceptStream;
    public static ContextAttrib InitIntegrity;
    public static ContextAttrib AcceptIntegrity;
    public static ContextAttrib InitIdentify;
    public static ContextAttrib AcceptIdentify;
    public static ContextAttrib InitManualCredValidation;
    public static ContextAttrib InitUseSuppliedCreds;
}
internal static class Cassandra.DataStax.Auth.Sspi.Contexts.ContextNativeMethods : object {
    internal static SecurityStatus AcceptSecurityContext_1(RawSspiHandle& credHandle, IntPtr oldContextHandle, IntPtr inputBuffer, ContextAttrib requestedAttribs, SecureBufferDataRep dataRep, RawSspiHandle& newContextHandle, IntPtr outputBuffer, ContextAttrib& outputAttribs, TimeStamp& expiry);
    internal static SecurityStatus AcceptSecurityContext_2(RawSspiHandle& credHandle, RawSspiHandle& oldContextHandle, IntPtr inputBuffer, ContextAttrib requestedAttribs, SecureBufferDataRep dataRep, RawSspiHandle& newContextHandle, IntPtr outputBuffer, ContextAttrib& outputAttribs, TimeStamp& expiry);
    internal static SecurityStatus InitializeSecurityContext_1(RawSspiHandle& credentialHandle, IntPtr zero, string serverPrincipleName, ContextAttrib requiredAttribs, int reserved1, SecureBufferDataRep dataRep, IntPtr inputBuffer, int reserved2, RawSspiHandle& newContextHandle, IntPtr outputBuffer, ContextAttrib& contextAttribs, TimeStamp& expiry);
    internal static SecurityStatus InitializeSecurityContext_2(RawSspiHandle& credentialHandle, RawSspiHandle& previousHandle, string serverPrincipleName, ContextAttrib requiredAttribs, int reserved1, SecureBufferDataRep dataRep, IntPtr inputBuffer, int reserved2, RawSspiHandle& newContextHandle, IntPtr outputBuffer, ContextAttrib& contextAttribs, TimeStamp& expiry);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus DeleteSecurityContext(RawSspiHandle& contextHandle);
    [ReliabilityContractAttribute("3", "1")]
internal static SecurityStatus EncryptMessage(RawSspiHandle& contextHandle, UInt32 qualityOfProtection, IntPtr bufferDescriptor, int sequenceNumber);
    [ReliabilityContractAttribute("3", "1")]
internal static SecurityStatus DecryptMessage(RawSspiHandle& contextHandle, IntPtr bufferDescriptor, int sequenceNumber, int qualityOfProtection);
    [ReliabilityContractAttribute("3", "1")]
internal static SecurityStatus MakeSignature(RawSspiHandle& contextHandle, int qualityOfProtection, IntPtr bufferDescriptor, int sequenceNumber);
    [ReliabilityContractAttribute("3", "1")]
internal static SecurityStatus VerifySignature(RawSspiHandle& contextHandle, IntPtr bufferDescriptor, int sequenceNumber, int qualityOfProtection);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus QueryContextAttributes_Sizes(RawSspiHandle& contextHandle, ContextQueryAttrib attrib, SecPkgContext_Sizes& sizes);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus QueryContextAttributes_String(RawSspiHandle& contextHandle, ContextQueryAttrib attrib, SecPkgContext_String& names);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus FreeContextBuffer(IntPtr handle);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus ImpersonateSecurityContext(RawSspiHandle& contextHandle);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus RevertSecurityContext(RawSspiHandle& contextHandle);
    internal static SecurityStatus SafeEncryptMessage(SafeContextHandle handle, UInt32 qualityOfProtection, SecureBufferAdapter bufferAdapter, int sequenceNumber);
    internal static SecurityStatus SafeDecryptMessage(SafeContextHandle handle, int qualityOfProtection, SecureBufferAdapter bufferAdapter, int sequenceNumber);
    internal static SecurityStatus SafeMakeSignature(SafeContextHandle handle, int qualityOfProtection, SecureBufferAdapter adapter, int sequenceNumber);
    internal static SecurityStatus SafeVerifySignature(SafeContextHandle handle, int qualityOfProtection, SecureBufferAdapter adapter, int sequenceNumber);
}
internal enum Cassandra.DataStax.Auth.Sspi.Contexts.ContextQueryAttrib : Enum {
    public int value__;
    public static ContextQueryAttrib Sizes;
    public static ContextQueryAttrib Names;
    public static ContextQueryAttrib Authority;
}
internal class Cassandra.DataStax.Auth.Sspi.Contexts.SafeContextHandle : SafeSspiHandle {
    [ReliabilityContractAttribute("3", "2")]
protected virtual bool ReleaseHandle();
}
internal class Cassandra.DataStax.Auth.Sspi.Contexts.SecPkgContext_Sizes : ValueType {
    public int MaxToken;
    public int MaxSignature;
    public int BlockSize;
    public int SecurityTrailer;
}
internal class Cassandra.DataStax.Auth.Sspi.Contexts.SecPkgContext_String : ValueType {
    public IntPtr StringResult;
}
internal class Cassandra.DataStax.Auth.Sspi.Credentials.ClientCredential : CurrentCredential {
    public ClientCredential(string package);
}
internal class Cassandra.DataStax.Auth.Sspi.Credentials.Credential : object {
    private bool disposed;
    private string securityPackage;
    private SafeCredentialHandle safeCredHandle;
    private DateTime expiry;
    [CompilerGeneratedAttribute]
private SecPkgInfo <PackageInfo>k__BackingField;
    public SecPkgInfo PackageInfo { get; private set; }
    public string SecurityPackage { get; }
    public string PrincipleName { get; }
    public DateTime Expiry { get; protected set; }
    public SafeCredentialHandle Handle { get; protected set; }
    public Credential(string package);
    [CompilerGeneratedAttribute]
public SecPkgInfo get_PackageInfo();
    [CompilerGeneratedAttribute]
private void set_PackageInfo(SecPkgInfo value);
    public string get_SecurityPackage();
    public string get_PrincipleName();
    public DateTime get_Expiry();
    protected void set_Expiry(DateTime value);
    public SafeCredentialHandle get_Handle();
    protected void set_Handle(SafeCredentialHandle value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void CheckLifecycle();
}
internal static class Cassandra.DataStax.Auth.Sspi.Credentials.CredentialNativeMethods : object {
    [ReliabilityContractAttribute("3", "1")]
internal static SecurityStatus AcquireCredentialsHandle(string principleName, string packageName, CredentialUse credentialUse, IntPtr loginId, IntPtr packageData, IntPtr getKeyFunc, IntPtr getKeyData, RawSspiHandle& credentialHandle, TimeStamp& expiry);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus FreeCredentialsHandle(RawSspiHandle& credentialHandle);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus QueryCredentialsAttribute_Name(RawSspiHandle& credentialHandle, CredentialQueryAttrib attributeName, QueryNameAttribCarrier& name);
}
internal enum Cassandra.DataStax.Auth.Sspi.Credentials.CredentialQueryAttrib : Enum {
    public UInt32 value__;
    public static CredentialQueryAttrib Names;
}
internal enum Cassandra.DataStax.Auth.Sspi.Credentials.CredentialUse : Enum {
    public UInt32 value__;
    public static CredentialUse Inbound;
    public static CredentialUse Outbound;
    public static CredentialUse Both;
}
internal class Cassandra.DataStax.Auth.Sspi.Credentials.CurrentCredential : Credential {
    public CurrentCredential(string securityPackage, CredentialUse use);
    private void Init(CredentialUse use);
}
internal class Cassandra.DataStax.Auth.Sspi.Credentials.QueryNameAttribCarrier : ValueType {
    public IntPtr Name;
}
internal class Cassandra.DataStax.Auth.Sspi.Credentials.SafeCredentialHandle : SafeSspiHandle {
    [ReliabilityContractAttribute("3", "2")]
protected virtual bool ReleaseHandle();
}
internal class Cassandra.DataStax.Auth.Sspi.Credentials.ServerCredential : CurrentCredential {
    public ServerCredential(string package);
}
internal class Cassandra.DataStax.Auth.Sspi.EnumMgr : object {
    public static string ToText(Enum value);
    public static T FromText(string text);
}
[AttributeUsageAttribute("256")]
internal class Cassandra.DataStax.Auth.Sspi.EnumStringAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; private set; }
    public EnumStringAttribute(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
}
internal static class Cassandra.DataStax.Auth.Sspi.NativeMethods : object {
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus FreeContextBuffer(IntPtr buffer);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus QuerySecurityPackageInfo(string packageName, IntPtr& pkgInfo);
    [ReliabilityContractAttribute("3", "2")]
internal static SecurityStatus EnumerateSecurityPackages(Int32& numPackages, IntPtr& pkgInfoArry);
}
internal static class Cassandra.DataStax.Auth.Sspi.PackageNames : object {
    public static string Negotiate;
    public static string Kerberos;
    public static string Ntlm;
}
internal static class Cassandra.DataStax.Auth.Sspi.PackageSupport : object {
    public static SecPkgInfo GetPackageCapabilities(string packageName);
    public static SecPkgInfo[] EnumeratePackages();
}
internal class Cassandra.DataStax.Auth.Sspi.RawSspiHandle : ValueType {
    private IntPtr lowPart;
    private IntPtr highPart;
    public bool IsZero();
    [ReliabilityContractAttribute("3", "2")]
public void SetInvalid();
}
internal abstract class Cassandra.DataStax.Auth.Sspi.SafeSspiHandle : SafeHandle {
    internal RawSspiHandle rawHandle;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    [ReliabilityContractAttribute("3", "2")]
protected virtual bool ReleaseHandle();
}
[FlagsAttribute]
internal enum Cassandra.DataStax.Auth.Sspi.SecPkgCapability : Enum {
    public UInt32 value__;
    public static SecPkgCapability Integrity;
    public static SecPkgCapability Privacy;
    public static SecPkgCapability TokenOnly;
    public static SecPkgCapability Datagram;
    public static SecPkgCapability Connection;
    public static SecPkgCapability MultiLeg;
    public static SecPkgCapability ClientOnly;
    public static SecPkgCapability ExtendedError;
    public static SecPkgCapability Impersonation;
    public static SecPkgCapability AcceptWin32Name;
    public static SecPkgCapability Stream;
    public static SecPkgCapability Negotiable;
    public static SecPkgCapability GssCompatible;
    public static SecPkgCapability Logon;
    public static SecPkgCapability AsciiBuffers;
    public static SecPkgCapability Fragment;
    public static SecPkgCapability MutualAuth;
    public static SecPkgCapability Delegation;
    public static SecPkgCapability ReadOnlyChecksum;
    public static SecPkgCapability RestrictedTokens;
    public static SecPkgCapability ExtendsNego;
    public static SecPkgCapability Negotiable2;
}
internal class Cassandra.DataStax.Auth.Sspi.SecPkgInfo : object {
    public SecPkgCapability Capabilities;
    public short Version;
    public short RpcId;
    public int MaxTokenLength;
    public string Name;
    public string Comment;
}
internal enum Cassandra.DataStax.Auth.Sspi.SecurityStatus : Enum {
    public UInt32 value__;
    [EnumStringAttribute("No error")]
public static SecurityStatus OK;
    [EnumStringAttribute("Authentication cycle needs to continue")]
public static SecurityStatus ContinueNeeded;
    [EnumStringAttribute("Authentication cycle needs to perform a 'complete'.")]
public static SecurityStatus CompleteNeeded;
    [EnumStringAttribute("Authentication cycle needs to perform a 'complete' and then continue.")]
public static SecurityStatus CompAndContinue;
    [EnumStringAttribute("The security context was used after its expiration time passed.")]
public static SecurityStatus ContextExpired;
    [EnumStringAttribute("The credentials supplied to the security context were not fully initialized.")]
public static SecurityStatus CredentialsNeeded;
    [EnumStringAttribute("The context data must be re-negotiated with the peer")]
public static SecurityStatus Renegotiate;
    [EnumStringAttribute("Not enough memory.")]
public static SecurityStatus OutOfMemory;
    [EnumStringAttribute("The handle provided to the API was invalid.")]
public static SecurityStatus InvalidHandle;
    [EnumStringAttribute("The attempted operation is not supported")]
public static SecurityStatus Unsupported;
    [EnumStringAttribute("The specified principle is not known in the authentication system.")]
public static SecurityStatus TargetUnknown;
    [EnumStringAttribute("An internal error occurred")]
public static SecurityStatus InternalError;
    [EnumStringAttribute("The requested security package was not found.")]
public static SecurityStatus PackageNotFound;
    public static SecurityStatus NotOwner;
    public static SecurityStatus CannotInstall;
    [EnumStringAttribute("The provided authentication token is invalid or corrupted.")]
public static SecurityStatus InvalidToken;
    public static SecurityStatus CannotPack;
    public static SecurityStatus QopNotSupported;
    [EnumStringAttribute("Impersonation is not supported with the current security package.")]
public static SecurityStatus NoImpersonation;
    [EnumStringAttribute("The logon was denied, perhaps because the provided credentials were incorrect.")]
public static SecurityStatus LogonDenied;
    [EnumStringAttribute("The credentials provided are not recognized by the selected security package.")]
public static SecurityStatus UnknownCredentials;
    [EnumStringAttribute("No credentials are available in the selected security package.")]
public static SecurityStatus NoCredentials;
    [EnumStringAttribute("A message that was provided to the Decrypt or VerifySignature functions was altered after it was created.")]
public static SecurityStatus MessageAltered;
    [EnumStringAttribute("A message was received out of the expected order.")]
public static SecurityStatus OutOfSequence;
    [EnumStringAttribute("The current security package cannot contact an authenticating authority.")]
public static SecurityStatus NoAuthenticatingAuthority;
    public static SecurityStatus IncompleteMessage;
    public static SecurityStatus IncompleteCredentials;
    public static SecurityStatus BufferNotEnough;
    public static SecurityStatus WrongPrincipal;
    public static SecurityStatus TimeSkew;
    public static SecurityStatus UntrustedRoot;
    public static SecurityStatus IllegalMessage;
    public static SecurityStatus CertUnknown;
    public static SecurityStatus CertExpired;
    public static SecurityStatus AlgorithmMismatch;
    public static SecurityStatus SecurityQosFailed;
    public static SecurityStatus SmartcardLogonRequired;
    public static SecurityStatus UnsupportedPreauth;
    public static SecurityStatus BadBinding;
}
[ExtensionAttribute]
internal static class Cassandra.DataStax.Auth.Sspi.SecurityStatusExtensions : object {
    [ExtensionAttribute]
public static bool IsError(SecurityStatus status);
}
public class Cassandra.DataStax.Auth.Sspi.SspiException : Exception {
    private SecurityStatus errorCode;
    private string message;
    public int ErrorCode { get; }
    public string Message { get; }
    internal SspiException(string message, SecurityStatus errorCode);
    public SspiException(string message, int errorCode);
    protected SspiException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public int get_ErrorCode();
    public virtual string get_Message();
}
internal class Cassandra.DataStax.Auth.Sspi.TimeStamp : ValueType {
    public static DateTime Epoch;
    private long time;
    private static TimeStamp();
    public DateTime ToDateTime();
}
internal class Cassandra.DataStax.Auth.SspiClient : object {
    private static ContextAttrib ContextRequestAttributes;
    private static Byte[] EmptyBuffer;
    private TransitionHandler[] _transitions;
    private int _transitionIndex;
    private ClientCredential modreq(System.Runtime.CompilerServices.IsVolatile) _credentials;
    private ClientContext modreq(System.Runtime.CompilerServices.IsVolatile) _context;
    private static SspiClient();
    public sealed virtual void Init(string service, string host);
    public sealed virtual Byte[] EvaluateChallenge(Byte[] challenge);
    private Byte[] FirstTransition(Byte[] challenge);
    private Byte[] SecondTransition(Byte[] challenge);
    private Byte[] ThirdTransition(Byte[] challenge);
    public sealed virtual void Dispose();
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Cloud.CloudConfiguration : object {
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePassword>k__BackingField;
    [JsonPropertyAttribute("host")]
public string Host { get; private set; }
    [JsonPropertyAttribute("port")]
public int Port { get; private set; }
    [JsonPropertyAttribute("pfxCertPassword")]
public string CertificatePassword { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
private void set_Host(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
private void set_Port(int value);
    [CompilerGeneratedAttribute]
public string get_CertificatePassword();
    [CompilerGeneratedAttribute]
private void set_CertificatePassword(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CloudConfiguration other);
    public virtual int GetHashCode();
    public static bool op_Equality(CloudConfiguration left, CloudConfiguration right);
    public static bool op_Inequality(CloudConfiguration left, CloudConfiguration right);
}
internal class Cassandra.DataStax.Cloud.CloudConfigurationParser : object {
    private static Logger Logger;
    private static CloudConfigurationParser();
    public sealed virtual CloudConfiguration ParseConfig(Stream stream);
    private void ValidateConfiguration(CloudConfiguration config);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Cloud.CloudMetadataResult : object {
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private ContactInfo <ContactInfo>k__BackingField;
    [JsonPropertyAttribute("region")]
public string Region { get; public set; }
    [JsonRequiredAttribute]
[JsonPropertyAttribute("contact_info")]
public ContactInfo ContactInfo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(string value);
    [CompilerGeneratedAttribute]
public ContactInfo get_ContactInfo();
    [CompilerGeneratedAttribute]
public void set_ContactInfo(ContactInfo value);
}
internal class Cassandra.DataStax.Cloud.CloudMetadataService : object {
    public sealed virtual Task`1<CloudMetadataResult> GetClusterMetadataAsync(string url, SocketOptions socketOptions, SSLOptions sslOptions);
    [AsyncStateMachineAttribute("Cassandra.DataStax.Cloud.CloudMetadataService/<GetWithWebRequestAsync>d__1")]
private Task`1<CloudMetadataResult> GetWithWebRequestAsync(string url, SocketOptions socketOptions, SSLOptions sslOptions);
    private SecurityProtocolType ConvertSslProtocolEnum(SslProtocols protocol);
    private Exception GetServiceRequestException(bool isParsingError, string url, Exception exception, Nullable`1<int> statusCode);
}
internal class Cassandra.DataStax.Cloud.CloudSniOptionsProvider : object {
    private SecureConnectionBundle _bundle;
    private SSLOptions _sslOptions;
    private SocketOptions _socketOptions;
    private ICloudMetadataService _cloudMetadataService;
    private SingleThreadedResolver _cloudMetadataResolver;
    private CloudMetadataResult modreq(System.Runtime.CompilerServices.IsVolatile) _cloudMetadataResult;
    private SniOptions modreq(System.Runtime.CompilerServices.IsVolatile) _sniOptions;
    public CloudSniOptionsProvider(SocketOptions socketOptions, SSLOptions sslOptions, SecureConnectionBundle bundle, ICloudMetadataService cloudMetadataService);
    [AsyncStateMachineAttribute("Cassandra.DataStax.Cloud.CloudSniOptionsProvider/<UnsafeRefreshSniOptions>d__8")]
private Task UnsafeRefreshSniOptions();
    [AsyncStateMachineAttribute("Cassandra.DataStax.Cloud.CloudSniOptionsProvider/<InitializeAsync>d__9")]
public Task`1<CloudMetadataResult> InitializeAsync();
    [AsyncStateMachineAttribute("Cassandra.DataStax.Cloud.CloudSniOptionsProvider/<GetAsync>d__10")]
public sealed virtual Task`1<SniOptions> GetAsync(bool refresh);
    public sealed virtual bool IsInitialized();
    public sealed virtual string GetStaticIdentifier();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CloudSniOptionsProvider other);
    public virtual int GetHashCode();
    public static bool op_Equality(CloudSniOptionsProvider left, CloudSniOptionsProvider right);
    public static bool op_Inequality(CloudSniOptionsProvider left, CloudSniOptionsProvider right);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Cloud.ContactInfo : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalDc>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ContactPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SniProxyAddress>k__BackingField;
    [JsonPropertyAttribute("type")]
public string Type { get; public set; }
    [JsonPropertyAttribute("local_dc")]
public string LocalDc { get; public set; }
    [JsonRequiredAttribute]
[JsonPropertyAttribute("contact_points")]
public List`1<string> ContactPoints { get; public set; }
    [JsonRequiredAttribute]
[JsonPropertyAttribute("sni_proxy_address")]
public string SniProxyAddress { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_LocalDc();
    [CompilerGeneratedAttribute]
public void set_LocalDc(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ContactPoints();
    [CompilerGeneratedAttribute]
public void set_ContactPoints(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_SniProxyAddress();
    [CompilerGeneratedAttribute]
public void set_SniProxyAddress(string value);
}
internal class Cassandra.DataStax.Cloud.CustomCaCertificateValidator : object {
    private static string SubjectAlternateNameOid;
    private static Logger Logger;
    private static string SanPlatformId;
    private static string SanSeparator;
    private X509Certificate2 _trustedRootCertificateAuthority;
    private string _hostname;
    private static CustomCaCertificateValidator();
    public CustomCaCertificateValidator(X509Certificate2 trustedRootCertificateAuthority, string hostname);
    public sealed virtual bool Validate(X509Certificate cert, X509Chain chain, SslPolicyErrors errors);
    private bool ValidateName(string name);
    private IEnumerable`1<string> GetSubjectAlternativeNames(X509Certificate2 cert);
    private void GetOrCreateCert2(X509Certificate2& cert2, X509Certificate cert);
    private void DisposeCert2(X509Certificate2 cert2);
}
internal interface Cassandra.DataStax.Cloud.ICertificateValidator {
    public abstract virtual bool Validate(X509Certificate cert, X509Chain chain, SslPolicyErrors errors);
}
internal interface Cassandra.DataStax.Cloud.ICloudConfigurationParser {
    public abstract virtual CloudConfiguration ParseConfig(Stream stream);
}
internal interface Cassandra.DataStax.Cloud.ICloudMetadataService {
    public abstract virtual Task`1<CloudMetadataResult> GetClusterMetadataAsync(string url, SocketOptions socketOptions, SSLOptions sslOptions);
}
internal interface Cassandra.DataStax.Cloud.ISecureConnectionBundleParser {
    public abstract virtual SecureConnectionBundle ParseBundle(string path);
}
internal class Cassandra.DataStax.Cloud.SecureConnectionBundle : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <CaCert>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <ClientCert>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudConfiguration <Config>k__BackingField;
    public X509Certificate2 CaCert { get; }
    public X509Certificate2 ClientCert { get; }
    public CloudConfiguration Config { get; }
    public SecureConnectionBundle(X509Certificate2 caCert, X509Certificate2 clientCert, CloudConfiguration config);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_CaCert();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_ClientCert();
    [CompilerGeneratedAttribute]
public CloudConfiguration get_Config();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SecureConnectionBundle other);
    public virtual int GetHashCode();
    public static bool op_Equality(SecureConnectionBundle left, SecureConnectionBundle right);
    public static bool op_Inequality(SecureConnectionBundle left, SecureConnectionBundle right);
}
internal class Cassandra.DataStax.Cloud.SecureConnectionBundleParser : object {
    private static string CaName;
    private static string ConfigName;
    private static string CertName;
    private static Logger Logger;
    private CloudConfigurationParser _configParser;
    private static SecureConnectionBundleParser();
    public sealed virtual SecureConnectionBundle ParseBundle(string path);
    private CloudConfiguration ParseConfig(ZipArchive archive);
    private X509Certificate2 LoadCertificateAuthority(ZipArchive archive);
    private X509Certificate2 LoadClientCertificate(ZipArchive archive, string password);
}
public class Cassandra.DataStax.Graph.Direction : EnumWrapper {
    private static IDictionary`2<string, Direction> Properties;
    public static Direction Both { get; }
    public static Direction In { get; }
    public static Direction Out { get; }
    private Direction(string enumValue);
    private static Direction();
    public static Direction get_Both();
    public static Direction get_In();
    public static Direction get_Out();
    public static Direction GetByValue(string value);
    public virtual string ToString();
    public static string op_Implicit(Direction v);
    public static Direction op_Implicit(string str);
}
public class Cassandra.DataStax.Graph.Edge : Element {
    [CompilerGeneratedAttribute]
private GraphNode <InV>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InVLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphNode <OutV>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutVLabel>k__BackingField;
    public GraphNode InV { get; }
    private IGraphNode Cassandra.DataStax.Graph.IEdge.InV { get; }
    public string InVLabel { get; }
    public GraphNode OutV { get; }
    private IGraphNode Cassandra.DataStax.Graph.IEdge.OutV { get; }
    public string OutVLabel { get; }
    public Edge(GraphNode id, string label, IDictionary`2<string, GraphNode> properties, GraphNode inV, string inVLabel, GraphNode outV, string outVLabel);
    [CompilerGeneratedAttribute]
public GraphNode get_InV();
    private sealed virtual override IGraphNode Cassandra.DataStax.Graph.IEdge.get_InV();
    [CompilerGeneratedAttribute]
public sealed virtual string get_InVLabel();
    [CompilerGeneratedAttribute]
public GraphNode get_OutV();
    private sealed virtual override IGraphNode Cassandra.DataStax.Graph.IEdge.get_OutV();
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutVLabel();
}
public abstract class Cassandra.DataStax.Graph.Element : object {
    [CompilerGeneratedAttribute]
private GraphNode <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, GraphNode> <Properties>k__BackingField;
    public GraphNode Id { get; }
    private IGraphNode Cassandra.DataStax.Graph.IElement.Id { get; }
    public string Label { get; }
    public IDictionary`2<string, GraphNode> Properties { get; }
    protected Element(GraphNode id, string label, IDictionary`2<string, GraphNode> properties);
    public sealed virtual bool Equals(IElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public GraphNode get_Id();
    private sealed virtual override IGraphNode Cassandra.DataStax.Graph.IElement.get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Label();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, GraphNode> get_Properties();
    public sealed virtual IProperty GetProperty(string name);
    public sealed virtual IEnumerable`1<IProperty> GetProperties();
    private IProperty CastOrCreateProperty(string name, GraphNode value);
    [CompilerGeneratedAttribute]
private IProperty <GetProperties>b__16_0(KeyValuePair`2<string, GraphNode> item);
}
public class Cassandra.DataStax.Graph.ElementMap : Element {
    public ElementMap(GraphNode id, string label, IDictionary`2<string, GraphNode> properties);
}
public abstract class Cassandra.DataStax.Graph.EnumWrapper : object {
    [CompilerGeneratedAttribute]
private string <EnumName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnumValue>k__BackingField;
    public string EnumName { get; }
    public string EnumValue { get; }
    protected EnumWrapper(string enumName, string enumValue);
    [CompilerGeneratedAttribute]
public string get_EnumName();
    [CompilerGeneratedAttribute]
public string get_EnumValue();
    public sealed virtual bool Equals(EnumWrapper other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Cassandra.DataStax.Graph.FluentGraphStatement : GraphStatement {
    [CompilerGeneratedAttribute]
private object <QueryBytecode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeserializeGraphNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<Type, IGraphSONSerializer>> <CustomSerializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<string, IGraphSONDeserializer>> <CustomDeserializers>k__BackingField;
    public object QueryBytecode { get; }
    internal bool DeserializeGraphNodes { get; }
    internal IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<Type, IGraphSONSerializer>> CustomSerializers { get; }
    internal IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<string, IGraphSONDeserializer>> CustomDeserializers { get; }
    private FluentGraphStatement(object queryBytecode, IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<Type, IGraphSONSerializer>> customSerializers, IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<string, IGraphSONDeserializer>> customDeserializers, bool deserializeGraphNodes);
    public FluentGraphStatement(object queryBytecode, IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<Type, IGraphSONSerializer>> customSerializers, IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<string, IGraphSONDeserializer>> customDeserializers);
    public FluentGraphStatement(object queryBytecode, IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<Type, IGraphSONSerializer>> customSerializers);
    [CompilerGeneratedAttribute]
public object get_QueryBytecode();
    [CompilerGeneratedAttribute]
internal bool get_DeserializeGraphNodes();
    [CompilerGeneratedAttribute]
internal IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<Type, IGraphSONSerializer>> get_CustomSerializers();
    [CompilerGeneratedAttribute]
internal IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<string, IGraphSONDeserializer>> get_CustomDeserializers();
    internal virtual IStatement GetIStatement(GraphOptions options);
}
[JsonConverterAttribute("Cassandra.DataStax.Graph.GraphNodeConverter")]
public class Cassandra.DataStax.Graph.GraphNode : DynamicObject {
    private INode _node;
    public bool IsArray { get; }
    public bool IsObjectTree { get; }
    public bool IsScalar { get; }
    internal long Bulk { get; }
    public GraphNode(string json);
    internal GraphNode(INode node);
    protected GraphNode(SerializationInfo info, StreamingContext context);
    internal GraphNode(JObject objectTree);
    public sealed virtual bool get_IsArray();
    public sealed virtual bool get_IsObjectTree();
    public sealed virtual bool get_IsScalar();
    internal string GetGraphSONType();
    internal long get_Bulk();
    public sealed virtual T Get(string propertyName);
    internal T Get(string propertyName, bool throwIfNotFound);
    public object GetRaw();
    public sealed virtual bool HasProperty(string name);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public sealed virtual bool Equals(GraphNode other);
    public sealed virtual bool Equals(IGraphNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public IDictionary`2<string, GraphNode> GetProperties();
    private sealed virtual override IDictionary`2<string, IGraphNode> Cassandra.DataStax.Graph.IGraphNode.GetProperties();
    public sealed virtual T To();
    public sealed virtual object To(Type type);
    public GraphNode[] ToArray();
    public sealed virtual IGraphNode[] ToIArray();
    public sealed virtual bool ToBoolean();
    public sealed virtual double ToDouble();
    public sealed virtual float ToFloat();
    public Edge ToEdge();
    public sealed virtual int ToInt32();
    public Path ToPath();
    public virtual string ToString();
    public Vertex ToVertex();
    internal void WriteJson(JsonWriter writer, JsonSerializer serializer);
    public static bool op_Equality(GraphNode result1, GraphNode result2);
    public static bool op_Inequality(GraphNode result1, GraphNode result2);
    public static Vertex op_Implicit(GraphNode b);
    public static Edge op_Implicit(GraphNode b);
    public static Path op_Implicit(GraphNode b);
    public static string op_Implicit(GraphNode b);
    public static short op_Implicit(GraphNode b);
    public static int op_Implicit(GraphNode b);
    public static long op_Implicit(GraphNode b);
    public static float op_Implicit(GraphNode b);
    public static double op_Implicit(GraphNode b);
    public static bool op_Implicit(GraphNode b);
}
internal class Cassandra.DataStax.Graph.GraphNodeConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Cassandra.DataStax.Graph.GraphOptions : object {
    public static string DefaultLanguage;
    internal static string BytecodeJson;
    internal static string GremlinGroovy;
    public static string DefaultSource;
    public static int DefaultReadTimeout;
    private IDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _defaultPayload;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _language;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _name;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _source;
    private long _readConsistencyLevel;
    private long _writeConsistencyLevel;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _readTimeout;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) _nullableGraphProtocol;
    private static IDictionary`2<ConsistencyLevel, string> ConsistencyLevelNames;
    public string Language { get; }
    public string Name { get; }
    public Nullable`1<ConsistencyLevel> ReadConsistencyLevel { get; }
    public int ReadTimeoutMillis { get; }
    public string Source { get; }
    public Nullable`1<GraphProtocol> GraphProtocolVersion { get; }
    public Nullable`1<ConsistencyLevel> WriteConsistencyLevel { get; }
    internal GraphOptions(GraphOptions other, GraphProtocol version);
    private static GraphOptions();
    public string get_Language();
    public string get_Name();
    public Nullable`1<ConsistencyLevel> get_ReadConsistencyLevel();
    public int get_ReadTimeoutMillis();
    public string get_Source();
    public Nullable`1<GraphProtocol> get_GraphProtocolVersion();
    public Nullable`1<ConsistencyLevel> get_WriteConsistencyLevel();
    internal bool IsAnalyticsQuery(IGraphStatement statement);
    public GraphOptions SetLanguage(string language);
    public GraphOptions SetName(string name);
    public GraphOptions SetGraphProtocolVersion(GraphProtocol version);
    public GraphOptions SetReadConsistencyLevel(ConsistencyLevel consistency);
    public GraphOptions SetReadTimeoutMillis(int timeout);
    public GraphOptions SetSource(string source);
    public GraphOptions SetSourceAnalytics();
    public GraphOptions SetWriteConsistencyLevel(ConsistencyLevel consistency);
    internal IDictionary`2<string, Byte[]> BuildPayload(IGraphStatement statement);
    private void Add(IDictionary`2<string, Byte[]> payload, string key, T value, T empty, Func`2<T, Byte[]> converter);
    private void RebuildDefaultPayload();
    private static string GetConsistencyName(ConsistencyLevel consistency);
    private static Byte[] ToUtf8Buffer(string value);
    private static Byte[] ToBuffer(long value);
}
public class Cassandra.DataStax.Graph.GraphResultSet : object {
    private RowSet _rs;
    private Func`2<Row, GraphNode> _factory;
    [CompilerGeneratedAttribute]
private GraphProtocol <GraphProtocol>k__BackingField;
    public ExecutionInfo Info { get; }
    public GraphProtocol GraphProtocol { get; }
    public GraphResultSet(RowSet rs);
    private GraphResultSet(RowSet rs, GraphProtocol protocol, Func`2<Row, GraphNode> factory);
    public ExecutionInfo get_Info();
    [CompilerGeneratedAttribute]
public GraphProtocol get_GraphProtocol();
    internal static GraphResultSet CreateNew(RowSet rs, GraphProtocol protocol, Func`2<Row, GraphNode> rowParser);
    public sealed virtual IEnumerator`1<GraphNode> GetEnumerator();
    [IteratorStateMachineAttribute("Cassandra.DataStax.Graph.GraphResultSet/<YieldNodes>d__11")]
private IEnumerable`1<GraphNode> YieldNodes();
    public IEnumerable`1<T> To();
    private static GraphNode GetGraphSON1Node(Row row);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class Cassandra.DataStax.Graph.GraphStatement : object {
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GraphAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GraphLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GraphName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<GraphProtocol> <GraphProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <GraphReadConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GraphSource>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <GraphWriteConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSystemQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReadTimeoutMillis>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    public Nullable`1<ConsistencyLevel> ConsistencyLevel { get; protected set; }
    public string GraphAlias { get; protected set; }
    public string GraphLanguage { get; protected set; }
    public string GraphName { get; protected set; }
    public Nullable`1<GraphProtocol> GraphProtocolVersion { get; protected set; }
    public Nullable`1<ConsistencyLevel> GraphReadConsistencyLevel { get; protected set; }
    public string GraphSource { get; protected set; }
    public Nullable`1<ConsistencyLevel> GraphWriteConsistencyLevel { get; protected set; }
    public bool IsSystemQuery { get; protected set; }
    public int ReadTimeoutMillis { get; protected set; }
    public Nullable`1<DateTimeOffset> Timestamp { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ConsistencyLevel> get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
protected void set_ConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public string get_GraphAlias();
    [CompilerGeneratedAttribute]
protected void set_GraphAlias(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_GraphLanguage();
    [CompilerGeneratedAttribute]
protected void set_GraphLanguage(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_GraphName();
    [CompilerGeneratedAttribute]
protected void set_GraphName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<GraphProtocol> get_GraphProtocolVersion();
    [CompilerGeneratedAttribute]
protected void set_GraphProtocolVersion(Nullable`1<GraphProtocol> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ConsistencyLevel> get_GraphReadConsistencyLevel();
    [CompilerGeneratedAttribute]
protected void set_GraphReadConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_GraphSource();
    [CompilerGeneratedAttribute]
protected void set_GraphSource(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ConsistencyLevel> get_GraphWriteConsistencyLevel();
    [CompilerGeneratedAttribute]
protected void set_GraphWriteConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSystemQuery();
    [CompilerGeneratedAttribute]
protected void set_IsSystemQuery(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ReadTimeoutMillis();
    [CompilerGeneratedAttribute]
protected void set_ReadTimeoutMillis(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
protected void set_Timestamp(Nullable`1<DateTimeOffset> value);
    internal abstract virtual IStatement GetIStatement(GraphOptions options);
    protected bool IsAnonymous(object obj);
    public sealed virtual IGraphStatement SetConsistencyLevel(ConsistencyLevel consistency);
    public sealed virtual IGraphStatement SetGraphLanguage(string language);
    public sealed virtual IGraphStatement SetGraphName(string name);
    public sealed virtual IGraphStatement SetGraphProtocolVersion(GraphProtocol graphProtocol);
    public sealed virtual IGraphStatement SetGraphReadConsistencyLevel(ConsistencyLevel consistency);
    public sealed virtual IGraphStatement SetGraphSource(string source);
    public sealed virtual IGraphStatement SetGraphSourceAnalytics();
    public sealed virtual IGraphStatement SetGraphWriteConsistencyLevel(ConsistencyLevel consistency);
    public sealed virtual IGraphStatement SetReadTimeoutMillis(int timeout);
    public sealed virtual IGraphStatement SetSystemQuery();
    public sealed virtual IGraphStatement SetTimestamp(DateTimeOffset timestamp);
    private sealed virtual override IStatement Cassandra.DataStax.Graph.IGraphStatement.ToIStatement(GraphOptions options);
}
public interface Cassandra.DataStax.Graph.IEdge {
    public IGraphNode InV { get; }
    public string InVLabel { get; }
    public IGraphNode OutV { get; }
    public string OutVLabel { get; }
    public abstract virtual IGraphNode get_InV();
    public abstract virtual string get_InVLabel();
    public abstract virtual IGraphNode get_OutV();
    public abstract virtual string get_OutVLabel();
}
public interface Cassandra.DataStax.Graph.IElement {
    public string Label { get; }
    public IGraphNode Id { get; }
    public abstract virtual string get_Label();
    public abstract virtual IGraphNode get_Id();
    public abstract virtual IProperty GetProperty(string name);
    public abstract virtual IEnumerable`1<IProperty> GetProperties();
}
public interface Cassandra.DataStax.Graph.IGraphNode {
    public bool IsArray { get; }
    public bool IsObjectTree { get; }
    public bool IsScalar { get; }
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsObjectTree();
    public abstract virtual bool get_IsScalar();
    public abstract virtual T Get(string propertyName);
    public abstract virtual bool HasProperty(string name);
    public abstract virtual T To();
    public abstract virtual object To(Type type);
    public abstract virtual IDictionary`2<string, IGraphNode> GetProperties();
    public abstract virtual IGraphNode[] ToIArray();
    public abstract virtual bool ToBoolean();
    public abstract virtual double ToDouble();
    public abstract virtual float ToFloat();
    public abstract virtual int ToInt32();
}
public interface Cassandra.DataStax.Graph.IGraphStatement {
    public Nullable`1<ConsistencyLevel> ConsistencyLevel { get; }
    public string GraphLanguage { get; }
    public string GraphName { get; }
    public Nullable`1<GraphProtocol> GraphProtocolVersion { get; }
    public Nullable`1<ConsistencyLevel> GraphReadConsistencyLevel { get; }
    public int ReadTimeoutMillis { get; }
    public string GraphSource { get; }
    public Nullable`1<ConsistencyLevel> GraphWriteConsistencyLevel { get; }
    public bool IsSystemQuery { get; }
    public Nullable`1<DateTimeOffset> Timestamp { get; }
    public abstract virtual Nullable`1<ConsistencyLevel> get_ConsistencyLevel();
    public abstract virtual string get_GraphLanguage();
    public abstract virtual string get_GraphName();
    public abstract virtual Nullable`1<GraphProtocol> get_GraphProtocolVersion();
    public abstract virtual Nullable`1<ConsistencyLevel> get_GraphReadConsistencyLevel();
    public abstract virtual int get_ReadTimeoutMillis();
    public abstract virtual string get_GraphSource();
    public abstract virtual Nullable`1<ConsistencyLevel> get_GraphWriteConsistencyLevel();
    public abstract virtual bool get_IsSystemQuery();
    public abstract virtual Nullable`1<DateTimeOffset> get_Timestamp();
    public abstract virtual IStatement ToIStatement(GraphOptions options);
    public abstract virtual IGraphStatement SetConsistencyLevel(ConsistencyLevel consistency);
    public abstract virtual IGraphStatement SetGraphLanguage(string language);
    public abstract virtual IGraphStatement SetGraphName(string name);
    public abstract virtual IGraphStatement SetGraphProtocolVersion(GraphProtocol graphProtocol);
    public abstract virtual IGraphStatement SetGraphReadConsistencyLevel(ConsistencyLevel consistency);
    public abstract virtual IGraphStatement SetGraphSource(string source);
    public abstract virtual IGraphStatement SetGraphSourceAnalytics();
    public abstract virtual IGraphStatement SetGraphWriteConsistencyLevel(ConsistencyLevel consistency);
    public abstract virtual IGraphStatement SetReadTimeoutMillis(int timeout);
    public abstract virtual IGraphStatement SetSystemQuery();
    public abstract virtual IGraphStatement SetTimestamp(DateTimeOffset timestamp);
}
public interface Cassandra.DataStax.Graph.Internal.IGraphSONDeserializer {
    public abstract virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
}
public interface Cassandra.DataStax.Graph.Internal.IGraphSONReader {
    public abstract virtual object ToObject(JToken jToken);
}
public interface Cassandra.DataStax.Graph.Internal.IGraphSONSerializer {
    public abstract virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
public interface Cassandra.DataStax.Graph.Internal.IGraphSONWriter {
    public abstract virtual object ToDict(object objectData);
    public abstract virtual string WriteObject(object objectData);
}
public interface Cassandra.DataStax.Graph.IPath {
    public ICollection`1<ICollection`1<string>> Labels { get; }
    public ICollection`1<IGraphNode> Objects { get; }
    public abstract virtual ICollection`1<ICollection`1<string>> get_Labels();
    public abstract virtual ICollection`1<IGraphNode> get_Objects();
}
public interface Cassandra.DataStax.Graph.IProperty {
    public string Name { get; }
    public IGraphNode Value { get; }
    public abstract virtual string get_Name();
    public abstract virtual IGraphNode get_Value();
}
public interface Cassandra.DataStax.Graph.IPropertyWithElement {
    public IGraphNode Element { get; }
    public abstract virtual IGraphNode get_Element();
}
public interface Cassandra.DataStax.Graph.IVertex {
    public abstract virtual IVertexProperty GetProperty(string name);
    public abstract virtual IEnumerable`1<IVertexProperty> GetProperties(string name);
    public abstract virtual IEnumerable`1<IVertexProperty> GetProperties();
}
public interface Cassandra.DataStax.Graph.IVertexProperty {
    public IGraphNode Vertex { get; }
    public abstract virtual IGraphNode get_Vertex();
}
public class Cassandra.DataStax.Graph.Path : object {
    [CompilerGeneratedAttribute]
private ICollection`1<ICollection`1<string>> <Labels>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<GraphNode> <Objects>k__BackingField;
    public ICollection`1<ICollection`1<string>> Labels { get; protected set; }
    public ICollection`1<GraphNode> Objects { get; protected set; }
    private ICollection`1<IGraphNode> Cassandra.DataStax.Graph.IPath.Objects { get; }
    public Path(ICollection`1<ICollection`1<string>> labels, ICollection`1<GraphNode> objects);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<ICollection`1<string>> get_Labels();
    [CompilerGeneratedAttribute]
protected void set_Labels(ICollection`1<ICollection`1<string>> value);
    [CompilerGeneratedAttribute]
public ICollection`1<GraphNode> get_Objects();
    [CompilerGeneratedAttribute]
protected void set_Objects(ICollection`1<GraphNode> value);
    private sealed virtual override ICollection`1<IGraphNode> Cassandra.DataStax.Graph.IPath.get_Objects();
}
internal class Cassandra.DataStax.Graph.Property : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IGraphNode <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IGraphNode <Element>k__BackingField;
    public string Name { get; }
    public IGraphNode Value { get; }
    public IGraphNode Element { get; }
    internal Property(string name, IGraphNode value, IGraphNode element);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IGraphNode get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual IGraphNode get_Element();
    protected bool Equals(Property other);
    public sealed virtual bool Equals(IProperty other);
    public sealed virtual bool Equals(IPropertyWithElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Cassandra.DataStax.Graph.SimpleGraphStatement : GraphStatement {
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ValuesDictionary>k__BackingField;
    public string Query { get; private set; }
    public object Values { get; private set; }
    public IDictionary`2<string, object> ValuesDictionary { get; private set; }
    public SimpleGraphStatement(string query);
    public SimpleGraphStatement(string query, object values);
    public SimpleGraphStatement(IDictionary`2<string, object> values, string query);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
private void set_Query(string value);
    [CompilerGeneratedAttribute]
public object get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(object value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_ValuesDictionary();
    [CompilerGeneratedAttribute]
private void set_ValuesDictionary(IDictionary`2<string, object> value);
    internal virtual IStatement GetIStatement(GraphOptions options);
}
public class Cassandra.DataStax.Graph.TEnum : EnumWrapper {
    private static IDictionary`2<string, TEnum> Properties;
    public static TEnum Id { get; }
    public static TEnum Key { get; }
    public static TEnum Label { get; }
    public static TEnum Value { get; }
    private TEnum(string enumValue);
    private static TEnum();
    public static TEnum get_Id();
    public static TEnum get_Key();
    public static TEnum get_Label();
    public static TEnum get_Value();
    public static TEnum GetByValue(string value);
    public virtual string ToString();
    public static string op_Implicit(TEnum v);
    public static TEnum op_Implicit(string str);
}
public class Cassandra.DataStax.Graph.Traverser : object {
    [CompilerGeneratedAttribute]
private GraphNode <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Bulk>k__BackingField;
    public GraphNode Object { get; }
    public long Bulk { get; internal set; }
    public Traverser(GraphNode obj, long bulk);
    [CompilerGeneratedAttribute]
public GraphNode get_Object();
    [CompilerGeneratedAttribute]
public long get_Bulk();
    [CompilerGeneratedAttribute]
internal void set_Bulk(long value);
    public bool Equals(Traverser other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Cassandra.DataStax.Graph.Vertex : Element {
    public Vertex(GraphNode id, string label, IDictionary`2<string, GraphNode> properties);
    public sealed virtual IVertexProperty GetProperty(string name);
    private sealed virtual override IProperty Cassandra.DataStax.Graph.IElement.GetProperty(string name);
    public sealed virtual IEnumerable`1<IVertexProperty> GetProperties(string name);
    public sealed virtual IEnumerable`1<IVertexProperty> GetProperties();
    private sealed virtual override IEnumerable`1<IProperty> Cassandra.DataStax.Graph.IElement.GetProperties();
    [CompilerGeneratedAttribute]
private IEnumerable`1<IVertexProperty> <GetProperties>b__4_0(KeyValuePair`2<string, GraphNode> prop);
}
internal class Cassandra.DataStax.Graph.VertexProperty : Element {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IGraphNode <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IGraphNode <Vertex>k__BackingField;
    public string Name { get; }
    public IGraphNode Value { get; }
    public IGraphNode Vertex { get; }
    internal VertexProperty(GraphNode id, string name, IGraphNode value, IGraphNode vertex, IDictionary`2<string, GraphNode> properties);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IGraphNode get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual IGraphNode get_Vertex();
    public sealed virtual bool Equals(IProperty other);
    protected bool Equals(VertexProperty other);
    public sealed virtual bool Equals(IVertexProperty other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal interface Cassandra.DataStax.Insights.IInsightsClient {
    public abstract virtual void Init();
    public abstract virtual Task ShutdownAsync();
}
internal interface Cassandra.DataStax.Insights.IInsightsClientFactory {
    public abstract virtual IInsightsClient Create(IInternalCluster cluster, IInternalSession session);
}
internal interface Cassandra.DataStax.Insights.IInsightsSupportVerifier {
    public abstract virtual bool SupportsInsights(IInternalCluster cluster);
    public abstract virtual bool DseVersionSupportsInsights(Version dseVersion);
}
internal interface Cassandra.DataStax.Insights.InfoProviders.IInsightsInfoProvider`1 {
    public abstract virtual T GetInformation(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.InfoProviders.InsightsInfoProvidersCollection : object {
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<InsightsPlatformInfo> <PlatformInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<Dictionary`2<string, ExecutionProfileInfo>> <ExecutionProfileInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<PoolSizeByHostDistance> <PoolSizeByHostDistanceInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<AuthProviderInfo> <AuthProviderInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<HashSet`1<string>> <DataCentersInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<Dictionary`2<string, object>> <OtherOptionsInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<Dictionary`2<string, string>> <ConfigAntiPatternsInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<PolicyInfo> <ReconnectionPolicyInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<DriverInfo> <DriverInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IInsightsInfoProvider`1<string> <HostnameProvider>k__BackingField;
    public IInsightsInfoProvider`1<InsightsPlatformInfo> PlatformInfoProvider { get; }
    public IInsightsInfoProvider`1<Dictionary`2<string, ExecutionProfileInfo>> ExecutionProfileInfoProvider { get; }
    public IInsightsInfoProvider`1<PoolSizeByHostDistance> PoolSizeByHostDistanceInfoProvider { get; }
    public IInsightsInfoProvider`1<AuthProviderInfo> AuthProviderInfoProvider { get; }
    public IInsightsInfoProvider`1<HashSet`1<string>> DataCentersInfoProvider { get; }
    public IInsightsInfoProvider`1<Dictionary`2<string, object>> OtherOptionsInfoProvider { get; }
    public IInsightsInfoProvider`1<Dictionary`2<string, string>> ConfigAntiPatternsInfoProvider { get; }
    public IInsightsInfoProvider`1<PolicyInfo> ReconnectionPolicyInfoProvider { get; }
    public IInsightsInfoProvider`1<DriverInfo> DriverInfoProvider { get; }
    public IInsightsInfoProvider`1<string> HostnameProvider { get; }
    public InsightsInfoProvidersCollection(IInsightsInfoProvider`1<InsightsPlatformInfo> platformInfoProvider, IInsightsInfoProvider`1<Dictionary`2<string, ExecutionProfileInfo>> executionProfileInfoProvider, IInsightsInfoProvider`1<PoolSizeByHostDistance> poolSizeByHostDistanceInfoProvider, IInsightsInfoProvider`1<AuthProviderInfo> authProviderInfoProvider, IInsightsInfoProvider`1<HashSet`1<string>> dataCentersInfoProvider, IInsightsInfoProvider`1<Dictionary`2<string, object>> otherOptionsInfoProvider, IInsightsInfoProvider`1<Dictionary`2<string, string>> configAntiPatternsInfoProvider, IInsightsInfoProvider`1<PolicyInfo> reconnectionPolicyInfoProvider, IInsightsInfoProvider`1<DriverInfo> driverInfoProvider, IInsightsInfoProvider`1<string> hostnameProvider);
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<InsightsPlatformInfo> get_PlatformInfoProvider();
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<Dictionary`2<string, ExecutionProfileInfo>> get_ExecutionProfileInfoProvider();
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<PoolSizeByHostDistance> get_PoolSizeByHostDistanceInfoProvider();
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<AuthProviderInfo> get_AuthProviderInfoProvider();
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<HashSet`1<string>> get_DataCentersInfoProvider();
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<Dictionary`2<string, object>> get_OtherOptionsInfoProvider();
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<Dictionary`2<string, string>> get_ConfigAntiPatternsInfoProvider();
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<PolicyInfo> get_ReconnectionPolicyInfoProvider();
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<DriverInfo> get_DriverInfoProvider();
    [CompilerGeneratedAttribute]
public IInsightsInfoProvider`1<string> get_HostnameProvider();
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.AuthProviderInfoProvider : object {
    public sealed virtual AuthProviderInfo GetInformation(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.ConfigAntiPatternsInfoProvider : object {
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<Type, Func`3<object, Dictionary`2<string, string>, Dictionary`2<string, string>>> <AntiPatternsProviders>k__BackingField;
    public static IReadOnlyDictionary`2<Type, Func`3<object, Dictionary`2<string, string>, Dictionary`2<string, string>>> AntiPatternsProviders { get; }
    private static ConfigAntiPatternsInfoProvider();
    [CompilerGeneratedAttribute]
public static IReadOnlyDictionary`2<Type, Func`3<object, Dictionary`2<string, string>, Dictionary`2<string, string>>> get_AntiPatternsProviders();
    public sealed virtual Dictionary`2<string, string> GetInformation(IInternalCluster cluster, IInternalSession session);
    private static Dictionary`2<string, string> AddAntiPatterns(object obj, Dictionary`2<string, string> antiPatterns);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.DataCentersInfoProvider : object {
    public sealed virtual HashSet`1<string> GetInformation(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.DriverInfo : object {
    [CompilerGeneratedAttribute]
private string <DriverName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DriverVersion>k__BackingField;
    public string DriverName { get; public set; }
    public string DriverVersion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DriverName();
    [CompilerGeneratedAttribute]
public void set_DriverName(string value);
    [CompilerGeneratedAttribute]
public string get_DriverVersion();
    [CompilerGeneratedAttribute]
public void set_DriverVersion(string value);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.DriverInfoProvider : object {
    public sealed virtual DriverInfo GetInformation(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.ExecutionProfileInfoProvider : object {
    private IPolicyInfoMapper`1<ILoadBalancingPolicy> _loadBalancingPolicyInfoProvider;
    private IPolicyInfoMapper`1<ISpeculativeExecutionPolicy> _speculativeExecutionPolicyInfoProvider;
    private IPolicyInfoMapper`1<IExtendedRetryPolicy> _retryPolicyInfoProvider;
    public ExecutionProfileInfoProvider(IPolicyInfoMapper`1<ILoadBalancingPolicy> loadBalancingPolicyInfoProvider, IPolicyInfoMapper`1<ISpeculativeExecutionPolicy> speculativeExecutionPolicyInfoProvider, IPolicyInfoMapper`1<IExtendedRetryPolicy> retryPolicyInfoProvider);
    public sealed virtual Dictionary`2<string, ExecutionProfileInfo> GetInformation(IInternalCluster cluster, IInternalSession session);
    private ExecutionProfileInfo GetExecutionProfileInfo(IExecutionProfile profile);
    private Dictionary`2<string, object> GetGraphOptions(IExecutionProfile profile);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.HostnameInfoProvider : object {
    public sealed virtual string GetInformation(IInternalCluster cluster, IInternalSession session);
}
internal interface Cassandra.DataStax.Insights.InfoProviders.StartupMessage.IPolicyInfoMapper`1 {
    public abstract virtual PolicyInfo GetPolicyInformation(T policy);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.LoadBalancingPolicyInfoProvider : object {
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<Type, Func`3<ILoadBalancingPolicy, IPolicyInfoMapper`1<IReconnectionPolicy>, Dictionary`2<string, object>>> <LoadBalancingPolicyOptionsProviders>k__BackingField;
    private IPolicyInfoMapper`1<IReconnectionPolicy> _reconnectionPolicyInfoMapper;
    private static IReadOnlyDictionary`2<Type, Func`3<ILoadBalancingPolicy, IPolicyInfoMapper`1<IReconnectionPolicy>, Dictionary`2<string, object>>> LoadBalancingPolicyOptionsProviders { get; }
    private static LoadBalancingPolicyInfoProvider();
    public LoadBalancingPolicyInfoProvider(IPolicyInfoMapper`1<IReconnectionPolicy> reconnectionPolicyInfoMapper);
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<Type, Func`3<ILoadBalancingPolicy, IPolicyInfoMapper`1<IReconnectionPolicy>, Dictionary`2<string, object>>> get_LoadBalancingPolicyOptionsProviders();
    public sealed virtual PolicyInfo GetPolicyInformation(ILoadBalancingPolicy policy);
    private static PolicyInfo GetLoadBalancingPolicyInfo(ILoadBalancingPolicy policy, IPolicyInfoMapper`1<IReconnectionPolicy> reconnectionPolicyInfoMapper);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.OtherOptionsInfoProvider : object {
    public sealed virtual Dictionary`2<string, object> GetInformation(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.PlatformInfoProvider : object {
    public sealed virtual InsightsPlatformInfo GetInformation(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.PoolSizeByHostDistanceInfoProvider : object {
    public sealed virtual PoolSizeByHostDistance GetInformation(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.ReconnectionPolicyInfoProvider : object {
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<Type, Func`2<IReconnectionPolicy, Dictionary`2<string, object>>> <PolicyOptionsProviders>k__BackingField;
    public static IReadOnlyDictionary`2<Type, Func`2<IReconnectionPolicy, Dictionary`2<string, object>>> PolicyOptionsProviders { get; }
    private static ReconnectionPolicyInfoProvider();
    [CompilerGeneratedAttribute]
public static IReadOnlyDictionary`2<Type, Func`2<IReconnectionPolicy, Dictionary`2<string, object>>> get_PolicyOptionsProviders();
    public sealed virtual PolicyInfo GetInformation(IInternalCluster cluster, IInternalSession session);
    public sealed virtual PolicyInfo GetPolicyInformation(IReconnectionPolicy policy);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.RetryPolicyInfoProvider : object {
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<Type, Func`2<IRetryPolicy, Dictionary`2<string, object>>> <RetryPolicyOptionsProviders>k__BackingField;
    private static IReadOnlyDictionary`2<Type, Func`2<IRetryPolicy, Dictionary`2<string, object>>> RetryPolicyOptionsProviders { get; }
    private static RetryPolicyInfoProvider();
    public sealed virtual PolicyInfo GetPolicyInformation(IExtendedRetryPolicy policy);
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<Type, Func`2<IRetryPolicy, Dictionary`2<string, object>>> get_RetryPolicyOptionsProviders();
    private static PolicyInfo GetRetryPolicyInfo(IRetryPolicy policy);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StartupMessage.SpeculativeExecutionPolicyInfoProvider : object {
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<Type, Func`2<ISpeculativeExecutionPolicy, Dictionary`2<string, object>>> <SpeculativeExecutionPolicyOptionsProviders>k__BackingField;
    private static IReadOnlyDictionary`2<Type, Func`2<ISpeculativeExecutionPolicy, Dictionary`2<string, object>>> SpeculativeExecutionPolicyOptionsProviders { get; }
    private static SpeculativeExecutionPolicyInfoProvider();
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<Type, Func`2<ISpeculativeExecutionPolicy, Dictionary`2<string, object>>> get_SpeculativeExecutionPolicyOptionsProviders();
    public sealed virtual PolicyInfo GetPolicyInformation(ISpeculativeExecutionPolicy policy);
    private static PolicyInfo GetSpeculativeExecutionPolicyInfo(ISpeculativeExecutionPolicy policy);
}
internal class Cassandra.DataStax.Insights.InfoProviders.StatusMessage.NodeStatusInfoProvider : object {
    public sealed virtual Dictionary`2<string, NodeStatusInfo> GetInformation(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.InsightsClient : object {
    private static string ReportInsightRpc;
    private static int ErrorCountThresholdForLogging;
    private static Logger Logger;
    private IInternalCluster _cluster;
    private IInternalSession _session;
    private MonitorReportingOptions _monitorReportingOptions;
    private IInsightsMessageFactory`1<InsightsStartupData> _startupMessageFactory;
    private IInsightsMessageFactory`1<InsightsStatusData> _statusMessageFactory;
    private Task _insightsTask;
    private CancellationTokenSource _cancellationTokenSource;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _errorCount;
    private bool Initialized { get; }
    public InsightsClient(IInternalCluster cluster, IInternalSession session, IInsightsMessageFactory`1<InsightsStartupData> startupMessageFactory, IInsightsMessageFactory`1<InsightsStatusData> statusMessageFactory);
    private static InsightsClient();
    private bool get_Initialized();
    [AsyncStateMachineAttribute("Cassandra.DataStax.Insights.InsightsClient/<SendStartupMessageAsync>d__14")]
private Task`1<bool> SendStartupMessageAsync();
    [AsyncStateMachineAttribute("Cassandra.DataStax.Insights.InsightsClient/<SendStatusMessageAsync>d__15")]
private Task`1<bool> SendStatusMessageAsync();
    public sealed virtual void Init();
    public sealed virtual Task ShutdownAsync();
    public sealed virtual void Dispose();
    private bool ShouldStartInsightsTask();
    [AsyncStateMachineAttribute("Cassandra.DataStax.Insights.InsightsClient/<MainLoopAsync>d__20")]
private Task MainLoopAsync();
    [AsyncStateMachineAttribute("Cassandra.DataStax.Insights.InsightsClient/<SendJsonMessageAsync>d__21`1")]
private Task SendJsonMessageAsync(T message);
    private Task`1<Response> RunWithTokenAsync(Func`1<Task`1<Response>> func);
}
internal class Cassandra.DataStax.Insights.InsightsClientFactory : object {
    private IInsightsMessageFactory`1<InsightsStartupData> _startupMessageFactory;
    private IInsightsMessageFactory`1<InsightsStatusData> _statusMessageFactory;
    public InsightsClientFactory(IInsightsMessageFactory`1<InsightsStartupData> startupMessageFactory, IInsightsMessageFactory`1<InsightsStatusData> statusMessageFactory);
    public sealed virtual IInsightsClient Create(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.InsightsSupportVerifier : object {
    private static Version MinDse6Version;
    private static Version MinDse51Version;
    private static Version Dse600Version;
    private static InsightsSupportVerifier();
    public sealed virtual bool SupportsInsights(IInternalCluster cluster);
    public sealed virtual bool DseVersionSupportsInsights(Version dseVersion);
    [CompilerGeneratedAttribute]
private bool <SupportsInsights>b__3_0(Host h);
}
internal interface Cassandra.DataStax.Insights.MessageFactories.IInsightsMessageFactory`1 {
    public abstract virtual Insight`1<T> CreateMessage(IInternalCluster cluster, IInternalSession session);
}
internal interface Cassandra.DataStax.Insights.MessageFactories.IInsightsMetadataFactory {
    public abstract virtual InsightsMetadata CreateInsightsMetadata(string messageName, string mappingId, InsightType insightType);
}
internal interface Cassandra.DataStax.Insights.MessageFactories.IInsightsMetadataTimestampGenerator {
    public abstract virtual long GenerateTimestamp();
}
internal class Cassandra.DataStax.Insights.MessageFactories.InsightsMetadataFactory : object {
    private IInsightsMetadataTimestampGenerator _unixTimestampGenerator;
    public InsightsMetadataFactory(IInsightsMetadataTimestampGenerator unixTimestampGenerator);
    public sealed virtual InsightsMetadata CreateInsightsMetadata(string messageName, string mappingId, InsightType insightType);
}
internal class Cassandra.DataStax.Insights.MessageFactories.InsightsMetadataTimestampGenerator : object {
    private static DateTimeOffset UnixEpoch;
    private static InsightsMetadataTimestampGenerator();
    public sealed virtual long GenerateTimestamp();
}
internal class Cassandra.DataStax.Insights.MessageFactories.InsightsStartupMessageFactory : object {
    private static string StartupMessageName;
    private static string StartupV1MappingId;
    private IInsightsMetadataFactory _metadataFactory;
    private InsightsInfoProvidersCollection _infoProviders;
    public InsightsStartupMessageFactory(IInsightsMetadataFactory metadataFactory, InsightsInfoProvidersCollection infoProviders);
    public sealed virtual Insight`1<InsightsStartupData> CreateMessage(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.MessageFactories.InsightsStatusMessageFactory : object {
    private static string StatusMessageName;
    private static string StatusV1MappingId;
    private IInsightsMetadataFactory _insightsMetadataFactory;
    private IInsightsInfoProvider`1<Dictionary`2<string, NodeStatusInfo>> _connectedNodesInfoProvider;
    public InsightsStatusMessageFactory(IInsightsMetadataFactory insightsMetadataFactory, IInsightsInfoProvider`1<Dictionary`2<string, NodeStatusInfo>> connectedNodesInfoProvider);
    public sealed virtual Insight`1<InsightsStatusData> CreateMessage(IInternalCluster cluster, IInternalSession session);
}
internal class Cassandra.DataStax.Insights.Schema.Converters.CompressionTypeInsightsConverter : InsightsEnumConverter`2<CompressionType, string> {
    private static IReadOnlyDictionary`2<CompressionType, string> CompressionTypeStringMap;
    protected IReadOnlyDictionary`2<CompressionType, string> EnumToJsonValueMap { get; }
    private static CompressionTypeInsightsConverter();
    protected virtual IReadOnlyDictionary`2<CompressionType, string> get_EnumToJsonValueMap();
}
internal class Cassandra.DataStax.Insights.Schema.Converters.ConsistencyInsightsConverter : InsightsEnumConverter`2<ConsistencyLevel, string> {
    private static IReadOnlyDictionary`2<ConsistencyLevel, string> ConsistencyLevelStringMap;
    protected IReadOnlyDictionary`2<ConsistencyLevel, string> EnumToJsonValueMap { get; }
    private static ConsistencyInsightsConverter();
    protected virtual IReadOnlyDictionary`2<ConsistencyLevel, string> get_EnumToJsonValueMap();
}
internal abstract class Cassandra.DataStax.Insights.Schema.Converters.InsightsEnumConverter`2 : JsonConverter {
    private static string TypeString;
    private static Logger Logger;
    protected IReadOnlyDictionary`2<TEnumType, TJsonType> EnumToJsonValueMap { get; }
    private static InsightsEnumConverter`2();
    protected abstract virtual IReadOnlyDictionary`2<TEnumType, TJsonType> get_EnumToJsonValueMap();
    public bool TryConvert(TEnumType value, TJsonType& output);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Cassandra.DataStax.Insights.Schema.Converters.InsightTypeInsightsConverter : InsightsEnumConverter`2<InsightType, string> {
    private static IReadOnlyDictionary`2<InsightType, string> InsightTypeStringMap;
    protected IReadOnlyDictionary`2<InsightType, string> EnumToJsonValueMap { get; }
    private static InsightTypeInsightsConverter();
    protected virtual IReadOnlyDictionary`2<InsightType, string> get_EnumToJsonValueMap();
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.Insight`1 : object {
    [JsonPropertyAttribute("metadata")]
public InsightsMetadata Metadata;
    [JsonPropertyAttribute("data")]
public T Data;
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.InsightsMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private InsightType <InsightType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InsightMappingId>k__BackingField;
    [JsonPropertyAttribute("name")]
public string Name { get; public set; }
    [JsonPropertyAttribute("timestamp")]
public long Timestamp { get; public set; }
    [JsonPropertyAttribute("tags")]
public Dictionary`2<string, string> Tags { get; public set; }
    [JsonPropertyAttribute("insightType")]
[JsonConverterAttribute("Cassandra.DataStax.Insights.Schema.Converters.InsightTypeInsightsConverter")]
public InsightType InsightType { get; public set; }
    [JsonPropertyAttribute("insightMappingId")]
public string InsightMappingId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(long value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public InsightType get_InsightType();
    [CompilerGeneratedAttribute]
public void set_InsightType(InsightType value);
    [CompilerGeneratedAttribute]
public string get_InsightMappingId();
    [CompilerGeneratedAttribute]
public void set_InsightMappingId(string value);
}
internal enum Cassandra.DataStax.Insights.Schema.InsightType : Enum {
    public int value__;
    public static InsightType Event;
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.AssemblyInfo : object {
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [JsonPropertyAttribute("fullName")]
public string FullName { get; public set; }
    [JsonPropertyAttribute("name")]
public string Name { get; public set; }
    [JsonPropertyAttribute("version")]
public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.AuthProviderInfo : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [JsonPropertyAttribute("type")]
public string Type { get; public set; }
    [JsonPropertyAttribute("namespace")]
public string Namespace { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.CentralProcessingUnitsInfo : object {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Model>k__BackingField;
    [JsonPropertyAttribute("length")]
public int Length { get; public set; }
    [JsonPropertyAttribute("model")]
public string Model { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    [CompilerGeneratedAttribute]
public string get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(string value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.ExecutionProfileInfo : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyInfo <Retry>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyInfo <LoadBalancing>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyInfo <SpeculativeExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <Consistency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <SerialConsistency>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <GraphOptions>k__BackingField;
    [JsonPropertyAttribute("readTimeout")]
public Nullable`1<int> ReadTimeout { get; public set; }
    [JsonPropertyAttribute("retry")]
public PolicyInfo Retry { get; public set; }
    [JsonPropertyAttribute("loadBalancing")]
public PolicyInfo LoadBalancing { get; public set; }
    [JsonPropertyAttribute("speculativeExecution")]
public PolicyInfo SpeculativeExecution { get; public set; }
    [JsonPropertyAttribute("consistency")]
[JsonConverterAttribute("Cassandra.DataStax.Insights.Schema.Converters.ConsistencyInsightsConverter")]
public Nullable`1<ConsistencyLevel> Consistency { get; public set; }
    [JsonPropertyAttribute("serialConsistency")]
[JsonConverterAttribute("Cassandra.DataStax.Insights.Schema.Converters.ConsistencyInsightsConverter")]
public Nullable`1<ConsistencyLevel> SerialConsistency { get; public set; }
    [JsonPropertyAttribute("graphOptions")]
public Dictionary`2<string, object> GraphOptions { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReadTimeout();
    [CompilerGeneratedAttribute]
public void set_ReadTimeout(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public PolicyInfo get_Retry();
    [CompilerGeneratedAttribute]
public void set_Retry(PolicyInfo value);
    [CompilerGeneratedAttribute]
public PolicyInfo get_LoadBalancing();
    [CompilerGeneratedAttribute]
public void set_LoadBalancing(PolicyInfo value);
    [CompilerGeneratedAttribute]
public PolicyInfo get_SpeculativeExecution();
    [CompilerGeneratedAttribute]
public void set_SpeculativeExecution(PolicyInfo value);
    [CompilerGeneratedAttribute]
public Nullable`1<ConsistencyLevel> get_Consistency();
    [CompilerGeneratedAttribute]
public void set_Consistency(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ConsistencyLevel> get_SerialConsistency();
    [CompilerGeneratedAttribute]
public void set_SerialConsistency(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_GraphOptions();
    [CompilerGeneratedAttribute]
public void set_GraphOptions(Dictionary`2<string, object> value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.InsightsPlatformInfo : object {
    [CompilerGeneratedAttribute]
private OperatingSystemInfo <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private CentralProcessingUnitsInfo <CentralProcessingUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeInfo <Runtime>k__BackingField;
    [JsonPropertyAttribute("os")]
public OperatingSystemInfo OperatingSystem { get; public set; }
    [JsonPropertyAttribute("cpus")]
public CentralProcessingUnitsInfo CentralProcessingUnits { get; public set; }
    [JsonPropertyAttribute("runtime")]
public RuntimeInfo Runtime { get; public set; }
    [CompilerGeneratedAttribute]
public OperatingSystemInfo get_OperatingSystem();
    [CompilerGeneratedAttribute]
public void set_OperatingSystem(OperatingSystemInfo value);
    [CompilerGeneratedAttribute]
public CentralProcessingUnitsInfo get_CentralProcessingUnits();
    [CompilerGeneratedAttribute]
public void set_CentralProcessingUnits(CentralProcessingUnitsInfo value);
    [CompilerGeneratedAttribute]
public RuntimeInfo get_Runtime();
    [CompilerGeneratedAttribute]
public void set_Runtime(RuntimeInfo value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.InsightsStartupData : object {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <ContactPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InitialControlConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ExecutionProfileInfo> <ExecutionProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private PoolSizeByHostDistance <PoolSizeByHostDistance>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HeartbeatInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionType <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyInfo <ReconnectionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private SslInfo <Ssl>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthProviderInfo <AuthProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <OtherOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ConfigAntiPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PeriodicStatusInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private InsightsPlatformInfo <PlatformInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DriverName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplicationNameWasGenerated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DriverVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <DataCenters>k__BackingField;
    [JsonPropertyAttribute("clientId")]
public string ClientId { get; public set; }
    [JsonPropertyAttribute("sessionId")]
public string SessionId { get; public set; }
    [JsonPropertyAttribute("applicationName")]
public string ApplicationName { get; public set; }
    [JsonPropertyAttribute("applicationVersion")]
public string ApplicationVersion { get; public set; }
    [JsonPropertyAttribute("contactPoints")]
public Dictionary`2<string, List`1<string>> ContactPoints { get; public set; }
    [JsonPropertyAttribute("initialControlConnection")]
public string InitialControlConnection { get; public set; }
    [JsonPropertyAttribute("protocolVersion")]
public byte ProtocolVersion { get; public set; }
    [JsonPropertyAttribute("localAddress")]
public string LocalAddress { get; public set; }
    [JsonPropertyAttribute("executionProfiles")]
public Dictionary`2<string, ExecutionProfileInfo> ExecutionProfiles { get; public set; }
    [JsonPropertyAttribute("poolSizeByHostDistance")]
public PoolSizeByHostDistance PoolSizeByHostDistance { get; public set; }
    [JsonPropertyAttribute("heartbeatInterval")]
public long HeartbeatInterval { get; public set; }
    [JsonPropertyAttribute("compression")]
[JsonConverterAttribute("Cassandra.DataStax.Insights.Schema.Converters.CompressionTypeInsightsConverter")]
public CompressionType Compression { get; public set; }
    [JsonPropertyAttribute("reconnectionPolicy")]
public PolicyInfo ReconnectionPolicy { get; public set; }
    [JsonPropertyAttribute("ssl")]
public SslInfo Ssl { get; public set; }
    [JsonPropertyAttribute("authProvider")]
public AuthProviderInfo AuthProvider { get; public set; }
    [JsonPropertyAttribute("otherOptions")]
public Dictionary`2<string, object> OtherOptions { get; public set; }
    [JsonPropertyAttribute("configAntiPatterns")]
public Dictionary`2<string, string> ConfigAntiPatterns { get; public set; }
    [JsonPropertyAttribute("periodicStatusInterval")]
public long PeriodicStatusInterval { get; public set; }
    [JsonPropertyAttribute("platformInfo")]
public InsightsPlatformInfo PlatformInfo { get; public set; }
    [JsonPropertyAttribute("hostName")]
public string HostName { get; public set; }
    [JsonPropertyAttribute("driverName")]
public string DriverName { get; public set; }
    [JsonPropertyAttribute("applicationNameWasGenerated")]
public bool ApplicationNameWasGenerated { get; public set; }
    [JsonPropertyAttribute("driverVersion")]
public string DriverVersion { get; public set; }
    [JsonPropertyAttribute("dataCenters")]
public HashSet`1<string> DataCenters { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
public void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationVersion();
    [CompilerGeneratedAttribute]
public void set_ApplicationVersion(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_ContactPoints();
    [CompilerGeneratedAttribute]
public void set_ContactPoints(Dictionary`2<string, List`1<string>> value);
    [CompilerGeneratedAttribute]
public string get_InitialControlConnection();
    [CompilerGeneratedAttribute]
public void set_InitialControlConnection(string value);
    [CompilerGeneratedAttribute]
public byte get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(byte value);
    [CompilerGeneratedAttribute]
public string get_LocalAddress();
    [CompilerGeneratedAttribute]
public void set_LocalAddress(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ExecutionProfileInfo> get_ExecutionProfiles();
    [CompilerGeneratedAttribute]
public void set_ExecutionProfiles(Dictionary`2<string, ExecutionProfileInfo> value);
    [CompilerGeneratedAttribute]
public PoolSizeByHostDistance get_PoolSizeByHostDistance();
    [CompilerGeneratedAttribute]
public void set_PoolSizeByHostDistance(PoolSizeByHostDistance value);
    [CompilerGeneratedAttribute]
public long get_HeartbeatInterval();
    [CompilerGeneratedAttribute]
public void set_HeartbeatInterval(long value);
    [CompilerGeneratedAttribute]
public CompressionType get_Compression();
    [CompilerGeneratedAttribute]
public void set_Compression(CompressionType value);
    [CompilerGeneratedAttribute]
public PolicyInfo get_ReconnectionPolicy();
    [CompilerGeneratedAttribute]
public void set_ReconnectionPolicy(PolicyInfo value);
    [CompilerGeneratedAttribute]
public SslInfo get_Ssl();
    [CompilerGeneratedAttribute]
public void set_Ssl(SslInfo value);
    [CompilerGeneratedAttribute]
public AuthProviderInfo get_AuthProvider();
    [CompilerGeneratedAttribute]
public void set_AuthProvider(AuthProviderInfo value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_OtherOptions();
    [CompilerGeneratedAttribute]
public void set_OtherOptions(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ConfigAntiPatterns();
    [CompilerGeneratedAttribute]
public void set_ConfigAntiPatterns(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public long get_PeriodicStatusInterval();
    [CompilerGeneratedAttribute]
public void set_PeriodicStatusInterval(long value);
    [CompilerGeneratedAttribute]
public InsightsPlatformInfo get_PlatformInfo();
    [CompilerGeneratedAttribute]
public void set_PlatformInfo(InsightsPlatformInfo value);
    [CompilerGeneratedAttribute]
public string get_HostName();
    [CompilerGeneratedAttribute]
public void set_HostName(string value);
    [CompilerGeneratedAttribute]
public string get_DriverName();
    [CompilerGeneratedAttribute]
public void set_DriverName(string value);
    [CompilerGeneratedAttribute]
public bool get_ApplicationNameWasGenerated();
    [CompilerGeneratedAttribute]
public void set_ApplicationNameWasGenerated(bool value);
    [CompilerGeneratedAttribute]
public string get_DriverVersion();
    [CompilerGeneratedAttribute]
public void set_DriverVersion(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_DataCenters();
    [CompilerGeneratedAttribute]
public void set_DataCenters(HashSet`1<string> value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.OperatingSystemInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arch>k__BackingField;
    [JsonPropertyAttribute("name")]
public string Name { get; public set; }
    [JsonPropertyAttribute("version")]
public string Version { get; public set; }
    [JsonPropertyAttribute("arch")]
public string Arch { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Arch();
    [CompilerGeneratedAttribute]
public void set_Arch(string value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.PolicyInfo : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Options>k__BackingField;
    [JsonPropertyAttribute("type")]
public string Type { get; public set; }
    [JsonPropertyAttribute("namespace")]
public string Namespace { get; public set; }
    [JsonPropertyAttribute("options")]
public Dictionary`2<string, object> Options { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(Dictionary`2<string, object> value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.PoolSizeByHostDistance : object {
    [CompilerGeneratedAttribute]
private int <Local>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Remote>k__BackingField;
    [JsonPropertyAttribute("local")]
public int Local { get; public set; }
    [JsonPropertyAttribute("remote")]
public int Remote { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Local();
    [CompilerGeneratedAttribute]
public void set_Local(int value);
    [CompilerGeneratedAttribute]
public int get_Remote();
    [CompilerGeneratedAttribute]
public void set_Remote(int value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.RuntimeInfo : object {
    [CompilerGeneratedAttribute]
private string <RuntimeFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, AssemblyInfo> <Dependencies>k__BackingField;
    [JsonPropertyAttribute("runtimeFramework")]
public string RuntimeFramework { get; public set; }
    [JsonPropertyAttribute("targetFramework")]
public string TargetFramework { get; public set; }
    [JsonPropertyAttribute("dependencies")]
public Dictionary`2<string, AssemblyInfo> Dependencies { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RuntimeFramework();
    [CompilerGeneratedAttribute]
public void set_RuntimeFramework(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, AssemblyInfo> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(Dictionary`2<string, AssemblyInfo> value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StartupMessage.SslInfo : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [JsonPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StatusMessage.InsightsStatusData : object {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ControlConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, NodeStatusInfo> <ConnectedNodes>k__BackingField;
    [JsonPropertyAttribute("clientId")]
public string ClientId { get; public set; }
    [JsonPropertyAttribute("sessionId")]
public string SessionId { get; public set; }
    [JsonPropertyAttribute("controlConnection")]
public string ControlConnection { get; public set; }
    [JsonPropertyAttribute("connectedNodes")]
public Dictionary`2<string, NodeStatusInfo> ConnectedNodes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_ControlConnection();
    [CompilerGeneratedAttribute]
public void set_ControlConnection(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, NodeStatusInfo> get_ConnectedNodes();
    [CompilerGeneratedAttribute]
public void set_ConnectedNodes(Dictionary`2<string, NodeStatusInfo> value);
}
[JsonObjectAttribute]
internal class Cassandra.DataStax.Insights.Schema.StatusMessage.NodeStatusInfo : object {
    [CompilerGeneratedAttribute]
private int <Connections>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InFlightQueries>k__BackingField;
    [JsonPropertyAttribute("connections")]
public int Connections { get; public set; }
    [JsonPropertyAttribute("inFlightQueries")]
public int InFlightQueries { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Connections();
    [CompilerGeneratedAttribute]
public void set_Connections(int value);
    [CompilerGeneratedAttribute]
public int get_InFlightQueries();
    [CompilerGeneratedAttribute]
public void set_InFlightQueries(int value);
}
public class Cassandra.DataStax.Search.DateRange : ValueType {
    private static Regex MultipleBoundariesRegex;
    private static DateRangeSerializer Serializer;
    [CompilerGeneratedAttribute]
private DateRangeBound <LowerBound>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateRangeBound> <UpperBound>k__BackingField;
    public DateRangeBound LowerBound { get; private set; }
    public Nullable`1<DateRangeBound> UpperBound { get; private set; }
    public DateRange(DateRangeBound lowerBound, DateRangeBound upperBound);
    public DateRange(DateRangeBound lowerBound);
    private static DateRange();
    [CompilerGeneratedAttribute]
public DateRangeBound get_LowerBound();
    [CompilerGeneratedAttribute]
private void set_LowerBound(DateRangeBound value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateRangeBound> get_UpperBound();
    [CompilerGeneratedAttribute]
private void set_UpperBound(Nullable`1<DateRangeBound> value);
    public static DateRange Parse(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DateRange other);
    public sealed virtual int CompareTo(DateRange other);
    public virtual string ToString();
    public static bool op_Equality(DateRange a, DateRange b);
    public static bool op_Inequality(DateRange a, DateRange b);
}
public class Cassandra.DataStax.Search.DateRangeBound : ValueType {
    private static Regex TimestampRegex;
    private static String[] FormatByPrecision;
    public static DateRangeBound Unbounded;
    private static string UnboundedString;
    private DateTimeOffset _timestamp;
    private DateRangePrecision _precision;
    public DateTimeOffset Timestamp { get; }
    public DateRangePrecision Precision { get; }
    public DateRangeBound(DateTimeOffset timestamp, DateRangePrecision precision);
    private DateRangeBound(DateRangePrecision precision, DateTimeOffset utcTimestamp);
    private DateRangeBound(bool asUnbounded);
    private static DateRangeBound();
    public DateTimeOffset get_Timestamp();
    public DateRangePrecision get_Precision();
    public sealed virtual bool Equals(DateRangeBound other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static DateRangeBound Parse(string boundaryString);
    internal static DateRangeBound ParseUpperBound(string boundaryString);
    private static Builder ParseBuilder(string boundaryString);
    public static bool op_Equality(DateRangeBound a, DateRangeBound b);
    public static bool op_Inequality(DateRangeBound a, DateRangeBound b);
}
public enum Cassandra.DataStax.Search.DateRangePrecision : Enum {
    public byte value__;
    public static DateRangePrecision Year;
    public static DateRangePrecision Month;
    public static DateRangePrecision Day;
    public static DateRangePrecision Hour;
    public static DateRangePrecision Minute;
    public static DateRangePrecision Second;
    public static DateRangePrecision Millisecond;
}
public class Cassandra.DCAwareRoundRobinPolicy : object {
    private static string UsedHostsPerRemoteDcObsoleteMessage;
    private static Logger Logger;
    private string _localDc;
    private int _usedHostsPerRemoteDc;
    private int _maxIndex;
    private Tuple`2 modreq(System.Runtime.CompilerServices.IsVolatile) _hosts;
    private object _hostCreationLock;
    private ICluster _cluster;
    private int _index;
    public string LocalDc { get; }
    [ObsoleteAttribute("The usedHostsPerRemoteDc parameter will be removed in the next major release of the driver. DC failover should not be done in the driver, which does not have the necessary context to know what makes sense considering application semantics. See https://datastax-oss.atlassian.net/browse/CSHARP-722")]
public int UsedHostsPerRemoteDc { get; }
    public DCAwareRoundRobinPolicy(string localDc);
    [ObsoleteAttribute("The usedHostsPerRemoteDc parameter will be removed in the next major release of the driver. DC failover should not be done in the driver, which does not have the necessary context to know what makes sense considering application semantics. See https://datastax-oss.atlassian.net/browse/CSHARP-722")]
public DCAwareRoundRobinPolicy(string localDc, int usedHostsPerRemoteDc);
    private static DCAwareRoundRobinPolicy();
    public string get_LocalDc();
    public int get_UsedHostsPerRemoteDc();
    public sealed virtual void Initialize(ICluster cluster);
    private Host GetLocalHost();
    public sealed virtual HostDistance Distance(Host host);
    [IteratorStateMachineAttribute("Cassandra.DCAwareRoundRobinPolicy/<NewQueryPlan>d__19")]
public sealed virtual IEnumerable`1<Host> NewQueryPlan(string keyspace, IStatement query);
    private void ClearHosts();
    private string GetDatacenter(Host host);
    internal Tuple`2<List`1<Host>, List`1<Host>> GetHosts();
    [CompilerGeneratedAttribute]
private void <Initialize>b__16_0(Host _);
    [CompilerGeneratedAttribute]
private void <Initialize>b__16_1(Host _);
}
public class Cassandra.DecimalTypeAdapter : object {
    public sealed virtual Type GetDataType();
    public sealed virtual object ConvertFrom(Byte[] decimalBuf);
    public sealed virtual Byte[] ConvertTo(object value);
}
internal class Cassandra.DefaultAddressTranslator : object {
    public sealed virtual IPEndPoint Translate(IPEndPoint address);
}
public class Cassandra.DefaultLoadBalancingPolicy : object {
    private Host modreq(System.Runtime.CompilerServices.IsVolatile) _lastPreferredHost;
    [CompilerGeneratedAttribute]
private ILoadBalancingPolicy <ChildPolicy>k__BackingField;
    internal ILoadBalancingPolicy ChildPolicy { get; }
    internal DefaultLoadBalancingPolicy(ILoadBalancingPolicy childPolicy);
    public DefaultLoadBalancingPolicy(string localDc);
    [CompilerGeneratedAttribute]
internal ILoadBalancingPolicy get_ChildPolicy();
    public sealed virtual HostDistance Distance(Host host);
    public sealed virtual void Initialize(ICluster cluster);
    public sealed virtual IEnumerable`1<Host> NewQueryPlan(string keyspace, IStatement statement);
    [IteratorStateMachineAttribute("Cassandra.DefaultLoadBalancingPolicy/<YieldPreferred>d__9")]
private IEnumerable`1<Host> YieldPreferred(string keyspace, TargettedSimpleStatement statement);
}
public class Cassandra.DefaultRetryPolicy : object {
    public sealed virtual RetryDecision OnReadTimeout(IStatement query, ConsistencyLevel cl, int requiredResponses, int receivedResponses, bool dataRetrieved, int nbRetry);
    public sealed virtual RetryDecision OnWriteTimeout(IStatement query, ConsistencyLevel cl, string writeType, int requiredAcks, int receivedAcks, int nbRetry);
    public sealed virtual RetryDecision OnUnavailable(IStatement query, ConsistencyLevel cl, int requiredReplica, int aliveReplica, int nbRetry);
    public sealed virtual RetryDecision OnRequestError(IStatement statement, Configuration config, Exception ex, int nbRetry);
}
public static class Cassandra.Diagnostics : object {
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) UseLoggerFactory;
    internal static ILoggerFactory LoggerFactory;
    public static TraceSwitch CassandraTraceSwitch;
    [CompilerGeneratedAttribute]
private static bool <CassandraStackTraceIncluded>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <CassandraPerformanceCountersEnabled>k__BackingField;
    public static bool CassandraStackTraceIncluded { get; public set; }
    public static bool CassandraPerformanceCountersEnabled { get; public set; }
    private static Diagnostics();
    [CompilerGeneratedAttribute]
public static bool get_CassandraStackTraceIncluded();
    [CompilerGeneratedAttribute]
public static void set_CassandraStackTraceIncluded(bool value);
    [CompilerGeneratedAttribute]
public static bool get_CassandraPerformanceCountersEnabled();
    [CompilerGeneratedAttribute]
public static void set_CassandraPerformanceCountersEnabled(bool value);
    public static void AddLoggerProvider(ILoggerProvider provider);
}
[ObsoleteAttribute("This retry policy has been deprecated and will be removed in future versions. See the upgrade guide (Docs » Upgrade Guide) for more information")]
public class Cassandra.DowngradingConsistencyRetryPolicy : object {
    public static DowngradingConsistencyRetryPolicy Instance;
    private static DowngradingConsistencyRetryPolicy();
    public sealed virtual RetryDecision OnReadTimeout(IStatement query, ConsistencyLevel cl, int requiredResponses, int receivedResponses, bool dataRetrieved, int nbRetry);
    public sealed virtual RetryDecision OnWriteTimeout(IStatement query, ConsistencyLevel cl, string writeType, int requiredAcks, int receivedAcks, int nbRetry);
    public sealed virtual RetryDecision OnUnavailable(IStatement query, ConsistencyLevel cl, int requiredReplica, int aliveReplica, int nbRetry);
    private static RetryDecision MaxLikelyToWorkCl(int knownOk);
}
public class Cassandra.DriverException : Exception {
    public DriverException(string message);
    public DriverException(string message, Exception innerException);
    protected DriverException(SerializationInfo info, StreamingContext context);
}
public class Cassandra.DriverInternalError : Exception {
    public DriverInternalError(string message);
    public DriverInternalError(string message, Exception innerException);
}
public class Cassandra.Duration : ValueType {
    private static long NanosPerMicro;
    private static long NanosPerMilli;
    private static long NanosPerSecond;
    private static long NanosPerMinute;
    private static long NanosPerHour;
    private static int DaysPerWeek;
    private static int MonthsPerYear;
    private static long TicksPerDay;
    private static long NanosPerTick;
    private static Regex StandardRegex;
    private static Regex Iso8601Regex;
    private static Regex Iso8601WeekRegex;
    private static Regex Iso8601AlternateRegex;
    public static Duration Zero;
    [CompilerGeneratedAttribute]
private int <Months>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Days>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Nanoseconds>k__BackingField;
    public int Months { get; private set; }
    public int Days { get; private set; }
    public long Nanoseconds { get; private set; }
    public Duration(int months, int days, long nanoseconds);
    private static Duration();
    [CompilerGeneratedAttribute]
public int get_Months();
    [CompilerGeneratedAttribute]
private void set_Months(int value);
    [CompilerGeneratedAttribute]
public int get_Days();
    [CompilerGeneratedAttribute]
private void set_Days(int value);
    [CompilerGeneratedAttribute]
public long get_Nanoseconds();
    [CompilerGeneratedAttribute]
private void set_Nanoseconds(long value);
    public sealed virtual bool Equals(Duration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(Duration other);
    public static Duration op_Explicit(TimeSpan ts);
    public static Duration FromTimeSpan(TimeSpan timespan);
    public TimeSpan ToTimeSpan();
    public virtual string ToString();
    public string ToIsoString();
    internal string ToJavaDurationString();
    private static long Append(StringBuilder builder, long dividend, long divisor, string unit);
    public static bool op_Equality(Duration a, Duration b);
    public static bool op_Inequality(Duration a, Duration b);
    public static Duration Parse(string input);
    private static Duration ParseStandardFormat(bool isNegative, string source, string input);
    private static Duration ParseIso8601Format(bool isNegative, string source);
    private static Duration ParseIso8601AlternativeFormat(bool isNegative, string source);
    private static Duration ParseIso8601WeekFormat(bool isNegative, string source);
}
public class Cassandra.DynamicCompositeTypeAdapter : object {
    public sealed virtual Type GetDataType();
    public sealed virtual object ConvertFrom(Byte[] decimalBuf);
    public sealed virtual Byte[] ConvertTo(object value);
}
public class Cassandra.EC2MultiRegionTranslator : object {
    private static Logger Logger;
    private static EC2MultiRegionTranslator();
    public sealed virtual IPEndPoint Translate(IPEndPoint endpoint);
}
public class Cassandra.EncryptedValue : ValueType {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public object Value { get; }
    public object Key { get; }
    public EncryptedValue(object value, object encryptionKey);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public object get_Key();
    public sealed virtual bool Equals(EncryptedValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EncryptedValue left, EncryptedValue right);
    public static bool op_Inequality(EncryptedValue left, EncryptedValue right);
}
internal static class Cassandra.EndianBitConverter : object {
    internal static void SetBytes(bool isLittleEndian, Byte[] buffer, int offset, int value);
    internal static void SetBytes(bool isLittleEndian, Byte[] buffer, int offset, double value);
    internal static void SetBytes(bool isLittleEndian, Byte[] buffer, int offset, long value);
    internal static int ToInt32(bool isLittleEndian, Byte[] buffer, int offset);
    public static long ToInt64(bool isLittleEndian, Byte[] buffer, int offset);
    public static double ToDouble(bool isLittleEndian, Byte[] buffer, int offset);
}
public class Cassandra.ExecutionException : DriverException {
    [CompilerGeneratedAttribute]
private Dictionary`2<IPAddress, Exception> <InnerInnerExceptions>k__BackingField;
    public Dictionary`2<IPAddress, Exception> InnerInnerExceptions { get; private set; }
    public ExecutionException(string message, Exception innerException, Dictionary`2<IPAddress, Exception> innerInnerExceptions);
    [CompilerGeneratedAttribute]
public Dictionary`2<IPAddress, Exception> get_InnerInnerExceptions();
    [CompilerGeneratedAttribute]
private void set_InnerInnerExceptions(Dictionary`2<IPAddress, Exception> value);
}
public class Cassandra.ExecutionInfo : object {
    [CompilerGeneratedAttribute]
private IList`1<IPEndPoint> <TriedHosts>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Warnings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Byte[]> <IncomingPayload>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryTrace <QueryTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsistencyLevel <AchievedConsistency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSchemaInAgreement>k__BackingField;
    public IList`1<IPEndPoint> TriedHosts { get; private set; }
    public String[] Warnings { get; internal set; }
    public IDictionary`2<string, Byte[]> IncomingPayload { get; internal set; }
    public IPEndPoint QueriedHost { get; }
    public QueryTrace QueryTrace { get; private set; }
    public ConsistencyLevel AchievedConsistency { get; private set; }
    public bool IsSchemaInAgreement { get; private set; }
    [CompilerGeneratedAttribute]
public IList`1<IPEndPoint> get_TriedHosts();
    [CompilerGeneratedAttribute]
private void set_TriedHosts(IList`1<IPEndPoint> value);
    [CompilerGeneratedAttribute]
public String[] get_Warnings();
    [CompilerGeneratedAttribute]
internal void set_Warnings(String[] value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, Byte[]> get_IncomingPayload();
    [CompilerGeneratedAttribute]
internal void set_IncomingPayload(IDictionary`2<string, Byte[]> value);
    public IPEndPoint get_QueriedHost();
    [CompilerGeneratedAttribute]
public QueryTrace get_QueryTrace();
    [CompilerGeneratedAttribute]
private void set_QueryTrace(QueryTrace value);
    [CompilerGeneratedAttribute]
public ConsistencyLevel get_AchievedConsistency();
    [CompilerGeneratedAttribute]
private void set_AchievedConsistency(ConsistencyLevel value);
    [CompilerGeneratedAttribute]
public bool get_IsSchemaInAgreement();
    [CompilerGeneratedAttribute]
private void set_IsSchemaInAgreement(bool value);
    public Task`1<QueryTrace> GetQueryTraceAsync();
    internal void SetTriedHosts(List`1<IPEndPoint> triedHosts);
    internal void SetQueryTrace(QueryTrace queryTrace);
    internal void SetAchievedConsistency(ConsistencyLevel achievedConsistency);
    internal void SetSchemaInAgreement(bool schemaAgreement);
}
internal class Cassandra.ExecutionProfiles.ExecutionProfile : object {
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <SerialConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReadTimeoutMillis>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoadBalancingPolicy <LoadBalancingPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISpeculativeExecutionPolicy <SpeculativeExecutionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private IExtendedRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphOptions <GraphOptions>k__BackingField;
    public Nullable`1<ConsistencyLevel> ConsistencyLevel { get; private set; }
    public Nullable`1<ConsistencyLevel> SerialConsistencyLevel { get; private set; }
    public Nullable`1<int> ReadTimeoutMillis { get; private set; }
    public ILoadBalancingPolicy LoadBalancingPolicy { get; private set; }
    public ISpeculativeExecutionPolicy SpeculativeExecutionPolicy { get; private set; }
    public IExtendedRetryPolicy RetryPolicy { get; private set; }
    public GraphOptions GraphOptions { get; private set; }
    internal ExecutionProfile(Nullable`1<ConsistencyLevel> consistencyLevel, Nullable`1<ConsistencyLevel> serialConsistencyLevel, Nullable`1<int> readTimeoutMillis, ILoadBalancingPolicy loadBalancingPolicy, ISpeculativeExecutionPolicy speculativeExecutionPolicy, IExtendedRetryPolicy retryPolicy, GraphOptions graphOptions);
    internal ExecutionProfile(IExecutionProfile baseProfile, IExecutionProfile profile);
    internal ExecutionProfile(IRequestOptions requestOptions);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ConsistencyLevel> get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
private void set_ConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ConsistencyLevel> get_SerialConsistencyLevel();
    [CompilerGeneratedAttribute]
private void set_SerialConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_ReadTimeoutMillis();
    [CompilerGeneratedAttribute]
private void set_ReadTimeoutMillis(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual ILoadBalancingPolicy get_LoadBalancingPolicy();
    [CompilerGeneratedAttribute]
private void set_LoadBalancingPolicy(ILoadBalancingPolicy value);
    [CompilerGeneratedAttribute]
public sealed virtual ISpeculativeExecutionPolicy get_SpeculativeExecutionPolicy();
    [CompilerGeneratedAttribute]
private void set_SpeculativeExecutionPolicy(ISpeculativeExecutionPolicy value);
    [CompilerGeneratedAttribute]
public sealed virtual IExtendedRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
private void set_RetryPolicy(IExtendedRetryPolicy value);
    [CompilerGeneratedAttribute]
public sealed virtual GraphOptions get_GraphOptions();
    [CompilerGeneratedAttribute]
private void set_GraphOptions(GraphOptions value);
    private void Initialize(Nullable`1<ConsistencyLevel> consistencyLevel, Nullable`1<ConsistencyLevel> serialConsistencyLevel, Nullable`1<int> readTimeoutMillis, ILoadBalancingPolicy loadBalancingPolicy, ISpeculativeExecutionPolicy speculativeExecutionPolicy, IExtendedRetryPolicy retryPolicy, GraphOptions graphOptions);
}
internal class Cassandra.ExecutionProfiles.ExecutionProfileBuilder : object {
    private Nullable`1<int> _readTimeoutMillis;
    private Nullable`1<ConsistencyLevel> _consistencyLevel;
    private Nullable`1<ConsistencyLevel> _serialConsistencyLevel;
    private ILoadBalancingPolicy _loadBalancingPolicy;
    private ISpeculativeExecutionPolicy _speculativeExecutionPolicy;
    private IExtendedRetryPolicy _retryPolicy;
    private GraphOptions _graphOptions;
    public sealed virtual IExecutionProfileBuilder WithLoadBalancingPolicy(ILoadBalancingPolicy loadBalancingPolicy);
    public sealed virtual IExecutionProfileBuilder WithRetryPolicy(IExtendedRetryPolicy retryPolicy);
    public sealed virtual IExecutionProfileBuilder WithSpeculativeExecutionPolicy(ISpeculativeExecutionPolicy speculativeExecutionPolicy);
    public sealed virtual IExecutionProfileBuilder WithConsistencyLevel(ConsistencyLevel consistencyLevel);
    public sealed virtual IExecutionProfileBuilder WithSerialConsistencyLevel(ConsistencyLevel serialConsistencyLevel);
    public sealed virtual IExecutionProfileBuilder WithReadTimeoutMillis(int readTimeoutMillis);
    public sealed virtual IExecutionProfileBuilder WithGraphOptions(GraphOptions graphOptions);
    public IExecutionProfile Build();
}
internal class Cassandra.ExecutionProfiles.ExecutionProfileOptions : object {
    private Dictionary`2<string, IExecutionProfile> _profiles;
    public sealed virtual IExecutionProfileOptions WithProfile(string name, Action`1<IExecutionProfileBuilder> profileBuildAction);
    public sealed virtual IExecutionProfileOptions WithDerivedProfile(string name, string baseProfile, Action`1<IExecutionProfileBuilder> profileBuildAction);
    private IExecutionProfileOptions WithProfile(string name, IExecutionProfile profile);
    private IExecutionProfileOptions WithDerivedProfile(string name, string baseProfile, IExecutionProfile profile);
    public IReadOnlyDictionary`2<string, IExecutionProfile> GetProfiles();
    private IExecutionProfile BuildProfile(Action`1<IExecutionProfileBuilder> profileBuildAction);
}
internal interface Cassandra.ExecutionProfiles.IRequestOptions {
    public ConsistencyLevel ConsistencyLevel { get; }
    public ConsistencyLevel SerialConsistencyLevel { get; }
    public int ReadTimeoutMillis { get; }
    public ILoadBalancingPolicy LoadBalancingPolicy { get; }
    public ISpeculativeExecutionPolicy SpeculativeExecutionPolicy { get; }
    public IExtendedRetryPolicy RetryPolicy { get; }
    public GraphOptions GraphOptions { get; }
    public int PageSize { get; }
    public ITimestampGenerator TimestampGenerator { get; }
    public bool DefaultIdempotence { get; }
    public int QueryAbortTimeout { get; }
    public abstract virtual ConsistencyLevel get_ConsistencyLevel();
    public abstract virtual ConsistencyLevel get_SerialConsistencyLevel();
    public abstract virtual int get_ReadTimeoutMillis();
    public abstract virtual ILoadBalancingPolicy get_LoadBalancingPolicy();
    public abstract virtual ISpeculativeExecutionPolicy get_SpeculativeExecutionPolicy();
    public abstract virtual IExtendedRetryPolicy get_RetryPolicy();
    public abstract virtual GraphOptions get_GraphOptions();
    public abstract virtual int get_PageSize();
    public abstract virtual ITimestampGenerator get_TimestampGenerator();
    public abstract virtual bool get_DefaultIdempotence();
    public abstract virtual int get_QueryAbortTimeout();
    public abstract virtual ConsistencyLevel GetSerialConsistencyLevelOrDefault(IStatement statement);
    public abstract virtual int GetQueryAbortTimeout(int amountOfQueries);
}
internal interface Cassandra.ExecutionProfiles.IRequestOptionsMapper {
    public abstract virtual IReadOnlyDictionary`2<string, IRequestOptions> BuildRequestOptionsDictionary(IReadOnlyDictionary`2<string, IExecutionProfile> executionProfiles, Policies policies, SocketOptions socketOptions, ClientOptions clientOptions, QueryOptions queryOptions, GraphOptions graphOptions);
}
internal class Cassandra.ExecutionProfiles.RequestOptions : object {
    private IExecutionProfile _profile;
    private IExecutionProfile _defaultProfile;
    private Policies _policies;
    private SocketOptions _socketOptions;
    private QueryOptions _queryOptions;
    private ClientOptions _clientOptions;
    private GraphOptions _graphOptions;
    public ConsistencyLevel ConsistencyLevel { get; }
    public ConsistencyLevel SerialConsistencyLevel { get; }
    public int ReadTimeoutMillis { get; }
    public ILoadBalancingPolicy LoadBalancingPolicy { get; }
    public ISpeculativeExecutionPolicy SpeculativeExecutionPolicy { get; }
    public IExtendedRetryPolicy RetryPolicy { get; }
    public GraphOptions GraphOptions { get; }
    public int PageSize { get; }
    public ITimestampGenerator TimestampGenerator { get; }
    public bool DefaultIdempotence { get; }
    public int QueryAbortTimeout { get; }
    public RequestOptions(IExecutionProfile profile, IExecutionProfile defaultProfile, Policies policies, SocketOptions socketOptions, QueryOptions queryOptions, ClientOptions clientOptions);
    public RequestOptions(IExecutionProfile profile, IExecutionProfile defaultProfile, Policies policies, SocketOptions socketOptions, QueryOptions queryOptions, ClientOptions clientOptions, GraphOptions graphOptions);
    public sealed virtual ConsistencyLevel get_ConsistencyLevel();
    public sealed virtual ConsistencyLevel get_SerialConsistencyLevel();
    public sealed virtual int get_ReadTimeoutMillis();
    public sealed virtual ILoadBalancingPolicy get_LoadBalancingPolicy();
    public sealed virtual ISpeculativeExecutionPolicy get_SpeculativeExecutionPolicy();
    public sealed virtual IExtendedRetryPolicy get_RetryPolicy();
    public sealed virtual GraphOptions get_GraphOptions();
    public sealed virtual int get_PageSize();
    public sealed virtual ITimestampGenerator get_TimestampGenerator();
    public sealed virtual bool get_DefaultIdempotence();
    public sealed virtual int get_QueryAbortTimeout();
    public sealed virtual ConsistencyLevel GetSerialConsistencyLevelOrDefault(IStatement statement);
    public sealed virtual int GetQueryAbortTimeout(int amountOfQueries);
}
internal class Cassandra.ExecutionProfiles.RequestOptionsMapper : object {
    public sealed virtual IReadOnlyDictionary`2<string, IRequestOptions> BuildRequestOptionsDictionary(IReadOnlyDictionary`2<string, IExecutionProfile> executionProfiles, Policies policies, SocketOptions socketOptions, ClientOptions clientOptions, QueryOptions queryOptions, GraphOptions graphOptions);
}
public class Cassandra.ExponentialReconnectionPolicy : object {
    private long _baseDelayMs;
    private long _maxAttempts;
    private long _maxDelayMs;
    public long BaseDelayMs { get; }
    public long MaxDelayMs { get; }
    public ExponentialReconnectionPolicy(long baseDelayMs, long maxDelayMs);
    public long get_BaseDelayMs();
    public long get_MaxDelayMs();
    public sealed virtual IReconnectionSchedule NewSchedule();
    private static int LeadingZeros(long value);
}
[ExtensionAttribute]
public static class Cassandra.Extensions : object {
    [ExtensionAttribute]
public static ISessionState GetState(ISession instance);
    [ExtensionAttribute]
internal static ISessionState GetState(IInternalSession instance);
    [ExtensionAttribute]
public static CqlVector`1<T> AsCqlVector(T[] array);
    public static CqlVector`1<T> ToCqlVector(IEnumerable`1<T> enumerable);
}
public class Cassandra.FallthroughRetryPolicy : object {
    public static FallthroughRetryPolicy Instance;
    private static FallthroughRetryPolicy();
    public sealed virtual RetryDecision OnReadTimeout(IStatement query, ConsistencyLevel cl, int requiredResponses, int receivedResponses, bool dataRetrieved, int nbRetry);
    public sealed virtual RetryDecision OnWriteTimeout(IStatement query, ConsistencyLevel cl, string writeType, int requiredAcks, int receivedAcks, int nbRetry);
    public sealed virtual RetryDecision OnUnavailable(IStatement query, ConsistencyLevel cl, int requiredReplica, int aliveReplica, int nbRetry);
    public sealed virtual RetryDecision OnRequestError(IStatement statement, Configuration config, Exception ex, int nbRetry);
}
public class Cassandra.FixedReconnectionPolicy : object {
    private Int64[] _delays;
    public Int64[] Delays { get; }
    public FixedReconnectionPolicy(Int64[] delays);
    public Int64[] get_Delays();
    public sealed virtual IReconnectionSchedule NewSchedule();
}
internal class Cassandra.Frame : object {
    [CompilerGeneratedAttribute]
private FrameHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultMetadata <ResultMetadata>k__BackingField;
    public FrameHeader Header { get; }
    public Stream Body { get; }
    public ISerializer Serializer { get; }
    public ResultMetadata ResultMetadata { get; }
    public Frame(FrameHeader header, Stream body, ISerializer serializer, ResultMetadata resultMetadata);
    [CompilerGeneratedAttribute]
public FrameHeader get_Header();
    [CompilerGeneratedAttribute]
public Stream get_Body();
    [CompilerGeneratedAttribute]
public ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
public ResultMetadata get_ResultMetadata();
}
internal class Cassandra.FrameHeader : object {
    public static int MaxFrameSize;
    private byte _versionByte;
    [CompilerGeneratedAttribute]
private int <BodyLength>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Opcode>k__BackingField;
    [CompilerGeneratedAttribute]
private short <StreamId>k__BackingField;
    public int BodyLength { get; private set; }
    public HeaderFlags Flags { get; public set; }
    public byte Opcode { get; public set; }
    public short StreamId { get; public set; }
    public ProtocolVersion Version { get; }
    [CompilerGeneratedAttribute]
public int get_BodyLength();
    [CompilerGeneratedAttribute]
private void set_BodyLength(int value);
    [CompilerGeneratedAttribute]
public HeaderFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(HeaderFlags value);
    [CompilerGeneratedAttribute]
public byte get_Opcode();
    [CompilerGeneratedAttribute]
public void set_Opcode(byte value);
    [CompilerGeneratedAttribute]
public short get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(short value);
    public ProtocolVersion get_Version();
    public bool IsValidResponse();
    public static FrameHeader ParseResponseHeader(ProtocolVersion version, Byte[] buffer, int offset);
    public static FrameHeader ParseResponseHeader(ProtocolVersion version, Byte[] buffer1, Byte[] buffer2);
    public static ProtocolVersion GetProtocolVersion(Byte[] buffer);
}
internal class Cassandra.FrameParser : object {
    private static Dictionary`2<byte, Func`2<Frame, Response>> _responseHandlerFactory;
    private static FrameParser();
    public static Response Parse(Frame frame);
}
internal class Cassandra.FrameReader : object {
    private Byte[] _buffer;
    private Stream _stream;
    private ISerializer _serializer;
    internal ISerializer Serializer { get; }
    public FrameReader(Stream stream, ISerializer serializer);
    internal ISerializer get_Serializer();
    public byte ReadByte();
    public ushort ReadUInt16();
    public short ReadInt16();
    public int ReadInt32();
    public string ReadString();
    public string ReadLongString();
    private string ReadStringByLength(int length);
    public String[] ReadStringList();
    public IPEndPoint ReadInet();
    public Dictionary`2<string, Byte[]> ReadBytesMap();
    public Byte[] ReadBytes();
    public Byte[] ReadShortBytes();
    public void Read(Byte[] buffer, int offset, int count);
    internal object ReadFromBytes(Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    internal object ReadFromBytesEncrypted(string ks, string table, string column, Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
}
internal class Cassandra.FrameWriter : object {
    private MemoryStream _stream;
    private ISerializer _serializer;
    private long _offset;
    private ProtocolVersion _version;
    public long Length { get; }
    internal ISerializer Serializer { get; }
    public FrameWriter(MemoryStream stream, ISerializer serializer);
    public long get_Length();
    internal ISerializer get_Serializer();
    internal Byte[] GetBuffer();
    public void WriteByte(byte value);
    public void WriteUInt16(ushort value);
    public void WriteInt32(int value);
    public void WriteLong(long value);
    public void WriteString(string str);
    public void WriteLongString(string str);
    public void WriteStringList(ICollection`1<string> l);
    public void WriteBytes(Byte[] buffer);
    public void WriteAsBytes(object value);
    public void WriteAndEncryptAsBytes(string defaultKs, RowSetMetadata metadata, int colIdx, Object[] values, int valueIdx);
    public void WriteShortBytes(Byte[] buffer);
    public void WriteBytesMap(IDictionary`2<string, Byte[]> map);
    public void WriteFrameHeader(byte flags, short streamId, byte opCode);
    protected void Write(Byte[] buffer);
    public int Close();
}
public class Cassandra.FunctionFailureException : DriverException {
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ArgumentTypes>k__BackingField;
    public string Keyspace { get; public set; }
    public string Name { get; public set; }
    public String[] ArgumentTypes { get; public set; }
    public FunctionFailureException(string message);
    public FunctionFailureException(string message, Exception innerException);
    protected FunctionFailureException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Keyspace();
    [CompilerGeneratedAttribute]
public void set_Keyspace(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public String[] get_ArgumentTypes();
    [CompilerGeneratedAttribute]
public void set_ArgumentTypes(String[] value);
}
public class Cassandra.FunctionMetadata : object {
    private static String[] EmptyStringArray;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyspaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ArgumentNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnDesc[] <ArgumentTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CalledOnNullInput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnDesc <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deterministic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Monotonic>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <MonotonicOn>k__BackingField;
    public string Name { get; internal set; }
    public string KeyspaceName { get; internal set; }
    public String[] Signature { get; internal set; }
    public String[] ArgumentNames { get; internal set; }
    public ColumnDesc[] ArgumentTypes { get; internal set; }
    public string Body { get; internal set; }
    public bool CalledOnNullInput { get; internal set; }
    public string Language { get; internal set; }
    public ColumnDesc ReturnType { get; internal set; }
    public bool Deterministic { get; internal set; }
    public bool Monotonic { get; internal set; }
    public ICollection`1<string> MonotonicOn { get; internal set; }
    public FunctionMetadata(string name, string keyspaceName, String[] signature, String[] argumentNames, ColumnDesc[] argumentTypes, string body, bool calledOnNullInput, string language, ColumnDesc returnType);
    private static FunctionMetadata();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_KeyspaceName();
    [CompilerGeneratedAttribute]
internal void set_KeyspaceName(string value);
    [CompilerGeneratedAttribute]
public String[] get_Signature();
    [CompilerGeneratedAttribute]
internal void set_Signature(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_ArgumentNames();
    [CompilerGeneratedAttribute]
internal void set_ArgumentNames(String[] value);
    [CompilerGeneratedAttribute]
public ColumnDesc[] get_ArgumentTypes();
    [CompilerGeneratedAttribute]
internal void set_ArgumentTypes(ColumnDesc[] value);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
internal void set_Body(string value);
    [CompilerGeneratedAttribute]
public bool get_CalledOnNullInput();
    [CompilerGeneratedAttribute]
internal void set_CalledOnNullInput(bool value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
internal void set_Language(string value);
    [CompilerGeneratedAttribute]
public ColumnDesc get_ReturnType();
    [CompilerGeneratedAttribute]
internal void set_ReturnType(ColumnDesc value);
    [CompilerGeneratedAttribute]
public bool get_Deterministic();
    [CompilerGeneratedAttribute]
internal void set_Deterministic(bool value);
    [CompilerGeneratedAttribute]
public bool get_Monotonic();
    [CompilerGeneratedAttribute]
internal void set_Monotonic(bool value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_MonotonicOn();
    [CompilerGeneratedAttribute]
internal void set_MonotonicOn(ICollection`1<string> value);
}
public abstract class Cassandra.Geometry.GeometryBase : object {
    private static JsonSerializer DefaultJsonSerializer;
    protected string GeoJsonType { get; }
    protected IEnumerable GeoCoordinates { get; }
    private static GeometryBase();
    protected virtual string get_GeoJsonType();
    protected abstract virtual IEnumerable get_GeoCoordinates();
    protected ReadOnlyCollection`1<T> AsReadOnlyCollection(IList`1<T> elements, Func`2<T, T> itemCallback);
    protected int CombineHashCode(IEnumerable`1<T> items);
    public virtual string ToGeoJson();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual void WriteJson(JsonWriter writer, JsonSerializer serializer);
    internal static FormatException InvalidFormatException(string textValue);
}
[JsonConverterAttribute("Cassandra.Geometry.LineStringJsonConverter")]
public class Cassandra.Geometry.LineString : GeometryBase {
    private static Regex WktRegex;
    [CompilerGeneratedAttribute]
private IList`1<Point> <Points>k__BackingField;
    public IList`1<Point> Points { get; private set; }
    protected IEnumerable GeoCoordinates { get; }
    public LineString(Point[] points);
    protected LineString(SerializationInfo info, StreamingContext context);
    internal LineString(JObject obj);
    public LineString(IList`1<Point> points);
    private static LineString();
    [CompilerGeneratedAttribute]
public IList`1<Point> get_Points();
    [CompilerGeneratedAttribute]
private void set_Points(IList`1<Point> value);
    protected virtual IEnumerable get_GeoCoordinates();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static LineString Parse(string textValue);
    internal static Point[] ParseSegments(string textValue);
}
internal class Cassandra.Geometry.LineStringJsonConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[JsonConverterAttribute("Cassandra.Geometry.PointJsonConverter")]
public class Cassandra.Geometry.Point : GeometryBase {
    private static Regex WktRegex;
    [CompilerGeneratedAttribute]
private double <X>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Y>k__BackingField;
    public double X { get; private set; }
    public double Y { get; private set; }
    protected IEnumerable GeoCoordinates { get; }
    public Point(double x, double y);
    protected Point(SerializationInfo info, StreamingContext context);
    internal Point(JObject obj);
    private static Point();
    [CompilerGeneratedAttribute]
public double get_X();
    [CompilerGeneratedAttribute]
private void set_X(double value);
    [CompilerGeneratedAttribute]
public double get_Y();
    [CompilerGeneratedAttribute]
private void set_Y(double value);
    protected virtual IEnumerable get_GeoCoordinates();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static Point Parse(string textValue);
    public sealed virtual int CompareTo(Point other);
}
internal class Cassandra.Geometry.PointJsonConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[JsonConverterAttribute("Cassandra.Geometry.PolygonJsonConverter")]
public class Cassandra.Geometry.Polygon : GeometryBase {
    private static Regex WktRegex;
    private IList`1<IList`1<Point>> _ringsWithOrderedPoints;
    [CompilerGeneratedAttribute]
private IList`1<IList`1<Point>> <Rings>k__BackingField;
    public IList`1<IList`1<Point>> Rings { get; private set; }
    protected IEnumerable GeoCoordinates { get; }
    public Polygon(Point[] points);
    public Polygon(IList`1[] points);
    public Polygon(IList`1<IList`1<Point>> rings);
    protected Polygon(SerializationInfo info, StreamingContext context);
    internal Polygon(JObject obj);
    private static Polygon();
    [CompilerGeneratedAttribute]
public IList`1<IList`1<Point>> get_Rings();
    [CompilerGeneratedAttribute]
private void set_Rings(IList`1<IList`1<Point>> value);
    protected virtual IEnumerable get_GeoCoordinates();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static Polygon Parse(string textValue);
    [CompilerGeneratedAttribute]
private IList`1<Point> <.ctor>b__11_0(IList`1<Point> r);
    [CompilerGeneratedAttribute]
private int <GetHashCode>b__15_0(IList`1<Point> r);
}
internal class Cassandra.Geometry.PolygonJsonConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public enum Cassandra.GraphProtocol : Enum {
    public int value__;
    public static GraphProtocol GraphSON1;
    public static GraphProtocol GraphSON2;
    public static GraphProtocol GraphSON3;
}
[ExtensionAttribute]
internal static class Cassandra.GraphProtocolExtensions : object {
    private static IDictionary`2<GraphProtocol, string> EnumToNameMap;
    private static GraphProtocolExtensions();
    [ExtensionAttribute]
public static string GetInternalRepresentation(Nullable`1<GraphProtocol> version);
    [ExtensionAttribute]
public static string GetInternalRepresentation(GraphProtocol version);
}
[FlagsAttribute]
internal enum Cassandra.HeaderFlags : Enum {
    public byte value__;
    public static HeaderFlags None;
    public static HeaderFlags Compression;
    public static HeaderFlags Tracing;
    public static HeaderFlags CustomPayload;
    public static HeaderFlags Warning;
    public static HeaderFlags UseBeta;
}
internal static class Cassandra.Helpers.AssemblyHelpers : object {
    private static Logger Logger;
    private static AssemblyHelpers();
    public static Assembly GetAssembly(Type type);
    public static Version GetVersionPrefix(Type type);
    public static Version GetVersionPrefix(Assembly assembly);
    public static string GetAssemblyInformationalVersion(Assembly assembly);
    public static string GetAssemblyInformationalVersion(Type type);
    public static string GetAssemblyTitle(Type type);
    public static Assembly GetEntryAssembly();
    private static Assembly GetEntryAssemblyByStacktrace();
    private static Assembly GetEntryAssemblyByMainModule();
}
[ExtensionAttribute]
internal static class Cassandra.Helpers.CollectionHelpers : object {
    [ExtensionAttribute]
internal static void CreateOrAdd(IDictionary`2<TKey, ICollection`1<TElement>> dictionary, TKey key, TElement elementToAdd);
    [ExtensionAttribute]
internal static void CreateIfDoesNotExist(IDictionary`2<TKey, ICollection`1<TElement>> dictionary, TKey key);
}
internal class Cassandra.Helpers.DefaultRandom : object {
    private Random _random;
    public sealed virtual int Next();
}
internal interface Cassandra.Helpers.IRandom {
    public abstract virtual int Next();
}
internal static class Cassandra.Helpers.PlatformHelper : object {
    private static Logger Logger;
    private static PlatformHelper();
    public static bool IsKerberosSupported();
    public static string GetTargetFramework();
    public static CpuInfo GetCpuInfo();
    public static CpuInfo GetWmiCpuInfo();
    public static CpuInfo GetLinuxProcCpuInfo();
}
internal class Cassandra.Helpers.ReferenceEqualityComparer`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
public class Cassandra.Host : object {
    private static Logger Logger;
    private long _isUpNow;
    private int _distance;
    private static IReadOnlyCollection`1<string> WorkloadsDefault;
    [CompilerGeneratedAttribute]
private Action`1<Host> Down;
    [CompilerGeneratedAttribute]
private Action`1<Host> Up;
    [CompilerGeneratedAttribute]
private Action Remove;
    [CompilerGeneratedAttribute]
private Action`2<HostDistance, HostDistance> DistanceChanged;
    [CompilerGeneratedAttribute]
private IPEndPoint <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <HostId>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Datacenter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Rack>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <CassandraVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Workloads>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <DseVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IContactPoint <ContactPoint>k__BackingField;
    public bool IsUp { get; }
    public bool IsConsiderablyUp { get; }
    public IPEndPoint Address { get; }
    public Guid HostId { get; private set; }
    internal IEnumerable`1<string> Tokens { get; private set; }
    public string Datacenter { get; internal set; }
    public string Rack { get; private set; }
    public Version CassandraVersion { get; private set; }
    public IReadOnlyCollection`1<string> Workloads { get; private set; }
    public Version DseVersion { get; private set; }
    internal IContactPoint ContactPoint { get; }
    public Host(IPEndPoint address, IReconnectionPolicy reconnectionPolicy);
    internal Host(IPEndPoint address, IContactPoint contactPoint);
    private static Host();
    [CompilerGeneratedAttribute]
internal void add_Down(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void remove_Down(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void add_Up(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void remove_Up(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void add_Remove(Action value);
    [CompilerGeneratedAttribute]
internal void remove_Remove(Action value);
    [CompilerGeneratedAttribute]
internal void add_DistanceChanged(Action`2<HostDistance, HostDistance> value);
    [CompilerGeneratedAttribute]
internal void remove_DistanceChanged(Action`2<HostDistance, HostDistance> value);
    public bool get_IsUp();
    public bool get_IsConsiderablyUp();
    [CompilerGeneratedAttribute]
public IPEndPoint get_Address();
    [CompilerGeneratedAttribute]
public Guid get_HostId();
    [CompilerGeneratedAttribute]
private void set_HostId(Guid value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_Tokens();
    [CompilerGeneratedAttribute]
private void set_Tokens(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Datacenter();
    [CompilerGeneratedAttribute]
internal void set_Datacenter(string value);
    [CompilerGeneratedAttribute]
public string get_Rack();
    [CompilerGeneratedAttribute]
private void set_Rack(string value);
    [CompilerGeneratedAttribute]
public Version get_CassandraVersion();
    [CompilerGeneratedAttribute]
private void set_CassandraVersion(Version value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_Workloads();
    [CompilerGeneratedAttribute]
private void set_Workloads(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public Version get_DseVersion();
    [CompilerGeneratedAttribute]
private void set_DseVersion(Version value);
    [CompilerGeneratedAttribute]
internal IContactPoint get_ContactPoint();
    public bool SetDown();
    public bool BringUpIfDown();
    public void SetAsRemoved();
    internal void SetInfo(IRow row);
    private void SetDseInfo(IRow row);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Host other);
    public virtual bool Equals(object obj);
    internal void SetDistance(HostDistance distance);
    internal HostDistance GetDistanceUnsafe();
}
public enum Cassandra.HostDistance : Enum {
    public int value__;
    public static HostDistance Local;
    public static HostDistance Remote;
    public static HostDistance Ignored;
}
internal class Cassandra.Hosts : object {
    private CopyOnWriteDictionary`2<IPEndPoint, Host> _hosts;
    [CompilerGeneratedAttribute]
private Action`1<Host> Down;
    [CompilerGeneratedAttribute]
private Action`1<Host> Up;
    [CompilerGeneratedAttribute]
private Action`1<Host> Added;
    [CompilerGeneratedAttribute]
private Action`1<Host> Removed;
    internal int Count { get; }
    [CompilerGeneratedAttribute]
internal void add_Down(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void remove_Down(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void add_Up(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void remove_Up(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void add_Added(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void remove_Added(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void add_Removed(Action`1<Host> value);
    [CompilerGeneratedAttribute]
internal void remove_Removed(Action`1<Host> value);
    internal int get_Count();
    public bool TryGet(IPEndPoint endpoint, Host& host);
    public ICollection`1<Host> ToCollection();
    public Host Add(IPEndPoint key);
    public Host Add(IPEndPoint key, IContactPoint contactPoint);
    private void OnHostDown(Host sender);
    private void OnHostUp(Host sender);
    public void RemoveIfExists(IPEndPoint ep);
    public IEnumerable`1<IPEndPoint> AllEndPointsToCollection();
    public sealed virtual IEnumerator`1<Host> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Cassandra.HostsEventArgs : EventArgs {
    public IPEndPoint Address;
    public Kind What;
}
public class Cassandra.HostsEventHandler : MulticastDelegate {
    public HostsEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, HostsEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, HostsEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface Cassandra.IAddressTranslator {
    public abstract virtual IPEndPoint Translate(IPEndPoint address);
}
public interface Cassandra.IAuthenticator {
    public abstract virtual Byte[] InitialResponse();
    public abstract virtual Byte[] EvaluateChallenge(Byte[] challenge);
}
internal interface Cassandra.IAuthInfoProvider {
    public abstract virtual IDictionary`2<string, string> GetAuthInfos(IPEndPoint host);
}
public interface Cassandra.IAuthProvider {
    public abstract virtual IAuthenticator NewAuthenticator(IPEndPoint host);
}
public interface Cassandra.IAuthProviderNamed {
    public abstract virtual void SetName(string name);
}
public interface Cassandra.ICluster {
    public Metadata Metadata { get; }
    public Configuration Configuration { get; }
    public abstract virtual Metadata get_Metadata();
    public abstract virtual Configuration get_Configuration();
    public abstract virtual ICollection`1<Host> AllHosts();
    [CompilerGeneratedAttribute]
public abstract virtual void add_HostAdded(Action`1<Host> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_HostAdded(Action`1<Host> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_HostRemoved(Action`1<Host> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_HostRemoved(Action`1<Host> value);
    public abstract virtual ISession Connect();
    public abstract virtual ISession Connect(string keyspace);
    public abstract virtual Task`1<ISession> ConnectAsync();
    public abstract virtual Task`1<ISession> ConnectAsync(string keyspace);
    public abstract virtual Host GetHost(IPEndPoint address);
    public abstract virtual ICollection`1<Host> GetReplicas(Byte[] partitionKey);
    public abstract virtual ICollection`1<Host> GetReplicas(string keyspace, Byte[] partitionKey);
    public abstract virtual void Shutdown(int timeoutMs);
    public abstract virtual Task ShutdownAsync(int timeoutMs);
    public abstract virtual Task`1<bool> RefreshSchemaAsync(string keyspace, string table);
    public abstract virtual bool RefreshSchema(string keyspace, string table);
}
internal interface Cassandra.ICollectionColumnInfo {
    public abstract virtual ColumnDesc GetChildType();
}
public interface Cassandra.IColumnEncryptionPolicy {
    public abstract virtual Byte[] Encrypt(object key, Byte[] objBytes);
    public abstract virtual Byte[] Decrypt(object key, Byte[] encryptedBytes);
    public abstract virtual Nullable`1<ColumnEncryptionMetadata> GetColumnEncryptionMetadata(string ks, string table, string col);
}
public interface Cassandra.IColumnInfo {
}
public class Cassandra.IdempotenceAwareRetryPolicy : object {
    private IExtendedRetryPolicy _extendedChildPolicy;
    [CompilerGeneratedAttribute]
private IRetryPolicy <ChildPolicy>k__BackingField;
    public IRetryPolicy ChildPolicy { get; }
    public IdempotenceAwareRetryPolicy(IRetryPolicy childPolicy);
    [CompilerGeneratedAttribute]
public IRetryPolicy get_ChildPolicy();
    public sealed virtual RetryDecision OnReadTimeout(IStatement stmt, ConsistencyLevel cl, int requiredResponses, int receivedResponses, bool dataRetrieved, int nbRetry);
    public sealed virtual RetryDecision OnWriteTimeout(IStatement stmt, ConsistencyLevel cl, string writeType, int requiredAcks, int receivedAcks, int nbRetry);
    public sealed virtual RetryDecision OnUnavailable(IStatement stmt, ConsistencyLevel cl, int requiredReplica, int aliveReplica, int nbRetry);
    public sealed virtual RetryDecision OnRequestError(IStatement stmt, Configuration config, Exception ex, int nbRetry);
}
public interface Cassandra.IExecutionProfile {
    public Nullable`1<ConsistencyLevel> ConsistencyLevel { get; }
    public ILoadBalancingPolicy LoadBalancingPolicy { get; }
    public Nullable`1<int> ReadTimeoutMillis { get; }
    public IExtendedRetryPolicy RetryPolicy { get; }
    public Nullable`1<ConsistencyLevel> SerialConsistencyLevel { get; }
    public ISpeculativeExecutionPolicy SpeculativeExecutionPolicy { get; }
    public GraphOptions GraphOptions { get; }
    public abstract virtual Nullable`1<ConsistencyLevel> get_ConsistencyLevel();
    public abstract virtual ILoadBalancingPolicy get_LoadBalancingPolicy();
    public abstract virtual Nullable`1<int> get_ReadTimeoutMillis();
    public abstract virtual IExtendedRetryPolicy get_RetryPolicy();
    public abstract virtual Nullable`1<ConsistencyLevel> get_SerialConsistencyLevel();
    public abstract virtual ISpeculativeExecutionPolicy get_SpeculativeExecutionPolicy();
    public abstract virtual GraphOptions get_GraphOptions();
}
public interface Cassandra.IExecutionProfileBuilder {
    public abstract virtual IExecutionProfileBuilder WithLoadBalancingPolicy(ILoadBalancingPolicy loadBalancingPolicy);
    public abstract virtual IExecutionProfileBuilder WithRetryPolicy(IExtendedRetryPolicy retryPolicy);
    public abstract virtual IExecutionProfileBuilder WithSpeculativeExecutionPolicy(ISpeculativeExecutionPolicy speculativeExecutionPolicy);
    public abstract virtual IExecutionProfileBuilder WithConsistencyLevel(ConsistencyLevel consistencyLevel);
    public abstract virtual IExecutionProfileBuilder WithSerialConsistencyLevel(ConsistencyLevel serialConsistencyLevel);
    public abstract virtual IExecutionProfileBuilder WithReadTimeoutMillis(int readTimeoutMillis);
    public abstract virtual IExecutionProfileBuilder WithGraphOptions(GraphOptions graphOptions);
}
public interface Cassandra.IExecutionProfileOptions {
    public abstract virtual IExecutionProfileOptions WithProfile(string name, Action`1<IExecutionProfileBuilder> profileBuildAction);
    public abstract virtual IExecutionProfileOptions WithDerivedProfile(string name, string baseProfile, Action`1<IExecutionProfileBuilder> profileBuildAction);
}
public interface Cassandra.IExtendedRetryPolicy {
    public abstract virtual RetryDecision OnRequestError(IStatement statement, Configuration config, Exception ex, int nbRetry);
}
public interface Cassandra.IFrameCompressor {
    public abstract virtual Stream Decompress(Stream stream);
}
public interface Cassandra.IInitializer {
    public ICollection`1<IPEndPoint> ContactPoints { get; }
    public abstract virtual ICollection`1<IPEndPoint> get_ContactPoints();
    public abstract virtual Configuration GetConfiguration();
}
[DefaultMemberAttribute("Item")]
internal interface Cassandra.IInternalCqlVector {
    public object Item { get; public set; }
    public int Count { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int get_Count();
    public abstract virtual Type GetSubType();
    public abstract virtual void SetArray(object array);
    public abstract virtual Array GetArray();
}
public interface Cassandra.ILoadBalancingPolicy {
    public abstract virtual void Initialize(ICluster cluster);
    public abstract virtual HostDistance Distance(Host host);
    public abstract virtual IEnumerable`1<Host> NewQueryPlan(string keyspace, IStatement query);
}
internal interface Cassandra.IMetadataQueryProvider {
    public ProtocolVersion ProtocolVersion { get; }
    public IConnectionEndPoint EndPoint { get; }
    public IPEndPoint LocalAddress { get; }
    public ISerializerManager Serializer { get; }
    public abstract virtual ProtocolVersion get_ProtocolVersion();
    public abstract virtual IConnectionEndPoint get_EndPoint();
    public abstract virtual IPEndPoint get_LocalAddress();
    public abstract virtual ISerializerManager get_Serializer();
    public abstract virtual Task`1<IEnumerable`1<IRow>> QueryAsync(string cqlQuery, bool retry);
    public abstract virtual Task`1<Response> SendQueryRequestAsync(string cqlQuery, bool retry, QueryProtocolOptions queryProtocolOptions);
    public abstract virtual Task`1<Response> UnsafeSendQueryRequestAsync(string cqlQuery, QueryProtocolOptions queryProtocolOptions);
    public abstract virtual IEnumerable`1<IRow> Query(string cqlQuery, bool retry);
}
public class Cassandra.IndexMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Options>k__BackingField;
    public string Name { get; private set; }
    public string Target { get; private set; }
    public IndexKind Kind { get; private set; }
    public IDictionary`2<string, string> Options { get; private set; }
    public IndexMetadata(string name, string target, IndexKind kind, IDictionary`2<string, string> options);
    private static IndexKind GetKindByName(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(string value);
    [CompilerGeneratedAttribute]
public IndexKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(IndexKind value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(IDictionary`2<string, string> value);
    internal static IndexMetadata FromTableColumn(TableColumn c);
    internal static IndexMetadata FromRow(IRow row);
}
public class Cassandra.InitFatalErrorException : Exception {
    private static string ExceptionMessage;
    public InitFatalErrorException(Exception innerException);
}
public class Cassandra.InvalidConfigurationInQueryException : InvalidQueryException {
    public InvalidConfigurationInQueryException(string message);
}
public class Cassandra.InvalidQueryException : QueryValidationException {
    public InvalidQueryException(string message);
    public InvalidQueryException(string message, Exception innerException);
}
public class Cassandra.InvalidTypeException : DriverException {
    [CompilerGeneratedAttribute]
private object <ReceivedType>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ExpectedType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParamName>k__BackingField;
    public object ReceivedType { get; private set; }
    public Object[] ExpectedType { get; private set; }
    public string ParamName { get; private set; }
    public InvalidTypeException(string msg);
    public InvalidTypeException(string msg, Exception cause);
    public InvalidTypeException(string paramName, object receivedType, Object[] expectedType);
    [CompilerGeneratedAttribute]
public object get_ReceivedType();
    [CompilerGeneratedAttribute]
private void set_ReceivedType(object value);
    [CompilerGeneratedAttribute]
public Object[] get_ExpectedType();
    [CompilerGeneratedAttribute]
private void set_ExpectedType(Object[] value);
    [CompilerGeneratedAttribute]
public string get_ParamName();
    [CompilerGeneratedAttribute]
private void set_ParamName(string value);
}
internal interface Cassandra.IOutput {
    public Nullable`1<Guid> TraceId { get; }
    public abstract virtual Nullable`1<Guid> get_TraceId();
}
public interface Cassandra.IReconnectionPolicy {
    public abstract virtual IReconnectionSchedule NewSchedule();
}
public interface Cassandra.IReconnectionSchedule {
    public abstract virtual long NextDelayMs();
}
public interface Cassandra.IRequestTracker {
    public abstract virtual Task OnStartAsync(SessionRequestInfo sessionRequestInfo);
    public abstract virtual Task OnSuccessAsync(SessionRequestInfo sessionRequestInfo);
    public abstract virtual Task OnErrorAsync(SessionRequestInfo sessionRequestInfo, Exception ex);
    public abstract virtual Task OnNodeSuccessAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public abstract virtual Task OnNodeErrorAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo, Exception ex);
    public abstract virtual Task OnNodeAborted(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public abstract virtual Task OnNodeStartAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
}
public interface Cassandra.IRetryPolicy {
    public abstract virtual RetryDecision OnReadTimeout(IStatement query, ConsistencyLevel cl, int requiredResponses, int receivedResponses, bool dataRetrieved, int nbRetry);
    public abstract virtual RetryDecision OnWriteTimeout(IStatement query, ConsistencyLevel cl, string writeType, int requiredAcks, int receivedAcks, int nbRetry);
    public abstract virtual RetryDecision OnUnavailable(IStatement query, ConsistencyLevel cl, int requiredReplica, int aliveReplica, int nbRetry);
}
internal interface Cassandra.IRow {
    public abstract virtual T GetValue(string name);
    public abstract virtual bool ContainsColumn(string name);
    public abstract virtual bool IsNull(string name);
    public abstract virtual T GetValue(int index);
    public abstract virtual CqlColumn GetColumn(string name);
}
public class Cassandra.IsBootstrappingException : QueryValidationException {
    public IsBootstrappingException(string message);
}
internal interface Cassandra.ISchemaParser {
    public abstract virtual Task`1<KeyspaceMetadata> GetKeyspaceAsync(string name);
    public abstract virtual Task`1<IEnumerable`1<KeyspaceMetadata>> GetKeyspacesAsync(bool retry);
    public abstract virtual Task`1<TableMetadata> GetTableAsync(string keyspaceName, string tableName);
    public abstract virtual Task`1<MaterializedViewMetadata> GetViewAsync(string keyspaceName, string viewName);
    public abstract virtual Task`1<ICollection`1<string>> GetTableNamesAsync(string keyspaceName);
    public abstract virtual Task`1<ICollection`1<string>> GetKeyspacesNamesAsync();
    public abstract virtual Task`1<FunctionMetadata> GetFunctionAsync(string keyspaceName, string functionName, string signatureString);
    public abstract virtual Task`1<AggregateMetadata> GetAggregateAsync(string keyspaceName, string aggregateName, string signatureString);
    public abstract virtual Task`1<UdtColumnInfo> GetUdtDefinitionAsync(string keyspaceName, string typeName);
    public abstract virtual string ComputeFunctionSignatureString(String[] signature);
    public abstract virtual Task`1<QueryTrace> GetQueryTraceAsync(QueryTrace trace, HashedWheelTimer timer);
}
public interface Cassandra.ISession {
    public int BinaryProtocolVersion { get; }
    public ICluster Cluster { get; }
    public bool IsDisposed { get; }
    public string Keyspace { get; }
    public UdtMappingDefinitions UserDefinedTypes { get; }
    public string SessionName { get; }
    public abstract virtual int get_BinaryProtocolVersion();
    public abstract virtual ICluster get_Cluster();
    public abstract virtual bool get_IsDisposed();
    public abstract virtual string get_Keyspace();
    public abstract virtual UdtMappingDefinitions get_UserDefinedTypes();
    public abstract virtual string get_SessionName();
    public abstract virtual IAsyncResult BeginExecute(IStatement statement, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginExecute(string cqlQuery, ConsistencyLevel consistency, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginPrepare(string cqlQuery, AsyncCallback callback, object state);
    public abstract virtual void ChangeKeyspace(string keyspaceName);
    public abstract virtual void CreateKeyspace(string keyspaceName, Dictionary`2<string, string> replication, bool durableWrites);
    public abstract virtual void CreateKeyspaceIfNotExists(string keyspaceName, Dictionary`2<string, string> replication, bool durableWrites);
    public abstract virtual void DeleteKeyspace(string keyspaceName);
    public abstract virtual void DeleteKeyspaceIfExists(string keyspaceName);
    public abstract virtual RowSet EndExecute(IAsyncResult ar);
    public abstract virtual PreparedStatement EndPrepare(IAsyncResult ar);
    public abstract virtual RowSet Execute(IStatement statement, string executionProfileName);
    public abstract virtual RowSet Execute(IStatement statement);
    public abstract virtual RowSet Execute(string cqlQuery);
    public abstract virtual RowSet Execute(string cqlQuery, string executionProfileName);
    public abstract virtual RowSet Execute(string cqlQuery, ConsistencyLevel consistency);
    public abstract virtual RowSet Execute(string cqlQuery, int pageSize);
    public abstract virtual Task`1<RowSet> ExecuteAsync(IStatement statement);
    public abstract virtual Task`1<RowSet> ExecuteAsync(IStatement statement, string executionProfileName);
    public abstract virtual PreparedStatement Prepare(string cqlQuery);
    public abstract virtual PreparedStatement Prepare(string cqlQuery, IDictionary`2<string, Byte[]> customPayload);
    public abstract virtual PreparedStatement Prepare(string cqlQuery, string keyspace);
    public abstract virtual PreparedStatement Prepare(string cqlQuery, string keyspace, IDictionary`2<string, Byte[]> customPayload);
    public abstract virtual Task`1<PreparedStatement> PrepareAsync(string cqlQuery);
    public abstract virtual Task`1<PreparedStatement> PrepareAsync(string cqlQuery, IDictionary`2<string, Byte[]> customPayload);
    public abstract virtual Task`1<PreparedStatement> PrepareAsync(string cqlQuery, string keyspace);
    public abstract virtual Task`1<PreparedStatement> PrepareAsync(string cqlQuery, string keyspace, IDictionary`2<string, Byte[]> customPayload);
    public abstract virtual IDriverMetrics GetMetrics();
    public abstract virtual GraphResultSet ExecuteGraph(IGraphStatement statement);
    public abstract virtual Task`1<GraphResultSet> ExecuteGraphAsync(IGraphStatement statement);
    public abstract virtual GraphResultSet ExecuteGraph(IGraphStatement statement, string executionProfileName);
    public abstract virtual Task`1<GraphResultSet> ExecuteGraphAsync(IGraphStatement statement, string executionProfileName);
    public abstract virtual Task ShutdownAsync();
    [ObsoleteAttribute("Method deprecated. The driver internally waits for schema agreement when there is an schema change. See ProtocolOptions.MaxSchemaAgreementWaitSeconds for more info.")]
public abstract virtual void WaitForSchemaAgreement(RowSet rs);
    [ObsoleteAttribute("Method deprecated. The driver internally waits for schema agreement when there is an schema change. See ProtocolOptions.MaxSchemaAgreementWaitSeconds for more info.")]
public abstract virtual bool WaitForSchemaAgreement(IPEndPoint forHost);
}
public interface Cassandra.ISessionState {
    public abstract virtual IReadOnlyCollection`1<Host> GetConnectedHosts();
    public abstract virtual int GetOpenConnections(Host host);
    public abstract virtual int GetInFlightQueries(Host host);
}
public interface Cassandra.ISpeculativeExecutionPlan {
    public abstract virtual long NextExecution(Host lastQueried);
}
public interface Cassandra.ISpeculativeExecutionPolicy {
    public abstract virtual void Initialize(ICluster cluster);
    public abstract virtual ISpeculativeExecutionPlan NewPlan(string keyspace, IStatement statement);
}
public interface Cassandra.IStatement {
    public bool AutoPage { get; }
    public Nullable`1<ConsistencyLevel> ConsistencyLevel { get; }
    public bool IsTracing { get; }
    public int PageSize { get; }
    public Byte[] PagingState { get; }
    public Object[] QueryValues { get; }
    public Nullable`1<DateTimeOffset> Timestamp { get; }
    public int ReadTimeoutMillis { get; }
    public IRetryPolicy RetryPolicy { get; }
    public RoutingKey RoutingKey { get; }
    public ConsistencyLevel SerialConsistencyLevel { get; }
    public bool SkipMetadata { get; }
    public IDictionary`2<string, Byte[]> OutgoingPayload { get; }
    public Nullable`1<bool> IsIdempotent { get; }
    public string Keyspace { get; }
    public abstract virtual bool get_AutoPage();
    public abstract virtual Nullable`1<ConsistencyLevel> get_ConsistencyLevel();
    public abstract virtual IStatement DisableTracing();
    public abstract virtual IStatement EnableTracing(bool enable);
    public abstract virtual bool get_IsTracing();
    public abstract virtual int get_PageSize();
    public abstract virtual Byte[] get_PagingState();
    public abstract virtual Object[] get_QueryValues();
    public abstract virtual Nullable`1<DateTimeOffset> get_Timestamp();
    public abstract virtual int get_ReadTimeoutMillis();
    public abstract virtual IRetryPolicy get_RetryPolicy();
    public abstract virtual RoutingKey get_RoutingKey();
    public abstract virtual ConsistencyLevel get_SerialConsistencyLevel();
    public abstract virtual bool get_SkipMetadata();
    public abstract virtual IDictionary`2<string, Byte[]> get_OutgoingPayload();
    public abstract virtual Nullable`1<bool> get_IsIdempotent();
    public abstract virtual string get_Keyspace();
    public abstract virtual IStatement ExecutingAs(string userOrRole);
    public abstract virtual IStatement SetAutoPage(bool autoPage);
    public abstract virtual IStatement SetConsistencyLevel(Nullable`1<ConsistencyLevel> consistency);
    public abstract virtual IStatement SetPageSize(int pageSize);
    public abstract virtual IStatement SetPagingState(Byte[] pagingState);
    public abstract virtual IStatement SetReadTimeoutMillis(int timeout);
    public abstract virtual IStatement SetRetryPolicy(IRetryPolicy policy);
    public abstract virtual IStatement SetSerialConsistencyLevel(ConsistencyLevel serialConsistency);
    public abstract virtual IStatement SetTimestamp(DateTimeOffset value);
    public abstract virtual IStatement SetOutgoingPayload(IDictionary`2<string, Byte[]> payload);
    public abstract virtual IStatement SetIdempotence(bool value);
}
public interface Cassandra.ITimestampGenerator {
    public abstract virtual long Next();
}
internal interface Cassandra.IToken {
}
public interface Cassandra.ITypeAdapter {
    public abstract virtual Type GetDataType();
    public abstract virtual object ConvertFrom(Byte[] decimalBuf);
    public abstract virtual Byte[] ConvertTo(object value);
}
public class Cassandra.KeyspaceMetadata : object {
    private ConcurrentDictionary`2<string, TableMetadata> _tables;
    private ConcurrentDictionary`2<string, MaterializedViewMetadata> _views;
    private ConcurrentDictionary`2<Tuple`2<string, string>, FunctionMetadata> _functions;
    private ConcurrentDictionary`2<Tuple`2<string, string>, AggregateMetadata> _aggregates;
    private Metadata _parent;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DurableWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StrategyClass>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, int> <Replication>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ReplicationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GraphEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private IReplicationStrategy <Strategy>k__BackingField;
    public string Name { get; }
    public bool DurableWrites { get; }
    public string StrategyClass { get; }
    public IDictionary`2<string, int> Replication { get; }
    private IDictionary`2<string, string> ReplicationOptions { get; }
    public bool IsVirtual { get; }
    public string GraphEngine { get; }
    internal IReplicationStrategy Strategy { get; }
    internal KeyspaceMetadata(Metadata parent, string name, bool durableWrites, string strategyClass, IDictionary`2<string, string> replicationOptions, IReplicationStrategyFactory replicationStrategyFactory, string graphEngine, bool isVirtual);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_DurableWrites();
    [CompilerGeneratedAttribute]
public string get_StrategyClass();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, int> get_Replication();
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> get_ReplicationOptions();
    [CompilerGeneratedAttribute]
public bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public string get_GraphEngine();
    [CompilerGeneratedAttribute]
internal IReplicationStrategy get_Strategy();
    public TableMetadata GetTableMetadata(string tableName);
    [AsyncStateMachineAttribute("Cassandra.KeyspaceMetadata/<GetTableMetadataAsync>d__31")]
internal Task`1<TableMetadata> GetTableMetadataAsync(string tableName);
    public MaterializedViewMetadata GetMaterializedViewMetadata(string viewName);
    [AsyncStateMachineAttribute("Cassandra.KeyspaceMetadata/<GetMaterializedViewMetadataAsync>d__33")]
private Task`1<MaterializedViewMetadata> GetMaterializedViewMetadataAsync(string viewName);
    internal void ClearTableMetadata(string tableName);
    internal void ClearViewMetadata(string name);
    internal void ClearFunction(string name, String[] signature);
    internal void ClearAggregate(string name, String[] signature);
    public IEnumerable`1<TableMetadata> GetTablesMetadata();
    public ICollection`1<string> GetTablesNames();
    public string ExportAsString();
    public string AsCqlQuery();
    internal UdtColumnInfo GetUdtDefinition(string typeName);
    internal Task`1<UdtColumnInfo> GetUdtDefinitionAsync(string typeName);
    public FunctionMetadata GetFunction(string functionName, String[] signature);
    [AsyncStateMachineAttribute("Cassandra.KeyspaceMetadata/<GetFunctionAsync>d__45")]
private Task`1<FunctionMetadata> GetFunctionAsync(string functionName, String[] signature);
    public AggregateMetadata GetAggregate(string aggregateName, String[] signature);
    [AsyncStateMachineAttribute("Cassandra.KeyspaceMetadata/<GetAggregateAsync>d__47")]
private Task`1<AggregateMetadata> GetAggregateAsync(string aggregateName, String[] signature);
    private static Tuple`2<string, string> GetFunctionKey(string name, String[] signature);
    private IDictionary`2<string, int> ConvertReplicationOptionsToLegacy(IDictionary`2<string, ReplicationFactor> replicationOptions);
    private Dictionary`2<string, ReplicationFactor> ParseReplicationFactors(IDictionary`2<string, string> replicationOptions);
}
public enum Cassandra.KeyType : Enum {
    public int value__;
    public static KeyType None;
    public static KeyType Partition;
    public static KeyType Clustering;
    public static KeyType SecondaryIndex;
}
public class Cassandra.ListColumnInfo : object {
    [CompilerGeneratedAttribute]
private ColumnTypeCode <ValueTypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IColumnInfo <ValueTypeInfo>k__BackingField;
    public ColumnTypeCode ValueTypeCode { get; public set; }
    public IColumnInfo ValueTypeInfo { get; public set; }
    [CompilerGeneratedAttribute]
public ColumnTypeCode get_ValueTypeCode();
    [CompilerGeneratedAttribute]
public void set_ValueTypeCode(ColumnTypeCode value);
    [CompilerGeneratedAttribute]
public IColumnInfo get_ValueTypeInfo();
    [CompilerGeneratedAttribute]
public void set_ValueTypeInfo(IColumnInfo value);
    private sealed virtual override ColumnDesc Cassandra.ICollectionColumnInfo.GetChildType();
}
public class Cassandra.LocalDate : object {
    private static Int32[] DaysToMonth;
    private static Int32[] DaysToMonthLeap;
    private static long DateCenter;
    private static long DaysFromYear0ToUnixEpoch;
    private static long DaysFromYear0March1stToUnixEpoch;
    private static Regex RegexInteger;
    private static string BadFormatMessage;
    [CompilerGeneratedAttribute]
private UInt32 <DaysSinceEpochCentered>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Day>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Month>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Year>k__BackingField;
    internal UInt32 DaysSinceEpochCentered { get; }
    public int Day { get; public set; }
    public int Month { get; public set; }
    public int Year { get; public set; }
    internal LocalDate(UInt32 days);
    public LocalDate(int year, int month, int day);
    private static LocalDate();
    [CompilerGeneratedAttribute]
internal UInt32 get_DaysSinceEpochCentered();
    [CompilerGeneratedAttribute]
public int get_Day();
    [CompilerGeneratedAttribute]
public void set_Day(int value);
    [CompilerGeneratedAttribute]
public int get_Month();
    [CompilerGeneratedAttribute]
public void set_Month(int value);
    [CompilerGeneratedAttribute]
public int get_Year();
    [CompilerGeneratedAttribute]
public void set_Year(int value);
    private void InitializeFromDaysSinceEpoch(long daysSinceEpoch);
    private static long DaysSinceYearZero(int year);
    public static int DaysSinceJan1(int year, int month, int day);
    private static long LeapDays(long year);
    private static bool IsLeapYear(int year);
    public sealed virtual int CompareTo(LocalDate other);
    public sealed virtual bool Equals(LocalDate other);
    public static LocalDate Parse(string value);
    public DateTimeOffset ToDateTimeOffset();
    public virtual string ToString();
    public static bool op_Equality(LocalDate value1, LocalDate value2);
    public static bool op_GreaterThanOrEqual(LocalDate value1, LocalDate value2);
    public static bool op_GreaterThan(LocalDate value1, LocalDate value2);
    public static bool op_LessThanOrEqual(LocalDate value1, LocalDate value2);
    public static bool op_LessThan(LocalDate value1, LocalDate value2);
    public static bool op_Inequality(LocalDate value1, LocalDate value2);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Cassandra.LocalTime : object {
    private static long MaxNanos;
    private static long NanosInMilliseconds;
    private static long NanosInSeconds;
    private static long NanosInMinutes;
    private static long NanosInHour;
    [CompilerGeneratedAttribute]
private long <TotalNanoseconds>k__BackingField;
    public long TotalNanoseconds { get; private set; }
    public int Hour { get; }
    public int Minute { get; }
    public int Second { get; }
    public int Nanoseconds { get; }
    public LocalTime(long totalNanoseconds);
    public LocalTime(int hour, int minute, int second, int nanosecond);
    [CompilerGeneratedAttribute]
public long get_TotalNanoseconds();
    [CompilerGeneratedAttribute]
private void set_TotalNanoseconds(long value);
    public int get_Hour();
    public int get_Minute();
    public int get_Second();
    public int get_Nanoseconds();
    public static LocalTime Parse(string value);
    public virtual string ToString();
    public sealed virtual int CompareTo(LocalTime other);
    public sealed virtual bool Equals(LocalTime other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(LocalTime value1, LocalTime value2);
    public static bool op_GreaterThanOrEqual(LocalTime value1, LocalTime value2);
    public static bool op_GreaterThan(LocalTime value1, LocalTime value2);
    public static bool op_LessThanOrEqual(LocalTime value1, LocalTime value2);
    public static bool op_LessThan(LocalTime value1, LocalTime value2);
    public static bool op_Inequality(LocalTime value1, LocalTime value2);
}
public class Cassandra.Logger : object {
    private ILoggerHandler _loggerHandler;
    public Logger(Type type);
    internal Logger(ILoggerHandler handler);
    public void Error(Exception ex);
    public void Error(string message, Exception ex);
    public void Error(string message, Object[] args);
    public void Warning(string message, Object[] args);
    public void Info(string message, Object[] args);
    public void Verbose(string message, Object[] args);
}
public class Cassandra.LoggingRetryPolicy : object {
    private Logger _logger;
    private IExtendedRetryPolicy _extendedPolicy;
    [CompilerGeneratedAttribute]
private IRetryPolicy <ChildPolicy>k__BackingField;
    public IRetryPolicy ChildPolicy { get; }
    public LoggingRetryPolicy(IRetryPolicy policy);
    [CompilerGeneratedAttribute]
public IRetryPolicy get_ChildPolicy();
    public sealed virtual RetryDecision OnReadTimeout(IStatement query, ConsistencyLevel cl, int requiredResponses, int receivedResponses, bool dataRetrieved, int nbRetry);
    public sealed virtual RetryDecision OnWriteTimeout(IStatement query, ConsistencyLevel cl, string writeType, int requiredAcks, int receivedAcks, int nbRetry);
    public sealed virtual RetryDecision OnUnavailable(IStatement query, ConsistencyLevel cl, int requiredReplica, int aliveReplica, int nbRetry);
    private static ConsistencyLevel CL(ConsistencyLevel cl, RetryDecision decision);
    public sealed virtual RetryDecision OnRequestError(IStatement statement, Configuration config, Exception ex, int nbRetry);
}
internal class Cassandra.M3PToken : object {
    public static TokenFactory Factory;
    private long _value;
    internal M3PToken(long value);
    private static M3PToken();
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Cassandra.MapColumnInfo : object {
    [CompilerGeneratedAttribute]
private ColumnTypeCode <KeyTypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IColumnInfo <KeyTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnTypeCode <ValueTypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IColumnInfo <ValueTypeInfo>k__BackingField;
    public ColumnTypeCode KeyTypeCode { get; public set; }
    public IColumnInfo KeyTypeInfo { get; public set; }
    public ColumnTypeCode ValueTypeCode { get; public set; }
    public IColumnInfo ValueTypeInfo { get; public set; }
    [CompilerGeneratedAttribute]
public ColumnTypeCode get_KeyTypeCode();
    [CompilerGeneratedAttribute]
public void set_KeyTypeCode(ColumnTypeCode value);
    [CompilerGeneratedAttribute]
public IColumnInfo get_KeyTypeInfo();
    [CompilerGeneratedAttribute]
public void set_KeyTypeInfo(IColumnInfo value);
    [CompilerGeneratedAttribute]
public ColumnTypeCode get_ValueTypeCode();
    [CompilerGeneratedAttribute]
public void set_ValueTypeCode(ColumnTypeCode value);
    [CompilerGeneratedAttribute]
public IColumnInfo get_ValueTypeInfo();
    [CompilerGeneratedAttribute]
public void set_ValueTypeInfo(IColumnInfo value);
}
public class Cassandra.Mapping.AppliedInfo`1 : object {
    [CompilerGeneratedAttribute]
private bool <Applied>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Existing>k__BackingField;
    public bool Applied { get; public set; }
    public T Existing { get; public set; }
    public AppliedInfo`1(bool applied);
    public AppliedInfo`1(T existing);
    [CompilerGeneratedAttribute]
public bool get_Applied();
    [CompilerGeneratedAttribute]
public void set_Applied(bool value);
    [CompilerGeneratedAttribute]
public T get_Existing();
    [CompilerGeneratedAttribute]
public void set_Existing(T value);
    internal static AppliedInfo`1<T> FromRowSet(MapperFactory mapperFactory, string cql, RowSet rs);
}
internal class Cassandra.Mapping.Attributes.AttributeBasedColumnDefinition : object {
    private MemberInfo _memberInfo;
    private Type _memberInfoType;
    private string _columnName;
    private Type _columnType;
    private bool _ignore;
    private bool _isExplicitlyDefined;
    private bool _secondaryIndex;
    private bool _isCounter;
    private bool _isStatic;
    private bool _isFrozen;
    private bool _hasFrozenKey;
    private bool _hasFrozenValue;
    private MemberInfo Cassandra.Mapping.IColumnDefinition.MemberInfo { get; }
    private Type Cassandra.Mapping.IColumnDefinition.MemberInfoType { get; }
    private string Cassandra.Mapping.IColumnDefinition.ColumnName { get; }
    private Type Cassandra.Mapping.IColumnDefinition.ColumnType { get; }
    private bool Cassandra.Mapping.IColumnDefinition.Ignore { get; }
    private bool Cassandra.Mapping.IColumnDefinition.IsExplicitlyDefined { get; }
    private bool Cassandra.Mapping.IColumnDefinition.SecondaryIndex { get; }
    private bool Cassandra.Mapping.IColumnDefinition.IsCounter { get; }
    private bool Cassandra.Mapping.IColumnDefinition.IsStatic { get; }
    private bool Cassandra.Mapping.IColumnDefinition.IsFrozen { get; }
    private bool Cassandra.Mapping.IColumnDefinition.HasFrozenKey { get; }
    private bool Cassandra.Mapping.IColumnDefinition.HasFrozenValue { get; }
    public AttributeBasedColumnDefinition(FieldInfo fieldInfo);
    public AttributeBasedColumnDefinition(PropertyInfo propertyInfo);
    private AttributeBasedColumnDefinition(MemberInfo memberInfo);
    private sealed virtual override MemberInfo Cassandra.Mapping.IColumnDefinition.get_MemberInfo();
    private sealed virtual override Type Cassandra.Mapping.IColumnDefinition.get_MemberInfoType();
    private sealed virtual override string Cassandra.Mapping.IColumnDefinition.get_ColumnName();
    private sealed virtual override Type Cassandra.Mapping.IColumnDefinition.get_ColumnType();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_Ignore();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_IsExplicitlyDefined();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_SecondaryIndex();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_IsCounter();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_IsStatic();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_IsFrozen();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_HasFrozenKey();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_HasFrozenValue();
    private static bool HasAttribute(MemberInfo memberInfo, Type attributeType);
}
internal class Cassandra.Mapping.Attributes.AttributeBasedTypeDefinition : object {
    private static BindingFlags PublicInstanceBindingFlags;
    [CompilerGeneratedAttribute]
private Type <PocoType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyspaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PartitionKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Tuple`2[] <ClusteringKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompactStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowFiltering>k__BackingField;
    public Type PocoType { get; private set; }
    public string TableName { get; private set; }
    public string KeyspaceName { get; private set; }
    public bool ExplicitColumns { get; internal set; }
    public String[] PartitionKeys { get; private set; }
    public Tuple`2[] ClusteringKeys { get; private set; }
    public bool CaseSensitive { get; private set; }
    public bool CompactStorage { get; private set; }
    public bool AllowFiltering { get; private set; }
    public AttributeBasedTypeDefinition(Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_PocoType();
    [CompilerGeneratedAttribute]
private void set_PocoType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TableName();
    [CompilerGeneratedAttribute]
private void set_TableName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyspaceName();
    [CompilerGeneratedAttribute]
private void set_KeyspaceName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ExplicitColumns();
    [CompilerGeneratedAttribute]
internal void set_ExplicitColumns(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PartitionKeys();
    [CompilerGeneratedAttribute]
private void set_PartitionKeys(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Tuple`2[] get_ClusteringKeys();
    [CompilerGeneratedAttribute]
private void set_ClusteringKeys(Tuple`2[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
private void set_CaseSensitive(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CompactStorage();
    [CompilerGeneratedAttribute]
private void set_CompactStorage(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowFiltering();
    [CompilerGeneratedAttribute]
private void set_AllowFiltering(bool value);
    private sealed virtual override IColumnDefinition Cassandra.Mapping.ITypeDefinition.GetColumnDefinition(FieldInfo field);
    private sealed virtual override IColumnDefinition Cassandra.Mapping.ITypeDefinition.GetColumnDefinition(PropertyInfo property);
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.ClusteringKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SortOrder <ClusteringSortOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public SortOrder ClusteringSortOrder { get; public set; }
    public int Index { get; public set; }
    public string Name { get; public set; }
    public ClusteringKeyAttribute(int index);
    public ClusteringKeyAttribute(int index, SortOrder order);
    [CompilerGeneratedAttribute]
public SortOrder get_ClusteringSortOrder();
    [CompilerGeneratedAttribute]
public void set_ClusteringSortOrder(SortOrder value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.ColumnAttribute : Attribute {
    private string _name;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Name { get; }
    public Type Type { get; public set; }
    public ColumnAttribute(string name);
    public string get_Name();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.CounterAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.FrozenAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.FrozenKeyAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.FrozenValueAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.IgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.PartitionKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; public set; }
    public PartitionKeyAttribute(int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.SecondaryIndexAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class Cassandra.Mapping.Attributes.StaticColumnAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Cassandra.Mapping.Attributes.TableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompactStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowFiltering>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitColumns>k__BackingField;
    public string Name { get; public set; }
    public bool CompactStorage { get; public set; }
    public bool AllowFiltering { get; public set; }
    public bool CaseSensitive { get; public set; }
    public string Keyspace { get; public set; }
    public bool ExplicitColumns { get; public set; }
    public TableAttribute(string tableName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_CompactStorage();
    [CompilerGeneratedAttribute]
public void set_CompactStorage(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowFiltering();
    [CompilerGeneratedAttribute]
public void set_AllowFiltering(bool value);
    [CompilerGeneratedAttribute]
public bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public void set_CaseSensitive(bool value);
    [CompilerGeneratedAttribute]
public string get_Keyspace();
    [CompilerGeneratedAttribute]
public void set_Keyspace(string value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitColumns();
    [CompilerGeneratedAttribute]
public void set_ExplicitColumns(bool value);
}
public class Cassandra.Mapping.ColumnMap : object {
    private MemberInfo _memberInfo;
    private Type _memberInfoType;
    private string _columnName;
    private Type _columnType;
    private bool _ignore;
    private bool _isExplicitlyDefined;
    private bool _secondaryIndex;
    private bool _isCounter;
    private bool _isStatic;
    private bool _isFrozen;
    private bool _hasFrozenKey;
    private bool _hasFrozenValue;
    private MemberInfo Cassandra.Mapping.IColumnDefinition.MemberInfo { get; }
    private Type Cassandra.Mapping.IColumnDefinition.MemberInfoType { get; }
    private string Cassandra.Mapping.IColumnDefinition.ColumnName { get; }
    private Type Cassandra.Mapping.IColumnDefinition.ColumnType { get; }
    private bool Cassandra.Mapping.IColumnDefinition.Ignore { get; }
    private bool Cassandra.Mapping.IColumnDefinition.IsExplicitlyDefined { get; }
    private bool Cassandra.Mapping.IColumnDefinition.SecondaryIndex { get; }
    private bool Cassandra.Mapping.IColumnDefinition.IsCounter { get; }
    private bool Cassandra.Mapping.IColumnDefinition.IsStatic { get; }
    private bool Cassandra.Mapping.IColumnDefinition.IsFrozen { get; }
    private bool Cassandra.Mapping.IColumnDefinition.HasFrozenKey { get; }
    private bool Cassandra.Mapping.IColumnDefinition.HasFrozenValue { get; }
    public ColumnMap(MemberInfo memberInfo, Type memberInfoType, bool isExplicitlyDefined);
    private sealed virtual override MemberInfo Cassandra.Mapping.IColumnDefinition.get_MemberInfo();
    private sealed virtual override Type Cassandra.Mapping.IColumnDefinition.get_MemberInfoType();
    private sealed virtual override string Cassandra.Mapping.IColumnDefinition.get_ColumnName();
    private sealed virtual override Type Cassandra.Mapping.IColumnDefinition.get_ColumnType();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_Ignore();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_IsExplicitlyDefined();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_SecondaryIndex();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_IsCounter();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_IsStatic();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_IsFrozen();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_HasFrozenKey();
    private sealed virtual override bool Cassandra.Mapping.IColumnDefinition.get_HasFrozenValue();
    public ColumnMap Ignore();
    public ColumnMap WithName(string columnName);
    public ColumnMap WithDbType(Type type);
    public ColumnMap WithDbType();
    public ColumnMap WithSecondaryIndex();
    public ColumnMap AsCounter();
    public ColumnMap AsStatic();
    public ColumnMap AsFrozen();
    public ColumnMap WithFrozenKey();
    public ColumnMap WithFrozenValue();
}
public class Cassandra.Mapping.Cql : object {
    [CompilerGeneratedAttribute]
private string <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecutionProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private CqlQueryOptions <QueryOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoPage>k__BackingField;
    public string Statement { get; private set; }
    public Object[] Arguments { get; private set; }
    public string ExecutionProfile { get; private set; }
    internal CqlQueryOptions QueryOptions { get; private set; }
    internal bool AutoPage { get; internal set; }
    public Cql(string cql, Object[] args);
    private Cql(string cql, Object[] args, CqlQueryOptions queryOptions);
    [CompilerGeneratedAttribute]
public string get_Statement();
    [CompilerGeneratedAttribute]
private void set_Statement(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(Object[] value);
    [CompilerGeneratedAttribute]
public string get_ExecutionProfile();
    [CompilerGeneratedAttribute]
private void set_ExecutionProfile(string value);
    [CompilerGeneratedAttribute]
internal CqlQueryOptions get_QueryOptions();
    [CompilerGeneratedAttribute]
private void set_QueryOptions(CqlQueryOptions value);
    [CompilerGeneratedAttribute]
internal bool get_AutoPage();
    [CompilerGeneratedAttribute]
internal void set_AutoPage(bool value);
    public Cql WithOptions(Action`1<CqlQueryOptions> options);
    public Cql WithExecutionProfile(string executionProfile);
    internal void SetStatement(string statement);
    public static Cql New(string cql, Object[] args);
    public static Cql New();
    internal static Cql New(string cql, Object[] args, CqlQueryOptions queryOptions);
}
internal class Cassandra.Mapping.CqlBatch : object {
    private MapperFactory _mapperFactory;
    private CqlGenerator _cqlGenerator;
    private List`1<Cql> _statements;
    [CompilerGeneratedAttribute]
private BatchType <BatchType>k__BackingField;
    [CompilerGeneratedAttribute]
private CqlQueryOptions <Options>k__BackingField;
    public IEnumerable`1<Cql> Statements { get; }
    public BatchType BatchType { get; private set; }
    public CqlQueryOptions Options { get; private set; }
    public CqlBatch(MapperFactory mapperFactory, CqlGenerator cqlGenerator);
    public CqlBatch(MapperFactory mapperFactory, CqlGenerator cqlGenerator, BatchType type);
    public sealed virtual IEnumerable`1<Cql> get_Statements();
    [CompilerGeneratedAttribute]
public sealed virtual BatchType get_BatchType();
    [CompilerGeneratedAttribute]
private void set_BatchType(BatchType value);
    [CompilerGeneratedAttribute]
public sealed virtual CqlQueryOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(CqlQueryOptions value);
    public sealed virtual void Insert(T poco, CqlQueryOptions queryOptions);
    public sealed virtual void Insert(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual void Insert(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public sealed virtual void InsertIfNotExists(T poco, CqlQueryOptions queryOptions);
    public sealed virtual void InsertIfNotExists(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual void InsertIfNotExists(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    private void Insert(bool ifNotExists, bool insertNulls, T poco, CqlQueryOptions queryOptions, Nullable`1<int> ttl);
    public sealed virtual void Update(T poco, CqlQueryOptions queryOptions);
    public sealed virtual void Update(string cql, Object[] args);
    public sealed virtual void Update(Cql cql);
    public sealed virtual void Delete(T poco, CqlQueryOptions queryOptions);
    public sealed virtual void Delete(string cql, Object[] args);
    public sealed virtual void Delete(Cql cql);
    public sealed virtual void Execute(string cql, Object[] args);
    public sealed virtual void Execute(Cql cql);
    public sealed virtual ICqlBatch WithOptions(Action`1<CqlQueryOptions> action);
    public sealed virtual TDatabase ConvertCqlArgument(TValue value);
}
public class Cassandra.Mapping.CqlQueryOptions : object {
    internal static CqlQueryOptions None;
    private Nullable`1<ConsistencyLevel> _consistencyLevel;
    private Nullable`1<bool> _tracingEnabled;
    private Nullable`1<int> _pageSize;
    private IRetryPolicy _retryPolicy;
    private Nullable`1<ConsistencyLevel> _serialConsistencyLevel;
    private Byte[] _pagingState;
    private Nullable`1<DateTimeOffset> _timestamp;
    private bool _noPrepare;
    internal bool NoPrepare { get; }
    private static CqlQueryOptions();
    internal bool get_NoPrepare();
    public CqlQueryOptions SetConsistencyLevel(ConsistencyLevel consistencyLevel);
    public CqlQueryOptions EnableTracing();
    public CqlQueryOptions DisableTracing();
    public CqlQueryOptions SetPageSize(int pageSize);
    public CqlQueryOptions SetPagingState(Byte[] pagingState);
    public CqlQueryOptions SetRetryPolicy(IRetryPolicy retryPolicy);
    public CqlQueryOptions SetSerialConsistencyLevel(ConsistencyLevel consistencyLevel);
    public CqlQueryOptions DoNotPrepare();
    public CqlQueryOptions SetTimestamp(Nullable`1<DateTimeOffset> timestamp);
    internal virtual void CopyOptionsToStatement(IStatement statement);
    public static CqlQueryOptions New();
}
public interface Cassandra.Mapping.IColumnDefinition {
    public MemberInfo MemberInfo { get; }
    public Type MemberInfoType { get; }
    public string ColumnName { get; }
    public Type ColumnType { get; }
    public bool Ignore { get; }
    public bool IsExplicitlyDefined { get; }
    public bool SecondaryIndex { get; }
    public bool IsCounter { get; }
    public bool IsStatic { get; }
    public bool IsFrozen { get; }
    public bool HasFrozenKey { get; }
    public bool HasFrozenValue { get; }
    public abstract virtual MemberInfo get_MemberInfo();
    public abstract virtual Type get_MemberInfoType();
    public abstract virtual string get_ColumnName();
    public abstract virtual Type get_ColumnType();
    public abstract virtual bool get_Ignore();
    public abstract virtual bool get_IsExplicitlyDefined();
    public abstract virtual bool get_SecondaryIndex();
    public abstract virtual bool get_IsCounter();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsFrozen();
    public abstract virtual bool get_HasFrozenKey();
    public abstract virtual bool get_HasFrozenValue();
}
public interface Cassandra.Mapping.ICqlBatch {
    public IEnumerable`1<Cql> Statements { get; }
    public BatchType BatchType { get; }
    public CqlQueryOptions Options { get; }
    public abstract virtual IEnumerable`1<Cql> get_Statements();
    public abstract virtual BatchType get_BatchType();
    public abstract virtual CqlQueryOptions get_Options();
    public abstract virtual ICqlBatch WithOptions(Action`1<CqlQueryOptions> action);
    public abstract virtual TDatabase ConvertCqlArgument(TValue value);
    public abstract virtual void InsertIfNotExists(T poco, CqlQueryOptions queryOptions);
    public abstract virtual void InsertIfNotExists(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public abstract virtual void InsertIfNotExists(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
}
public interface Cassandra.Mapping.ICqlQueryAsyncClient {
    public abstract virtual Task`1<IEnumerable`1<T>> FetchAsync(CqlQueryOptions queryOptions);
    public abstract virtual Task`1<IEnumerable`1<T>> FetchAsync(string cql, Object[] args);
    public abstract virtual Task`1<IEnumerable`1<T>> FetchAsync(Cql cql);
    public abstract virtual Task`1<IPage`1<T>> FetchPageAsync(Cql cql);
    public abstract virtual Task`1<IPage`1<T>> FetchPageAsync(CqlQueryOptions queryOptions);
    public abstract virtual Task`1<IPage`1<T>> FetchPageAsync(int pageSize, Byte[] pagingState, string query, Object[] args);
    public abstract virtual Task`1<T> SingleAsync(string cql, Object[] args);
    public abstract virtual Task`1<T> SingleAsync(Cql cql);
    public abstract virtual Task`1<T> SingleOrDefaultAsync(string cql, Object[] args);
    public abstract virtual Task`1<T> SingleOrDefaultAsync(Cql cql);
    public abstract virtual Task`1<T> FirstAsync(string cql, Object[] args);
    public abstract virtual Task`1<T> FirstAsync(Cql cql);
    public abstract virtual Task`1<T> FirstOrDefaultAsync(string cql, Object[] args);
    public abstract virtual Task`1<T> FirstOrDefaultAsync(Cql cql);
}
public interface Cassandra.Mapping.ICqlQueryClient {
    public abstract virtual IEnumerable`1<T> Fetch(CqlQueryOptions queryOptions);
    public abstract virtual IEnumerable`1<T> Fetch(string cql, Object[] args);
    public abstract virtual IEnumerable`1<T> Fetch(Cql cql);
    public abstract virtual IPage`1<T> FetchPage(Cql cql);
    public abstract virtual IPage`1<T> FetchPage(CqlQueryOptions queryOptions);
    public abstract virtual IPage`1<T> FetchPage(int pageSize, Byte[] pagingState, string query, Object[] args);
    public abstract virtual T Single(string cql, Object[] args);
    public abstract virtual T Single(Cql cql);
    public abstract virtual T SingleOrDefault(string cql, Object[] args);
    public abstract virtual T SingleOrDefault(Cql cql);
    public abstract virtual T First(string cql, Object[] args);
    public abstract virtual T First(Cql cql);
    public abstract virtual T FirstOrDefault(string cql, Object[] args);
    public abstract virtual T FirstOrDefault(Cql cql);
}
public interface Cassandra.Mapping.ICqlWriteAsyncClient {
    public abstract virtual Task InsertAsync(T poco, CqlQueryOptions queryOptions);
    public abstract virtual Task InsertAsync(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public abstract virtual Task InsertAsync(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public abstract virtual Task UpdateAsync(T poco, CqlQueryOptions queryOptions);
    public abstract virtual Task UpdateAsync(string cql, Object[] args);
    public abstract virtual Task UpdateAsync(Cql cql);
    public abstract virtual Task DeleteAsync(T poco, CqlQueryOptions queryOptions);
    public abstract virtual Task DeleteAsync(string cql, Object[] args);
    public abstract virtual Task DeleteAsync(Cql cql);
    public abstract virtual Task ExecuteAsync(string cql, Object[] args);
    public abstract virtual Task ExecuteAsync(Cql cql);
}
public interface Cassandra.Mapping.ICqlWriteClient {
    public abstract virtual void Insert(T poco, CqlQueryOptions queryOptions);
    public abstract virtual void Insert(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public abstract virtual void Insert(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public abstract virtual void Update(T poco, CqlQueryOptions queryOptions);
    public abstract virtual void Update(string cql, Object[] args);
    public abstract virtual void Update(Cql cql);
    public abstract virtual void Delete(T poco, CqlQueryOptions queryOptions);
    public abstract virtual void Delete(string cql, Object[] args);
    public abstract virtual void Delete(Cql cql);
    public abstract virtual void Execute(string cql, Object[] args);
    public abstract virtual void Execute(Cql cql);
}
public interface Cassandra.Mapping.IMapper {
    public abstract virtual ICqlBatch CreateBatch();
    public abstract virtual ICqlBatch CreateBatch(BatchType batchType);
    public abstract virtual void Execute(ICqlBatch batch);
    public abstract virtual void Execute(ICqlBatch batch, string executionProfile);
    public abstract virtual Task ExecuteAsync(ICqlBatch batch);
    public abstract virtual Task ExecuteAsync(ICqlBatch batch, string executionProfile);
    public abstract virtual TDatabase ConvertCqlArgument(TValue value);
    public abstract virtual void Insert(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public abstract virtual void Insert(T poco, string executionProfile, bool insertNulls, CqlQueryOptions queryOptions);
    public abstract virtual void Insert(T poco, string executionProfile, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public abstract virtual Task InsertAsync(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public abstract virtual Task InsertAsync(T poco, string executionProfile, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public abstract virtual Task InsertAsync(T poco, string executionProfile, bool insertNulls, CqlQueryOptions queryOptions);
    public abstract virtual void Update(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public abstract virtual Task UpdateAsync(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public abstract virtual void Delete(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public abstract virtual Task DeleteAsync(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public abstract virtual AppliedInfo`1<T> DeleteIf(string cql, Object[] args);
    public abstract virtual AppliedInfo`1<T> DeleteIf(Cql cql);
    public abstract virtual Task`1<AppliedInfo`1<T>> DeleteIfAsync(string cql, Object[] args);
    public abstract virtual Task`1<AppliedInfo`1<T>> DeleteIfAsync(Cql cql);
    public abstract virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, CqlQueryOptions queryOptions);
    public abstract virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public abstract virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public abstract virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, string executionProfile, bool insertNulls, CqlQueryOptions queryOptions);
    public abstract virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public abstract virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, string executionProfile, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public abstract virtual AppliedInfo`1<T> InsertIfNotExists(T poco, CqlQueryOptions queryOptions);
    public abstract virtual AppliedInfo`1<T> InsertIfNotExists(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public abstract virtual AppliedInfo`1<T> InsertIfNotExists(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public abstract virtual AppliedInfo`1<T> InsertIfNotExists(T poco, string executionProfile, bool insertNulls, CqlQueryOptions queryOptions);
    public abstract virtual AppliedInfo`1<T> InsertIfNotExists(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public abstract virtual AppliedInfo`1<T> InsertIfNotExists(T poco, string executionProfile, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public abstract virtual AppliedInfo`1<T> UpdateIf(Cql cql);
    public abstract virtual AppliedInfo`1<T> UpdateIf(string cql, Object[] args);
    public abstract virtual Task`1<AppliedInfo`1<T>> UpdateIfAsync(Cql cql);
    public abstract virtual Task`1<AppliedInfo`1<T>> UpdateIfAsync(string cql, Object[] args);
    public abstract virtual Task`1<AppliedInfo`1<T>> ExecuteConditionalAsync(ICqlBatch batch);
    public abstract virtual Task`1<AppliedInfo`1<T>> ExecuteConditionalAsync(ICqlBatch batch, string executionProfile);
    public abstract virtual AppliedInfo`1<T> ExecuteConditional(ICqlBatch batch);
    public abstract virtual AppliedInfo`1<T> ExecuteConditional(ICqlBatch batch, string executionProfile);
}
public interface Cassandra.Mapping.IPage`1 {
    public Byte[] CurrentPagingState { get; }
    public Byte[] PagingState { get; }
    public abstract virtual Byte[] get_CurrentPagingState();
    public abstract virtual Byte[] get_PagingState();
}
internal interface Cassandra.Mapping.IPocoData {
    public bool CaseSensitive { get; }
    public abstract virtual bool get_CaseSensitive();
}
public interface Cassandra.Mapping.ITypeDefinition {
    public Type PocoType { get; }
    public string TableName { get; }
    public string KeyspaceName { get; }
    public bool ExplicitColumns { get; }
    public String[] PartitionKeys { get; }
    public Tuple`2[] ClusteringKeys { get; }
    public bool CaseSensitive { get; }
    public bool CompactStorage { get; }
    public bool AllowFiltering { get; }
    public abstract virtual Type get_PocoType();
    public abstract virtual string get_TableName();
    public abstract virtual string get_KeyspaceName();
    public abstract virtual bool get_ExplicitColumns();
    public abstract virtual String[] get_PartitionKeys();
    public abstract virtual Tuple`2[] get_ClusteringKeys();
    public abstract virtual bool get_CaseSensitive();
    public abstract virtual bool get_CompactStorage();
    public abstract virtual bool get_AllowFiltering();
    public abstract virtual IColumnDefinition GetColumnDefinition(FieldInfo field);
    public abstract virtual IColumnDefinition GetColumnDefinition(PropertyInfo property);
}
public class Cassandra.Mapping.Map`1 : object {
    private Type _pocoType;
    private Dictionary`2<string, ColumnMap> _columnMaps;
    private string _tableName;
    private bool _explicitColumns;
    private bool _caseSensitive;
    private String[] _partitionKeyColumns;
    private MemberInfo[] _partitionKeyColumnMembers;
    private List`1<Tuple`2<string, SortOrder>> _clusteringKeyColumns;
    private List`1<Tuple`2<MemberInfo, SortOrder>> _clusteringKeyColumnMembers;
    private bool _compactStorage;
    private string _keyspaceName;
    private Type Cassandra.Mapping.ITypeDefinition.PocoType { get; }
    private string Cassandra.Mapping.ITypeDefinition.TableName { get; }
    private string Cassandra.Mapping.ITypeDefinition.KeyspaceName { get; }
    private bool Cassandra.Mapping.ITypeDefinition.ExplicitColumns { get; }
    private bool Cassandra.Mapping.ITypeDefinition.CaseSensitive { get; }
    private bool Cassandra.Mapping.ITypeDefinition.AllowFiltering { get; }
    private bool Cassandra.Mapping.ITypeDefinition.CompactStorage { get; }
    private String[] Cassandra.Mapping.ITypeDefinition.PartitionKeys { get; }
    private Tuple`2[] Cassandra.Mapping.ITypeDefinition.ClusteringKeys { get; }
    private sealed virtual override Type Cassandra.Mapping.ITypeDefinition.get_PocoType();
    private sealed virtual override string Cassandra.Mapping.ITypeDefinition.get_TableName();
    private sealed virtual override string Cassandra.Mapping.ITypeDefinition.get_KeyspaceName();
    private sealed virtual override bool Cassandra.Mapping.ITypeDefinition.get_ExplicitColumns();
    private sealed virtual override bool Cassandra.Mapping.ITypeDefinition.get_CaseSensitive();
    private sealed virtual override bool Cassandra.Mapping.ITypeDefinition.get_AllowFiltering();
    private sealed virtual override bool Cassandra.Mapping.ITypeDefinition.get_CompactStorage();
    private sealed virtual override String[] Cassandra.Mapping.ITypeDefinition.get_PartitionKeys();
    private sealed virtual override Tuple`2[] Cassandra.Mapping.ITypeDefinition.get_ClusteringKeys();
    public Map`1<TPoco> TableName(string tableName);
    public Map`1<TPoco> PartitionKey(String[] columnNames);
    public Map`1<TPoco> PartitionKey(Expression`1[] columns);
    public Map`1<TPoco> ClusteringKey(String[] columnNames);
    public Map`1<TPoco> ClusteringKey(Tuple`2[] columnNames);
    public Map`1<TPoco> ClusteringKey(Expression`1<Func`2<TPoco, object>> column, SortOrder order);
    public Map`1<TPoco> ClusteringKey(Expression`1<Func`2<TPoco, object>> column);
    public Map`1<TPoco> ExplicitColumns();
    public Map`1<TPoco> CaseSensitive();
    public Map`1<TPoco> Column(Expression`1<Func`2<TPoco, TProp>> column, Action`1<ColumnMap> columnConfig);
    public Map`1<TPoco> KeyspaceName(string name);
    public Map`1<TPoco> CompactStorage();
    public Map`1<TPoco> Column(Expression`1<Func`2<TPoco, TProp>> column);
    private sealed virtual override IColumnDefinition Cassandra.Mapping.ITypeDefinition.GetColumnDefinition(FieldInfo field);
    private sealed virtual override IColumnDefinition Cassandra.Mapping.ITypeDefinition.GetColumnDefinition(PropertyInfo property);
    private string GetColumnName(MemberInfo memberInfo);
    private MemberInfo GetPropertyOrField(Expression`1<Func`2<TPoco, TProp>> expression);
    private static bool IsPropertyOrField(MemberInfo memberInfo);
    [CompilerGeneratedAttribute]
private Tuple`2<string, SortOrder> <Cassandra.Mapping.ITypeDefinition.get_ClusteringKeys>b__28_0(Tuple`2<MemberInfo, SortOrder> i);
}
public class Cassandra.Mapping.Mapper : object {
    private ISession _session;
    private IMetricsManager _metricsManager;
    private MapperFactory _mapperFactory;
    private StatementFactory _statementFactory;
    private CqlGenerator _cqlGenerator;
    private int _queryAbortTimeout;
    public Mapper(ISession session, MappingConfiguration config);
    public Mapper(ISession session);
    internal Mapper(ISession session, MapperFactory mapperFactory, StatementFactory statementFactory, CqlGenerator cqlGenerator);
    [AsyncStateMachineAttribute("Cassandra.Mapping.Mapper/<ExecuteAsyncAndAdapt>d__9`1")]
private Task`1<TResult> ExecuteAsyncAndAdapt(Cql cql, Func`3<Statement, RowSet, TResult> adaptation);
    public sealed virtual Task`1<IEnumerable`1<T>> FetchAsync(CqlQueryOptions options);
    public sealed virtual Task`1<IEnumerable`1<T>> FetchAsync(string cql, Object[] args);
    public sealed virtual Task`1<IEnumerable`1<T>> FetchAsync(Cql cql);
    public sealed virtual Task`1<IPage`1<T>> FetchPageAsync(Cql cql);
    public sealed virtual Task`1<IPage`1<T>> FetchPageAsync(CqlQueryOptions options);
    public sealed virtual Task`1<IPage`1<T>> FetchPageAsync(int pageSize, Byte[] pagingState, string query, Object[] args);
    public sealed virtual Task`1<T> SingleAsync(string cql, Object[] args);
    public sealed virtual Task`1<T> SingleAsync(Cql cql);
    public sealed virtual Task`1<T> SingleOrDefaultAsync(string cql, Object[] args);
    public sealed virtual Task`1<T> SingleOrDefaultAsync(Cql cql);
    public sealed virtual Task`1<T> FirstAsync(string cql, Object[] args);
    public sealed virtual Task`1<T> FirstAsync(Cql cql);
    public sealed virtual Task`1<T> FirstOrDefaultAsync(string cql, Object[] args);
    public sealed virtual Task`1<T> FirstOrDefaultAsync(Cql cql);
    public sealed virtual Task InsertAsync(T poco, CqlQueryOptions queryOptions);
    public sealed virtual Task InsertAsync(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public sealed virtual Task InsertAsync(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual Task InsertAsync(T poco, string executionProfile, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual Task InsertAsync(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public sealed virtual Task InsertAsync(T poco, string executionProfile, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public sealed virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, CqlQueryOptions queryOptions);
    public sealed virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public sealed virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, string executionProfile, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public sealed virtual Task`1<AppliedInfo`1<T>> InsertIfNotExistsAsync(T poco, string executionProfile, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public sealed virtual Task UpdateAsync(T poco, CqlQueryOptions queryOptions);
    public sealed virtual Task UpdateAsync(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public sealed virtual Task UpdateAsync(string cql, Object[] args);
    public sealed virtual Task UpdateAsync(Cql cql);
    public sealed virtual Task`1<AppliedInfo`1<T>> UpdateIfAsync(string cql, Object[] args);
    public sealed virtual Task`1<AppliedInfo`1<T>> UpdateIfAsync(Cql cql);
    public sealed virtual Task DeleteAsync(T poco, CqlQueryOptions queryOptions);
    public sealed virtual Task DeleteAsync(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public sealed virtual Task DeleteAsync(string cql, Object[] args);
    public sealed virtual Task DeleteAsync(Cql cql);
    public sealed virtual Task ExecuteAsync(string cql, Object[] args);
    [AsyncStateMachineAttribute("Cassandra.Mapping.Mapper/<ExecuteAsync>d__47")]
public sealed virtual Task ExecuteAsync(Cql cql);
    public sealed virtual ICqlBatch CreateBatch();
    public sealed virtual ICqlBatch CreateBatch(BatchType batchType);
    public sealed virtual void Execute(ICqlBatch batch);
    public sealed virtual void Execute(ICqlBatch batch, string executionProfile);
    public sealed virtual Task ExecuteAsync(ICqlBatch batch);
    [AsyncStateMachineAttribute("Cassandra.Mapping.Mapper/<ExecuteAsync>d__53")]
public sealed virtual Task ExecuteAsync(ICqlBatch batch, string executionProfile);
    public sealed virtual TDatabase ConvertCqlArgument(TValue value);
    public sealed virtual AppliedInfo`1<T> DeleteIf(string cql, Object[] args);
    public sealed virtual AppliedInfo`1<T> DeleteIf(Cql cql);
    public sealed virtual Task`1<AppliedInfo`1<T>> DeleteIfAsync(string cql, Object[] args);
    public sealed virtual Task`1<AppliedInfo`1<T>> DeleteIfAsync(Cql cql);
    public sealed virtual IEnumerable`1<T> Fetch(CqlQueryOptions queryOptions);
    public sealed virtual IEnumerable`1<T> Fetch(string cql, Object[] args);
    public sealed virtual IEnumerable`1<T> Fetch(Cql cql);
    public sealed virtual IPage`1<T> FetchPage(CqlQueryOptions queryOptions);
    public sealed virtual IPage`1<T> FetchPage(int pageSize, Byte[] pagingState, string cql, Object[] args);
    public sealed virtual IPage`1<T> FetchPage(Cql cql);
    public sealed virtual T Single(string cql, Object[] args);
    public sealed virtual T Single(Cql cql);
    public sealed virtual T SingleOrDefault(string cql, Object[] args);
    public sealed virtual T SingleOrDefault(Cql cql);
    public sealed virtual T First(string cql, Object[] args);
    public sealed virtual T First(Cql cql);
    public sealed virtual T FirstOrDefault(string cql, Object[] args);
    public sealed virtual T FirstOrDefault(Cql cql);
    public sealed virtual void Insert(T poco, CqlQueryOptions queryOptions);
    public sealed virtual void Insert(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public sealed virtual void Insert(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual void Insert(T poco, string executionProfile, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual void Insert(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public sealed virtual void Insert(T poco, string executionProfile, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public sealed virtual AppliedInfo`1<T> InsertIfNotExists(T poco, CqlQueryOptions queryOptions);
    public sealed virtual AppliedInfo`1<T> InsertIfNotExists(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public sealed virtual AppliedInfo`1<T> InsertIfNotExists(T poco, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual AppliedInfo`1<T> InsertIfNotExists(T poco, string executionProfile, bool insertNulls, CqlQueryOptions queryOptions);
    public sealed virtual AppliedInfo`1<T> InsertIfNotExists(T poco, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public sealed virtual AppliedInfo`1<T> InsertIfNotExists(T poco, string executionProfile, bool insertNulls, Nullable`1<int> ttl, CqlQueryOptions queryOptions);
    public sealed virtual void Update(T poco, CqlQueryOptions queryOptions);
    public sealed virtual void Update(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public sealed virtual void Update(string cql, Object[] args);
    public sealed virtual void Update(Cql cql);
    public sealed virtual AppliedInfo`1<T> UpdateIf(string cql, Object[] args);
    public sealed virtual AppliedInfo`1<T> UpdateIf(Cql cql);
    public sealed virtual void Delete(T poco, CqlQueryOptions queryOptions);
    public sealed virtual void Delete(T poco, string executionProfile, CqlQueryOptions queryOptions);
    public sealed virtual void Delete(string cql, Object[] args);
    public sealed virtual void Delete(Cql cql);
    public sealed virtual void Execute(string cql, Object[] args);
    public sealed virtual void Execute(Cql cql);
    public sealed virtual Task`1<AppliedInfo`1<T>> ExecuteConditionalAsync(ICqlBatch batch);
    [AsyncStateMachineAttribute("Cassandra.Mapping.Mapper/<ExecuteConditionalAsync>d__98`1")]
public sealed virtual Task`1<AppliedInfo`1<T>> ExecuteConditionalAsync(ICqlBatch batch, string executionProfile);
    public sealed virtual AppliedInfo`1<T> ExecuteConditional(ICqlBatch batch);
    public sealed virtual AppliedInfo`1<T> ExecuteConditional(ICqlBatch batch, string executionProfile);
    private Task`1<RowSet> ExecuteStatementAsync(IStatement statement, string executionProfile);
}
internal class Cassandra.Mapping.MapperFactory : object {
    private static Type CassandraRowType;
    private static Type IntType;
    private static Type ObjectType;
    private static BindingFlags PublicInstance;
    private static MethodInfo GetValueOfTMethod;
    private static MethodInfo IsNullMethod;
    private TypeConverter _typeConverter;
    private PocoDataFactory _pocoDataFactory;
    private ConcurrentDictionary`2<Tuple`3<Type, string, string>, Delegate> _mapperFuncCache;
    private ConcurrentDictionary`2<Tuple`2<Type, string>, Delegate> _valueCollectorFuncCache;
    public TypeConverter TypeConverter { get; }
    public PocoDataFactory PocoDataFactory { get; }
    public MapperFactory(TypeConverter typeConverter, PocoDataFactory pocoDataFactory);
    private static MapperFactory();
    public TypeConverter get_TypeConverter();
    public PocoDataFactory get_PocoDataFactory();
    public Func`2<Row, T> GetMapper(string cql, RowSet rows);
    public Func`2<Row, T> GetMapperWithProjection(string cql, RowSet rows, Expression projectionExpression);
    private static Tuple`3<Type, string, string> GetMapperCacheKey(string cql, string additional);
    public Func`2<T, Object[]> GetValueCollector(string cql, bool primaryKeyValuesOnly, bool primaryKeyValuesLast);
    private Func`2<Row, T> CreateMapper(RowSet rows);
    private Func`2<Row, T> CreateMapperWithProjection(RowSet rows, Expression projectionExpression);
    public PocoData GetPocoData();
    private Func`2<T, Object[]> CreateValueCollector(bool primaryKeyValuesOnly, bool primaryKeyValuesLast);
    private Func`2<Row, T> CreateMapperForSingleColumnToPoco(RowSet rows, PocoData pocoData);
    private Func`2<Row, T> CreateMapperForPoco(RowSet rows, PocoData pocoData);
    private Func`2<Row, T> CreateMapperForProjection(RowSet rows, NewTypeProjection projection);
    private static Type GetUnderlyingType(MemberInfo member);
    private Expression GetExpressionToGetValueFromPoco(ParameterExpression poco, PocoColumn column);
    public object AdaptValue(PocoData pocoData, PocoColumn column, object value);
    private Expression GetExpressionToGetColumnValueFromRow(ParameterExpression row, CqlColumn dbColumn, Type pocoDestType);
    private static bool TryGetCreateEmptyCollectionExpression(CqlColumn dbColumn, Type pocoDestType, Expression& createEmptyCollection);
    private static bool IsCassandraCollection(CqlColumn dbColumn);
    private static bool ImplementsCollectionInterface(Type t);
    private static MethodInfo GetMethod(Delegate deleg);
}
public class Cassandra.Mapping.MappingConfiguration : object {
    private static MappingConfiguration GlobalInstance;
    private TypeConverter _typeConverter;
    private LookupKeyedCollection`2<Type, ITypeDefinition> _typeDefinitions;
    [CompilerGeneratedAttribute]
private MapperFactory <MapperFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementFactory <StatementFactory>k__BackingField;
    public static MappingConfiguration Global { get; }
    internal MapperFactory MapperFactory { get; private set; }
    internal StatementFactory StatementFactory { get; private set; }
    public int MaxPreparedStatementsThreshold { get; public set; }
    private static MappingConfiguration();
    public static MappingConfiguration get_Global();
    [CompilerGeneratedAttribute]
internal MapperFactory get_MapperFactory();
    [CompilerGeneratedAttribute]
private void set_MapperFactory(MapperFactory value);
    [CompilerGeneratedAttribute]
internal StatementFactory get_StatementFactory();
    [CompilerGeneratedAttribute]
private void set_StatementFactory(StatementFactory value);
    public int get_MaxPreparedStatementsThreshold();
    public void set_MaxPreparedStatementsThreshold(int value);
    public MappingConfiguration ConvertTypesUsing(TypeConverter typeConverter);
    public MappingConfiguration Define(ITypeDefinition[] maps);
    public MappingConfiguration Define(Mappings[] mappings);
    public MappingConfiguration Define();
    public ITypeDefinition Get();
    public MappingConfiguration SetMaxPreparedStatementsThreshold(int value);
    internal void Clear();
}
public abstract class Cassandra.Mapping.Mappings : object {
    internal LookupKeyedCollection`2<Type, ITypeDefinition> Definitions;
    public Map`1<TPoco> For();
}
internal class Cassandra.Mapping.Page`1 : object {
    private List`1<T> _list;
    [CompilerGeneratedAttribute]
private Byte[] <CurrentPagingState>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PagingState>k__BackingField;
    public Byte[] CurrentPagingState { get; private set; }
    public Byte[] PagingState { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal Page`1(IEnumerable`1<T> items, Byte[] currentPagingState, Byte[] pagingState);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_CurrentPagingState();
    [CompilerGeneratedAttribute]
private void set_CurrentPagingState(Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_PagingState();
    [CompilerGeneratedAttribute]
private void set_PagingState(Byte[] value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
}
internal class Cassandra.Mapping.PocoColumn : object {
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ColumnType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberInfoType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SecondaryIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFrozen>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFrozenKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFrozenValue>k__BackingField;
    public string ColumnName { get; private set; }
    public Type ColumnType { get; private set; }
    public MemberInfo MemberInfo { get; private set; }
    public Type MemberInfoType { get; private set; }
    public bool SecondaryIndex { get; private set; }
    public bool IsCounter { get; private set; }
    public bool IsStatic { get; private set; }
    public bool IsFrozen { get; private set; }
    public bool HasFrozenKey { get; private set; }
    public bool HasFrozenValue { get; private set; }
    [CompilerGeneratedAttribute]
public string get_ColumnName();
    [CompilerGeneratedAttribute]
private void set_ColumnName(string value);
    [CompilerGeneratedAttribute]
public Type get_ColumnType();
    [CompilerGeneratedAttribute]
private void set_ColumnType(Type value);
    [CompilerGeneratedAttribute]
public MemberInfo get_MemberInfo();
    [CompilerGeneratedAttribute]
private void set_MemberInfo(MemberInfo value);
    [CompilerGeneratedAttribute]
public Type get_MemberInfoType();
    [CompilerGeneratedAttribute]
private void set_MemberInfoType(Type value);
    [CompilerGeneratedAttribute]
public bool get_SecondaryIndex();
    [CompilerGeneratedAttribute]
private void set_SecondaryIndex(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCounter();
    [CompilerGeneratedAttribute]
private void set_IsCounter(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
private void set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFrozen();
    [CompilerGeneratedAttribute]
private void set_IsFrozen(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasFrozenKey();
    [CompilerGeneratedAttribute]
private void set_HasFrozenKey(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasFrozenValue();
    [CompilerGeneratedAttribute]
private void set_HasFrozenValue(bool value);
    public static PocoColumn FromColumnDefinition(IColumnDefinition columnDefinition);
}
internal class Cassandra.Mapping.PocoData : object {
    private Dictionary`2<string, PocoColumn> _columnsByMemberName;
    private HashSet`1<string> _primaryKeys;
    [CompilerGeneratedAttribute]
private Type <PocoType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyspaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private LookupKeyedCollection`2<string, PocoColumn> <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PocoColumn> <PartitionKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Tuple`2<PocoColumn, SortOrder>> <ClusteringKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompactStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowFiltering>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <MissingPrimaryKeyColumns>k__BackingField;
    public Type PocoType { get; private set; }
    public string TableName { get; private set; }
    public string KeyspaceName { get; public set; }
    public LookupKeyedCollection`2<string, PocoColumn> Columns { get; private set; }
    public List`1<PocoColumn> PartitionKeys { get; public set; }
    public List`1<Tuple`2<PocoColumn, SortOrder>> ClusteringKeys { get; private set; }
    public bool CaseSensitive { get; private set; }
    public bool CompactStorage { get; private set; }
    public bool AllowFiltering { get; private set; }
    public List`1<string> MissingPrimaryKeyColumns { get; private set; }
    public PocoData(Type pocoType, string tableName, string keyspaceName, LookupKeyedCollection`2<string, PocoColumn> columns, String[] partitionkeys, Tuple`2[] clusteringKeys, bool caseSensitive, bool compact, bool allowFiltering);
    [CompilerGeneratedAttribute]
public Type get_PocoType();
    [CompilerGeneratedAttribute]
private void set_PocoType(Type value);
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
private void set_TableName(string value);
    [CompilerGeneratedAttribute]
public string get_KeyspaceName();
    [CompilerGeneratedAttribute]
public void set_KeyspaceName(string value);
    [CompilerGeneratedAttribute]
public LookupKeyedCollection`2<string, PocoColumn> get_Columns();
    [CompilerGeneratedAttribute]
private void set_Columns(LookupKeyedCollection`2<string, PocoColumn> value);
    [CompilerGeneratedAttribute]
public List`1<PocoColumn> get_PartitionKeys();
    [CompilerGeneratedAttribute]
public void set_PartitionKeys(List`1<PocoColumn> value);
    [CompilerGeneratedAttribute]
public List`1<Tuple`2<PocoColumn, SortOrder>> get_ClusteringKeys();
    [CompilerGeneratedAttribute]
private void set_ClusteringKeys(List`1<Tuple`2<PocoColumn, SortOrder>> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
private void set_CaseSensitive(bool value);
    [CompilerGeneratedAttribute]
public bool get_CompactStorage();
    [CompilerGeneratedAttribute]
private void set_CompactStorage(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowFiltering();
    [CompilerGeneratedAttribute]
private void set_AllowFiltering(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_MissingPrimaryKeyColumns();
    [CompilerGeneratedAttribute]
private void set_MissingPrimaryKeyColumns(List`1<string> value);
    public IList`1<PocoColumn> GetNonPrimaryKeyColumns();
    public IList`1<PocoColumn> GetPrimaryKeyColumns();
    public PocoColumn GetColumnByMemberName(string memberName);
    public string GetColumnNameByMemberName(string memberName);
    public string GetColumnName(MemberInfo member);
    [CompilerGeneratedAttribute]
private bool <GetNonPrimaryKeyColumns>b__43_0(PocoColumn c);
    [CompilerGeneratedAttribute]
private bool <GetPrimaryKeyColumns>b__44_0(PocoColumn c);
}
internal class Cassandra.Mapping.PocoDataFactory : object {
    private static BindingFlags PublicInstanceBindingFlags;
    private LookupKeyedCollection`2<Type, ITypeDefinition> _predefinedTypeDefinitions;
    private ConcurrentDictionary`2<Type, PocoData> _cache;
    public PocoDataFactory(LookupKeyedCollection`2<Type, ITypeDefinition> predefinedTypeDefinitions);
    public PocoData GetPocoData();
    public void AddDefinitionDefault(Type type, Func`1<ITypeDefinition> definitionHandler);
    private PocoData CreatePocoData(Type pocoType);
    private PocoData CreatePocoData(Type pocoType, ITypeDefinition typeDefinition);
    internal static IEnumerable`1<FieldInfo> GetMappableFields(Type t);
    private static IEnumerable`1<PropertyInfo> GetMappableProperties(Type t);
}
[AttributeUsageAttribute("4")]
public class Cassandra.Mapping.PrimaryKeyAttribute : Attribute {
    private String[] _columnNames;
    public String[] ColumnNames { get; }
    public PrimaryKeyAttribute(String[] columnNames);
    public String[] get_ColumnNames();
}
internal class Cassandra.Mapping.ProjectionExpressionVisitor : ExpressionVisitor {
    private Expression _expression;
    [CompilerGeneratedAttribute]
private NewTypeProjection <Projection>k__BackingField;
    public NewTypeProjection Projection { get; private set; }
    [CompilerGeneratedAttribute]
public NewTypeProjection get_Projection();
    [CompilerGeneratedAttribute]
private void set_Projection(NewTypeProjection value);
    public virtual Expression Visit(Expression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual Expression VisitNew(NewExpression node);
}
public enum Cassandra.Mapping.SortOrder : Enum {
    public sbyte value__;
    public static SortOrder Unspecified;
    public static SortOrder Ascending;
    public static SortOrder Descending;
}
internal class Cassandra.Mapping.Statements.CqlGenerator : object {
    private static string CannotGenerateStatementForPoco;
    private static string NoColumns;
    private static string MissingPkColumns;
    private static Regex SelectRegex;
    private static Regex FromRegex;
    private PocoDataFactory _pocoDataFactory;
    private static DateTimeOffset UnixEpoch;
    private static ICqlIdentifierHelper CqlIdentifierHelper;
    public CqlGenerator(PocoDataFactory pocoDataFactory);
    private static CqlGenerator();
    public void AddSelect(Cql cql);
    private static Func`2<PocoColumn, string> EscapeFunc(PocoData pocoData);
    private static Func`2<PocoColumn, string> EscapeFunc(PocoData pocoData, string format);
    public string GenerateInsert(bool insertNulls, Object[] pocoValues, Object[]& queryParameters, bool ifNotExists, Nullable`1<int> ttl, Nullable`1<DateTimeOffset> timestamp, string tableName);
    public string GenerateUpdate();
    public void PrependUpdate(Cql cql);
    public string GenerateDelete();
    public void PrependDelete(Cql cql);
    private static string GetTypeString(ISerializer serializer, PocoColumn column);
    public static List`1<string> GetCreate(ISerializer serializer, PocoData pocoData, string tableName, string keyspaceName, bool ifNotExists);
    private static string GetTypeString(PocoColumn column, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    private static string WrapFrozen(bool condition, string typeName);
}
internal class Cassandra.Mapping.Statements.StatementFactory : object {
    private IThreadSafeDictionary`2<CacheKey, Task`1<PreparedStatement>> _statementCache;
    private static Logger Logger;
    private int _statementCacheCount;
    [CompilerGeneratedAttribute]
private int <MaxPreparedStatementsThreshold>k__BackingField;
    public int MaxPreparedStatementsThreshold { get; public set; }
    private static StatementFactory();
    [CompilerGeneratedAttribute]
public int get_MaxPreparedStatementsThreshold();
    [CompilerGeneratedAttribute]
public void set_MaxPreparedStatementsThreshold(int value);
    [AsyncStateMachineAttribute("Cassandra.Mapping.Statements.StatementFactory/<GetStatementAsync>d__8")]
public Task`1<Statement> GetStatementAsync(ISession session, Cql cql, Nullable`1<bool> forceNoPrepare);
    private void SetStatementProperties(IStatement stmt, Cql cql);
    public Statement GetStatement(ISession session, Cql cql);
    [AsyncStateMachineAttribute("Cassandra.Mapping.Statements.StatementFactory/<GetBatchStatementAsync>d__11")]
public Task`1<BatchStatement> GetBatchStatementAsync(ISession session, ICqlBatch cqlBatch);
}
[AttributeUsageAttribute("4")]
public class Cassandra.Mapping.TableNameAttribute : Attribute {
    private string _tableName;
    public string Value { get; }
    public TableNameAttribute(string tableName);
    public string get_Value();
}
public class Cassandra.Mapping.TypeConversion.DefaultTypeConverter : TypeConverter {
    protected virtual Func`2<TDatabase, TPoco> GetUserDefinedFromDbConverter();
    protected virtual Func`2<TPoco, TDatabase> GetUserDefinedToDbConverter();
}
public static class Cassandra.Mapping.TypeConversion.EnumStringMapper`1 : object {
    private static Dictionary`2<string, T> StringToEnumCache;
    private static EnumStringMapper`1();
    public static T MapStringToEnum(string value);
}
internal class Cassandra.Mapping.TypeConversion.NewTypeProjection : object {
    [CompilerGeneratedAttribute]
private ConstructorInfo <ConstructorInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<MemberInfo> <Members>k__BackingField;
    public ConstructorInfo ConstructorInfo { get; private set; }
    public ICollection`1<MemberInfo> Members { get; private set; }
    public NewTypeProjection(ConstructorInfo constructorInfo);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_ConstructorInfo();
    [CompilerGeneratedAttribute]
private void set_ConstructorInfo(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public ICollection`1<MemberInfo> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(ICollection`1<MemberInfo> value);
}
public static class Cassandra.Mapping.TypeConversion.NullableEnumStringMapper`1 : object {
    private static Dictionary`2<string, T> StringToEnumCache;
    private static NullableEnumStringMapper`1();
    public static T MapStringToEnum(string value);
    public static string MapEnumToString(T enumValue);
}
[ExtensionAttribute]
internal static class Cassandra.Mapping.TypeConversion.ReflectionUtils : object {
    [ExtensionAttribute]
public static Delegate CreateDelegateLocal(MethodInfo method, object sender);
}
public abstract class Cassandra.Mapping.TypeConversion.TypeConverter : object {
    internal static IReadOnlyCollection`1<Type> ListGenericInterfaces;
    private static BindingFlags PrivateStatic;
    private static BindingFlags PrivateInstance;
    private static MethodInfo FindFromDbConverterMethod;
    private static MethodInfo FindToDbConverterMethod;
    private static MethodInfo ConvertToDictionaryMethod;
    private static MethodInfo ConvertToDictionaryFromDbMethod;
    private static MethodInfo ConvertToSortedDictionaryFromDbMethod;
    private static MethodInfo ConvertToHashSetMethod;
    private static MethodInfo ConvertToHashSetFromDbMethod;
    private static MethodInfo ConvertToSortedSetMethod;
    private static MethodInfo ConvertToSortedSetFromDbMethod;
    private static MethodInfo ConvertToListMethod;
    private static MethodInfo ConvertToListFromDbMethod;
    private static MethodInfo ConvertToArrayFromDbMethod;
    private static MethodInfo ConvertIEnumerableToDbTypeMethod;
    private static MethodInfo ConvertIEnumerableToSetDbMethod;
    private static MethodInfo ConvertIDictionaryToDbTypeMethod;
    private ConcurrentDictionary`2<Tuple`2<Type, Type>, Delegate> _fromDbConverterCache;
    private ConcurrentDictionary`2<Tuple`2<Type, Type>, Delegate> _toDbConverterCache;
    private static TypeConverter();
    internal TDatabase ConvertCqlArgument(TValue value);
    internal object ConvertToDbFromUdtFieldValue(Type valueType, Type dbType, object value);
    internal object ConvertToUdtFieldFromDbValue(Type dbType, Type valueType, object value);
    internal Delegate TryGetFromDbConverter(Type dbType, Type pocoType);
    private Func`2<TSource, TResult> TryGetFromDbConverter();
    private TResult ChangeType(TSource a);
    internal Delegate GetToDbConverter(Type pocoType, Type dbType);
    private Delegate FindFromDbConverter();
    private Delegate ConvertFromIDictionary(Type targetGenericType, Type[] sourceGenericArgs, Type[] targetGenericArgs, Type pocoType);
    private Delegate ConvertFromIEnumerable(Type targetGenericType, Type[] sourceGenericArgs, Type[] targetGenericArgs, Type pocoType);
    private Delegate FindToDbConverter();
    private Func`2<TPoco, TDatabase> TryFindToDbConverter();
    private IEnumerable`1<TResult> ConvertIEnumerableToDbType(IEnumerable`1<TSource> items);
    private IDictionary`2<TResultKey, TResultValue> ConvertIDictionaryToDbType(IDictionary`2<TSourceKey, TSourceValue> map);
    private static Dictionary`2<TKey, TValue> ConvertToDictionary(IDictionary`2<TKey, TValue> map);
    private Dictionary`2<TKeyResult, TValueResult> ConvertToDictionaryFromDb(IDictionary`2<TKeySource, TValueSource> mapFromDatabase);
    private TDictionaryResult ConvertToSortedDictionaryFromDb(IDictionary`2<TKeySource, TValueSource> mapFromDatabase);
    private static HashSet`1<T> ConvertToHashSet(IEnumerable`1<T> set);
    private HashSet`1<TResult> ConvertToHashSetFromDb(IEnumerable`1<TSource> setFromDatabase);
    private HashSet`1<TResult> ConvertIEnumerableToSetDb(IEnumerable`1<TSource> set);
    private static SortedSet`1<T> ConvertToSortedSet(IEnumerable`1<T> set);
    private TSetResult ConvertToSortedSetFromDb(IEnumerable`1<TSource> setFromDatabase);
    private static List`1<T> ConvertToList(IEnumerable`1<T> list);
    private TListResult ConvertToListFromDb(IEnumerable`1<TSource> itemsDatabase);
    private TResult[] ConvertToArrayFromDb(IEnumerable`1<TSource> listFromDatabase);
    protected abstract virtual Func`2<TDatabase, TPoco> GetUserDefinedFromDbConverter();
    protected abstract virtual Func`2<TPoco, TDatabase> GetUserDefinedToDbConverter();
    [CompilerGeneratedAttribute]
internal static Guid <FindToDbConverter>g__TimeUuidConverter|31_0(TimeUuid a);
}
internal class Cassandra.Mapping.Utils.CqlIdentifierHelper : object {
    private static HashSet`1<string> ReservedKeywords;
    private static CqlIdentifierHelper();
    public sealed virtual string EscapeIdentifierIfNecessary(IPocoData pocoData, string identifier);
    public sealed virtual string EscapeTableNameIfNecessary(IPocoData pocoData, string keyspace, string table);
}
[ExtensionAttribute]
internal static class Cassandra.Mapping.Utils.EnumerableExtensions : object {
    [ExtensionAttribute]
public static LookupKeyedCollection`2<TKey, TValue> ToLookupKeyedCollection(IEnumerable`1<TValue> values, Func`2<TValue, TKey> keySelector);
    [ExtensionAttribute]
public static LookupKeyedCollection`2<TKey, TValue> ToLookupKeyedCollection(IEnumerable`1<TValue> values, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static string ToCommaDelimitedString(IEnumerable`1<string> values);
}
internal interface Cassandra.Mapping.Utils.ICqlIdentifierHelper {
    public abstract virtual string EscapeIdentifierIfNecessary(IPocoData pocoData, string identifier);
    public abstract virtual string EscapeTableNameIfNecessary(IPocoData pocoData, string keyspace, string table);
}
internal class Cassandra.Mapping.Utils.LookupKeyedCollection`2 : KeyedCollection`2<TKey, TItem> {
    private Func`2<TItem, TKey> _getKeyFunc;
    public LookupKeyedCollection`2(Func`2<TItem, TKey> getKeyFunc);
    public LookupKeyedCollection`2(Func`2<TItem, TKey> getKeyFunc, IEqualityComparer`1<TKey> keyComparer);
    protected virtual TKey GetKeyForItem(TItem item);
    public bool TryGetItem(TKey key, TItem& item);
}
public static class Cassandra.Mapping.Utils.MemberInfoExtensions : object {
    public static bool HasAttribute(MemberInfo member, bool inherit);
    public static TAttribute GetFirstAttribute(MemberInfo member, bool inherit);
}
public class Cassandra.MaterializedViewMetadata : DataCollectionMetadata {
    [CompilerGeneratedAttribute]
private string <WhereClause>k__BackingField;
    public string WhereClause { get; protected set; }
    internal MaterializedViewMetadata(string name, string whereClause);
    [CompilerGeneratedAttribute]
public string get_WhereClause();
    [CompilerGeneratedAttribute]
protected void set_WhereClause(string value);
}
public class Cassandra.Metadata : object {
    private static string SelectSchemaVersionPeers;
    private static string SelectSchemaVersionLocal;
    private static Logger Logger;
    private TokenMap modreq(System.Runtime.CompilerServices.IsVolatile) _tokenMap;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _keyspaces;
    private ISchemaParser modreq(System.Runtime.CompilerServices.IsVolatile) _schemaParser;
    private int _queryAbortTimeout;
    private CopyOnWriteDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _resolvedContactPoints;
    [CompilerGeneratedAttribute]
private HostsEventHandler HostsEvent;
    [CompilerGeneratedAttribute]
private SchemaChangedEventHandler SchemaChangedEvent;
    [CompilerGeneratedAttribute]
private string <ClusterName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDbaas>k__BackingField;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IControlConnection <ControlConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Partitioner>k__BackingField;
    [CompilerGeneratedAttribute]
private Hosts <Hosts>k__BackingField;
    public string ClusterName { get; internal set; }
    public bool IsDbaas { get; private set; }
    internal Configuration Configuration { get; private set; }
    internal IControlConnection ControlConnection { get; internal set; }
    internal ISchemaParser SchemaParser { get; }
    internal string Partitioner { get; internal set; }
    internal Hosts Hosts { get; private set; }
    internal IReadOnlyDictionary`2<IContactPoint, IEnumerable`1<IConnectionEndPoint>> ResolvedContactPoints { get; }
    internal IReadOnlyTokenMap TokenToReplicasMap { get; }
    internal KeyValuePair`2[] KeyspacesSnapshot { get; }
    internal Metadata(Configuration configuration);
    internal Metadata(Configuration configuration, SchemaParser schemaParser);
    private static Metadata();
    [CompilerGeneratedAttribute]
public void add_HostsEvent(HostsEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_HostsEvent(HostsEventHandler value);
    [CompilerGeneratedAttribute]
public void add_SchemaChangedEvent(SchemaChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SchemaChangedEvent(SchemaChangedEventHandler value);
    [CompilerGeneratedAttribute]
public string get_ClusterName();
    [CompilerGeneratedAttribute]
internal void set_ClusterName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsDbaas();
    [CompilerGeneratedAttribute]
private void set_IsDbaas(bool value);
    [CompilerGeneratedAttribute]
internal Configuration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(Configuration value);
    [CompilerGeneratedAttribute]
internal IControlConnection get_ControlConnection();
    [CompilerGeneratedAttribute]
internal void set_ControlConnection(IControlConnection value);
    internal ISchemaParser get_SchemaParser();
    [CompilerGeneratedAttribute]
internal string get_Partitioner();
    [CompilerGeneratedAttribute]
internal void set_Partitioner(string value);
    [CompilerGeneratedAttribute]
internal Hosts get_Hosts();
    [CompilerGeneratedAttribute]
private void set_Hosts(Hosts value);
    internal IReadOnlyDictionary`2<IContactPoint, IEnumerable`1<IConnectionEndPoint>> get_ResolvedContactPoints();
    internal IReadOnlyTokenMap get_TokenToReplicasMap();
    public sealed virtual void Dispose();
    internal KeyspaceMetadata GetKeyspaceFromCache(string keyspace);
    internal void SetResolvedContactPoints(IDictionary`2<IContactPoint, IEnumerable`1<IConnectionEndPoint>> resolvedContactPoints);
    public Host GetHost(IPEndPoint address);
    internal Host AddHost(IPEndPoint address);
    internal Host AddHost(IPEndPoint address, IContactPoint contactPoint);
    internal void RemoveHost(IPEndPoint address);
    internal void FireSchemaChangedEvent(Kind what, string keyspace, string table, object sender);
    private void OnHostDown(Host h);
    private void OnHostUp(Host h);
    public ICollection`1<Host> AllHosts();
    public IEnumerable`1<IPEndPoint> AllReplicas();
    internal KeyValuePair`2[] get_KeyspacesSnapshot();
    [AsyncStateMachineAttribute("Cassandra.Metadata/<RebuildTokenMapAsync>d__60")]
internal Task RebuildTokenMapAsync(bool retry, bool fetchKeyspaces);
    internal bool RemoveKeyspaceFromTokenMap(string name);
    [AsyncStateMachineAttribute("Cassandra.Metadata/<UpdateTokenMapForKeyspace>d__62")]
internal Task`1<KeyspaceMetadata> UpdateTokenMapForKeyspace(string name);
    public ICollection`1<Host> GetReplicas(string keyspaceName, Byte[] partitionKey);
    public ICollection`1<Host> GetReplicas(Byte[] partitionKey);
    public KeyspaceMetadata GetKeyspace(string keyspace);
    public ICollection`1<string> GetKeyspaces();
    public ICollection`1<string> GetTables(string keyspace);
    public TableMetadata GetTable(string keyspace, string tableName);
    internal Task`1<TableMetadata> GetTableAsync(string keyspace, string tableName);
    public MaterializedViewMetadata GetMaterializedView(string keyspace, string name);
    public UdtColumnInfo GetUdtDefinition(string keyspace, string typeName);
    public Task`1<UdtColumnInfo> GetUdtDefinitionAsync(string keyspace, string typeName);
    public FunctionMetadata GetFunction(string keyspace, string name, String[] signature);
    public AggregateMetadata GetAggregate(string keyspace, string name, String[] signature);
    internal Task`1<QueryTrace> GetQueryTraceAsync(QueryTrace trace);
    public bool RefreshSchema(string keyspace, string table);
    [AsyncStateMachineAttribute("Cassandra.Metadata/<RefreshSchemaAsync>d__77")]
public Task`1<bool> RefreshSchemaAsync(string keyspace, string table);
    public void ShutDown(int timeoutMs);
    internal bool RemoveKeyspace(string name);
    internal Task`1<KeyspaceMetadata> RefreshSingleKeyspace(string name);
    internal void ClearTable(string keyspaceName, string tableName);
    internal void ClearView(string keyspaceName, string name);
    internal void ClearFunction(string keyspaceName, string functionName, String[] signature);
    internal void ClearAggregate(string keyspaceName, string aggregateName, String[] signature);
    [AsyncStateMachineAttribute("Cassandra.Metadata/<CheckSchemaAgreementAsync>d__85")]
public Task`1<bool> CheckSchemaAgreementAsync();
    private static bool CheckSchemaVersionResults(IEnumerable`1<IRow> localVersionQuery, IEnumerable`1<IRow> peerVersionsQuery);
    [AsyncStateMachineAttribute("Cassandra.Metadata/<WaitForSchemaAgreementAsync>d__87")]
internal Task`1<bool> WaitForSchemaAgreementAsync(IConnection connection);
    internal void SetCassandraVersion(Version version);
    internal void SetProductTypeAsDbaas();
    internal IEnumerable`1<IConnectionEndPoint> UpdateResolvedContactPoint(IContactPoint contactPoint, IEnumerable`1<IConnectionEndPoint> endpoints);
}
internal class Cassandra.MetadataHelpers.DatacenterInfo : object {
    private HashSet`1<string> _racks;
    [CompilerGeneratedAttribute]
private int <HostLength>k__BackingField;
    public int HostLength { get; public set; }
    public ISet`1<string> Racks { get; }
    [CompilerGeneratedAttribute]
public int get_HostLength();
    [CompilerGeneratedAttribute]
public void set_HostLength(int value);
    public ISet`1<string> get_Racks();
    public void AddRack(string name);
}
internal class Cassandra.MetadataHelpers.DatacenterReplicationFactor : ValueType {
    private int _hashCode;
    [CompilerGeneratedAttribute]
private string <Datacenter>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationFactor <ReplicationFactor>k__BackingField;
    public string Datacenter { get; }
    public ReplicationFactor ReplicationFactor { get; }
    public DatacenterReplicationFactor(string datacenter, ReplicationFactor replicationFactor);
    [CompilerGeneratedAttribute]
public string get_Datacenter();
    [CompilerGeneratedAttribute]
public ReplicationFactor get_ReplicationFactor();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DatacenterReplicationFactor other);
    public virtual int GetHashCode();
    private static int ComputeHashCode(string datacenter, ReplicationFactor replicationFactor);
    public sealed virtual int CompareTo(DatacenterReplicationFactor other);
}
internal class Cassandra.MetadataHelpers.EverywhereStrategy : object {
    private static int HashCode;
    [CompilerGeneratedAttribute]
private static IReplicationStrategy <Instance>k__BackingField;
    public static IReplicationStrategy Instance { get; }
    private static EverywhereStrategy();
    [CompilerGeneratedAttribute]
public static IReplicationStrategy get_Instance();
    public sealed virtual Dictionary`2<IToken, ISet`1<Host>> ComputeTokenToReplicaMap(IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, int numberOfHostsWithTokens, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters);
    public sealed virtual bool Equals(IReplicationStrategy other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EverywhereStrategy other);
    private bool TypedEquals(EverywhereStrategy other);
    public virtual int GetHashCode();
}
internal interface Cassandra.MetadataHelpers.IReadOnlyTokenMap {
    public abstract virtual IReadOnlyDictionary`2<IToken, ISet`1<Host>> GetByKeyspace(string keyspaceName);
}
internal interface Cassandra.MetadataHelpers.IReplicationStrategy {
    public abstract virtual Dictionary`2<IToken, ISet`1<Host>> ComputeTokenToReplicaMap(IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, int numberOfHostsWithTokens, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters);
}
internal interface Cassandra.MetadataHelpers.IReplicationStrategyFactory {
    public abstract virtual IReplicationStrategy Create(string strategyClass, IReadOnlyDictionary`2<string, ReplicationFactor> replicationOptions);
}
internal interface Cassandra.MetadataHelpers.ISchemaParserFactory {
    public abstract virtual ISchemaParser Create(Version cassandraVersion, Metadata parent, Func`3<string, string, Task`1<UdtColumnInfo>> udtResolver, ISchemaParser currentInstance);
}
internal class Cassandra.MetadataHelpers.LocalStrategy : object {
    private static int HashCode;
    [CompilerGeneratedAttribute]
private static IReplicationStrategy <Instance>k__BackingField;
    public static IReplicationStrategy Instance { get; }
    private static LocalStrategy();
    [CompilerGeneratedAttribute]
public static IReplicationStrategy get_Instance();
    public sealed virtual Dictionary`2<IToken, ISet`1<Host>> ComputeTokenToReplicaMap(IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, int numberOfHostsWithTokens, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters);
    public sealed virtual bool Equals(IReplicationStrategy other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LocalStrategy other);
    private bool TypedEquals(LocalStrategy other);
    public virtual int GetHashCode();
}
internal class Cassandra.MetadataHelpers.NetworkTopologyStrategy : object {
    private SortedSet`1<DatacenterReplicationFactor> _replicationFactorsSet;
    private IReadOnlyDictionary`2<string, ReplicationFactor> _replicationFactorsMap;
    private int _hashCode;
    public NetworkTopologyStrategy(IReadOnlyDictionary`2<string, ReplicationFactor> replicationFactors);
    public sealed virtual Dictionary`2<IToken, ISet`1<Host>> ComputeTokenToReplicaMap(IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, int numberOfHostsWithTokens, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IReplicationStrategy other);
    public sealed virtual bool Equals(NetworkTopologyStrategy other);
    private static int ComputeHashCode(IEnumerable`1<DatacenterReplicationFactor> replicationFactorsSet);
    public virtual int GetHashCode();
    private Dictionary`2<IToken, ISet`1<Host>> ComputeTokenToReplicaNetwork(IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters);
    private ISet`1<Host> ComputeReplicasForToken(IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters, int i);
    private static HashSet`1<string> GetAddedRacksInDatacenter(NetworkTopologyTokenMapContext context, string dc);
    private static bool ShouldSkipHost(NetworkTopologyTokenMapContext context, Host h, HashSet`1<string> racksPlacedInDc);
    private static void TryAddToSkippedHostsCollection(NetworkTopologyTokenMapContext context, Host h, int dcRf, int dcAddedReplicas);
    private static void AddReplica(NetworkTopologyTokenMapContext context, Host host, int dcRf, int dcAddedReplicas, HashSet`1<string> racksPlacedInDc);
    internal static bool AreReplicationFactorsSatisfied(IReadOnlyDictionary`2<string, ReplicationFactor> replicationFactors, IDictionary`2<string, int> replicasByDc, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters);
    private static int AddSkippedHosts(NetworkTopologyTokenMapContext context, string dc, int dcRf, int dcReplicas);
}
internal class Cassandra.MetadataHelpers.NetworkTopologyTokenMapContext : ValueType {
    [CompilerGeneratedAttribute]
private IList`1<Host> <SkippedHosts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, HashSet`1<string>> <RacksAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedHashSet`1<Host> <TokenReplicas>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, int> <ReplicasByDc>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IToken> <Ring>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<IToken, Host> <PrimaryReplicas>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, DatacenterInfo> <Datacenters>k__BackingField;
    public IList`1<Host> SkippedHosts { get; }
    public IDictionary`2<string, HashSet`1<string>> RacksAdded { get; }
    public OrderedHashSet`1<Host> TokenReplicas { get; }
    public IDictionary`2<string, int> ReplicasByDc { get; }
    public IReadOnlyList`1<IToken> Ring { get; }
    public IReadOnlyDictionary`2<IToken, Host> PrimaryReplicas { get; }
    public IReadOnlyDictionary`2<string, DatacenterInfo> Datacenters { get; }
    public NetworkTopologyTokenMapContext(IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters);
    [CompilerGeneratedAttribute]
public IList`1<Host> get_SkippedHosts();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, HashSet`1<string>> get_RacksAdded();
    [CompilerGeneratedAttribute]
public OrderedHashSet`1<Host> get_TokenReplicas();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, int> get_ReplicasByDc();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IToken> get_Ring();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<IToken, Host> get_PrimaryReplicas();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, DatacenterInfo> get_Datacenters();
}
internal class Cassandra.MetadataHelpers.ReplicationFactor : object {
    [CompilerGeneratedAttribute]
private int <AllReplicas>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransientReplicas>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FullReplicas>k__BackingField;
    public int AllReplicas { get; }
    public int TransientReplicas { get; }
    public int FullReplicas { get; }
    private ReplicationFactor(int allReplicas, int transientReplicas);
    [CompilerGeneratedAttribute]
public int get_AllReplicas();
    [CompilerGeneratedAttribute]
public int get_TransientReplicas();
    [CompilerGeneratedAttribute]
public int get_FullReplicas();
    public bool HasTransientReplicas();
    public virtual string ToString();
    public static ReplicationFactor Parse(string rf);
    private static int ParseNumberOfReplicas(string numberOfReplicas);
    public sealed virtual bool Equals(ReplicationFactor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(ReplicationFactor other);
}
internal class Cassandra.MetadataHelpers.ReplicationStrategyFactory : object {
    private static Logger Logger;
    private static ReplicationStrategyFactory();
    public sealed virtual IReplicationStrategy Create(string strategyClass, IReadOnlyDictionary`2<string, ReplicationFactor> replicationOptions);
}
internal class Cassandra.MetadataHelpers.SchemaParserFactory : object {
    private static Version Version30;
    private static Version Version40;
    private static SchemaParserFactory();
    public sealed virtual ISchemaParser Create(Version cassandraVersion, Metadata parent, Func`3<string, string, Task`1<UdtColumnInfo>> udtResolver, ISchemaParser currentInstance);
}
internal class Cassandra.MetadataHelpers.SimpleStrategy : object {
    private ReplicationFactor _replicationFactor;
    public SimpleStrategy(ReplicationFactor replicationFactor);
    public sealed virtual Dictionary`2<IToken, ISet`1<Host>> ComputeTokenToReplicaMap(IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, int numberOfHostsWithTokens, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters);
    public sealed virtual bool Equals(IReplicationStrategy other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SimpleStrategy other);
    public virtual int GetHashCode();
    private Dictionary`2<IToken, ISet`1<Host>> ComputeTokenToReplicaSimple(int numberOfHostsWithTokens, IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas);
}
public class Cassandra.MetadataSyncOptions : object {
    [CompilerGeneratedAttribute]
private bool <MetadataSyncEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RefreshSchemaDelayIncrement>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxTotalRefreshSchemaDelay>k__BackingField;
    public bool MetadataSyncEnabled { get; private set; }
    public long RefreshSchemaDelayIncrement { get; private set; }
    public long MaxTotalRefreshSchemaDelay { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_MetadataSyncEnabled();
    [CompilerGeneratedAttribute]
private void set_MetadataSyncEnabled(bool value);
    [CompilerGeneratedAttribute]
public long get_RefreshSchemaDelayIncrement();
    [CompilerGeneratedAttribute]
private void set_RefreshSchemaDelayIncrement(long value);
    [CompilerGeneratedAttribute]
public long get_MaxTotalRefreshSchemaDelay();
    [CompilerGeneratedAttribute]
private void set_MaxTotalRefreshSchemaDelay(long value);
    public MetadataSyncOptions SetMetadataSyncEnabled(bool metadataSyncEnabled);
    public MetadataSyncOptions SetRefreshSchemaDelayIncrement(long refreshSchemaDelayIncrement);
    public MetadataSyncOptions SetMaxTotalRefreshSchemaDelay(long maxTotalRefreshSchemaDelay);
    internal MetadataSyncOptions Clone();
}
public interface Cassandra.Metrics.Abstractions.IDriverCounter {
    public abstract virtual void Increment();
    public abstract virtual void Increment(long value);
}
public interface Cassandra.Metrics.Abstractions.IDriverGauge {
}
public interface Cassandra.Metrics.Abstractions.IDriverMeter {
    public abstract virtual void Mark(long amount);
}
public interface Cassandra.Metrics.Abstractions.IDriverMetric {
}
public interface Cassandra.Metrics.Abstractions.IDriverMetricsProvider {
    public abstract virtual IDriverTimer Timer(string bucket, IMetric metric);
    public abstract virtual IDriverMeter Meter(string bucket, IMetric metric);
    public abstract virtual IDriverCounter Counter(string bucket, IMetric metric);
    public abstract virtual IDriverGauge Gauge(string bucket, IMetric metric, Func`1<Nullable`1<double>> valueProvider);
    public abstract virtual void ShutdownMetricsBucket(string bucket);
}
public interface Cassandra.Metrics.Abstractions.IDriverTimer {
    public abstract virtual void Record(long elapsedNanoseconds);
}
public class Cassandra.Metrics.DriverMetricsOptions : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<NodeMetric> <EnabledNodeMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SessionMetric> <EnabledSessionMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BucketPrefix>k__BackingField;
    public IEnumerable`1<NodeMetric> EnabledNodeMetrics { get; private set; }
    public IEnumerable`1<SessionMetric> EnabledSessionMetrics { get; private set; }
    public string BucketPrefix { get; private set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<NodeMetric> get_EnabledNodeMetrics();
    [CompilerGeneratedAttribute]
private void set_EnabledNodeMetrics(IEnumerable`1<NodeMetric> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<SessionMetric> get_EnabledSessionMetrics();
    [CompilerGeneratedAttribute]
private void set_EnabledSessionMetrics(IEnumerable`1<SessionMetric> value);
    [CompilerGeneratedAttribute]
public string get_BucketPrefix();
    [CompilerGeneratedAttribute]
private void set_BucketPrefix(string value);
    public DriverMetricsOptions SetEnabledNodeMetrics(IEnumerable`1<NodeMetric> enabledNodeMetrics);
    public DriverMetricsOptions SetEnabledSessionMetrics(IEnumerable`1<SessionMetric> enabledSessionMetrics);
    public DriverMetricsOptions SetBucketPrefix(string bucketPrefix);
    internal DriverMetricsOptions Clone();
}
public interface Cassandra.Metrics.IDriverMetrics {
    public IMetricsRegistry`1<SessionMetric> SessionMetrics { get; }
    public IReadOnlyDictionary`2<Host, IMetricsRegistry`1<NodeMetric>> NodeMetrics { get; }
    public abstract virtual IMetricsRegistry`1<SessionMetric> get_SessionMetrics();
    public abstract virtual IReadOnlyDictionary`2<Host, IMetricsRegistry`1<NodeMetric>> get_NodeMetrics();
    public abstract virtual TMetricType GetNodeMetric(Host host, NodeMetric nodeMetric);
    public abstract virtual TMetricType GetSessionMetric(SessionMetric sessionMetric);
}
public interface Cassandra.Metrics.IMetric {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public interface Cassandra.Metrics.IMetricsRegistry`1 {
    public IReadOnlyDictionary`2<TMetric, IDriverCounter> Counters { get; }
    public IReadOnlyDictionary`2<TMetric, IDriverGauge> Gauges { get; }
    public IReadOnlyDictionary`2<TMetric, IDriverMeter> Meters { get; }
    public IReadOnlyDictionary`2<TMetric, IDriverTimer> Timers { get; }
    public IReadOnlyDictionary`2<TMetric, IDriverMetric> Metrics { get; }
    public abstract virtual IReadOnlyDictionary`2<TMetric, IDriverCounter> get_Counters();
    public abstract virtual IReadOnlyDictionary`2<TMetric, IDriverGauge> get_Gauges();
    public abstract virtual IReadOnlyDictionary`2<TMetric, IDriverMeter> get_Meters();
    public abstract virtual IReadOnlyDictionary`2<TMetric, IDriverTimer> get_Timers();
    public abstract virtual IReadOnlyDictionary`2<TMetric, IDriverMetric> get_Metrics();
}
internal interface Cassandra.Metrics.Internal.IMetricsManager {
    public bool AreSessionTimerMetricsEnabled { get; }
    public bool AreNodeTimerMetricsEnabled { get; }
    public bool AreMetricsEnabled { get; }
    public abstract virtual ISessionMetrics GetSessionMetrics();
    public abstract virtual INodeMetrics GetOrCreateNodeMetrics(Host host);
    public abstract virtual void InitializeMetrics(IInternalSession session);
    public abstract virtual void RemoveNodeMetrics(Host host);
    public abstract virtual bool get_AreSessionTimerMetricsEnabled();
    public abstract virtual bool get_AreNodeTimerMetricsEnabled();
    public abstract virtual bool get_AreMetricsEnabled();
}
internal class Cassandra.Metrics.Internal.MetricsManager : object {
    private static Logger Logger;
    private IDriverMetricsProvider _driverMetricsProvider;
    private DriverMetricsOptions _metricsOptions;
    private bool _metricsEnabled;
    private string _sessionBucket;
    private ISessionMetrics _sessionMetrics;
    private CopyOnWriteDictionary`2<Host, IMetricsRegistry`1<NodeMetric>> _nodeMetricsRegistryCollection;
    private CopyOnWriteDictionary`2<Host, INodeMetrics> _nodeMetricsCollection;
    private bool _disabledSessionTimerMetrics;
    private bool _disabledNodeTimerMetrics;
    public IMetricsRegistry`1<SessionMetric> SessionMetrics { get; }
    public IReadOnlyDictionary`2<Host, IMetricsRegistry`1<NodeMetric>> NodeMetrics { get; }
    public bool AreMetricsEnabled { get; }
    public bool AreSessionTimerMetricsEnabled { get; }
    public bool AreNodeTimerMetricsEnabled { get; }
    public MetricsManager(IDriverMetricsProvider driverMetricsProvider, DriverMetricsOptions metricsOptions, bool metricsEnabled, string sessionName);
    private static MetricsManager();
    public sealed virtual IMetricsRegistry`1<SessionMetric> get_SessionMetrics();
    public sealed virtual IReadOnlyDictionary`2<Host, IMetricsRegistry`1<NodeMetric>> get_NodeMetrics();
    public sealed virtual bool get_AreMetricsEnabled();
    public sealed virtual TMetricType GetNodeMetric(Host host, NodeMetric nodeMetric);
    public sealed virtual TMetricType GetSessionMetric(SessionMetric sessionMetric);
    public sealed virtual void InitializeMetrics(IInternalSession session);
    public sealed virtual void RemoveNodeMetrics(Host host);
    public sealed virtual bool get_AreSessionTimerMetricsEnabled();
    public sealed virtual bool get_AreNodeTimerMetricsEnabled();
    public sealed virtual ISessionMetrics GetSessionMetrics();
    public sealed virtual INodeMetrics GetOrCreateNodeMetrics(Host host);
    private static string BuildHostAddressMetricPath(IPEndPoint address);
    public sealed virtual void Dispose();
}
public class Cassandra.Metrics.NodeMetric : object {
    private int _hashCode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static IEnumerable`1<NodeMetric> AllNodeMetrics;
    public static IEnumerable`1<NodeMetric> DefaultNodeMetrics;
    public string Name { get; }
    private static NodeMetric();
    internal NodeMetric(string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual bool Equals(NodeMetric other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(IMetric other);
    public virtual string ToString();
    private bool StrictEquals(object obj);
    private bool StrictEqualsNotNull(NodeMetric other);
}
internal class Cassandra.Metrics.Providers.Null.NullDriverCounter : object {
    public static IDriverCounter Instance;
    private static NullDriverCounter();
    public sealed virtual void Increment(long value);
    public sealed virtual void Increment();
}
internal class Cassandra.Metrics.Providers.Null.NullDriverGauge : object {
    public static IDriverGauge Instance;
    private static NullDriverGauge();
    public void Dispose();
}
internal class Cassandra.Metrics.Providers.Null.NullDriverMeter : object {
    public static IDriverMeter Instance;
    private static NullDriverMeter();
    public sealed virtual void Mark(long amount);
}
internal class Cassandra.Metrics.Providers.Null.NullDriverMetricsProvider : object {
    public sealed virtual IDriverTimer Timer(string bucket, IMetric metric);
    public sealed virtual IDriverMeter Meter(string bucket, IMetric metric);
    public sealed virtual IDriverCounter Counter(string bucket, IMetric metric);
    public sealed virtual IDriverGauge Gauge(string bucket, IMetric metric, Func`1<Nullable`1<double>> valueProvider);
    public IDriverGauge Gauge(string bucket, IMetric metric);
    public sealed virtual void ShutdownMetricsBucket(string bucket);
}
internal class Cassandra.Metrics.Providers.Null.NullDriverTimer : object {
    public static IDriverTimer Instance;
    private static NullDriverTimer();
    public sealed virtual void Record(long elapsedNanoseconds);
}
internal interface Cassandra.Metrics.Registries.IInternalMetricsRegistry`1 {
    public abstract virtual IDriverTimer Timer(string bucket, TMetric metric);
    public abstract virtual IDriverMeter Meter(string bucket, TMetric metric);
    public abstract virtual IDriverCounter Counter(string bucket, TMetric metric);
    public abstract virtual IDriverGauge Gauge(string bucket, TMetric metric, Func`1<Nullable`1<double>> valueProvider);
    public abstract virtual IDriverMetric GetMetric(TMetric metric);
    public abstract virtual void OnMetricsAdded();
}
internal interface Cassandra.Metrics.Registries.INodeMetrics {
    public IDriverCounter SpeculativeExecutions { get; }
    public IDriverMeter BytesSent { get; }
    public IDriverMeter BytesReceived { get; }
    public IDriverTimer CqlMessages { get; }
    public IDriverGauge OpenConnections { get; }
    public IDriverGauge InFlight { get; }
    public IRequestErrorMetrics Errors { get; }
    public IRetryPolicyMetrics Retries { get; }
    public IRetryPolicyMetrics Ignores { get; }
    public IInternalMetricsRegistry`1<NodeMetric> MetricsRegistry { get; }
    public abstract virtual IDriverCounter get_SpeculativeExecutions();
    public abstract virtual IDriverMeter get_BytesSent();
    public abstract virtual IDriverMeter get_BytesReceived();
    public abstract virtual IDriverTimer get_CqlMessages();
    public abstract virtual IDriverGauge get_OpenConnections();
    public abstract virtual IDriverGauge get_InFlight();
    public abstract virtual IRequestErrorMetrics get_Errors();
    public abstract virtual IRetryPolicyMetrics get_Retries();
    public abstract virtual IRetryPolicyMetrics get_Ignores();
    public abstract virtual IInternalMetricsRegistry`1<NodeMetric> get_MetricsRegistry();
    public abstract virtual void InitializePoolGauges(IHostConnectionPool pool);
}
internal class Cassandra.Metrics.Registries.InternalMetricsRegistry`1 : object {
    private IDriverMetricsProvider _driverMetricsProvider;
    private bool _metricsEnabled;
    private HashSet`1<TMetric> _disabledMetrics;
    private Dictionary`2<TMetric, IDriverGauge> _gauges;
    private Dictionary`2<TMetric, IDriverCounter> _counters;
    private Dictionary`2<TMetric, IDriverMeter> _meters;
    private Dictionary`2<TMetric, IDriverTimer> _timers;
    private Dictionary`2<TMetric, IDriverMetric> _metrics;
    private bool _initialized;
    public IReadOnlyDictionary`2<TMetric, IDriverCounter> Counters { get; }
    public IReadOnlyDictionary`2<TMetric, IDriverGauge> Gauges { get; }
    public IReadOnlyDictionary`2<TMetric, IDriverMeter> Meters { get; }
    public IReadOnlyDictionary`2<TMetric, IDriverTimer> Timers { get; }
    public IReadOnlyDictionary`2<TMetric, IDriverMetric> Metrics { get; }
    public InternalMetricsRegistry`1(IDriverMetricsProvider driverMetricsProvider, IEnumerable`1<TMetric> disabledMetrics, bool metricsEnabled);
    public sealed virtual IReadOnlyDictionary`2<TMetric, IDriverCounter> get_Counters();
    public sealed virtual IReadOnlyDictionary`2<TMetric, IDriverGauge> get_Gauges();
    public sealed virtual IReadOnlyDictionary`2<TMetric, IDriverMeter> get_Meters();
    public sealed virtual IReadOnlyDictionary`2<TMetric, IDriverTimer> get_Timers();
    public sealed virtual IReadOnlyDictionary`2<TMetric, IDriverMetric> get_Metrics();
    public sealed virtual IDriverTimer Timer(string bucket, TMetric metric);
    public sealed virtual IDriverMeter Meter(string bucket, TMetric metric);
    public sealed virtual IDriverCounter Counter(string bucket, TMetric metric);
    public sealed virtual IDriverGauge Gauge(string bucket, TMetric metric, Func`1<Nullable`1<double>> valueProvider);
    public sealed virtual IDriverMetric GetMetric(TMetric metric);
    public sealed virtual void OnMetricsAdded();
    private void ThrowIfInitialized();
    private bool IsMetricEnabled(TMetric metric);
}
internal interface Cassandra.Metrics.Registries.IRequestErrorMetrics {
    public IDriverCounter Aborted { get; }
    public IDriverCounter ReadTimeout { get; }
    public IDriverCounter WriteTimeout { get; }
    public IDriverCounter Unavailable { get; }
    public IDriverCounter ClientTimeout { get; }
    public IDriverCounter Other { get; }
    public IDriverCounter Unsent { get; }
    public IDriverCounter ConnectionInitErrors { get; }
    public IDriverCounter AuthenticationErrors { get; }
    public abstract virtual IDriverCounter get_Aborted();
    public abstract virtual IDriverCounter get_ReadTimeout();
    public abstract virtual IDriverCounter get_WriteTimeout();
    public abstract virtual IDriverCounter get_Unavailable();
    public abstract virtual IDriverCounter get_ClientTimeout();
    public abstract virtual IDriverCounter get_Other();
    public abstract virtual IDriverCounter get_Unsent();
    public abstract virtual IDriverCounter get_ConnectionInitErrors();
    public abstract virtual IDriverCounter get_AuthenticationErrors();
}
internal interface Cassandra.Metrics.Registries.IRetryPolicyMetrics {
    public IDriverCounter ReadTimeout { get; }
    public IDriverCounter WriteTimeout { get; }
    public IDriverCounter Unavailable { get; }
    public IDriverCounter Other { get; }
    public IDriverCounter Total { get; }
    public abstract virtual IDriverCounter get_ReadTimeout();
    public abstract virtual IDriverCounter get_WriteTimeout();
    public abstract virtual IDriverCounter get_Unavailable();
    public abstract virtual IDriverCounter get_Other();
    public abstract virtual IDriverCounter get_Total();
}
internal interface Cassandra.Metrics.Registries.ISessionMetrics {
    public IDriverTimer CqlRequests { get; }
    public IDriverCounter CqlClientTimeouts { get; }
    public IDriverMeter BytesSent { get; }
    public IDriverMeter BytesReceived { get; }
    public IDriverGauge ConnectedNodes { get; }
    public IInternalMetricsRegistry`1<SessionMetric> MetricsRegistry { get; }
    public abstract virtual IDriverTimer get_CqlRequests();
    public abstract virtual IDriverCounter get_CqlClientTimeouts();
    public abstract virtual IDriverMeter get_BytesSent();
    public abstract virtual IDriverMeter get_BytesReceived();
    public abstract virtual IDriverGauge get_ConnectedNodes();
    public abstract virtual IInternalMetricsRegistry`1<SessionMetric> get_MetricsRegistry();
    public abstract virtual void InitializeMetrics(IInternalSession session);
}
internal class Cassandra.Metrics.Registries.NodeMetrics : object {
    private IDriverMetricsProvider _driverMetricsProvider;
    private string _bucketName;
    private IHostConnectionPool _hostConnectionPool;
    [CompilerGeneratedAttribute]
private IDriverCounter <SpeculativeExecutions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverMeter <BytesSent>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverMeter <BytesReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverTimer <CqlMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverGauge <OpenConnections>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverGauge <InFlight>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestErrorMetrics <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private IRetryPolicyMetrics <Retries>k__BackingField;
    [CompilerGeneratedAttribute]
private IRetryPolicyMetrics <Ignores>k__BackingField;
    [CompilerGeneratedAttribute]
private IInternalMetricsRegistry`1<NodeMetric> <MetricsRegistry>k__BackingField;
    public IDriverCounter SpeculativeExecutions { get; private set; }
    public IDriverMeter BytesSent { get; private set; }
    public IDriverMeter BytesReceived { get; private set; }
    public IDriverTimer CqlMessages { get; private set; }
    public IDriverGauge OpenConnections { get; private set; }
    public IDriverGauge InFlight { get; private set; }
    public IRequestErrorMetrics Errors { get; private set; }
    public IRetryPolicyMetrics Retries { get; private set; }
    public IRetryPolicyMetrics Ignores { get; private set; }
    public IInternalMetricsRegistry`1<NodeMetric> MetricsRegistry { get; }
    public NodeMetrics(IDriverMetricsProvider driverMetricsProvider, DriverMetricsOptions metricOptions, bool metricsEnabled, string bucketName);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_SpeculativeExecutions();
    [CompilerGeneratedAttribute]
private void set_SpeculativeExecutions(IDriverCounter value);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverMeter get_BytesSent();
    [CompilerGeneratedAttribute]
private void set_BytesSent(IDriverMeter value);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverMeter get_BytesReceived();
    [CompilerGeneratedAttribute]
private void set_BytesReceived(IDriverMeter value);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverTimer get_CqlMessages();
    [CompilerGeneratedAttribute]
private void set_CqlMessages(IDriverTimer value);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverGauge get_OpenConnections();
    [CompilerGeneratedAttribute]
private void set_OpenConnections(IDriverGauge value);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverGauge get_InFlight();
    [CompilerGeneratedAttribute]
private void set_InFlight(IDriverGauge value);
    [CompilerGeneratedAttribute]
public sealed virtual IRequestErrorMetrics get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(IRequestErrorMetrics value);
    [CompilerGeneratedAttribute]
public sealed virtual IRetryPolicyMetrics get_Retries();
    [CompilerGeneratedAttribute]
private void set_Retries(IRetryPolicyMetrics value);
    [CompilerGeneratedAttribute]
public sealed virtual IRetryPolicyMetrics get_Ignores();
    [CompilerGeneratedAttribute]
private void set_Ignores(IRetryPolicyMetrics value);
    [CompilerGeneratedAttribute]
public sealed virtual IInternalMetricsRegistry`1<NodeMetric> get_MetricsRegistry();
    private void InitializeMetrics();
    public sealed virtual void InitializePoolGauges(IHostConnectionPool pool);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private Nullable`1<double> <InitializeMetrics>b__43_0();
    [CompilerGeneratedAttribute]
private Nullable`1<double> <InitializeMetrics>b__43_1();
}
internal class Cassandra.Metrics.Registries.RequestErrorMetrics : object {
    [CompilerGeneratedAttribute]
private IDriverCounter <Aborted>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <ReadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <WriteTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <Unavailable>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <ClientTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <Other>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <Unsent>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <ConnectionInitErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <AuthenticationErrors>k__BackingField;
    public IDriverCounter Aborted { get; }
    public IDriverCounter ReadTimeout { get; }
    public IDriverCounter WriteTimeout { get; }
    public IDriverCounter Unavailable { get; }
    public IDriverCounter ClientTimeout { get; }
    public IDriverCounter Other { get; }
    public IDriverCounter Unsent { get; }
    public IDriverCounter ConnectionInitErrors { get; }
    public IDriverCounter AuthenticationErrors { get; }
    public RequestErrorMetrics(IInternalMetricsRegistry`1<NodeMetric> nodeMetricsRegistry, string context);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Aborted();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_ReadTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_WriteTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Unavailable();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_ClientTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Other();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Unsent();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_ConnectionInitErrors();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_AuthenticationErrors();
}
internal class Cassandra.Metrics.Registries.RetryPolicyOnIgnoreMetrics : object {
    [CompilerGeneratedAttribute]
private IDriverCounter <ReadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <WriteTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <Unavailable>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <Other>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <Total>k__BackingField;
    public IDriverCounter ReadTimeout { get; }
    public IDriverCounter WriteTimeout { get; }
    public IDriverCounter Unavailable { get; }
    public IDriverCounter Other { get; }
    public IDriverCounter Total { get; }
    public RetryPolicyOnIgnoreMetrics(IInternalMetricsRegistry`1<NodeMetric> nodeMetricsRegistry, string context);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_ReadTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_WriteTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Unavailable();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Other();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Total();
}
internal class Cassandra.Metrics.Registries.RetryPolicyOnRetryMetrics : object {
    [CompilerGeneratedAttribute]
private IDriverCounter <ReadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <WriteTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <Unavailable>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <Other>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <Total>k__BackingField;
    public IDriverCounter ReadTimeout { get; }
    public IDriverCounter WriteTimeout { get; }
    public IDriverCounter Unavailable { get; }
    public IDriverCounter Other { get; }
    public IDriverCounter Total { get; }
    public RetryPolicyOnRetryMetrics(IInternalMetricsRegistry`1<NodeMetric> nodeMetricsRegistry, string context);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_ReadTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_WriteTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Unavailable();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Other();
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_Total();
}
internal class Cassandra.Metrics.Registries.SessionMetrics : object {
    private IDriverMetricsProvider _driverMetricsProvider;
    private string _context;
    [CompilerGeneratedAttribute]
private IDriverTimer <CqlRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverCounter <CqlClientTimeouts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverMeter <BytesSent>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverMeter <BytesReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private IDriverGauge <ConnectedNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private IInternalMetricsRegistry`1<SessionMetric> <MetricsRegistry>k__BackingField;
    public IDriverTimer CqlRequests { get; private set; }
    public IDriverCounter CqlClientTimeouts { get; private set; }
    public IDriverMeter BytesSent { get; private set; }
    public IDriverMeter BytesReceived { get; private set; }
    public IDriverGauge ConnectedNodes { get; private set; }
    public IInternalMetricsRegistry`1<SessionMetric> MetricsRegistry { get; }
    public SessionMetrics(IDriverMetricsProvider driverMetricsProvider, DriverMetricsOptions metricsOptions, bool metricsEnabled, string context);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverTimer get_CqlRequests();
    [CompilerGeneratedAttribute]
private void set_CqlRequests(IDriverTimer value);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverCounter get_CqlClientTimeouts();
    [CompilerGeneratedAttribute]
private void set_CqlClientTimeouts(IDriverCounter value);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverMeter get_BytesSent();
    [CompilerGeneratedAttribute]
private void set_BytesSent(IDriverMeter value);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverMeter get_BytesReceived();
    [CompilerGeneratedAttribute]
private void set_BytesReceived(IDriverMeter value);
    [CompilerGeneratedAttribute]
public sealed virtual IDriverGauge get_ConnectedNodes();
    [CompilerGeneratedAttribute]
private void set_ConnectedNodes(IDriverGauge value);
    [CompilerGeneratedAttribute]
public sealed virtual IInternalMetricsRegistry`1<SessionMetric> get_MetricsRegistry();
    public sealed virtual void InitializeMetrics(IInternalSession session);
    public sealed virtual void Dispose();
}
public class Cassandra.Metrics.SessionMetric : object {
    private int _hashCode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static IEnumerable`1<SessionMetric> AllSessionMetrics;
    public static IEnumerable`1<SessionMetric> DefaultSessionMetrics;
    public string Name { get; }
    private static SessionMetric();
    internal SessionMetric(string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual bool Equals(SessionMetric other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(IMetric other);
    public virtual string ToString();
    private bool StrictEquals(object obj);
    private bool StrictEqualsNotNull(SessionMetric other);
}
public class Cassandra.MonitorReportingOptions : object {
    internal static long DefaultStatusEventDelayMilliseconds;
    internal static bool DefaultMonitorReportingEnabled;
    [CompilerGeneratedAttribute]
private long <StatusEventDelayMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MonitorReportingEnabled>k__BackingField;
    internal long StatusEventDelayMilliseconds { get; private set; }
    public bool MonitorReportingEnabled { get; private set; }
    [CompilerGeneratedAttribute]
internal long get_StatusEventDelayMilliseconds();
    [CompilerGeneratedAttribute]
private void set_StatusEventDelayMilliseconds(long value);
    [CompilerGeneratedAttribute]
public bool get_MonitorReportingEnabled();
    [CompilerGeneratedAttribute]
private void set_MonitorReportingEnabled(bool value);
    public MonitorReportingOptions SetMonitorReportingEnabled(bool monitorReportingEnabled);
    internal MonitorReportingOptions SetStatusEventDelayMilliseconds(long delay);
}
public class Cassandra.NodeRequestInfo : object {
    [CompilerGeneratedAttribute]
private Host <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ExecutionId>k__BackingField;
    [CompilerGeneratedAttribute]
private PrepareRequest <PrepareRequest>k__BackingField;
    public Host Host { get; }
    public Guid ExecutionId { get; }
    public PrepareRequest PrepareRequest { get; }
    internal NodeRequestInfo(Host host, PrepareRequest prepareRequest);
    [CompilerGeneratedAttribute]
public Host get_Host();
    [CompilerGeneratedAttribute]
public Guid get_ExecutionId();
    [CompilerGeneratedAttribute]
public PrepareRequest get_PrepareRequest();
    public sealed virtual bool Equals(NodeRequestInfo other);
    public static bool op_Equality(NodeRequestInfo a, NodeRequestInfo b);
    public static bool op_Inequality(NodeRequestInfo a, NodeRequestInfo b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Cassandra.NoHostAvailableException : DriverException {
    private static string StartMessage;
    private static int MaxTriedInfo;
    [CompilerGeneratedAttribute]
private Dictionary`2<IPEndPoint, Exception> <Errors>k__BackingField;
    public Dictionary`2<IPEndPoint, Exception> Errors { get; }
    public NoHostAvailableException(Dictionary`2<IPEndPoint, Exception> errors);
    internal NoHostAvailableException(string message);
    internal NoHostAvailableException(string message, Exception innerException);
    protected NoHostAvailableException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Dictionary`2<IPEndPoint, Exception> get_Errors();
    private static string CreateMessage(Dictionary`2<IPEndPoint, Exception> errors);
}
public class Cassandra.NoneAuthProvider : object {
    private static string DseAuthenticator;
    public static NoneAuthProvider Instance;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _name;
    private static NoneAuthProvider();
    public sealed virtual IAuthenticator NewAuthenticator(IPEndPoint host);
    public sealed virtual void SetName(string name);
}
public class Cassandra.NoSpeculativeExecutionPolicy : object {
    private static ISpeculativeExecutionPlan Plan;
    public static NoSpeculativeExecutionPolicy Instance;
    private static NoSpeculativeExecutionPolicy();
    public sealed virtual void Dispose();
    public sealed virtual void Initialize(ICluster cluster);
    public sealed virtual ISpeculativeExecutionPlan NewPlan(string keyspace, IStatement statement);
}
public class Cassandra.NullTypeAdapter : object {
    public sealed virtual Type GetDataType();
    public sealed virtual object ConvertFrom(Byte[] decimalBuf);
    public sealed virtual Byte[] ConvertTo(object value);
}
internal interface Cassandra.Observers.Abstractions.IConnectionObserver {
    public abstract virtual void OnBytesSent(long size);
    public abstract virtual void OnBytesReceived(long size);
    public abstract virtual void OnErrorOnOpen(Exception exception);
    public abstract virtual IOperationObserver CreateOperationObserver();
}
internal interface Cassandra.Observers.Abstractions.IObserverFactory {
    public abstract virtual IRequestObserver CreateRequestObserver();
    public abstract virtual IConnectionObserver CreateConnectionObserver(Host host);
}
internal interface Cassandra.Observers.Abstractions.IOperationObserver {
    public abstract virtual void OnOperationSend(long requestSize, long timestamp);
    public abstract virtual void OnOperationReceive(IRequestError exception, Response response, long timestamp);
}
internal interface Cassandra.Observers.Abstractions.IRequestObserver {
    public abstract virtual void OnSpeculativeExecution(Host host, long delay);
    public abstract virtual Task OnNodeStartAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public abstract virtual Task OnNodeRequestErrorAsync(RequestErrorType errorType, RetryDecisionType decision, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo, Exception ex);
    public abstract virtual Task OnNodeRequestErrorAsync(IRequestError error, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo);
    public abstract virtual Task OnNodeSuccessAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public abstract virtual Task OnNodeRequestAbortedAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public abstract virtual Task OnRequestStartAsync(SessionRequestInfo sessionRequestInfo);
    public abstract virtual Task OnRequestFailureAsync(Exception ex, SessionRequestInfo sessionRequestInfo);
    public abstract virtual Task OnRequestSuccessAsync(SessionRequestInfo sessionRequestInfo);
}
internal class Cassandra.Observers.Composite.CompositeConnectionObserver : object {
    private IConnectionObserver _o1;
    private IConnectionObserver _o2;
    public CompositeConnectionObserver(IConnectionObserver o1, IConnectionObserver o2);
    public sealed virtual void OnBytesSent(long size);
    public sealed virtual void OnBytesReceived(long size);
    public sealed virtual void OnErrorOnOpen(Exception exception);
    public sealed virtual IOperationObserver CreateOperationObserver();
}
internal class Cassandra.Observers.Composite.CompositeObserverFactory : object {
    private IObserverFactory _f1;
    private IObserverFactory _f2;
    public CompositeObserverFactory(IObserverFactory f1, IObserverFactory f2);
    public sealed virtual IConnectionObserver CreateConnectionObserver(Host host);
    public sealed virtual IRequestObserver CreateRequestObserver();
}
internal class Cassandra.Observers.Composite.CompositeObserverFactoryBuilder : object {
    private IObserverFactoryBuilder _b1;
    private IObserverFactoryBuilder _b2;
    public CompositeObserverFactoryBuilder(IObserverFactoryBuilder b1, IObserverFactoryBuilder b2);
    public sealed virtual IObserverFactory Build(IMetricsManager manager);
}
internal class Cassandra.Observers.Composite.CompositeOperationObserver : object {
    private IOperationObserver _o1;
    private IOperationObserver _o2;
    public CompositeOperationObserver(IOperationObserver o1, IOperationObserver o2);
    public sealed virtual void OnOperationSend(long requestSize, long timestamp);
    public sealed virtual void OnOperationReceive(IRequestError exception, Response response, long timestamp);
}
internal class Cassandra.Observers.Composite.CompositeRequestObserver : object {
    private IRequestObserver _o1;
    private IRequestObserver _o2;
    public CompositeRequestObserver(IRequestObserver o1, IRequestObserver o2);
    [AsyncStateMachineAttribute("Cassandra.Observers.Composite.CompositeRequestObserver/<OnNodeRequestErrorAsync>d__3")]
public sealed virtual Task OnNodeRequestErrorAsync(RequestErrorType errorType, RetryDecisionType decision, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo, Exception ex);
    [AsyncStateMachineAttribute("Cassandra.Observers.Composite.CompositeRequestObserver/<OnNodeRequestErrorAsync>d__4")]
public sealed virtual Task OnNodeRequestErrorAsync(IRequestError error, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo);
    [AsyncStateMachineAttribute("Cassandra.Observers.Composite.CompositeRequestObserver/<OnRequestFailureAsync>d__5")]
public sealed virtual Task OnRequestFailureAsync(Exception ex, SessionRequestInfo r);
    [AsyncStateMachineAttribute("Cassandra.Observers.Composite.CompositeRequestObserver/<OnRequestSuccessAsync>d__6")]
public sealed virtual Task OnRequestSuccessAsync(SessionRequestInfo r);
    [AsyncStateMachineAttribute("Cassandra.Observers.Composite.CompositeRequestObserver/<OnNodeRequestAbortedAsync>d__7")]
public sealed virtual Task OnNodeRequestAbortedAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    [AsyncStateMachineAttribute("Cassandra.Observers.Composite.CompositeRequestObserver/<OnRequestStartAsync>d__8")]
public sealed virtual Task OnRequestStartAsync(SessionRequestInfo sessionRequestInfo);
    public sealed virtual void OnSpeculativeExecution(Host host, long delay);
    [AsyncStateMachineAttribute("Cassandra.Observers.Composite.CompositeRequestObserver/<OnNodeStartAsync>d__10")]
public sealed virtual Task OnNodeStartAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    [AsyncStateMachineAttribute("Cassandra.Observers.Composite.CompositeRequestObserver/<OnNodeSuccessAsync>d__11")]
public sealed virtual Task OnNodeSuccessAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
}
internal interface Cassandra.Observers.IObserverFactoryBuilder {
    public abstract virtual IObserverFactory Build(IMetricsManager manager);
}
internal class Cassandra.Observers.Metrics.MetricsConnectionObserver : object {
    private static Logger Logger;
    private ISessionMetrics _sessionMetrics;
    private INodeMetrics _nodeMetrics;
    private bool _enabledNodeTimerMetrics;
    public MetricsConnectionObserver(ISessionMetrics sessionMetrics, INodeMetrics nodeMetrics, bool enabledNodeTimerMetrics);
    private static MetricsConnectionObserver();
    public sealed virtual void OnBytesSent(long size);
    public sealed virtual void OnBytesReceived(long size);
    public sealed virtual void OnErrorOnOpen(Exception exception);
    public sealed virtual IOperationObserver CreateOperationObserver();
    private static void LogError(Exception ex);
}
internal class Cassandra.Observers.Metrics.MetricsObserverFactory : object {
    private IMetricsManager _metricsManager;
    public MetricsObserverFactory(IMetricsManager metricsManager);
    public sealed virtual IRequestObserver CreateRequestObserver();
    public sealed virtual IConnectionObserver CreateConnectionObserver(Host host);
}
internal class Cassandra.Observers.Metrics.MetricsObserverFactoryBuilder : object {
    private bool isEnabled;
    public MetricsObserverFactoryBuilder(bool isEnabled);
    public sealed virtual IObserverFactory Build(IMetricsManager manager);
}
internal class Cassandra.Observers.Metrics.MetricsOperationObserver : object {
    private bool _enabledNodeTimerMetrics;
    private static Logger Logger;
    private static long Factor;
    private IDriverTimer _operationTimer;
    private long _startTimestamp;
    public MetricsOperationObserver(INodeMetrics nodeMetrics, bool enabledNodeTimerMetrics);
    private static MetricsOperationObserver();
    public sealed virtual void OnOperationSend(long requestSize, long timestamp);
    public sealed virtual void OnOperationReceive(IRequestError error, Response response, long timestamp);
    private static void LogError(Exception ex);
}
internal class Cassandra.Observers.Metrics.MetricsRequestObserver : object {
    private static Logger Logger;
    private static long Factor;
    private IMetricsManager _manager;
    private IDriverTimer _requestTimer;
    private long _startTimestamp;
    public MetricsRequestObserver(IMetricsManager manager, IDriverTimer requestTimer);
    private static MetricsRequestObserver();
    public sealed virtual void OnSpeculativeExecution(Host host, long delay);
    public sealed virtual Task OnNodeRequestErrorAsync(RequestErrorType errorType, RetryDecisionType decision, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo, Exception ex);
    public sealed virtual Task OnNodeRequestErrorAsync(IRequestError error, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo);
    private void OnRetryPolicyDecision(IRetryPolicyMetrics metricsRegistry, RequestErrorType reason);
    private void OnRequestError(IRequestErrorMetrics metricsRegistry, RequestErrorType errorType);
    public sealed virtual Task OnNodeRequestAbortedAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public sealed virtual Task OnRequestStartAsync(SessionRequestInfo r);
    public sealed virtual Task OnRequestFailureAsync(Exception ex, SessionRequestInfo r);
    public sealed virtual Task OnRequestSuccessAsync(SessionRequestInfo r);
    private Task OnRequestFinish(Exception ex, SessionRequestInfo r);
    private static void LogError(Exception ex);
    public sealed virtual Task OnNodeStartAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public sealed virtual Task OnNodeSuccessAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
}
internal class Cassandra.Observers.Null.NullConnectionObserver : object {
    public static IConnectionObserver Instance;
    private static NullConnectionObserver();
    public sealed virtual void OnBytesSent(long size);
    public sealed virtual void OnBytesReceived(long size);
    public sealed virtual void OnErrorOnOpen(Exception exception);
    public sealed virtual IOperationObserver CreateOperationObserver();
}
internal class Cassandra.Observers.Null.NullObserverFactory : object {
    public static IObserverFactory Instance;
    private static NullObserverFactory();
    public sealed virtual IRequestObserver CreateRequestObserver();
    public sealed virtual IConnectionObserver CreateConnectionObserver(Host host);
}
internal class Cassandra.Observers.Null.NullObserverFactoryBuilder : object {
    public sealed virtual IObserverFactory Build(IMetricsManager manager);
}
internal class Cassandra.Observers.Null.NullOperationObserver : object {
    public static IOperationObserver Instance;
    private static NullOperationObserver();
    public sealed virtual void OnOperationSend(long requestSize, long timestamp);
    public sealed virtual void OnOperationReceive(IRequestError error, Response response, long timestamp);
}
internal class Cassandra.Observers.Null.NullRequestObserver : object {
    public static IRequestObserver Instance;
    private static NullRequestObserver();
    public sealed virtual Task OnNodeRequestErrorAsync(RequestErrorType errorType, RetryDecisionType decision, SessionRequestInfo r, NodeRequestInfo h, Exception ex);
    public sealed virtual Task OnNodeRequestErrorAsync(IRequestError error, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo);
    public sealed virtual Task OnNodeStartAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo h);
    public sealed virtual Task OnNodeSuccessAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo h);
    public sealed virtual Task OnNodeRequestAbortedAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public sealed virtual Task OnRequestFailureAsync(Exception ex, SessionRequestInfo r);
    public sealed virtual Task OnRequestStartAsync(SessionRequestInfo r);
    public sealed virtual Task OnRequestSuccessAsync(SessionRequestInfo r);
    public sealed virtual void OnSpeculativeExecution(Host host, long delay);
}
internal class Cassandra.Observers.RequestTracker.RequestTrackerObserver : object {
    private IRequestTracker _requestTracker;
    public RequestTrackerObserver(IRequestTracker requestTracker);
    public sealed virtual Task OnNodeRequestErrorAsync(RequestErrorType errorType, RetryDecisionType decision, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo, Exception ex);
    public sealed virtual Task OnNodeRequestErrorAsync(IRequestError error, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo);
    public sealed virtual Task OnRequestSuccessAsync(SessionRequestInfo r);
    public sealed virtual Task OnRequestFailureAsync(Exception ex, SessionRequestInfo r);
    public sealed virtual Task OnNodeRequestAbortedAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public sealed virtual Task OnRequestStartAsync(SessionRequestInfo r);
    public sealed virtual void OnSpeculativeExecution(Host host, long delay);
    public sealed virtual Task OnNodeStartAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
    public sealed virtual Task OnNodeSuccessAsync(SessionRequestInfo sessionRequestInfo, NodeRequestInfo nodeRequestInfo);
}
internal class Cassandra.Observers.RequestTracker.RequestTrackerObserverFactory : object {
    private IRequestTracker _tracker;
    public RequestTrackerObserverFactory(IRequestTracker tracker);
    public sealed virtual IConnectionObserver CreateConnectionObserver(Host host);
    public sealed virtual IRequestObserver CreateRequestObserver();
}
internal class Cassandra.Observers.RequestTracker.RequestTrackerObserverFactoryBuilder : object {
    private IRequestTracker _tracker;
    public RequestTrackerObserverFactoryBuilder(IRequestTracker tracker);
    public sealed virtual IObserverFactory Build(IMetricsManager manager);
}
internal class Cassandra.OperationState : object {
    private static Logger Logger;
    private IOperationObserver _operationObserver;
    private static int StateInit;
    private static int StateCancelled;
    private static int StateTimedout;
    private static int StateCompleted;
    private Func`4<IRequestError, Response, long, Task> _callback;
    public static Func`4<IRequestError, Response, long, Task> Noop;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _timeoutCallbackSet;
    private int _state;
    private ITimeout modreq(System.Runtime.CompilerServices.IsVolatile) _timeout;
    [CompilerGeneratedAttribute]
private ResultMetadata <ResultMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeoutMillis>k__BackingField;
    public ResultMetadata ResultMetadata { get; }
    public IRequest Request { get; private set; }
    public int TimeoutMillis { get; }
    public OperationState(Func`3<IRequestError, Response, Task> callback, IRequest request, int timeoutMillis, IOperationObserver operationObserver);
    private static OperationState();
    [CompilerGeneratedAttribute]
public ResultMetadata get_ResultMetadata();
    [CompilerGeneratedAttribute]
public IRequest get_Request();
    [CompilerGeneratedAttribute]
private void set_Request(IRequest value);
    [CompilerGeneratedAttribute]
public int get_TimeoutMillis();
    public void SetTimeout(ITimeout value);
    public long WriteFrame(short streamId, MemoryStream memoryStream, ISerializer serializer, long timestamp);
    public bool CanBeWritten();
    public Func`4<IRequestError, Response, long, Task> SetCompleted();
    public void InvokeCallback(IRequestError error, long timestamp);
    public bool MarkAsTimedOut(OperationTimedOutException ex, Func`1<Task> onReceive, long timestamp);
    public void Cancel();
    internal static void CallbackMultiple(IEnumerable`1<OperationState> ops, IRequestError error, long timestamp);
}
public class Cassandra.OperationTimedOutException : DriverException {
    public OperationTimedOutException(IPEndPoint address, int timeout);
    internal OperationTimedOutException(IConnectionEndPoint endPoint, int timeout);
}
internal class Cassandra.OPPToken : object {
    public static TokenFactory Factory;
    private Byte[] _value;
    private OPPToken(Byte[] value);
    private static OPPToken();
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Cassandra.OutputAlreadyExists : OutputError {
    private AlreadyExistsInfo _info;
    protected virtual void Load(FrameReader cb);
    public virtual DriverException CreateException();
}
internal class Cassandra.OutputBadCredentials : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputConfigError : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal abstract class Cassandra.OutputError : object {
    private static Dictionary`2<int, Func`1<OutputError>> OutputErrorFactoryMethods;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <TraceId>k__BackingField;
    protected string Message { get; private set; }
    protected int Code { get; private set; }
    public Nullable`1<Guid> TraceId { get; internal set; }
    private static OutputError();
    [CompilerGeneratedAttribute]
protected string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
protected int get_Code();
    [CompilerGeneratedAttribute]
private void set_Code(int value);
    public sealed virtual void Dispose();
    public abstract virtual DriverException CreateException();
    protected abstract virtual void Load(FrameReader reader);
    internal static OutputError CreateOutputError(int code, string message, FrameReader cb);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_TraceId();
    [CompilerGeneratedAttribute]
internal void set_TraceId(Nullable`1<Guid> value);
}
internal class Cassandra.OutputFunctionFailure : OutputError {
    private FunctionFailureException _exception;
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputInvalid : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputIsBootstrapping : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputOptions : object {
    private Dictionary`2<string, String[]> _options;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <TraceId>k__BackingField;
    public Nullable`1<Guid> TraceId { get; internal set; }
    public IDictionary`2<string, String[]> Options { get; }
    internal OutputOptions(FrameReader reader);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_TraceId();
    [CompilerGeneratedAttribute]
internal void set_TraceId(Nullable`1<Guid> value);
    public IDictionary`2<string, String[]> get_Options();
    public sealed virtual void Dispose();
}
internal class Cassandra.OutputOverloaded : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputPrepared : object {
    [CompilerGeneratedAttribute]
private RowSetMetadata <VariablesRowsMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private RowSetMetadata <ResultRowsMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <QueryId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ResultMetadataId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <TraceId>k__BackingField;
    public RowSetMetadata VariablesRowsMetadata { get; }
    public RowSetMetadata ResultRowsMetadata { get; }
    public Byte[] QueryId { get; }
    public Byte[] ResultMetadataId { get; }
    public Nullable`1<Guid> TraceId { get; internal set; }
    internal OutputPrepared(ProtocolVersion protocolVersion, FrameReader reader);
    internal OutputPrepared(Byte[] queryId, RowSetMetadata rowSetVariablesRowsMetadata, RowSetMetadata resultRowsMetadata);
    [CompilerGeneratedAttribute]
public RowSetMetadata get_VariablesRowsMetadata();
    [CompilerGeneratedAttribute]
public RowSetMetadata get_ResultRowsMetadata();
    [CompilerGeneratedAttribute]
public Byte[] get_QueryId();
    [CompilerGeneratedAttribute]
public Byte[] get_ResultMetadataId();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_TraceId();
    [CompilerGeneratedAttribute]
internal void set_TraceId(Nullable`1<Guid> value);
    public sealed virtual void Dispose();
}
internal class Cassandra.OutputProtocolError : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputReadTimeout : OutputError {
    private int _blockFor;
    private ConsistencyLevel _consistency;
    private bool _dataPresent;
    private int _received;
    private int _failures;
    private bool _isFailure;
    private IDictionary`2<IPAddress, int> _reasons;
    internal OutputReadTimeout(bool isFailure);
    protected virtual void Load(FrameReader reader);
    internal static IDictionary`2<IPAddress, int> GetReasonsDictionary(FrameReader reader, int length);
    public virtual DriverException CreateException();
}
internal class Cassandra.OutputRows : object {
    private int _rowLength;
    private static int ReusableBufferLength;
    private static ThreadLocal`1<Byte[]> ReusableBuffer;
    [CompilerGeneratedAttribute]
private RowSet <RowSet>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <TraceId>k__BackingField;
    [CompilerGeneratedAttribute]
private RowSetMetadata <ResultRowsMetadata>k__BackingField;
    public RowSet RowSet { get; public set; }
    public Nullable`1<Guid> TraceId { get; private set; }
    public RowSetMetadata ResultRowsMetadata { get; }
    internal OutputRows(FrameReader reader, ResultMetadata resultMetadata, Nullable`1<Guid> traceId);
    private static OutputRows();
    [CompilerGeneratedAttribute]
public RowSet get_RowSet();
    [CompilerGeneratedAttribute]
public void set_RowSet(RowSet value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_TraceId();
    [CompilerGeneratedAttribute]
private void set_TraceId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public RowSetMetadata get_ResultRowsMetadata();
    internal void ProcessRows(RowSet rs, FrameReader reader, ResultMetadata providedResultMetadata);
    private static Row ProcessRowItem(FrameReader reader, RowSetMetadata resultMetadata, Byte[] reusableBuffer);
    private static Byte[] GetBuffer(int length, ColumnTypeCode typeCode, Byte[] reusableBuffer);
    public sealed virtual void Dispose();
}
internal class Cassandra.OutputSchemaChange : object {
    [CompilerGeneratedAttribute]
private SchemaChangeEventArgs <SchemaChangeEventArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <TraceId>k__BackingField;
    public SchemaChangeEventArgs SchemaChangeEventArgs { get; }
    public Nullable`1<Guid> TraceId { get; }
    internal OutputSchemaChange(ProtocolVersion protocolVersion, FrameReader reader, Nullable`1<Guid> traceId);
    [CompilerGeneratedAttribute]
public SchemaChangeEventArgs get_SchemaChangeEventArgs();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_TraceId();
    public sealed virtual void Dispose();
}
internal class Cassandra.OutputServerError : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputSetKeyspace : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <TraceId>k__BackingField;
    public string Value { get; public set; }
    public Nullable`1<Guid> TraceId { get; internal set; }
    internal OutputSetKeyspace(string val);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_TraceId();
    [CompilerGeneratedAttribute]
internal void set_TraceId(Nullable`1<Guid> value);
    public sealed virtual void Dispose();
}
internal class Cassandra.OutputSyntaxError : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputTruncateError : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputUnauthorized : OutputError {
    public virtual DriverException CreateException();
    protected virtual void Load(FrameReader reader);
}
internal class Cassandra.OutputUnavailableException : OutputError {
    private ConsistencyLevel _consistency;
    private int _required;
    private int _alive;
    protected virtual void Load(FrameReader cb);
    public virtual DriverException CreateException();
}
internal class Cassandra.OutputUnprepared : OutputError {
    private PreparedQueryNotFoundInfo _info;
    protected virtual void Load(FrameReader cb);
    public virtual DriverException CreateException();
}
internal class Cassandra.OutputVoid : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <TraceId>k__BackingField;
    public Nullable`1<Guid> TraceId { get; private set; }
    public OutputVoid(Nullable`1<Guid> traceId);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_TraceId();
    [CompilerGeneratedAttribute]
private void set_TraceId(Nullable`1<Guid> value);
    public sealed virtual void Dispose();
}
internal class Cassandra.OutputWriteTimeout : OutputError {
    private int _blockFor;
    private ConsistencyLevel _consistencyLevel;
    private int _received;
    private string _writeType;
    private bool _isFailure;
    private int _failures;
    private IDictionary`2<IPAddress, int> _reasons;
    internal OutputWriteTimeout(bool isFailure);
    protected virtual void Load(FrameReader reader);
    public virtual DriverException CreateException();
}
public class Cassandra.OverloadedException : QueryValidationException {
    public OverloadedException(string message);
}
public class Cassandra.PlainTextAuthProvider : object {
    private string _password;
    private string _username;
    internal string Username { get; }
    public PlainTextAuthProvider(string username, string password);
    internal string get_Username();
    public sealed virtual IAuthenticator NewAuthenticator(IPEndPoint host);
}
public class Cassandra.Policies : object {
    private ILoadBalancingPolicy _loadBalancingPolicy;
    private IReconnectionPolicy _reconnectionPolicy;
    private IRetryPolicy _retryPolicy;
    private ISpeculativeExecutionPolicy _speculativeExecutionPolicy;
    private IExtendedRetryPolicy _extendedRetryPolicy;
    private ITimestampGenerator _timestampGenerator;
    private IColumnEncryptionPolicy _columnEncryptionPolicy;
    public static ILoadBalancingPolicy DefaultLoadBalancingPolicy { get; }
    public static IReconnectionPolicy DefaultReconnectionPolicy { get; }
    public static IRetryPolicy DefaultRetryPolicy { get; }
    internal static IExtendedRetryPolicy DefaultExtendedRetryPolicy { get; }
    public static ISpeculativeExecutionPolicy DefaultSpeculativeExecutionPolicy { get; }
    public static ITimestampGenerator DefaultTimestampGenerator { get; }
    public static Policies DefaultPolicies { get; }
    public ILoadBalancingPolicy LoadBalancingPolicy { get; }
    public IReconnectionPolicy ReconnectionPolicy { get; }
    public IRetryPolicy RetryPolicy { get; }
    public ISpeculativeExecutionPolicy SpeculativeExecutionPolicy { get; }
    internal IExtendedRetryPolicy ExtendedRetryPolicy { get; }
    public ITimestampGenerator TimestampGenerator { get; }
    public IColumnEncryptionPolicy ColumnEncryptionPolicy { get; }
    public Policies(ILoadBalancingPolicy loadBalancingPolicy, IReconnectionPolicy reconnectionPolicy, IRetryPolicy retryPolicy);
    internal Policies(ILoadBalancingPolicy loadBalancingPolicy, IReconnectionPolicy reconnectionPolicy, IRetryPolicy retryPolicy, ISpeculativeExecutionPolicy speculativeExecutionPolicy, ITimestampGenerator timestampGenerator, IColumnEncryptionPolicy columnEncryptionPolicy);
    public static ILoadBalancingPolicy get_DefaultLoadBalancingPolicy();
    public static ILoadBalancingPolicy NewDefaultLoadBalancingPolicy(string localDc);
    public static IReconnectionPolicy get_DefaultReconnectionPolicy();
    public static IRetryPolicy get_DefaultRetryPolicy();
    internal static IExtendedRetryPolicy get_DefaultExtendedRetryPolicy();
    public static ISpeculativeExecutionPolicy get_DefaultSpeculativeExecutionPolicy();
    public static ITimestampGenerator get_DefaultTimestampGenerator();
    public static Policies get_DefaultPolicies();
    public ILoadBalancingPolicy get_LoadBalancingPolicy();
    public IReconnectionPolicy get_ReconnectionPolicy();
    public IRetryPolicy get_RetryPolicy();
    public ISpeculativeExecutionPolicy get_SpeculativeExecutionPolicy();
    internal IExtendedRetryPolicy get_ExtendedRetryPolicy();
    public ITimestampGenerator get_TimestampGenerator();
    public IColumnEncryptionPolicy get_ColumnEncryptionPolicy();
}
public class Cassandra.PoolingOptions : object {
    private static int DefaultMinRequests;
    private static int DefaultMaxRequestsThreshold;
    private static int DefaultCorePoolLocal;
    private static int DefaultCorePoolRemote;
    private static int DefaultMaxPoolLocal;
    private static int DefaultMaxPoolRemote;
    public static int DefaultMaxRequestsPerConnection;
    public static int DefaultHeartBeatInterval;
    private int _coreConnectionsForLocal;
    private int _coreConnectionsForRemote;
    private int _maxConnectionsForLocal;
    private int _maxConnectionsForRemote;
    private int _maxSimultaneousRequestsForLocal;
    private int _maxSimultaneousRequestsForRemote;
    private int _minSimultaneousRequestsForLocal;
    private int _minSimultaneousRequestsForRemote;
    private int _heartBeatInterval;
    private int _maxRequestsPerConnection;
    private bool _warmup;
    public int GetMinSimultaneousRequestsPerConnectionTreshold(HostDistance distance);
    public PoolingOptions SetMinSimultaneousRequestsPerConnectionTreshold(HostDistance distance, int minSimultaneousRequests);
    public int GetMaxSimultaneousRequestsPerConnectionTreshold(HostDistance distance);
    public PoolingOptions SetMaxSimultaneousRequestsPerConnectionTreshold(HostDistance distance, int maxSimultaneousRequests);
    public int GetCoreConnectionsPerHost(HostDistance distance);
    public bool GetWarmup();
    public PoolingOptions SetCoreConnectionsPerHost(HostDistance distance, int coreConnections);
    public int GetMaxConnectionPerHost(HostDistance distance);
    public PoolingOptions SetMaxConnectionsPerHost(HostDistance distance, int maxConnections);
    public Nullable`1<int> GetHeartBeatInterval();
    public PoolingOptions SetHeartBeatInterval(int value);
    public int GetMaxRequestsPerConnection();
    public PoolingOptions SetMaxRequestsPerConnection(int value);
    public PoolingOptions SetWarmup(bool doWarmup);
    public static PoolingOptions Create(ProtocolVersion protocolVersion);
}
public class Cassandra.PreparedQueryNotFoundException : QueryValidationException {
    [CompilerGeneratedAttribute]
private Byte[] <UnknownId>k__BackingField;
    public Byte[] UnknownId { get; private set; }
    public PreparedQueryNotFoundException(string message, Byte[] unknownId);
    [CompilerGeneratedAttribute]
public Byte[] get_UnknownId();
    [CompilerGeneratedAttribute]
private void set_UnknownId(Byte[] value);
}
internal class Cassandra.PreparedQueryNotFoundInfo : object {
    public Byte[] UnknownId;
}
public class Cassandra.PreparedStatement : object {
    private RowSetMetadata _variablesRowsMetadata;
    private ISerializerManager _serializerManager;
    private RoutingKey modreq(System.Runtime.CompilerServices.IsVolatile) _routingKey;
    private String[] _routingNames;
    private Int32[] modreq(System.Runtime.CompilerServices.IsVolatile) _routingIndexes;
    private ResultMetadata modreq(System.Runtime.CompilerServices.IsVolatile) _resultMetadata;
    [CompilerGeneratedAttribute]
private string <Cql>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Byte[]> <IncomingPayload>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Byte[]> <OutgoingPayload>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsIdempotent>k__BackingField;
    internal string Cql { get; private set; }
    internal Byte[] Id { get; private set; }
    internal string Keyspace { get; private set; }
    public IDictionary`2<string, Byte[]> IncomingPayload { get; internal set; }
    public IDictionary`2<string, Byte[]> OutgoingPayload { get; private set; }
    public RowSetMetadata Variables { get; }
    internal ResultMetadata ResultMetadata { get; }
    public RoutingKey RoutingKey { get; }
    public Int32[] RoutingIndexes { get; internal set; }
    public Nullable`1<ConsistencyLevel> ConsistencyLevel { get; private set; }
    public Nullable`1<bool> IsIdempotent { get; private set; }
    public string QueryString { get; }
    internal PreparedStatement(RowSetMetadata variablesRowsMetadata, Byte[] id, ResultMetadata resultMetadata, string cql, string keyspace, ISerializerManager serializer);
    [CompilerGeneratedAttribute]
internal string get_Cql();
    [CompilerGeneratedAttribute]
private void set_Cql(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Byte[] value);
    [CompilerGeneratedAttribute]
internal string get_Keyspace();
    [CompilerGeneratedAttribute]
private void set_Keyspace(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, Byte[]> get_IncomingPayload();
    [CompilerGeneratedAttribute]
internal void set_IncomingPayload(IDictionary`2<string, Byte[]> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, Byte[]> get_OutgoingPayload();
    [CompilerGeneratedAttribute]
private void set_OutgoingPayload(IDictionary`2<string, Byte[]> value);
    public RowSetMetadata get_Variables();
    internal ResultMetadata get_ResultMetadata();
    public RoutingKey get_RoutingKey();
    public Int32[] get_RoutingIndexes();
    internal void set_RoutingIndexes(Int32[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<ConsistencyLevel> get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
private void set_ConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsIdempotent();
    [CompilerGeneratedAttribute]
private void set_IsIdempotent(Nullable`1<bool> value);
    internal void UpdateResultMetadata(ResultMetadata resultMetadata);
    public virtual BoundStatement Bind(Object[] values);
    public PreparedStatement SetConsistencyLevel(ConsistencyLevel consistency);
    internal bool SetPartitionKeys(TableColumn[] keys);
    public PreparedStatement SetRoutingKey(RoutingKey[] routingKeyComponents);
    public PreparedStatement SetRoutingNames(String[] names);
    public PreparedStatement SetIdempotence(bool value);
    public PreparedStatement SetOutgoingPayload(IDictionary`2<string, Byte[]> payload);
    public string get_QueryString();
    public virtual string ToString();
}
public class Cassandra.PreparedStatementIdMismatchException : DriverException {
    [CompilerGeneratedAttribute]
private Byte[] <Id>k__BackingField;
    public Byte[] Id { get; }
    public PreparedStatementIdMismatchException(Byte[] originalId, Byte[] outputId);
    [CompilerGeneratedAttribute]
public Byte[] get_Id();
}
public class Cassandra.PrepareRequest : object {
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    public string Keyspace { get; }
    public string Query { get; }
    internal PrepareRequest(string cql, string keyspace);
    [CompilerGeneratedAttribute]
public string get_Keyspace();
    [CompilerGeneratedAttribute]
public string get_Query();
}
public class Cassandra.ProtocolErrorException : QueryValidationException {
    public ProtocolErrorException(string message);
}
internal class Cassandra.ProtocolEvents.Internal.EventQueue : object {
    public ProtocolEvent modreq(System.Runtime.CompilerServices.IsVolatile) MainEvent;
    [CompilerGeneratedAttribute]
private IList`1<TaskCompletionSource`1<bool>> <Callbacks>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, KeyspaceEvents> <Keyspaces>k__BackingField;
    public IList`1<TaskCompletionSource`1<bool>> Callbacks { get; }
    public IDictionary`2<string, KeyspaceEvents> Keyspaces { get; }
    [CompilerGeneratedAttribute]
public IList`1<TaskCompletionSource`1<bool>> get_Callbacks();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, KeyspaceEvents> get_Keyspaces();
}
internal class Cassandra.ProtocolEvents.Internal.InternalKeyspaceProtocolEvent : object {
    [CompilerGeneratedAttribute]
private KeyspaceProtocolEvent <KeyspaceEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<bool> <Callback>k__BackingField;
    public KeyspaceProtocolEvent KeyspaceEvent { get; public set; }
    public TaskCompletionSource`1<bool> Callback { get; public set; }
    [CompilerGeneratedAttribute]
public KeyspaceProtocolEvent get_KeyspaceEvent();
    [CompilerGeneratedAttribute]
public void set_KeyspaceEvent(KeyspaceProtocolEvent value);
    [CompilerGeneratedAttribute]
public TaskCompletionSource`1<bool> get_Callback();
    [CompilerGeneratedAttribute]
public void set_Callback(TaskCompletionSource`1<bool> value);
}
internal class Cassandra.ProtocolEvents.Internal.KeyspaceEvents : object {
    public ProtocolEvent modreq(System.Runtime.CompilerServices.IsVolatile) RefreshKeyspaceEvent;
    [CompilerGeneratedAttribute]
private IList`1<InternalKeyspaceProtocolEvent> <Events>k__BackingField;
    public IList`1<InternalKeyspaceProtocolEvent> Events { get; }
    [CompilerGeneratedAttribute]
public IList`1<InternalKeyspaceProtocolEvent> get_Events();
}
internal interface Cassandra.ProtocolEvents.IProtocolEventDebouncer {
    public abstract virtual Task ScheduleEventAsync(ProtocolEvent ev, bool processNow);
    public abstract virtual Task HandleEventAsync(ProtocolEvent ev, bool processNow);
    public abstract virtual Task ShutdownAsync();
}
internal interface Cassandra.ProtocolEvents.ITimer {
    public abstract virtual void Cancel();
    public abstract virtual void Change(Action action, TimeSpan due);
}
internal interface Cassandra.ProtocolEvents.ITimerFactory {
    public abstract virtual ITimer Create(TaskScheduler scheduler);
}
internal class Cassandra.ProtocolEvents.KeyspaceProtocolEvent : ProtocolEvent {
    [CompilerGeneratedAttribute]
private bool <IsRefreshKeyspaceEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    public bool IsRefreshKeyspaceEvent { get; }
    public string Keyspace { get; }
    public KeyspaceProtocolEvent(bool isRefreshKeyspaceEvent, string keyspace, Func`1<Task> handler);
    [CompilerGeneratedAttribute]
public bool get_IsRefreshKeyspaceEvent();
    [CompilerGeneratedAttribute]
public string get_Keyspace();
}
internal class Cassandra.ProtocolEvents.ProtocolEvent : object {
    [CompilerGeneratedAttribute]
private Func`1<Task> <Handler>k__BackingField;
    public Func`1<Task> Handler { get; }
    public ProtocolEvent(Func`1<Task> handler);
    [CompilerGeneratedAttribute]
public Func`1<Task> get_Handler();
}
internal class Cassandra.ProtocolEvents.ProtocolEventDebouncer : object {
    private static Logger Logger;
    private ActionBlock`1<Tuple`3<TaskCompletionSource`1<bool>, ProtocolEvent, bool>> _enqueueBlock;
    private ActionBlock`1<EventQueue> _processQueueBlock;
    private SlidingWindowExclusiveTimer _timer;
    private EventQueue modreq(System.Runtime.CompilerServices.IsVolatile) _queue;
    public ProtocolEventDebouncer(ITimerFactory timerFactory, TimeSpan delay, TimeSpan maxDelay);
    private static ProtocolEventDebouncer();
    [AsyncStateMachineAttribute("Cassandra.ProtocolEvents.ProtocolEventDebouncer/<ScheduleEventAsync>d__6")]
public sealed virtual Task ScheduleEventAsync(ProtocolEvent ev, bool processNow);
    [AsyncStateMachineAttribute("Cassandra.ProtocolEvents.ProtocolEventDebouncer/<HandleEventAsync>d__7")]
public sealed virtual Task HandleEventAsync(ProtocolEvent ev, bool processNow);
    [AsyncStateMachineAttribute("Cassandra.ProtocolEvents.ProtocolEventDebouncer/<ShutdownAsync>d__8")]
public sealed virtual Task ShutdownAsync();
    internal EventQueue GetQueue();
    private void MainEventReceived(ProtocolEvent ev, bool processNow, TaskCompletionSource`1<bool> callback);
    private void KeyspaceEventReceived(KeyspaceProtocolEvent ev, bool processNow, TaskCompletionSource`1<bool> callback);
    private void Process();
    [AsyncStateMachineAttribute("Cassandra.ProtocolEvents.ProtocolEventDebouncer/<ProcessQueue>d__13")]
private static Task ProcessQueue(EventQueue queue);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(Tuple`3<TaskCompletionSource`1<bool>, ProtocolEvent, bool> tuple);
}
internal class Cassandra.ProtocolEvents.SlidingWindowExclusiveTimer : object {
    private TimeSpan _delayIncrement;
    private TimeSpan _maxDelay;
    private Action _act;
    private ITimer _timer;
    private TaskFactory _timerTaskFactory;
    private long _windowFirstTimestamp;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isRunning;
    [CompilerGeneratedAttribute]
private TaskScheduler <ExclusiveScheduler>k__BackingField;
    public TaskScheduler ExclusiveScheduler { get; }
    public SlidingWindowExclusiveTimer(ITimerFactory timerFactory, TimeSpan delayIncrement, TimeSpan maxDelay, Action act);
    [CompilerGeneratedAttribute]
public TaskScheduler get_ExclusiveScheduler();
    public sealed virtual void Dispose();
    public void SlideDelay(bool processNow);
    public Task SlideDelayAsync(bool processNow);
    private TimeSpan ComputeTimeUntilNextTrigger(long currentTimestamp);
    private void CancelExistingTimer();
    private void Fire();
}
internal class Cassandra.ProtocolEvents.TaskBasedTimer : object {
    private static Logger Logger;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _task;
    private CancellationTokenSource modreq(System.Runtime.CompilerServices.IsVolatile) _cts;
    private TaskFactory _taskFactory;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    public TaskBasedTimer(TaskScheduler scheduler);
    private static TaskBasedTimer();
    public sealed virtual void Dispose();
    public sealed virtual void Cancel();
    public sealed virtual void Change(Action action, TimeSpan due);
    [CompilerGeneratedAttribute]
private Task <Dispose>b__6_0();
}
internal class Cassandra.ProtocolEvents.TaskBasedTimerFactory : object {
    public sealed virtual ITimer Create(TaskScheduler scheduler);
}
public class Cassandra.ProtocolOptions : object {
    public static int DefaultPort;
    internal static int MaximumFrameLength;
    public static int DefaultMaxSchemaAgreementWaitSeconds;
    private int _port;
    private SSLOptions _sslOptions;
    private CompressionType _compression;
    private IFrameCompressor _compressor;
    private int _maxSchemaAgreementWaitSeconds;
    private Nullable`1<ProtocolVersion> _maxProtocolVersion;
    [CompilerGeneratedAttribute]
private bool <NoCompact>k__BackingField;
    public int Port { get; }
    public SSLOptions SslOptions { get; }
    public CompressionType Compression { get; }
    public IFrameCompressor CustomCompressor { get; }
    public int MaxSchemaAgreementWaitSeconds { get; }
    public bool NoCompact { get; private set; }
    public Nullable`1<byte> MaxProtocolVersion { get; }
    internal Nullable`1<ProtocolVersion> MaxProtocolVersionValue { get; }
    public ProtocolOptions(int port);
    public ProtocolOptions(int port, SSLOptions sslOptions);
    public int get_Port();
    public SSLOptions get_SslOptions();
    public CompressionType get_Compression();
    public IFrameCompressor get_CustomCompressor();
    public int get_MaxSchemaAgreementWaitSeconds();
    [CompilerGeneratedAttribute]
public bool get_NoCompact();
    [CompilerGeneratedAttribute]
private void set_NoCompact(bool value);
    public Nullable`1<byte> get_MaxProtocolVersion();
    internal Nullable`1<ProtocolVersion> get_MaxProtocolVersionValue();
    public ProtocolOptions SetCompression(CompressionType compression);
    public ProtocolOptions SetCustomCompressor(IFrameCompressor compressor);
    public ProtocolOptions SetMaxSchemaAgreementWaitSeconds(int value);
    public ProtocolOptions SetMaxProtocolVersion(byte value);
    public ProtocolOptions SetMaxProtocolVersion(ProtocolVersion value);
    public ProtocolOptions SetNoCompact(bool value);
}
public enum Cassandra.ProtocolVersion : Enum {
    public byte value__;
    public static ProtocolVersion V1;
    public static ProtocolVersion V2;
    public static ProtocolVersion V3;
    public static ProtocolVersion V4;
    public static ProtocolVersion V5;
    public static ProtocolVersion DseV2;
    public static ProtocolVersion MaxSupported;
    public static ProtocolVersion MinSupported;
}
[ExtensionAttribute]
internal static class Cassandra.ProtocolVersionExtensions : object {
    private static Logger Logger;
    private static Version Version60;
    private static Version Version40;
    private static Version Version30;
    private static Version Version22;
    private static Version Version21;
    private static Version Version20;
    private static ProtocolVersionExtensions();
    [ExtensionAttribute]
public static bool IsSupported(ProtocolVersion version, Configuration config);
    [ExtensionAttribute]
public static ProtocolVersion GetLowerSupported(ProtocolVersion version, Configuration config);
    [ExtensionAttribute]
public static ProtocolVersion GetHighestCommon(ProtocolVersion version, Configuration config, IEnumerable`1<Host> hosts);
    [ExtensionAttribute]
public static bool SupportsPreparedPartitionKey(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsSchemaChangeFullMetadata(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsTimestamp(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsBatchFlags(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsNamedValuesInQueries(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsUnset(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsBatch(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsResultMetadataId(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsKeyspaceInRequest(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsDriverInfoInStartup(ProtocolVersion version);
    [ExtensionAttribute]
public static bool SupportsFailureReasons(ProtocolVersion version);
    [ExtensionAttribute]
public static bool Uses2BytesStreamIds(ProtocolVersion version);
    [ExtensionAttribute]
public static bool Uses4BytesCollectionLength(ProtocolVersion version);
    [ExtensionAttribute]
public static bool Uses4BytesQueryFlags(ProtocolVersion version);
    [ExtensionAttribute]
public static bool CanStartupResponseErrorBeWrapped(ProtocolVersion version);
    [ExtensionAttribute]
public static int GetHeaderSize(ProtocolVersion version);
    [ExtensionAttribute]
public static bool IsBeta(ProtocolVersion version);
}
public abstract class Cassandra.QueryExecutionException : QueryValidationException {
    public QueryExecutionException(string message);
    public QueryExecutionException(string message, Exception innerException);
}
public class Cassandra.QueryOptions : object {
    internal static QueryOptions Empty;
    public static ConsistencyLevel DefaultConsistencyLevel;
    public static ConsistencyLevel DefaultSerialConsistencyLevel;
    public static int DefaultPageSize;
    public static bool DefaultRetryOnTimeout;
    private Nullable`1<ConsistencyLevel> _consistency;
    private ConsistencyLevel _defaultConsistencyLevel;
    private int _pageSize;
    private ConsistencyLevel _serialConsistency;
    private bool _retryOnTimeout;
    private bool _defaultIdempotence;
    private bool _prepareOnAllHosts;
    private bool _reprepareOnUp;
    public bool RetryOnTimeout { get; }
    private static QueryOptions();
    public bool get_RetryOnTimeout();
    public QueryOptions SetConsistencyLevel(ConsistencyLevel consistencyLevel);
    internal void SetDefaultConsistencyLevel(ConsistencyLevel consistencyLevel);
    public ConsistencyLevel GetConsistencyLevel();
    public QueryOptions SetSerialConsistencyLevel(ConsistencyLevel serialConsistencyLevel);
    public ConsistencyLevel GetSerialConsistencyLevel();
    public QueryOptions SetPageSize(int pageSize);
    public QueryOptions SetRetryOnTimeout(bool retry);
    public int GetPageSize();
    public QueryOptions SetDefaultIdempotence(bool idempotence);
    public bool GetDefaultIdempotence();
    public bool IsPrepareOnAllHosts();
    public QueryOptions SetPrepareOnAllHosts(bool prepareOnAllHosts);
    public bool IsReprepareOnUp();
    public QueryOptions SetReprepareOnUp(bool reprepareOnUp);
}
public class Cassandra.QueryProtocolOptions : object {
    public static QueryProtocolOptions Default;
    public int PageSize;
    public ConsistencyLevel SerialConsistency;
    private string _keyspace;
    [CompilerGeneratedAttribute]
private bool <SkipMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PagingState>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsistencyLevel <Consistency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RawTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ValueNames>k__BackingField;
    [CompilerGeneratedAttribute]
private RowSetMetadata <VariablesMetadata>k__BackingField;
    public bool SkipMetadata { get; }
    public Byte[] PagingState { get; public set; }
    public Object[] Values { get; private set; }
    public ConsistencyLevel Consistency { get; public set; }
    public Nullable`1<DateTimeOffset> Timestamp { get; }
    internal Nullable`1<long> RawTimestamp { get; }
    public IList`1<string> ValueNames { get; public set; }
    internal RowSetMetadata VariablesMetadata { get; }
    internal string Keyspace { get; }
    internal QueryProtocolOptions(ConsistencyLevel consistency, Object[] values, bool skipMetadata, int pageSize, Byte[] pagingState, ConsistencyLevel serialConsistency, Nullable`1<long> timestamp, string keyspace, RowSetMetadata variablesMetadata);
    private static QueryProtocolOptions();
    [CompilerGeneratedAttribute]
public bool get_SkipMetadata();
    [CompilerGeneratedAttribute]
public Byte[] get_PagingState();
    [CompilerGeneratedAttribute]
public void set_PagingState(Byte[] value);
    [CompilerGeneratedAttribute]
public Object[] get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(Object[] value);
    [CompilerGeneratedAttribute]
public ConsistencyLevel get_Consistency();
    [CompilerGeneratedAttribute]
public void set_Consistency(ConsistencyLevel value);
    public Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_RawTimestamp();
    [CompilerGeneratedAttribute]
public IList`1<string> get_ValueNames();
    [CompilerGeneratedAttribute]
public void set_ValueNames(IList`1<string> value);
    [CompilerGeneratedAttribute]
internal RowSetMetadata get_VariablesMetadata();
    internal string get_Keyspace();
    internal static QueryProtocolOptions CreateFromQuery(ProtocolVersion protocolVersion, Statement query, IRequestOptions requestOptions, Nullable`1<bool> forceSkipMetadata, RowSetMetadata variablesMetadata);
    internal static QueryProtocolOptions CreateForBatchItem(Statement statement, RowSetMetadata variablesMetadata);
    private QueryFlags GetFlags(ProtocolVersion protocolVersion, bool isPrepared);
    internal void Write(FrameWriter wb, bool isPrepared);
}
public abstract class Cassandra.QueryTimeoutException : QueryExecutionException {
    [CompilerGeneratedAttribute]
private ConsistencyLevel <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceivedAcknowledgements>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequiredAcknowledgements>k__BackingField;
    public ConsistencyLevel ConsistencyLevel { get; private set; }
    public int ReceivedAcknowledgements { get; private set; }
    public int RequiredAcknowledgements { get; private set; }
    public QueryTimeoutException(string message, ConsistencyLevel consistencyLevel, int received, int required);
    [CompilerGeneratedAttribute]
public ConsistencyLevel get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
private void set_ConsistencyLevel(ConsistencyLevel value);
    [CompilerGeneratedAttribute]
public int get_ReceivedAcknowledgements();
    [CompilerGeneratedAttribute]
private void set_ReceivedAcknowledgements(int value);
    [CompilerGeneratedAttribute]
public int get_RequiredAcknowledgements();
    [CompilerGeneratedAttribute]
private void set_RequiredAcknowledgements(int value);
}
public class Cassandra.QueryTrace : object {
    private object _fetchLock;
    private Metadata _metadata;
    private Guid _traceId;
    private IPAddress _coordinator;
    private int _duration;
    private List`1<Event> _events;
    private IDictionary`2<string, string> _parameters;
    private string _requestType;
    private long _startedAt;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisconnected;
    private IPAddress _clientAddress;
    private int _metadataFetchSyncTimeout;
    public Guid TraceId { get; }
    public string RequestType { get; internal set; }
    public int DurationMicros { get; internal set; }
    public IPAddress Coordinator { get; internal set; }
    public IDictionary`2<string, string> Parameters { get; internal set; }
    public long StartedAt { get; internal set; }
    public List`1<Event> Events { get; internal set; }
    public IPAddress ClientAddress { get; internal set; }
    public QueryTrace(Guid traceId, ISession session);
    public Guid get_TraceId();
    public string get_RequestType();
    internal void set_RequestType(string value);
    public int get_DurationMicros();
    internal void set_DurationMicros(int value);
    public IPAddress get_Coordinator();
    internal void set_Coordinator(IPAddress value);
    public IDictionary`2<string, string> get_Parameters();
    internal void set_Parameters(IDictionary`2<string, string> value);
    public long get_StartedAt();
    internal void set_StartedAt(long value);
    public List`1<Event> get_Events();
    internal void set_Events(List`1<Event> value);
    public IPAddress get_ClientAddress();
    internal void set_ClientAddress(IPAddress value);
    public virtual string ToString();
    private void MaybeFetchTrace();
    private void DoFetchTrace();
    internal Task`1<QueryTrace> LoadAsync();
}
public abstract class Cassandra.QueryValidationException : DriverException {
    public QueryValidationException(string message);
    public QueryValidationException(string message, Exception innerException);
}
public class Cassandra.ReadFailureException : QueryExecutionException {
    private static IDictionary`2<IPAddress, int> DefaultReasons;
    [CompilerGeneratedAttribute]
private bool <WasDataRetrieved>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsistencyLevel <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceivedAcknowledgements>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequiredAcknowledgements>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Failures>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<IPAddress, int> <Reasons>k__BackingField;
    public bool WasDataRetrieved { get; private set; }
    public ConsistencyLevel ConsistencyLevel { get; private set; }
    public int ReceivedAcknowledgements { get; private set; }
    public int RequiredAcknowledgements { get; private set; }
    public int Failures { get; private set; }
    public IDictionary`2<IPAddress, int> Reasons { get; }
    public ReadFailureException(ConsistencyLevel consistency, int received, int required, bool dataPresent, int failures);
    public ReadFailureException(ConsistencyLevel consistency, int received, int required, bool dataPresent, IDictionary`2<IPAddress, int> reasons);
    private static ReadFailureException();
    [CompilerGeneratedAttribute]
public bool get_WasDataRetrieved();
    [CompilerGeneratedAttribute]
private void set_WasDataRetrieved(bool value);
    [CompilerGeneratedAttribute]
public ConsistencyLevel get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
private void set_ConsistencyLevel(ConsistencyLevel value);
    [CompilerGeneratedAttribute]
public int get_ReceivedAcknowledgements();
    [CompilerGeneratedAttribute]
private void set_ReceivedAcknowledgements(int value);
    [CompilerGeneratedAttribute]
public int get_RequiredAcknowledgements();
    [CompilerGeneratedAttribute]
private void set_RequiredAcknowledgements(int value);
    [CompilerGeneratedAttribute]
public int get_Failures();
    [CompilerGeneratedAttribute]
private void set_Failures(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<IPAddress, int> get_Reasons();
    private static string FormatMessage(ConsistencyLevel consistency, int received, int required, bool dataPresent, int failures);
}
public class Cassandra.ReadTimeoutException : QueryTimeoutException {
    [CompilerGeneratedAttribute]
private bool <WasDataRetrieved>k__BackingField;
    public bool WasDataRetrieved { get; private set; }
    public ReadTimeoutException(ConsistencyLevel consistency, int received, int required, bool dataPresent);
    [CompilerGeneratedAttribute]
public bool get_WasDataRetrieved();
    [CompilerGeneratedAttribute]
private void set_WasDataRetrieved(bool value);
    private static string FormatDetails(int received, int required, bool dataPresent);
}
public abstract class Cassandra.RegularStatement : Statement {
    [CompilerGeneratedAttribute]
private IList`1<string> <QueryValueNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    internal IList`1<string> QueryValueNames { get; internal set; }
    public string QueryString { get; }
    internal ISerializer Serializer { get; internal set; }
    [CompilerGeneratedAttribute]
internal IList`1<string> get_QueryValueNames();
    [CompilerGeneratedAttribute]
internal void set_QueryValueNames(IList`1<string> value);
    public abstract virtual string get_QueryString();
    [CompilerGeneratedAttribute]
internal ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
internal void set_Serializer(ISerializer value);
    public virtual string ToString();
}
public static class Cassandra.ReplicationStrategies : object {
    public static string NetworkTopologyStrategy;
    public static string SimpleStrategy;
    internal static string EverywhereStrategy;
    internal static string LocalStrategy;
    public static Dictionary`2<string, string> CreateSimpleStrategyReplicationProperty(int replicationFactor);
    public static Dictionary`2<string, string> CreateNetworkTopologyStrategyReplicationProperty(Dictionary`2<string, int> datacentersReplicationFactors);
    public static Dictionary`2<string, string> CreateReplicationProperty(string strategyClass, Dictionary`2<string, string> subOptions);
}
public class Cassandra.RequestInvalidException : DriverException {
    public RequestInvalidException(string message);
}
internal class Cassandra.Requests.AuthResponseRequest : BaseRequest {
    public static byte AuthResponseOpCode;
    private Byte[] _token;
    protected byte OpCode { get; }
    public ResultMetadata ResultMetadata { get; }
    public AuthResponseRequest(Byte[] token);
    protected virtual byte get_OpCode();
    public virtual ResultMetadata get_ResultMetadata();
    protected virtual void WriteBody(FrameWriter wb);
}
internal abstract class Cassandra.Requests.BaseRequest : object {
    private HeaderFlags _headerFlags;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TracingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Byte[]> <Payload>k__BackingField;
    private ISerializer Serializer { get; }
    public bool TracingEnabled { get; }
    public IDictionary`2<string, Byte[]> Payload { get; }
    protected byte OpCode { get; }
    public ResultMetadata ResultMetadata { get; }
    protected BaseRequest(ISerializer serializer, bool tracingEnabled, IDictionary`2<string, Byte[]> payload);
    protected BaseRequest(bool tracingEnabled, IDictionary`2<string, Byte[]> payload);
    [CompilerGeneratedAttribute]
private ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TracingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, Byte[]> get_Payload();
    protected abstract virtual byte get_OpCode();
    public abstract virtual ResultMetadata get_ResultMetadata();
    protected abstract virtual void WriteBody(FrameWriter wb);
    public sealed virtual int WriteFrame(short streamId, MemoryStream stream, ISerializer connectionSerializer);
    private void WriteFrameHeader(FrameWriter writer, short streamId);
}
internal class Cassandra.Requests.BatchRequest : BaseRequest {
    private static byte BatchOpCode;
    private QueryFlags _batchFlags;
    private ICollection`1<IQueryRequest> _requests;
    private BatchType _type;
    private Nullable`1<long> _timestamp;
    private string _keyspace;
    [CompilerGeneratedAttribute]
private ConsistencyLevel <SerialConsistency>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsistencyLevel <Consistency>k__BackingField;
    internal ConsistencyLevel SerialConsistency { get; }
    public ConsistencyLevel Consistency { get; public set; }
    protected byte OpCode { get; }
    public ResultMetadata ResultMetadata { get; }
    public BatchRequest(ISerializer serializer, IDictionary`2<string, Byte[]> payload, BatchStatement statement, ConsistencyLevel consistency, IRequestOptions requestOptions);
    [CompilerGeneratedAttribute]
internal ConsistencyLevel get_SerialConsistency();
    [CompilerGeneratedAttribute]
public sealed virtual ConsistencyLevel get_Consistency();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Consistency(ConsistencyLevel value);
    protected virtual byte get_OpCode();
    public virtual ResultMetadata get_ResultMetadata();
    private static Nullable`1<long> GetRequestTimestamp(BatchStatement statement, ITimestampGenerator timestampGenerator);
    protected virtual void WriteBody(FrameWriter wb);
}
internal class Cassandra.Requests.CredentialsRequest : BaseRequest {
    public static byte CredentialsRequestOpCode;
    private IDictionary`2<string, string> _credentials;
    protected byte OpCode { get; }
    public ResultMetadata ResultMetadata { get; }
    public CredentialsRequest(IDictionary`2<string, string> credentials);
    protected virtual byte get_OpCode();
    public virtual ResultMetadata get_ResultMetadata();
    protected virtual void WriteBody(FrameWriter wb);
}
internal class Cassandra.Requests.ExecuteRequest : BaseRequest {
    public static byte ExecuteOpCode;
    private Byte[] _id;
    private QueryProtocolOptions _queryOptions;
    [CompilerGeneratedAttribute]
private ResultMetadata <ResultMetadata>k__BackingField;
    public ConsistencyLevel Consistency { get; public set; }
    public Byte[] PagingState { get; public set; }
    public int PageSize { get; }
    public ConsistencyLevel SerialConsistency { get; }
    public bool SkipMetadata { get; }
    public ResultMetadata ResultMetadata { get; }
    protected byte OpCode { get; }
    public ExecuteRequest(ISerializer serializer, Byte[] id, ResultMetadata resultMetadata, QueryProtocolOptions queryOptions, bool tracingEnabled, IDictionary`2<string, Byte[]> payload, bool isBatchChild);
    public sealed virtual ConsistencyLevel get_Consistency();
    public sealed virtual void set_Consistency(ConsistencyLevel value);
    public sealed virtual Byte[] get_PagingState();
    public sealed virtual void set_PagingState(Byte[] value);
    public int get_PageSize();
    public ConsistencyLevel get_SerialConsistency();
    public sealed virtual bool get_SkipMetadata();
    [CompilerGeneratedAttribute]
public virtual ResultMetadata get_ResultMetadata();
    protected virtual byte get_OpCode();
    protected virtual void WriteBody(FrameWriter wb);
    public sealed virtual void WriteToBatch(FrameWriter wb);
}
internal class Cassandra.Requests.GraphRequestHandler : object {
    private static Logger Logger;
    private IInternalSession _session;
    private IGraphTypeSerializerFactory _graphTypeSerializerFactory;
    public GraphRequestHandler(IInternalSession session, IGraphTypeSerializerFactory graphTypeSerializerFactory);
    private static GraphRequestHandler();
    public sealed virtual Task`1<GraphResultSet> SendAsync(IGraphStatement graphStatement, IRequestOptions requestOptions);
    [AsyncStateMachineAttribute("Cassandra.Requests.GraphRequestHandler/<ExecuteGraphAsync>d__5")]
private Task`1<GraphResultSet> ExecuteGraphAsync(IGraphStatement graphStatement, IRequestOptions requestOptions);
    [AsyncStateMachineAttribute("Cassandra.Requests.GraphRequestHandler/<GetAnalyticsPrimary>d__6")]
private Task`1<IStatement> GetAnalyticsPrimary(IStatement statement, IGraphStatement graphStatement, IRequestOptions requestOptions);
    private IStatement AdaptRpcPrimaryResult(RowSet rowSet, TargettedSimpleStatement statement);
    private GraphResultSet CreateGraphResultSet(RowSet rs, IGraphTypeSerializer serializer);
    private ConvertedStatementResult GetIStatement(IGraphStatement graphStmt, GraphOptions options);
    private ConvertedStatementResult ConvertGraphStatement(IGraphStatement graphStmt, GraphOptions options, GraphProtocol graphProtocol);
}
internal class Cassandra.Requests.GraphTypeSerializerFactory : object {
    private static string CoreEngine;
    private static Logger Logger;
    private GraphSON1TypeSerializer _graphSon1TypeSerializer;
    private IThreadSafeDictionary`2<CacheKey, GraphTypeSerializer> _graphTypeSerializers;
    private static GraphTypeSerializerFactory();
    public sealed virtual GraphProtocol GetDefaultGraphProtocol(IInternalSession session, IGraphStatement statement, GraphOptions options);
    public sealed virtual IGraphTypeSerializer CreateSerializer(IInternalSession session, IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<string, IGraphSONDeserializer>> customDeserializers, IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<Type, IGraphSONSerializer>> customSerializers, GraphProtocol graphProtocol, bool deserializeGraphNodes);
    private Nullable`1<GraphProtocol> GetByKeyspaceMetadata(ISession session, IGraphStatement statement, GraphOptions options);
    private Nullable`1<GraphProtocol> GetByLanguage(IGraphStatement statement, GraphOptions options);
}
internal interface Cassandra.Requests.ICqlRequest {
    public ConsistencyLevel Consistency { get; public set; }
    public abstract virtual ConsistencyLevel get_Consistency();
    public abstract virtual void set_Consistency(ConsistencyLevel value);
}
internal interface Cassandra.Requests.IGraphRequestHandler {
    public abstract virtual Task`1<GraphResultSet> SendAsync(IGraphStatement graphStatement, IRequestOptions requestOptions);
}
internal interface Cassandra.Requests.IGraphTypeSerializerFactory {
    public abstract virtual GraphProtocol GetDefaultGraphProtocol(IInternalSession session, IGraphStatement statement, GraphOptions options);
    public abstract virtual IGraphTypeSerializer CreateSerializer(IInternalSession session, IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<string, IGraphSONDeserializer>> customDeserializers, IReadOnlyDictionary`2<GraphProtocol, IReadOnlyDictionary`2<Type, IGraphSONSerializer>> customSerializers, GraphProtocol graphProtocolVersion, bool deserializeGraphNodes);
}
internal class Cassandra.Requests.InternalPrepareRequest : BaseRequest {
    public static byte PrepareOpCode;
    private Nullable`1<PrepareFlags> _prepareFlags;
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    public string Keyspace { get; }
    public string Query { get; public set; }
    public ResultMetadata ResultMetadata { get; }
    protected byte OpCode { get; }
    public InternalPrepareRequest(ISerializer serializer, string cqlQuery, string keyspace, IDictionary`2<string, Byte[]> payload);
    [CompilerGeneratedAttribute]
public string get_Keyspace();
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    public virtual ResultMetadata get_ResultMetadata();
    protected virtual byte get_OpCode();
    protected virtual void WriteBody(FrameWriter wb);
}
internal interface Cassandra.Requests.IPrepareHandler {
    public abstract virtual Task`1<PreparedStatement> Prepare(InternalPrepareRequest request, IInternalSession session, IEnumerator`1<Host> queryPlan);
}
internal interface Cassandra.Requests.IPrepareHandlerFactory {
    public abstract virtual IPrepareHandler CreatePrepareHandler(ISerializerManager serializerManager, IInternalCluster cluster, IInternalSession session, InternalPrepareRequest request);
    public abstract virtual IReprepareHandler CreateReprepareHandler();
}
internal interface Cassandra.Requests.IQueryRequest {
    public Byte[] PagingState { get; public set; }
    public bool SkipMetadata { get; }
    public abstract virtual Byte[] get_PagingState();
    public abstract virtual void set_PagingState(Byte[] value);
    public abstract virtual bool get_SkipMetadata();
    public abstract virtual void WriteToBatch(FrameWriter writer);
}
internal interface Cassandra.Requests.IReprepareHandler {
    public abstract virtual Task ReprepareOnAllNodesWithExistingConnections(IInternalSession session, InternalPrepareRequest request, PrepareResult prepareResult, IRequestObserver observer, SessionRequestInfo sessionRequestInfo);
    public abstract virtual Task ReprepareOnSingleNodeAsync(KeyValuePair`2<Host, IHostConnectionPool> poolKvp, PreparedStatement ps, IRequest request, SemaphoreSlim sem, bool throwException);
    public abstract virtual Task ReprepareOnSingleNodeAsync(IRequestObserver observer, SessionRequestInfo sessionRequestInfo, KeyValuePair`2<Host, IHostConnectionPool> poolKvp, PreparedStatement ps, IRequest request, SemaphoreSlim sem, bool throwException);
}
internal interface Cassandra.Requests.IRequest {
    public bool TracingEnabled { get; }
    public IDictionary`2<string, Byte[]> Payload { get; }
    public ResultMetadata ResultMetadata { get; }
    public abstract virtual bool get_TracingEnabled();
    public abstract virtual IDictionary`2<string, Byte[]> get_Payload();
    public abstract virtual int WriteFrame(short streamId, MemoryStream stream, ISerializer connectionSerializer);
    public abstract virtual ResultMetadata get_ResultMetadata();
}
internal interface Cassandra.Requests.IRequestExecution {
    public abstract virtual void Cancel();
    public abstract virtual Host Start(bool currentHostRetry);
}
internal interface Cassandra.Requests.IRequestExecutionFactory {
    public abstract virtual IRequestExecution Create(IRequestHandler parent, IInternalSession session, IRequest request, IRequestObserver requestObserver, SessionRequestInfo sessionRequestInfo);
}
internal interface Cassandra.Requests.IRequestHandler {
    public IRequestOptions RequestOptions { get; }
    public IExtendedRetryPolicy RetryPolicy { get; }
    public ISerializer Serializer { get; }
    public IStatement Statement { get; }
    public abstract virtual IRequestOptions get_RequestOptions();
    public abstract virtual IExtendedRetryPolicy get_RetryPolicy();
    public abstract virtual ISerializer get_Serializer();
    public abstract virtual IStatement get_Statement();
    public abstract virtual Task`1<bool> SetCompletedAsync(Exception ex, RowSet result);
    public abstract virtual Task`1<bool> SetCompletedAsync(RowSet result, Func`1<Task> action);
    public abstract virtual Task SetNoMoreHostsAsync(NoHostAvailableException ex, IRequestExecution execution);
    public abstract virtual bool HasCompleted();
    public abstract virtual ValidHost GetNextValidHost(Dictionary`2<IPEndPoint, Exception> triedHosts);
    public abstract virtual Task`1<IConnection> GetNextConnectionAsync(Dictionary`2<IPEndPoint, Exception> triedHosts);
    public abstract virtual Task`1<IConnection> GetConnectionToValidHostAsync(ValidHost validHost, IDictionary`2<IPEndPoint, Exception> triedHosts);
    public abstract virtual Task`1<IConnection> ValidateHostAndGetConnectionAsync(Host host, Dictionary`2<IPEndPoint, Exception> triedHosts);
    public abstract virtual Task`1<RowSet> SendAsync();
    public abstract virtual IRequest BuildRequest();
    public abstract virtual bool OnNewNodeExecution(NodeRequestInfo nodeRequestInfo);
    public abstract virtual bool SetNodeExecutionCompleted(Guid executionId);
}
internal interface Cassandra.Requests.IRequestHandlerFactory {
    public abstract virtual Task`1<IRequestHandler> CreateAsync(IInternalSession session, ISerializer serializer, IRequest request, IStatement statement, IRequestOptions options);
    public abstract virtual Task`1<IRequestHandler> CreateAsync(IInternalSession session, ISerializer serializer, IStatement statement, IRequestOptions options);
    public abstract virtual Task`1<IRequestHandler> CreateAsync(IInternalSession session, ISerializer serializer);
    public abstract virtual IGraphRequestHandler CreateGraphRequestHandler(IInternalSession session, IGraphTypeSerializerFactory graphTypeSerializerFactory);
}
internal interface Cassandra.Requests.IRequestResultHandler {
    public Task`1<RowSet> Task { get; }
    public abstract virtual Task TrySetResultAsync(RowSet result, SessionRequestInfo sessionRequestInfo);
    public abstract virtual Task TrySetExceptionAsync(Exception exception, SessionRequestInfo sessionRequestInfo);
    public abstract virtual Task`1<RowSet> get_Task();
}
internal interface Cassandra.Requests.IStartupOptionsFactory {
    public abstract virtual IReadOnlyDictionary`2<string, string> CreateStartupOptions(ProtocolOptions options);
}
internal interface Cassandra.Requests.IStartupRequestFactory {
    public abstract virtual IRequest CreateStartupRequest(ProtocolOptions protocolOptions);
}
internal class Cassandra.Requests.OptionsRequest : BaseRequest {
    public static byte OptionsOpCode;
    protected byte OpCode { get; }
    public ResultMetadata ResultMetadata { get; }
    protected virtual byte get_OpCode();
    public virtual ResultMetadata get_ResultMetadata();
    protected virtual void WriteBody(FrameWriter wb);
}
internal class Cassandra.Requests.PrepareHandler : object {
    internal static Logger Logger;
    private ISerializerManager _serializerManager;
    private IInternalCluster _cluster;
    private IReprepareHandler _reprepareHandler;
    public PrepareHandler(ISerializerManager serializerManager, IInternalCluster cluster, IReprepareHandler reprepareHandler);
    private static PrepareHandler();
    [AsyncStateMachineAttribute("Cassandra.Requests.PrepareHandler/<Prepare>d__5")]
public sealed virtual Task`1<PreparedStatement> Prepare(InternalPrepareRequest request, IInternalSession session, IEnumerator`1<Host> queryPlan);
    [AsyncStateMachineAttribute("Cassandra.Requests.PrepareHandler/<CreateRequestObserverAsync>d__6")]
public static Task`1<Tuple`2<SessionRequestInfo, IRequestObserver>> CreateRequestObserverAsync(IInternalSession session, InternalPrepareRequest request);
    [AsyncStateMachineAttribute("Cassandra.Requests.PrepareHandler/<SendRequestToOneNode>d__7")]
private Task`1<PrepareResult> SendRequestToOneNode(IInternalSession session, IEnumerator`1<Host> queryPlan, InternalPrepareRequest request, IRequestObserver observer, SessionRequestInfo info);
    private static bool CanBeRetried(Exception ex);
    [AsyncStateMachineAttribute("Cassandra.Requests.PrepareHandler/<GetNextConnection>d__9")]
private Task`1<Tuple`2<Host, IConnection>> GetNextConnection(IInternalSession session, IEnumerator`1<Host> queryPlan, Dictionary`2<IPEndPoint, Exception> triedHosts);
    private Host GetNextHost(IEnumerator`1<Host> queryPlan, HostDistance& distance);
    [AsyncStateMachineAttribute("Cassandra.Requests.PrepareHandler/<GetPreparedStatement>d__11")]
private Task`1<PreparedStatement> GetPreparedStatement(Response response, InternalPrepareRequest request, string keyspace, ICluster cluster);
    [AsyncStateMachineAttribute("Cassandra.Requests.PrepareHandler/<FillRoutingInfo>d__12")]
private static Task FillRoutingInfo(PreparedStatement ps, ICluster cluster);
}
internal class Cassandra.Requests.PrepareHandlerFactory : object {
    public sealed virtual IPrepareHandler CreatePrepareHandler(ISerializerManager serializerManager, IInternalCluster cluster, IInternalSession session, InternalPrepareRequest request);
    public sealed virtual IReprepareHandler CreateReprepareHandler();
}
internal class Cassandra.Requests.PrepareResult : object {
    [CompilerGeneratedAttribute]
private PreparedStatement <PreparedStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<IPEndPoint, Exception> <TriedHosts>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <HostAddress>k__BackingField;
    public PreparedStatement PreparedStatement { get; public set; }
    public IDictionary`2<IPEndPoint, Exception> TriedHosts { get; public set; }
    public IPEndPoint HostAddress { get; public set; }
    [CompilerGeneratedAttribute]
public PreparedStatement get_PreparedStatement();
    [CompilerGeneratedAttribute]
public void set_PreparedStatement(PreparedStatement value);
    [CompilerGeneratedAttribute]
public IDictionary`2<IPEndPoint, Exception> get_TriedHosts();
    [CompilerGeneratedAttribute]
public void set_TriedHosts(IDictionary`2<IPEndPoint, Exception> value);
    [CompilerGeneratedAttribute]
public IPEndPoint get_HostAddress();
    [CompilerGeneratedAttribute]
public void set_HostAddress(IPEndPoint value);
}
internal class Cassandra.Requests.QueryRequest : BaseRequest {
    public static byte QueryOpCode;
    private string _cqlQuery;
    private QueryProtocolOptions _queryOptions;
    public ConsistencyLevel Consistency { get; public set; }
    public Byte[] PagingState { get; public set; }
    public bool SkipMetadata { get; }
    public int PageSize { get; }
    public ConsistencyLevel SerialConsistency { get; }
    public ResultMetadata ResultMetadata { get; }
    public string Query { get; }
    protected byte OpCode { get; }
    public QueryRequest(ISerializer serializer, string cqlQuery, QueryProtocolOptions queryOptions, bool tracingEnabled, IDictionary`2<string, Byte[]> payload);
    public sealed virtual ConsistencyLevel get_Consistency();
    public sealed virtual void set_Consistency(ConsistencyLevel value);
    public sealed virtual Byte[] get_PagingState();
    public sealed virtual void set_PagingState(Byte[] value);
    public sealed virtual bool get_SkipMetadata();
    public int get_PageSize();
    public ConsistencyLevel get_SerialConsistency();
    public virtual ResultMetadata get_ResultMetadata();
    public string get_Query();
    protected virtual byte get_OpCode();
    protected virtual void WriteBody(FrameWriter wb);
    public sealed virtual void WriteToBatch(FrameWriter wb);
}
internal class Cassandra.Requests.RegisterForEventRequest : BaseRequest {
    public static byte RegisterOpCode;
    private List`1<string> _eventTypes;
    protected byte OpCode { get; }
    public ResultMetadata ResultMetadata { get; }
    public RegisterForEventRequest(CassandraEventType eventTypes);
    protected virtual byte get_OpCode();
    public virtual ResultMetadata get_ResultMetadata();
    protected virtual void WriteBody(FrameWriter wb);
}
internal class Cassandra.Requests.ReprepareHandler : object {
    [AsyncStateMachineAttribute("Cassandra.Requests.ReprepareHandler/<ReprepareOnAllNodesWithExistingConnections>d__0")]
public sealed virtual Task ReprepareOnAllNodesWithExistingConnections(IInternalSession session, InternalPrepareRequest request, PrepareResult prepareResult, IRequestObserver observer, SessionRequestInfo sessionRequestInfo);
    private static Task`1<IConnection> GetConnectionFromHostAsync(IHostConnectionPool pool, PreparedStatement ps, IDictionary`2<IPEndPoint, Exception> triedHosts);
    [AsyncStateMachineAttribute("Cassandra.Requests.ReprepareHandler/<GetConnectionFromHostInternalAsync>d__2")]
private static Task`1<IConnection> GetConnectionFromHostInternalAsync(IHostConnectionPool pool, PreparedStatement ps, IDictionary`2<IPEndPoint, Exception> triedHosts, bool retry);
    public sealed virtual Task ReprepareOnSingleNodeAsync(KeyValuePair`2<Host, IHostConnectionPool> poolKvp, PreparedStatement ps, IRequest request, SemaphoreSlim sem, bool throwException);
    [AsyncStateMachineAttribute("Cassandra.Requests.ReprepareHandler/<ReprepareOnSingleNodeAsync>d__4")]
public sealed virtual Task ReprepareOnSingleNodeAsync(IRequestObserver observer, SessionRequestInfo sessionRequestInfo, KeyValuePair`2<Host, IHostConnectionPool> poolKvp, PreparedStatement ps, IRequest request, SemaphoreSlim sem, bool throwException);
    private void LogOrThrow(bool throwException, Exception ex, string msg, Object[] args);
}
internal enum Cassandra.Requests.RequestErrorType : Enum {
    public int value__;
    public static RequestErrorType ReadTimeOut;
    public static RequestErrorType WriteTimeOut;
    public static RequestErrorType Unavailable;
    public static RequestErrorType Other;
    public static RequestErrorType Aborted;
    public static RequestErrorType Unsent;
    public static RequestErrorType ClientTimeout;
}
internal class Cassandra.Requests.RequestExecution : object {
    private static Logger Logger;
    private IRequestHandler _parent;
    private IInternalSession _session;
    private IRequest _request;
    private Dictionary`2<IPEndPoint, Exception> _triedHosts;
    private IConnection modreq(System.Runtime.CompilerServices.IsVolatile) _connection;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _retryCount;
    private OperationState modreq(System.Runtime.CompilerServices.IsVolatile) _operation;
    private IRequestObserver _requestObserver;
    private SessionRequestInfo _sessionRequestInfo;
    private Host modreq(System.Runtime.CompilerServices.IsVolatile) _host;
    public RequestExecution(IRequestHandler parent, IInternalSession session, IRequest request, IRequestObserver requestObserver, SessionRequestInfo sessionRequestInfo);
    private static RequestExecution();
    public sealed virtual void Cancel();
    public sealed virtual Host Start(bool currentHostRetry);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestExecution/<SendToCurrentHostAsync>d__14")]
private Task SendToCurrentHostAsync();
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestExecution/<SendToNextHostAsync>d__15")]
private Task SendToNextHostAsync(ValidHost validHost);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestExecution/<RetryExecutionAsync>d__16")]
private Task RetryExecutionAsync(bool currentHostRetry, Host host);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestExecution/<SendAsync>d__17")]
private Task SendAsync(IRequest request, Host host, Func`4<IRequestError, Response, NodeRequestInfo, Task> callback);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestExecution/<HandleResponseAsync>d__18")]
private Task HandleResponseAsync(IRequestError error, Response response, NodeRequestInfo nodeRequestInfo);
    private Task RetryAsync(Nullable`1<ConsistencyLevel> consistency, bool useCurrentHost, Host host);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestExecution/<HandleRowSetResultAsync>d__20")]
private Task HandleRowSetResultAsync(Response response, NodeRequestInfo nodeRequestInfo);
    private Task HandleSchemaChangeAsync(ResultResponse response, OutputSchemaChange schemaChange);
    private RowSet FillRowSet(RowSet rs, ResultResponse response);
    private void SetAutoPage(RowSet rs, IInternalSession session);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestExecution/<HandleRequestErrorAsync>d__24")]
private Task HandleRequestErrorAsync(IRequestError error, NodeRequestInfo nodeRequestInfo);
    private Task ObserveNodeRequestErrorAsync(IRequestError error, RequestErrorType errorType, RetryDecisionType decision, SessionRequestInfo r, NodeRequestInfo nodeRequestInfo, Exception ex);
    internal static RetryDecisionWithReason GetRetryDecisionWithReason(IRequestError error, IExtendedRetryPolicy policy, IStatement statement, Configuration config, int retryCount);
    internal static RequestErrorType GetErrorType(IRequestError error);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestExecution/<PrepareAndRetryAsync>d__28")]
private Task PrepareAndRetryAsync(PreparedQueryNotFoundException ex, NodeRequestInfo nodeRequestInfo);
    private Func`4<IRequestError, Response, NodeRequestInfo, Task> NewReprepareResponseHandler(PreparedQueryNotFoundException originalError);
    private static void ValidateResult(Response response);
}
internal class Cassandra.Requests.RequestExecutionFactory : object {
    public sealed virtual IRequestExecution Create(IRequestHandler parent, IInternalSession session, IRequest request, IRequestObserver requestObserver, SessionRequestInfo sessionRequestInfo);
}
internal class Cassandra.Requests.RequestHandler : object {
    private static Logger Logger;
    public static long StateInit;
    public static long StateCompleted;
    private IRequest _request;
    private IInternalSession _session;
    private IRequestResultHandler _requestResultHandler;
    private long _state;
    private IEnumerator`1<Host> _queryPlan;
    private object _queryPlanLock;
    private ICollection`1<IRequestExecution> _running;
    private ISpeculativeExecutionPlan _executionPlan;
    private ITimeout modreq(System.Runtime.CompilerServices.IsVolatile) _nextExecutionTimeout;
    private IRequestObserver _requestObserver;
    private SessionRequestInfo _sessionRequestInfo;
    [CompilerGeneratedAttribute]
private IExtendedRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IStatement <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestOptions <RequestOptions>k__BackingField;
    private Dictionary`2<Guid, NodeRequestInfo> _nodeExecutions;
    private object _nodeExecutionLock;
    private bool _nodeExecutionsCleared;
    public IExtendedRetryPolicy RetryPolicy { get; }
    public ISerializer Serializer { get; }
    public IStatement Statement { get; }
    public IRequestOptions RequestOptions { get; }
    public RequestHandler(IInternalSession session, ISerializer serializer, IRequest request, SessionRequestInfo sessionRequestInfo, IRequestOptions requestOptions, IRequestObserver requestObserver);
    public RequestHandler(IInternalSession session, ISerializer serializer, SessionRequestInfo sessionRequestInfo, IRequestOptions requestOptions, IRequestObserver requestObserver);
    public RequestHandler(IInternalSession session, ISerializer serializer, SessionRequestInfo sessionRequestInfo, IRequestObserver requestObserver);
    private static RequestHandler();
    [CompilerGeneratedAttribute]
public sealed virtual IExtendedRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
public sealed virtual ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
public sealed virtual IStatement get_Statement();
    [CompilerGeneratedAttribute]
public sealed virtual IRequestOptions get_RequestOptions();
    private static IEnumerable`1<Host> GetQueryPlan(ISession session, IStatement statement, ILoadBalancingPolicy lbp);
    public sealed virtual IRequest BuildRequest();
    public sealed virtual bool OnNewNodeExecution(NodeRequestInfo nodeRequestInfo);
    public sealed virtual bool SetNodeExecutionCompleted(Guid executionId);
    internal static IRequest GetRequest(IStatement statement, ISerializer serializer, IRequestOptions requestOptions);
    public sealed virtual Task`1<bool> SetCompletedAsync(Exception ex, RowSet result);
    public sealed virtual Task`1<bool> SetCompletedAsync(RowSet result, Func`1<Task> action);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandler/<SetCompletedAsync>d__39")]
private Task`1<bool> SetCompletedAsync(Exception ex, RowSet result, Func`1<Task> action);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandler/<ClearNodeExecutionsAsync>d__40")]
private Task ClearNodeExecutionsAsync();
    public sealed virtual Task SetNoMoreHostsAsync(NoHostAvailableException ex, IRequestExecution execution);
    public sealed virtual bool HasCompleted();
    private Host GetNextHost();
    public sealed virtual ValidHost GetNextValidHost(Dictionary`2<IPEndPoint, Exception> triedHosts);
    private bool TryValidateHost(Host host, ValidHost& validHost);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandler/<GetNextConnectionAsync>d__46")]
public sealed virtual Task`1<IConnection> GetNextConnectionAsync(Dictionary`2<IPEndPoint, Exception> triedHosts);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandler/<ValidateHostAndGetConnectionAsync>d__47")]
public sealed virtual Task`1<IConnection> ValidateHostAndGetConnectionAsync(Host host, Dictionary`2<IPEndPoint, Exception> triedHosts);
    public sealed virtual Task`1<IConnection> GetConnectionToValidHostAsync(ValidHost validHost, IDictionary`2<IPEndPoint, Exception> triedHosts);
    internal static Task`1<IConnection> GetConnectionFromHostAsync(Host host, HostDistance distance, IInternalSession session, IDictionary`2<IPEndPoint, Exception> triedHosts);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandler/<GetConnectionFromHostInternalAsync>d__50")]
private static Task`1<IConnection> GetConnectionFromHostInternalAsync(Host host, HostDistance distance, IInternalSession session, IDictionary`2<IPEndPoint, Exception> triedHosts, bool retry);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandler/<SendAsync>d__51")]
public sealed virtual Task`1<RowSet> SendAsync();
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandler/<StartNewExecutionAsync>d__52")]
private Task StartNewExecutionAsync();
    private void ScheduleNext(Host currentHost);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandler/<CreateRequestObserver>d__54")]
public static Task`1<Tuple`2<SessionRequestInfo, IRequestObserver>> CreateRequestObserver(IInternalSession session, IStatement statement);
}
internal class Cassandra.Requests.RequestHandlerFactory : object {
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandlerFactory/<CreateAsync>d__0")]
public sealed virtual Task`1<IRequestHandler> CreateAsync(IInternalSession session, ISerializer serializer, IRequest request, IStatement statement, IRequestOptions options);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandlerFactory/<CreateAsync>d__1")]
public sealed virtual Task`1<IRequestHandler> CreateAsync(IInternalSession session, ISerializer serializer, IStatement statement, IRequestOptions options);
    [AsyncStateMachineAttribute("Cassandra.Requests.RequestHandlerFactory/<CreateAsync>d__2")]
public sealed virtual Task`1<IRequestHandler> CreateAsync(IInternalSession session, ISerializer serializer);
    public sealed virtual IGraphRequestHandler CreateGraphRequestHandler(IInternalSession session, IGraphTypeSerializerFactory graphTypeSerializerFactory);
}
internal class Cassandra.Requests.ResultMetadata : object {
    [CompilerGeneratedAttribute]
private Byte[] <ResultMetadataId>k__BackingField;
    [CompilerGeneratedAttribute]
private RowSetMetadata <RowSetMetadata>k__BackingField;
    public Byte[] ResultMetadataId { get; }
    public RowSetMetadata RowSetMetadata { get; }
    public ResultMetadata(Byte[] resultMetadataId, RowSetMetadata rowSetMetadata);
    [CompilerGeneratedAttribute]
public Byte[] get_ResultMetadataId();
    [CompilerGeneratedAttribute]
public RowSetMetadata get_RowSetMetadata();
    public bool ContainsColumnDefinitions();
}
internal class Cassandra.Requests.RetryDecisionWithReason : ValueType {
    [CompilerGeneratedAttribute]
private RetryDecision <Decision>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestErrorType <Reason>k__BackingField;
    public RetryDecision Decision { get; }
    public RequestErrorType Reason { get; }
    public RetryDecisionWithReason(RetryDecision decision, RequestErrorType reason);
    [CompilerGeneratedAttribute]
public RetryDecision get_Decision();
    [CompilerGeneratedAttribute]
public RequestErrorType get_Reason();
}
internal class Cassandra.Requests.StartupOptionsFactory : object {
    public static string CqlVersionOption;
    public static string CompressionOption;
    public static string NoCompactOption;
    public static string DriverNameOption;
    public static string DriverVersionOption;
    public static string ApplicationNameOption;
    public static string ApplicationVersionOption;
    public static string ClientIdOption;
    public static string CqlVersion;
    public static string SnappyCompression;
    public static string Lz4Compression;
    private string _appName;
    private string _appVersion;
    private Guid _clusterId;
    public StartupOptionsFactory(Guid clusterId, string appVersion, string appName);
    public sealed virtual IReadOnlyDictionary`2<string, string> CreateStartupOptions(ProtocolOptions options);
}
internal class Cassandra.Requests.StartupRequest : BaseRequest {
    public static byte StartupOpCode;
    private IReadOnlyDictionary`2<string, string> _options;
    protected byte OpCode { get; }
    public ResultMetadata ResultMetadata { get; }
    public StartupRequest(IReadOnlyDictionary`2<string, string> startupOptions);
    protected virtual byte get_OpCode();
    public virtual ResultMetadata get_ResultMetadata();
    protected virtual void WriteBody(FrameWriter wb);
}
internal class Cassandra.Requests.StartupRequestFactory : object {
    private IStartupOptionsFactory _optionsFactory;
    public StartupRequestFactory(IStartupOptionsFactory optionsFactory);
    public sealed virtual IRequest CreateStartupRequest(ProtocolOptions protocolOptions);
}
internal class Cassandra.Requests.TcsMetricsRequestResultHandler : object {
    private IRequestObserver _requestObserver;
    private TaskCompletionSource`1<RowSet> _taskCompletionSource;
    private long _done;
    public Task`1<RowSet> Task { get; }
    public TcsMetricsRequestResultHandler(IRequestObserver requestObserver);
    [AsyncStateMachineAttribute("Cassandra.Requests.TcsMetricsRequestResultHandler/<TrySetResultAsync>d__4")]
public sealed virtual Task TrySetResultAsync(RowSet result, SessionRequestInfo sessionRequestInfo);
    [AsyncStateMachineAttribute("Cassandra.Requests.TcsMetricsRequestResultHandler/<TrySetExceptionAsync>d__5")]
public sealed virtual Task TrySetExceptionAsync(Exception exception, SessionRequestInfo sessionRequestInfo);
    public sealed virtual Task`1<RowSet> get_Task();
}
internal class Cassandra.Requests.ValidHost : object {
    [CompilerGeneratedAttribute]
private Host <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private HostDistance <Distance>k__BackingField;
    public Host Host { get; }
    public HostDistance Distance { get; }
    private ValidHost(Host host, HostDistance distance);
    [CompilerGeneratedAttribute]
public Host get_Host();
    [CompilerGeneratedAttribute]
public HostDistance get_Distance();
    public static ValidHost New(Host host, HostDistance distance);
}
internal class Cassandra.Responses.AuthChallengeResponse : Response {
    public static byte OpCode;
    public Byte[] Token;
    internal AuthChallengeResponse(Frame frame);
    internal static AuthChallengeResponse Create(Frame frame);
}
internal class Cassandra.Responses.AuthenticateResponse : Response {
    public static byte OpCode;
    public string Authenticator;
    internal AuthenticateResponse(Frame frame);
    internal static AuthenticateResponse Create(Frame frame);
}
internal class Cassandra.Responses.AuthSuccessResponse : Response {
    public static byte OpCode;
    public Byte[] Token;
    internal AuthSuccessResponse(Frame frame);
    internal static AuthSuccessResponse Create(Frame frame);
}
internal class Cassandra.Responses.ErrorResponse : Response {
    public static byte OpCode;
    public OutputError Output;
    internal ErrorResponse(Frame frame);
    internal static ErrorResponse Create(Frame frame);
}
internal class Cassandra.Responses.EventResponse : Response {
    public static byte OpCode;
    private Logger _logger;
    [CompilerGeneratedAttribute]
private CassandraEventArgs <CassandraEventArgs>k__BackingField;
    public CassandraEventArgs CassandraEventArgs { get; public set; }
    internal EventResponse(Frame frame);
    [CompilerGeneratedAttribute]
public CassandraEventArgs get_CassandraEventArgs();
    [CompilerGeneratedAttribute]
public void set_CassandraEventArgs(CassandraEventArgs value);
    public static SchemaChangeEventArgs ParseSchemaChangeBody(ProtocolVersion protocolVersion, FrameReader reader);
    internal static EventResponse Create(Frame frame);
}
internal class Cassandra.Responses.ReadyResponse : Response {
    public static byte OpCode;
    internal ReadyResponse(Frame frame);
    internal static ReadyResponse Create(Frame frame);
}
internal class Cassandra.Responses.Response : object {
    [CompilerGeneratedAttribute]
private FrameReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <TraceId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Warnings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Byte[]> <CustomPayload>k__BackingField;
    protected FrameReader Reader { get; }
    protected internal Nullable`1<Guid> TraceId { get; }
    public String[] Warnings { get; }
    public IDictionary`2<string, Byte[]> CustomPayload { get; }
    internal Response(Frame frame);
    [CompilerGeneratedAttribute]
protected FrameReader get_Reader();
    [CompilerGeneratedAttribute]
protected internal Nullable`1<Guid> get_TraceId();
    [CompilerGeneratedAttribute]
public String[] get_Warnings();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, Byte[]> get_CustomPayload();
}
internal class Cassandra.Responses.ResultResponse : Response {
    public static byte OpCode;
    [CompilerGeneratedAttribute]
private ResultResponseKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IOutput <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultMetadata <NewResultMetadata>k__BackingField;
    public ResultResponseKind Kind { get; private set; }
    public IOutput Output { get; private set; }
    public ResultMetadata NewResultMetadata { get; }
    internal ResultResponse(Frame frame);
    protected ResultResponse(ResultResponseKind kind, IOutput output);
    [CompilerGeneratedAttribute]
public ResultResponseKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(ResultResponseKind value);
    [CompilerGeneratedAttribute]
public IOutput get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(IOutput value);
    [CompilerGeneratedAttribute]
public ResultMetadata get_NewResultMetadata();
    internal static ResultResponse Create(Frame frame);
}
internal class Cassandra.Responses.SupportedResponse : Response {
    public static byte OpCode;
    public OutputOptions Output;
    internal SupportedResponse(Frame frame);
    internal static SupportedResponse Create(Frame frame);
}
public class Cassandra.RetryDecision : object {
    [CompilerGeneratedAttribute]
private RetryDecisionType <DecisionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <RetryConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCurrentHost>k__BackingField;
    public RetryDecisionType DecisionType { get; private set; }
    public Nullable`1<ConsistencyLevel> RetryConsistencyLevel { get; private set; }
    public bool UseCurrentHost { get; private set; }
    private RetryDecision(RetryDecisionType type, Nullable`1<ConsistencyLevel> retryConsistencyLevel, bool useCurrentHost);
    [CompilerGeneratedAttribute]
public RetryDecisionType get_DecisionType();
    [CompilerGeneratedAttribute]
private void set_DecisionType(RetryDecisionType value);
    [CompilerGeneratedAttribute]
public Nullable`1<ConsistencyLevel> get_RetryConsistencyLevel();
    [CompilerGeneratedAttribute]
private void set_RetryConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public bool get_UseCurrentHost();
    [CompilerGeneratedAttribute]
private void set_UseCurrentHost(bool value);
    public static RetryDecision Rethrow();
    public static RetryDecision Retry(Nullable`1<ConsistencyLevel> consistency, bool useCurrentHost);
    public static RetryDecision Retry(Nullable`1<ConsistencyLevel> consistency);
    public static RetryDecision Ignore();
}
public class Cassandra.RetryLoadBalancingPolicy : object {
    public EventHandler`1<RetryLoadBalancingPolicyEventArgs> ReconnectionEvent;
    [CompilerGeneratedAttribute]
private IReconnectionPolicy <ReconnectionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoadBalancingPolicy <LoadBalancingPolicy>k__BackingField;
    public IReconnectionPolicy ReconnectionPolicy { get; }
    public ILoadBalancingPolicy LoadBalancingPolicy { get; }
    public RetryLoadBalancingPolicy(ILoadBalancingPolicy loadBalancingPolicy, IReconnectionPolicy reconnectionPolicy);
    [CompilerGeneratedAttribute]
public IReconnectionPolicy get_ReconnectionPolicy();
    [CompilerGeneratedAttribute]
public ILoadBalancingPolicy get_LoadBalancingPolicy();
    public sealed virtual void Initialize(ICluster cluster);
    public sealed virtual HostDistance Distance(Host host);
    [IteratorStateMachineAttribute("Cassandra.RetryLoadBalancingPolicy/<NewQueryPlan>d__10")]
public sealed virtual IEnumerable`1<Host> NewQueryPlan(string keyspace, IStatement query);
}
public class Cassandra.RetryLoadBalancingPolicyEventArgs : EventArgs {
    public bool Cancel;
    [CompilerGeneratedAttribute]
private long <DelayMs>k__BackingField;
    public long DelayMs { get; private set; }
    public RetryLoadBalancingPolicyEventArgs(long delayMs);
    [CompilerGeneratedAttribute]
public long get_DelayMs();
    [CompilerGeneratedAttribute]
private void set_DelayMs(long value);
}
[ExtensionAttribute]
internal static class Cassandra.RetryPolicyExtensions : object {
    [ExtensionAttribute]
internal static IExtendedRetryPolicy Wrap(IRetryPolicy policy, IExtendedRetryPolicy defaultPolicy);
}
public class Cassandra.RoundRobinPolicy : object {
    private ICluster _cluster;
    private int _index;
    public sealed virtual void Initialize(ICluster cluster);
    public sealed virtual HostDistance Distance(Host host);
    [IteratorStateMachineAttribute("Cassandra.RoundRobinPolicy/<NewQueryPlan>d__4")]
public sealed virtual IEnumerable`1<Host> NewQueryPlan(string keyspace, IStatement query);
}
public class Cassandra.RoutingKey : object {
    public static RoutingKey Empty;
    [CompilerGeneratedAttribute]
private Byte[] <RawRoutingKey>k__BackingField;
    public Byte[] RawRoutingKey { get; public set; }
    public RoutingKey(Byte[] rawKey);
    private static RoutingKey();
    [CompilerGeneratedAttribute]
public Byte[] get_RawRoutingKey();
    [CompilerGeneratedAttribute]
public void set_RawRoutingKey(Byte[] value);
    internal static RoutingKey Compose(RoutingKey[] components);
    private static void PutShortLength(Byte[] bb, int idx, int length);
}
[DefaultMemberAttribute("Item")]
public class Cassandra.Row : object {
    private Object[] _rowValues;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> <ColumnIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private CqlColumn[] <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[][] <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProtocolVersion>k__BackingField;
    protected Dictionary`2<string, int> ColumnIndexes { get; protected set; }
    protected CqlColumn[] Columns { get; protected set; }
    [ObsoleteAttribute("This property is deprecated and to be removed in future versions.")]
protected Byte[][] Values { get; protected set; }
    [ObsoleteAttribute("This property is deprecated and to be removed in future versions.")]
protected int ProtocolVersion { get; protected set; }
    public int Length { get; }
    public object Item { get; }
    public object Item { get; }
    [ObsoleteAttribute("This constructor is deprecated and to be removed in future versions. If you need to create mock instances of Row, use the parameter-less constructor and override GetValue<T>()")]
public Row(int protocolVersion, Byte[][] values, CqlColumn[] columns, Dictionary`2<string, int> columnIndexes);
    internal Row(Object[] values, CqlColumn[] columns, Dictionary`2<string, int> columnIndexes);
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, int> get_ColumnIndexes();
    [CompilerGeneratedAttribute]
protected void set_ColumnIndexes(Dictionary`2<string, int> value);
    [CompilerGeneratedAttribute]
protected CqlColumn[] get_Columns();
    [CompilerGeneratedAttribute]
protected void set_Columns(CqlColumn[] value);
    [CompilerGeneratedAttribute]
protected Byte[][] get_Values();
    [CompilerGeneratedAttribute]
protected void set_Values(Byte[][] value);
    [CompilerGeneratedAttribute]
protected int get_ProtocolVersion();
    [CompilerGeneratedAttribute]
protected void set_ProtocolVersion(int value);
    public int get_Length();
    public object get_Item(int index);
    public object get_Item(string name);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool IsNull(string name);
    public virtual bool IsNull(int index);
    public sealed virtual CqlColumn GetColumn(string name);
    private sealed virtual override bool Cassandra.IRow.ContainsColumn(string name);
    internal bool ContainsColumn(string name);
    public object GetValue(Type type, int index);
    public object GetValue(Type type, string name);
    public virtual T GetValue(int index);
    public virtual T GetValue(string name);
    internal static object TryConvertToType(object value, ColumnDesc column, Type targetType);
    private static object TryConvertToCollection(object value, ColumnDesc column, Type targetType);
    private static Array GetCollectionArray(object source);
    private static Array GetArray(Array source, Type childTargetType, IColumnInfo columnInfo);
    private static IDictionary TryConvertDictionary(IDictionary value, ColumnDesc column, Type targetType);
    [CompilerGeneratedAttribute]
private object <GetEnumerator>b__26_0(CqlColumn c);
}
public class Cassandra.RowSet : object {
    private static CqlColumn[] EmptyColumns;
    private Func`2 modreq(System.Runtime.CompilerServices.IsVolatile) _fetchNextPage;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _pagingState;
    private int _isPaging;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _currentFetchNextPageTask;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _pageSyncAbortTimeout;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _autoPage;
    private IMetricsManager modreq(System.Runtime.CompilerServices.IsVolatile) _metricsManager;
    [CompilerGeneratedAttribute]
private ConcurrentQueue`1<Row> <RowQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionInfo <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private CqlColumn[] <Columns>k__BackingField;
    protected internal bool AutoPage { get; protected internal set; }
    protected ConcurrentQueue`1<Row> RowQueue { get; protected set; }
    internal int InnerQueueCount { get; }
    public ExecutionInfo Info { get; public set; }
    public CqlColumn[] Columns { get; public set; }
    public Byte[] PagingState { get; protected internal set; }
    public bool IsFullyFetched { get; }
    private RowSet(bool isVoid);
    private static RowSet();
    protected internal bool get_AutoPage();
    protected internal void set_AutoPage(bool value);
    internal void SetFetchNextPageHandler(Func`2<Byte[], Task`1<RowSet>> handler, int pageSyncAbortTimeout, IMetricsManager metricsManager);
    [CompilerGeneratedAttribute]
protected virtual ConcurrentQueue`1<Row> get_RowQueue();
    [CompilerGeneratedAttribute]
protected virtual void set_RowQueue(ConcurrentQueue`1<Row> value);
    internal int get_InnerQueueCount();
    [CompilerGeneratedAttribute]
public virtual ExecutionInfo get_Info();
    [CompilerGeneratedAttribute]
public virtual void set_Info(ExecutionInfo value);
    [CompilerGeneratedAttribute]
public virtual CqlColumn[] get_Columns();
    [CompilerGeneratedAttribute]
public virtual void set_Columns(CqlColumn[] value);
    public virtual Byte[] get_PagingState();
    protected internal virtual void set_PagingState(Byte[] value);
    public virtual bool IsExhausted();
    public virtual bool get_IsFullyFetched();
    internal static RowSet Empty();
    internal virtual void AddRow(Row row);
    public void FetchMoreResults();
    [AsyncStateMachineAttribute("Cassandra.RowSet/<FetchMoreResultsAsync>d__37")]
public Task FetchMoreResultsAsync();
    public int GetAvailableWithoutFetching();
    public IEnumerable`1<Row> GetRows();
    [IteratorStateMachineAttribute("Cassandra.RowSet/<GetEnumerator>d__40")]
public virtual IEnumerator`1<Row> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual void PageNext();
    [ObsoleteAttribute("Explicitly releasing the RowSet resources is not required. It will be removed in future versions.", "False")]
public sealed virtual void Dispose();
}
public class Cassandra.RowSetMetadata : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> <ColumnIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PagingState>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <NewResultMetadataId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    [CompilerGeneratedAttribute]
private CqlColumn[] <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <PartitionKeys>k__BackingField;
    public Dictionary`2<string, int> ColumnIndexes { get; protected set; }
    internal Byte[] PagingState { get; private set; }
    internal Byte[] NewResultMetadataId { get; }
    internal string Keyspace { get; private set; }
    public CqlColumn[] Columns { get; internal set; }
    internal Int32[] PartitionKeys { get; private set; }
    internal RowSetMetadata(FrameReader reader, bool parsePartitionKeys);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, int> get_ColumnIndexes();
    [CompilerGeneratedAttribute]
protected void set_ColumnIndexes(Dictionary`2<string, int> value);
    [CompilerGeneratedAttribute]
internal Byte[] get_PagingState();
    [CompilerGeneratedAttribute]
private void set_PagingState(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_NewResultMetadataId();
    [CompilerGeneratedAttribute]
internal string get_Keyspace();
    [CompilerGeneratedAttribute]
private void set_Keyspace(string value);
    [CompilerGeneratedAttribute]
public CqlColumn[] get_Columns();
    [CompilerGeneratedAttribute]
internal void set_Columns(CqlColumn[] value);
    [CompilerGeneratedAttribute]
internal Int32[] get_PartitionKeys();
    [CompilerGeneratedAttribute]
private void set_PartitionKeys(Int32[] value);
    internal bool HasNewResultMetadataId();
    private IColumnInfo GetColumnInfo(FrameReader reader, ColumnTypeCode code);
}
[FlagsAttribute]
internal enum Cassandra.RowSetMetadataFlags : Enum {
    public int value__;
    public static RowSetMetadataFlags GlobalTablesSpec;
    public static RowSetMetadataFlags HasMorePages;
    public static RowSetMetadataFlags NoMetadata;
    public static RowSetMetadataFlags MetadataChanged;
}
internal class Cassandra.RPToken : object {
    public static TokenFactory Factory;
    private BigInteger _value;
    private RPToken(BigInteger value);
    private static RPToken();
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Cassandra.SchemaChangedEventArgs : EventArgs {
    public string Keyspace;
    public string Table;
    public Kind What;
}
public class Cassandra.SchemaChangedEventHandler : MulticastDelegate {
    public SchemaChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SchemaChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SchemaChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Cassandra.SchemaChangeEventArgs : CassandraEventArgs {
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Table>k__BackingField;
    [CompilerGeneratedAttribute]
private Reason <What>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FunctionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AggregateName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Signature>k__BackingField;
    public string Keyspace { get; public set; }
    public string Table { get; public set; }
    public Reason What { get; public set; }
    public string Type { get; public set; }
    public string FunctionName { get; public set; }
    public string AggregateName { get; public set; }
    public String[] Signature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Keyspace();
    [CompilerGeneratedAttribute]
public void set_Keyspace(string value);
    [CompilerGeneratedAttribute]
public string get_Table();
    [CompilerGeneratedAttribute]
public void set_Table(string value);
    [CompilerGeneratedAttribute]
public Reason get_What();
    [CompilerGeneratedAttribute]
public void set_What(Reason value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_FunctionName();
    [CompilerGeneratedAttribute]
public void set_FunctionName(string value);
    [CompilerGeneratedAttribute]
public string get_AggregateName();
    [CompilerGeneratedAttribute]
public void set_AggregateName(string value);
    [CompilerGeneratedAttribute]
public String[] get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(String[] value);
}
internal abstract class Cassandra.SchemaParser : object {
    protected static string CompositeTypeName;
    private static int TraceMaxAttempts;
    private static int TraceAttemptDelay;
    private static string SelectTraceSessions;
    private static string SelectTraceEvents;
    protected IMetadataQueryProvider Cc;
    protected Metadata Parent;
    protected string SelectAggregates { get; }
    protected string SelectFunctions { get; }
    protected string SelectTables { get; }
    protected string SelectUdts { get; }
    protected SchemaParser(Metadata parent);
    protected abstract virtual string get_SelectAggregates();
    protected abstract virtual string get_SelectFunctions();
    protected abstract virtual string get_SelectTables();
    protected abstract virtual string get_SelectUdts();
    public abstract virtual Task`1<KeyspaceMetadata> GetKeyspaceAsync(string name);
    public abstract virtual Task`1<IEnumerable`1<KeyspaceMetadata>> GetKeyspacesAsync(bool retry);
    public abstract virtual Task`1<TableMetadata> GetTableAsync(string keyspaceName, string tableName);
    public abstract virtual Task`1<MaterializedViewMetadata> GetViewAsync(string keyspaceName, string viewName);
    [AsyncStateMachineAttribute("Cassandra.SchemaParser/<GetTableNamesAsync>d__20")]
public sealed virtual Task`1<ICollection`1<string>> GetTableNamesAsync(string keyspaceName);
    public abstract virtual Task`1<ICollection`1<string>> GetKeyspacesNamesAsync();
    public abstract virtual Task`1<FunctionMetadata> GetFunctionAsync(string keyspaceName, string functionName, string signatureString);
    public abstract virtual Task`1<AggregateMetadata> GetAggregateAsync(string keyspaceName, string aggregateName, string signatureString);
    public abstract virtual Task`1<UdtColumnInfo> GetUdtDefinitionAsync(string keyspaceName, string typeName);
    public sealed virtual string ComputeFunctionSignatureString(String[] signature);
    public sealed virtual Task`1<QueryTrace> GetQueryTraceAsync(QueryTrace trace, HashedWheelTimer timer);
    private Task`1<QueryTrace> GetQueryTraceAsync(QueryTrace trace, HashedWheelTimer timer, int attempt);
}
internal class Cassandra.SchemaParserV1 : SchemaParser {
    private static Task`1<TableMetadata> NullTableTask;
    private static string SelectColumns;
    private static string SelectKeyspaces;
    private static string SelectSingleKeyspace;
    private static string SelectSingleTable;
    private static string SelectKeyspacesNames;
    protected string SelectAggregates { get; }
    protected string SelectFunctions { get; }
    protected string SelectTables { get; }
    protected string SelectUdts { get; }
    internal SchemaParserV1(Metadata parent);
    private static SchemaParserV1();
    protected virtual string get_SelectAggregates();
    protected virtual string get_SelectFunctions();
    protected virtual string get_SelectTables();
    protected virtual string get_SelectUdts();
    private KeyspaceMetadata ParseKeyspaceRow(IRow row);
    public virtual Task`1<KeyspaceMetadata> GetKeyspaceAsync(string name);
    public virtual Task`1<IEnumerable`1<KeyspaceMetadata>> GetKeyspacesAsync(bool retry);
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV1/<GetKeyspacesNamesAsync>d__18")]
public virtual Task`1<ICollection`1<string>> GetKeyspacesNamesAsync();
    private static SortedDictionary`2<string, string> GetCompactionStrategyOptions(IRow row);
    public virtual Task`1<TableMetadata> GetTableAsync(string keyspaceName, string tableName);
    private static ColumnDesc[] AdaptKeyTypes(string typesString);
    public virtual Task`1<MaterializedViewMetadata> GetViewAsync(string keyspaceName, string viewName);
    private static IDictionary`2<string, IndexMetadata> GetIndexesFromColumns(IEnumerable`1<TableColumn> columns);
    public virtual Task`1<UdtColumnInfo> GetUdtDefinitionAsync(string keyspaceName, string typeName);
    public virtual Task`1<FunctionMetadata> GetFunctionAsync(string keyspaceName, string functionName, string signatureString);
    public virtual Task`1<AggregateMetadata> GetAggregateAsync(string keyspaceName, string aggregateName, string signatureString);
    private static object Deserialize(IMetadataQueryProvider cc, Byte[] buffer, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    [CompilerGeneratedAttribute]
private KeyspaceMetadata <GetKeyspaceAsync>b__16_0(IEnumerable`1<IRow> rs);
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyspaceMetadata> <GetKeyspacesAsync>b__17_0(IEnumerable`1<IRow> rs);
    [CompilerGeneratedAttribute]
private AggregateMetadata <GetAggregateAsync>b__26_0(IEnumerable`1<IRow> rs);
}
internal class Cassandra.SchemaParserV2 : SchemaParser {
    private Func`3<string, string, Task`1<UdtColumnInfo>> _udtResolver;
    private static string SelectColumns;
    private static string SelectIndexes;
    protected static string SelectKeyspaces;
    private static string SelectSingleKeyspace;
    private static string SelectSingleTable;
    private static string SelectSingleView;
    private static string SelectKeyspacesNames;
    protected string SelectAggregates { get; }
    protected string SelectFunctions { get; }
    protected string SelectTables { get; }
    protected string SelectUdts { get; }
    internal SchemaParserV2(Metadata parent, Func`3<string, string, Task`1<UdtColumnInfo>> udtResolver);
    protected virtual string get_SelectAggregates();
    protected virtual string get_SelectFunctions();
    protected virtual string get_SelectTables();
    protected virtual string get_SelectUdts();
    private KeyspaceMetadata ParseKeyspaceRow(IRow row);
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV2/<GetKeyspaceAsync>d__18")]
public virtual Task`1<KeyspaceMetadata> GetKeyspaceAsync(string name);
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV2/<GetKeyspacesAsync>d__19")]
public virtual Task`1<IEnumerable`1<KeyspaceMetadata>> GetKeyspacesAsync(bool retry);
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV2/<GetKeyspacesNamesAsync>d__20")]
public virtual Task`1<ICollection`1<string>> GetKeyspacesNamesAsync();
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV2/<GetTableAsync>d__21")]
public virtual Task`1<TableMetadata> GetTableAsync(string keyspaceName, string tableName);
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV2/<ParseTableOrView>d__22`1")]
protected Task`1<T> ParseTableOrView(Func`2<IRow, T> newInstance, IEnumerable`1<IRow> tableRs, IEnumerable`1<IRow> columnsRs);
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV2/<GetViewAsync>d__23")]
public virtual Task`1<MaterializedViewMetadata> GetViewAsync(string keyspaceName, string viewName);
    private static void PruneDenseTableColumns(IDictionary`2<string, TableColumn> columns);
    private static void PruneStaticCompactTableColumns(ICollection`1<Tuple`2<int, Tuple`2<TableColumn, SortOrder>>> clusteringKeys, IDictionary`2<string, TableColumn> columns);
    private static IDictionary`2<string, IndexMetadata> GetIndexes(IEnumerable`1<IRow> rows);
    public virtual Task`1<UdtColumnInfo> GetUdtDefinitionAsync(string keyspaceName, string typeName);
    public virtual Task`1<AggregateMetadata> GetAggregateAsync(string keyspaceName, string aggregateName, string signatureString);
    public virtual Task`1<FunctionMetadata> GetFunctionAsync(string keyspaceName, string functionName, string signatureString);
    [CompilerGeneratedAttribute]
private Task`1<AggregateMetadata> <GetAggregateAsync>b__28_0(IEnumerable`1<IRow> rs);
    [CompilerGeneratedAttribute]
private Task`1<FunctionMetadata> <GetFunctionAsync>b__29_0(IEnumerable`1<IRow> rs);
}
internal class Cassandra.SchemaParserV3 : SchemaParserV2 {
    private static string SelectVirtualKeyspaces;
    private static string SelectSingleVirtualKeyspace;
    private static string SelectVirtualTable;
    private static string SelectVirtualColumns;
    private static string SelectVirtualKeyspaceNames;
    internal SchemaParserV3(Metadata parent, Func`3<string, string, Task`1<UdtColumnInfo>> udtResolver);
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV3/<GetKeyspaceAsync>d__6")]
public virtual Task`1<KeyspaceMetadata> GetKeyspaceAsync(string name);
    private KeyspaceMetadata ParseVirtualKeyspaceRow(IRow row);
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV3/<GetKeyspacesAsync>d__8")]
public virtual Task`1<IEnumerable`1<KeyspaceMetadata>> GetKeyspacesAsync(bool retry);
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV3/<GetKeyspacesNamesAsync>d__9")]
public virtual Task`1<ICollection`1<string>> GetKeyspacesNamesAsync();
    [AsyncStateMachineAttribute("Cassandra.SchemaParserV3/<GetTableAsync>d__10")]
public virtual Task`1<TableMetadata> GetTableAsync(string keyspaceName, string tableName);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<KeyspaceMetadata> <>n__0(string name);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<IEnumerable`1<KeyspaceMetadata>> <>n__1(bool retry);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ICollection`1<string>> <>n__2();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<TableMetadata> <>n__3(string keyspaceName, string tableName);
}
internal class Cassandra.SecureConnectionBundleException : Exception {
    public SecureConnectionBundleException(string message);
    public SecureConnectionBundleException(string message, Exception innerException);
}
internal class Cassandra.Serialization.CollectionSerializer : TypeSerializer`1<IEnumerable> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual IEnumerable Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    internal Type GetClrTypeForList(IColumnInfo typeInfo);
    internal Type GetClrTypeForGraphList(IColumnInfo typeInfo);
    internal Type GetClrTypeForSet(IColumnInfo typeInfo);
    internal Type GetClrTypeForGraphSet(IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, IEnumerable value);
}
public abstract class Cassandra.Serialization.CustomTypeSerializer`1 : TypeSerializer`1<T> {
    private IColumnInfo _typeInfo;
    public ColumnTypeCode CqlType { get; }
    public IColumnInfo TypeInfo { get; }
    protected CustomTypeSerializer`1(string name);
    public virtual ColumnTypeCode get_CqlType();
    public virtual IColumnInfo get_TypeInfo();
}
internal static class Cassandra.Serialization.DataTypeParser : object {
    private static string ListTypeName;
    private static string SetTypeName;
    private static string MapTypeName;
    public static string UdtTypeName;
    private static string TupleTypeName;
    private static string FrozenTypeName;
    public static string ReversedTypeName;
    public static string CompositeTypeName;
    private static string EmptyTypeName;
    public static string VectorTypeName;
    private static Dictionary`2<string, ColumnTypeCode> SingleFqTypeNames;
    private static Dictionary`2<string, ColumnTypeCode> SingleCqlNames;
    private static int SingleFqTypeNamesLength;
    private static DataTypeParser();
    internal static ColumnDesc ParseFqTypeName(string typeName);
    internal static ColumnDesc ParseFqTypeName(string typeName, int startIndex, int length);
    internal static Task`1<ColumnDesc> ParseTypeName(Func`3<string, string, Task`1<UdtColumnInfo>> udtResolver, string keyspace, string typeName, int startIndex, int length);
    private static string HexToUtf8(string hexString);
    private static List`1<string> ParseParams(string value, int startIndex, int length, char open, char close);
    private static bool IsBlankChar(char c);
    private static Exception GetTypeException(string typeName);
    internal static VectorColumnInfo ParseVectorColumnInfo(string typeName, int startIndex, int length);
}
internal class Cassandra.Serialization.DictionarySerializer : TypeSerializer`1<IDictionary> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual IDictionary Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    internal Type GetClrType(IColumnInfo typeInfo);
    internal Type GetClrTypeForGraph(IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, IDictionary value);
    public int AddItem(LinkedList`1<Byte[]> bufferList, ushort protocolVersion, object item);
}
internal class Cassandra.Serialization.DurationSerializer : TypeSerializer`1<Duration> {
    private static ThreadLocal`1<Byte[][]> EncodingBuffers;
    public ColumnTypeCode CqlType { get; }
    public IColumnInfo TypeInfo { get; }
    public DurationSerializer(bool asCustomType);
    private static DurationSerializer();
    public virtual ColumnTypeCode get_CqlType();
    public virtual IColumnInfo get_TypeInfo();
    public virtual Duration Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, Duration value);
}
internal class Cassandra.Serialization.GenericSerializer : object {
    private static Logger Logger;
    private IDictionary`2<ColumnTypeCode, ITypeSerializer> _primitiveDeserializers;
    private IEnumerable`1<ITypeSerializer> _defaultCustomTypeSerializers;
    private Dictionary`2<Type, ITypeSerializer> _primitiveSerializers;
    private IDictionary`2<IColumnInfo, ITypeSerializer> _customDeserializers;
    private IDictionary`2<Type, ITypeSerializer> _customSerializers;
    private CollectionSerializer _collectionSerializer;
    private DictionarySerializer _dictionarySerializer;
    private VectorSerializer _vectorSerializer;
    private TupleSerializer _tupleSerializer;
    private Dictionary`2<ColumnTypeCode, Func`2<IColumnInfo, Type>> _defaultTypes;
    private Dictionary`2<ColumnTypeCode, Func`2<IColumnInfo, Type>> _defaultGraphTypes;
    private UdtSerializer _udtSerializer;
    internal GenericSerializer(IEnumerable`1<ITypeSerializer> typeSerializers);
    private static GenericSerializer();
    public sealed virtual object Deserialize(ProtocolVersion version, Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual Type GetClrType(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual Type GetClrTypeForGraph(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual Type GetClrTypeForCustom(IColumnInfo typeInfo);
    public sealed virtual ColumnTypeCode GetCqlType(Type type, IColumnInfo& typeInfo);
    private void InitPrimitiveSerializers();
    private void InitDefaultTypes();
    private void InitTypeAdapters();
    public void InsertLegacySerializer(ColumnTypeCode typeCode, ITypeAdapter typeAdapter, bool reverse);
    public sealed virtual bool IsAssignableFrom(ColumnTypeCode columnTypeCode, IColumnInfo typeInfo, object value, String& failureMsg);
    private bool IsAssignableHelper(ColumnTypeCode columnTypeCode, IColumnInfo typeInfo, object value, String& failureMsg);
    public sealed virtual UdtMap GetUdtMapByName(string name);
    public sealed virtual UdtMap GetUdtMapByType(Type type);
    public sealed virtual Byte[] Serialize(ProtocolVersion version, object value);
    public void SetSpecificSerializers(IEnumerable`1<ITypeSerializer> typeSerializers);
    public void SetUdtMap(string name, UdtMap map);
    internal static void ValidateColumnInfo(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual int GetValueLengthIfFixed(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual int GetValueLengthIfFixed(object value);
    [CompilerGeneratedAttribute]
private ColumnDesc <GetCqlType>b__18_2(Type t);
}
internal abstract class Cassandra.Serialization.Geometry.GeometrySerializer`1 : TypeSerializer`1<T> {
    protected bool IsLittleEndian(Byte[] buffer, int offset);
    protected virtual bool UseLittleEndianSerialization();
}
internal class Cassandra.Serialization.Geometry.LineStringSerializer : GeometrySerializer`1<LineString> {
    private IColumnInfo _typeInfo;
    public ColumnTypeCode CqlType { get; }
    public IColumnInfo TypeInfo { get; }
    public virtual LineString Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual ColumnTypeCode get_CqlType();
    public virtual IColumnInfo get_TypeInfo();
    public virtual Byte[] Serialize(ushort protocolVersion, LineString value);
}
internal class Cassandra.Serialization.Geometry.PointSerializer : GeometrySerializer`1<Point> {
    private IColumnInfo _typeInfo;
    public ColumnTypeCode CqlType { get; }
    public IColumnInfo TypeInfo { get; }
    public virtual Point Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual ColumnTypeCode get_CqlType();
    public virtual IColumnInfo get_TypeInfo();
    public virtual Byte[] Serialize(ushort protocolVersion, Point value);
}
internal class Cassandra.Serialization.Geometry.PolygonSerializer : GeometrySerializer`1<Polygon> {
    private IColumnInfo _typeInfo;
    public ColumnTypeCode CqlType { get; }
    public IColumnInfo TypeInfo { get; }
    public virtual Polygon Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual ColumnTypeCode get_CqlType();
    public virtual IColumnInfo get_TypeInfo();
    public virtual Byte[] Serialize(ushort protocolVersion, Polygon value);
}
internal class Cassandra.Serialization.Graph.GraphSON1.GraphSON1ContractResolver : DefaultContractResolver {
    internal static JsonSerializerSettings Settings;
    private static GraphSON1ContractResolver();
    protected virtual JsonContract CreateContract(Type objectType);
}
internal class Cassandra.Serialization.Graph.GraphSON1.GraphSON1Converter : GraphSONConverter {
    private static Dictionary`2<Type, WriteDelegate> Writers;
    internal static GraphSON1Converter Instance;
    private Dictionary`2<Type, ReadDelegate> _readers;
    private static GraphSON1Converter();
    private ReadDelegate GetTokenReader(Func`2<JToken, T> tokenReader);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    protected virtual GraphNode ToGraphNode(JToken token);
    public virtual bool CanConvert(Type objectType);
    private static void WriteStringValue(JsonWriter writer, object value, JsonSerializer serializer);
    private static void WriteStringRawValue(JsonWriter writer, object value, JsonSerializer serializer);
    private static void WriteGraphNode(JsonWriter writer, object value, JsonSerializer serializer);
    private static void WriteDuration(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class Cassandra.Serialization.Graph.GraphSON1.GraphSON1Node : object {
    private static JsonSerializer Serializer;
    private static JTokenEqualityComparer Comparer;
    private JToken _token;
    [CompilerGeneratedAttribute]
private long <Bulk>k__BackingField;
    public bool DeserializeGraphNodes { get; }
    public bool IsArray { get; }
    public bool IsObjectTree { get; }
    public bool IsScalar { get; }
    public long Bulk { get; }
    internal GraphSON1Node(string json, bool validateGraphson2);
    private GraphSON1Node(JToken parsedGraphItem);
    private static GraphSON1Node();
    public sealed virtual bool get_DeserializeGraphNodes();
    public sealed virtual bool get_IsArray();
    public sealed virtual bool get_IsObjectTree();
    public sealed virtual bool get_IsScalar();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Bulk();
    internal static GraphSON1Node CreateParsedNode(JToken parsedGraphItem);
    public sealed virtual T Get(string propertyName, bool throwIfNotFound);
    private JToken GetPropertyValue(string name, bool throwIfNotFound);
    public sealed virtual object GetRaw();
    private T GetTokenValue(JToken token);
    private object GetTokenValue(JToken token, Type type);
    private object GetTokenValue(JToken token);
    public sealed virtual bool HasProperty(string name);
    public sealed virtual string GetGraphSONType();
    public sealed virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual IDictionary`2<string, GraphNode> GetProperties();
    public sealed virtual IDictionary`2<string, IGraphNode> GetIProperties();
    private IDictionary`2<string, T> GetProperties(JToken item);
    public sealed virtual T To();
    public sealed virtual object To(Type type);
    public Array ToArray(JArray jArray, Type elementType);
    public sealed virtual GraphNode[] ToArray();
    public virtual string ToString();
    public sealed virtual void WriteJson(JsonWriter writer, JsonSerializer serializer);
}
internal class Cassandra.Serialization.Graph.GraphSON1.GraphSON1TypeSerializer : object {
    private static Func`2<Row, GraphNode> RowParser;
    public bool DefaultDeserializeGraphNodes { get; }
    public GraphProtocol GraphProtocol { get; }
    private static GraphSON1TypeSerializer();
    public sealed virtual bool get_DefaultDeserializeGraphNodes();
    public sealed virtual GraphProtocol get_GraphProtocol();
    public sealed virtual Func`2<Row, GraphNode> GetGraphRowParser();
    public sealed virtual object FromDb(JToken token, Type type);
    public sealed virtual object FromDb(JToken token, Type type, bool deserializeGraphNodes);
    public sealed virtual T FromDb(JToken token);
    public sealed virtual string ToDb(object obj);
    public sealed virtual bool ConvertFromDb(object obj, Type targetType, Object& result);
}
internal abstract class Cassandra.Serialization.Graph.GraphSON1.GraphSONConverter : JsonConverter {
    private static IDictionary`2<string, GraphNode> EmptyProperties;
    private static GraphSONConverter();
    protected abstract virtual GraphNode ToGraphNode(JToken token);
    private GraphNode ToGraphNode(JToken token, string propName, bool required);
    private string ToString(JToken token, string propName, bool required);
    protected Vertex ToVertex(JToken token);
    protected Edge ToEdge(JToken token);
    protected Path ToPath(JToken token);
    protected IVertexProperty ToVertexProperty(JToken token);
    protected IProperty ToProperty(JToken token);
    protected TimeUuid ParseTimeUuid(string value);
    [CompilerGeneratedAttribute]
private GraphNode <ToVertex>b__6_1(JProperty prop);
    [CompilerGeneratedAttribute]
private GraphNode <ToEdge>b__7_1(JProperty prop);
}
internal class Cassandra.Serialization.Graph.GraphSON2.CustomGraphSON2Reader : object {
    private Dictionary`2<string, IGraphSONDeserializer> _deserializers;
    private Dictionary`2<string, IGraphSONStructureDeserializer> _structureDeserializers;
    private IGraphSONReader _reader;
    private IReadOnlyDictionary`2<string, IGraphSONDeserializer> _customDeserializers;
    private static IReadOnlyDictionary`2<string, IGraphSONStructureDeserializer> CustomGraphSON2SpecificStructureDeserializers;
    private static IDictionary`2<string, IGraphSONDeserializer> CustomGraphSON2SpecificDeserializers;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, IGraphSONDeserializer> <DefaultDeserializers>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, IGraphSONStructureDeserializer> <StructureDeserializers>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<JToken, GraphNode> <GraphNodeFactory>k__BackingField;
    private static Dictionary`2<string, IGraphSONDeserializer> DefaultDeserializers { get; }
    private static Dictionary`2<string, IGraphSONStructureDeserializer> StructureDeserializers { get; }
    protected Func`2<JToken, GraphNode> GraphNodeFactory { get; }
    private static CustomGraphSON2Reader();
    public CustomGraphSON2Reader(Func`2<JToken, GraphNode> graphNodeFactory, IReadOnlyDictionary`2<string, IGraphSONDeserializer> customDeserializers, IGraphSONReader reader);
    protected CustomGraphSON2Reader(Dictionary`2<string, IGraphSONDeserializer> deserializers, Dictionary`2<string, IGraphSONStructureDeserializer> structureDeserializers, Func`2<JToken, GraphNode> graphNodeFactory, IReadOnlyDictionary`2<string, IGraphSONDeserializer> customDeserializers, IGraphSONReader reader);
    protected static void AddGraphSON2Deserializers(IDictionary`2<string, IGraphSONDeserializer> dictionary);
    protected static void AddGraphSON2StructureDeserializers(IDictionary`2<string, IGraphSONStructureDeserializer> dictionary);
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, IGraphSONDeserializer> get_DefaultDeserializers();
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, IGraphSONStructureDeserializer> get_StructureDeserializers();
    [CompilerGeneratedAttribute]
protected Func`2<JToken, GraphNode> get_GraphNodeFactory();
    public sealed virtual object ToObject(JToken jToken);
    private bool HasTypeKey(JToken jToken);
    private object ReadTypedValue(JToken typedValue, IGraphSONReader reader);
    private object ReadDictionary(JToken jtokenDict);
    private bool IsNullOrUndefined(JToken jToken);
    [CompilerGeneratedAttribute]
private object <ToObject>b__20_0(JToken t);
}
internal class Cassandra.Serialization.Graph.GraphSON2.CustomGraphSON2Writer : object {
    private static IDictionary`2<Type, IGraphSONSerializer> CustomGraphSON2SpecificSerializers;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IDictionary`2<Type, Func`2<object, object>> CustomSerializers;
    [CompilerGeneratedAttribute]
private static Dictionary`2<Type, IGraphSONSerializer> <DefaultSerializers>k__BackingField;
    private IReadOnlyDictionary`2<Type, IGraphSONSerializer> _customSerializers;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<Type, IGraphSONSerializer> <Serializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IGraphSONWriter <Writer>k__BackingField;
    private static Dictionary`2<Type, IGraphSONSerializer> DefaultSerializers { get; }
    protected IReadOnlyDictionary`2<Type, IGraphSONSerializer> Serializers { get; }
    protected IGraphSONWriter Writer { get; }
    private static CustomGraphSON2Writer();
    public CustomGraphSON2Writer(IReadOnlyDictionary`2<Type, IGraphSONSerializer> customSerializers, IGraphSONWriter writer);
    protected CustomGraphSON2Writer(Dictionary`2<Type, IGraphSONSerializer> serializers, IReadOnlyDictionary`2<Type, IGraphSONSerializer> customSerializers, IGraphSONWriter writer);
    [CompilerGeneratedAttribute]
private static Dictionary`2<Type, IGraphSONSerializer> get_DefaultSerializers();
    protected static void AddGraphSON2Serializers(IDictionary`2<Type, IGraphSONSerializer> dictionary);
    [CompilerGeneratedAttribute]
protected IReadOnlyDictionary`2<Type, IGraphSONSerializer> get_Serializers();
    [CompilerGeneratedAttribute]
protected IGraphSONWriter get_Writer();
    public sealed virtual bool TryToDict(object objectData, Object& result);
    protected virtual bool TryHandleNotSupportedType(Type type, object objectData, Object& result);
    private IGraphSONSerializer TryGetSerializerFor(IReadOnlyDictionary`2<Type, IGraphSONSerializer> serializers, Type type);
    private bool IsDictionary(object objectData);
    private bool IsSet(Type type);
    private bool IsEnumerable(object objectData);
    protected virtual object DictToGraphSONDict(object dict);
    protected virtual object SetToGraphSONSet(object collection);
    protected virtual object ListToGraphSONList(object collection);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Dse.BlobSerializer : StringBasedSerializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    protected virtual string ToString(object obj);
    protected virtual object FromString(string str);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Dse.LineStringSerializer : StringBasedSerializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    protected virtual string ToString(object obj);
    protected virtual object FromString(string str);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Dse.PointSerializer : StringBasedSerializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    protected virtual string ToString(object obj);
    protected virtual object FromString(string str);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Dse.PolygonSerializer : StringBasedSerializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    protected virtual string ToString(object obj);
    protected virtual object FromString(string str);
}
internal class Cassandra.Serialization.Graph.GraphSON2.EmptyGraphSON2Reader : GraphSON2Reader {
    public Dictionary`2<string, IGraphSONDeserializer> GetDeserializers();
}
internal class Cassandra.Serialization.Graph.GraphSON2.EmptyGraphSON2Writer : GraphSON2Writer {
    public Dictionary`2<Type, IGraphSONSerializer> GetSerializers();
}
internal class Cassandra.Serialization.Graph.GraphSON2.GraphSONNode : object {
    private IGraphTypeSerializer _graphSerializer;
    private static JTokenEqualityComparer Comparer;
    private JToken _token;
    private string _graphsonType;
    internal static JsonSerializerSettings GraphSONSerializerSettings;
    [CompilerGeneratedAttribute]
private long <Bulk>k__BackingField;
    public bool DeserializeGraphNodes { get; }
    public bool IsArray { get; }
    public bool IsObjectTree { get; }
    public bool IsScalar { get; }
    public long Bulk { get; }
    internal GraphSONNode(IGraphTypeSerializer graphTypeSerializer, string json);
    internal GraphSONNode(IGraphTypeSerializer graphTypeSerializer, JToken parsedGraphItem);
    private static GraphSONNode();
    public sealed virtual bool get_DeserializeGraphNodes();
    public sealed virtual bool get_IsArray();
    public sealed virtual bool get_IsObjectTree();
    public sealed virtual bool get_IsScalar();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Bulk();
    public sealed virtual T Get(string propertyName, bool throwIfNotFound);
    private JObject GetTypedValue();
    private JProperty GetProperty(string name);
    private JToken GetPropertyValue(string name, bool throwIfNotFound);
    public sealed virtual object GetRaw();
    private T GetTokenValue(JToken token);
    private object GetTokenValue(JToken token, Type type);
    public sealed virtual bool HasProperty(string name);
    public sealed virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual IDictionary`2<string, GraphNode> GetProperties();
    public sealed virtual IDictionary`2<string, IGraphNode> GetIProperties();
    private IDictionary`2<string, T> GetProperties(JToken item);
    public sealed virtual object To(Type type);
    public sealed virtual T To();
    public sealed virtual GraphNode[] ToArray();
    public virtual string ToString();
    public sealed virtual void WriteJson(JsonWriter writer, JsonSerializer serializer);
    public sealed virtual string GetGraphSONType();
    [CompilerGeneratedAttribute]
private T <GetProperties>b__31_1(JProperty prop);
}
internal class Cassandra.Serialization.Graph.GraphSON2.GraphTypeSerializer : object {
    private static TypeConverter DefaultTypeConverter;
    private static IReadOnlyDictionary`2<string, IGraphSONDeserializer> EmptyDeserializersDict;
    private static IReadOnlyDictionary`2<Type, IGraphSONSerializer> EmptySerializersDict;
    private static IComplexTypeGraphSONDeserializer UdtDeserializer;
    private static IComplexTypeGraphSONSerializer UdtSerializer;
    private static IComplexTypeGraphSONDeserializer TupleDeserializer;
    private static IComplexTypeGraphSONSerializer TupleSerializer;
    private TypeConverter _typeConverter;
    private ICustomGraphSONReader _reader;
    private ICustomGraphSONWriter _writer;
    private Func`2<Row, GraphNode> _rowParser;
    private IInternalSession _session;
    public static string TypeKey;
    public static string ValueKey;
    [CompilerGeneratedAttribute]
private bool <DefaultDeserializeGraphNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphProtocol <GraphProtocol>k__BackingField;
    public bool DefaultDeserializeGraphNodes { get; }
    public GraphProtocol GraphProtocol { get; }
    public GraphTypeSerializer(IInternalSession session, GraphProtocol protocol, IReadOnlyDictionary`2<string, IGraphSONDeserializer> customDeserializers, IReadOnlyDictionary`2<Type, IGraphSONSerializer> customSerializers, bool deserializeGraphNodes);
    private static GraphTypeSerializer();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DefaultDeserializeGraphNodes();
    [CompilerGeneratedAttribute]
public sealed virtual GraphProtocol get_GraphProtocol();
    public sealed virtual Func`2<Row, GraphNode> GetGraphRowParser();
    public sealed virtual string ToDb(object obj);
    public sealed virtual T FromDb(JToken token);
    public sealed virtual object FromDb(JToken token, Type type);
    public sealed virtual object FromDb(JToken token, Type type, bool deserializeGraphNodes);
    private bool TryDeserialize(JToken token, Type type, bool useGraphNodes, Object& result);
    private bool TryConvertFromListOrSet(JToken token, Type type, string typeName, bool deserializeGraphNodes, Object& result);
    private bool TryConvertFromMap(JToken token, Type type, string typeName, bool deserializeGraphNodes, Object& result);
    private bool TryConvertFromBulkSet(JToken token, Type type, string typeName, bool deserializeGraphNodes, Object& result);
    private bool TryConvertFromUdt(JToken token, Type type, string typeName, Object& result);
    private bool TryConvertFromTuple(JToken token, Type type, string typeName, Object& result);
    public sealed virtual bool ConvertFromDb(object obj, Type targetType, Object& result);
    private bool ConvertToElementMap(IDictionary`2<object, GraphNode> map, Object& result);
    private IEnumerable FromListOrSetToEnumerable(JArray jArray, Type elementType, bool deserializeGraphNodes);
    private IEnumerable FromSetToEnumerable(JArray jArray, bool deserializeGraphNodes);
    private IDictionary FromMapToDictionary(JArray jArray, Type keyType, Type elementType, bool deserializeGraphNodes);
    public sealed virtual object ToDict(object objectData);
    public sealed virtual string WriteObject(object objectData);
    public sealed virtual object ToObject(JToken token);
    [CompilerGeneratedAttribute]
private GraphNode <.ctor>b__14_0(JToken token);
    [CompilerGeneratedAttribute]
private GraphNode <.ctor>b__14_1(JToken token);
    [CompilerGeneratedAttribute]
private GraphNode <.ctor>b__14_2(Row row);
}
internal abstract class Cassandra.Serialization.Graph.GraphSON2.StringBasedSerializer : object {
    private string _typeKey;
    private string _prefix;
    protected StringBasedSerializer(string prefix, string typeKey);
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
    protected virtual string TokenToString(JToken token);
    protected abstract virtual string ToString(object obj);
    protected abstract virtual object FromString(string str);
}
internal abstract class Cassandra.Serialization.Graph.GraphSON2.Structure.BaseStructureDeserializer : object {
    protected GraphNode ToGraphNode(Func`2<JToken, GraphNode> factory, JToken token, string propName, bool required);
    protected GraphNode ToGraphNode(Func`2<JToken, GraphNode> factory, JToken token);
    protected string ToString(JToken token, string propName, bool required);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Structure.EdgeDeserializer : BaseStructureDeserializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken token, Func`2<JToken, GraphNode> factory, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Structure.EdgeSerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Structure.PathDeserializer : BaseStructureDeserializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken token, Func`2<JToken, GraphNode> factory, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Structure.PropertyDeserializer : BaseStructureDeserializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken token, Func`2<JToken, GraphNode> factory, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Structure.PropertySerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
    private object CreateElementDict(IGraphNode graphNode, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Structure.VertexDeserializer : BaseStructureDeserializer {
    private static string Prefix;
    private static string TypeKey;
    public static string DefaultLabel;
    public static string TypeName { get; }
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken token, Func`2<JToken, GraphNode> factory, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Structure.VertexPropertyDeserializer : BaseStructureDeserializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken token, Func`2<JToken, GraphNode> factory, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Structure.VertexPropertySerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Structure.VertexSerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Tinkerpop.Duration2Serializer : StringBasedSerializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    protected virtual string ToString(object obj);
    protected virtual object FromString(string str);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Tinkerpop.InetAddressSerializer : StringBasedSerializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    protected virtual string ToString(object obj);
    protected virtual object FromString(string str);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Tinkerpop.LocalDateSerializer : StringBasedSerializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    protected virtual string ToString(object obj);
    protected virtual object FromString(string str);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Tinkerpop.LocalTimeSerializer : StringBasedSerializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    protected virtual string ToString(object obj);
    protected virtual object FromString(string str);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Tinkerpop.TimestampSerializer : StringBasedSerializer {
    private static string Prefix;
    private static string TypeKey;
    private static string FormatString;
    public static string TypeName { get; }
    public static string get_TypeName();
    protected virtual string ToString(object obj);
    protected virtual object FromString(string str);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Tinkerpop.TinkerpopDateDeserializer : object {
    private static string Prefix;
    private static string TypeKey;
    private static DateTimeOffset UnixStart;
    public static string TypeName { get; }
    private static TinkerpopDateDeserializer();
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Tinkerpop.TinkerpopTimestampDeserializer : object {
    private static string Prefix;
    private static string TypeKey;
    private static DateTimeOffset UnixStart;
    public static string TypeName { get; }
    private static TinkerpopTimestampDeserializer();
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.GraphSON2.Tinkerpop.TraverserDeserializer : BaseStructureDeserializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken graphsonObject, Func`2<JToken, GraphNode> factory, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.GraphSON3.CustomGraphSON3Reader : CustomGraphSON2Reader {
    private static IReadOnlyDictionary`2<string, IGraphSONStructureDeserializer> CustomGraphSON3SpecificStructureDeserializers;
    private static IDictionary`2<string, IGraphSONDeserializer> CustomGraphSON3SpecificDeserializers;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, IGraphSONDeserializer> <Deserializers>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, IGraphSONStructureDeserializer> <StructureDeserializers>k__BackingField;
    private static Dictionary`2<string, IGraphSONDeserializer> Deserializers { get; }
    private static Dictionary`2<string, IGraphSONStructureDeserializer> StructureDeserializers { get; }
    private static CustomGraphSON3Reader();
    public CustomGraphSON3Reader(Func`2<JToken, GraphNode> graphNodeFactory, IReadOnlyDictionary`2<string, IGraphSONDeserializer> customDeserializers, IGraphSONReader reader);
    protected static void AddGraphSON3Deserializers(IDictionary`2<string, IGraphSONDeserializer> dictionary);
    protected static void AddGraphSON3StructureDeserializers(IDictionary`2<string, IGraphSONStructureDeserializer> dictionary);
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, IGraphSONDeserializer> get_Deserializers();
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, IGraphSONStructureDeserializer> get_StructureDeserializers();
}
internal class Cassandra.Serialization.Graph.GraphSON3.CustomGraphSON3Writer : CustomGraphSON2Writer {
    private static IDictionary`2<Type, IGraphSONSerializer> CustomGraphSON3SpecificSerializers;
    [CompilerGeneratedAttribute]
private static Dictionary`2<Type, IGraphSONSerializer> <DefaultSerializers>k__BackingField;
    private static Dictionary`2<Type, IGraphSONSerializer> DefaultSerializers { get; }
    private static CustomGraphSON3Writer();
    public CustomGraphSON3Writer(IReadOnlyDictionary`2<Type, IGraphSONSerializer> customSerializers, IGraphSONWriter writer);
    [CompilerGeneratedAttribute]
private static Dictionary`2<Type, IGraphSONSerializer> get_DefaultSerializers();
    protected static void AddGraphSON3Serializers(IDictionary`2<Type, IGraphSONSerializer> dictionary);
    protected virtual object DictToGraphSONDict(object dict);
    protected virtual object SetToGraphSONSet(object collection);
    protected virtual object ListToGraphSONList(object collection);
}
internal static class Cassandra.Serialization.Graph.GraphSON3.Dse.ComplexTypeDefinitionHelper : object {
    public static Dictionary`2<string, object> GetUdtTypeDefinition(Dictionary`2<string, object> dictionary, UdtMap map, IGenericSerializer genericSerializer);
    public static Dictionary`2<string, object> GetDefinitionByValue(IGenericSerializer genericSerializer, object obj);
    private static Dictionary`2<string, object> GetDefinitionByType(IGenericSerializer genericSerializer, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    private static Dictionary`2<string, object> GetDefinitionByType(Dictionary`2<string, object> dictionary, IGenericSerializer genericSerializer, ColumnTypeCode typeCode, IColumnInfo typeInfo);
}
internal class Cassandra.Serialization.Graph.GraphSON3.Dse.Duration3Serializer : object {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
}
internal interface Cassandra.Serialization.Graph.GraphSON3.Dse.IComplexTypeGraphSONDeserializer {
    public abstract virtual object Objectify(JToken graphsonObject, Type type, IGraphTypeSerializer serializer, IGenericSerializer genericSerializer);
}
internal interface Cassandra.Serialization.Graph.GraphSON3.Dse.IComplexTypeGraphSONSerializer {
    public abstract virtual bool TryDictify(object objectData, IGraphSONWriter serializer, IGenericSerializer genericSerializer, Object& result);
}
internal class Cassandra.Serialization.Graph.GraphSON3.Dse.TupleGraphSONDeserializer : object {
    public sealed virtual object Objectify(JToken graphsonObject, Type type, IGraphTypeSerializer serializer, IGenericSerializer genericSerializer);
}
internal class Cassandra.Serialization.Graph.GraphSON3.Dse.TupleGraphSONSerializer : object {
    public sealed virtual bool TryDictify(object objectData, IGraphSONWriter serializer, IGenericSerializer genericSerializer, Object& result);
}
internal class Cassandra.Serialization.Graph.GraphSON3.Dse.UdtGraphSONDeserializer : object {
    public sealed virtual object Objectify(JToken graphsonObject, Type type, IGraphTypeSerializer serializer, IGenericSerializer genericSerializer);
    internal object ToObject(IGraphTypeSerializer serializer, UdtMap map, IEnumerable`1<JToken> valuesArr);
    internal object ToDictionary(IGraphTypeSerializer serializer, Type elementType, IEnumerable`1<JToken> definitions, IEnumerable`1<JToken> valuesArr);
}
internal class Cassandra.Serialization.Graph.GraphSON3.Dse.UdtGraphSONSerializer : object {
    public sealed virtual bool TryDictify(object objectData, IGraphSONWriter serializer, IGenericSerializer genericSerializer, Object& result);
    private Dictionary`2<string, object> GetUdtTypeDefinition(UdtMap map, IGenericSerializer genericSerializer);
}
internal class Cassandra.Serialization.Graph.GraphSON3.Structure.Path3Deserializer : BaseStructureDeserializer {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken graphsonObject, Func`2<JToken, GraphNode> factory, IGraphSONReader reader);
    private ICollection`1<ICollection`1<string>> ParseLabels(JObject tokenObj);
    private ICollection`1<GraphNode> ParseObjects(JObject tokenObj, Func`2<JToken, GraphNode> factory);
}
internal class Cassandra.Serialization.Graph.GraphSON3.Tinkerpop.ByteBufferDeserializer : object {
    private static string Prefix;
    private static string TypeKey;
    public static string TypeName { get; }
    public static string get_TypeName();
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.GraphSON3.Tinkerpop.ByteBufferSerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal interface Cassandra.Serialization.Graph.ICustomGraphSONReader {
    public abstract virtual object ToObject(JToken jToken);
}
internal interface Cassandra.Serialization.Graph.ICustomGraphSONWriter {
    public abstract virtual bool TryToDict(object objectData, Object& result);
}
internal interface Cassandra.Serialization.Graph.IGraphSONStructureDeserializer {
    public abstract virtual object Objectify(JToken graphsonObject, Func`2<JToken, GraphNode> graphNodeFactory, IGraphSONReader reader);
}
internal interface Cassandra.Serialization.Graph.IGraphTypeSerializer {
    public bool DefaultDeserializeGraphNodes { get; }
    public GraphProtocol GraphProtocol { get; }
    public abstract virtual bool get_DefaultDeserializeGraphNodes();
    public abstract virtual GraphProtocol get_GraphProtocol();
    public abstract virtual Func`2<Row, GraphNode> GetGraphRowParser();
    public abstract virtual object FromDb(JToken token, Type type);
    public abstract virtual object FromDb(JToken token, Type type, bool deserializeGraphNodes);
    public abstract virtual T FromDb(JToken token);
    public abstract virtual string ToDb(object obj);
    public abstract virtual bool ConvertFromDb(object obj, Type targetType, Object& result);
}
internal interface Cassandra.Serialization.Graph.INode {
    public bool DeserializeGraphNodes { get; }
    public bool IsArray { get; }
    public bool IsObjectTree { get; }
    public bool IsScalar { get; }
    public long Bulk { get; }
    public abstract virtual bool get_DeserializeGraphNodes();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsObjectTree();
    public abstract virtual bool get_IsScalar();
    public abstract virtual long get_Bulk();
    public abstract virtual T Get(string propertyName, bool throwIfNotFound);
    public abstract virtual int GetHashCode();
    public abstract virtual IDictionary`2<string, GraphNode> GetProperties();
    public abstract virtual IDictionary`2<string, IGraphNode> GetIProperties();
    public abstract virtual object GetRaw();
    public abstract virtual bool HasProperty(string name);
    public abstract virtual string GetGraphSONType();
    public abstract virtual object To(Type type);
    public abstract virtual T To();
    public abstract virtual GraphNode[] ToArray();
    public abstract virtual string ToString();
    public abstract virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public abstract virtual void WriteJson(JsonWriter writer, JsonSerializer serializer);
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.BigIntegerDeserializer : object {
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.BigIntegerSerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.ByteConverter : NumberConverter {
    protected string GraphSONTypeName { get; }
    protected Type HandledType { get; }
    protected string Prefix { get; }
    protected virtual string get_GraphSONTypeName();
    protected virtual Type get_HandledType();
    protected virtual string get_Prefix();
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.CharConverter : NumberConverter {
    protected string GraphSONTypeName { get; }
    protected Type HandledType { get; }
    protected string Prefix { get; }
    protected bool StringifyValue { get; }
    protected virtual string get_GraphSONTypeName();
    protected virtual Type get_HandledType();
    protected virtual string get_Prefix();
    protected virtual bool get_StringifyValue();
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.ClassSerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.DecimalConverter : NumberConverter {
    protected string GraphSONTypeName { get; }
    protected Type HandledType { get; }
    protected string Prefix { get; }
    protected bool StringifyValue { get; }
    protected virtual string get_GraphSONTypeName();
    protected virtual Type get_HandledType();
    protected virtual string get_Prefix();
    protected virtual bool get_StringifyValue();
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.DirectionDeserializer : object {
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.DoubleConverter : NumberConverter {
    protected string GraphSONTypeName { get; }
    protected Type HandledType { get; }
    protected virtual string get_GraphSONTypeName();
    protected virtual Type get_HandledType();
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.DurationSerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.EnumSerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.FloatConverter : NumberConverter {
    protected string GraphSONTypeName { get; }
    protected Type HandledType { get; }
    protected virtual string get_GraphSONTypeName();
    protected virtual Type get_HandledType();
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.GraphSON2Reader : GraphSONReader {
    public GraphSON2Reader(IReadOnlyDictionary`2<string, IGraphSONDeserializer> deserializerByGraphSONType);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.GraphSON2Writer : GraphSONWriter {
    public GraphSON2Writer(IReadOnlyDictionary`2<Type, IGraphSONSerializer> customSerializerByType);
}
internal abstract class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.GraphSONReader : object {
    protected Dictionary`2<string, IGraphSONDeserializer> Deserializers;
    protected GraphSONReader(IReadOnlyDictionary`2<string, IGraphSONDeserializer> deserializerByGraphSONType);
    public virtual object ToObject(IEnumerable`1<JToken> graphSonData);
    public virtual object ToObject(JToken jToken);
    private bool HasTypeKey(JToken jToken);
    private object ReadTypedValue(JToken typedValue);
    private object ReadDictionary(JToken jtokenDict);
    [CompilerGeneratedAttribute]
private object <ToObject>b__3_0(JToken graphson);
    [CompilerGeneratedAttribute]
private object <ToObject>b__4_0(JToken t);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.GraphSONTokens : object {
    public static string TypeKey;
    public static string ValueKey;
    public static string GremlinTypeNamespace;
    private static GraphSONTokens();
}
internal static class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.GraphSONUtil : object {
    public static Dictionary`2<string, object> ToTypedValue(string typename, object value, string prefix);
    public static string FormatTypeName(string namespacePrefix, string typeName);
    internal static Dictionary`2<string, object> ToCollection(object objectData, IGraphSONWriter writer, string typename);
}
internal abstract class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.GraphSONWriter : object {
    protected Dictionary`2<Type, IGraphSONSerializer> Serializers;
    protected GraphSONWriter(IReadOnlyDictionary`2<Type, IGraphSONSerializer> customSerializerByType);
    public virtual string WriteObject(object objectData);
    public virtual object ToDict(object objectData);
    private IGraphSONSerializer TryGetSerializerFor(Type type);
    private bool IsDictionaryType(Type type);
    private Dictionary`2<string, object> DictToGraphSONDict(object dict);
    private bool IsCollectionType(Type type);
    [IteratorStateMachineAttribute("Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.GraphSONWriter/<CollectionToGraphSONCollection>d__9")]
private IEnumerable`1<object> CollectionToGraphSONCollection(object collection);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.Int16Converter : NumberConverter {
    protected string GraphSONTypeName { get; }
    protected Type HandledType { get; }
    protected string Prefix { get; }
    protected virtual string get_GraphSONTypeName();
    protected virtual Type get_HandledType();
    protected virtual string get_Prefix();
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.Int32Converter : NumberConverter {
    protected string GraphSONTypeName { get; }
    protected Type HandledType { get; }
    protected virtual string get_GraphSONTypeName();
    protected virtual Type get_HandledType();
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.Int64Converter : NumberConverter {
    protected string GraphSONTypeName { get; }
    protected Type HandledType { get; }
    protected virtual string get_GraphSONTypeName();
    protected virtual Type get_HandledType();
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.ListSerializer : object {
    private static IReadOnlyList`1<object> EmptyList;
    private static ListSerializer();
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.MapSerializer : object {
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal abstract class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.NumberConverter : object {
    protected string GraphSONTypeName { get; }
    protected Type HandledType { get; }
    protected string Prefix { get; }
    protected bool StringifyValue { get; }
    protected abstract virtual string get_GraphSONTypeName();
    protected abstract virtual Type get_HandledType();
    protected virtual string get_Prefix();
    protected virtual bool get_StringifyValue();
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.SetSerializer : object {
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.TDeserializer : object {
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.UuidDeserializer : object {
    public sealed virtual object Objectify(JToken graphsonObject, IGraphSONReader reader);
}
internal class Cassandra.Serialization.Graph.Tinkerpop.Structure.IO.GraphSON.UuidSerializer : object {
    public sealed virtual Dictionary`2<string, object> Dictify(object objectData, IGraphSONWriter writer);
}
internal interface Cassandra.Serialization.IGenericSerializer {
    public abstract virtual object Deserialize(ProtocolVersion version, Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public abstract virtual Byte[] Serialize(ProtocolVersion version, object value);
    public abstract virtual Type GetClrType(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public abstract virtual Type GetClrTypeForGraph(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public abstract virtual Type GetClrTypeForCustom(IColumnInfo typeInfo);
    public abstract virtual ColumnTypeCode GetCqlType(Type type, IColumnInfo& typeInfo);
    public abstract virtual bool IsAssignableFrom(ColumnTypeCode columnTypeCode, IColumnInfo typeInfo, object value, String& failureMsg);
    public abstract virtual UdtMap GetUdtMapByName(string name);
    public abstract virtual UdtMap GetUdtMapByType(Type type);
    public abstract virtual int GetValueLengthIfFixed(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public abstract virtual int GetValueLengthIfFixed(object value);
}
internal interface Cassandra.Serialization.ISerializer {
    public ProtocolVersion ProtocolVersion { get; }
    public bool IsEncryptionEnabled { get; }
    public abstract virtual ProtocolVersion get_ProtocolVersion();
    public abstract virtual object Deserialize(Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public abstract virtual object DeserializeAndDecrypt(string ks, string table, string col, Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public abstract virtual Byte[] Serialize(object value);
    public abstract virtual Byte[] SerializeAndEncrypt(string defaultKs, RowSetMetadata metadata, int colMetadataIdx, Object[] values, int valueIdx);
    public abstract virtual ISerializer CloneWithProtocolVersion(ProtocolVersion version);
    public abstract virtual bool get_IsEncryptionEnabled();
    public abstract virtual Tuple`3<bool, ColumnTypeCode, IColumnInfo> IsAssignableFromEncrypted(string ks, string table, string column, ColumnTypeCode columnTypeCode, IColumnInfo typeInfo, object value, String& failureMsg);
}
internal interface Cassandra.Serialization.ISerializerManager {
    public ProtocolVersion CurrentProtocolVersion { get; }
    public abstract virtual ProtocolVersion get_CurrentProtocolVersion();
    public abstract virtual void ChangeProtocolVersion(ProtocolVersion version);
    public abstract virtual ISerializer GetCurrentSerializer();
    public abstract virtual void SetUdtMap(string name, UdtMap map);
    public abstract virtual IGenericSerializer GetGenericSerializer();
}
internal interface Cassandra.Serialization.ITypeSerializer {
    public Type Type { get; }
    public IColumnInfo TypeInfo { get; }
    public ColumnTypeCode CqlType { get; }
    public abstract virtual Type get_Type();
    public abstract virtual IColumnInfo get_TypeInfo();
    public abstract virtual ColumnTypeCode get_CqlType();
    public abstract virtual object Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public abstract virtual Byte[] Serialize(ushort protocolVersion, object obj);
}
internal class Cassandra.Serialization.LegacyTypeSerializer : object {
    private ColumnTypeCode _typeCode;
    private ITypeAdapter _adapter;
    private bool _reverse;
    public Type Type { get; }
    public IColumnInfo TypeInfo { get; }
    public ColumnTypeCode CqlType { get; }
    internal LegacyTypeSerializer(ColumnTypeCode typeCode, ITypeAdapter adapter, bool reverse);
    public sealed virtual Type get_Type();
    public sealed virtual IColumnInfo get_TypeInfo();
    public sealed virtual ColumnTypeCode get_CqlType();
    public sealed virtual object Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public sealed virtual Byte[] Serialize(ushort protocolVersion, object obj);
}
internal class Cassandra.Serialization.Primitive.BigIntegerSerializer : TypeSerializer`1<BigInteger> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual BigInteger Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, BigInteger value);
}
internal class Cassandra.Serialization.Primitive.BooleanSerializer : TypeSerializer`1<bool> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual bool Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, bool value);
}
internal class Cassandra.Serialization.Primitive.ByteArraySerializer : TypeSerializer`1<Byte[]> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual Byte[] Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, Byte[] value);
}
internal class Cassandra.Serialization.Primitive.DateTimeOffsetSerializer : TypeSerializer`1<DateTimeOffset> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    internal static DateTimeOffset Deserialize(Byte[] buffer, int offset);
    internal static Byte[] Serialize(DateTimeOffset value);
    public virtual DateTimeOffset Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, DateTimeOffset value);
}
internal class Cassandra.Serialization.Primitive.DateTimeSerializer : TypeSerializer`1<DateTime> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual DateTime Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, DateTime value);
}
public class Cassandra.Serialization.Primitive.DecimalSerializer : TypeSerializer`1<decimal> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual decimal Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    internal static decimal ToDecimal(BigInteger unscaledValue, int scale);
    public virtual Byte[] Serialize(ushort protocolVersion, decimal value);
}
internal class Cassandra.Serialization.Primitive.DoubleSerializer : TypeSerializer`1<double> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual double Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, double value);
}
internal class Cassandra.Serialization.Primitive.FloatSerializer : TypeSerializer`1<float> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual float Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, float value);
}
internal class Cassandra.Serialization.Primitive.GuidSerializer : TypeSerializer`1<Guid> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual Guid Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, Guid value);
}
internal class Cassandra.Serialization.Primitive.IntSerializer : TypeSerializer`1<int> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual int Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, int value);
}
internal class Cassandra.Serialization.Primitive.IpAddressSerializer : TypeSerializer`1<IPAddress> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual IPAddress Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, IPAddress value);
}
internal class Cassandra.Serialization.Primitive.LocalDateSerializer : TypeSerializer`1<LocalDate> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual LocalDate Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, LocalDate value);
}
internal class Cassandra.Serialization.Primitive.LocalTimeSerializer : TypeSerializer`1<LocalTime> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual LocalTime Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, LocalTime value);
}
internal class Cassandra.Serialization.Primitive.LongSerializer : TypeSerializer`1<long> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual long Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, long value);
}
internal class Cassandra.Serialization.Primitive.SbyteSerializer : TypeSerializer`1<sbyte> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual sbyte Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, sbyte value);
}
internal class Cassandra.Serialization.Primitive.ShortSerializer : TypeSerializer`1<short> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual short Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, short value);
}
internal class Cassandra.Serialization.Primitive.StringSerializer : TypeSerializer`1<string> {
    private Encoding _encoding;
    public ColumnTypeCode CqlType { get; }
    public StringSerializer(Encoding encoding);
    public virtual ColumnTypeCode get_CqlType();
    public virtual string Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, string value);
}
internal class Cassandra.Serialization.Primitive.TimeUuidSerializer : TypeSerializer`1<TimeUuid> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual TimeUuid Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, TimeUuid value);
}
internal class Cassandra.Serialization.Search.DateRangeSerializer : TypeSerializer`1<DateRange> {
    private IColumnInfo _typeInfo;
    private static int ByteLengthSingleBoundary;
    private static int ByteLengthTwoBoundaries;
    public ColumnTypeCode CqlType { get; }
    public IColumnInfo TypeInfo { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual IColumnInfo get_TypeInfo();
    public virtual DateRange Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    private DateRangeBound ReadDateRangeBound(Byte[] buffer, int offset);
    public virtual Byte[] Serialize(ushort protocolVersion, DateRange value);
    private static int WriteDateRangeBound(Byte[] buffer, int offset, DateRangeBound value);
}
internal class Cassandra.Serialization.Serializer : object {
    private IGenericSerializer _serializer;
    private IColumnEncryptionPolicy _columnEncryptionPolicy;
    [CompilerGeneratedAttribute]
private ProtocolVersion <ProtocolVersion>k__BackingField;
    public ProtocolVersion ProtocolVersion { get; }
    public bool IsEncryptionEnabled { get; }
    public Serializer(ProtocolVersion version, IGenericSerializer serializer, IColumnEncryptionPolicy columnEncryptionPolicy);
    [CompilerGeneratedAttribute]
public sealed virtual ProtocolVersion get_ProtocolVersion();
    public sealed virtual object Deserialize(Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual object DeserializeAndDecrypt(string ks, string table, string column, Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual Byte[] Serialize(object value);
    public sealed virtual Byte[] SerializeAndEncrypt(string defaultKs, RowSetMetadata metadata, int colIdx, Object[] values, int valueIdx);
    public sealed virtual ISerializer CloneWithProtocolVersion(ProtocolVersion version);
    public sealed virtual bool get_IsEncryptionEnabled();
    public sealed virtual Tuple`3<bool, ColumnTypeCode, IColumnInfo> IsAssignableFromEncrypted(string ks, string table, string column, ColumnTypeCode columnTypeCode, IColumnInfo columnTypeInfo, object value, String& failureMsg);
    public sealed virtual object Deserialize(ProtocolVersion version, Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual Byte[] Serialize(ProtocolVersion version, object value);
    public sealed virtual Type GetClrType(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual Type GetClrTypeForGraph(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual Type GetClrTypeForCustom(IColumnInfo typeInfo);
    public sealed virtual ColumnTypeCode GetCqlType(Type type, IColumnInfo& typeInfo);
    public sealed virtual bool IsAssignableFrom(ColumnTypeCode columnTypeCode, IColumnInfo typeInfo, object value, String& failureMsg);
    public sealed virtual UdtMap GetUdtMapByName(string name);
    public sealed virtual UdtMap GetUdtMapByType(Type type);
    public sealed virtual int GetValueLengthIfFixed(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public sealed virtual int GetValueLengthIfFixed(object value);
}
internal class Cassandra.Serialization.SerializerManager : object {
    internal static ISerializerManager Default;
    internal static Byte[] UnsetBuffer;
    private GenericSerializer _genericSerializer;
    private IColumnEncryptionPolicy _clePolicy;
    private ISerializer modreq(System.Runtime.CompilerServices.IsVolatile) _serializer;
    public ProtocolVersion CurrentProtocolVersion { get; }
    internal SerializerManager(ProtocolVersion protocolVersion, IColumnEncryptionPolicy clePolicy, IEnumerable`1<ITypeSerializer> typeSerializers);
    private static SerializerManager();
    public sealed virtual ProtocolVersion get_CurrentProtocolVersion();
    public sealed virtual void ChangeProtocolVersion(ProtocolVersion version);
    public sealed virtual ISerializer GetCurrentSerializer();
    public object Deserialize(ProtocolVersion version, Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    public Byte[] Serialize(ProtocolVersion version, object value);
    public sealed virtual void SetUdtMap(string name, UdtMap map);
    public sealed virtual IGenericSerializer GetGenericSerializer();
}
internal class Cassandra.Serialization.TupleSerializer : TypeSerializer`1<IStructuralEquatable> {
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    public virtual IStructuralEquatable Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    internal Type GetClrType(IColumnInfo typeInfo);
    internal Type GetClrTypeForGraph(IColumnInfo typeInfo);
    private Type GetGenericTupleType(TupleColumnInfo tupleInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, IStructuralEquatable value);
    [CompilerGeneratedAttribute]
private Type <GetClrType>b__3_0(ColumnDesc s);
    [CompilerGeneratedAttribute]
private Type <GetClrTypeForGraph>b__4_0(ColumnDesc s);
}
public abstract class Cassandra.Serialization.TypeSerializer : object {
    public static TypeSerializer`1<BigInteger> PrimitiveBigIntegerSerializer;
    public static TypeSerializer`1<bool> PrimitiveBooleanSerializer;
    public static TypeSerializer`1<Byte[]> PrimitiveByteArraySerializer;
    public static TypeSerializer`1<DateTimeOffset> PrimitiveDateTimeOffsetSerializer;
    public static TypeSerializer`1<DateTime> PrimitiveDateTimeSerializer;
    public static TypeSerializer`1<decimal> PrimitiveDecimalSerializer;
    public static TypeSerializer`1<double> PrimitiveDoubleSerializer;
    public static TypeSerializer`1<Duration> PrimitiveDurationSerializer;
    public static TypeSerializer`1<float> PrimitiveFloatSerializer;
    public static TypeSerializer`1<Guid> PrimitiveGuidSerializer;
    public static TypeSerializer`1<int> PrimitiveIntSerializer;
    public static TypeSerializer`1<IPAddress> PrimitiveIpAddressSerializer;
    public static TypeSerializer`1<LocalDate> PrimitiveLocalDateSerializer;
    public static TypeSerializer`1<LocalTime> PrimitiveLocalTimeSerializer;
    public static TypeSerializer`1<long> PrimitiveLongSerializer;
    public static TypeSerializer`1<sbyte> PrimitiveSbyteSerializer;
    public static TypeSerializer`1<short> PrimitiveShortSerializer;
    public static TypeSerializer`1<string> PrimitiveStringSerializer;
    public static TypeSerializer`1<string> PrimitiveAsciiStringSerializer;
    public static TypeSerializer`1<TimeUuid> PrimitiveTimeUuidSerializer;
    internal static DateTimeOffset UnixStart;
    private static TypeSerializer();
    internal static Byte[] GuidShuffle(Byte[] b, int offset);
    internal static int DecodeCollectionLength(ProtocolVersion protocolVersion, Byte[] buffer, Int32& index);
    internal static Byte[] EncodeCollectionLength(ushort protocolVersion, int value);
    internal static Byte[] EncodeBufferList(ICollection`1<Byte[]> bufferList, int bufferLength);
    public static TimeSpan SinceUnixEpoch(DateTimeOffset value);
    internal static void CheckArgument(object value);
}
public abstract class Cassandra.Serialization.TypeSerializer`1 : TypeSerializer {
    private IGenericSerializer _serializer;
    public Type Type { get; }
    public IColumnInfo TypeInfo { get; }
    public ColumnTypeCode CqlType { get; }
    public sealed virtual Type get_Type();
    public virtual IColumnInfo get_TypeInfo();
    public abstract virtual ColumnTypeCode get_CqlType();
    private sealed virtual override object Cassandra.Serialization.ITypeSerializer.Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    private sealed virtual override Byte[] Cassandra.Serialization.ITypeSerializer.Serialize(ushort protocolVersion, object obj);
    public abstract virtual T Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public abstract virtual Byte[] Serialize(ushort protocolVersion, T value);
    internal object DeserializeChild(ushort protocolVersion, Byte[] buffer, int offset, int length, ColumnTypeCode typeCode, IColumnInfo typeInfo);
    internal Type GetClrType(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    internal Type GetClrTypeForGraph(ColumnTypeCode typeCode, IColumnInfo typeInfo);
    internal Byte[] SerializeChild(ushort protocolVersion, object obj);
    internal void SetChildSerializer(IGenericSerializer serializer);
    internal IGenericSerializer GetChildSerializer();
}
public class Cassandra.Serialization.TypeSerializerDefinitions : object {
    private ICollection`1<ITypeSerializer> _definitions;
    internal ICollection`1<ITypeSerializer> Definitions { get; }
    internal ICollection`1<ITypeSerializer> get_Definitions();
    public TypeSerializerDefinitions Define(TypeSerializer`1<T> typeSerializer);
    internal TypeSerializerDefinitions DefineIfNotExists(TypeSerializer`1<T> serializer);
}
public class Cassandra.Serialization.UdtSerializer : TypeSerializer`1<object> {
    private ConcurrentDictionary`2<string, UdtMap> _udtMapsByName;
    private ConcurrentDictionary`2<Type, UdtMap> _udtMapsByClrType;
    public ColumnTypeCode CqlType { get; }
    public virtual ColumnTypeCode get_CqlType();
    protected internal virtual Type GetClrType(IColumnInfo typeInfo);
    protected internal virtual UdtMap GetUdtMap(string name);
    protected internal virtual UdtMap GetUdtMap(Type type);
    public virtual object Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, object value);
    public virtual void SetUdtMap(string name, UdtMap map);
}
internal class Cassandra.Serialization.VectorSerializer : TypeSerializer`1<IInternalCqlVector> {
    private static ThreadLocal`1<Byte[]> EncodingBuffer;
    public ColumnTypeCode CqlType { get; }
    public IColumnInfo TypeInfo { get; }
    private static VectorSerializer();
    public virtual ColumnTypeCode get_CqlType();
    public virtual IColumnInfo get_TypeInfo();
    public virtual IInternalCqlVector Deserialize(ushort protocolVersion, Byte[] buffer, int offset, int length, IColumnInfo typeInfo);
    public virtual Byte[] Serialize(ushort protocolVersion, IInternalCqlVector value);
    internal Type GetClrType(VectorColumnInfo vectorColumnInfo);
    private VectorColumnInfo GetVectorColumnInfo(IColumnInfo typeInfo);
}
internal static class Cassandra.Serialization.VintSerializer : object {
    private static long EncodeZigZag64(long n);
    private static long DecodeZigZag64(long n);
    private static int ComputeUnsignedVIntSize(long value);
    private static int LeadingZeros(UInt32 value);
    private static int LeadingZeros(ulong value);
    private static int FirstByteValueMask(int extraBytesToRead);
    private static int EncodeExtraBytesToRead(int extraBytesToRead);
    private static int NumberOfExtraBytesToRead(int firstByte);
    private static void EncodeVInt(long value, int size, Byte[] buffer);
    public static int WriteUnsignedVInt(long value, Byte[] buffer);
    public static int WriteVInt(long value, Byte[] buffer);
    public static long ReadUnsignedVInt(Byte[] input, Int32& offset);
    public static long ReadVInt(Byte[] buffer, Int32& offset);
}
public class Cassandra.ServerErrorException : QueryValidationException {
    public ServerErrorException(string message);
}
public class Cassandra.Session : object {
    private ISerializerManager _serializerManager;
    private static Logger Logger;
    private IThreadSafeDictionary`2<IPEndPoint, IHostConnectionPool> _connectionPool;
    private IInternalCluster _cluster;
    private int _disposed;
    private long _initialized;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _keyspace;
    private IMetricsManager _metricsManager;
    private IObserverFactory _observerFactory;
    private IInsightsClient _insightsClient;
    private IGraphTypeSerializerFactory _graphTypeSerializerFactory;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private UdtMappingDefinitions <UserDefinedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Cassandra.SessionManagement.IInternalSession.InternalSessionId>k__BackingField;
    internal IInternalSession InternalRef { get; }
    public int BinaryProtocolVersion { get; }
    public ICluster Cluster { get; }
    private IInternalCluster Cassandra.SessionManagement.IInternalSession.InternalCluster { get; }
    private IMetricsManager Cassandra.SessionManagement.IInternalSession.MetricsManager { get; }
    private IObserverFactory Cassandra.SessionManagement.IInternalSession.ObserverFactory { get; }
    public Configuration Configuration { get; protected set; }
    public bool IsDisposed { get; }
    public string Keyspace { get; private set; }
    private string Cassandra.SessionManagement.IInternalSession.Keyspace { get; private set; }
    public UdtMappingDefinitions UserDefinedTypes { get; private set; }
    public string SessionName { get; }
    public Policies Policies { get; }
    private Guid Cassandra.SessionManagement.IInternalSession.InternalSessionId { get; }
    private int Cassandra.SessionManagement.IInternalSession.ConnectedNodes { get; }
    internal Session(IInternalCluster cluster, Configuration configuration, string keyspace, ISerializerManager serializerManager, string sessionName);
    private static Session();
    internal IInternalSession get_InternalRef();
    public sealed virtual int get_BinaryProtocolVersion();
    public sealed virtual ICluster get_Cluster();
    private sealed virtual override IInternalCluster Cassandra.SessionManagement.IInternalSession.get_InternalCluster();
    private sealed virtual override IMetricsManager Cassandra.SessionManagement.IInternalSession.get_MetricsManager();
    private sealed virtual override IObserverFactory Cassandra.SessionManagement.IInternalSession.get_ObserverFactory();
    [CompilerGeneratedAttribute]
public Configuration get_Configuration();
    [CompilerGeneratedAttribute]
protected void set_Configuration(Configuration value);
    public sealed virtual bool get_IsDisposed();
    public sealed virtual string get_Keyspace();
    private void set_Keyspace(string value);
    private sealed virtual override string Cassandra.SessionManagement.IInternalSession.get_Keyspace();
    private sealed virtual override void Cassandra.SessionManagement.IInternalSession.set_Keyspace(string value);
    [CompilerGeneratedAttribute]
public sealed virtual UdtMappingDefinitions get_UserDefinedTypes();
    [CompilerGeneratedAttribute]
private void set_UserDefinedTypes(UdtMappingDefinitions value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SessionName();
    public Policies get_Policies();
    [CompilerGeneratedAttribute]
private sealed virtual override Guid Cassandra.SessionManagement.IInternalSession.get_InternalSessionId();
    public sealed virtual IAsyncResult BeginExecute(IStatement statement, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginExecute(string cqlQuery, ConsistencyLevel consistency, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginPrepare(string cqlQuery, AsyncCallback callback, object state);
    public sealed virtual void ChangeKeyspace(string keyspace);
    public sealed virtual void CreateKeyspace(string keyspace, Dictionary`2<string, string> replication, bool durableWrites);
    public sealed virtual void CreateKeyspaceIfNotExists(string keyspaceName, Dictionary`2<string, string> replication, bool durableWrites);
    public sealed virtual void DeleteKeyspace(string keyspaceName);
    public sealed virtual void DeleteKeyspaceIfExists(string keyspaceName);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Cassandra.Session/<ShutdownAsync>d__57")]
public sealed virtual Task ShutdownAsync();
    [AsyncStateMachineAttribute("Cassandra.Session/<Cassandra-SessionManagement-IInternalSession-Init>d__58")]
private sealed virtual override Task Cassandra.SessionManagement.IInternalSession.Init();
    [AsyncStateMachineAttribute("Cassandra.Session/<Warmup>d__59")]
private Task Warmup();
    public sealed virtual RowSet EndExecute(IAsyncResult ar);
    public sealed virtual PreparedStatement EndPrepare(IAsyncResult ar);
    public sealed virtual RowSet Execute(IStatement statement, string executionProfileName);
    public sealed virtual RowSet Execute(IStatement statement);
    public sealed virtual RowSet Execute(string cqlQuery);
    public sealed virtual RowSet Execute(string cqlQuery, string executionProfileName);
    public sealed virtual RowSet Execute(string cqlQuery, ConsistencyLevel consistency);
    public sealed virtual RowSet Execute(string cqlQuery, int pageSize);
    public sealed virtual Task`1<RowSet> ExecuteAsync(IStatement statement);
    public sealed virtual Task`1<RowSet> ExecuteAsync(IStatement statement, string executionProfileName);
    [AsyncStateMachineAttribute("Cassandra.Session/<Cassandra-SessionManagement-IInternalSession-ExecuteAsync>d__70")]
private sealed virtual override Task`1<RowSet> Cassandra.SessionManagement.IInternalSession.ExecuteAsync(IStatement statement, IRequestOptions requestOptions);
    private sealed virtual override IHostConnectionPool Cassandra.SessionManagement.IInternalSession.GetOrCreateConnectionPool(Host host, HostDistance distance);
    private sealed virtual override IEnumerable`1<KeyValuePair`2<IPEndPoint, IHostConnectionPool>> Cassandra.SessionManagement.IInternalSession.GetPools();
    private sealed virtual override void Cassandra.SessionManagement.IInternalSession.OnAllConnectionClosed(Host host, IHostConnectionPool pool);
    private sealed virtual override int Cassandra.SessionManagement.IInternalSession.get_ConnectedNodes();
    public sealed virtual IDriverMetrics GetMetrics();
    private sealed virtual override bool Cassandra.SessionManagement.IInternalSession.HasConnections(Host host);
    private sealed virtual override IHostConnectionPool Cassandra.SessionManagement.IInternalSession.GetExistingPool(IPEndPoint address);
    private sealed virtual override void Cassandra.SessionManagement.IInternalSession.CheckHealth(Host host, IConnection connection);
    public sealed virtual PreparedStatement Prepare(string cqlQuery);
    public sealed virtual PreparedStatement Prepare(string cqlQuery, IDictionary`2<string, Byte[]> customPayload);
    public sealed virtual PreparedStatement Prepare(string cqlQuery, string keyspace);
    public sealed virtual PreparedStatement Prepare(string cqlQuery, string keyspace, IDictionary`2<string, Byte[]> customPayload);
    public sealed virtual Task`1<PreparedStatement> PrepareAsync(string query);
    public sealed virtual Task`1<PreparedStatement> PrepareAsync(string query, IDictionary`2<string, Byte[]> customPayload);
    public sealed virtual Task`1<PreparedStatement> PrepareAsync(string cqlQuery, string keyspace);
    [AsyncStateMachineAttribute("Cassandra.Session/<PrepareAsync>d__87")]
public sealed virtual Task`1<PreparedStatement> PrepareAsync(string cqlQuery, string keyspace, IDictionary`2<string, Byte[]> customPayload);
    public sealed virtual void WaitForSchemaAgreement(RowSet rs);
    public sealed virtual bool WaitForSchemaAgreement(IPEndPoint hostAddress);
    private IStatement GetDefaultStatement(string cqlQuery);
    private sealed virtual override IRequestOptions Cassandra.SessionManagement.IInternalSession.GetRequestOptions(string executionProfileName);
    private void OnHostRemoved(Host host);
    public sealed virtual GraphResultSet ExecuteGraph(IGraphStatement statement);
    public sealed virtual Task`1<GraphResultSet> ExecuteGraphAsync(IGraphStatement graphStatement);
    public sealed virtual GraphResultSet ExecuteGraph(IGraphStatement statement, string executionProfileName);
    public sealed virtual Task`1<GraphResultSet> ExecuteGraphAsync(IGraphStatement graphStatement, string executionProfileName);
    [CompilerGeneratedAttribute]
private bool <Warmup>b__59_0(Host h);
}
internal interface Cassandra.SessionManagement.IInternalCluster {
    public ConcurrentDictionary`2<Byte[], PreparedStatement> PreparedQueries { get; }
    public abstract virtual bool AnyOpenConnections(Host host);
    public abstract virtual IControlConnection GetControlConnection();
    public abstract virtual ConcurrentDictionary`2<Byte[], PreparedStatement> get_PreparedQueries();
    public abstract virtual Task`1<PreparedStatement> Prepare(IInternalSession session, ISerializerManager serializerManager, InternalPrepareRequest request);
    public abstract virtual IReadOnlyDictionary`2<IContactPoint, IEnumerable`1<IConnectionEndPoint>> GetResolvedEndpoints();
    public abstract virtual HostDistance RetrieveAndSetDistance(Host host);
    public abstract virtual IEnumerable`1<IInternalSession> GetConnectedSessions();
    public abstract virtual void RemoveSession(IInternalSession session);
}
internal interface Cassandra.SessionManagement.IInternalSession {
    public Guid InternalSessionId { get; }
    public string Keyspace { get; public set; }
    public IInternalCluster InternalCluster { get; }
    public int ConnectedNodes { get; }
    public IMetricsManager MetricsManager { get; }
    public IObserverFactory ObserverFactory { get; }
    public abstract virtual Guid get_InternalSessionId();
    public abstract virtual Task Init();
    public abstract virtual IHostConnectionPool GetOrCreateConnectionPool(Host host, HostDistance distance);
    public abstract virtual IEnumerable`1<KeyValuePair`2<IPEndPoint, IHostConnectionPool>> GetPools();
    public abstract virtual IHostConnectionPool GetExistingPool(IPEndPoint address);
    public abstract virtual void CheckHealth(Host host, IConnection connection);
    public abstract virtual bool HasConnections(Host host);
    public abstract virtual void OnAllConnectionClosed(Host host, IHostConnectionPool pool);
    public abstract virtual string get_Keyspace();
    public abstract virtual void set_Keyspace(string value);
    public abstract virtual IInternalCluster get_InternalCluster();
    public abstract virtual IRequestOptions GetRequestOptions(string executionProfileName);
    public abstract virtual int get_ConnectedNodes();
    public abstract virtual IMetricsManager get_MetricsManager();
    public abstract virtual IObserverFactory get_ObserverFactory();
    public abstract virtual Task`1<RowSet> ExecuteAsync(IStatement statement, IRequestOptions requestOptions);
}
internal interface Cassandra.SessionManagement.ISessionFactory {
    public abstract virtual Task`1<IInternalSession> CreateSessionAsync(IInternalCluster cluster, string keyspace, ISerializerManager serializer, string sessionName);
}
internal class Cassandra.SessionManagement.SessionFactory : object {
    public sealed virtual Task`1<IInternalSession> CreateSessionAsync(IInternalCluster cluster, string keyspace, ISerializerManager serializer, string sessionName);
}
public class Cassandra.SessionRequestInfo : object {
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IStatement <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private PrepareRequest <PrepareRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionKeyspace>k__BackingField;
    public ConcurrentDictionary`2<string, object> Items { get; }
    public IStatement Statement { get; }
    public PrepareRequest PrepareRequest { get; }
    public string SessionKeyspace { get; }
    private SessionRequestInfo(string sessionKeyspace);
    internal SessionRequestInfo(IStatement statement, string sessionKeyspace);
    internal SessionRequestInfo(InternalPrepareRequest prepareRequest, string sessionKeyspace);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public IStatement get_Statement();
    [CompilerGeneratedAttribute]
public PrepareRequest get_PrepareRequest();
    [CompilerGeneratedAttribute]
public string get_SessionKeyspace();
}
internal class Cassandra.SessionState : object {
    private static IDictionary`2<Host, HostStateInfo> EmptyDictionary;
    private IDictionary`2<Host, HostStateInfo> _infos;
    internal SessionState(IDictionary`2<Host, HostStateInfo> infos);
    private static SessionState();
    public sealed virtual IReadOnlyCollection`1<Host> GetConnectedHosts();
    public sealed virtual int GetOpenConnections(Host host);
    public sealed virtual int GetInFlightQueries(Host host);
    public virtual string ToString();
    internal static SessionState From(IInternalSession session);
    internal static SessionState Empty();
}
public class Cassandra.SetColumnInfo : object {
    [CompilerGeneratedAttribute]
private ColumnTypeCode <KeyTypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IColumnInfo <KeyTypeInfo>k__BackingField;
    public ColumnTypeCode KeyTypeCode { get; public set; }
    public IColumnInfo KeyTypeInfo { get; public set; }
    [CompilerGeneratedAttribute]
public ColumnTypeCode get_KeyTypeCode();
    [CompilerGeneratedAttribute]
public void set_KeyTypeCode(ColumnTypeCode value);
    [CompilerGeneratedAttribute]
public IColumnInfo get_KeyTypeInfo();
    [CompilerGeneratedAttribute]
public void set_KeyTypeInfo(IColumnInfo value);
    private sealed virtual override ColumnDesc Cassandra.ICollectionColumnInfo.GetChildType();
}
internal class Cassandra.SimpleAuthInfoProvider : object {
    private Dictionary`2<string, string> _credentials;
    public SimpleAuthInfoProvider(Dictionary`2<string, string> properties);
    public sealed virtual IDictionary`2<string, string> GetAuthInfos(IPEndPoint host);
    public SimpleAuthInfoProvider Add(string property, string value);
    public SimpleAuthInfoProvider AddAll(Dictionary`2<string, string> properties);
}
public class Cassandra.SimpleStatement : RegularStatement {
    private static Logger Logger;
    private string _query;
    private RoutingKey modreq(System.Runtime.CompilerServices.IsVolatile) _routingKey;
    private Object[] _routingValues;
    private string _keyspace;
    public string QueryString { get; }
    public RoutingKey RoutingKey { get; }
    public string Keyspace { get; }
    public SimpleStatement(string query);
    public SimpleStatement(string query, Object[] values);
    public SimpleStatement(IDictionary`2<string, object> valuesDictionary, string query);
    private static SimpleStatement();
    public virtual string get_QueryString();
    public virtual RoutingKey get_RoutingKey();
    public virtual string get_Keyspace();
    public SimpleStatement SetRoutingKey(RoutingKey[] routingKeyComponents);
    public SimpleStatement SetRoutingValues(Object[] keys);
    public SimpleStatement SetQueryString(string queryString);
    [ObsoleteAttribute("The method Bind() is deprecated, use SimpleStatement constructor parameters to provide query values")]
public SimpleStatement Bind(Object[] values);
    [ObsoleteAttribute("The method BindObject() is deprecated, use SimpleStatement constructor parameters to provide query values")]
public SimpleStatement BindObjects(Object[] values);
    public SimpleStatement SetKeyspace(string name);
    internal virtual IQueryRequest CreateBatchRequest(ISerializer serializer);
    internal virtual void SetValues(Object[] values, ISerializer serializer);
    private void SetParameterNames(IEnumerable`1<string> names);
}
internal class Cassandra.SniOptions : object {
    [CompilerGeneratedAttribute]
private IPAddress <Ip>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <ServerNames>k__BackingField;
    public IPAddress Ip { get; }
    public string Name { get; }
    public int Port { get; }
    public bool IsIp { get; }
    public ISet`1<string> ServerNames { get; }
    public SniOptions(IPAddress ip, int port, string name, ISet`1<string> serverNames);
    [CompilerGeneratedAttribute]
public IPAddress get_Ip();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_Port();
    public bool get_IsIp();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_ServerNames();
}
public class Cassandra.SocketOptions : object {
    public static int DefaultConnectTimeoutMillis;
    public static int DefaultReadTimeoutMillis;
    internal static int DefaultDefunctReadTimeoutThreshold;
    private int _connectTimeoutMillis;
    private bool _keepAlive;
    private Nullable`1<int> _receiveBufferSize;
    private Nullable`1<bool> _reuseAddress;
    private Nullable`1<int> _sendBufferSize;
    private Nullable`1<int> _soLinger;
    private bool _tcpNoDelay;
    private bool _useStreamMode;
    private int _readTimeoutMillis;
    private int _defunctReadTimeoutThreshold;
    private int _metadataAbortTimeout;
    public int ConnectTimeoutMillis { get; }
    public Nullable`1<bool> KeepAlive { get; }
    public Nullable`1<bool> ReuseAddress { get; }
    public Nullable`1<int> SoLinger { get; }
    public Nullable`1<bool> TcpNoDelay { get; }
    public Nullable`1<int> ReceiveBufferSize { get; }
    public Nullable`1<int> SendBufferSize { get; }
    public bool UseStreamMode { get; }
    public int ReadTimeoutMillis { get; }
    internal int MetadataAbortTimeout { get; }
    public int DefunctReadTimeoutThreshold { get; }
    public int get_ConnectTimeoutMillis();
    public Nullable`1<bool> get_KeepAlive();
    public Nullable`1<bool> get_ReuseAddress();
    public Nullable`1<int> get_SoLinger();
    public Nullable`1<bool> get_TcpNoDelay();
    public Nullable`1<int> get_ReceiveBufferSize();
    public Nullable`1<int> get_SendBufferSize();
    public bool get_UseStreamMode();
    public int get_ReadTimeoutMillis();
    internal int get_MetadataAbortTimeout();
    public int get_DefunctReadTimeoutThreshold();
    public SocketOptions SetConnectTimeoutMillis(int connectTimeoutMillis);
    public SocketOptions SetKeepAlive(bool keepAlive);
    public SocketOptions SetReuseAddress(bool reuseAddress);
    public SocketOptions SetSoLinger(int soLinger);
    public SocketOptions SetTcpNoDelay(bool tcpNoDelay);
    public SocketOptions SetReceiveBufferSize(int receiveBufferSize);
    public SocketOptions SetSendBufferSize(int sendBufferSize);
    public SocketOptions SetStreamMode(bool useStreamMode);
    public SocketOptions SetReadTimeoutMillis(int milliseconds);
    public SocketOptions SetDefunctReadTimeoutThreshold(int amountOfTimeouts);
    internal SocketOptions SetMetadataAbortTimeout(int metadataAbortTimeout);
}
public class Cassandra.SSLOptions : object {
    private static Logger _logger;
    private RemoteCertificateValidationCallback _remoteCertValidationCallback;
    private SslProtocols _sslProtocol;
    private bool _checkCertificateRevocation;
    private X509CertificateCollection _certificateCollection;
    private Func`2<IPAddress, string> _hostNameResolver;
    public RemoteCertificateValidationCallback RemoteCertValidationCallback { get; }
    public SslProtocols SslProtocol { get; }
    public bool CheckCertificateRevocation { get; }
    public Func`2<IPAddress, string> HostNameResolver { get; }
    public X509CertificateCollection CertificateCollection { get; }
    public SSLOptions(SslProtocols sslProtocol, bool checkCertificateRevocation, RemoteCertificateValidationCallback remoteCertValidationCallback);
    private static SSLOptions();
    public RemoteCertificateValidationCallback get_RemoteCertValidationCallback();
    public SslProtocols get_SslProtocol();
    public bool get_CheckCertificateRevocation();
    public Func`2<IPAddress, string> get_HostNameResolver();
    public X509CertificateCollection get_CertificateCollection();
    public SSLOptions SetCertificateCollection(X509CertificateCollection certificates);
    public SSLOptions SetHostNameResolver(Func`2<IPAddress, string> resolver);
    public SSLOptions SetCertificateRevocationCheck(bool flag);
    public SSLOptions SetRemoteCertValidationCallback(RemoteCertificateValidationCallback callback);
    private static bool ValidateServerCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    private static string GetHostName(IPAddress address);
}
public abstract class Cassandra.Statement : object {
    protected static string ProxyExecuteKey;
    private ConsistencyLevel _serialConsistency;
    private Object[] _values;
    private bool _autoPage;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _isIdempotent;
    private Host modreq(System.Runtime.CompilerServices.IsVolatile) _host;
    private string _authorizationId;
    private IDictionary`2<string, Byte[]> _outgoingPayload;
    [CompilerGeneratedAttribute]
private bool <SkipMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTracing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReadTimeoutMillis>k__BackingField;
    [CompilerGeneratedAttribute]
private IRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PagingState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    public Object[] QueryValues { get; }
    public bool SkipMetadata { get; private set; }
    public Nullable`1<ConsistencyLevel> ConsistencyLevel { get; private set; }
    public ConsistencyLevel SerialConsistencyLevel { get; }
    public int PageSize { get; private set; }
    public bool IsTracing { get; private set; }
    public int ReadTimeoutMillis { get; private set; }
    public IRetryPolicy RetryPolicy { get; private set; }
    public Byte[] PagingState { get; private set; }
    public Nullable`1<DateTimeOffset> Timestamp { get; private set; }
    public bool AutoPage { get; }
    public IDictionary`2<string, Byte[]> OutgoingPayload { get; private set; }
    public RoutingKey RoutingKey { get; }
    public Nullable`1<bool> IsIdempotent { get; }
    public string Keyspace { get; }
    public Host Host { get; }
    protected Statement(QueryProtocolOptions queryProtocolOptions);
    public virtual Object[] get_QueryValues();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipMetadata();
    [CompilerGeneratedAttribute]
private void set_SkipMetadata(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ConsistencyLevel> get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
private void set_ConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    public sealed virtual ConsistencyLevel get_SerialConsistencyLevel();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PageSize();
    [CompilerGeneratedAttribute]
private void set_PageSize(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTracing();
    [CompilerGeneratedAttribute]
private void set_IsTracing(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ReadTimeoutMillis();
    [CompilerGeneratedAttribute]
private void set_ReadTimeoutMillis(int value);
    [CompilerGeneratedAttribute]
public sealed virtual IRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
private void set_RetryPolicy(IRetryPolicy value);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_PagingState();
    [CompilerGeneratedAttribute]
private void set_PagingState(Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(Nullable`1<DateTimeOffset> value);
    public sealed virtual bool get_AutoPage();
    public sealed virtual IDictionary`2<string, Byte[]> get_OutgoingPayload();
    private void set_OutgoingPayload(IDictionary`2<string, Byte[]> value);
    public abstract virtual RoutingKey get_RoutingKey();
    public sealed virtual Nullable`1<bool> get_IsIdempotent();
    public virtual string get_Keyspace();
    public Host get_Host();
    public sealed virtual IStatement ExecutingAs(string userOrRole);
    private void RebuildOutgoingPayload(IDictionary`2<string, Byte[]> payload);
    internal Statement SetSkipMetadata(bool val);
    internal virtual void SetValues(Object[] values, ISerializer serializer);
    public sealed virtual IStatement SetAutoPage(bool autoPage);
    public sealed virtual IStatement SetPagingState(Byte[] pagingState);
    public sealed virtual IStatement SetReadTimeoutMillis(int timeout);
    public sealed virtual IStatement SetConsistencyLevel(Nullable`1<ConsistencyLevel> consistency);
    public sealed virtual IStatement SetSerialConsistencyLevel(ConsistencyLevel serialConsistency);
    public sealed virtual IStatement SetTimestamp(DateTimeOffset value);
    public sealed virtual IStatement EnableTracing(bool enable);
    public sealed virtual IStatement DisableTracing();
    public sealed virtual IStatement SetRetryPolicy(IRetryPolicy policy);
    internal virtual IQueryRequest CreateBatchRequest(ISerializer serializer);
    public sealed virtual IStatement SetIdempotence(bool value);
    public sealed virtual IStatement SetPageSize(int pageSize);
    public sealed virtual IStatement SetOutgoingPayload(IDictionary`2<string, Byte[]> payload);
    public IStatement SetHost(Host host);
}
internal class Cassandra.StatusChangeEventArgs : CassandraEventArgs {
    public IPEndPoint Address;
    public Reason What;
}
public class Cassandra.SyntaxError : QueryValidationException {
    public SyntaxError(string message);
}
public class Cassandra.TableColumn : CqlColumn {
    [CompilerGeneratedAttribute]
private KeyType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecondaryIndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecondaryIndexType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <SecondaryIndexOptions>k__BackingField;
    public KeyType KeyType { get; public set; }
    [ObsoleteAttribute("The driver provides a new secondary index metadata API, IndexMetadata, that is returned as part of the TableMetadata.")]
public string SecondaryIndexName { get; public set; }
    [ObsoleteAttribute("The driver provides a new secondary index metadata API, IndexMetadata, that is returned as part of the TableMetadata.")]
public string SecondaryIndexType { get; public set; }
    [ObsoleteAttribute("The driver provides a new secondary index metadata API, IndexMetadata, that is returned as part of the TableMetadata.")]
public IDictionary`2<string, string> SecondaryIndexOptions { get; public set; }
    [CompilerGeneratedAttribute]
public KeyType get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(KeyType value);
    [CompilerGeneratedAttribute]
public string get_SecondaryIndexName();
    [CompilerGeneratedAttribute]
public void set_SecondaryIndexName(string value);
    [CompilerGeneratedAttribute]
public string get_SecondaryIndexType();
    [CompilerGeneratedAttribute]
public void set_SecondaryIndexType(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_SecondaryIndexOptions();
    [CompilerGeneratedAttribute]
public void set_SecondaryIndexOptions(IDictionary`2<string, string> value);
}
public class Cassandra.TableMetadata : DataCollectionMetadata {
    private static IDictionary`2<string, IndexMetadata> EmptyIndexes;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IndexMetadata> <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    public IDictionary`2<string, IndexMetadata> Indexes { get; protected set; }
    public bool IsVirtual { get; protected set; }
    internal TableMetadata(string name, IDictionary`2<string, IndexMetadata> indexes, bool isVirtual);
    private static TableMetadata();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IndexMetadata> get_Indexes();
    [CompilerGeneratedAttribute]
protected void set_Indexes(IDictionary`2<string, IndexMetadata> value);
    [CompilerGeneratedAttribute]
public bool get_IsVirtual();
    [CompilerGeneratedAttribute]
protected void set_IsVirtual(bool value);
}
public class Cassandra.TableOptions : object {
    private static string BF_FP_CHANCE;
    private static string CACHING;
    private static string COMMENT;
    private static string COMPACTION_OPTIONS;
    private static string COMPRESSION_PARAMS;
    private static string GC_GRACE;
    private static string LOCAL_READ_REPAIR;
    private static string READ_REPAIR;
    private static string REPLICATE_ON_WRITE;
    internal double bfFpChance;
    internal string caching;
    internal string comment;
    internal SortedDictionary`2<string, string> compactionOptions;
    internal SortedDictionary`2<string, string> compressionParams;
    internal int gcGrace;
    internal bool isCompactStorage;
    internal double localReadRepair;
    internal double readRepair;
    internal bool replicateOnWrite;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <NodeSync>k__BackingField;
    public bool IsCompactStorage { get; }
    public string Comment { get; }
    public double ReadRepairChance { get; }
    public double LocalReadRepairChance { get; }
    public bool ReplicateOnWrite { get; }
    public int GcGraceSeconds { get; }
    public double BloomFilterFpChance { get; }
    public string Caching { get; }
    public SortedDictionary`2<string, string> CompactionOptions { get; }
    public SortedDictionary`2<string, string> CompressionParams { get; }
    public IDictionary`2<string, string> NodeSync { get; internal set; }
    public TableOptions(string comment, double readRepair, double localReadRepair, bool replicateOnWrite, int gcGrace, double bfFpChance, string caching, SortedDictionary`2<string, string> compactionOptions, SortedDictionary`2<string, string> compressionParams);
    public bool get_IsCompactStorage();
    public string get_Comment();
    public double get_ReadRepairChance();
    public double get_LocalReadRepairChance();
    public bool get_ReplicateOnWrite();
    public int get_GcGraceSeconds();
    public double get_BloomFilterFpChance();
    public string get_Caching();
    public SortedDictionary`2<string, string> get_CompactionOptions();
    public SortedDictionary`2<string, string> get_CompressionParams();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_NodeSync();
    [CompilerGeneratedAttribute]
internal void set_NodeSync(IDictionary`2<string, string> value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Cassandra.TargettedSimpleStatement : SimpleStatement {
    [CompilerGeneratedAttribute]
private Host <PreferredHost>k__BackingField;
    public Host PreferredHost { get; public set; }
    public TargettedSimpleStatement(string query, Object[] values);
    public TargettedSimpleStatement(string query);
    [CompilerGeneratedAttribute]
public Host get_PreferredHost();
    [CompilerGeneratedAttribute]
public void set_PreferredHost(Host value);
}
internal class Cassandra.Tasks.HashedWheelTimer : object {
    private static int InitState;
    private static int StartedState;
    private static int DisposedState;
    private int _state;
    private Bucket[] _wheel;
    private Timer _timer;
    private int _tickDuration;
    private ConcurrentQueue`1<Tuple`2<TimeoutItem, long>> _pendingToAdd;
    private ConcurrentQueue`1<TimeoutItem> _cancelledTimeouts;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) Index;
    public HashedWheelTimer(int tickDuration, int ticksPerWheel);
    private void TimerTick(object state);
    private void SetTimer();
    public void Start();
    public sealed virtual void Dispose();
    public ITimeout NewTimeout(Action`1<object> action, object state, long delay);
    private void AddPending();
    private void AddTimeout(TimeoutItem item, long delay);
    private void RemoveCancelled();
}
[ExtensionAttribute]
internal static class Cassandra.Tasks.TaskHelper : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <Completed>k__BackingField;
    public static Task`1<bool> Completed { get; }
    private static TaskHelper();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_Completed();
    [ExtensionAttribute]
public static Task`1<TResult> ToApm(Task`1<TResult> task, AsyncCallback callback, object state);
    public static Task`1<TResult> FromException(Exception exception);
    public static T WaitToComplete(Task`1<T> task, int timeout);
    public static void WaitToCompleteWithMetrics(IMetricsManager manager, Task task, int timeout);
    public static T WaitToCompleteWithMetrics(IMetricsManager manager, Task`1<T> task, int timeout);
    public static void WaitToComplete(Task task, int timeout);
    [AsyncStateMachineAttribute("Cassandra.Tasks.TaskHelper/<WaitToCompleteAsync>d__10")]
[ExtensionAttribute]
public static Task WaitToCompleteAsync(Task task, int timeout);
    [ExtensionAttribute]
public static void TrySet(TaskCompletionSource`1<T> tcs, Exception ex, T result);
    [ExtensionAttribute]
public static Task TrySetRequestErrorAsync(TaskCompletionSource`1<T> tcs, IRequestError error, T result);
    [ExtensionAttribute]
public static Task`1<TOut> ContinueSync(Task`1<TIn> task, Func`2<TIn, TOut> next);
    private static void DoNextAndHandle(TaskCompletionSource`1<TOut> tcs, Task`1<TIn> previousTask, Func`2<TIn, TOut> next);
    [ExtensionAttribute]
public static Task`1<TOut> Then(Task`1<TIn> task, Func`2<TIn, Task`1<TOut>> next);
    [ExtensionAttribute]
public static bool HasFinished(Task task);
    private static void DoNextThen(TaskCompletionSource`1<TOut> tcs, Task`1<TIn> previousTask, Func`2<TIn, Task`1<TOut>> next, TaskContinuationOptions options);
    private static void SetInnerException(TaskCompletionSource`1<T> tcs, AggregateException ex);
    public static Task`1<T> ToTask(T value);
    public static TaskCompletionSource`1<T> TaskCompletionSourceWithTimeout(int milliseconds, Func`1<Exception> newTimeoutException);
    public static Task`1<TOut> ScheduleExecution(Func`1<TOut> method, HashedWheelTimer timer, int delay);
    [ExtensionAttribute]
public static void Forget(Task task);
    [AsyncStateMachineAttribute("Cassandra.Tasks.TaskHelper/<WithCancellation>d__23`1")]
[ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    public static CancellationToken CancelTokenAfterDelay(TimeSpan timespan);
    [AsyncStateMachineAttribute("Cassandra.Tasks.TaskHelper/<DelayWithCancellation>d__25")]
public static Task`1<bool> DelayWithCancellation(TimeSpan delayTimeSpan, CancellationToken token);
    public static Func`1<Task> ActionToAsync(Action act);
}
public class Cassandra.TimeUuid : ValueType {
    private static DateTimeOffset GregorianCalendarTime;
    private static Random RandomGenerator;
    private static object RandomLock;
    private static Byte[] MinNodeId;
    private static Byte[] MinClockId;
    private static Byte[] MaxNodeId;
    private static Byte[] MaxClockId;
    private Guid _value;
    private TimeUuid(Guid value);
    private TimeUuid(Byte[] nodeId, Byte[] clockId, DateTimeOffset time);
    private static TimeUuid();
    public sealed virtual bool Equals(TimeUuid other);
    public virtual bool Equals(object obj);
    public DateTimeOffset GetDate();
    public virtual int GetHashCode();
    public Byte[] ToByteArray();
    public Guid ToGuid();
    public sealed virtual int CompareTo(TimeUuid other);
    public virtual string ToString();
    public string ToString(string format, IFormatProvider provider);
    public string ToString(string format);
    public static TimeUuid Min(DateTimeOffset date);
    public static TimeUuid Max(DateTimeOffset date);
    public static TimeUuid NewId();
    public static TimeUuid NewId(DateTimeOffset date);
    public static TimeUuid NewId(Byte[] nodeId, Byte[] clockId, DateTimeOffset date);
    public static TimeUuid Parse(string input);
    public static Guid op_Implicit(TimeUuid value);
    public static TimeUuid op_Implicit(Guid value);
    public static bool op_Equality(TimeUuid id1, TimeUuid id2);
    public static bool op_Inequality(TimeUuid id1, TimeUuid id2);
}
public class Cassandra.TokenAwarePolicy : object {
    private ICluster _cluster;
    private ThreadLocal`1<Random> _prng;
    [CompilerGeneratedAttribute]
private ILoadBalancingPolicy <ChildPolicy>k__BackingField;
    public ILoadBalancingPolicy ChildPolicy { get; }
    public TokenAwarePolicy(ILoadBalancingPolicy childPolicy);
    [CompilerGeneratedAttribute]
public ILoadBalancingPolicy get_ChildPolicy();
    public sealed virtual void Initialize(ICluster cluster);
    public sealed virtual HostDistance Distance(Host host);
    [IteratorStateMachineAttribute("Cassandra.TokenAwarePolicy/<NewQueryPlan>d__8")]
public sealed virtual IEnumerable`1<Host> NewQueryPlan(string loggedKeyspace, IStatement query);
    [CompilerGeneratedAttribute]
private bool <NewQueryPlan>b__8_0(Host h);
}
internal abstract class Cassandra.TokenFactory : object {
    public static TokenFactory GetFactory(string partitionerName);
    public abstract virtual IToken Parse(string tokenStr);
    public abstract virtual IToken Hash(Byte[] partitionKey);
}
internal class Cassandra.TokenMap : object {
    internal TokenFactory Factory;
    private List`1<IToken> _ring;
    private IReadOnlyDictionary`2<IToken, Host> _primaryReplicas;
    private IReadOnlyDictionary`2<string, DatacenterInfo> _datacenters;
    private int _numberOfHostsWithTokens;
    private ConcurrentDictionary`2<string, IReadOnlyDictionary`2<IToken, ISet`1<Host>>> _tokenToHostsByKeyspace;
    private ConcurrentDictionary`2<IReplicationStrategy, IReadOnlyDictionary`2<IToken, ISet`1<Host>>> _keyspaceTokensCache;
    private static Logger Logger;
    internal TokenMap(TokenFactory factory, IReadOnlyDictionary`2<string, IReadOnlyDictionary`2<IToken, ISet`1<Host>>> tokenToHostsByKeyspace, List`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, IReadOnlyDictionary`2<IReplicationStrategy, IReadOnlyDictionary`2<IToken, ISet`1<Host>>> keyspaceTokensCache, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters, int numberOfHostsWithTokens);
    private static TokenMap();
    public sealed virtual IReadOnlyDictionary`2<IToken, ISet`1<Host>> GetByKeyspace(string keyspaceName);
    public void UpdateKeyspace(KeyspaceMetadata ks);
    public ICollection`1<Host> GetReplicas(string keyspaceName, IToken token);
    public static TokenMap Build(string partitioner, ICollection`1<Host> hosts, ICollection`1<KeyspaceMetadata> keyspaces);
    private static void UpdateKeyspace(KeyspaceMetadata ks, IDictionary`2<string, IReadOnlyDictionary`2<IToken, ISet`1<Host>>> tokenToHostsByKeyspace, IReadOnlyList`1<IToken> ring, IReadOnlyDictionary`2<IToken, Host> primaryReplicas, IDictionary`2<IReplicationStrategy, IReadOnlyDictionary`2<IToken, ISet`1<Host>>> keyspaceTokensCache, IReadOnlyDictionary`2<string, DatacenterInfo> datacenters, int numberOfHostsWithTokens);
    public void RemoveKeyspace(string name);
}
public class Cassandra.ToManyConnectionsPerHost : DriverException {
}
internal class Cassandra.TopologyChangeEventArgs : CassandraEventArgs {
    public IPEndPoint Address;
    public Reason What;
}
public class Cassandra.TraceRetrievalException : DriverException {
    public TraceRetrievalException(string message);
    public TraceRetrievalException(string message, Exception cause);
}
public class Cassandra.TruncateException : QueryExecutionException {
    public TruncateException(string message);
}
public class Cassandra.TupleColumnInfo : object {
    [CompilerGeneratedAttribute]
private List`1<ColumnDesc> <Elements>k__BackingField;
    public List`1<ColumnDesc> Elements { get; public set; }
    internal TupleColumnInfo(IEnumerable`1<ColumnDesc> elements);
    [CompilerGeneratedAttribute]
public List`1<ColumnDesc> get_Elements();
    [CompilerGeneratedAttribute]
public void set_Elements(List`1<ColumnDesc> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public static class Cassandra.TypeAdapters : object {
    public static ITypeAdapter DecimalTypeAdapter;
    public static ITypeAdapter VarIntTypeAdapter;
    public static ITypeAdapter CustomTypeAdapter;
    private static TypeAdapters();
}
public class Cassandra.UdtColumnInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ColumnDesc> <Fields>k__BackingField;
    public string Name { get; private set; }
    public List`1<ColumnDesc> Fields { get; private set; }
    public UdtColumnInfo(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<ColumnDesc> get_Fields();
    [CompilerGeneratedAttribute]
private void set_Fields(List`1<ColumnDesc> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class Cassandra.UdtMap : object {
    protected Dictionary`2<string, PropertyInfo> _fieldNameToProperty;
    protected Dictionary`2<PropertyInfo, string> _propertyToFieldName;
    private ISerializer _serializer;
    internal static TypeConverter TypeConverter;
    public static BindingFlags PropertyFlags;
    [CompilerGeneratedAttribute]
private Type <NetType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UdtName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private UdtColumnInfo <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keyspace>k__BackingField;
    protected internal Type NetType { get; protected set; }
    protected internal string UdtName { get; protected set; }
    protected internal bool IgnoreCase { get; protected internal set; }
    protected internal UdtColumnInfo Definition { get; protected set; }
    protected internal string Keyspace { get; }
    protected UdtMap(Type netType, string udtName);
    protected UdtMap(Type netType, string udtName, string keyspace);
    private static UdtMap();
    [CompilerGeneratedAttribute]
protected internal Type get_NetType();
    [CompilerGeneratedAttribute]
protected void set_NetType(Type value);
    [CompilerGeneratedAttribute]
protected internal string get_UdtName();
    [CompilerGeneratedAttribute]
protected void set_UdtName(string value);
    [CompilerGeneratedAttribute]
protected internal bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
protected internal void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
protected internal UdtColumnInfo get_Definition();
    [CompilerGeneratedAttribute]
protected void set_Definition(UdtColumnInfo value);
    [CompilerGeneratedAttribute]
protected internal string get_Keyspace();
    internal void SetSerializer(ISerializer serializer);
    public void AddPropertyMapping(PropertyInfo propInfo, string udtFieldName);
    protected virtual void Automap();
    protected internal virtual void Build(UdtColumnInfo definition);
    private void Validate();
    protected virtual object CreateInstance();
    protected internal string GetUdtFieldName(PropertyInfo property);
    protected internal PropertyInfo GetPropertyForUdtField(string udtFieldName);
    public static UdtMap`1<T> For(string udtName, string keyspace);
    internal object ToObject(Object[] values);
}
public class Cassandra.UdtMap`1 : UdtMap {
    private static string NotPropertyMessage;
    internal UdtMap`1(string udtName, string keyspace);
    public virtual UdtMap`1<T> Automap();
    public virtual UdtMap`1<T> Map(Expression`1<Func`2<T, TProperty>> propertyExpression, string udtFieldName);
    public virtual UdtMap`1<T> SetIgnoreCase(bool value);
}
public class Cassandra.UdtMappingDefinitions : object {
    private ConcurrentDictionary`2<Type, UdtMap> _udtByNetType;
    private IInternalCluster _cluster;
    private IInternalSession _session;
    private ISerializerManager _serializer;
    internal UdtMappingDefinitions(IInternalSession session, ISerializerManager serializer);
    public void Define(UdtMap[] udtMaps);
    [AsyncStateMachineAttribute("Cassandra.UdtMappingDefinitions/<DefineAsync>d__6")]
public Task DefineAsync(UdtMap[] udtMaps);
    [AsyncStateMachineAttribute("Cassandra.UdtMappingDefinitions/<GetDefinitionAsync>d__7")]
private Task`1<UdtColumnInfo> GetDefinitionAsync(string keyspace, UdtMap map);
    internal UdtMap GetUdtMap(string keyspace);
    internal UdtMap GetUdtMap(string keyspace, Type netType);
}
public class Cassandra.UnauthorizedException : QueryValidationException {
    public UnauthorizedException(string message);
}
public class Cassandra.UnavailableException : QueryExecutionException {
    [CompilerGeneratedAttribute]
private ConsistencyLevel <Consistency>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequiredReplicas>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AliveReplicas>k__BackingField;
    public ConsistencyLevel Consistency { get; private set; }
    public int RequiredReplicas { get; private set; }
    public int AliveReplicas { get; private set; }
    public UnavailableException(ConsistencyLevel consistency, int required, int alive);
    [CompilerGeneratedAttribute]
public ConsistencyLevel get_Consistency();
    [CompilerGeneratedAttribute]
private void set_Consistency(ConsistencyLevel value);
    [CompilerGeneratedAttribute]
public int get_RequiredReplicas();
    [CompilerGeneratedAttribute]
private void set_RequiredReplicas(int value);
    [CompilerGeneratedAttribute]
public int get_AliveReplicas();
    [CompilerGeneratedAttribute]
private void set_AliveReplicas(int value);
}
public class Cassandra.Unset : object {
    public static Unset Value;
    private static Unset();
}
internal class Cassandra.UnsupportedProtocolVersionException : DriverException {
    [CompilerGeneratedAttribute]
private ProtocolVersion <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ProtocolVersion <ResponseProtocolVersion>k__BackingField;
    public ProtocolVersion ProtocolVersion { get; }
    public ProtocolVersion ResponseProtocolVersion { get; }
    public UnsupportedProtocolVersionException(ProtocolVersion protocolVersion, ProtocolVersion responseProtocolVersion, Exception innerException);
    [CompilerGeneratedAttribute]
public ProtocolVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public ProtocolVersion get_ResponseProtocolVersion();
}
[ExtensionAttribute]
internal static class Cassandra.Utils : object {
    public static string ConvertToCqlMap(IDictionary`2<string, string> source);
    public static IDictionary`2<string, string> ConvertStringToMap(string source);
    public static IDictionary`2<string, int> ConvertStringToMapInt(string source);
    public static string GetPrimaryHostNameInfo(string address);
    public static bool CompareIDictionary(IDictionary`2<TKey, TValue> dict1, IDictionary`2<TKey, TValue> dict2);
    public static Byte[] JoinBuffers(Byte[] buffer1, int offset1, int count1, Byte[] buffer2, int offset2, int count2);
    public static Byte[] JoinBuffers(IEnumerable`1<Byte[]> buffers, int totalLength);
    public static Byte[] SliceBuffer(Byte[] value, int startIndex, int count);
    public static Byte[] FromOffset(Byte[] value, int offset, int count);
    public static Byte[] CopyBuffer(Byte[] buffer);
    public static Byte[] ReadAllBytes(Stream stream, int position);
    public static Byte[] ReadAllBytes(IEnumerable`1<Stream> streamList, long totalLength);
    public static void CopyStream(Stream input, Stream output, int length, Byte[] buffer);
    public static bool IsAnonymousType(object value);
    public static bool IsAnonymousType(Type type);
    public static IEnumerable`1<object> GetValues(IEnumerable`1<string> propNames, object value);
    public static IDictionary`2<string, object> GetValues(object value);
    internal static int CombineHashCode(IEnumerable`1<T> items);
    internal static int CombineHashCodeWithNulls(IEnumerable`1<T> items);
    internal static int CombineHashCodeWithNulls(Object[] items);
    [ExtensionAttribute]
public static bool IsSerialConsistencyLevel(ConsistencyLevel consistency);
    public static object ToCollectionType(Type collectionType, Type valueType, Array value);
    public static object ToVectorType(Type valueType, Array value);
    public static bool IsIEnumerable(Type t, Type& childType);
    public static bool IsIDictionary(Type t, Type& keyType, Type& valueType);
    public static bool IsTuple(Type type);
    public static string FillZeros(int value, int length);
    public static String[] ParseJsonStringArray(string value);
    internal static IDictionary`2<string, string> ParseJsonStringMap(string jsonValue);
}
public class Cassandra.VectorColumnInfo : object {
    [CompilerGeneratedAttribute]
private ColumnTypeCode <ValueTypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IColumnInfo <ValueTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Dimensions>k__BackingField;
    public ColumnTypeCode ValueTypeCode { get; public set; }
    public IColumnInfo ValueTypeInfo { get; public set; }
    public Nullable`1<int> Dimensions { get; public set; }
    [CompilerGeneratedAttribute]
public ColumnTypeCode get_ValueTypeCode();
    [CompilerGeneratedAttribute]
public void set_ValueTypeCode(ColumnTypeCode value);
    [CompilerGeneratedAttribute]
public IColumnInfo get_ValueTypeInfo();
    [CompilerGeneratedAttribute]
public void set_ValueTypeInfo(IColumnInfo value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Dimensions();
    [CompilerGeneratedAttribute]
public void set_Dimensions(Nullable`1<int> value);
    private sealed virtual override ColumnDesc Cassandra.ICollectionColumnInfo.GetChildType();
}
public class Cassandra.WriteFailureException : QueryExecutionException {
    private static IDictionary`2<IPAddress, int> DefaultReasons;
    private static string FailureMessage;
    [CompilerGeneratedAttribute]
private string <WriteType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsistencyLevel <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceivedAcknowledgements>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequiredAcknowledgements>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Failures>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<IPAddress, int> <Reasons>k__BackingField;
    public string WriteType { get; }
    public ConsistencyLevel ConsistencyLevel { get; private set; }
    public int ReceivedAcknowledgements { get; private set; }
    public int RequiredAcknowledgements { get; private set; }
    public int Failures { get; private set; }
    public IDictionary`2<IPAddress, int> Reasons { get; }
    public WriteFailureException(ConsistencyLevel consistency, int received, int required, string writeType, int failures);
    public WriteFailureException(ConsistencyLevel consistency, int received, int required, string writeType, IDictionary`2<IPAddress, int> reasons);
    private static WriteFailureException();
    [CompilerGeneratedAttribute]
public string get_WriteType();
    [CompilerGeneratedAttribute]
public ConsistencyLevel get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
private void set_ConsistencyLevel(ConsistencyLevel value);
    [CompilerGeneratedAttribute]
public int get_ReceivedAcknowledgements();
    [CompilerGeneratedAttribute]
private void set_ReceivedAcknowledgements(int value);
    [CompilerGeneratedAttribute]
public int get_RequiredAcknowledgements();
    [CompilerGeneratedAttribute]
private void set_RequiredAcknowledgements(int value);
    [CompilerGeneratedAttribute]
public int get_Failures();
    [CompilerGeneratedAttribute]
private void set_Failures(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<IPAddress, int> get_Reasons();
}
public class Cassandra.WriteTimeoutException : QueryTimeoutException {
    private static string BatchLogMessage;
    private static string QueryMessage;
    private static string BatchLogWriteType;
    [CompilerGeneratedAttribute]
private string <WriteType>k__BackingField;
    public string WriteType { get; }
    public WriteTimeoutException(ConsistencyLevel consistency, int received, int required, string writeType);
    [CompilerGeneratedAttribute]
public string get_WriteType();
    private static string GetMessage(string writeType, ConsistencyLevel consistency, int received, int required);
}
internal class Microsoft.IO.RecyclableMemoryStream : MemoryStream {
    private static long MaxStreamLength;
    private List`1<Byte[]> blocks;
    private Byte[] largeBuffer;
    private List`1<Byte[]> dirtyBuffers;
    private Guid id;
    private string tag;
    private RecyclableMemoryStreamManager memoryManager;
    private bool disposed;
    private string allocationStack;
    private string disposeStack;
    private Byte[] byteBuffer;
    private int length;
    private int position;
    internal Guid Id { get; }
    internal string Tag { get; }
    internal RecyclableMemoryStreamManager MemoryManager { get; }
    internal string AllocationStack { get; }
    internal string DisposeStack { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager);
    public RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager, string tag);
    public RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager, string tag, int requestedSize);
    internal RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager, string tag, int requestedSize, Byte[] initialLargeBuffer);
    internal Guid get_Id();
    internal string get_Tag();
    internal RecyclableMemoryStreamManager get_MemoryManager();
    internal string get_AllocationStack();
    internal string get_DisposeStack();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual Byte[] GetBuffer();
    public virtual Byte[] ToArray();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual string ToString();
    public virtual void WriteByte(byte value);
    public virtual int ReadByte();
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void WriteTo(Stream stream);
    private void CheckDisposed();
    private int InternalRead(Byte[] buffer, int offset, int count, int fromPosition);
    private BlockAndOffset GetBlockAndRelativeOffset(int offset);
    private void EnsureCapacity(int newCapacity);
    private void ReleaseLargeBuffer();
    public IList`1<ArraySegment`1<byte>> GetBufferList();
}
internal class Microsoft.IO.RecyclableMemoryStreamManager : object {
    public static int DefaultBlockSize;
    public static int DefaultLargeBufferMultiple;
    public static int DefaultMaximumBufferSize;
    private int blockSize;
    private Int64[] largeBufferFreeSize;
    private Int64[] largeBufferInUseSize;
    private int largeBufferMultiple;
    private ConcurrentStack`1[] largePools;
    private int maximumBufferSize;
    private ConcurrentStack`1<Byte[]> smallPool;
    private long smallPoolFreeSize;
    private long smallPoolInUseSize;
    [CompilerGeneratedAttribute]
private long <MaximumFreeSmallPoolBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaximumFreeLargePoolBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaximumStreamCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateCallStacks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AggressiveBufferReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler BlockCreated;
    [CompilerGeneratedAttribute]
private EventHandler BlockDiscarded;
    [CompilerGeneratedAttribute]
private EventHandler LargeBufferCreated;
    [CompilerGeneratedAttribute]
private EventHandler StreamCreated;
    [CompilerGeneratedAttribute]
private EventHandler StreamDisposed;
    [CompilerGeneratedAttribute]
private EventHandler StreamFinalized;
    [CompilerGeneratedAttribute]
private StreamLengthReportHandler StreamLength;
    [CompilerGeneratedAttribute]
private EventHandler StreamConvertedToArray;
    [CompilerGeneratedAttribute]
private UsageReportEventHandler UsageReport;
    public int BlockSize { get; }
    public int LargeBufferMultiple { get; }
    public int MaximumBufferSize { get; }
    public long SmallPoolFreeSize { get; }
    public long SmallPoolInUseSize { get; }
    public long LargePoolFreeSize { get; }
    public long LargePoolInUseSize { get; }
    public long SmallBlocksFree { get; }
    public long LargeBuffersFree { get; }
    public long MaximumFreeSmallPoolBytes { get; public set; }
    public long MaximumFreeLargePoolBytes { get; public set; }
    public long MaximumStreamCapacity { get; public set; }
    public bool GenerateCallStacks { get; public set; }
    public bool AggressiveBufferReturn { get; public set; }
    public RecyclableMemoryStreamManager(int blockSize, int largeBufferMultiple, int maximumBufferSize);
    public int get_BlockSize();
    public int get_LargeBufferMultiple();
    public int get_MaximumBufferSize();
    public long get_SmallPoolFreeSize();
    public long get_SmallPoolInUseSize();
    public long get_LargePoolFreeSize();
    public long get_LargePoolInUseSize();
    public long get_SmallBlocksFree();
    public long get_LargeBuffersFree();
    [CompilerGeneratedAttribute]
public long get_MaximumFreeSmallPoolBytes();
    [CompilerGeneratedAttribute]
public void set_MaximumFreeSmallPoolBytes(long value);
    [CompilerGeneratedAttribute]
public long get_MaximumFreeLargePoolBytes();
    [CompilerGeneratedAttribute]
public void set_MaximumFreeLargePoolBytes(long value);
    [CompilerGeneratedAttribute]
public long get_MaximumStreamCapacity();
    [CompilerGeneratedAttribute]
public void set_MaximumStreamCapacity(long value);
    [CompilerGeneratedAttribute]
public bool get_GenerateCallStacks();
    [CompilerGeneratedAttribute]
public void set_GenerateCallStacks(bool value);
    [CompilerGeneratedAttribute]
public bool get_AggressiveBufferReturn();
    [CompilerGeneratedAttribute]
public void set_AggressiveBufferReturn(bool value);
    internal Byte[] GetBlock();
    internal Byte[] GetLargeBuffer(int requiredSize, string tag);
    private int RoundToLargeBufferMultiple(int requiredSize);
    private bool IsLargeBufferMultiple(int value);
    internal void ReturnLargeBuffer(Byte[] buffer, string tag);
    internal void ReturnBlocks(ICollection`1<Byte[]> blocks, string tag);
    internal void ReportStreamCreated();
    internal void ReportStreamDisposed();
    internal void ReportStreamFinalized();
    internal void ReportStreamLength(long bytes);
    internal void ReportStreamToArray();
    public MemoryStream GetStream();
    public MemoryStream GetStream(string tag);
    public MemoryStream GetStream(string tag, int requiredSize);
    public MemoryStream GetStream(string tag, int requiredSize, bool asContiguousBuffer);
    public MemoryStream GetStream(string tag, Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
public void add_BlockCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BlockCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_BlockDiscarded(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BlockDiscarded(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_LargeBufferCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LargeBufferCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamDisposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamDisposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamFinalized(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamFinalized(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamLength(StreamLengthReportHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamLength(StreamLengthReportHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamConvertedToArray(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamConvertedToArray(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_UsageReport(UsageReportEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UsageReport(UsageReportEventHandler value);
}
internal class Snappy.CorruptionException : Exception {
    public CorruptionException(string message);
}
internal interface Snappy.IMemory {
    public abstract virtual bool FastAccessSupported();
    public abstract virtual int LookupShort(Int16[] data, int index);
    public abstract virtual int LoadByte(Byte[] data, int index);
    public abstract virtual int LoadInt(Byte[] data, int index);
    public abstract virtual void CopyLong(Byte[] src, int srcIndex, Byte[] dest, int destIndex);
    public abstract virtual long LoadLong(Byte[] data, int index);
    public abstract virtual void CopyMemory(Byte[] input, int inputIndex, Byte[] output, int outputIndex, int length);
}
internal class Snappy.SlowMemory : object {
    public sealed virtual bool FastAccessSupported();
    public sealed virtual int LookupShort(Int16[] data, int index);
    public sealed virtual int LoadByte(Byte[] data, int index);
    public sealed virtual int LoadInt(Byte[] data, int index);
    public sealed virtual void CopyLong(Byte[] src, int srcIndex, Byte[] dest, int destIndex);
    public sealed virtual long LoadLong(Byte[] data, int index);
    public sealed virtual void CopyMemory(Byte[] input, int inputIndex, Byte[] output, int outputIndex, int length);
}
internal class Snappy.SnappyDecompressor : object {
    private static int Literal;
    private static int MaxIncrementCopyOverflow;
    private static Int32[] _wordmask;
    private static Int16[] _opLookupTable;
    private static SnappyDecompressor();
    public static int GetUncompressedLength(Byte[] compressed, int compressedOffset);
    public static Byte[] Uncompress(Byte[] compressed, int compressedOffset, int compressedSize);
    public static int Uncompress(Byte[] compressed, int compressedOffset, int compressedSize, Byte[] uncompressed, int uncompressedOffset);
    private static int DecompressAllTags(Byte[] input, int inputOffset, int inputSize, Byte[] output, int outputOffset);
    private static Int32[] DecompressTagSlow(Byte[] input, int ipIndex, Byte[] output, int outputLimit, int outputOffset, int opIndex);
    private static int ReadTrailer(Byte[] data, int index, int bytes);
    private static void CopyLiteral(Byte[] input, int ipIndex, Byte[] output, int opIndex, int length);
    private static void IncrementalCopy(Byte[] src, int srcIndex, Byte[] op, int opIndex, int length);
    private static void IncrementalCopyFastPath(Byte[] output, int srcIndex, int opIndex, int length);
    private static Int32[] ReadUncompressedLength(Byte[] compressed, int compressedOffset);
}
internal class Snappy.SnappyInternalUtils : object {
    private static IMemory _memory;
    private static SnappyInternalUtils();
    private static bool Equals(Byte[] left, int leftIndex, Byte[] right, int rightIndex, int length);
    public static int LookupShort(Int16[] data, int index);
    public static int LoadByte(Byte[] data, int index);
    public static int LoadInt(Byte[] data, int index);
    public static void CopyLong(Byte[] src, int srcIndex, Byte[] dest, int destIndex);
    public static long LoadLong(Byte[] data, int index);
    public static void CopyMemory(Byte[] input, int inputIndex, Byte[] output, int outputIndex, int length);
    public static void CheckArgument(bool expression, string errorMessageTemplate, object errorMessageArg0, object errorMessageArg1);
    private static void CheckPositionIndexes(int start, int end, int size);
    public static string BadPositionIndexes(int start, int end, int size);
    private static string BadPositionIndex(int index, int size, string desc);
}
