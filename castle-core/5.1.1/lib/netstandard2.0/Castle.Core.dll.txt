[DefaultMemberAttribute("Item")]
public abstract class Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter : object {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public abstract virtual bool Contains(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public sealed virtual ICollection get_Keys();
    public sealed virtual void Remove(object key);
    public sealed virtual ICollection get_Values();
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class Castle.Components.DictionaryAdapter.AbstractDictionaryAdapterVisitor : object {
    private Dictionary`2<IDictionaryAdapter, int> scopes;
    [CompilerGeneratedAttribute]
private bool <Cancelled>k__BackingField;
    protected bool Cancelled { get; protected set; }
    protected AbstractDictionaryAdapterVisitor(AbstractDictionaryAdapterVisitor parent);
    [CompilerGeneratedAttribute]
protected bool get_Cancelled();
    [CompilerGeneratedAttribute]
protected void set_Cancelled(bool value);
    public virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, object state);
    public virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, Func`2<PropertyDescriptor, bool> selector, object state);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor.VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    protected virtual void VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor.VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    protected virtual void VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor.VisitCollection(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, Type collectionItemType, object state);
    protected virtual void VisitCollection(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, Type collectionItemType, object state);
    private bool PushScope(IDictionaryAdapter dictionaryAdapter);
    private void PopScope(IDictionaryAdapter dictionaryAdapter);
    private static bool IsCollection(PropertyDescriptor property, Type& collectionItemType);
}
[DefaultMemberAttribute("Item")]
public class Castle.Components.DictionaryAdapter.BindingList`1 : object {
    private BindingList`1<T> list;
    public BindingList`1<T> InnerList { get; }
    public IBindingList AsBindingList { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool AllowNew { get; public set; }
    public bool AllowEdit { get; public set; }
    public bool AllowRemove { get; public set; }
    public bool RaiseListChangedEvents { get; public set; }
    private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsChangeNotification { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSearching { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSorting { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.IsSorted { get; }
    private PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.SortProperty { get; }
    private ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.SortDirection { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public BindingList`1(IList`1<T> list);
    public BindingList`1(BindingList`1<T> list);
    public BindingList`1<T> get_InnerList();
    public sealed virtual IBindingList get_AsBindingList();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool get_AllowNew();
    public void set_AllowNew(bool value);
    public sealed virtual bool get_AllowEdit();
    public void set_AllowEdit(bool value);
    public sealed virtual bool get_AllowRemove();
    public void set_AllowRemove(bool value);
    public bool get_RaiseListChangedEvents();
    public void set_RaiseListChangedEvents(bool value);
    private sealed virtual override bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsChangeNotification();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSearching();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSorting();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_IsSorted();
    private sealed virtual override PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortProperty();
    private sealed virtual override ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortDirection();
    private sealed virtual override int Castle.Components.DictionaryAdapter.IBindingList<T>.Find(PropertyDescriptor property, object key);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.AddIndex(PropertyDescriptor property);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveSort();
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T AddNew();
    public sealed virtual void CancelNew(int index);
    public sealed virtual void EndNew(int index);
    public sealed virtual void Add(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public sealed virtual void Clear();
    public void ResetBindings();
    public void ResetItem(int index);
}
public class Castle.Components.DictionaryAdapter.BindingListInitializer`1 : object {
    private Func`1<object> addNew;
    private Func`3<int, object, object> addAt;
    private Func`3<int, object, object> setAt;
    private Action`1<int> removeAt;
    private Action reset;
    private bool addingNew;
    public BindingListInitializer`1(Func`3<int, object, object> addAt, Func`1<object> addNew, Func`3<int, object, object> setAt, Action`1<int> removeAt, Action reset);
    public sealed virtual void Initialize(IDictionaryAdapter dictionaryAdapter, object value);
}
[DefaultMemberAttribute("Item")]
public class Castle.Components.DictionaryAdapter.CascadingDictionaryAdapter : AbstractDictionaryAdapter {
    private IDictionary primary;
    private IDictionary secondary;
    public IDictionary Primary { get; }
    public IDictionary Secondary { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public CascadingDictionaryAdapter(IDictionary primary, IDictionary secondary);
    public IDictionary get_Primary();
    public IDictionary get_Secondary();
    public virtual bool get_IsReadOnly();
    public virtual bool Contains(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
}
[AttributeUsageAttribute("128")]
public class Castle.Components.DictionaryAdapter.ComponentAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public bool NoPrefix { get; public set; }
    public string Prefix { get; public set; }
    public bool get_NoPrefix();
    public void set_NoPrefix(bool value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    public sealed virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
}
public class Castle.Components.DictionaryAdapter.DefaultPropertyGetter : object {
    private TypeConverter converter;
    public int ExecutionOrder { get; }
    public DefaultPropertyGetter(TypeConverter converter);
    public sealed virtual int get_ExecutionOrder();
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    public sealed virtual IDictionaryBehavior Copy();
}
[AttributeUsageAttribute("4")]
public class Castle.Components.DictionaryAdapter.DictionaryAdapterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <InterfaceType>k__BackingField;
    public Type InterfaceType { get; private set; }
    public DictionaryAdapterAttribute(Type interfaceType);
    [CompilerGeneratedAttribute]
public Type get_InterfaceType();
    [CompilerGeneratedAttribute]
private void set_InterfaceType(Type value);
}
[DefaultMemberAttribute("Item")]
public abstract class Castle.Components.DictionaryAdapter.DictionaryAdapterBase : object {
    [CompilerGeneratedAttribute]
private DictionaryAdapterInstance <This>k__BackingField;
    private int suppressEditingCount;
    private Stack`1<Dictionary`2<string, Edit>> updates;
    private HashSet`1<IEditableObject> editDependencies;
    [CompilerGeneratedAttribute]
private bool <SupportsMultiLevelEdit>k__BackingField;
    [ThreadStaticAttribute]
private static TrackPropertyChangeScope readOnlyTrackingScope;
    private int suppressNotificationCount;
    [CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private bool <CanNotify>k__BackingField;
    private ICollection`1<IDictionaryValidator> validators;
    [CompilerGeneratedAttribute]
private bool <CanValidate>k__BackingField;
    public DictionaryAdapterMeta Meta { get; }
    public DictionaryAdapterInstance This { get; private set; }
    public bool CanEdit { get; public set; }
    public bool IsEditing { get; }
    public bool SupportsMultiLevelEdit { get; public set; }
    public bool IsChanged { get; }
    public bool CanNotify { get; public set; }
    public bool ShouldNotify { get; }
    public bool CanValidate { get; public set; }
    public bool IsValid { get; }
    public string Error { get; }
    public string Item { get; }
    public IEnumerable`1<IDictionaryValidator> Validators { get; }
    public DictionaryAdapterBase(DictionaryAdapterInstance instance);
    public sealed virtual T Coerce();
    public sealed virtual object Coerce(Type type);
    public sealed virtual void CopyTo(IDictionaryAdapter other);
    public sealed virtual void CopyTo(IDictionaryAdapter other, Func`2<PropertyDescriptor, bool> selector);
    public sealed virtual T Create();
    public sealed virtual object Create(Type type);
    public sealed virtual T Create(IDictionary dictionary);
    public sealed virtual object Create(Type type, IDictionary dictionary);
    public sealed virtual T Create(Action`1<T> init);
    public sealed virtual T Create(IDictionary dictionary, Action`1<T> init);
    public abstract virtual DictionaryAdapterMeta get_Meta();
    [CompilerGeneratedAttribute]
public sealed virtual DictionaryAdapterInstance get_This();
    [CompilerGeneratedAttribute]
private void set_This(DictionaryAdapterInstance value);
    public sealed virtual string GetKey(string propertyName);
    public virtual object GetProperty(string propertyName, bool ifExists);
    public sealed virtual T GetPropertyOfType(string propertyName);
    public sealed virtual object ReadProperty(string key);
    public virtual bool SetProperty(string propertyName, Object& value);
    public sealed virtual void StoreProperty(PropertyDescriptor property, string key, object value);
    public sealed virtual void ClearProperty(PropertyDescriptor property, string key);
    public sealed virtual bool ShouldClearProperty(PropertyDescriptor property, object value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void Initialize();
    private static IDictionary GetDictionary(IDictionary dictionary, String& key);
    public sealed virtual bool get_CanEdit();
    public void set_CanEdit(bool value);
    public sealed virtual bool get_IsEditing();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SupportsMultiLevelEdit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SupportsMultiLevelEdit(bool value);
    public sealed virtual bool get_IsChanged();
    public sealed virtual void BeginEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void EndEdit();
    public sealed virtual void RejectChanges();
    public sealed virtual void AcceptChanges();
    public sealed virtual IDisposable SuppressEditingBlock();
    public sealed virtual void SuppressEditing();
    public sealed virtual void ResumeEditing();
    protected bool GetEditedProperty(string propertyName, Object& propertyValue);
    protected bool EditProperty(PropertyDescriptor property, string key, object propertyValue);
    protected bool ClearEditProperty(PropertyDescriptor property, string key);
    protected void AddEditDependency(IEditableObject editDependency);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanNotify();
    [CompilerGeneratedAttribute]
public void set_CanNotify(bool value);
    public sealed virtual bool get_ShouldNotify();
    public sealed virtual IDisposable SuppressNotificationsBlock();
    public sealed virtual void SuppressNotifications();
    public sealed virtual void ResumeNotifications();
    protected bool NotifyPropertyChanging(PropertyDescriptor property, object oldValue, object newValue);
    protected void NotifyPropertyChanged(PropertyDescriptor property, object oldValue, object newValue);
    protected void NotifyPropertyChanged(string propertyName);
    protected TrackPropertyChangeScope TrackPropertyChange(PropertyDescriptor property, object oldValue, object newValue);
    protected TrackPropertyChangeScope TrackReadonlyPropertyChanges();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanValidate();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CanValidate(bool value);
    public sealed virtual bool get_IsValid();
    public sealed virtual string get_Error();
    public sealed virtual string get_Item(string columnName);
    public sealed virtual DictionaryValidateGroup ValidateGroups(Object[] groups);
    public sealed virtual IEnumerable`1<IDictionaryValidator> get_Validators();
    public sealed virtual void AddValidator(IDictionaryValidator validator);
    protected internal void Invalidate();
    [CompilerGeneratedAttribute]
private object <get_IsChanged>b__43_2(PropertyDescriptor prop);
    [CompilerGeneratedAttribute]
private bool <get_IsValid>b__87_0(IDictionaryValidator v);
    [CompilerGeneratedAttribute]
private string <get_Error>b__89_0(IDictionaryValidator v);
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.DictionaryAdapterExtensions : object {
    [ExtensionAttribute]
public static IVirtual AsVirtual(IDictionaryAdapter dictionaryAdapter);
}
public class Castle.Components.DictionaryAdapter.DictionaryAdapterFactory : object {
    private SynchronizedDictionary`2<Type, DictionaryAdapterMeta> interfaceToMeta;
    private static PropertyInfo AdapterGetMeta;
    private static ConstructorInfo BaseCtor;
    private static Type[] ConstructorParameterTypes;
    private static MethodInfo AdapterGetProperty;
    private static MethodInfo AdapterSetProperty;
    private static HashSet`1<Type> InfrastructureTypes;
    private static DictionaryAdapterFactory();
    public sealed virtual T GetAdapter(IDictionary dictionary);
    public sealed virtual object GetAdapter(Type type, IDictionary dictionary);
    public sealed virtual object GetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);
    public T GetAdapter(IDictionary`2<string, R> dictionary);
    public object GetAdapter(Type type, IDictionary`2<string, R> dictionary);
    public sealed virtual T GetAdapter(NameValueCollection nameValues);
    public sealed virtual object GetAdapter(Type type, NameValueCollection nameValues);
    public sealed virtual T GetAdapter(XmlNode xmlNode);
    public sealed virtual object GetAdapter(Type type, XmlNode xmlNode);
    public sealed virtual DictionaryAdapterMeta GetAdapterMeta(Type type);
    public sealed virtual DictionaryAdapterMeta GetAdapterMeta(Type type, PropertyDescriptor descriptor);
    public sealed virtual DictionaryAdapterMeta GetAdapterMeta(Type type, DictionaryAdapterMeta other);
    private DictionaryAdapterMeta InternalGetAdapterMeta(Type type, PropertyDescriptor descriptor, DictionaryAdapterMeta other);
    private object InternalGetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);
    private static TypeBuilder CreateTypeBuilder(Type type);
    private static TypeBuilder CreateAdapterType(Type type, ModuleBuilder moduleBuilder);
    private DictionaryAdapterMeta CreateAdapterMeta(Type type, TypeBuilder typeBuilder, PropertyDescriptor descriptor);
    private static ConstructorInfo CreateAdapterConstructor(TypeBuilder typeBuilder);
    private static void CreateAdapterFactoryMethod(TypeBuilder typeBuilder, ConstructorInfo constructor);
    private static void CreateMetaProperty(TypeBuilder typeBuilder, PropertyInfo prop, FieldInfo field);
    private static void CreateAdapterProperty(TypeBuilder typeBuilder, PropertyDescriptor descriptor);
    private static void PreparePropertyMethod(PropertyDescriptor descriptor, ILGenerator propILGenerator);
    private static void CreatePropertyGetMethod(TypeBuilder typeBuilder, PropertyBuilder propertyBuilder, PropertyDescriptor descriptor, MethodAttributes propAttribs);
    private static void CreatePropertySetMethod(TypeBuilder typeBuilder, PropertyBuilder propertyBuilder, PropertyDescriptor descriptor, MethodAttributes propAttribs);
    private static Dictionary`2<string, PropertyDescriptor> GetPropertyDescriptors(Type type, PropertyDescriptor initializers, Object[]& typeBehaviors);
    [IteratorStateMachineAttribute("Castle.Components.DictionaryAdapter.DictionaryAdapterFactory/<ExpandBehaviors>d__31")]
private static IEnumerable`1<object> ExpandBehaviors(IEnumerable`1<object> behaviors);
    private static void CollectProperties(Type currentType, Action`2<PropertyInfo, Type> onProperty);
    private static void AddDefaultGetter(PropertyDescriptor descriptor);
}
public class Castle.Components.DictionaryAdapter.DictionaryAdapterInstance : object {
    private IDictionary extendedProperties;
    private List`1<IDictionaryCopyStrategy> copyStrategies;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OldHashCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary <Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryAdapterFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryInitializer[] <Initializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, PropertyDescriptor> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryEqualityHashCodeStrategy <EqualityHashCodeStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryCreateStrategy <CreateStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryCoerceStrategy <CoerceStrategy>k__BackingField;
    private static IDictionaryInitializer[] NoInitializers;
    internal Nullable`1<int> OldHashCode { get; internal set; }
    public IDictionary Dictionary { get; private set; }
    public PropertyDescriptor Descriptor { get; private set; }
    public IDictionaryAdapterFactory Factory { get; private set; }
    public IDictionaryInitializer[] Initializers { get; private set; }
    public IDictionary`2<string, PropertyDescriptor> Properties { get; private set; }
    public IDictionaryEqualityHashCodeStrategy EqualityHashCodeStrategy { get; public set; }
    public IDictionaryCreateStrategy CreateStrategy { get; public set; }
    public IDictionaryCoerceStrategy CoerceStrategy { get; public set; }
    public IEnumerable`1<IDictionaryCopyStrategy> CopyStrategies { get; }
    public IDictionary ExtendedProperties { get; }
    public DictionaryAdapterInstance(IDictionary dictionary, DictionaryAdapterMeta meta, PropertyDescriptor descriptor, IDictionaryAdapterFactory factory);
    private static DictionaryAdapterInstance();
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_OldHashCode();
    [CompilerGeneratedAttribute]
internal void set_OldHashCode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IDictionary get_Dictionary();
    [CompilerGeneratedAttribute]
private void set_Dictionary(IDictionary value);
    [CompilerGeneratedAttribute]
public PropertyDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
private void set_Descriptor(PropertyDescriptor value);
    [CompilerGeneratedAttribute]
public IDictionaryAdapterFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(IDictionaryAdapterFactory value);
    [CompilerGeneratedAttribute]
public IDictionaryInitializer[] get_Initializers();
    [CompilerGeneratedAttribute]
private void set_Initializers(IDictionaryInitializer[] value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, PropertyDescriptor> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, PropertyDescriptor> value);
    [CompilerGeneratedAttribute]
public IDictionaryEqualityHashCodeStrategy get_EqualityHashCodeStrategy();
    [CompilerGeneratedAttribute]
public void set_EqualityHashCodeStrategy(IDictionaryEqualityHashCodeStrategy value);
    [CompilerGeneratedAttribute]
public IDictionaryCreateStrategy get_CreateStrategy();
    [CompilerGeneratedAttribute]
public void set_CreateStrategy(IDictionaryCreateStrategy value);
    [CompilerGeneratedAttribute]
public IDictionaryCoerceStrategy get_CoerceStrategy();
    [CompilerGeneratedAttribute]
public void set_CoerceStrategy(IDictionaryCoerceStrategy value);
    public IEnumerable`1<IDictionaryCopyStrategy> get_CopyStrategies();
    public void AddCopyStrategy(IDictionaryCopyStrategy copyStrategy);
    public IDictionary get_ExtendedProperties();
    private static IDictionaryInitializer[] MergeInitializers(IDictionaryInitializer[] source, List`1<IDictionaryBehavior> behaviors);
    private static IDictionary`2<string, PropertyDescriptor> MergeProperties(IDictionary`2<string, PropertyDescriptor> source);
    private static IDictionary`2<string, PropertyDescriptor> MergeProperties(IDictionary`2<string, PropertyDescriptor> source, List`1<IDictionaryBehavior> behaviors);
}
[DebuggerDisplayAttribute("Type: {Type.FullName,nq}")]
public class Castle.Components.DictionaryAdapter.DictionaryAdapterMeta : object {
    private IDictionary extendedProperties;
    private Func`2<DictionaryAdapterInstance, IDictionaryAdapter> creator;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Implementation>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Behaviors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryAdapterFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, PropertyDescriptor> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryMetaInitializer[] <MetaInitializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryInitializer[] <Initializers>k__BackingField;
    public Type Type { get; private set; }
    public Type Implementation { get; private set; }
    public Object[] Behaviors { get; private set; }
    public IDictionaryAdapterFactory Factory { get; private set; }
    public IDictionary`2<string, PropertyDescriptor> Properties { get; private set; }
    public IDictionaryMetaInitializer[] MetaInitializers { get; private set; }
    public IDictionaryInitializer[] Initializers { get; private set; }
    public IDictionary ExtendedProperties { get; }
    public DictionaryAdapterMeta(Type type, Type implementation, Object[] behaviors, IDictionaryMetaInitializer[] metaInitializers, IDictionaryInitializer[] initializers, IDictionary`2<string, PropertyDescriptor> properties, IDictionaryAdapterFactory factory, Func`2<DictionaryAdapterInstance, IDictionaryAdapter> creator);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public Type get_Implementation();
    [CompilerGeneratedAttribute]
private void set_Implementation(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_Behaviors();
    [CompilerGeneratedAttribute]
private void set_Behaviors(Object[] value);
    [CompilerGeneratedAttribute]
public IDictionaryAdapterFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(IDictionaryAdapterFactory value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, PropertyDescriptor> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, PropertyDescriptor> value);
    [CompilerGeneratedAttribute]
public IDictionaryMetaInitializer[] get_MetaInitializers();
    [CompilerGeneratedAttribute]
private void set_MetaInitializers(IDictionaryMetaInitializer[] value);
    [CompilerGeneratedAttribute]
public IDictionaryInitializer[] get_Initializers();
    [CompilerGeneratedAttribute]
private void set_Initializers(IDictionaryInitializer[] value);
    public IDictionary get_ExtendedProperties();
    public PropertyDescriptor CreateDescriptor();
    private static List`1<T> CollectSharedBehaviors(T[] source, IDictionaryMetaInitializer[] predicates);
    public DictionaryAdapterMeta GetAdapterMeta(Type type);
    public object CreateInstance(IDictionary dictionary, PropertyDescriptor descriptor);
    private void InitializeMeta();
}
public abstract class Castle.Components.DictionaryAdapter.DictionaryBehaviorAttribute : Attribute {
    public static int FirstExecutionOrder;
    public static int DefaultExecutionOrder;
    public static int LastExecutionOrder;
    [CompilerGeneratedAttribute]
private int <ExecutionOrder>k__BackingField;
    public int ExecutionOrder { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_ExecutionOrder();
    [CompilerGeneratedAttribute]
public void set_ExecutionOrder(int value);
    public virtual IDictionaryBehavior Copy();
}
[DefaultMemberAttribute("Item")]
public class Castle.Components.DictionaryAdapter.DictionaryValidateGroup : object {
    private Object[] groups;
    private IDictionaryAdapter adapter;
    private String[] propertyNames;
    private PropertyChangedEventHandler propertyChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public bool CanValidate { get; public set; }
    public bool IsValid { get; }
    public string Error { get; }
    public string Item { get; }
    public IEnumerable`1<IDictionaryValidator> Validators { get; }
    public DictionaryValidateGroup(Object[] groups, IDictionaryAdapter adapter);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual bool get_CanValidate();
    public sealed virtual void set_CanValidate(bool value);
    public sealed virtual bool get_IsValid();
    public sealed virtual string get_Error();
    public sealed virtual string get_Item(string columnName);
    public sealed virtual DictionaryValidateGroup ValidateGroups(Object[] groups);
    public sealed virtual IEnumerable`1<IDictionaryValidator> get_Validators();
    public sealed virtual void AddValidator(IDictionaryValidator validator);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__4_2(<>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_4(object sender, PropertyChangedEventArgs args);
    [CompilerGeneratedAttribute]
private string <get_Error>b__14_0(string propertyName);
}
public class Castle.Components.DictionaryAdapter.DynamicDictionary : DynamicObject {
    private IDictionary dictionary;
    public DynamicDictionary(IDictionary dictionary);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
}
public abstract class Castle.Components.DictionaryAdapter.DynamicValue`1 : object {
    public T Value { get; }
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDynamicValue.GetValue();
    public abstract virtual T get_Value();
    public virtual string ToString();
}
public class Castle.Components.DictionaryAdapter.DynamicValueDelegate`1 : DynamicValue`1<T> {
    private Func`1<T> dynamicDelegate;
    public T Value { get; }
    public DynamicValueDelegate`1(Func`1<T> dynamicDelegate);
    public virtual T get_Value();
}
public class Castle.Components.DictionaryAdapter.EditableBindingList`1 : BindingList`1<T> {
    private bool isEditing;
    private List`1<T> snapshot;
    public bool IsChanged { get; }
    public EditableBindingList`1(IList`1<T> initial);
    public sealed virtual bool get_IsChanged();
    public sealed virtual void BeginEdit();
    public sealed virtual void EndEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void AcceptChanges();
    public sealed virtual void RejectChanges();
}
public class Castle.Components.DictionaryAdapter.EditableList : EditableList`1<object> {
    public EditableList(IEnumerable`1<object> collection);
}
public class Castle.Components.DictionaryAdapter.EditableList`1 : List`1<T> {
    private bool isEditing;
    private List`1<T> snapshot;
    public bool IsChanged { get; }
    public EditableList`1(IEnumerable`1<T> collection);
    public sealed virtual void BeginEdit();
    public sealed virtual bool get_IsChanged();
    public sealed virtual void EndEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void AcceptChanges();
    public sealed virtual void RejectChanges();
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.FetchAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Fetch>k__BackingField;
    public bool Fetch { get; private set; }
    public FetchAttribute(bool fetch);
    [CompilerGeneratedAttribute]
public bool get_Fetch();
    [CompilerGeneratedAttribute]
private void set_Fetch(bool value);
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.GenericDictionaryAdapter : object {
    [ExtensionAttribute]
public static GenericDictionaryAdapter`1<TValue> ForDictionaryAdapter(IDictionary`2<string, TValue> dictionary);
}
[DefaultMemberAttribute("Item")]
public class Castle.Components.DictionaryAdapter.GenericDictionaryAdapter`1 : AbstractDictionaryAdapter {
    private IDictionary`2<string, TValue> dictionary;
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public GenericDictionaryAdapter`1(IDictionary`2<string, TValue> dictionary);
    public virtual bool get_IsReadOnly();
    public virtual bool Contains(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private static string GetKey(object key);
}
[AttributeUsageAttribute("128")]
public class Castle.Components.DictionaryAdapter.GroupAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Object[] <Group>k__BackingField;
    public Object[] Group { get; private set; }
    public GroupAttribute(object group);
    public GroupAttribute(Object[] group);
    [CompilerGeneratedAttribute]
public Object[] get_Group();
    [CompilerGeneratedAttribute]
private void set_Group(Object[] value);
}
public interface Castle.Components.DictionaryAdapter.IBindingList`1 {
    public bool AllowNew { get; }
    public bool AllowEdit { get; }
    public bool AllowRemove { get; }
    public bool SupportsChangeNotification { get; }
    public bool SupportsSearching { get; }
    public bool SupportsSorting { get; }
    public bool IsSorted { get; }
    public PropertyDescriptor SortProperty { get; }
    public ListSortDirection SortDirection { get; }
    public abstract virtual bool get_AllowNew();
    public abstract virtual bool get_AllowEdit();
    public abstract virtual bool get_AllowRemove();
    public abstract virtual bool get_SupportsChangeNotification();
    public abstract virtual bool get_SupportsSearching();
    public abstract virtual bool get_SupportsSorting();
    public abstract virtual bool get_IsSorted();
    public abstract virtual PropertyDescriptor get_SortProperty();
    public abstract virtual ListSortDirection get_SortDirection();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ListChanged(ListChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ListChanged(ListChangedEventHandler value);
    public abstract virtual T AddNew();
    public abstract virtual int Find(PropertyDescriptor property, object key);
    public abstract virtual void AddIndex(PropertyDescriptor property);
    public abstract virtual void RemoveIndex(PropertyDescriptor property);
    public abstract virtual void ApplySort(PropertyDescriptor property, ListSortDirection direction);
    public abstract virtual void RemoveSort();
}
public interface Castle.Components.DictionaryAdapter.IBindingListSource {
    public IBindingList AsBindingList { get; }
    public abstract virtual IBindingList get_AsBindingList();
}
[DefaultMemberAttribute("Item")]
public interface Castle.Components.DictionaryAdapter.ICollectionAdapter`1 {
    public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    public T Item { get; public set; }
    public bool HasSnapshot { get; }
    public int SnapshotCount { get; }
    public abstract virtual void Initialize(ICollectionAdapterObserver`1<T> advisor);
    public abstract virtual IEqualityComparer`1<T> get_Comparer();
    public abstract virtual int get_Count();
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual T AddNew();
    public abstract virtual bool Add(T value);
    public abstract virtual bool Insert(int index, T value);
    public abstract virtual void Remove(int index);
    public abstract virtual void Clear();
    public abstract virtual void ClearReferences();
    public abstract virtual bool get_HasSnapshot();
    public abstract virtual int get_SnapshotCount();
    public abstract virtual T GetCurrentItem(int index);
    public abstract virtual T GetSnapshotItem(int index);
    public abstract virtual void SaveSnapshot();
    public abstract virtual void LoadSnapshot();
    public abstract virtual void DropSnapshot();
}
public interface Castle.Components.DictionaryAdapter.ICollectionAdapterObserver`1 {
    public abstract virtual bool OnInserting(T newValue);
    public abstract virtual bool OnReplacing(T oldValue, T newValue);
    public abstract virtual void OnRemoving(T oldValue);
    public abstract virtual void OnInserted(T newValue, int index);
    public abstract virtual void OnReplaced(T oldValue, T newValue, int index);
    public abstract virtual void OnRemoved(T oldValue, int index);
}
public interface Castle.Components.DictionaryAdapter.ICollectionProjection {
    public abstract virtual void Replace(IEnumerable source);
    public abstract virtual void Clear();
    public abstract virtual void ClearReferences();
}
public interface Castle.Components.DictionaryAdapter.ICondition {
    public abstract virtual bool SatisfiedBy(object value);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryAdapter {
    public DictionaryAdapterMeta Meta { get; }
    public DictionaryAdapterInstance This { get; }
    public abstract virtual DictionaryAdapterMeta get_Meta();
    public abstract virtual DictionaryAdapterInstance get_This();
    public abstract virtual string GetKey(string propertyName);
    public abstract virtual object GetProperty(string propertyName, bool ifExists);
    public abstract virtual object ReadProperty(string key);
    public abstract virtual T GetPropertyOfType(string propertyName);
    public abstract virtual bool SetProperty(string propertyName, Object& value);
    public abstract virtual void StoreProperty(PropertyDescriptor property, string key, object value);
    public abstract virtual void ClearProperty(PropertyDescriptor property, string key);
    public abstract virtual bool ShouldClearProperty(PropertyDescriptor property, object value);
    public abstract virtual void CopyTo(IDictionaryAdapter other);
    public abstract virtual void CopyTo(IDictionaryAdapter other, Func`2<PropertyDescriptor, bool> selector);
    public abstract virtual T Coerce();
    public abstract virtual object Coerce(Type type);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory {
    public abstract virtual T GetAdapter(IDictionary dictionary);
    public abstract virtual object GetAdapter(Type type, IDictionary dictionary);
    public abstract virtual object GetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);
    public abstract virtual T GetAdapter(NameValueCollection nameValues);
    public abstract virtual object GetAdapter(Type type, NameValueCollection nameValues);
    public abstract virtual T GetAdapter(XmlNode xmlNode);
    public abstract virtual object GetAdapter(Type type, XmlNode xmlNode);
    public abstract virtual DictionaryAdapterMeta GetAdapterMeta(Type type);
    public abstract virtual DictionaryAdapterMeta GetAdapterMeta(Type type, PropertyDescriptor descriptor);
    public abstract virtual DictionaryAdapterMeta GetAdapterMeta(Type type, DictionaryAdapterMeta other);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor {
    public abstract virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, object state);
    public abstract virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, Func`2<PropertyDescriptor, bool> selector, object state);
    public abstract virtual void VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    public abstract virtual void VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    public abstract virtual void VisitCollection(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, Type collectionItemType, object state);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryBehavior {
    public int ExecutionOrder { get; }
    public abstract virtual int get_ExecutionOrder();
    public abstract virtual IDictionaryBehavior Copy();
}
public interface Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder {
    public abstract virtual Object[] BuildBehaviors();
}
public interface Castle.Components.DictionaryAdapter.IDictionaryCoerceStrategy {
    public abstract virtual object Coerce(IDictionaryAdapter adapter, Type type);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryCopyStrategy {
    public abstract virtual bool Copy(IDictionaryAdapter source, IDictionaryAdapter target, Func`2& selector);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryCreate {
    public abstract virtual T Create();
    public abstract virtual object Create(Type type);
    public abstract virtual T Create(IDictionary dictionary);
    public abstract virtual object Create(Type type, IDictionary dictionary);
    public abstract virtual T Create(Action`1<T> init);
    public abstract virtual T Create(IDictionary dictionary, Action`1<T> init);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryCreateStrategy {
    public abstract virtual object Create(IDictionaryAdapter adapter, Type type, IDictionary dictionary);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryEdit {
    public bool CanEdit { get; }
    public bool IsEditing { get; }
    public bool SupportsMultiLevelEdit { get; public set; }
    public abstract virtual bool get_CanEdit();
    public abstract virtual bool get_IsEditing();
    public abstract virtual bool get_SupportsMultiLevelEdit();
    public abstract virtual void set_SupportsMultiLevelEdit(bool value);
    public abstract virtual IDisposable SuppressEditingBlock();
    public abstract virtual void SuppressEditing();
    public abstract virtual void ResumeEditing();
}
public interface Castle.Components.DictionaryAdapter.IDictionaryEqualityHashCodeStrategy {
    public abstract virtual bool Equals(IDictionaryAdapter adapter1, IDictionaryAdapter adapter2);
    public abstract virtual bool GetHashCode(IDictionaryAdapter adapter, Int32& hashCode);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryInitializer {
    public abstract virtual void Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder {
    public abstract virtual string GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer {
    public abstract virtual void Initialize(IDictionaryAdapterFactory factory, DictionaryAdapterMeta dictionaryMeta);
    public abstract virtual bool ShouldHaveBehavior(object behavior);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryNotify {
    public bool CanNotify { get; }
    public bool ShouldNotify { get; }
    public abstract virtual bool get_CanNotify();
    public abstract virtual bool get_ShouldNotify();
    public abstract virtual IDisposable SuppressNotificationsBlock();
    public abstract virtual void SuppressNotifications();
    public abstract virtual void ResumeNotifications();
}
public interface Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter {
    public abstract virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryPropertySetter {
    public abstract virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryReferenceManager {
    public abstract virtual bool IsReferenceProperty(IDictionaryAdapter dictionaryAdapter, string propertyName);
    public abstract virtual bool TryGetReference(object keyObject, Object& inGraphObject);
    public abstract virtual void AddReference(object keyObject, object relatedObject, bool isInGraph);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryValidate {
    public bool CanValidate { get; public set; }
    public bool IsValid { get; }
    public IEnumerable`1<IDictionaryValidator> Validators { get; }
    public abstract virtual bool get_CanValidate();
    public abstract virtual void set_CanValidate(bool value);
    public abstract virtual bool get_IsValid();
    public abstract virtual DictionaryValidateGroup ValidateGroups(Object[] groups);
    public abstract virtual IEnumerable`1<IDictionaryValidator> get_Validators();
    public abstract virtual void AddValidator(IDictionaryValidator validator);
}
public interface Castle.Components.DictionaryAdapter.IDictionaryValidator {
    public abstract virtual bool IsValid(IDictionaryAdapter dictionaryAdapter);
    public abstract virtual string Validate(IDictionaryAdapter dictionaryAdapter);
    public abstract virtual string Validate(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);
    public abstract virtual void Invalidate(IDictionaryAdapter dictionaryAdapter);
}
public interface Castle.Components.DictionaryAdapter.IDynamicValue {
    public abstract virtual object GetValue();
}
public interface Castle.Components.DictionaryAdapter.IDynamicValue`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[AttributeUsageAttribute("128")]
public class Castle.Components.DictionaryAdapter.IfExistsAttribute : Attribute {
}
public interface Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer {
    public abstract virtual void Initialize(PropertyDescriptor propertyDescriptor, Object[] behaviors);
}
public interface Castle.Components.DictionaryAdapter.IValueInitializer {
    public abstract virtual void Initialize(IDictionaryAdapter dictionaryAdapter, object value);
}
public interface Castle.Components.DictionaryAdapter.IVirtual {
    public bool IsReal { get; }
    public abstract virtual bool get_IsReal();
    public abstract virtual void Realize();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Realized(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Realized(EventHandler value);
}
public interface Castle.Components.DictionaryAdapter.IVirtual`1 {
    public abstract virtual T Realize();
    public abstract virtual void AddSite(IVirtualSite`1<T> site);
    public abstract virtual void RemoveSite(IVirtualSite`1<T> site);
}
public interface Castle.Components.DictionaryAdapter.IVirtualSite`1 {
    public abstract virtual void OnRealizing(T node);
}
public interface Castle.Components.DictionaryAdapter.IVirtualTarget`2 {
    public abstract virtual void OnRealizing(TNode node, TMember member);
}
[AttributeUsageAttribute("128")]
public class Castle.Components.DictionaryAdapter.KeyAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; private set; }
    public KeyAttribute(string key);
    public KeyAttribute(String[] keys);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
[AttributeUsageAttribute("1024")]
public class Castle.Components.DictionaryAdapter.KeyPrefixAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <KeyPrefix>k__BackingField;
    public string KeyPrefix { get; public set; }
    public KeyPrefixAttribute(string keyPrefix);
    [CompilerGeneratedAttribute]
public string get_KeyPrefix();
    [CompilerGeneratedAttribute]
public void set_KeyPrefix(string value);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.KeySubstitutionAttribute : DictionaryBehaviorAttribute {
    private string oldValue;
    private string newValue;
    public KeySubstitutionAttribute(string oldValue, string newValue);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}, Adapter = {Adapter}")]
[DebuggerTypeProxyAttribute("Castle.Components.DictionaryAdapter.ListProjectionDebugView`1")]
public class Castle.Components.DictionaryAdapter.ListProjection`1 : object {
    private ICollectionAdapter`1<T> adapter;
    private int addNewIndex;
    private int addedIndex;
    private int suspendLevel;
    private int changedIndex;
    private PropertyChangedEventHandler propertyHandler;
    private static PropertyDescriptorCollection itemProperties;
    private static int NoIndex;
    [CompilerGeneratedAttribute]
private ListChangedEventHandler ListChanged;
    public int Count { get; }
    public IBindingList AsBindingList { get; }
    public ICollectionAdapter`1<T> Adapter { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.AllowEdit { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.AllowNew { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.AllowRemove { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsChangeNotification { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSearching { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSorting { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.IsSorted { get; }
    private PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.SortProperty { get; }
    private ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.SortDirection { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public bool IsChanged { get; }
    public bool EventsEnabled { get; }
    public ListProjection`1(ICollectionAdapter`1<T> adapter);
    public sealed virtual int get_Count();
    public sealed virtual IBindingList get_AsBindingList();
    public ICollectionAdapter`1<T> get_Adapter();
    public IEqualityComparer`1<T> get_Comparer();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_AllowEdit();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_AllowNew();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_AllowRemove();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsChangeNotification();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSearching();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSorting();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_IsSorted();
    private sealed virtual override PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortProperty();
    private sealed virtual override ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortDirection();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [IteratorStateMachineAttribute("Castle.Components.DictionaryAdapter.ListProjection`1/<GetEnumerator>d__71")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public void Replace(IEnumerable`1<T> items);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionProjection.Replace(IEnumerable items);
    protected virtual bool OnReplacing(T oldValue, T newValue);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnReplacing(T oldValue, T newValue);
    protected virtual void OnReplaced(T oldValue, T newValue, int index);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnReplaced(T oldValue, T newValue, int index);
    public virtual T AddNew();
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    public bool IsNew(int index);
    public virtual void EndNew(int index);
    public virtual void CancelNew(int index);
    public virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    protected virtual bool OnInserting(T value);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnInserting(T value);
    protected virtual void OnInserted(T newValue, int index);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnInserted(T newValue, int index);
    public virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public virtual void RemoveAt(int index);
    public virtual void Clear();
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionProjection.ClearReferences();
    protected virtual void OnRemoving(T oldValue);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnRemoving(T oldValue);
    protected virtual void OnRemoved(T oldValue, int index);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnRemoved(T oldValue, int index);
    public sealed virtual bool get_IsChanged();
    public sealed virtual void BeginEdit();
    public sealed virtual void EndEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void AcceptChanges();
    public sealed virtual void RejectChanges();
    private void AttachPropertyChanged(T value);
    private void DetachPropertyChanged(T value);
    private void HandlePropertyChanged(object sender, PropertyChangedEventArgs e);
    private bool CanHandle(object sender, PropertyChangedEventArgs e);
    private bool TryGetChangedItem(object sender, T& item);
    private bool TryGetChangedIndex(T item);
    private static PropertyDescriptor GetChangedProperty(PropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    protected virtual void OnListChanged(ListChangedEventArgs args);
    protected void NotifyListChanged(ListChangedType type, int index);
    protected void NotifyListReset();
    public bool get_EventsEnabled();
    public void SuspendEvents();
    public bool ResumeEvents();
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.AddIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override int Castle.Components.DictionaryAdapter.IBindingList<T>.Find(PropertyDescriptor property, object key);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveSort();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
}
internal class Castle.Components.DictionaryAdapter.ListProjectionDebugView`1 : object {
    private ListProjection`1<T> projection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionAdapter`1<T> Adapter { get; }
    public ListProjectionDebugView`1(ListProjection`1<T> projection);
    public T[] get_Items();
    public ICollectionAdapter`1<T> get_Adapter();
}
public class Castle.Components.DictionaryAdapter.MemberwiseEqualityHashCodeStrategy : DictionaryBehaviorAttribute {
    public sealed virtual bool Equals(IDictionaryAdapter adapter1, IDictionaryAdapter adapter2);
    public sealed virtual int GetHashCode(IDictionaryAdapter adapter);
    public sealed virtual bool GetHashCode(IDictionaryAdapter adapter, Int32& hashCode);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
}
[AttributeUsageAttribute("1024")]
public class Castle.Components.DictionaryAdapter.MultiLevelEditAttribute : DictionaryBehaviorAttribute {
    public sealed virtual void Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
}
[DefaultMemberAttribute("Item")]
public class Castle.Components.DictionaryAdapter.NameValueCollectionAdapter : AbstractDictionaryAdapter {
    private NameValueCollection nameValues;
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public NameValueCollectionAdapter(NameValueCollection nameValues);
    public virtual bool get_IsReadOnly();
    public virtual bool Contains(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public static NameValueCollectionAdapter Adapt(NameValueCollection nameValues);
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.NewGuidAttribute : DictionaryBehaviorAttribute {
    private static Guid UnassignedGuid;
    private static NewGuidAttribute();
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.OnDemandAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type Type { get; private set; }
    public object Value { get; private set; }
    public OnDemandAttribute(Type type);
    public OnDemandAttribute(object value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private static bool IsAcceptedType(Type type);
    private static Type GetInferredType(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, IValueInitializer& initializer);
}
public class Castle.Components.DictionaryAdapter.PropertyChangedEventArgsEx : PropertyChangedEventArgs {
    private object oldValue;
    private object newValue;
    public object OldValue { get; }
    public object NewValue { get; }
    public PropertyChangedEventArgsEx(string propertyName, object oldValue, object newValue);
    public object get_OldValue();
    public object get_NewValue();
}
public class Castle.Components.DictionaryAdapter.PropertyChangingEventArgsEx : PropertyChangingEventArgs {
    private object oldValue;
    private object newValue;
    private bool cancel;
    public object OldValue { get; }
    public object NewValue { get; }
    public bool Cancel { get; public set; }
    public PropertyChangingEventArgsEx(string propertyName, object oldValue, object newValue);
    public object get_OldValue();
    public object get_NewValue();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
[DebuggerDisplayAttribute("{Property.DeclaringType.FullName,nq}.{PropertyName,nq}")]
public class Castle.Components.DictionaryAdapter.PropertyDescriptor : object {
    private IDictionary state;
    private Dictionary`2<object, object> extendedProperties;
    protected List`1<IDictionaryBehavior> dictionaryBehaviors;
    private static Object[] NoAnnotations;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamicProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Fetch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IfExists>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressNotifications>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Annotations>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeConverter <TypeConverter>k__BackingField;
    public int ExecutionOrder { get; }
    public string PropertyName { get; }
    public Type PropertyType { get; }
    public PropertyInfo Property { get; private set; }
    public bool IsDynamicProperty { get; private set; }
    public IDictionary State { get; }
    public bool Fetch { get; public set; }
    public bool IfExists { get; public set; }
    public bool SuppressNotifications { get; public set; }
    public Object[] Annotations { get; private set; }
    public TypeConverter TypeConverter { get; private set; }
    public IDictionary ExtendedProperties { get; }
    public IEnumerable`1<IDictionaryBehavior> Behaviors { get; }
    internal List`1<IDictionaryBehavior> BehaviorsInternal { get; }
    public IEnumerable`1<IDictionaryKeyBuilder> KeyBuilders { get; }
    public IEnumerable`1<IDictionaryPropertySetter> Setters { get; }
    public IEnumerable`1<IDictionaryPropertyGetter> Getters { get; }
    public IEnumerable`1<IDictionaryInitializer> Initializers { get; }
    public IEnumerable`1<IDictionaryMetaInitializer> MetaInitializers { get; }
    public PropertyDescriptor(PropertyInfo property, Object[] annotations);
    public PropertyDescriptor(Object[] annotations);
    public PropertyDescriptor(PropertyDescriptor source, bool copyBehaviors);
    private static PropertyDescriptor();
    public sealed virtual int get_ExecutionOrder();
    public string get_PropertyName();
    public Type get_PropertyType();
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(PropertyInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsDynamicProperty();
    [CompilerGeneratedAttribute]
private void set_IsDynamicProperty(bool value);
    public IDictionary get_State();
    [CompilerGeneratedAttribute]
public bool get_Fetch();
    [CompilerGeneratedAttribute]
public void set_Fetch(bool value);
    [CompilerGeneratedAttribute]
public bool get_IfExists();
    [CompilerGeneratedAttribute]
public void set_IfExists(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressNotifications();
    [CompilerGeneratedAttribute]
public void set_SuppressNotifications(bool value);
    [CompilerGeneratedAttribute]
public Object[] get_Annotations();
    [CompilerGeneratedAttribute]
private void set_Annotations(Object[] value);
    [CompilerGeneratedAttribute]
public TypeConverter get_TypeConverter();
    [CompilerGeneratedAttribute]
private void set_TypeConverter(TypeConverter value);
    public IDictionary get_ExtendedProperties();
    public IEnumerable`1<IDictionaryBehavior> get_Behaviors();
    internal List`1<IDictionaryBehavior> get_BehaviorsInternal();
    public IEnumerable`1<IDictionaryKeyBuilder> get_KeyBuilders();
    public IEnumerable`1<IDictionaryPropertySetter> get_Setters();
    public IEnumerable`1<IDictionaryPropertyGetter> get_Getters();
    public IEnumerable`1<IDictionaryInitializer> get_Initializers();
    public IEnumerable`1<IDictionaryMetaInitializer> get_MetaInitializers();
    public sealed virtual string GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor descriptor);
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor descriptor, bool ifExists);
    public sealed virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor descriptor);
    public PropertyDescriptor AddBehavior(IDictionaryBehavior behavior);
    public static void MergeBehavior(List`1& dictionaryBehaviors, T behavior);
    public PropertyDescriptor AddBehaviors(IDictionaryBehavior[] behaviors);
    public PropertyDescriptor AddBehaviors(IEnumerable`1<IDictionaryBehavior> behaviors);
    public PropertyDescriptor CopyBehaviors(PropertyDescriptor other);
    public sealed virtual IDictionaryBehavior Copy();
    private void ObtainTypeConverter();
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.ReferenceAttribute : Attribute {
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.RemoveIfAttribute : DictionaryBehaviorAttribute {
    private ICondition condition;
    unknown Type Condition {public set; }
    public RemoveIfAttribute(Object[] values);
    public RemoveIfAttribute(Object[] values, Type comparerType);
    protected RemoveIfAttribute(ICondition condition);
    public void set_Condition(Type value);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    internal bool ShouldRemove(object value);
    private static TBase Construct(Type type, string paramName);
}
public class Castle.Components.DictionaryAdapter.RemoveIfEmptyAttribute : RemoveIfAttribute {
    [CompilerGeneratedAttribute]
private Type <Condition>k__BackingField;
    private Type Condition { get; private set; }
    [CompilerGeneratedAttribute]
private Type get_Condition();
    [CompilerGeneratedAttribute]
private void set_Condition(Type value);
}
public class Castle.Components.DictionaryAdapter.SetProjection`1 : ListProjection`1<T> {
    private HashSet`1<T> set;
    public SetProjection`1(ICollectionAdapter`1<T> adapter);
    public virtual bool Contains(T item);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    private void Repopulate();
    public virtual void EndNew(int index);
    public virtual bool Add(T item);
    protected virtual bool OnInserting(T value);
    protected virtual bool OnReplacing(T oldValue, T newValue);
    public virtual bool Remove(T item);
    public virtual void RemoveAt(int index);
    public virtual void Clear();
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
}
[AttributeUsageAttribute("128")]
public class Castle.Components.DictionaryAdapter.StringFormatAttribute : DictionaryBehaviorAttribute {
    private static Char[] PropertyDelimeters;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Properties>k__BackingField;
    public string Format { get; private set; }
    public string Properties { get; private set; }
    public StringFormatAttribute(string format, string properties);
    private static StringFormatAttribute();
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
    [CompilerGeneratedAttribute]
public string get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(string value);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private Object[] GetFormatArguments(IDictionaryAdapter dictionaryAdapter, string formattedPropertyName);
}
[AttributeUsageAttribute("128")]
public class Castle.Components.DictionaryAdapter.StringListAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private char <Separator>k__BackingField;
    public char Separator { get; public set; }
    [CompilerGeneratedAttribute]
public char get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(char value);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    internal static string BuildString(IEnumerable enumerable, char separator);
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.StringStorageAttribute : DictionaryBehaviorAttribute {
    public sealed virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.StringValuesAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    private string GetPropertyAsString(PropertyDescriptor property, object value);
}
[AttributeUsageAttribute("128")]
public class Castle.Components.DictionaryAdapter.SuppressNotificationsAttribute : DictionaryBehaviorAttribute {
    public sealed virtual void Initialize(PropertyDescriptor propertyDescriptor, Object[] behaviors);
}
[AttributeUsageAttribute("1024")]
public class Castle.Components.DictionaryAdapter.TypeKeyPrefixAttribute : DictionaryBehaviorAttribute {
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
public abstract class Castle.Components.DictionaryAdapter.VirtualObject`1 : object {
    private List`1<IVirtualSite`1<TNode>> sites;
    [CompilerGeneratedAttribute]
private EventHandler Realized;
    public bool IsReal { get; }
    protected VirtualObject`1(IVirtualSite`1<TNode> site);
    public abstract virtual bool get_IsReal();
    protected void AddSite(IVirtualSite`1<TNode> site);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual<TNode>.AddSite(IVirtualSite`1<TNode> site);
    protected void RemoveSite(IVirtualSite`1<TNode> site);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual<TNode>.RemoveSite(IVirtualSite`1<TNode> site);
    public sealed virtual TNode Realize();
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual.Realize();
    protected abstract virtual bool TryRealize(TNode& node);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Realized(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
}
public class Castle.Components.DictionaryAdapter.VirtualSite`2 : object {
    private IVirtualTarget`2<TNode, TMember> target;
    private TMember member;
    private static IEqualityComparer`1<IVirtualTarget`2<TNode, TMember>> TargetComparer;
    private static IEqualityComparer`1<TMember> MemberComparer;
    public IVirtualTarget`2<TNode, TMember> Target { get; }
    public TMember Member { get; }
    public VirtualSite`2(IVirtualTarget`2<TNode, TMember> target, TMember member);
    private static VirtualSite`2();
    public IVirtualTarget`2<TNode, TMember> get_Target();
    public TMember get_Member();
    public sealed virtual void OnRealizing(TNode node);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VirtualSite`2<TNode, TMember> other);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.VolatileAttribute : Attribute {
}
public class Castle.Components.DictionaryAdapter.Xml.CompiledXPath : object {
    private XPathExpression path;
    private CompiledXPathStep firstStep;
    private int depth;
    public XPathExpression Path { get; internal set; }
    public CompiledXPathStep FirstStep { get; internal set; }
    public CompiledXPathStep LastStep { get; }
    public int Depth { get; internal set; }
    public bool IsCreatable { get; }
    public XPathExpression get_Path();
    internal void set_Path(XPathExpression value);
    public CompiledXPathStep get_FirstStep();
    internal void set_FirstStep(CompiledXPathStep value);
    public CompiledXPathStep get_LastStep();
    public int get_Depth();
    internal void set_Depth(int value);
    public bool get_IsCreatable();
    internal void MakeNotCreatable();
    internal void Prepare();
    public void SetContext(XsltContext context);
}
public class Castle.Components.DictionaryAdapter.Xml.CompiledXPathNode : object {
    private string prefix;
    private string localName;
    private bool isAttribute;
    private XPathExpression value;
    private CompiledXPathNode next;
    private CompiledXPathNode previous;
    private IList`1<CompiledXPathNode> dependencies;
    private static IList`1<CompiledXPathNode> NoDependencies;
    public string Prefix { get; internal set; }
    public string LocalName { get; internal set; }
    public bool IsAttribute { get; internal set; }
    public bool IsSelfReference { get; }
    public bool IsSimple { get; }
    public XPathExpression Value { get; internal set; }
    public CompiledXPathNode NextNode { get; internal set; }
    public CompiledXPathNode PreviousNode { get; internal set; }
    public IList`1<CompiledXPathNode> Dependencies { get; }
    private static CompiledXPathNode();
    public string get_Prefix();
    internal void set_Prefix(string value);
    public string get_LocalName();
    internal void set_LocalName(string value);
    public bool get_IsAttribute();
    internal void set_IsAttribute(bool value);
    public bool get_IsSelfReference();
    public bool get_IsSimple();
    public XPathExpression get_Value();
    internal void set_Value(XPathExpression value);
    public CompiledXPathNode get_NextNode();
    internal void set_NextNode(CompiledXPathNode value);
    public CompiledXPathNode get_PreviousNode();
    internal void set_PreviousNode(CompiledXPathNode value);
    public IList`1<CompiledXPathNode> get_Dependencies();
    private bool HasNoRealDependencies();
    private XPathExpression GetSelfReferenceValue();
    internal virtual void Prepare();
    internal virtual void SetContext(XsltContext context);
}
public class Castle.Components.DictionaryAdapter.Xml.CompiledXPathStep : CompiledXPathNode {
    private XPathExpression path;
    public XPathExpression Path { get; internal set; }
    public CompiledXPathStep NextStep { get; }
    public XPathExpression get_Path();
    internal void set_Path(XPathExpression value);
    public CompiledXPathStep get_NextStep();
    internal virtual void SetContext(XsltContext context);
}
[FlagsAttribute]
public enum Castle.Components.DictionaryAdapter.Xml.CursorFlags : Enum {
    public int value__;
    public static CursorFlags None;
    public static CursorFlags Elements;
    public static CursorFlags Attributes;
    public static CursorFlags Multiple;
    public static CursorFlags Mutable;
    public static CursorFlags AllNodes;
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.CursorFlagsExtensions : object {
    [ExtensionAttribute]
public static CursorFlags MutableIf(CursorFlags flags, bool mutable);
    [ExtensionAttribute]
public static bool IncludesElements(CursorFlags flags);
    [ExtensionAttribute]
public static bool IncludesAttributes(CursorFlags flags);
    [ExtensionAttribute]
public static bool AllowsMultipleItems(CursorFlags flags);
    [ExtensionAttribute]
public static bool SupportsMutation(CursorFlags flags);
}
public class Castle.Components.DictionaryAdapter.Xml.DefaultXmlReferenceFormat : object {
    public static DefaultXmlReferenceFormat Instance;
    private static NumberStyles IntegerStyle;
    private static IFormatProvider Culture;
    private static DefaultXmlReferenceFormat();
    public sealed virtual bool TryGetIdentity(IXmlNode node, Int32& id);
    public sealed virtual bool TryGetReference(IXmlNode node, Int32& id);
    public sealed virtual void SetIdentity(IXmlNode node, int id);
    public sealed virtual void SetReference(IXmlNode node, int id);
    public sealed virtual void ClearIdentity(IXmlNode node);
    public sealed virtual void ClearReference(IXmlNode node);
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.DictionaryAdapterExtensions : object {
    private static string XmlAccessorKey;
    private static string XmlMetaKey;
    private static string XmlTypeKey;
    [ExtensionAttribute]
public static object CreateChildAdapter(IDictionaryAdapter parent, Type type, XmlAdapter adapter);
    [ExtensionAttribute]
public static object CreateChildAdapter(IDictionaryAdapter parent, Type type, XmlAdapter adapter, IDictionary dictionary);
    [ExtensionAttribute]
public static bool HasAccessor(PropertyDescriptor property);
    [ExtensionAttribute]
public static XmlAccessor GetAccessor(PropertyDescriptor property);
    [ExtensionAttribute]
public static void SetAccessor(PropertyDescriptor property, XmlAccessor accessor);
    [ExtensionAttribute]
public static bool HasXmlMeta(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static XmlMetadata GetXmlMeta(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static void SetXmlMeta(DictionaryAdapterMeta meta, XmlMetadata xmlMeta);
    [ExtensionAttribute]
public static bool HasXmlType(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static string GetXmlType(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static void SetXmlType(DictionaryAdapterMeta meta, string value);
}
internal static class Castle.Components.DictionaryAdapter.Xml.Error : object {
    internal static Exception ArgumentNull(string paramName);
    internal static Exception ArgumentOutOfRange(string paramName);
    internal static Exception InvalidOperation();
    internal static Exception NotSupported();
    internal static Exception ObjectDisposed(string objectName);
    internal static Exception AttributeConflict(string propertyName);
    internal static Exception SeparateGetterSetterOnComplexType(string propertyName);
    internal static Exception XmlMetadataNotAvailable(Type clrType);
    internal static Exception NotDictionaryAdapter(string paramName);
    internal static Exception NoInstanceDescriptor(string paramName);
    internal static Exception NoXmlAdapter(string paramName);
    internal static Exception NotRealizable();
    internal static Exception CursorNotMutable();
    internal static Exception CursorNotInCreatableState();
    internal static Exception CursorNotInRemovableState();
    internal static Exception CursorNotInCoercibleState();
    internal static Exception CursorNotInRealizableState();
    internal static Exception CursorCannotMoveToGivenNode();
    internal static Exception CannotSetAttribute(IXmlIdentity identity);
    internal static Exception NotXmlKnownType(Type clrType);
    internal static Exception UnsupportedCollectionType(Type clrType);
    internal static Exception NotCollectionType(string paramName);
    internal static Exception InvalidLocalName();
    internal static Exception InvalidNamespaceUri();
    internal static Exception NoDefaultKnownType();
    internal static Exception XPathNotCreatable(CompiledXPath path);
    internal static Exception XPathNavigationFailed(XPathExpression path);
    internal static Exception ObjectIdNotFound(string id);
}
public interface Castle.Components.DictionaryAdapter.Xml.IConfigurable`1 {
    public abstract virtual void Configure(T value);
}
public interface Castle.Components.DictionaryAdapter.Xml.IRealizable`1 {
    public bool IsReal { get; }
    public T Value { get; }
    public abstract virtual bool get_IsReal();
    public abstract virtual T get_Value();
}
public interface Castle.Components.DictionaryAdapter.Xml.IRealizableSource {
    public abstract virtual IRealizable`1<T> AsRealizable();
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlAccessor {
    public Type ClrType { get; }
    public XmlTypeSerializer Serializer { get; }
    public IXmlContext Context { get; }
    public bool IsNillable { get; }
    public bool IsReference { get; }
    public abstract virtual Type get_ClrType();
    public abstract virtual XmlTypeSerializer get_Serializer();
    public abstract virtual IXmlContext get_Context();
    public abstract virtual bool get_IsNillable();
    public abstract virtual bool get_IsReference();
    public abstract virtual object GetValue(IXmlNode node, IDictionaryAdapter parentObject, XmlReferenceManager references, bool nodeExists, bool orStub);
    public abstract virtual void SetValue(IXmlCursor cursor, IDictionaryAdapter parentObject, XmlReferenceManager references, bool hasCurrent, object oldValue, Object& newValue);
    public abstract virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlBehaviorSemantics`1 {
    public abstract virtual string GetLocalName(T behavior);
    public abstract virtual string GetNamespaceUri(T behavior);
    public abstract virtual Type GetClrType(T behavior);
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlCollectionAccessor {
    public abstract virtual IXmlCursor SelectCollectionItems(IXmlNode parentNode, bool mutable);
    public abstract virtual void GetCollectionItems(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, IList values);
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlContext {
    public string ChildNamespaceUri { get; }
    public abstract virtual string get_ChildNamespaceUri();
    public abstract virtual IXmlContext Clone();
    public abstract virtual XmlName GetDefaultXsiType(Type clrType);
    public abstract virtual IEnumerable`1<IXmlIncludedType> GetIncludedTypes(Type baseType);
    public abstract virtual bool IsReservedNamespaceUri(string namespaceUri);
    public abstract virtual void AddVariable(XPathVariableAttribute attribute);
    public abstract virtual void AddFunction(XPathFunctionAttribute attribute);
    public abstract virtual void Enlist(CompiledXPath path);
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlCursor {
    public abstract virtual void Reset();
    public abstract virtual void MoveTo(IXmlNode node);
    public abstract virtual void MoveToEnd();
    public abstract virtual void Create(Type type);
    public abstract virtual void Coerce(Type type);
    public abstract virtual void Remove();
    public abstract virtual void RemoveAllNext();
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlIdentity {
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public abstract virtual XmlName get_Name();
    public abstract virtual XmlName get_XsiType();
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlIncludedType {
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public abstract virtual XmlName get_XsiType();
    public abstract virtual Type get_ClrType();
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap {
    public IXmlIncludedType Default { get; }
    public abstract virtual IXmlIncludedType get_Default();
    public abstract virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public abstract virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlIterator {
    public abstract virtual bool MoveNext();
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlKnownType {
    public Type ClrType { get; }
    public abstract virtual Type get_ClrType();
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap {
    public IXmlKnownType Default { get; }
    public abstract virtual IXmlKnownType get_Default();
    public abstract virtual bool TryGet(IXmlIdentity xmlNode, IXmlKnownType& knownType);
    public abstract virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlNamespaceSource {
    public abstract virtual string GetElementPrefix(IXmlNode node, string namespaceUri);
    public abstract virtual string GetAttributePrefix(IXmlNode node, string namespaceUri);
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlNode {
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public IXmlNode Parent { get; }
    public IXmlNamespaceSource Namespaces { get; }
    public object UnderlyingObject { get; }
    public CompiledXPath Path { get; }
    public abstract virtual bool get_IsElement();
    public abstract virtual bool get_IsAttribute();
    public abstract virtual bool get_IsNil();
    public abstract virtual void set_IsNil(bool value);
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual string get_Xml();
    public abstract virtual IXmlNode get_Parent();
    public abstract virtual IXmlNamespaceSource get_Namespaces();
    public abstract virtual string GetAttribute(XmlName name);
    public abstract virtual void SetAttribute(XmlName name, string value);
    public abstract virtual string LookupPrefix(string namespaceUri);
    public abstract virtual string LookupNamespaceUri(string prefix);
    public abstract virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    public abstract virtual object get_UnderlyingObject();
    public abstract virtual bool UnderlyingPositionEquals(IXmlNode node);
    public abstract virtual IXmlNode Save();
    public abstract virtual IXmlCursor SelectSelf(Type clrType);
    public abstract virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public abstract virtual IXmlIterator SelectSubtree();
    public abstract virtual CompiledXPath get_Path();
    public abstract virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public abstract virtual object Evaluate(CompiledXPath path);
    public abstract virtual void Clear();
    public abstract virtual XmlReader ReadSubtree();
    public abstract virtual XmlWriter WriteAttributes();
    public abstract virtual XmlWriter WriteChildren();
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlNodeSource {
    public IXmlNode Node { get; }
    public abstract virtual IXmlNode get_Node();
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlPropertyAccessor {
    public abstract virtual object GetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    public abstract virtual void SetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, object oldValue, Object& newValue);
}
public interface Castle.Components.DictionaryAdapter.Xml.IXmlReferenceFormat {
    public abstract virtual bool TryGetIdentity(IXmlNode node, Int32& id);
    public abstract virtual bool TryGetReference(IXmlNode node, Int32& id);
    public abstract virtual void SetIdentity(IXmlNode node, int id);
    public abstract virtual void SetReference(IXmlNode node, int id);
    public abstract virtual void ClearIdentity(IXmlNode node);
    public abstract virtual void ClearReference(IXmlNode node);
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.RealizableExtensions : object {
    [ExtensionAttribute]
public static IRealizable`1<T> RequireRealizable(IRealizableSource obj);
}
[DefaultMemberAttribute("Item")]
public class Castle.Components.DictionaryAdapter.Xml.SingletonDispenser`2 : object {
    private ReaderWriterLockSlim locker;
    private Dictionary`2<TKey, object> items;
    private Func`2<TKey, TItem> factory;
    public TItem Item { get; protected set; }
    public SingletonDispenser`2(Func`2<TKey, TItem> factory);
    public TItem get_Item(TKey key);
    protected void set_Item(TKey key, TItem value);
    private TItem GetOrCreate(TKey key);
    private bool TryGetExistingItem(TKey key, Object& item);
    private TItem WaitForCreate(TKey key, object item);
    private TItem Create(TKey key, object item);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.StringExtensions : object {
    [ExtensionAttribute]
public static string NonEmpty(string s);
}
public class Castle.Components.DictionaryAdapter.Xml.SysXmlCursor : SysXmlNode {
    private State state;
    private int index;
    private IXmlKnownTypeMap knownTypes;
    private CursorFlags flags;
    [CompilerGeneratedAttribute]
private EventHandler Realized;
    protected static StringComparer DefaultComparer;
    public bool IsReal { get; }
    public bool HasCurrent { get; }
    public Type ClrType { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public SysXmlCursor(IXmlNode parent, IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    private static SysXmlCursor();
    public virtual bool get_IsReal();
    public bool get_HasCurrent();
    public virtual Type get_ClrType();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public virtual object Evaluate(CompiledXPath path);
    public sealed virtual bool MoveNext();
    private bool MoveNextCore();
    private bool IsMatch();
    private bool Advance();
    protected virtual bool AdvanceToFirstElement();
    private bool AdvanceToNextElement();
    protected virtual bool AdvanceToFirstAttribute();
    private bool AdvanceToNextAttribute();
    private bool AdvanceElement(XmlNode next);
    private bool AdvanceAttribute(XmlNode parent);
    private bool Succeed(State state);
    private bool Fail(State state);
    private bool IsAtEnd();
    public sealed virtual void MoveTo(IXmlNode position);
    private void SetMovedToElement();
    private void SetMovedToAttribute();
    public sealed virtual void MoveToEnd();
    public sealed virtual void Reset();
    private void MoveToParentOfElement();
    private void MoveToParentOfAttribute();
    private void MoveToRealizedParent();
    [CompilerGeneratedAttribute]
public virtual void add_Realized(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
    protected virtual void Realize();
    public void MakeNext(Type clrType);
    public sealed virtual void Coerce(Type clrType);
    private void CoerceElement(IXmlKnownType knownType);
    private void CoerceAttribute(IXmlKnownType knownType);
    public sealed virtual void Create(Type type);
    private void CreateElement(IXmlKnownType knownType, XmlNode position);
    private void CreateAttribute(IXmlKnownType knownType, XmlNode position);
    private XmlElement CreateElementCore(XmlNode parent, XmlName name);
    private XmlAttribute CreateAttributeCore(XmlNode parent, XmlName name);
    private void RequireNoXsiType(IXmlKnownType knownType);
    private XmlName GetEffectiveName(IXmlKnownType knownType, XmlNode parent);
    public sealed virtual void RemoveAllNext();
    public sealed virtual void Remove();
    private void RemoveElement(XmlNode node);
    private void RemoveAttribute(XmlNode node);
    public virtual IXmlNode Save();
    private XmlNode RequireCreatable();
    private void RequireCoercible();
    private void RequireRemovable();
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.SysXmlExtensions : object {
    [ExtensionAttribute]
public static void DefineNamespace(XmlElement node, string prefix, string namespaceUri);
    [ExtensionAttribute]
public static bool IsNamespace(XmlAttribute attribute);
    [ExtensionAttribute]
public static XmlElement FindRoot(XmlElement node);
    [ExtensionAttribute]
public static bool IsXsiType(XmlAttribute attribute);
}
public class Castle.Components.DictionaryAdapter.Xml.SysXmlNode : XmlNodeBase {
    protected XmlNode node;
    public object UnderlyingObject { get; }
    private XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.Value { get; }
    private XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.Value { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    protected SysXmlNode(IXmlNamespaceSource namespaces, IXmlNode parent);
    public SysXmlNode(XmlNode node, Type type, IXmlNamespaceSource namespaces);
    public sealed virtual object get_UnderlyingObject();
    private sealed virtual override XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.get_Value();
    private sealed virtual override XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.get_Value();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public sealed virtual bool UnderlyingPositionEquals(IXmlNode node);
    public sealed virtual string GetAttribute(XmlName name);
    public sealed virtual void SetAttribute(XmlName name, string value);
    private void SetAttributeCore(XmlName name, string value);
    private void ClearAttribute(XmlName name);
    public sealed virtual string LookupPrefix(string namespaceUri);
    public sealed virtual string LookupNamespaceUri(string prefix);
    public sealed virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    private XmlElement GetNamespaceTargetElement();
    public virtual IXmlNode Save();
    public sealed virtual IXmlCursor SelectSelf(Type clrType);
    public sealed virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual IXmlIterator SelectSubtree();
    public sealed virtual XmlReader ReadSubtree();
    public sealed virtual XmlWriter WriteAttributes();
    public sealed virtual XmlWriter WriteChildren();
    public sealed virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public virtual object Evaluate(CompiledXPath path);
    public XmlNode GetNode();
    public sealed virtual void Clear();
    private void ClearAttributes();
    private void ClearChildren();
}
public class Castle.Components.DictionaryAdapter.Xml.SysXmlSubtreeIterator : SysXmlNode {
    private State state;
    public SysXmlSubtreeIterator(IXmlNode parent, IXmlNamespaceSource namespaces);
    public sealed virtual bool MoveNext();
    private bool MoveToInitial();
    private bool MoveToSubsequent();
    private bool MoveToElement(XmlNode node);
    private bool SetNext(XmlNode node);
    public virtual IXmlNode Save();
}
public static class Castle.Components.DictionaryAdapter.Xml.Try : object {
    [DebuggerHiddenAttribute]
public static bool Failure(T& result);
    [DebuggerHiddenAttribute]
public static bool Success(T& result, T value);
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.TypeExtensions : object {
    [ExtensionAttribute]
public static Type NonNullable(Type type);
    [ExtensionAttribute]
public static Type GetCollectionItemType(Type type);
    [ExtensionAttribute]
public static Type GetComponentType(object obj);
    [ExtensionAttribute]
internal static bool IsCustomSerializable(Type type);
}
public static class Castle.Components.DictionaryAdapter.Xml.Wsdl : object {
    public static string Prefix;
    public static string NamespaceUri;
    internal static XmlNamespaceAttribute Namespace;
    private static Wsdl();
}
public abstract class Castle.Components.DictionaryAdapter.Xml.XmlAccessor : object {
    private Type clrType;
    private XmlName xsiType;
    private XmlTypeSerializer serializer;
    private IXmlContext context;
    protected States state;
    public Type ClrType { get; }
    public XmlName XsiType { get; }
    public XmlTypeSerializer Serializer { get; }
    public IXmlContext Context { get; protected set; }
    public bool IsCollection { get; }
    public bool IsIgnored { get; }
    public bool IsNillable { get; }
    public bool IsVolatile { get; }
    public bool IsReference { get; }
    protected XmlAccessor(Type clrType, IXmlContext context);
    public sealed virtual Type get_ClrType();
    public XmlName get_XsiType();
    public sealed virtual XmlTypeSerializer get_Serializer();
    public sealed virtual IXmlContext get_Context();
    protected void set_Context(IXmlContext value);
    public bool get_IsCollection();
    public virtual bool get_IsIgnored();
    public sealed virtual bool get_IsNillable();
    public bool get_IsVolatile();
    public sealed virtual bool get_IsReference();
    public virtual void ConfigureNillable(bool nillable);
    public void ConfigureVolatile(bool isVolatile);
    public virtual void ConfigureReference(bool isReference);
    public virtual void Prepare();
    protected IXmlContext CloneContext();
    private void SetContext(IXmlContext value);
    public virtual bool IsPropertyDefined(IXmlNode parentNode);
    public virtual object GetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    public sealed virtual object GetValue(IXmlNode node, IDictionaryAdapter parentObject, XmlReferenceManager references, bool nodeExists, bool orStub);
    private object GetValueCore(IXmlNode node, IDictionaryAdapter parentObject, bool nodeExists, bool orStub);
    public virtual void SetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, object oldValue, Object& value);
    public virtual void SetValue(IXmlCursor cursor, IDictionaryAdapter parentObject, XmlReferenceManager references, bool hasCurrent, object oldValue, Object& newValue);
    private void Coerce(IXmlCursor cursor, Type clrType, bool replace);
    public sealed virtual void GetCollectionItems(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, IList values);
    protected void RemoveCollectionItems(IXmlNode parentNode, XmlReferenceManager references, object value);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    protected IXmlCollectionAccessor GetDefaultCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode parentNode, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode parentNode, bool mutable);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode parentNode, bool mutable);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlAccessorFactory`1 : MulticastDelegate {
    public XmlAccessorFactory`1(object object, IntPtr method);
    public virtual TAccessor Invoke(string name, Type type, IXmlContext context);
    public virtual IAsyncResult BeginInvoke(string name, Type type, IXmlContext context, AsyncCallback callback, object object);
    public virtual TAccessor EndInvoke(IAsyncResult result);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlAdapter : DictionaryBehaviorAttribute {
    private IXmlNode node;
    private object source;
    private XmlReferenceManager references;
    private XmlMetadata primaryXmlMeta;
    private Dictionary`2<Type, XmlMetadata> secondaryXmlMetas;
    private bool isRoot;
    [CompilerGeneratedAttribute]
private EventHandler Realized;
    public bool IsReal { get; }
    public IXmlNode Node { get; }
    internal XmlReferenceManager References { get; }
    public XmlAdapter(XmlNode node);
    public XmlAdapter(IXmlNode node, XmlReferenceManager references);
    public sealed virtual bool get_IsReal();
    public sealed virtual IXmlNode get_Node();
    internal XmlReferenceManager get_References();
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryCreateStrategy.Create(IDictionaryAdapter parent, Type type, IDictionary dictionary);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
    private void InitializePrimary(DictionaryAdapterMeta meta, IDictionaryAdapter dictionaryAdapter);
    private void InitializeSecondary(DictionaryAdapterMeta meta);
    private void InitializeBaseTypes(DictionaryAdapterMeta meta);
    private void InitializeStrategies(IDictionaryAdapter dictionaryAdapter);
    private void InitializeReference(object value);
    private void AddSecondaryXmlMeta(DictionaryAdapterMeta meta);
    private static void RequireXmlMeta(DictionaryAdapterMeta meta);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryCopyStrategy.Copy(IDictionaryAdapter source, IDictionaryAdapter target, Func`2& selector);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    private static string EnsureKey(string key, PropertyDescriptor property);
    private IXmlNode GetBaseNode();
    private IXmlNode GetSourceNode();
    private bool TryGetAccessor(string key, PropertyDescriptor property, bool requireVolatile, XmlAccessor& accessor);
    private XmlAccessor CreateAccessor(string key, PropertyDescriptor property);
    private bool TryApplyBehavior(string key, PropertyDescriptor property, object behavior, XmlAccessor& accessor);
    private bool TryApplyBehavior(string key, PropertyDescriptor property, object behavior, XmlAccessor& accessor, XmlAccessorFactory`1<TAccessor> factory);
    private TAccessor CreateAccessor(string key, PropertyDescriptor property, XmlAccessorFactory`1<TAccessor> factory);
    private XmlMetadata GetXmlMetadata(Type type);
    private static bool IsIgnoreBehavior(object behavior);
    private static bool IsVolatileBehavior(object behavior);
    private static bool IsReferenceBehavior(object behavior);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual.Realize();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Realized(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
    private void HandleNodeRealized(object sender, EventArgs e);
    private void AttachObservers(object value, IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);
    private void HandleListChanged(object value, ListChangedEventArgs args, IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryReferenceManager.IsReferenceProperty(IDictionaryAdapter dictionaryAdapter, string propertyName);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryReferenceManager.TryGetReference(object keyObject, Object& inGraphObject);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryReferenceManager.AddReference(object keyObject, object relatedObject, bool isInGraph);
    public virtual IDictionaryBehavior Copy();
    public static XmlAdapter For(object obj);
    public static XmlAdapter For(object obj, bool required);
    public static bool IsPropertyDefined(string propertyName, IDictionaryAdapter dictionaryAdapter);
    public bool HasProperty(string propertyName, IDictionaryAdapter dictionaryAdapter);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlArrayBehaviorAccessor : XmlNodeAccessor {
    private ItemAccessor itemAccessor;
    internal static XmlAccessorFactory`1<XmlArrayBehaviorAccessor> Factory;
    private static CursorFlags PropertyFlags;
    private static CursorFlags CollectionItemFlags;
    public XmlArrayBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlArrayBehaviorAccessor();
    public sealed virtual void Configure(XmlArrayAttribute attribute);
    public sealed virtual void Configure(XmlArrayItemAttribute attribute);
    public virtual void Prepare();
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlArraySerializer : XmlTypeSerializer {
    public static XmlArraySerializer Instance;
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    private static XmlArraySerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
    private static object GetItemSafe(Array array, int index);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlAttributeBehaviorAccessor : XmlNodeAccessor {
    internal static XmlAccessorFactory`1<XmlAttributeBehaviorAccessor> Factory;
    public XmlAttributeBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlAttributeBehaviorAccessor();
    public sealed virtual void Configure(XmlAttributeAttribute attribute);
    public virtual void ConfigureNillable(bool nillable);
    public virtual void ConfigureReference(bool isReference);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.Xml.XmlCollectionAdapter`1 : object {
    private List`1<XmlCollectionItem`1<T>> items;
    private List`1<XmlCollectionItem`1<T>> snapshot;
    private ICollectionAdapterObserver`1<T> advisor;
    private IXmlCursor cursor;
    private IXmlCollectionAccessor accessor;
    private IXmlNode parentNode;
    private IDictionaryAdapter parentObject;
    private XmlReferenceManager references;
    public IXmlNode Node { get; }
    public XmlReferenceManager References { get; }
    public int Count { get; }
    public T Item { get; public set; }
    public IEqualityComparer`1<T> Comparer { get; }
    public bool HasSnapshot { get; }
    public int SnapshotCount { get; }
    public XmlCollectionAdapter`1(IXmlNode parentNode, IDictionaryAdapter parentObject, IXmlCollectionAccessor accessor);
    public sealed virtual IXmlNode get_Node();
    public XmlReferenceManager get_References();
    public sealed virtual int get_Count();
    public sealed virtual void Initialize(ICollectionAdapterObserver`1<T> advisor);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual T AddNew();
    public sealed virtual bool Add(T value);
    public sealed virtual bool Insert(int index, T value);
    private bool InsertCore(int index, T value, bool append);
    private bool CommitInsert(int index, IXmlNode node, T value, bool append);
    private bool RollbackInsert();
    public sealed virtual void Remove(int index);
    public sealed virtual void Clear();
    public sealed virtual void ClearReferences();
    private void OnRemoving(XmlCollectionItem`1<T> item);
    private T GetValue(IXmlNode node);
    private void SetValue(IXmlCursor cursor, object oldValue, T& value);
    private static Type GetTypeOrDefault(T value);
    public sealed virtual IEqualityComparer`1<T> get_Comparer();
    public sealed virtual bool get_HasSnapshot();
    public sealed virtual int get_SnapshotCount();
    public sealed virtual T GetCurrentItem(int index);
    public sealed virtual T GetSnapshotItem(int index);
    public sealed virtual void SaveSnapshot();
    public sealed virtual void LoadSnapshot();
    public sealed virtual void DropSnapshot();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlCollectionItem`1 : ValueType {
    public IXmlNode Node;
    public T Value;
    public bool HasValue;
    public XmlCollectionItem`1(IXmlNode node);
    public XmlCollectionItem`1(IXmlNode node, T value);
    private XmlCollectionItem`1(IXmlNode node, T value, bool hasValue);
    public XmlCollectionItem`1<T> WithValue(T value);
}
public abstract class Castle.Components.DictionaryAdapter.Xml.XmlCollectionSerializer : XmlTypeSerializer {
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    public Type ListTypeConstructor { get; }
    public virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public abstract virtual Type get_ListTypeConstructor();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    private object GetValueCore(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlComponentSerializer : XmlTypeSerializer {
    public static XmlComponentSerializer Instance;
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    private static XmlComponentSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlContext : XmlContextBase {
    private XmlMetadata metadata;
    public string ChildNamespaceUri { get; }
    public XmlContext(XmlMetadata metadata);
    protected XmlContext(XmlContext parent);
    public sealed virtual IXmlContext Clone();
    public sealed virtual string get_ChildNamespaceUri();
    public sealed virtual bool IsReservedNamespaceUri(string namespaceUri);
    public sealed virtual XmlName GetDefaultXsiType(Type clrType);
    public sealed virtual IEnumerable`1<IXmlIncludedType> GetIncludedTypes(Type baseType);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlContextBase : XsltContext {
    private XmlContextBase parent;
    private Dictionary`2<string, string> rootNamespaces;
    private bool hasNamespaces;
    private XPathContext xPathContext;
    private Dictionary`2<XmlName, IXsltContextVariable> variables;
    private Dictionary`2<XmlName, IXsltContextFunction> functions;
    private XPathContext XPathContext { get; }
    public bool Whitespace { get; }
    protected XmlContextBase(XmlContextBase parent);
    private static NameTable GetNameTable(XmlContextBase parent);
    public void AddNamespace(XmlNamespaceAttribute attribute);
    public virtual void AddNamespace(string prefix, string uri);
    private Dictionary`2<string, string> EnsureRootNamespaces();
    public virtual string LookupNamespace(string prefix);
    public virtual string LookupPrefix(string uri);
    public sealed virtual string GetElementPrefix(IXmlNode node, string namespaceUri);
    public sealed virtual string GetAttributePrefix(IXmlNode node, string namespaceUri);
    private static bool TryGetDefinedPrefix(IXmlNode node, string namespaceUri, String& prefix);
    private bool TryGetPreferredPrefix(IXmlNode node, string namespaceUri, String& prefix);
    private static string GeneratePrefix(IXmlNode node);
    private bool ShouldDefineOnRoot(string prefix, string uri);
    private bool ShouldDefineOnRootCore(string prefix, string uri);
    private XPathContext get_XPathContext();
    public virtual bool get_Whitespace();
    public virtual bool PreserveWhitespace(XPathNavigator node);
    public virtual int CompareDocument(string baseUriA, string baseUriB);
    public void AddVariable(string prefix, string name, IXsltContextVariable variable);
    public void AddFunction(string prefix, string name, IXsltContextFunction function);
    public sealed virtual void AddVariable(XPathVariableAttribute attribute);
    public sealed virtual void AddFunction(XPathFunctionAttribute attribute);
    public void AddVariable(XmlName name, IXsltContextVariable variable);
    public void AddFunction(XmlName name, IXsltContextFunction function);
    private Dictionary`2<XmlName, IXsltContextVariable> EnsureVariables();
    private Dictionary`2<XmlName, IXsltContextFunction> EnsureFunctions();
    public virtual IXsltContextVariable ResolveVariable(string prefix, string name);
    public virtual IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes);
    private IXsltContextVariable ResolveVariableCore(string prefix, string name);
    private IXsltContextFunction ResolveFunctionCore(string prefix, string name, XPathResultType[] argTypes);
    public sealed virtual void Enlist(CompiledXPath path);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlCustomSerializer : XmlTypeSerializer {
    public static XmlCustomSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlCustomSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlDefaultBehaviorAccessor : XmlNodeAccessor {
    internal static XmlAccessorFactory`1<XmlDefaultBehaviorAccessor> Factory;
    public XmlDefaultBehaviorAccessor(Type type, IXmlContext context);
    public XmlDefaultBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlDefaultBehaviorAccessor();
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode node, bool mutable);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlDefaultSerializer : XmlTypeSerializer {
    private XmlSerializer serializer;
    public static XmlRootAttribute Root;
    public XmlTypeKind Kind { get; }
    public XmlDefaultSerializer(Type type);
    private static XmlDefaultSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlDynamicSerializer : XmlTypeSerializer {
    public static XmlDynamicSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlDynamicSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlElementBehaviorAccessor : XmlNodeAccessor {
    private ItemAccessor itemAccessor;
    private List`1<XmlElementAttribute> attributes;
    internal static XmlAccessorFactory`1<XmlElementBehaviorAccessor> Factory;
    public XmlElementBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlElementBehaviorAccessor();
    public sealed virtual void Configure(XmlElementAttribute attribute);
    public virtual void Prepare();
    public virtual void SetValue(IXmlCursor cursor, IDictionaryAdapter parentObject, XmlReferenceManager references, bool hasCurrent, object oldValue, Object& newValue);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    public sealed virtual string GetLocalName(XmlElementAttribute attribute);
    public sealed virtual string GetNamespaceUri(XmlElementAttribute attribute);
    public sealed virtual Type GetClrType(XmlElementAttribute attribute);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlEnumerationSerializer : XmlStringSerializer {
    public static XmlEnumerationSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlEnumerationSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XmlExtensions : object {
    [ExtensionAttribute]
public static bool PositionEquals(IXmlNode nodeA, IXmlNode nodeB);
    [ExtensionAttribute]
public static void CopyTo(IXmlNode source, IXmlNode target);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlIgnoreBehaviorAccessor : XmlAccessor {
    public static XmlIgnoreBehaviorAccessor Instance;
    public bool IsIgnored { get; }
    private static XmlIgnoreBehaviorAccessor();
    public virtual bool get_IsIgnored();
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode node, bool mutable);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlIncludedType : object {
    private XmlName xsiType;
    private Type clrType;
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public XmlIncludedType(XmlName xsiType, Type clrType);
    public XmlIncludedType(string localName, string namespaceUri, Type clrType);
    public sealed virtual XmlName get_XsiType();
    public sealed virtual Type get_ClrType();
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.XmlIncludedTypeMapExtensions : object {
    [ExtensionAttribute]
public static IXmlIncludedType Require(IXmlIncludedTypeMap includedTypes, Type clrType);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlIncludedTypeSet : object {
    private Dictionary`2<XmlName, IXmlIncludedType> itemsByXsiType;
    private Dictionary`2<Type, IXmlIncludedType> itemsByClrType;
    public static IList`1<IXmlIncludedType> DefaultEntries;
    private IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.Default { get; }
    private static XmlIncludedTypeSet();
    private sealed virtual override IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.get_Default();
    public void Add(IXmlIncludedType includedType);
    public sealed virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public sealed virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
    public sealed virtual IEnumerator`1<IXmlIncludedType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Castle.Components.DictionaryAdapter.Xml.XmlKnownType : object {
    private XmlName name;
    private XmlName xsiType;
    private Type clrType;
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public XmlKnownType(XmlName name, XmlName xsiType, Type clrType);
    public XmlKnownType(string nameLocalName, string nameNamespaceUri, string xsiTypeLocalName, string xsiTypeNamespaceUri, Type clrType);
    public sealed virtual XmlName get_Name();
    public sealed virtual XmlName get_XsiType();
    public sealed virtual Type get_ClrType();
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.XmlKnownTypeMapExtensions : object {
    [ExtensionAttribute]
public static IXmlKnownType Require(IXmlKnownTypeMap map, Type clrType);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlKnownTypeSet : object {
    private Dictionary`2<IXmlIdentity, IXmlKnownType> itemsByXmlIdentity;
    private Dictionary`2<Type, IXmlKnownType> itemsByClrType;
    private Type defaultType;
    private static StringComparer NameComparer;
    private static XmlNameComparer XsiTypeComparer;
    public IXmlKnownType Default { get; }
    public XmlKnownTypeSet(Type defaultType);
    private static XmlKnownTypeSet();
    public sealed virtual IXmlKnownType get_Default();
    public void Add(IXmlKnownType knownType, bool overwrite);
    public void AddXsiTypeDefaults();
    public sealed virtual bool TryGet(IXmlIdentity xmlIdentity, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
    public IXmlKnownType[] ToArray();
    public sealed virtual IEnumerator`1<IXmlKnownType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Castle.Components.DictionaryAdapter.Xml.XmlListSerializer : XmlCollectionSerializer {
    public static XmlListSerializer Instance;
    public Type ListTypeConstructor { get; }
    private static XmlListSerializer();
    public virtual Type get_ListTypeConstructor();
}
public class Castle.Components.DictionaryAdapter.Xml.XmlMetadata : object {
    private Type clrType;
    private Nullable`1<bool> qualified;
    private Nullable`1<bool> isNullable;
    private Nullable`1<bool> isReference;
    private string rootLocalName;
    private string rootNamespaceUri;
    private string childNamespaceUri;
    private string typeLocalName;
    private string typeNamespaceUri;
    private HashSet`1<string> reservedNamespaceUris;
    private List`1<Type> pendingIncludes;
    private XmlIncludedTypeSet includedTypes;
    private XmlContext context;
    private DictionaryAdapterMeta source;
    private CompiledXPath path;
    protected static StringComparer NameComparer;
    private static CursorFlags RootFlags;
    public Type ClrType { get; }
    public Nullable`1<bool> Qualified { get; }
    public Nullable`1<bool> IsNullable { get; }
    public Nullable`1<bool> IsReference { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    private XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.XsiType { get; }
    public string ChildNamespaceUri { get; }
    public IEnumerable`1<string> ReservedNamespaceUris { get; }
    public XmlIncludedTypeSet IncludedTypes { get; }
    public IXmlContext Context { get; }
    public CompiledXPath Path { get; }
    private IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.Default { get; }
    private IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.Default { get; }
    public XmlMetadata(DictionaryAdapterMeta meta, IEnumerable`1<string> reservedNamespaceUris);
    private static XmlMetadata();
    public sealed virtual Type get_ClrType();
    public Nullable`1<bool> get_Qualified();
    public Nullable`1<bool> get_IsNullable();
    public Nullable`1<bool> get_IsReference();
    public sealed virtual XmlName get_Name();
    public sealed virtual XmlName get_XsiType();
    private sealed virtual override XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.get_XsiType();
    public string get_ChildNamespaceUri();
    public IEnumerable`1<string> get_ReservedNamespaceUris();
    public XmlIncludedTypeSet get_IncludedTypes();
    public IXmlContext get_Context();
    public CompiledXPath get_Path();
    private sealed virtual override IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.get_Default();
    private sealed virtual override IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.get_Default();
    public bool IsReservedNamespaceUri(string namespaceUri);
    public IXmlCursor SelectBase(IXmlNode node);
    private bool IsMatch(IXmlIdentity xmlIdentity);
    private bool IsMatch(Type clrType);
    public sealed virtual bool TryGet(IXmlIdentity xmlIdentity, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public sealed virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
    private void AddPendingInclude(XmlIncludeAttribute attribute);
    private void ProcessPendingIncludes();
    public XmlName GetDefaultXsiType(Type clrType);
    [IteratorStateMachineAttribute("Castle.Components.DictionaryAdapter.Xml.XmlMetadata/<GetIncludedTypes>d__55")]
public IEnumerable`1<IXmlIncludedType> GetIncludedTypes(Type baseType);
    private bool TryGetXmlMetadata(Type clrType, XmlMetadata& metadata);
    private XmlMetadata GetXmlMetadata(Type clrType);
    private string GetDefaultTypeLocalName(Type clrType);
    private static bool IsInterfaceName(string name);
    private static bool TryCast(object obj, T& result);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlMetadataBehavior : DictionaryBehaviorAttribute {
    public static XmlMetadataBehavior Default;
    private HashSet`1<string> reservedNamespaceUris;
    public IEnumerable`1<string> ReservedNamespaceUris { get; }
    private static XmlMetadataBehavior();
    public IEnumerable`1<string> get_ReservedNamespaceUris();
    public XmlMetadataBehavior AddReservedNamespaceUri(string uri);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.Initialize(IDictionaryAdapterFactory factory, DictionaryAdapterMeta meta);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.ShouldHaveBehavior(object behavior);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlName : ValueType {
    public static XmlName Empty;
    private string localName;
    private string namespaceUri;
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public XmlName(string localName, string namespaceUri);
    public string get_LocalName();
    public string get_NamespaceUri();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(XmlName other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(XmlName x, XmlName y);
    public static bool op_Inequality(XmlName x, XmlName y);
    public XmlName WithNamespaceUri(string namespaceUri);
    public virtual string ToString();
    public static XmlName ParseQName(string text);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlNameComparer : object {
    public static XmlNameComparer Default;
    public static XmlNameComparer IgnoreCase;
    private StringComparer comparer;
    private XmlNameComparer(StringComparer comparer);
    private static XmlNameComparer();
    public sealed virtual int GetHashCode(XmlName name);
    public sealed virtual bool Equals(XmlName x, XmlName y);
}
public abstract class Castle.Components.DictionaryAdapter.Xml.XmlNodeAccessor : XmlAccessor {
    private string localName;
    private string namespaceUri;
    private XmlKnownTypeSet knownTypes;
    protected static StringComparer NameComparer;
    public XmlName Name { get; }
    private XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.XsiType { get; }
    protected IXmlKnownTypeMap KnownTypes { get; }
    private IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.Default { get; }
    protected XmlNodeAccessor(Type type, IXmlContext context);
    protected XmlNodeAccessor(string name, Type type, IXmlContext context);
    private static XmlNodeAccessor();
    public sealed virtual XmlName get_Name();
    private sealed virtual override XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.get_XsiType();
    protected IXmlKnownTypeMap get_KnownTypes();
    private sealed virtual override IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.get_Default();
    public sealed virtual bool TryGet(IXmlIdentity xmlName, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
    protected virtual bool IsMatch(IXmlIdentity xmlIdentity);
    private bool IsMatchOnNamespaceUri(IXmlIdentity xmlIdentity);
    private bool IsMatchOnXsiType(IXmlIdentity xmlIdentity);
    private bool ShouldIgnoreAttributeNamespaceUri(IXmlIdentity xmlName);
    protected virtual bool IsMatch(Type clrType);
    protected void ConfigureLocalName(string localName);
    protected void ConfigureNamespaceUri(string namespaceUri);
    private void ConfigureField(String& field, string value, States mask);
    protected void ConfigureKnownTypesFromParent(XmlNodeAccessor accessor);
    protected void ConfigureKnownTypesFromAttributes(IEnumerable`1<T> attributes, IXmlBehaviorSemantics`1<T> semantics);
    public virtual void Prepare();
    private void ConfigureDefaultAndIncludedTypes();
    private void ConfigureIncludedTypes(IXmlKnownType knownType);
    private void AddKnownType(XmlName name, XmlName xsiType, Type clrType, bool overwrite);
    private void AddSelfAsKnownType();
}
public abstract class Castle.Components.DictionaryAdapter.Xml.XmlNodeBase : object {
    protected Type type;
    private IXmlNode parent;
    private IXmlNamespaceSource namespaces;
    public bool IsReal { get; }
    public Type ClrType { get; }
    public IXmlNode Parent { get; }
    public IXmlNamespaceSource Namespaces { get; }
    public CompiledXPath Path { get; }
    protected XmlNodeBase(IXmlNamespaceSource namespaces, IXmlNode parent);
    public virtual bool get_IsReal();
    public virtual Type get_ClrType();
    public sealed virtual IXmlNode get_Parent();
    public sealed virtual IXmlNamespaceSource get_Namespaces();
    public virtual CompiledXPath get_Path();
    private sealed virtual override IRealizable`1<T> Castle.Components.DictionaryAdapter.Xml.IRealizableSource.AsRealizable();
    protected virtual void Realize();
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual.Realize();
    public virtual void add_Realized(EventHandler value);
    public virtual void remove_Realized(EventHandler value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlNodeList`1 : ListProjection`1<T> {
    public IXmlNode Node { get; }
    public XmlNodeList`1(IXmlNode parentNode, IDictionaryAdapter parentObject, IXmlCollectionAccessor accessor);
    public sealed virtual IXmlNode get_Node();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlNodeSet`1 : SetProjection`1<T> {
    public IXmlNode Node { get; }
    public XmlNodeSet`1(IXmlNode parentNode, IDictionaryAdapter parentObject, IXmlCollectionAccessor accessor);
    public sealed virtual IXmlNode get_Node();
}
public static class Castle.Components.DictionaryAdapter.Xml.Xmlns : object {
    public static string Prefix;
    public static string NamespaceUri;
}
public class Castle.Components.DictionaryAdapter.Xml.XmlPositionComparer : object {
    public static XmlPositionComparer Instance;
    private static XmlPositionComparer();
    public bool Equals(IXmlNode nodeA, IXmlNode nodeB);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlReferenceManager : object {
    private Dictionary`2<int, Entry> entriesById;
    private WeakKeyDictionary`2<object, Entry> entriesByValue;
    private IXmlReferenceFormat format;
    private int nextId;
    private static Type StringType;
    private static object CreateEntryToken;
    public XmlReferenceManager(IXmlNode root, IXmlReferenceFormat format);
    private static XmlReferenceManager();
    private void Populate(IXmlNode node);
    private void PopulateFromNode(IXmlIterator node, ICollection`1<Reference> references);
    private void PopulateIdentity(int id, IXmlNode node);
    private void PopulateReference(int id, IXmlNode node, ICollection`1<Reference> references);
    private void PopulateDeferredReferences(ICollection`1<Reference> references);
    public bool TryGet(object keyObject, Object& inGraphObject);
    public void Add(IXmlNode node, object keyValue, object newValue, bool isInGraph);
    public bool OnGetStarting(IXmlNode& node, Object& value, Object& token);
    public void OnGetCompleted(IXmlNode node, object value, object token);
    public bool OnAssigningNull(IXmlNode node, object oldValue);
    public bool OnAssigningValue(IXmlNode node, object oldValue, Object& newValue, Object& token);
    private bool ShouldAssignmentProceed(Entry oldEntry, Entry newEntry, object token);
    private Entry OnReplacingValue(IXmlNode node, object oldValue);
    public void OnAssignedValue(IXmlNode node, object givenValue, object storedValue, object token);
    private void AddReference(IXmlNode node, Entry entry);
    private void GenerateId(Entry entry);
    private void AddValue(Entry entry, Type type, object value, XmlAdapter xmlAdapter);
    private void AddValueCore(Entry entry, Type type, object value, bool isInGraph);
    private void ClearReference(Entry entry, IXmlNode node);
    private void PrepareForReuse(Entry entry);
    private bool TryGetEntry(IXmlNode node, Entry& entry, Boolean& reference);
    private bool TryGetCompatibleValue(Entry entry, Type type, Object& value);
    private static void SetNotInGraph(Entry entry, object value);
    private static bool ShouldExclude(Type type);
    private static void SetNotInGraphCore(Entry entry, object value);
    private static IXmlNode RedirectNode(IXmlNode& node, Entry entry);
    public void UnionWith(XmlReferenceManager other);
    private static Exception IdNotFoundError(int id);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlSelfAccessor : XmlAccessor {
    internal static XmlAccessorFactory`1<XmlSelfAccessor> Factory;
    public XmlSelfAccessor(Type clrType, IXmlContext context);
    private static XmlSelfAccessor();
    public virtual void ConfigureNillable(bool nillable);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode parentNode, bool mutable);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlSelfCursor : object {
    private IXmlNode node;
    private Type clrType;
    private int position;
    public CursorFlags Flags { get; }
    public CompiledXPath Path { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public bool IsReal { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public IXmlNode Parent { get; }
    public IXmlNamespaceSource Namespaces { get; }
    public object UnderlyingObject { get; }
    public XmlSelfCursor(IXmlNode node, Type clrType);
    public CursorFlags get_Flags();
    public sealed virtual CompiledXPath get_Path();
    public sealed virtual XmlName get_Name();
    public sealed virtual XmlName get_XsiType();
    public sealed virtual Type get_ClrType();
    public sealed virtual bool get_IsReal();
    public sealed virtual bool get_IsElement();
    public sealed virtual bool get_IsAttribute();
    public sealed virtual bool get_IsNil();
    public sealed virtual void set_IsNil(bool value);
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    public sealed virtual string get_Xml();
    public sealed virtual IXmlNode get_Parent();
    public sealed virtual IXmlNamespaceSource get_Namespaces();
    public sealed virtual object get_UnderlyingObject();
    public sealed virtual bool UnderlyingPositionEquals(IXmlNode node);
    public sealed virtual IRealizable`1<T> AsRealizable();
    public sealed virtual void Realize();
    public sealed virtual void add_Realized(EventHandler value);
    public sealed virtual void remove_Realized(EventHandler value);
    public sealed virtual string GetAttribute(XmlName name);
    public sealed virtual void SetAttribute(XmlName name, string value);
    public sealed virtual string LookupPrefix(string namespaceUri);
    public sealed virtual string LookupNamespaceUri(string prefix);
    public sealed virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    public sealed virtual bool MoveNext();
    public sealed virtual void MoveToEnd();
    public sealed virtual void Reset();
    public sealed virtual void MoveTo(IXmlNode position);
    public sealed virtual IXmlNode Save();
    public sealed virtual IXmlCursor SelectSelf(Type clrType);
    public sealed virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual IXmlIterator SelectSubtree();
    public sealed virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual object Evaluate(CompiledXPath path);
    public sealed virtual XmlReader ReadSubtree();
    public sealed virtual XmlWriter WriteAttributes();
    public sealed virtual XmlWriter WriteChildren();
    public void MakeNext(Type type);
    public sealed virtual void Create(Type type);
    public sealed virtual void Coerce(Type type);
    public sealed virtual void Clear();
    public sealed virtual void Remove();
    public sealed virtual void RemoveAllNext();
}
public class Castle.Components.DictionaryAdapter.Xml.XmlSetSerializer : XmlCollectionSerializer {
    public static XmlSetSerializer Instance;
    public Type ListTypeConstructor { get; }
    private static XmlSetSerializer();
    public virtual Type get_ListTypeConstructor();
}
public static class Castle.Components.DictionaryAdapter.Xml.XmlSimpleSerializer : object {
    public static XmlTypeSerializer ForBoolean;
    public static XmlTypeSerializer ForChar;
    public static XmlTypeSerializer ForSByte;
    public static XmlTypeSerializer ForInt16;
    public static XmlTypeSerializer ForInt32;
    public static XmlTypeSerializer ForInt64;
    public static XmlTypeSerializer ForByte;
    public static XmlTypeSerializer ForUInt16;
    public static XmlTypeSerializer ForUInt32;
    public static XmlTypeSerializer ForUInt64;
    public static XmlTypeSerializer ForSingle;
    public static XmlTypeSerializer ForDouble;
    public static XmlTypeSerializer ForDecimal;
    public static XmlTypeSerializer ForTimeSpan;
    public static XmlTypeSerializer ForDateTime;
    public static XmlTypeSerializer ForDateTimeOffset;
    public static XmlTypeSerializer ForGuid;
    public static XmlTypeSerializer ForByteArray;
    public static XmlTypeSerializer ForUri;
    private static XmlSimpleSerializer();
    private static string XmlConvert_ToString(DateTime value);
    private static DateTime XmlConvert_ToDateTime(string value);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlSimpleSerializer`1 : XmlTypeSerializer {
    private Func`2<T, string> getString;
    private Func`2<string, T> getObject;
    public XmlTypeKind Kind { get; }
    public XmlSimpleSerializer`1(Func`2<T, string> getString, Func`2<string, T> getObject);
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlStringSerializer : XmlTypeSerializer {
    public static XmlStringSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlStringSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlSubtreeReader : XmlReader {
    private string rootLocalName;
    private string rootNamespaceURI;
    private string underlyingNamespaceURI;
    private XmlReader reader;
    public bool IsDisposed { get; }
    protected XmlReader Reader { get; }
    public ReadState ReadState { get; }
    public int Depth { get; }
    public XmlNodeType NodeType { get; }
    public bool IsAtRootElement { get; }
    public bool EOF { get; }
    public string Prefix { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Value { get; }
    public bool IsEmptyElement { get; }
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlSubtreeReader(IXmlNode node, XmlRootAttribute root);
    public XmlSubtreeReader(IXmlNode node, string rootLocalName, string rootNamespaceUri);
    protected virtual void Dispose(bool managed);
    private void DisposeReader();
    public bool get_IsDisposed();
    private void RequireNotDisposed();
    protected XmlReader get_Reader();
    public virtual ReadState get_ReadState();
    public virtual int get_Depth();
    public virtual XmlNodeType get_NodeType();
    public bool get_IsAtRootElement();
    public virtual bool get_EOF();
    public virtual string get_Prefix();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    private string CaptureNamespaceUri();
    private string TranslateNamespaceURI();
    public virtual string get_Value();
    public virtual bool get_IsEmptyElement();
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual XmlNameTable get_NameTable();
    public virtual bool Read();
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual bool ReadAttributeValue();
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string LookupNamespace(string prefix);
    public virtual void ResolveEntity();
    public virtual void Close();
}
public class Castle.Components.DictionaryAdapter.Xml.XmlSubtreeWriter : XmlWriter {
    private IXmlNode node;
    private XmlWriter rootWriter;
    private XmlWriter childWriter;
    private WriteState state;
    private int depth;
    private XmlWriter RootWriter { get; }
    private XmlWriter ChildWriter { get; }
    private bool IsInRootAttribute { get; }
    private bool IsInRoot { get; }
    private bool IsInChild { get; }
    public WriteState WriteState { get; }
    public XmlSubtreeWriter(IXmlNode node);
    protected virtual void Dispose(bool managed);
    private void DisposeWriter(XmlWriter& writer);
    private XmlWriter get_RootWriter();
    private XmlWriter get_ChildWriter();
    private bool get_IsInRootAttribute();
    private bool get_IsInRoot();
    private bool get_IsInChild();
    public virtual WriteState get_WriteState();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartDocument();
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    private void WriteEndElement(Action`1<XmlWriter> action);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    private void WriteAttribute(Action`1<XmlWriter> action, WriteState entryState, WriteState exitState);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    private void WriteElementOrAttributeContent(Action`1<XmlWriter> action);
    public virtual void WriteString(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    private void WriteElementContent(Action`1<XmlWriter> action);
    public virtual void WriteCData(string text);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void WithWriters(Action`1<XmlWriter> action, bool worksIfClosed, Nullable`1<WriteState> resetTo);
    public virtual void Flush();
    public virtual void WriteEndDocument();
    public virtual void Close();
    public virtual string LookupPrefix(string ns);
    private void RequireNotClosed();
    private void RequireState(WriteState state);
    private void RequireState(WriteState state1, WriteState state2);
    private void Reset(WriteState state);
}
public enum Castle.Components.DictionaryAdapter.Xml.XmlTypeKind : Enum {
    public int value__;
    public static XmlTypeKind Simple;
    public static XmlTypeKind Complex;
    public static XmlTypeKind Collection;
}
public abstract class Castle.Components.DictionaryAdapter.Xml.XmlTypeSerializer : object {
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    public abstract virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public abstract virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public abstract virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
    public static XmlTypeSerializer For(Type type);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlTypeSerializerCache : SingletonDispenser`2<Type, XmlTypeSerializer> {
    public static XmlTypeSerializerCache Instance;
    private static XmlTypeSerializerCache();
    private static XmlTypeSerializer CreateSerializer(Type type);
}
public class Castle.Components.DictionaryAdapter.Xml.XmlXmlNodeSerializer : XmlTypeSerializer {
    public static XmlXmlNodeSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlXmlNodeSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.Xml.XPathAttribute : Attribute {
    private CompiledXPath getPath;
    private CompiledXPath setPath;
    [CompilerGeneratedAttribute]
private bool <Nullable>k__BackingField;
    public CompiledXPath GetPath { get; }
    public CompiledXPath SetPath { get; }
    public bool Nullable { get; public set; }
    public XPathAttribute(string path);
    public XPathAttribute(string get, string set);
    public CompiledXPath get_GetPath();
    public CompiledXPath get_SetPath();
    [CompilerGeneratedAttribute]
public bool get_Nullable();
    [CompilerGeneratedAttribute]
public void set_Nullable(bool value);
}
public class Castle.Components.DictionaryAdapter.Xml.XPathBehaviorAccessor : XmlAccessor {
    private CompiledXPath path;
    private XmlIncludedTypeSet includedTypes;
    private XmlAccessor defaultAccessor;
    private XmlAccessor itemAccessor;
    internal static XmlAccessorFactory`1<XPathBehaviorAccessor> Factory;
    private XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIncludedType.XsiType { get; }
    private IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.Default { get; }
    private bool SelectsNodes { get; }
    private bool CreatesAttributes { get; }
    protected XPathBehaviorAccessor(Type type, IXmlContext context);
    private static XPathBehaviorAccessor();
    private sealed virtual override XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIncludedType.get_XsiType();
    private sealed virtual override IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.get_Default();
    private bool get_SelectsNodes();
    private bool get_CreatesAttributes();
    public sealed virtual void Configure(XPathAttribute attribute);
    public sealed virtual void Configure(XPathVariableAttribute attribute);
    public sealed virtual void Configure(XPathFunctionAttribute attribute);
    public virtual void Prepare();
    public virtual bool IsPropertyDefined(IXmlNode parentNode);
    public virtual object GetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    private object GetPropertyValueCore(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    private object GetDefaultPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    private object Evaluate(IXmlNode node);
    public virtual void SetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, object oldValue, Object& value);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool create);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool create);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode node, bool create);
    public sealed virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public sealed virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathBufferedNodeIterator : XPathNodeIterator {
    private IList`1<XPathNavigator> items;
    private int index;
    public int CurrentPosition { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public XPathNavigator Current { get; }
    public XPathBufferedNodeIterator(XPathNodeIterator iterator);
    private XPathBufferedNodeIterator(XPathBufferedNodeIterator iterator);
    public virtual int get_CurrentPosition();
    public virtual int get_Count();
    public bool get_IsEmpty();
    public virtual XPathNavigator get_Current();
    public void Reset();
    public virtual bool MoveNext();
    public void MoveToEnd();
    public virtual XPathNodeIterator Clone();
}
public static class Castle.Components.DictionaryAdapter.Xml.XPathCompiler : object {
    private static Func`1<CompiledXPathNode> NodeFactory;
    private static Func`1<CompiledXPathStep> StepFactory;
    private static XPathCompiler();
    public static CompiledXPath Compile(string path);
    private static bool ParsePath(Tokenizer source, CompiledXPath path);
    private static bool ParseStep(Tokenizer source, CompiledXPath path, CompiledXPathStep& step);
    private static bool ParseNodeCore(Tokenizer source, Func`1<TNode> factory, TNode& node);
    private static bool ParsePredicateList(Tokenizer source, CompiledXPathNode parent);
    private static bool ParsePredicate(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseAndExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseLeftToRightExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseRightToLeftExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseNestedPath(Tokenizer source, CompiledXPathNode parent, CompiledXPathNode& node);
    private static bool ParseNode(Tokenizer source, CompiledXPathNode parent, CompiledXPathNode& node);
    private static bool ParseValue(Tokenizer source, XPathExpression& value);
    private static bool ParseQualifiedName(Tokenizer source, CompiledXPathNode node);
    private static bool ParseName(Tokenizer source, String& name);
    private static bool Consume(Tokenizer source, Token token);
    private static void LinkNodes(CompiledXPathNode previous, CompiledXPathNode next);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathContext : XsltContext {
    private XsltContext context;
    public string DefaultNamespace { get; }
    public bool Whitespace { get; }
    public XPathContext(XsltContext xpathContext);
    public virtual string get_DefaultNamespace();
    public virtual string LookupNamespace(string prefix);
    public virtual bool get_Whitespace();
    public virtual bool PreserveWhitespace(XPathNavigator node);
    public virtual int CompareDocument(string baseUri, string nextbaseUri);
    public virtual IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes);
    public virtual IXsltContextVariable ResolveVariable(string prefix, string name);
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.XPathExtensions : object {
    [ExtensionAttribute]
public static XPathNavigator CreateNavigatorSafe(IXPathNavigable source);
    [ExtensionAttribute]
public static bool MoveToLastChild(XPathNavigator navigator);
    [ExtensionAttribute]
public static bool MoveToLastAttribute(XPathNavigator navigator);
    [ExtensionAttribute]
public static XPathNavigator GetRootElement(XPathNavigator navigator);
    [ExtensionAttribute]
public static XPathNavigator GetParent(XPathNavigator navigator);
    [ExtensionAttribute]
public static void DeleteChildren(XPathNavigator node);
}
[AttributeUsageAttribute("1152")]
public abstract class Castle.Components.DictionaryAdapter.Xml.XPathFunctionAttribute : Attribute {
    public static XPathResultType[] NoArgs;
    public XmlName Name { get; }
    public XPathResultType ReturnType { get; }
    public XPathResultType[] ArgTypes { get; }
    public int Maxargs { get; }
    public int Minargs { get; }
    private static XPathFunctionAttribute();
    public abstract virtual XmlName get_Name();
    public abstract virtual XPathResultType get_ReturnType();
    public virtual XPathResultType[] get_ArgTypes();
    public virtual int get_Maxargs();
    public virtual int get_Minargs();
    public abstract virtual object Invoke(XsltContext context, Object[] args, XPathNavigator node);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathMutableCursor : XPathNode {
    private XPathBufferedNodeIterator iterator;
    private CompiledXPathStep step;
    private int depth;
    private IXmlIncludedTypeMap knownTypes;
    private CursorFlags flags;
    [CompilerGeneratedAttribute]
private EventHandler Realized;
    public bool IsReal { get; }
    public bool HasCurrent { get; }
    public bool HasPartialOrCurrent { get; }
    public Type ClrType { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public XPathMutableCursor(IXmlNode parent, CompiledXPath path, IXmlIncludedTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public virtual bool get_IsReal();
    public bool get_HasCurrent();
    public bool get_HasPartialOrCurrent();
    public virtual Type get_ClrType();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public virtual object Evaluate(CompiledXPath path);
    public sealed virtual bool MoveNext();
    private bool SeekCurrent();
    private bool Consume(XPathNodeIterator iterator, bool multiple);
    private bool SetAtEnd();
    public sealed virtual void Reset();
    public sealed virtual void MoveToEnd();
    private void ResetCurrent();
    private void ResetDepth();
    private int Descend();
    public sealed virtual void MoveTo(IXmlNode position);
    [CompilerGeneratedAttribute]
public virtual void add_Realized(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
    protected virtual void Realize();
    public void MakeNext(Type clrType);
    public sealed virtual void Coerce(Type clrType);
    public sealed virtual void Create(Type type);
    private void Insert();
    private void Append();
    private void Complete();
    private XmlWriter CreateWriterForAppend();
    private void WriteNode(CompiledXPathNode node, XmlWriter writer);
    private void WriteAttribute(CompiledXPathNode node, XmlWriter writer);
    private void WriteSimpleElement(CompiledXPathNode node, XmlWriter writer);
    private void WriteComplexElement(CompiledXPathNode node, XmlWriter writer);
    private void WriteSubnodes(CompiledXPathNode parent, XmlWriter writer, bool attributes);
    private void WriteValue(CompiledXPathNode node, XmlWriter writer);
    private void SeekCurrentAfterCreate(bool moved);
    public sealed virtual void RemoveAllNext();
    public sealed virtual void Remove();
    public virtual IXmlNode Save();
    private void RequireRemovable();
    private void RequireMoved(bool result);
}
public class Castle.Components.DictionaryAdapter.Xml.XPathNode : XmlNodeBase {
    protected XPathNavigator node;
    protected CompiledXPath xpath;
    public object UnderlyingObject { get; }
    private XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.Value { get; }
    private XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.Value { get; }
    public CompiledXPath Path { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    protected XPathNode(CompiledXPath path, IXmlNamespaceSource namespaces, IXmlNode parent);
    public XPathNode(XPathNavigator node, Type type, IXmlNamespaceSource namespaces);
    public sealed virtual object get_UnderlyingObject();
    private sealed virtual override XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.get_Value();
    private sealed virtual override XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.get_Value();
    public virtual CompiledXPath get_Path();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public sealed virtual string GetAttribute(XmlName name);
    public sealed virtual void SetAttribute(XmlName name, string value);
    private void SetAttributeCore(XmlName name, string value);
    private void ClearAttribute(XmlName name);
    public sealed virtual string LookupPrefix(string namespaceUri);
    public sealed virtual string LookupNamespaceUri(string prefix);
    public sealed virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    public sealed virtual bool UnderlyingPositionEquals(IXmlNode node);
    public virtual IXmlNode Save();
    public sealed virtual IXmlCursor SelectSelf(Type clrType);
    public sealed virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual IXmlIterator SelectSubtree();
    public sealed virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public virtual object Evaluate(CompiledXPath path);
    public virtual XmlReader ReadSubtree();
    public virtual XmlWriter WriteAttributes();
    public virtual XmlWriter WriteChildren();
    public virtual void Clear();
}
public class Castle.Components.DictionaryAdapter.Xml.XPathReadOnlyCursor : XPathNode {
    private XPathNodeIterator iterator;
    private IXmlIncludedTypeMap includedTypes;
    private CursorFlags flags;
    public XPathReadOnlyCursor(IXmlNode parent, CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    private bool SetAtEnd();
    private bool SetAtNext();
    public sealed virtual void MoveTo(IXmlNode position);
    public sealed virtual void MoveToEnd();
    public void MakeNext(Type type);
    public sealed virtual void Create(Type type);
    public sealed virtual void Coerce(Type type);
    public sealed virtual void Remove();
    public sealed virtual void RemoveAllNext();
    public virtual IXmlNode Save();
}
[AttributeUsageAttribute("1152")]
public abstract class Castle.Components.DictionaryAdapter.Xml.XPathVariableAttribute : Attribute {
    public XmlName Name { get; }
    public XPathResultType VariableType { get; }
    private bool System.Xml.Xsl.IXsltContextVariable.IsLocal { get; }
    private bool System.Xml.Xsl.IXsltContextVariable.IsParam { get; }
    public abstract virtual XmlName get_Name();
    public abstract virtual XPathResultType get_VariableType();
    private sealed virtual override bool System.Xml.Xsl.IXsltContextVariable.get_IsLocal();
    private sealed virtual override bool System.Xml.Xsl.IXsltContextVariable.get_IsParam();
    public abstract virtual object Evaluate(XsltContext context);
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.XRef : object {
    public static string Prefix;
    public static string NamespaceUri;
    public static XmlName Id;
    public static XmlName Ref;
    internal static XmlNamespaceAttribute Namespace;
    private static XRef();
    [ExtensionAttribute]
public static string GetId(IXmlNode node);
    [ExtensionAttribute]
public static void SetId(IXmlCursor node, string id);
    [ExtensionAttribute]
public static string GetReference(IXmlNode node);
    [ExtensionAttribute]
public static void SetReference(IXmlCursor cursor, string id);
}
public static class Castle.Components.DictionaryAdapter.Xml.Xsd : object {
    public static string Prefix;
    public static string NamespaceUri;
    internal static XmlNamespaceAttribute Namespace;
    private static Xsd();
}
[ExtensionAttribute]
public static class Castle.Components.DictionaryAdapter.Xml.Xsi : object {
    public static string Prefix;
    public static string NamespaceUri;
    public static string NilValue;
    public static XmlName Type;
    public static XmlName Nil;
    internal static XmlNamespaceAttribute Namespace;
    private static Xsi();
    [ExtensionAttribute]
public static XmlName GetXsiType(IXmlNode node);
    [ExtensionAttribute]
public static void SetXsiType(IXmlNode node, XmlName xsiType);
    [ExtensionAttribute]
public static bool IsXsiNil(IXmlNode node);
    [ExtensionAttribute]
public static void SetXsiNil(IXmlNode node, bool nil);
}
[AttributeUsageAttribute("1024")]
public class Castle.Components.DictionaryAdapter.XmlDefaultsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Qualified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    public bool Qualified { get; public set; }
    public bool IsNullable { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Qualified();
    [CompilerGeneratedAttribute]
public void set_Qualified(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNullable();
    [CompilerGeneratedAttribute]
public void set_IsNullable(bool value);
}
[AttributeUsageAttribute("1152")]
public class Castle.Components.DictionaryAdapter.XmlNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public bool Root { get; public set; }
    public bool Default { get; public set; }
    public string NamespaceUri { get; private set; }
    public string Prefix { get; private set; }
    public XmlNamespaceAttribute(string namespaceUri, string prefix);
    [CompilerGeneratedAttribute]
public bool get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(bool value);
    [CompilerGeneratedAttribute]
public bool get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(bool value);
    [CompilerGeneratedAttribute]
public string get_NamespaceUri();
    [CompilerGeneratedAttribute]
private void set_NamespaceUri(string value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
private void set_Prefix(string value);
}
public abstract class Castle.Core.Configuration.AbstractConfiguration : object {
    private ConfigurationAttributeCollection attributes;
    private ConfigurationCollection children;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public ConfigurationAttributeCollection Attributes { get; }
    public ConfigurationCollection Children { get; }
    public string Name { get; protected set; }
    public string Value { get; protected set; }
    public virtual ConfigurationAttributeCollection get_Attributes();
    public virtual ConfigurationCollection get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
protected void set_Value(string value);
    public virtual object GetValue(Type type, object defaultValue);
}
public class Castle.Core.Configuration.ConfigurationAttributeCollection : NameValueCollection {
}
[DefaultMemberAttribute("Item")]
public class Castle.Core.Configuration.ConfigurationCollection : List`1<IConfiguration> {
    public IConfiguration Item { get; }
    public ConfigurationCollection(IEnumerable`1<IConfiguration> value);
    public IConfiguration get_Item(string name);
}
public interface Castle.Core.Configuration.IConfiguration {
    public string Name { get; }
    public string Value { get; }
    public ConfigurationCollection Children { get; }
    public ConfigurationAttributeCollection Attributes { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Value();
    public abstract virtual ConfigurationCollection get_Children();
    public abstract virtual ConfigurationAttributeCollection get_Attributes();
    public abstract virtual object GetValue(Type type, object defaultValue);
}
public class Castle.Core.Configuration.MutableConfiguration : AbstractConfiguration {
    public string Value { get; public set; }
    public MutableConfiguration(string name);
    public MutableConfiguration(string name, string value);
    public string get_Value();
    public void set_Value(string value);
    public static MutableConfiguration Create(string name);
    public MutableConfiguration Attribute(string name, string value);
    public MutableConfiguration CreateChild(string name);
    public MutableConfiguration CreateChild(string name, string value);
}
public class Castle.Core.Configuration.Xml.XmlConfigurationDeserializer : object {
    public IConfiguration Deserialize(XmlNode node);
    public static string GetConfigValue(string value);
    public static IConfiguration GetDeserializedNode(XmlNode node);
    public static bool IsTextNode(XmlNode node);
}
[ExtensionAttribute]
public static class Castle.Core.Internal.AttributesUtil : object {
    private static AttributeUsageAttribute DefaultAttributeUsage;
    private static AttributesUtil();
    [ExtensionAttribute]
public static T GetAttribute(Type type);
    [IteratorStateMachineAttribute("Castle.Core.Internal.AttributesUtil/<GetAttributes>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> GetAttributes(Type type);
    [ExtensionAttribute]
public static T GetAttribute(MemberInfo member);
    [IteratorStateMachineAttribute("Castle.Core.Internal.AttributesUtil/<GetAttributes>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> GetAttributes(MemberInfo member);
    [ExtensionAttribute]
public static T GetTypeAttribute(Type type);
    public static T[] GetTypeAttributes(Type type);
    [ExtensionAttribute]
public static AttributeUsageAttribute GetAttributeUsage(Type attributeType);
    public static Type GetTypeConverter(MemberInfo member);
}
internal class Castle.Core.Internal.InterfaceAttributeUtil : object {
    private Aged`1[] types;
    private Dictionary`2<Type, Aged`1<object>> singletons;
    private List`1<object> results;
    private int index;
    private static object ConflictMarker;
    private Type CurrentType { get; }
    private int CurrentAge { get; }
    private bool IsMostDerivedType { get; }
    private InterfaceAttributeUtil(Type derivedType, Type[] baseTypes);
    private static InterfaceAttributeUtil();
    private Type get_CurrentType();
    private int get_CurrentAge();
    private bool get_IsMostDerivedType();
    public static Object[] GetAttributes(Type type, bool inherit);
    private Aged`1[] CollectTypes(Type derivedType, Type[] baseTypes);
    private Object[] GetAttributes(Object[] attributes);
    private void ProcessType(Object[] attributes);
    private void AddSingleton(object attribute, Type attributeType);
    private void CollectSingletons();
    private void HandleAttributeConflict(Type attributeType);
    private static bool ShouldConsiderType(Type type);
    private Aged`1<T> MakeAged(T value);
}
public class Castle.Core.Internal.InternalsVisible : object {
    public static string ToCastleCore;
    public static string ToDynamicProxyGenAssembly2;
    internal static Byte[] DynamicProxyGenAssembly2PublicKey;
    private static InternalsVisible();
}
internal class Castle.Core.Internal.SynchronizedDictionary`2 : object {
    private Dictionary`2<TKey, TValue> items;
    private ReaderWriterLockSlim itemsLock;
    public void AddOrUpdateWithoutTakingLock(TKey key, TValue value);
    public sealed virtual void Dispose();
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAddWithoutTakingLock(TKey key, Func`2<TKey, TValue> valueFactory);
    public void ForEach(Action`2<TKey, TValue> action);
}
[ExtensionAttribute]
internal static class Castle.Core.Internal.TypeExtensions : object {
    [ExtensionAttribute]
public static string GetBestName(Type type);
}
internal class Castle.Core.Internal.WeakKey : WeakReference {
    private int hashCode;
    public object Target { get; public set; }
    public WeakKey(object target, int hashCode);
    public virtual object get_Target();
    public virtual void set_Target(object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
internal class Castle.Core.Internal.WeakKeyComparer`1 : object {
    public static WeakKeyComparer`1<TKey> Default;
    private IEqualityComparer`1<TKey> comparer;
    public WeakKeyComparer`1(IEqualityComparer`1<TKey> comparer);
    private static WeakKeyComparer`1();
    public object Wrap(TKey key);
    public TKey Unwrap(object obj);
    public sealed virtual int GetHashCode(object obj);
    public sealed virtual bool Equals(object objA, object objB);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Core.Internal.WeakKeyDictionary`2 : object {
    private Dictionary`2<object, TValue> dictionary;
    private WeakKeyComparer`1<TKey> comparer;
    private KeyCollection<TKey, TValue> keys;
    private int age;
    private static int AgeThreshold;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public WeakKeyDictionary`2(int capacity);
    public WeakKeyDictionary`2(IEqualityComparer`1<TKey> comparer);
    public WeakKeyDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    [IteratorStateMachineAttribute("Castle.Core.Internal.WeakKeyDictionary`2/<GetEnumerator>d__23")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    private void Age(int amount);
    public void TrimDeadObjects();
}
public interface Castle.Core.IServiceEnabledComponent {
    public abstract virtual void Service(IServiceProvider provider);
}
public interface Castle.Core.IServiceProviderEx {
    public abstract virtual T GetService();
}
public interface Castle.Core.IServiceProviderExAccessor {
    public IServiceProviderEx ServiceProvider { get; }
    public abstract virtual IServiceProviderEx get_ServiceProvider();
}
public abstract class Castle.Core.Logging.AbstractExtendedLoggerFactory : object {
    public virtual IExtendedLogger Create(Type type);
    public abstract virtual IExtendedLogger Create(string name);
    public virtual IExtendedLogger Create(Type type, LoggerLevel level);
    public abstract virtual IExtendedLogger Create(string name, LoggerLevel level);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(Type type);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(string name);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(Type type, LoggerLevel level);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(string name, LoggerLevel level);
    protected static FileInfo GetConfigFile(string fileName);
}
public abstract class Castle.Core.Logging.AbstractLoggerFactory : object {
    public virtual ILogger Create(Type type);
    public virtual ILogger Create(Type type, LoggerLevel level);
    public abstract virtual ILogger Create(string name);
    public abstract virtual ILogger Create(string name, LoggerLevel level);
    protected static FileInfo GetConfigFile(string fileName);
}
public class Castle.Core.Logging.ConsoleFactory : object {
    private Nullable`1<LoggerLevel> level;
    public ConsoleFactory(LoggerLevel level);
    public sealed virtual ILogger Create(Type type);
    public sealed virtual ILogger Create(string name);
    public sealed virtual ILogger Create(Type type, LoggerLevel level);
    public sealed virtual ILogger Create(string name, LoggerLevel level);
}
public class Castle.Core.Logging.ConsoleLogger : LevelFilteredLogger {
    public ConsoleLogger(LoggerLevel logLevel);
    public ConsoleLogger(string name);
    public ConsoleLogger(string name, LoggerLevel logLevel);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    public virtual ILogger CreateChildLogger(string loggerName);
}
public class Castle.Core.Logging.DiagnosticsLogger : LevelFilteredLogger {
    private EventLog eventLog;
    public DiagnosticsLogger(string logName);
    public DiagnosticsLogger(string logName, string source);
    public DiagnosticsLogger(string logName, string machineName, string source);
    public virtual ILogger CreateChildLogger(string loggerName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    protected virtual override void Finalize();
    private static EventLogEntryType TranslateLevel(LoggerLevel level);
}
public class Castle.Core.Logging.DiagnosticsLoggerFactory : AbstractLoggerFactory {
    private static string DefaultLogName;
    public virtual ILogger Create(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
}
[DefaultMemberAttribute("Item")]
public interface Castle.Core.Logging.IContextProperties {
    public object Item { get; public set; }
    public abstract virtual object get_Item(string key);
    public abstract virtual void set_Item(string key, object value);
}
public interface Castle.Core.Logging.IContextStack {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual void Clear();
    public abstract virtual string Pop();
    public abstract virtual IDisposable Push(string message);
}
[DefaultMemberAttribute("Item")]
public interface Castle.Core.Logging.IContextStacks {
    public IContextStack Item { get; }
    public abstract virtual IContextStack get_Item(string key);
}
public interface Castle.Core.Logging.IExtendedLogger {
    public IContextProperties GlobalProperties { get; }
    public IContextProperties ThreadProperties { get; }
    public IContextStacks ThreadStacks { get; }
    public abstract virtual IContextProperties get_GlobalProperties();
    public abstract virtual IContextProperties get_ThreadProperties();
    public abstract virtual IContextStacks get_ThreadStacks();
}
public interface Castle.Core.Logging.IExtendedLoggerFactory {
    public abstract virtual IExtendedLogger Create(Type type);
    public abstract virtual IExtendedLogger Create(string name);
    public abstract virtual IExtendedLogger Create(Type type, LoggerLevel level);
    public abstract virtual IExtendedLogger Create(string name, LoggerLevel level);
}
public interface Castle.Core.Logging.ILogger {
    public bool IsTraceEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public abstract virtual bool get_IsTraceEnabled();
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual ILogger CreateChildLogger(string loggerName);
    public abstract virtual void Trace(string message);
    public abstract virtual void Trace(Func`1<string> messageFactory);
    public abstract virtual void Trace(string message, Exception exception);
    public abstract virtual void TraceFormat(string format, Object[] args);
    public abstract virtual void TraceFormat(Exception exception, string format, Object[] args);
    public abstract virtual void TraceFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void TraceFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Debug(string message);
    public abstract virtual void Debug(Func`1<string> messageFactory);
    public abstract virtual void Debug(string message, Exception exception);
    public abstract virtual void DebugFormat(string format, Object[] args);
    public abstract virtual void DebugFormat(Exception exception, string format, Object[] args);
    public abstract virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void DebugFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Error(string message);
    public abstract virtual void Error(Func`1<string> messageFactory);
    public abstract virtual void Error(string message, Exception exception);
    public abstract virtual void ErrorFormat(string format, Object[] args);
    public abstract virtual void ErrorFormat(Exception exception, string format, Object[] args);
    public abstract virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void ErrorFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Fatal(string message);
    public abstract virtual void Fatal(Func`1<string> messageFactory);
    public abstract virtual void Fatal(string message, Exception exception);
    public abstract virtual void FatalFormat(string format, Object[] args);
    public abstract virtual void FatalFormat(Exception exception, string format, Object[] args);
    public abstract virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void FatalFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Info(string message);
    public abstract virtual void Info(Func`1<string> messageFactory);
    public abstract virtual void Info(string message, Exception exception);
    public abstract virtual void InfoFormat(string format, Object[] args);
    public abstract virtual void InfoFormat(Exception exception, string format, Object[] args);
    public abstract virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void InfoFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Warn(string message);
    public abstract virtual void Warn(Func`1<string> messageFactory);
    public abstract virtual void Warn(string message, Exception exception);
    public abstract virtual void WarnFormat(string format, Object[] args);
    public abstract virtual void WarnFormat(Exception exception, string format, Object[] args);
    public abstract virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void WarnFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
}
public interface Castle.Core.Logging.ILoggerFactory {
    public abstract virtual ILogger Create(Type type);
    public abstract virtual ILogger Create(string name);
    public abstract virtual ILogger Create(Type type, LoggerLevel level);
    public abstract virtual ILogger Create(string name, LoggerLevel level);
}
public abstract class Castle.Core.Logging.LevelFilteredLogger : object {
    private LoggerLevel level;
    private string name;
    public LoggerLevel Level { get; public set; }
    public string Name { get; }
    public bool IsTraceEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    protected LevelFilteredLogger(string name);
    protected LevelFilteredLogger(LoggerLevel loggerLevel);
    protected LevelFilteredLogger(string loggerName, LoggerLevel loggerLevel);
    public abstract virtual ILogger CreateChildLogger(string loggerName);
    public LoggerLevel get_Level();
    public void set_Level(LoggerLevel value);
    public string get_Name();
    public sealed virtual void Trace(string message);
    public sealed virtual void Trace(Func`1<string> messageFactory);
    public sealed virtual void Trace(string message, Exception exception);
    public sealed virtual void TraceFormat(string format, Object[] args);
    public sealed virtual void TraceFormat(Exception exception, string format, Object[] args);
    public sealed virtual void TraceFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void TraceFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(Func`1<string> messageFactory);
    public sealed virtual void Debug(string message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, string format, Object[] args);
    public sealed virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Info(string message);
    public sealed virtual void Info(Func`1<string> messageFactory);
    public sealed virtual void Info(string message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, string format, Object[] args);
    public sealed virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Warn(string message);
    public sealed virtual void Warn(Func`1<string> messageFactory);
    public sealed virtual void Warn(string message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, string format, Object[] args);
    public sealed virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(Func`1<string> messageFactory);
    public sealed virtual void Error(string message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, string format, Object[] args);
    public sealed virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Fatal(string message);
    public sealed virtual void Fatal(Func`1<string> messageFactory);
    public sealed virtual void Fatal(string message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, string format, Object[] args);
    public sealed virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual bool get_IsTraceEnabled();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    protected abstract virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    protected void ChangeName(string newName);
    private void Log(LoggerLevel loggerLevel, string message, Exception exception);
}
public class Castle.Core.Logging.LoggerException : Exception {
    public LoggerException(string message);
    public LoggerException(string message, Exception innerException);
    protected LoggerException(SerializationInfo info, StreamingContext context);
}
public enum Castle.Core.Logging.LoggerLevel : Enum {
    public int value__;
    public static LoggerLevel Off;
    public static LoggerLevel Fatal;
    public static LoggerLevel Error;
    public static LoggerLevel Warn;
    public static LoggerLevel Info;
    public static LoggerLevel Debug;
    public static LoggerLevel Trace;
}
public class Castle.Core.Logging.NullLogFactory : AbstractLoggerFactory {
    public virtual ILogger Create(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
}
public class Castle.Core.Logging.NullLogger : object {
    public static NullLogger Instance;
    public IContextProperties GlobalProperties { get; }
    public IContextProperties ThreadProperties { get; }
    public IContextStacks ThreadStacks { get; }
    public bool IsTraceEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    private static NullLogger();
    public sealed virtual IContextProperties get_GlobalProperties();
    public sealed virtual IContextProperties get_ThreadProperties();
    public sealed virtual IContextStacks get_ThreadStacks();
    public sealed virtual bool get_IsTraceEnabled();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual ILogger CreateChildLogger(string loggerName);
    public sealed virtual void Trace(string message);
    public sealed virtual void Trace(Func`1<string> messageFactory);
    public sealed virtual void Trace(string message, Exception exception);
    public sealed virtual void TraceFormat(string format, Object[] args);
    public sealed virtual void TraceFormat(Exception exception, string format, Object[] args);
    public sealed virtual void TraceFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void TraceFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(Func`1<string> messageFactory);
    public sealed virtual void Debug(string message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, string format, Object[] args);
    public sealed virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(Func`1<string> messageFactory);
    public sealed virtual void Error(string message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, string format, Object[] args);
    public sealed virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Fatal(string message);
    public sealed virtual void Fatal(Func`1<string> messageFactory);
    public sealed virtual void Fatal(string message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, string format, Object[] args);
    public sealed virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Info(string message);
    public sealed virtual void Info(Func`1<string> messageFactory);
    public sealed virtual void Info(string message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, string format, Object[] args);
    public sealed virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Warn(string message);
    public sealed virtual void Warn(Func`1<string> messageFactory);
    public sealed virtual void Warn(string message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, string format, Object[] args);
    public sealed virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
}
public class Castle.Core.Logging.StreamLogger : LevelFilteredLogger {
    private StreamWriter writer;
    public StreamLogger(string name, Stream stream);
    public StreamLogger(string name, Stream stream, Encoding encoding);
    public StreamLogger(string name, Stream stream, Encoding encoding, int bufferSize);
    protected StreamLogger(string name, StreamWriter writer);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    public virtual ILogger CreateChildLogger(string loggerName);
}
public class Castle.Core.Logging.StreamLoggerFactory : AbstractLoggerFactory {
    public virtual ILogger Create(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
}
public class Castle.Core.Logging.TraceLogger : LevelFilteredLogger {
    private static Dictionary`2<string, TraceSource> cache;
    private TraceSource traceSource;
    public TraceLogger(string name);
    public TraceLogger(string name, LoggerLevel level);
    private static TraceLogger();
    public virtual ILogger CreateChildLogger(string loggerName);
    private ILogger InternalCreateChildLogger(string loggerName);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    private void Initialize();
    private static string ShortenName(string name);
    private static bool IsSourceConfigured(TraceSource source);
    private static LoggerLevel MapLoggerLevel(SourceLevels level);
    private static SourceLevels MapSourceLevels(LoggerLevel level);
    private static TraceEventType MapTraceEventType(LoggerLevel level);
}
public class Castle.Core.Logging.TraceLoggerFactory : AbstractLoggerFactory {
    private Nullable`1<LoggerLevel> level;
    public TraceLoggerFactory(LoggerLevel level);
    public virtual ILogger Create(string name);
    private ILogger InternalCreate(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
    private ILogger InternalCreate(string name, LoggerLevel level);
}
public static class Castle.Core.ProxyServices : object {
    public static bool IsDynamicProxy(Type type);
}
public class Castle.Core.ReferenceEqualityComparer`1 : object {
    private static ReferenceEqualityComparer`1<T> instance;
    public static ReferenceEqualityComparer`1<T> Instance { get; }
    private static ReferenceEqualityComparer`1();
    public sealed virtual int GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<T>.Equals(T x, T y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<T>.GetHashCode(T obj);
    public static ReferenceEqualityComparer`1<T> get_Instance();
}
[DefaultMemberAttribute("Item")]
public class Castle.Core.ReflectionBasedDictionaryAdapter : object {
    private Dictionary`2<string, object> properties;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    public ReflectionBasedDictionaryAdapter(object target);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Remove(object key);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public static void Read(IDictionary targetDictionary, object valuesAsAnonymousObject);
    private static object GetPropertyValue(object target, PropertyInfo property);
    private static IEnumerable`1<PropertyInfo> GetReadableProperties(Type targetType);
    private static bool IsReadable(PropertyInfo property);
}
public abstract class Castle.Core.Resource.AbstractResource : object {
    protected static string DefaultBasePath;
    public string FileBasePath { get; }
    private static AbstractResource();
    public virtual string get_FileBasePath();
    public abstract virtual TextReader GetStreamReader();
    public abstract virtual TextReader GetStreamReader(Encoding encoding);
    public abstract virtual IResource CreateRelative(string relativePath);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public abstract class Castle.Core.Resource.AbstractStreamResource : AbstractResource {
    private StreamFactory createStream;
    public StreamFactory CreateStream { get; public set; }
    protected virtual override void Finalize();
    public StreamFactory get_CreateStream();
    public void set_CreateStream(StreamFactory value);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
}
public class Castle.Core.Resource.AssemblyBundleResource : AbstractResource {
    private CustomUri resource;
    public AssemblyBundleResource(CustomUri resource);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
    public virtual IResource CreateRelative(string relativePath);
    private static Assembly ObtainAssembly(string assemblyName);
}
public class Castle.Core.Resource.AssemblyResource : AbstractStreamResource {
    private string assemblyName;
    private string resourcePath;
    private string basePath;
    public AssemblyResource(CustomUri resource);
    public AssemblyResource(CustomUri resource, string basePath);
    public AssemblyResource(string resource);
    public virtual IResource CreateRelative(string relativePath);
    public virtual string ToString();
    private Stream CreateResourceFromPath(string resource, string path);
    private Stream CreateResourceFromUri(CustomUri resourcex, string path);
    private string GetNameFound(String[] names);
    private string ConvertToResourceName(string assembly, string resource);
    private string GetSimpleName(string assembly);
    private string ConvertToPath(string resource);
    private static Assembly ObtainAssembly(string assemblyName);
}
public class Castle.Core.Resource.AssemblyResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
public class Castle.Core.Resource.CustomUri : object {
    public static string SchemeDelimiter;
    public static string UriSchemeFile;
    public static string UriSchemeAssembly;
    private string scheme;
    private string host;
    private string path;
    private bool isUnc;
    private bool isFile;
    private bool isAssembly;
    public bool IsUnc { get; }
    public bool IsFile { get; }
    public bool IsAssembly { get; }
    public string Scheme { get; }
    public string Host { get; }
    public string Path { get; }
    public CustomUri(string resourceIdentifier);
    private static CustomUri();
    public bool get_IsUnc();
    public bool get_IsFile();
    public bool get_IsAssembly();
    public string get_Scheme();
    public string get_Host();
    public string get_Path();
    private void ParseIdentifier(string identifier);
}
public class Castle.Core.Resource.FileResource : AbstractStreamResource {
    private string filePath;
    private string basePath;
    public string FileBasePath { get; }
    public FileResource(CustomUri resource);
    public FileResource(CustomUri resource, string basePath);
    public FileResource(string resourceName);
    public FileResource(string resourceName, string basePath);
    public virtual string ToString();
    public virtual string get_FileBasePath();
    public virtual IResource CreateRelative(string relativePath);
    private Stream CreateStreamFromUri(CustomUri resource, string rootPath);
    private Stream CreateStreamFromPath(string resourcePath, string rootPath);
    private static void CheckFileExists(string path);
}
public class Castle.Core.Resource.FileResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
public interface Castle.Core.Resource.IResource {
    public string FileBasePath { get; }
    public abstract virtual string get_FileBasePath();
    public abstract virtual TextReader GetStreamReader();
    public abstract virtual TextReader GetStreamReader(Encoding encoding);
    public abstract virtual IResource CreateRelative(string relativePath);
}
public interface Castle.Core.Resource.IResourceFactory {
    public abstract virtual bool Accept(CustomUri uri);
    public abstract virtual IResource Create(CustomUri uri);
    public abstract virtual IResource Create(CustomUri uri, string basePath);
}
public class Castle.Core.Resource.ResourceException : Exception {
    public ResourceException(string message);
    public ResourceException(string message, Exception innerException);
    protected ResourceException(SerializationInfo info, StreamingContext context);
}
public class Castle.Core.Resource.StaticContentResource : AbstractResource {
    private string contents;
    public StaticContentResource(string contents);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
    public virtual IResource CreateRelative(string relativePath);
}
public class Castle.Core.Resource.StreamFactory : MulticastDelegate {
    public StreamFactory(object object, IntPtr method);
    public virtual Stream Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Stream EndInvoke(IAsyncResult result);
}
public class Castle.Core.Resource.UncResource : AbstractStreamResource {
    private string basePath;
    private string filePath;
    public string FileBasePath { get; }
    public UncResource(CustomUri resource);
    public UncResource(CustomUri resource, string basePath);
    public UncResource(string resourceName);
    public UncResource(string resourceName, string basePath);
    public virtual string get_FileBasePath();
    public virtual IResource CreateRelative(string relativePath);
    public virtual string ToString();
    private Stream CreateStreamFromUri(CustomUri resource, string rootPath);
    private static void CheckFileExists(string path);
}
public class Castle.Core.Resource.UncResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
public class Castle.Core.Smtp.DefaultSmtpSender : object {
    private bool asyncSend;
    private string hostname;
    private int port;
    private Nullable`1<int> timeout;
    private bool useSsl;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public int Port { get; public set; }
    public string Hostname { get; }
    public bool AsyncSend { get; public set; }
    public int Timeout { get; public set; }
    public bool UseSsl { get; public set; }
    public string Domain { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    private bool HasCredentials { get; }
    public DefaultSmtpSender(string hostname);
    public int get_Port();
    public void set_Port(int value);
    public string get_Hostname();
    public bool get_AsyncSend();
    public void set_AsyncSend(bool value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public bool get_UseSsl();
    public void set_UseSsl(bool value);
    public sealed virtual void Send(string from, string to, string subject, string messageText);
    public sealed virtual void Send(MailMessage message);
    private void InternalSend(MailMessage message);
    public sealed virtual void Send(IEnumerable`1<MailMessage> messages);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    protected virtual void Configure(SmtpClient smtpClient);
    private bool get_HasCredentials();
    private SmtpClient CreateSmtpClient();
}
public interface Castle.Core.Smtp.IEmailSender {
    public abstract virtual void Send(string from, string to, string subject, string messageText);
    public abstract virtual void Send(MailMessage message);
    public abstract virtual void Send(IEnumerable`1<MailMessage> messages);
}
[DefaultMemberAttribute("Item")]
public class Castle.Core.StringObjectDictionaryAdapter : object {
    private IDictionary dictionary;
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public StringObjectDictionaryAdapter(IDictionary dictionary);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    public bool Contains(object key);
    public void Add(object key, object value);
    public sealed virtual void Clear();
    public void Remove(object key);
    public object get_Item(object key);
    public void set_Item(object key, object value);
    public ICollection get_Keys();
    public ICollection get_Values();
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsFixedSize();
    public void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public object get_SyncRoot();
    public bool get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
}
public abstract class Castle.DynamicProxy.AbstractInvocation : object {
    private IInterceptor[] interceptors;
    private Object[] arguments;
    private int currentInterceptorIndex;
    private Type[] genericMethodArguments;
    private MethodInfo proxiedMethod;
    protected object proxyObject;
    [CompilerGeneratedAttribute]
private object <ReturnValue>k__BackingField;
    public object InvocationTarget { get; }
    public Type TargetType { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type[] GenericArguments { get; }
    public object Proxy { get; }
    public MethodInfo Method { get; }
    public object ReturnValue { get; public set; }
    public Object[] Arguments { get; }
    protected AbstractInvocation(object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    public void SetGenericMethodArguments(Type[] arguments);
    public abstract virtual object get_InvocationTarget();
    public abstract virtual Type get_TargetType();
    public abstract virtual MethodInfo get_MethodInvocationTarget();
    public sealed virtual Type[] get_GenericArguments();
    public sealed virtual object get_Proxy();
    public sealed virtual MethodInfo get_Method();
    public sealed virtual MethodInfo GetConcreteMethod();
    public sealed virtual MethodInfo GetConcreteMethodInvocationTarget();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ReturnValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReturnValue(object value);
    public sealed virtual Object[] get_Arguments();
    public sealed virtual void SetArgumentValue(int index, object value);
    public sealed virtual object GetArgumentValue(int index);
    public sealed virtual void Proceed();
    public sealed virtual IInvocationProceedInfo CaptureProceedInfo();
    protected abstract virtual void InvokeMethodOnTarget();
    protected void ThrowOnNoTarget();
    private MethodInfo EnsureClosedMethod(MethodInfo method);
}
public class Castle.DynamicProxy.AllMethodsHook : object {
    protected static ICollection`1<Type> SkippedTypes;
    private static AllMethodsHook();
    public virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
    public virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
    public virtual void MethodsInspected();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Castle.DynamicProxy.Contributors.ClassMembersCollector : MembersCollector {
    public ClassMembersCollector(Type targetType);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
}
internal class Castle.DynamicProxy.Contributors.ClassProxyTargetContributor : CompositeTypeContributor {
    private Type targetType;
    public ClassProxyTargetContributor(Type targetType, INamingScope namingScope);
    [IteratorStateMachineAttribute("Castle.DynamicProxy.Contributors.ClassProxyTargetContributor/<GetCollectors>d__2")]
protected virtual IEnumerable`1<MembersCollector> GetCollectors();
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, OverrideMethodDelegate overrideMethod);
    private Type BuildInvocationType(MetaMethod method, ClassEmitter class);
    private MethodBuilder CreateCallbackMethod(ClassEmitter emitter, MethodInfo methodInfo, MethodInfo methodOnTarget);
    private bool ExplicitlyImplementedInterfaceMethod(MetaMethod method);
    private MethodGenerator ExplicitlyImplementedInterfaceMethodGenerator(MetaMethod method, ClassEmitter class, OverrideMethodDelegate overrideMethod);
    private IInvocationCreationContributor GetContributor(Type delegate, MetaMethod method);
    private Type GetDelegateType(MetaMethod method, ClassEmitter class);
    private Type GetInvocationType(MetaMethod method, ClassEmitter class);
    [CompilerGeneratedAttribute]
private IExpression <GetMethodGenerator>b__3_0(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private IExpression <ExplicitlyImplementedInterfaceMethodGenerator>b__7_0(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.ClassProxyWithTargetTargetContributor : CompositeTypeContributor {
    private Type targetType;
    public ClassProxyWithTargetTargetContributor(Type targetType, INamingScope namingScope);
    [IteratorStateMachineAttribute("Castle.DynamicProxy.Contributors.ClassProxyWithTargetTargetContributor/<GetCollectors>d__2")]
protected virtual IEnumerable`1<MembersCollector> GetCollectors();
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, OverrideMethodDelegate overrideMethod);
    private Type BuildInvocationType(MetaMethod method, ClassEmitter class);
    private IInvocationCreationContributor GetContributor(Type delegate, MetaMethod method);
    private Type GetDelegateType(MetaMethod method, ClassEmitter class);
    private Type GetInvocationType(MetaMethod method, ClassEmitter class);
    private MethodGenerator IndirectlyCalledMethodGenerator(MetaMethod method, ClassEmitter proxy, OverrideMethodDelegate overrideMethod, bool skipInterceptors);
    private bool IsDirectlyAccessible(MetaMethod method);
}
internal abstract class Castle.DynamicProxy.Contributors.CompositeTypeContributor : object {
    protected INamingScope namingScope;
    protected ICollection`1<Type> interfaces;
    private ILogger logger;
    private List`1<MetaProperty> properties;
    private List`1<MetaEvent> events;
    private List`1<MetaMethod> methods;
    public ILogger Logger { get; public set; }
    protected CompositeTypeContributor(INamingScope namingScope);
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    public sealed virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
    protected abstract virtual IEnumerable`1<MembersCollector> GetCollectors();
    public virtual void Generate(ClassEmitter class);
    public void AddInterfaceToProxy(Type interface);
    private void ImplementEvent(ClassEmitter emitter, MetaEvent event);
    private void ImplementProperty(ClassEmitter emitter, MetaProperty property);
    protected abstract virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, OverrideMethodDelegate overrideMethod);
    private void ImplementMethod(MetaMethod method, ClassEmitter class, OverrideMethodDelegate overrideMethod);
}
internal class Castle.DynamicProxy.Contributors.DelegateTypeMembersCollector : MembersCollector {
    public DelegateTypeMembersCollector(Type delegateType);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
}
internal class Castle.DynamicProxy.Contributors.FieldReferenceComparer : object {
    public sealed virtual int Compare(Type x, Type y);
}
internal class Castle.DynamicProxy.Contributors.GetTargetExpressionDelegate : MulticastDelegate {
    public GetTargetExpressionDelegate(object object, IntPtr method);
    public virtual IExpression Invoke(ClassEmitter class, MethodInfo method);
    public virtual IAsyncResult BeginInvoke(ClassEmitter class, MethodInfo method, AsyncCallback callback, object object);
    public virtual IExpression EndInvoke(IAsyncResult result);
}
internal class Castle.DynamicProxy.Contributors.GetTargetReferenceDelegate : MulticastDelegate {
    public GetTargetReferenceDelegate(object object, IntPtr method);
    public virtual Reference Invoke(ClassEmitter class, MethodInfo method);
    public virtual IAsyncResult BeginInvoke(ClassEmitter class, MethodInfo method, AsyncCallback callback, object object);
    public virtual Reference EndInvoke(IAsyncResult result);
}
internal interface Castle.DynamicProxy.Contributors.IInvocationCreationContributor {
    public abstract virtual ConstructorEmitter CreateConstructor(ArgumentReference[] baseCtorArguments, AbstractTypeEmitter invocation);
    public abstract virtual MethodInfo GetCallbackMethod();
    public abstract virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, IExpression[] args, Reference targetField, MethodEmitter invokeMethodOnTarget);
    public abstract virtual IExpression[] GetConstructorInvocationArguments(IExpression[] arguments, ClassEmitter proxy);
}
internal interface Castle.DynamicProxy.Contributors.IMembersCollectorSink {
    public abstract virtual void Add(MetaEvent event);
    public abstract virtual void Add(MetaMethod method);
    public abstract virtual void Add(MetaProperty property);
}
internal class Castle.DynamicProxy.Contributors.InterfaceMembersCollector : MembersCollector {
    public InterfaceMembersCollector(Type interface);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
}
internal class Castle.DynamicProxy.Contributors.InterfaceMembersOnClassCollector : MembersCollector {
    private InterfaceMapping map;
    private bool onlyProxyVirtual;
    public InterfaceMembersOnClassCollector(Type type, bool onlyProxyVirtual, InterfaceMapping map);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    private MethodInfo GetMethodOnTarget(MethodInfo method);
    private bool IsVirtuallyImplementedInterfaceMethod(MethodInfo method);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyTargetContributor : CompositeTypeContributor {
    private bool canChangeTarget;
    private Type proxyTargetType;
    public InterfaceProxyTargetContributor(Type proxyTargetType, bool canChangeTarget, INamingScope namingScope);
    [IteratorStateMachineAttribute("Castle.DynamicProxy.Contributors.InterfaceProxyTargetContributor/<GetCollectors>d__3")]
protected virtual IEnumerable`1<MembersCollector> GetCollectors();
    protected virtual MembersCollector GetCollectorForInterface(Type interface);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, OverrideMethodDelegate overrideMethod);
    private Type GetInvocationType(MetaMethod method, ClassEmitter class);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyWithOptionalTargetContributor : InterfaceProxyWithoutTargetContributor {
    private GetTargetReferenceDelegate getTargetReference;
    public InterfaceProxyWithOptionalTargetContributor(INamingScope namingScope, GetTargetExpressionDelegate getTarget, GetTargetReferenceDelegate getTargetReference);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, OverrideMethodDelegate overrideMethod);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyWithoutTargetContributor : CompositeTypeContributor {
    private GetTargetExpressionDelegate getTargetExpression;
    protected bool canChangeTarget;
    public InterfaceProxyWithoutTargetContributor(INamingScope namingScope, GetTargetExpressionDelegate getTarget);
    [IteratorStateMachineAttribute("Castle.DynamicProxy.Contributors.InterfaceProxyWithoutTargetContributor/<GetCollectors>d__3")]
protected virtual IEnumerable`1<MembersCollector> GetCollectors();
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, OverrideMethodDelegate overrideMethod);
    private Type GetInvocationType(MetaMethod method, ClassEmitter emitter);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyWithTargetInterfaceTargetContributor : InterfaceProxyTargetContributor {
    public InterfaceProxyWithTargetInterfaceTargetContributor(Type proxyTargetType, bool allowChangeTarget, INamingScope namingScope);
    protected virtual MembersCollector GetCollectorForInterface(Type interface);
}
internal class Castle.DynamicProxy.Contributors.InvocationWithDelegateContributor : object {
    private Type delegateType;
    private MetaMethod method;
    private INamingScope namingScope;
    private Type targetType;
    public InvocationWithDelegateContributor(Type delegateType, Type targetType, MetaMethod method, INamingScope namingScope);
    public sealed virtual ConstructorEmitter CreateConstructor(ArgumentReference[] baseCtorArguments, AbstractTypeEmitter invocation);
    public sealed virtual MethodInfo GetCallbackMethod();
    public sealed virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, IExpression[] args, Reference targetField, MethodEmitter invokeMethodOnTarget);
    public sealed virtual IExpression[] GetConstructorInvocationArguments(IExpression[] arguments, ClassEmitter proxy);
    private FieldReference BuildDelegateToken(ClassEmitter proxy);
    private IExpression[] GetAllArgs(IExpression[] args, Reference targetField);
    private ArgumentReference[] GetArguments(ArgumentReference[] baseCtorArguments);
}
internal class Castle.DynamicProxy.Contributors.InvocationWithGenericDelegateContributor : object {
    private Type delegateType;
    private MetaMethod method;
    private Reference targetReference;
    public InvocationWithGenericDelegateContributor(Type delegateType, MetaMethod method, Reference targetReference);
    public sealed virtual ConstructorEmitter CreateConstructor(ArgumentReference[] baseCtorArguments, AbstractTypeEmitter invocation);
    public sealed virtual MethodInfo GetCallbackMethod();
    public sealed virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, IExpression[] args, Reference targetField, MethodEmitter invokeMethodOnTarget);
    public sealed virtual IExpression[] GetConstructorInvocationArguments(IExpression[] arguments, ClassEmitter proxy);
    private Reference GetDelegate(AbstractTypeEmitter invocation, MethodEmitter invokeMethodOnTarget);
    private AssignStatement SetDelegate(LocalReference localDelegate, Reference localTarget, Type closedDelegateType, MethodInfo closedMethodOnTarget);
}
internal interface Castle.DynamicProxy.Contributors.ITypeContributor {
    public abstract virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
    public abstract virtual void Generate(ClassEmitter class);
}
internal abstract class Castle.DynamicProxy.Contributors.MembersCollector : object {
    private static BindingFlags Flags;
    private ILogger logger;
    protected Type type;
    public ILogger Logger { get; public set; }
    protected MembersCollector(Type type);
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    public virtual void CollectMembersToProxy(IProxyGenerationHook hook, IMembersCollectorSink sink);
    protected abstract virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    protected bool AcceptMethod(MethodInfo method, bool onlyVirtuals, IProxyGenerationHook hook);
    protected bool AcceptMethodPreScreen(MethodInfo method, bool onlyVirtuals, IProxyGenerationHook hook);
    private static bool IsInternalAndNotVisibleToDynamicProxy(MethodInfo method);
    [CompilerGeneratedAttribute]
private void <CollectMembersToProxy>g__CollectProperties|7_0(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
private void <CollectMembersToProxy>g__CollectEvents|7_1(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
private void <CollectMembersToProxy>g__CollectMethods|7_2(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
private void <CollectMembersToProxy>g__AddProperty|7_3(PropertyInfo property, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
private void <CollectMembersToProxy>g__AddEvent|7_4(EventInfo event, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
private MetaMethod <CollectMembersToProxy>g__AddMethod|7_5(MethodInfo method, bool isStandalone, <>c__DisplayClass7_0& );
}
internal class Castle.DynamicProxy.Contributors.MixinContributor : CompositeTypeContributor {
    private bool canChangeTarget;
    private IList`1<Type> empty;
    private IDictionary`2<Type, FieldReference> fields;
    private GetTargetExpressionDelegate getTargetExpression;
    public IEnumerable`1<FieldReference> Fields { get; }
    public MixinContributor(INamingScope namingScope, bool canChangeTarget);
    public IEnumerable`1<FieldReference> get_Fields();
    public void AddEmptyInterface(Type interface);
    public virtual void Generate(ClassEmitter class);
    [IteratorStateMachineAttribute("Castle.DynamicProxy.Contributors.MixinContributor/<GetCollectors>d__9")]
protected virtual IEnumerable`1<MembersCollector> GetCollectors();
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, OverrideMethodDelegate overrideMethod);
    private GetTargetExpressionDelegate BuildGetTargetExpression();
    private FieldReference BuildTargetField(ClassEmitter class, Type type);
    private Type GetInvocationType(MetaMethod method, ClassEmitter emitter);
    [CompilerGeneratedAttribute]
private Reference <GetMethodGenerator>b__10_0(ClassEmitter c, MethodInfo i);
    [CompilerGeneratedAttribute]
private IExpression <BuildGetTargetExpression>b__11_0(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private IExpression <BuildGetTargetExpression>b__11_1(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.NonInheritableAttributesContributor : object {
    private Type targetType;
    public NonInheritableAttributesContributor(Type targetType);
    public sealed virtual void Generate(ClassEmitter emitter);
    public sealed virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
}
internal class Castle.DynamicProxy.Contributors.OverrideMethodDelegate : MulticastDelegate {
    public OverrideMethodDelegate(object object, IntPtr method);
    public virtual MethodEmitter Invoke(string name, MethodAttributes attributes, MethodInfo methodToOverride);
    public virtual IAsyncResult BeginInvoke(string name, MethodAttributes attributes, MethodInfo methodToOverride, AsyncCallback callback, object object);
    public virtual MethodEmitter EndInvoke(IAsyncResult result);
}
internal class Castle.DynamicProxy.Contributors.ProxyTargetAccessorContributor : object {
    private Func`1<Reference> getTargetReference;
    private Type targetType;
    public ProxyTargetAccessorContributor(Func`1<Reference> getTargetReference, Type targetType);
    public sealed virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
    public sealed virtual void Generate(ClassEmitter emitter);
}
internal class Castle.DynamicProxy.Contributors.WrappedClassMembersCollector : ClassMembersCollector {
    public WrappedClassMembersCollector(Type type);
    public virtual void CollectMembersToProxy(IProxyGenerationHook hook, IMembersCollectorSink sink);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    protected bool IsGeneratedByTheCompiler(FieldInfo field);
    protected virtual bool IsOKToBeOnProxy(FieldInfo field);
    private void CollectFields(IProxyGenerationHook hook);
}
public class Castle.DynamicProxy.CustomAttributeInfo : object {
    private static PropertyInfo[] EmptyProperties;
    private static FieldInfo[] EmptyFields;
    private static Object[] EmptyValues;
    private static IEqualityComparer`1<object> ValueComparer;
    private CustomAttributeBuilder builder;
    private ConstructorInfo constructor;
    private Object[] constructorArgs;
    private IDictionary`2<string, object> properties;
    private IDictionary`2<string, object> fields;
    internal CustomAttributeBuilder Builder { get; }
    public CustomAttributeInfo(ConstructorInfo constructor, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeInfo(ConstructorInfo constructor, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues);
    public CustomAttributeInfo(ConstructorInfo constructor, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeInfo(ConstructorInfo constructor, Object[] constructorArgs);
    private static CustomAttributeInfo();
    public static CustomAttributeInfo FromExpression(Expression`1<Func`1<Attribute>> expression);
    private static Expression UnwrapBody(Expression body);
    private static object GetAttributeArgumentValue(Expression arg, bool allowArray);
    private static bool IsCompilerGenerated(Type type);
    internal CustomAttributeBuilder get_Builder();
    public sealed virtual bool Equals(CustomAttributeInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static bool AreMembersEquivalent(IDictionary`2<string, object> x, IDictionary`2<string, object> y);
    private static int CombineHashCodes(IEnumerable`1<object> values);
    private static int CombineMemberHashCodes(IDictionary`2<string, object> dict);
    private IDictionary`2<string, object> MakeNameValueDictionary(T[] members, Object[] values);
}
public class Castle.DynamicProxy.DefaultProxyBuilder : object {
    private ModuleScope scope;
    private ILogger logger;
    public ILogger Logger { get; public set; }
    public ModuleScope ModuleScope { get; }
    public DefaultProxyBuilder(ModuleScope scope);
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    public sealed virtual ModuleScope get_ModuleScope();
    public sealed virtual Type CreateClassProxyType(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public sealed virtual Type CreateClassProxyTypeWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public sealed virtual Type CreateInterfaceProxyTypeWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, Type targetType, ProxyGenerationOptions options);
    public sealed virtual Type CreateInterfaceProxyTypeWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public sealed virtual Type CreateInterfaceProxyTypeWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    private void AssertValidMixins(ProxyGenerationOptions options, string paramName);
    private void AssertValidType(Type target, string paramName);
    private void AssertValidTypeForTarget(Type type, Type target, string paramName);
    private void AssertValidTypes(IEnumerable`1<Type> targetTypes, string paramName);
}
public class Castle.DynamicProxy.DynamicProxyException : Exception {
    internal DynamicProxyException(string message);
    internal DynamicProxyException(string message, Exception innerException);
    internal DynamicProxyException(SerializationInfo info, StreamingContext context);
}
internal static class Castle.DynamicProxy.ExceptionMessageBuilder : object {
    internal static string CreateInstructionsToMakeVisible(Assembly targetAssembly);
    public static string CreateMessageForInaccessibleType(Type inaccessibleType, Type typeToProxy);
    [CompilerGeneratedAttribute]
internal static bool <CreateInstructionsToMakeVisible>g__ReferencesCastleCore|0_0(Assembly ia);
}
public static class Castle.DynamicProxy.Generators.AttributesToAvoidReplicating : object {
    private static object lockObject;
    private static IList`1<Type> attributes;
    private static AttributesToAvoidReplicating();
    public static void Add(Type attribute);
    public static void Add();
    public static bool Contains(Type attribute);
    internal static bool ShouldAvoid(Type attribute);
}
internal abstract class Castle.DynamicProxy.Generators.BaseClassProxyGenerator : BaseProxyGenerator {
    protected FieldReference TargetField { get; }
    protected BaseClassProxyGenerator(ModuleScope scope, Type targetType, Type[] interfaces, ProxyGenerationOptions options);
    protected abstract virtual FieldReference get_TargetField();
    protected abstract virtual CompositeTypeContributor GetProxyTargetContributor(INamingScope namingScope);
    protected abstract virtual ProxyTargetAccessorContributor GetProxyTargetAccessorContributor();
    protected sealed virtual Type GenerateType(string name, INamingScope namingScope);
    private IEnumerable`1<Type> GetTypeImplementerMapping(IEnumerable`1& contributors, INamingScope namingScope);
    private void EnsureDoesNotImplementIProxyTargetAccessor(Type type, string name);
}
internal abstract class Castle.DynamicProxy.Generators.BaseInterfaceProxyGenerator : BaseProxyGenerator {
    protected Type proxyTargetType;
    protected FieldReference targetField;
    protected bool AllowChangeTarget { get; }
    protected string GeneratorType { get; }
    protected BaseInterfaceProxyGenerator(ModuleScope scope, Type targetType, Type[] interfaces, Type proxyTargetType, ProxyGenerationOptions options);
    protected abstract virtual bool get_AllowChangeTarget();
    protected abstract virtual string get_GeneratorType();
    protected abstract virtual CompositeTypeContributor GetProxyTargetContributor(Type proxyTargetType, INamingScope namingScope);
    protected abstract virtual ProxyTargetAccessorContributor GetProxyTargetAccessorContributor();
    protected abstract virtual void AddMappingForAdditionalInterfaces(CompositeTypeContributor contributor, Type[] proxiedInterfaces, IDictionary`2<Type, ITypeContributor> typeImplementerMapping, ICollection`1<Type> targetInterfaces);
    protected virtual ITypeContributor AddMappingForTargetType(IDictionary`2<Type, ITypeContributor> typeImplementerMapping, Type proxyTargetType, ICollection`1<Type> targetInterfaces, INamingScope namingScope);
    protected virtual CacheKey GetCacheKey();
    protected virtual Type GenerateType(string typeName, INamingScope namingScope);
    protected virtual InterfaceProxyWithoutTargetContributor GetContributorForAdditionalInterfaces(INamingScope namingScope);
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(Type proxyTargetType, IEnumerable`1& contributors, INamingScope namingScope);
    protected virtual Type Init(string typeName, ClassEmitter& emitter, Type proxyTargetType, FieldReference& interceptorsField, IEnumerable`1<Type> allInterfaces);
    private void CreateFields(ClassEmitter emitter, Type proxyTargetType);
    private void EnsureValidBaseType(Type type);
    private void ThrowInvalidBaseType(Type type, string doesNotHaveAccessibleParameterlessConstructor);
}
internal abstract class Castle.DynamicProxy.Generators.BaseProxyGenerator : object {
    protected Type targetType;
    protected Type[] interfaces;
    private ModuleScope scope;
    private ILogger logger;
    private ProxyGenerationOptions proxyGenerationOptions;
    public ILogger Logger { get; public set; }
    protected ProxyGenerationOptions ProxyGenerationOptions { get; }
    protected ModuleScope Scope { get; }
    protected BaseProxyGenerator(ModuleScope scope, Type targetType, Type[] interfaces, ProxyGenerationOptions proxyGenerationOptions);
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    protected ProxyGenerationOptions get_ProxyGenerationOptions();
    protected ModuleScope get_Scope();
    public Type GetProxyType();
    protected abstract virtual CacheKey GetCacheKey();
    protected abstract virtual Type GenerateType(string name, INamingScope namingScope);
    protected void AddMapping(Type interface, ITypeContributor implementer, IDictionary`2<Type, ITypeContributor> mapping);
    protected void AddMappingNoCheck(Type interface, ITypeContributor implementer, IDictionary`2<Type, ITypeContributor> mapping);
    protected virtual ClassEmitter BuildClassEmitter(string typeName, Type parentType, IEnumerable`1<Type> interfaces);
    protected void CheckNotGenericTypeDefinition(Type type, string argumentName);
    protected void CheckNotGenericTypeDefinitions(IEnumerable`1<Type> types, string argumentName);
    protected void CompleteInitCacheMethod(CodeBuilder constCodeBuilder);
    protected virtual void CreateFields(ClassEmitter emitter);
    protected void CreateInterceptorsField(ClassEmitter emitter);
    protected FieldReference CreateOptionsField(ClassEmitter emitter);
    protected void CreateSelectorField(ClassEmitter emitter);
    protected virtual void CreateTypeAttributes(ClassEmitter emitter);
    protected void EnsureOptionsOverrideEqualsAndGetHashCode();
    protected void GenerateConstructor(ClassEmitter emitter, ConstructorInfo baseConstructor, FieldReference[] fields);
    protected void GenerateConstructors(ClassEmitter emitter, Type baseType, FieldReference[] fields);
    protected void GenerateParameterlessConstructor(ClassEmitter emitter, Type baseClass, FieldReference interceptorField);
    protected ConstructorEmitter GenerateStaticConstructor(ClassEmitter emitter);
    protected void HandleExplicitlyPassedProxyTargetAccessor(ICollection`1<Type> targetInterfaces);
    protected void InitializeStaticFields(Type builtType);
    private bool OverridesEqualsAndGetHashCode(Type type);
}
internal class Castle.DynamicProxy.Generators.CacheKey : object {
    private MemberInfo target;
    private Type[] interfaces;
    private ProxyGenerationOptions options;
    private Type type;
    public CacheKey(MemberInfo target, Type type, Type[] interfaces, ProxyGenerationOptions options);
    public CacheKey(Type target, Type[] interfaces, ProxyGenerationOptions options);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Castle.DynamicProxy.Generators.ClassProxyGenerator : BaseClassProxyGenerator {
    protected FieldReference TargetField { get; }
    public ClassProxyGenerator(ModuleScope scope, Type targetType, Type[] interfaces, ProxyGenerationOptions options);
    protected virtual FieldReference get_TargetField();
    protected virtual CacheKey GetCacheKey();
    protected virtual CompositeTypeContributor GetProxyTargetContributor(INamingScope namingScope);
    protected virtual ProxyTargetAccessorContributor GetProxyTargetAccessorContributor();
}
internal class Castle.DynamicProxy.Generators.ClassProxyWithTargetGenerator : BaseClassProxyGenerator {
    private FieldReference targetField;
    protected FieldReference TargetField { get; }
    public ClassProxyWithTargetGenerator(ModuleScope scope, Type targetType, Type[] interfaces, ProxyGenerationOptions options);
    protected virtual FieldReference get_TargetField();
    protected virtual CacheKey GetCacheKey();
    protected virtual void CreateFields(ClassEmitter emitter);
    protected virtual CompositeTypeContributor GetProxyTargetContributor(INamingScope namingScope);
    protected virtual ProxyTargetAccessorContributor GetProxyTargetAccessorContributor();
    private void CreateTargetField(ClassEmitter emitter);
    [CompilerGeneratedAttribute]
private Reference <GetProxyTargetAccessorContributor>b__7_0();
}
internal class Castle.DynamicProxy.Generators.CompositionInvocationTypeGenerator : InvocationTypeGenerator {
    public static Type BaseType;
    public CompositionInvocationTypeGenerator(Type target, MetaMethod method, MethodInfo callback, bool canChangeTarget, IInvocationCreationContributor contributor);
    private static CompositionInvocationTypeGenerator();
    protected virtual ArgumentReference[] GetBaseCtorArguments(Type targetFieldType, ConstructorInfo& baseConstructor);
    protected virtual Type GetBaseType();
    protected virtual FieldReference GetTargetReference();
    protected virtual void ImplementInvokeMethodOnTarget(AbstractTypeEmitter invocation, ParameterInfo[] parameters, MethodEmitter invokeMethodOnTarget, Reference targetField);
}
internal class Castle.DynamicProxy.Generators.DelegateTypeGenerator : object {
    private static TypeAttributes DelegateFlags;
    private MetaMethod method;
    private Type targetType;
    public DelegateTypeGenerator(MetaMethod method, Type targetType);
    public sealed virtual AbstractTypeEmitter Generate(ClassEmitter class, INamingScope namingScope);
    private void BuildConstructor(AbstractTypeEmitter emitter);
    private void BuildInvokeMethod(AbstractTypeEmitter delegate);
    private AbstractTypeEmitter GetEmitter(ClassEmitter class, INamingScope namingScope);
    private Type[] GetParamTypes(AbstractTypeEmitter delegate);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.AbstractTypeEmitter : object {
    private static MethodAttributes defaultAttributes;
    private List`1<ConstructorEmitter> constructors;
    private List`1<EventEmitter> events;
    private IDictionary`2<string, FieldReference> fields;
    private List`1<MethodEmitter> methods;
    private List`1<NestedClassEmitter> nested;
    private List`1<PropertyEmitter> properties;
    private TypeBuilder typeBuilder;
    private GenericTypeParameterBuilder[] genericTypeParams;
    [CompilerGeneratedAttribute]
private TypeConstructorEmitter <ClassConstructor>k__BackingField;
    public Type BaseType { get; }
    public TypeConstructorEmitter ClassConstructor { get; private set; }
    public GenericTypeParameterBuilder[] GenericTypeParams { get; }
    public TypeBuilder TypeBuilder { get; }
    protected AbstractTypeEmitter(TypeBuilder typeBuilder);
    public Type get_BaseType();
    [CompilerGeneratedAttribute]
public TypeConstructorEmitter get_ClassConstructor();
    [CompilerGeneratedAttribute]
private void set_ClassConstructor(TypeConstructorEmitter value);
    public GenericTypeParameterBuilder[] get_GenericTypeParams();
    public TypeBuilder get_TypeBuilder();
    public void AddCustomAttributes(IEnumerable`1<CustomAttributeInfo> additionalAttributes);
    public void AddNestedClass(NestedClassEmitter nestedClass);
    public virtual Type BuildType();
    public void CopyGenericParametersFromMethod(MethodInfo methodToCopyGenericsFrom);
    public ConstructorEmitter CreateConstructor(ArgumentReference[] arguments);
    public void CreateDefaultConstructor();
    public EventEmitter CreateEvent(string name, EventAttributes atts, Type type);
    public FieldReference CreateField(string name, Type fieldType);
    public FieldReference CreateField(string name, Type fieldType, bool serializable);
    public FieldReference CreateField(string name, Type fieldType, FieldAttributes atts);
    public MethodEmitter CreateMethod(string name, MethodAttributes attrs, Type returnType, Type[] argumentTypes);
    public MethodEmitter CreateMethod(string name, Type returnType, Type[] parameterTypes);
    public MethodEmitter CreateMethod(string name, MethodInfo methodToUseAsATemplate);
    public MethodEmitter CreateMethod(string name, MethodAttributes attributes, MethodInfo methodToUseAsATemplate);
    public PropertyEmitter CreateProperty(string name, PropertyAttributes attributes, Type propertyType, Type[] arguments);
    public FieldReference CreateStaticField(string name, Type fieldType);
    public FieldReference CreateStaticField(string name, Type fieldType, FieldAttributes atts);
    public ConstructorEmitter CreateTypeConstructor();
    public void DefineCustomAttribute(CustomAttributeBuilder attribute);
    public void DefineCustomAttribute(Object[] constructorArguments);
    public void DefineCustomAttribute();
    public void DefineCustomAttributeFor(FieldReference field);
    public IEnumerable`1<FieldReference> GetAllFields();
    public FieldReference GetField(string name);
    public Type GetClosedParameterType(Type parameter);
    public Type GetGenericArgument(int position);
    public Type[] GetGenericArgumentsFor(MethodInfo genericMethod);
    public void SetGenericTypeParameters(GenericTypeParameterBuilder[] genericTypeParameterBuilders);
    protected Type CreateType(TypeBuilder type);
    protected virtual void EnsureBuildersAreInAValidState();
    [CompilerGeneratedAttribute]
private bool <GetClosedParameterType>g__CloseGenericParametersIfAny|44_0(Type[] arguments);
}
internal class Castle.DynamicProxy.Generators.Emitters.ApplyGenArgs : MulticastDelegate {
    public ApplyGenArgs(object object, IntPtr method);
    public virtual GenericTypeParameterBuilder[] Invoke(String[] argumentNames);
    public virtual IAsyncResult BeginInvoke(String[] argumentNames, AsyncCallback callback, object object);
    public virtual GenericTypeParameterBuilder[] EndInvoke(IAsyncResult result);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.ArgumentsUtil : object {
    public static ArgumentReference[] ConvertToArgumentReference(Type[] args);
    public static ArgumentReference[] ConvertToArgumentReference(ParameterInfo[] args);
    public static IExpression[] ConvertToArgumentReferenceExpression(ParameterInfo[] args);
    public static void EmitLoadOwnerAndReference(Reference reference, ILGenerator il);
    public static Type[] GetTypes(ParameterInfo[] parameters);
    public static Type[] InitializeAndConvert(ArgumentReference[] args);
    public static void InitializeArgumentsByPosition(ArgumentReference[] args, bool isStatic);
}
internal class Castle.DynamicProxy.Generators.Emitters.ClassEmitter : AbstractTypeEmitter {
    internal static TypeAttributes DefaultAttributes;
    private ModuleScope moduleScope;
    public ModuleScope ModuleScope { get; }
    internal bool InStrongNamedModule { get; }
    public ClassEmitter(ModuleScope moduleScope, string name, Type baseType, IEnumerable`1<Type> interfaces);
    public ClassEmitter(ModuleScope moduleScope, string name, Type baseType, IEnumerable`1<Type> interfaces, TypeAttributes flags, bool forceUnsigned);
    public ClassEmitter(TypeBuilder typeBuilder);
    public ModuleScope get_ModuleScope();
    internal bool get_InStrongNamedModule();
    protected virtual IEnumerable`1<Type> InitializeGenericArgumentsFromBases(Type& baseType, IEnumerable`1<Type> interfaces);
    private static TypeBuilder CreateTypeBuilder(ModuleScope moduleScope, string name, Type baseType, IEnumerable`1<Type> interfaces, TypeAttributes flags, bool forceUnsigned);
}
internal class Castle.DynamicProxy.Generators.Emitters.CodeBuilder : object {
    private List`1<LocalReference> locals;
    private List`1<IStatement> statements;
    private bool isEmpty;
    internal bool IsEmpty { get; }
    internal bool get_IsEmpty();
    public CodeBuilder AddStatement(IStatement statement);
    public LocalReference DeclareLocal(Type type);
    internal void Generate(ILGenerator il);
}
internal class Castle.DynamicProxy.Generators.Emitters.ConstructorEmitter : object {
    private ConstructorBuilder builder;
    private CodeBuilder codeBuilder;
    private AbstractTypeEmitter mainType;
    public CodeBuilder CodeBuilder { get; }
    public ConstructorBuilder ConstructorBuilder { get; }
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    private bool ImplementedByRuntime { get; }
    protected internal ConstructorEmitter(AbstractTypeEmitter mainType, ConstructorBuilder builder);
    internal ConstructorEmitter(AbstractTypeEmitter mainType, ArgumentReference[] arguments);
    public CodeBuilder get_CodeBuilder();
    public ConstructorBuilder get_ConstructorBuilder();
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    private bool get_ImplementedByRuntime();
    public virtual void EnsureValidCodeBlock();
    public virtual void Generate();
}
internal class Castle.DynamicProxy.Generators.Emitters.EventEmitter : object {
    private EventBuilder eventBuilder;
    private Type type;
    private AbstractTypeEmitter typeEmitter;
    private MethodEmitter addMethod;
    private MethodEmitter removeMethod;
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    public EventEmitter(AbstractTypeEmitter typeEmitter, string name, EventAttributes attributes, Type type);
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    public MethodEmitter CreateAddMethod(string addMethodName, MethodAttributes attributes, MethodInfo methodToOverride);
    public MethodEmitter CreateRemoveMethod(string removeMethodName, MethodAttributes attributes, MethodInfo methodToOverride);
    public sealed virtual void EnsureValidCodeBlock();
    public sealed virtual void Generate();
}
internal class Castle.DynamicProxy.Generators.Emitters.GenericUtil : object {
    public static GenericTypeParameterBuilder[] CopyGenericArguments(MethodInfo methodToCopyGenericsFrom, TypeBuilder builder);
    public static GenericTypeParameterBuilder[] CopyGenericArguments(MethodInfo methodToCopyGenericsFrom, MethodBuilder builder);
    private static Type AdjustConstraintToNewGenericParameters(Type constraint, MethodInfo methodToCopyGenericsFrom, Type[] originalGenericParameters, GenericTypeParameterBuilder[] newGenericParameters);
    private static Type[] AdjustGenericConstraints(MethodInfo methodToCopyGenericsFrom, GenericTypeParameterBuilder[] newGenericParameters, Type[] originalGenericArguments, Type[] constraints);
    private static GenericTypeParameterBuilder[] CopyGenericArguments(MethodInfo methodToCopyGenericsFrom, ApplyGenArgs genericParameterGenerator);
    private static void CopyNonInheritableAttributes(GenericTypeParameterBuilder newGenericParameter, Type originalGenericArgument);
    private static String[] GetArgumentNames(Type[] originalGenericArguments);
}
internal interface Castle.DynamicProxy.Generators.Emitters.IMemberEmitter {
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    public abstract virtual MemberInfo get_Member();
    public abstract virtual Type get_ReturnType();
    public abstract virtual void EnsureValidCodeBlock();
    public abstract virtual void Generate();
}
[DefaultMemberAttribute("Item")]
internal class Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary : Dictionary`2<Type, OpCode> {
    private static LdcOpCodesDictionary dict;
    private static OpCode emptyOpCode;
    public OpCode Item { get; }
    public static OpCode EmptyOpCode { get; }
    public static LdcOpCodesDictionary Instance { get; }
    private static LdcOpCodesDictionary();
    public OpCode get_Item(Type type);
    public static OpCode get_EmptyOpCode();
    public static LdcOpCodesDictionary get_Instance();
}
[DefaultMemberAttribute("Item")]
internal class Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary : Dictionary`2<Type, OpCode> {
    private static LdindOpCodesDictionary dict;
    private static OpCode emptyOpCode;
    public OpCode Item { get; }
    public static OpCode EmptyOpCode { get; }
    public static LdindOpCodesDictionary Instance { get; }
    private static LdindOpCodesDictionary();
    public OpCode get_Item(Type type);
    public static OpCode get_EmptyOpCode();
    public static LdindOpCodesDictionary get_Instance();
}
[DebuggerDisplayAttribute("{builder.Name}")]
internal class Castle.DynamicProxy.Generators.Emitters.MethodEmitter : object {
    private MethodBuilder builder;
    private CodeBuilder codeBuilder;
    private GenericTypeParameterBuilder[] genericTypeParams;
    private ArgumentReference[] arguments;
    public ArgumentReference[] Arguments { get; }
    public CodeBuilder CodeBuilder { get; }
    public GenericTypeParameterBuilder[] GenericTypeParams { get; }
    public MethodBuilder MethodBuilder { get; }
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    private bool ImplementedByRuntime { get; }
    protected internal MethodEmitter(MethodBuilder builder);
    internal MethodEmitter(AbstractTypeEmitter owner, string name, MethodAttributes attributes);
    internal MethodEmitter(AbstractTypeEmitter owner, string name, MethodAttributes attributes, Type returnType, Type[] argumentTypes);
    internal MethodEmitter(AbstractTypeEmitter owner, string name, MethodAttributes attributes, MethodInfo methodToUseAsATemplate);
    public ArgumentReference[] get_Arguments();
    public CodeBuilder get_CodeBuilder();
    public GenericTypeParameterBuilder[] get_GenericTypeParams();
    public MethodBuilder get_MethodBuilder();
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    private bool get_ImplementedByRuntime();
    public void DefineCustomAttribute(CustomAttributeBuilder attribute);
    public void SetParameters(Type[] paramTypes);
    public virtual void EnsureValidCodeBlock();
    public virtual void Generate();
    private void DefineParameters(ParameterInfo[] parameters);
    private void CopyDefaultValueConstant(ParameterInfo from, ParameterBuilder to);
    private void SetReturnType(Type returnType);
    private void SetSignature(Type returnType, ParameterInfo returnParameter, Type[] parameters, ParameterInfo[] baseMethodParameters);
}
internal class Castle.DynamicProxy.Generators.Emitters.NestedClassEmitter : AbstractTypeEmitter {
    public NestedClassEmitter(AbstractTypeEmitter mainType, string name, Type baseType, Type[] interfaces);
    public NestedClassEmitter(AbstractTypeEmitter mainType, string name, TypeAttributes attributes, Type baseType, Type[] interfaces);
    public NestedClassEmitter(AbstractTypeEmitter mainType, TypeBuilder typeBuilder);
    private static TypeBuilder CreateTypeBuilder(AbstractTypeEmitter mainType, string name, TypeAttributes attributes, Type baseType, Type[] interfaces);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.OpCodeUtil : object {
    public static void EmitLoadIndirectOpCodeForType(ILGenerator gen, Type type);
    public static void EmitLoadOpCodeForDefaultValueOfType(ILGenerator gen, Type type);
    public static void EmitStoreIndirectOpCodeForType(ILGenerator gen, Type type);
    private static Type GetUnderlyingTypeOfEnum(Type enumType);
    private static bool Is64BitTypeLoadedAsInt32(Type type);
}
internal class Castle.DynamicProxy.Generators.Emitters.PropertyEmitter : object {
    private PropertyBuilder builder;
    private AbstractTypeEmitter parentTypeEmitter;
    private MethodEmitter getMethod;
    private MethodEmitter setMethod;
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    public PropertyEmitter(AbstractTypeEmitter parentTypeEmitter, string name, PropertyAttributes attributes, Type propertyType, Type[] arguments);
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    public MethodEmitter CreateGetMethod(string name, MethodAttributes attrs, MethodInfo methodToOverride, Type[] parameters);
    public MethodEmitter CreateGetMethod(string name, MethodAttributes attributes, MethodInfo methodToOverride);
    public MethodEmitter CreateSetMethod(string name, MethodAttributes attrs, MethodInfo methodToOverride, Type[] parameters);
    public MethodEmitter CreateSetMethod(string name, MethodAttributes attributes, MethodInfo methodToOverride);
    public void DefineCustomAttribute(CustomAttributeBuilder attribute);
    public sealed virtual void EnsureValidCodeBlock();
    public sealed virtual void Generate();
}
[DebuggerDisplayAttribute("argument {Type}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ArgumentReference : TypeReference {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal int Position { get; internal set; }
    public ArgumentReference(Type argumentType);
    public ArgumentReference(Type argumentType, int position);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(int value);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AssignArgumentStatement : object {
    private ArgumentReference argument;
    private IExpression expression;
    public AssignArgumentStatement(ArgumentReference argument, IExpression expression);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AssignArrayStatement : object {
    private Reference targetArray;
    private int targetPosition;
    private IExpression value;
    public AssignArrayStatement(Reference targetArray, int targetPosition, IExpression value);
    public sealed virtual void Emit(ILGenerator il);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AssignStatement : object {
    private IExpression expression;
    private Reference target;
    public AssignStatement(Reference target, IExpression expression);
    public sealed virtual void Emit(ILGenerator gen);
}
[DebuggerDisplayAttribute("{reference} as {type}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AsTypeReference : Reference {
    private Reference reference;
    private Type type;
    public AsTypeReference(Reference reference, Type type);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.BlockStatement : object {
    private List`1<IStatement> statements;
    public void AddStatement(IStatement statement);
    public sealed virtual void Emit(ILGenerator gen);
}
[DebuggerDisplayAttribute("&{localReference}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ByRefReference : TypeReference {
    private LocalReference localReference;
    public ByRefReference(LocalReference localReference);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ConstructorInvocationStatement : object {
    private IExpression[] args;
    private ConstructorInfo cmethod;
    public ConstructorInvocationStatement(Type baseType);
    public ConstructorInvocationStatement(ConstructorInfo method, IExpression[] args);
    public sealed virtual void Emit(ILGenerator gen);
    private static ConstructorInfo GetDefaultConstructor(Type baseType);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ConvertExpression : object {
    private IExpression right;
    private Type fromType;
    private Type target;
    public ConvertExpression(Type targetType, IExpression right);
    public ConvertExpression(Type targetType, Type fromType, IExpression right);
    public sealed virtual void Emit(ILGenerator gen);
    private static void EmitCastIfNeeded(Type from, Type target, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.DefaultValueExpression : object {
    private Type type;
    public DefaultValueExpression(Type type);
    public sealed virtual void Emit(ILGenerator gen);
    private void EmitByRef(ILGenerator gen);
    private bool IsPrimitiveOrClass(Type type);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.EndExceptionBlockStatement : object {
    public sealed virtual void Emit(ILGenerator gen);
}
[DebuggerDisplayAttribute("{fieldBuilder.Name} ({fieldBuilder.FieldType})")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference : Reference {
    private FieldInfo field;
    private FieldBuilder fieldBuilder;
    private bool isStatic;
    public FieldBuilder FieldBuilder { get; }
    public FieldInfo Reference { get; }
    public FieldReference(FieldInfo field);
    public FieldReference(FieldBuilder fieldBuilder);
    public FieldBuilder get_FieldBuilder();
    public FieldInfo get_Reference();
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.FinallyStatement : object {
    public sealed virtual void Emit(ILGenerator gen);
}
internal interface Castle.DynamicProxy.Generators.Emitters.SimpleAST.IExpression {
}
internal interface Castle.DynamicProxy.Generators.Emitters.SimpleAST.IExpressionOrStatement {
    public abstract virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.IfNullExpression : object {
    private IExpressionOrStatement ifNotNull;
    private IExpressionOrStatement ifNull;
    private Reference reference;
    private IExpression expression;
    public IfNullExpression(Reference reference, IExpressionOrStatement ifNull, IExpressionOrStatement ifNotNull);
    public IfNullExpression(IExpression expression, IExpressionOrStatement ifNull, IExpressionOrStatement ifNotNull);
    public sealed virtual void Emit(ILGenerator gen);
}
[DebuggerDisplayAttribute("&{OwnerReference}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference : TypeReference {
    public IndirectReference(TypeReference byRefReference);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
    public static TypeReference WrapIfByRef(TypeReference reference);
    public static TypeReference[] WrapIfByRef(TypeReference[] references);
}
internal interface Castle.DynamicProxy.Generators.Emitters.SimpleAST.IStatement {
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LiteralBoolExpression : object {
    private bool value;
    public LiteralBoolExpression(bool value);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LiteralIntExpression : object {
    private int value;
    public LiteralIntExpression(int value);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LiteralStringExpression : object {
    private string value;
    public LiteralStringExpression(string value);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LoadRefArrayElementExpression : object {
    private Reference arrayReference;
    private LiteralIntExpression index;
    public LoadRefArrayElementExpression(int index, Reference arrayReference);
    public sealed virtual void Emit(ILGenerator gen);
}
[DebuggerDisplayAttribute("local {Type}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LocalReference : TypeReference {
    private LocalBuilder localBuilder;
    public LocalReference(Type type);
    public virtual void Generate(ILGenerator gen);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.MethodInvocationExpression : object {
    protected IExpression[] args;
    protected MethodInfo method;
    protected Reference owner;
    [CompilerGeneratedAttribute]
private bool <VirtualCall>k__BackingField;
    public bool VirtualCall { get; public set; }
    public MethodInvocationExpression(MethodInfo method, IExpression[] args);
    public MethodInvocationExpression(MethodEmitter method, IExpression[] args);
    public MethodInvocationExpression(Reference owner, MethodEmitter method, IExpression[] args);
    public MethodInvocationExpression(Reference owner, MethodInfo method, IExpression[] args);
    [CompilerGeneratedAttribute]
public bool get_VirtualCall();
    [CompilerGeneratedAttribute]
public void set_VirtualCall(bool value);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.MethodTokenExpression : object {
    private MethodInfo method;
    public MethodTokenExpression(MethodInfo method);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression : object {
    private Type arrayType;
    private int size;
    public NewArrayExpression(int size, Type arrayType);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewInstanceExpression : object {
    private IExpression[] arguments;
    private ConstructorInfo constructor;
    public NewInstanceExpression(ConstructorInfo constructor, IExpression[] args);
    public NewInstanceExpression(Type target);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NullCoalescingOperatorExpression : object {
    private IExpression default;
    private IExpression expression;
    public NullCoalescingOperatorExpression(IExpression expression, IExpression default);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NullExpression : object {
    public static NullExpression Instance;
    private static NullExpression();
    public sealed virtual void Emit(ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.Reference : object {
    protected Reference owner;
    public Reference OwnerReference { get; public set; }
    protected Reference(Reference owner);
    public Reference get_OwnerReference();
    public void set_OwnerReference(Reference value);
    public abstract virtual void LoadAddressOfReference(ILGenerator gen);
    public abstract virtual void LoadReference(ILGenerator gen);
    public abstract virtual void StoreReference(ILGenerator gen);
    public virtual void Generate(ILGenerator gen);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression : object {
    private TypeReference[] args;
    public ReferencesToObjectArrayExpression(TypeReference[] args);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReturnStatement : object {
    private IExpression expression;
    private Reference reference;
    public ReturnStatement(Reference reference);
    public ReturnStatement(IExpression expression);
    public sealed virtual void Emit(ILGenerator gen);
}
[DebuggerDisplayAttribute("this")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.SelfReference : Reference {
    public static SelfReference Self;
    private static SelfReference();
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ThrowStatement : object {
    private string errorMessage;
    private Type exceptionType;
    public ThrowStatement(Type exceptionType, string errorMessage);
    public sealed virtual void Emit(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.TryStatement : object {
    public sealed virtual void Emit(ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.TypeReference : Reference {
    private Type type;
    public Type Type { get; }
    protected TypeReference(Type argumentType);
    protected TypeReference(Reference owner, Type type);
    public Type get_Type();
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.TypeTokenExpression : object {
    private Type type;
    public TypeTokenExpression(Type type);
    public sealed virtual void Emit(ILGenerator gen);
}
[DefaultMemberAttribute("Item")]
internal class Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary : Dictionary`2<Type, OpCode> {
    private static StindOpCodesDictionary dict;
    private static OpCode emptyOpCode;
    public OpCode Item { get; }
    public static OpCode EmptyOpCode { get; }
    public static StindOpCodesDictionary Instance { get; }
    private static StindOpCodesDictionary();
    public OpCode get_Item(Type type);
    public static OpCode get_EmptyOpCode();
    public static StindOpCodesDictionary get_Instance();
}
[ExtensionAttribute]
internal static class Castle.DynamicProxy.Generators.Emitters.StrongNameUtil : object {
    private static IDictionary`2<Assembly, bool> signedAssemblyCache;
    private static object lockObject;
    private static StrongNameUtil();
    [ExtensionAttribute]
public static bool IsAssemblySigned(Assembly assembly);
    [ExtensionAttribute]
private static bool ContainsPublicKey(Assembly assembly);
    public static bool IsAnyTypeFromUnsignedAssembly(IEnumerable`1<Type> types);
    public static bool IsAnyTypeFromUnsignedAssembly(Type baseType, IEnumerable`1<Type> interfaces);
}
internal class Castle.DynamicProxy.Generators.Emitters.TypeConstructorEmitter : ConstructorEmitter {
    internal TypeConstructorEmitter(AbstractTypeEmitter mainType);
    public virtual void EnsureValidCodeBlock();
}
internal class Castle.DynamicProxy.Generators.ForwardingMethodGenerator : MethodGenerator {
    private GetTargetReferenceDelegate getTargetReference;
    public ForwardingMethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod, GetTargetReferenceDelegate getTargetReference);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, INamingScope namingScope);
}
internal static class Castle.DynamicProxy.Generators.GeneratorUtil : object {
    public static void CopyOutAndRefParameters(TypeReference[] dereferencedArguments, LocalReference invocation, MethodInfo method, MethodEmitter emitter);
    private static ConvertExpression Argument(int i, LocalReference invocationArgs, TypeReference[] arguments);
    private static AssignStatement AssignArgument(TypeReference[] dereferencedArguments, int i, LocalReference invocationArgs);
    private static AssignStatement GetArguments(LocalReference invocationArgs, LocalReference invocation);
    private static LocalReference StoreInvocationArgumentsInLocal(MethodEmitter emitter, LocalReference invocation);
    [CompilerGeneratedAttribute]
internal static bool <CopyOutAndRefParameters>g__IsByRef|0_0(ParameterInfo parameter);
    [CompilerGeneratedAttribute]
internal static bool <CopyOutAndRefParameters>g__IsReadOnly|0_1(ParameterInfo parameter);
}
internal interface Castle.DynamicProxy.Generators.IGenerator`1 {
    public abstract virtual T Generate(ClassEmitter class, INamingScope namingScope);
}
internal interface Castle.DynamicProxy.Generators.INamingScope {
    public INamingScope ParentScope { get; }
    public abstract virtual INamingScope get_ParentScope();
    public abstract virtual string GetUniqueName(string suggestedName);
    public abstract virtual INamingScope SafeSubScope();
}
internal class Castle.DynamicProxy.Generators.InheritanceInvocationTypeGenerator : InvocationTypeGenerator {
    public static Type BaseType;
    public InheritanceInvocationTypeGenerator(Type targetType, MetaMethod method, MethodInfo callback, IInvocationCreationContributor contributor);
    private static InheritanceInvocationTypeGenerator();
    protected virtual ArgumentReference[] GetBaseCtorArguments(Type targetFieldType, ConstructorInfo& baseConstructor);
    protected virtual Type GetBaseType();
    protected virtual FieldReference GetTargetReference();
}
internal class Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator : BaseInterfaceProxyGenerator {
    protected bool AllowChangeTarget { get; }
    protected string GeneratorType { get; }
    public InterfaceProxyWithoutTargetGenerator(ModuleScope scope, Type targetType, Type[] interfaces, Type proxyTargetType, ProxyGenerationOptions options);
    protected virtual bool get_AllowChangeTarget();
    protected virtual string get_GeneratorType();
    protected virtual CompositeTypeContributor GetProxyTargetContributor(Type proxyTargetType, INamingScope namingScope);
    protected virtual ProxyTargetAccessorContributor GetProxyTargetAccessorContributor();
    protected virtual void AddMappingForAdditionalInterfaces(CompositeTypeContributor contributor, Type[] proxiedInterfaces, IDictionary`2<Type, ITypeContributor> typeImplementerMapping, ICollection`1<Type> targetInterfaces);
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(Type _, IEnumerable`1& contributors, INamingScope namingScope);
    [CompilerGeneratedAttribute]
private Reference <GetProxyTargetAccessorContributor>b__6_0();
}
internal class Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator : BaseInterfaceProxyGenerator {
    protected bool AllowChangeTarget { get; }
    protected string GeneratorType { get; }
    public InterfaceProxyWithTargetGenerator(ModuleScope scope, Type targetType, Type[] interfaces, Type proxyTargetType, ProxyGenerationOptions options);
    protected virtual bool get_AllowChangeTarget();
    protected virtual string get_GeneratorType();
    protected virtual CompositeTypeContributor GetProxyTargetContributor(Type proxyTargetType, INamingScope namingScope);
    protected virtual ProxyTargetAccessorContributor GetProxyTargetAccessorContributor();
    protected virtual void AddMappingForAdditionalInterfaces(CompositeTypeContributor contributor, Type[] proxiedInterfaces, IDictionary`2<Type, ITypeContributor> typeImplementerMapping, ICollection`1<Type> targetInterfaces);
    private bool ImplementedByTarget(ICollection`1<Type> targetInterfaces, Type interface);
    [CompilerGeneratedAttribute]
private Reference <GetProxyTargetAccessorContributor>b__6_0();
}
internal class Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator : BaseInterfaceProxyGenerator {
    protected bool AllowChangeTarget { get; }
    protected string GeneratorType { get; }
    public InterfaceProxyWithTargetInterfaceGenerator(ModuleScope scope, Type targetType, Type[] interfaces, Type proxyTargetType, ProxyGenerationOptions options);
    protected virtual bool get_AllowChangeTarget();
    protected virtual string get_GeneratorType();
    protected virtual CompositeTypeContributor GetProxyTargetContributor(Type proxyTargetType, INamingScope namingScope);
    protected virtual ProxyTargetAccessorContributor GetProxyTargetAccessorContributor();
    protected virtual void AddMappingForAdditionalInterfaces(CompositeTypeContributor contributor, Type[] proxiedInterfaces, IDictionary`2<Type, ITypeContributor> typeImplementerMapping, ICollection`1<Type> targetInterfaces);
    protected virtual InterfaceProxyWithoutTargetContributor GetContributorForAdditionalInterfaces(INamingScope namingScope);
    private Reference GetTarget(ClassEmitter class, MethodInfo method);
    private IExpression GetTargetExpression(ClassEmitter class, MethodInfo method);
    [CompilerGeneratedAttribute]
private Reference <GetProxyTargetAccessorContributor>b__6_0();
}
internal abstract class Castle.DynamicProxy.Generators.InvocationTypeGenerator : object {
    protected MetaMethod method;
    protected Type targetType;
    private MethodInfo callback;
    private bool canChangeTarget;
    private IInvocationCreationContributor contributor;
    protected InvocationTypeGenerator(Type targetType, MetaMethod method, MethodInfo callback, bool canChangeTarget, IInvocationCreationContributor contributor);
    protected abstract virtual ArgumentReference[] GetBaseCtorArguments(Type targetFieldType, ConstructorInfo& baseConstructor);
    protected abstract virtual Type GetBaseType();
    protected abstract virtual FieldReference GetTargetReference();
    public sealed virtual AbstractTypeEmitter Generate(ClassEmitter class, INamingScope namingScope);
    protected virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, IExpression[] args, MethodInfo callbackMethod, Reference targetField, MethodEmitter invokeMethodOnTarget);
    protected virtual void ImplementInvokeMethodOnTarget(AbstractTypeEmitter invocation, ParameterInfo[] parameters, MethodEmitter invokeMethodOnTarget, Reference targetField);
    private void AssignBackByRefArguments(MethodEmitter invokeMethodOnTarget, Dictionary`2<int, LocalReference> byRefArguments);
    private void CreateConstructor(AbstractTypeEmitter invocation);
    private ConstructorEmitter CreateConstructor(AbstractTypeEmitter invocation, ArgumentReference[] baseCtorArguments);
    private void EmitCallThrowOnNoTarget(MethodEmitter invokeMethodOnTarget);
    private MethodInfo GetCallbackMethod(AbstractTypeEmitter invocation);
    private AbstractTypeEmitter GetEmitter(ClassEmitter class, Type[] interfaces, INamingScope namingScope, MethodInfo methodInfo);
    private void ImplementInvokeMethodOnTarget(AbstractTypeEmitter invocation, ParameterInfo[] parameters, FieldReference targetField, MethodInfo callbackMethod);
    private void ImplementChangeInvocationTarget(AbstractTypeEmitter invocation, FieldReference targetField);
    private void ImplementChangeProxyTarget(AbstractTypeEmitter invocation, ClassEmitter class);
    private void ImplementChangeProxyTargetInterface(ClassEmitter class, AbstractTypeEmitter invocation, FieldReference targetField);
}
internal class Castle.DynamicProxy.Generators.MetaEvent : MetaTypeElement {
    private MetaMethod adder;
    private MetaMethod remover;
    private EventEmitter emitter;
    [CompilerGeneratedAttribute]
private EventAttributes <Attributes>k__BackingField;
    public MetaMethod Adder { get; }
    public EventAttributes Attributes { get; private set; }
    public EventEmitter Emitter { get; }
    public MetaMethod Remover { get; }
    private Type Type { get; }
    public MetaEvent(EventInfo event, MetaMethod adder, MetaMethod remover, EventAttributes attributes);
    public MetaMethod get_Adder();
    [CompilerGeneratedAttribute]
public EventAttributes get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(EventAttributes value);
    public EventEmitter get_Emitter();
    public MetaMethod get_Remover();
    private Type get_Type();
    public void BuildEventEmitter(ClassEmitter classEmitter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetaEvent other);
    public virtual void SwitchToExplicitImplementation();
}
[DebuggerDisplayAttribute("{Method}")]
internal class Castle.DynamicProxy.Generators.MetaMethod : MetaTypeElement {
    private static MethodAttributes ExplicitImplementationAttributes;
    [CompilerGeneratedAttribute]
private MethodAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodOnTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Proxyable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Standalone>k__BackingField;
    public MethodAttributes Attributes { get; private set; }
    public bool HasTarget { get; private set; }
    public MethodInfo Method { get; private set; }
    public MethodInfo MethodOnTarget { get; private set; }
    public bool Ignore { get; internal set; }
    public bool Proxyable { get; private set; }
    public bool Standalone { get; private set; }
    public MetaMethod(MethodInfo method, MethodInfo methodOnTarget, bool standalone, bool proxyable, bool hasTarget);
    [CompilerGeneratedAttribute]
public MethodAttributes get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(MethodAttributes value);
    [CompilerGeneratedAttribute]
public bool get_HasTarget();
    [CompilerGeneratedAttribute]
private void set_HasTarget(bool value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodOnTarget();
    [CompilerGeneratedAttribute]
private void set_MethodOnTarget(MethodInfo value);
    [CompilerGeneratedAttribute]
public bool get_Ignore();
    [CompilerGeneratedAttribute]
internal void set_Ignore(bool value);
    [CompilerGeneratedAttribute]
public bool get_Proxyable();
    [CompilerGeneratedAttribute]
private void set_Proxyable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Standalone();
    [CompilerGeneratedAttribute]
private void set_Standalone(bool value);
    public sealed virtual bool Equals(MetaMethod other);
    public virtual void SwitchToExplicitImplementation();
    private MethodAttributes ObtainAttributes();
}
internal class Castle.DynamicProxy.Generators.MetaProperty : MetaTypeElement {
    private Type[] arguments;
    private PropertyAttributes attributes;
    private IEnumerable`1<CustomAttributeBuilder> customAttributes;
    private MetaMethod getter;
    private MetaMethod setter;
    private PropertyEmitter emitter;
    public Type[] Arguments { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public PropertyEmitter Emitter { get; }
    public MethodInfo GetMethod { get; }
    public MetaMethod Getter { get; }
    public MethodInfo SetMethod { get; }
    public MetaMethod Setter { get; }
    private Type Type { get; }
    public MetaProperty(PropertyInfo property, MetaMethod getter, MetaMethod setter, IEnumerable`1<CustomAttributeBuilder> customAttributes, Type[] arguments);
    public Type[] get_Arguments();
    public bool get_CanRead();
    public bool get_CanWrite();
    public PropertyEmitter get_Emitter();
    public MethodInfo get_GetMethod();
    public MetaMethod get_Getter();
    public MethodInfo get_SetMethod();
    public MetaMethod get_Setter();
    private Type get_Type();
    public void BuildPropertyEmitter(ClassEmitter classEmitter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetaProperty other);
    public virtual void SwitchToExplicitImplementation();
}
internal class Castle.DynamicProxy.Generators.MetaType : object {
    private MetaTypeElementCollection`1<MetaEvent> events;
    private MetaTypeElementCollection`1<MetaMethod> methods;
    private Dictionary`2<MethodInfo, MetaMethod> methodsIndex;
    private MetaTypeElementCollection`1<MetaProperty> properties;
    public IEnumerable`1<MetaEvent> Events { get; }
    public IEnumerable`1<MetaMethod> Methods { get; }
    public IEnumerable`1<MetaProperty> Properties { get; }
    public IEnumerable`1<MetaEvent> get_Events();
    public IEnumerable`1<MetaMethod> get_Methods();
    public IEnumerable`1<MetaProperty> get_Properties();
    public void AddEvent(MetaEvent event);
    public void AddMethod(MetaMethod method);
    public void AddProperty(MetaProperty property);
    public MetaMethod FindMethod(MethodInfo method);
}
internal abstract class Castle.DynamicProxy.Generators.MetaTypeElement : object {
    private MemberInfo member;
    private string name;
    public bool CanBeImplementedExplicitly { get; }
    public string Name { get; }
    protected MemberInfo Member { get; }
    protected MetaTypeElement(MemberInfo member);
    public bool get_CanBeImplementedExplicitly();
    public string get_Name();
    protected MemberInfo get_Member();
    public abstract virtual void SwitchToExplicitImplementation();
    protected void SwitchToExplicitImplementationName();
    [CompilerGeneratedAttribute]
internal static void <SwitchToExplicitImplementationName>g__AppendTypeName|10_0(StringBuilder nameBuilder, Type type);
}
internal class Castle.DynamicProxy.Generators.MetaTypeElementCollection`1 : object {
    private ICollection`1<TElement> items;
    public void Add(TElement item);
    public bool Contains(TElement item);
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Castle.DynamicProxy.Generators.MethodFinder : object {
    private static Dictionary`2<Type, MethodInfo[]> cachedMethodInfosByType;
    private static object lockObject;
    private static MethodFinder();
    public static MethodInfo[] GetAllInstanceMethods(Type type, BindingFlags flags);
    private static MethodInfo[] MakeFilteredCopy(MethodInfo[] methodsInCache, BindingFlags visibilityFlags);
}
internal abstract class Castle.DynamicProxy.Generators.MethodGenerator : object {
    private MetaMethod method;
    private OverrideMethodDelegate overrideMethod;
    protected MethodInfo MethodOnTarget { get; }
    protected MethodInfo MethodToOverride { get; }
    protected MethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod);
    protected MethodInfo get_MethodOnTarget();
    protected MethodInfo get_MethodToOverride();
    protected abstract virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, INamingScope namingScope);
    public sealed virtual MethodEmitter Generate(ClassEmitter class, INamingScope namingScope);
}
internal class Castle.DynamicProxy.Generators.MethodSignatureComparer : object {
    public static MethodSignatureComparer Instance;
    private static Type preserveBaseOverridesAttribute;
    private static MethodSignatureComparer();
    public bool EqualGenericParameters(MethodInfo x, MethodInfo y);
    public bool EqualParameters(MethodInfo x, MethodInfo y);
    public bool EqualReturnTypes(MethodInfo x, MethodInfo y);
    private bool EqualSignatureTypes(Type x, Type y);
    public sealed virtual bool Equals(MethodInfo x, MethodInfo y);
    public sealed virtual int GetHashCode(MethodInfo obj);
    private bool EqualNames(MethodInfo x, MethodInfo y);
}
internal class Castle.DynamicProxy.Generators.MethodWithInvocationGenerator : MethodGenerator {
    private IInvocationCreationContributor contributor;
    private GetTargetExpressionDelegate getTargetExpression;
    private GetTargetExpressionDelegate getTargetTypeExpression;
    private IExpression interceptors;
    private Type invocation;
    public MethodWithInvocationGenerator(MetaMethod method, IExpression interceptors, Type invocation, GetTargetExpressionDelegate getTargetExpression, OverrideMethodDelegate createMethod, IInvocationCreationContributor contributor);
    public MethodWithInvocationGenerator(MetaMethod method, IExpression interceptors, Type invocation, GetTargetExpressionDelegate getTargetExpression, GetTargetExpressionDelegate getTargetTypeExpression, OverrideMethodDelegate createMethod, IInvocationCreationContributor contributor);
    protected FieldReference BuildMethodInterceptorsField(ClassEmitter class, MethodInfo method, INamingScope namingScope);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, INamingScope namingScope);
    private IExpression SetMethodInterceptors(ClassEmitter class, INamingScope namingScope, MethodEmitter emitter, IExpression proxiedMethodTokenExpression);
    private void EmitLoadGenericMethodArguments(MethodEmitter methodEmitter, MethodInfo method, Reference invocationLocal);
    private IExpression[] GetCtorArguments(ClassEmitter class, IExpression proxiedMethodTokenExpression, TypeReference[] dereferencedArguments, IExpression methodInterceptors);
    private IExpression[] ModifyArguments(ClassEmitter class, IExpression[] arguments);
    private bool HasByRefArguments(ArgumentReference[] arguments);
}
internal class Castle.DynamicProxy.Generators.MinimalisticMethodGenerator : MethodGenerator {
    public MinimalisticMethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, INamingScope namingScope);
    private void InitOutParameters(MethodEmitter emitter, ParameterInfo[] parameters);
}
internal class Castle.DynamicProxy.Generators.NamingScope : object {
    private IDictionary`2<string, int> names;
    private INamingScope parentScope;
    public INamingScope ParentScope { get; }
    private NamingScope(INamingScope parent);
    public sealed virtual INamingScope get_ParentScope();
    public sealed virtual string GetUniqueName(string suggestedName);
    public sealed virtual INamingScope SafeSubScope();
}
internal class Castle.DynamicProxy.Generators.OptionallyForwardingMethodGenerator : MethodGenerator {
    private GetTargetReferenceDelegate getTargetReference;
    public OptionallyForwardingMethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod, GetTargetReferenceDelegate getTargetReference);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, INamingScope namingScope);
    private IStatement IfNotNull(Reference targetReference);
    private IStatement IfNull(Type returnType);
    private void InitOutParameters(BlockStatement statements, ParameterInfo[] parameters);
}
public interface Castle.DynamicProxy.IChangeProxyTarget {
    public abstract virtual void ChangeInvocationTarget(object target);
    [ObsoleteAttribute("Use ((IProxyTargetAccessor)invocation.Proxy).DynProxySetTarget(target) instead.")]
public abstract virtual void ChangeProxyTarget(object target);
}
public interface Castle.DynamicProxy.IInterceptor {
    public abstract virtual void Intercept(IInvocation invocation);
}
public interface Castle.DynamicProxy.IInterceptorSelector {
    public abstract virtual IInterceptor[] SelectInterceptors(Type type, MethodInfo method, IInterceptor[] interceptors);
}
public interface Castle.DynamicProxy.IInvocation {
    public Object[] Arguments { get; }
    public Type[] GenericArguments { get; }
    public object InvocationTarget { get; }
    public MethodInfo Method { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public object Proxy { get; }
    public object ReturnValue { get; public set; }
    public Type TargetType { get; }
    public abstract virtual Object[] get_Arguments();
    public abstract virtual Type[] get_GenericArguments();
    public abstract virtual object get_InvocationTarget();
    public abstract virtual MethodInfo get_Method();
    public abstract virtual MethodInfo get_MethodInvocationTarget();
    public abstract virtual object get_Proxy();
    public abstract virtual object get_ReturnValue();
    public abstract virtual void set_ReturnValue(object value);
    public abstract virtual Type get_TargetType();
    public abstract virtual object GetArgumentValue(int index);
    public abstract virtual MethodInfo GetConcreteMethod();
    public abstract virtual MethodInfo GetConcreteMethodInvocationTarget();
    public abstract virtual void Proceed();
    public abstract virtual IInvocationProceedInfo CaptureProceedInfo();
    public abstract virtual void SetArgumentValue(int index, object value);
}
public interface Castle.DynamicProxy.IInvocationProceedInfo {
    public abstract virtual void Invoke();
}
[ExtensionAttribute]
internal static class Castle.DynamicProxy.Internal.AttributeUtil : object {
    public static CustomAttributeInfo CreateInfo(CustomAttributeData attribute);
    private static Object[] GetArguments(IList`1<CustomAttributeTypedArgument> constructorArguments);
    private static object ReadAttributeValue(CustomAttributeTypedArgument argument);
    private static void GetSettersAndFields(Type attributeType, IEnumerable`1<CustomAttributeNamedArgument> namedArguments, PropertyInfo[]& properties, Object[]& propertyValues, FieldInfo[]& fields, Object[]& fieldValues);
    [IteratorStateMachineAttribute("Castle.DynamicProxy.Internal.AttributeUtil/<GetNonInheritableAttributes>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<CustomAttributeInfo> GetNonInheritableAttributes(MemberInfo member);
    [IteratorStateMachineAttribute("Castle.DynamicProxy.Internal.AttributeUtil/<GetNonInheritableAttributes>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<CustomAttributeInfo> GetNonInheritableAttributes(ParameterInfo parameter);
    private static bool ShouldSkipAttributeReplication(Type attribute, bool ignoreInheritance);
    public static CustomAttributeInfo CreateInfo();
    public static CustomAttributeInfo CreateInfo(Type attribute, Object[] constructorArguments);
    private static Type[] GetTypes(Object[] objects);
}
public abstract class Castle.DynamicProxy.Internal.CompositionInvocation : AbstractInvocation {
    protected object target;
    public object InvocationTarget { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type TargetType { get; }
    protected CompositionInvocation(object target, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    public virtual object get_InvocationTarget();
    public virtual MethodInfo get_MethodInvocationTarget();
    public virtual Type get_TargetType();
    protected void EnsureValidProxyTarget(object newTarget);
    protected void EnsureValidTarget();
}
public abstract class Castle.DynamicProxy.Internal.InheritanceInvocation : AbstractInvocation {
    private Type targetType;
    public object InvocationTarget { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type TargetType { get; }
    protected InheritanceInvocation(Type targetType, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    public virtual object get_InvocationTarget();
    public virtual MethodInfo get_MethodInvocationTarget();
    public virtual Type get_TargetType();
    protected abstract virtual void InvokeMethodOnTarget();
}
[EditorBrowsableAttribute("1")]
public class Castle.DynamicProxy.Internal.InheritanceInvocationWithoutTarget : InheritanceInvocation {
    public InheritanceInvocationWithoutTarget(Type targetType, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    protected virtual void InvokeMethodOnTarget();
}
[EditorBrowsableAttribute("1")]
public class Castle.DynamicProxy.Internal.InterfaceMethodWithoutTargetInvocation : AbstractInvocation {
    public object InvocationTarget { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type TargetType { get; }
    public InterfaceMethodWithoutTargetInvocation(object target, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    public virtual object get_InvocationTarget();
    public virtual MethodInfo get_MethodInvocationTarget();
    public virtual Type get_TargetType();
    protected virtual void InvokeMethodOnTarget();
}
internal static class Castle.DynamicProxy.Internal.InvocationHelper : object {
    private static SynchronizedDictionary`2<CacheKey, MethodInfo> cache;
    private static InvocationHelper();
    public static MethodInfo GetMethodOnObject(object target, MethodInfo proxiedMethod);
    public static MethodInfo GetMethodOnType(Type type, MethodInfo proxiedMethod);
    private static MethodInfo ObtainMethod(MethodInfo proxiedMethod, Type type);
}
[ExtensionAttribute]
public static class Castle.DynamicProxy.Internal.TypeUtil : object {
    [ExtensionAttribute]
internal static bool IsNullableType(Type type);
    [ExtensionAttribute]
internal static FieldInfo[] GetAllFields(Type type);
    internal static Type[] GetAllInterfaces(Type[] types);
    [ExtensionAttribute]
public static Type[] GetAllInterfaces(Type type);
    public static Type GetTypeOrNull(object target);
    [ExtensionAttribute]
internal static Type[] AsTypeArray(GenericTypeParameterBuilder[] typeInfos);
    [ExtensionAttribute]
internal static bool IsFinalizer(MethodInfo methodInfo);
    [ExtensionAttribute]
internal static bool IsGetType(MethodInfo methodInfo);
    [ExtensionAttribute]
internal static bool IsMemberwiseClone(MethodInfo methodInfo);
    [ExtensionAttribute]
internal static void SetStaticField(Type type, string fieldName, BindingFlags additionalFlags, object value);
    public static MemberInfo[] Sort(MemberInfo[] members);
    [ExtensionAttribute]
internal static bool IsDelegateType(Type type);
    private static Type[] Sort(ICollection`1<Type> types);
}
public interface Castle.DynamicProxy.IProxyBuilder {
    public ILogger Logger { get; public set; }
    public ModuleScope ModuleScope { get; }
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual ModuleScope get_ModuleScope();
    public abstract virtual Type CreateClassProxyType(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public abstract virtual Type CreateClassProxyTypeWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public abstract virtual Type CreateInterfaceProxyTypeWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, Type targetType, ProxyGenerationOptions options);
    public abstract virtual Type CreateInterfaceProxyTypeWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public abstract virtual Type CreateInterfaceProxyTypeWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
}
public interface Castle.DynamicProxy.IProxyGenerationHook {
    public abstract virtual void MethodsInspected();
    public abstract virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
    public abstract virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
}
[CLSCompliantAttribute("True")]
public interface Castle.DynamicProxy.IProxyGenerator {
    public ILogger Logger { get; public set; }
    public IProxyBuilder ProxyBuilder { get; }
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual IProxyBuilder get_ProxyBuilder();
    public abstract virtual TInterface CreateInterfaceProxyWithTarget(TInterface target, IInterceptor[] interceptors);
    public abstract virtual TInterface CreateInterfaceProxyWithTarget(TInterface target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, object target, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, object target, IInterceptor[] interceptors);
    public abstract virtual TInterface CreateInterfaceProxyWithTargetInterface(TInterface target, IInterceptor[] interceptors);
    public abstract virtual TInterface CreateInterfaceProxyWithTargetInterface(TInterface target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual TInterface CreateInterfaceProxyWithoutTarget(IInterceptor interceptor);
    public abstract virtual TInterface CreateInterfaceProxyWithoutTarget(IInterceptor[] interceptors);
    public abstract virtual TInterface CreateInterfaceProxyWithoutTarget(ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, IInterceptor interceptor);
    public abstract virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual TClass CreateClassProxyWithTarget(TClass target, IInterceptor[] interceptors);
    public abstract virtual TClass CreateClassProxyWithTarget(TClass target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxyWithTarget(Type classToProxy, object target, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxyWithTarget(Type classToProxy, object target, Object[] constructorArguments, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxyWithTarget(Type classToProxy, object target, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxyWithTarget(Type classToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public abstract virtual TClass CreateClassProxy(IInterceptor[] interceptors);
    public abstract virtual TClass CreateClassProxy(ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxy(Type classToProxy, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxy(Type classToProxy, Object[] constructorArguments, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxy(Type classToProxy, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxy(Type classToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public abstract virtual object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
}
public interface Castle.DynamicProxy.IProxyTargetAccessor {
    public abstract virtual object DynProxyGetTarget();
    public abstract virtual void DynProxySetTarget(object target);
    public abstract virtual IInterceptor[] GetInterceptors();
}
public class Castle.DynamicProxy.MixinData : object {
    private Dictionary`2<Type, int> mixinPositions;
    private List`1<object> mixinsImpl;
    private int delegateMixinCount;
    public IEnumerable`1<Type> MixinInterfaces { get; }
    public IEnumerable`1<object> Mixins { get; }
    public MixinData(IEnumerable`1<object> mixinInstances);
    public IEnumerable`1<Type> get_MixinInterfaces();
    public IEnumerable`1<object> get_Mixins();
    public bool ContainsMixin(Type mixinInterfaceType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public object GetMixinInstance(Type mixinInterfaceType);
    public int GetMixinPosition(Type mixinInterfaceType);
}
public class Castle.DynamicProxy.ModuleScope : object {
    public static string DEFAULT_FILE_NAME;
    public static string DEFAULT_ASSEMBLY_NAME;
    private ModuleBuilder moduleBuilderWithStrongName;
    private ModuleBuilder moduleBuilder;
    private string strongAssemblyName;
    private string weakAssemblyName;
    private string strongModulePath;
    private string weakModulePath;
    private SynchronizedDictionary`2<CacheKey, Type> typeCache;
    private object moduleLocker;
    private bool savePhysicalAssembly;
    private bool disableSignedModule;
    private INamingScope namingScope;
    internal INamingScope NamingScope { get; }
    internal SynchronizedDictionary`2<CacheKey, Type> TypeCache { get; }
    internal ModuleBuilder StrongNamedModule { get; }
    public string StrongNamedModuleName { get; }
    internal ModuleBuilder WeakNamedModule { get; }
    public string WeakNamedModuleName { get; }
    public ModuleScope(bool savePhysicalAssembly);
    public ModuleScope(bool savePhysicalAssembly, bool disableSignedModule);
    public ModuleScope(bool savePhysicalAssembly, bool disableSignedModule, string strongAssemblyName, string strongModulePath, string weakAssemblyName, string weakModulePath);
    internal ModuleScope(bool savePhysicalAssembly, bool disableSignedModule, INamingScope namingScope, string strongAssemblyName, string strongModulePath, string weakAssemblyName, string weakModulePath);
    private static ModuleScope();
    internal INamingScope get_NamingScope();
    internal SynchronizedDictionary`2<CacheKey, Type> get_TypeCache();
    public static Byte[] GetKeyPair();
    internal ModuleBuilder get_StrongNamedModule();
    public string get_StrongNamedModuleName();
    internal ModuleBuilder get_WeakNamedModule();
    public string get_WeakNamedModuleName();
    internal ModuleBuilder ObtainDynamicModule(bool isStrongNamed);
    internal ModuleBuilder ObtainDynamicModuleWithStrongName();
    internal ModuleBuilder ObtainDynamicModuleWithWeakName();
    private ModuleBuilder CreateModule(bool signStrongName);
    private AssemblyName GetAssemblyName(bool signStrongName);
    internal TypeBuilder DefineType(bool inSignedModulePreferably, string name, TypeAttributes flags);
}
public class Castle.DynamicProxy.ProxyGenerationOptions : object {
    public static ProxyGenerationOptions Default;
    private List`1<object> mixins;
    private IList`1<CustomAttributeInfo> additionalAttributes;
    private MixinData mixinData;
    [CompilerGeneratedAttribute]
private IProxyGenerationHook <Hook>k__BackingField;
    [CompilerGeneratedAttribute]
private IInterceptorSelector <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BaseTypeForInterfaceProxy>k__BackingField;
    public IProxyGenerationHook Hook { get; public set; }
    public IInterceptorSelector Selector { get; public set; }
    public Type BaseTypeForInterfaceProxy { get; public set; }
    public IList`1<CustomAttributeInfo> AdditionalAttributes { get; }
    public MixinData MixinData { get; }
    public bool HasMixins { get; }
    public ProxyGenerationOptions(IProxyGenerationHook hook);
    private static ProxyGenerationOptions();
    public void Initialize();
    [CompilerGeneratedAttribute]
public IProxyGenerationHook get_Hook();
    [CompilerGeneratedAttribute]
public void set_Hook(IProxyGenerationHook value);
    [CompilerGeneratedAttribute]
public IInterceptorSelector get_Selector();
    [CompilerGeneratedAttribute]
public void set_Selector(IInterceptorSelector value);
    [CompilerGeneratedAttribute]
public Type get_BaseTypeForInterfaceProxy();
    [CompilerGeneratedAttribute]
public void set_BaseTypeForInterfaceProxy(Type value);
    public IList`1<CustomAttributeInfo> get_AdditionalAttributes();
    public MixinData get_MixinData();
    public void AddDelegateTypeMixin(Type delegateType);
    public void AddDelegateMixin(Delegate delegate);
    public void AddMixinInstance(object instance);
    private void AddMixinImpl(object instanceOrType);
    public Object[] MixinsAsArray();
    public bool get_HasMixins();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private int GetAdditionalAttributesHashCode();
    private bool HasEquivalentAdditionalAttributes(ProxyGenerationOptions other);
}
[CLSCompliantAttribute("True")]
public class Castle.DynamicProxy.ProxyGenerator : object {
    private ILogger logger;
    private IProxyBuilder proxyBuilder;
    public ILogger Logger { get; public set; }
    public IProxyBuilder ProxyBuilder { get; }
    public ProxyGenerator(IProxyBuilder builder);
    public ProxyGenerator(bool disableSignedModule);
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    public sealed virtual IProxyBuilder get_ProxyBuilder();
    public sealed virtual TInterface CreateInterfaceProxyWithTarget(TInterface target, IInterceptor[] interceptors);
    public sealed virtual TInterface CreateInterfaceProxyWithTarget(TInterface target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, object target, IInterceptor[] interceptors);
    public sealed virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    protected List`1<object> GetConstructorArguments(object target, IInterceptor[] interceptors, ProxyGenerationOptions options);
    public sealed virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, object target, IInterceptor[] interceptors);
    public sealed virtual TInterface CreateInterfaceProxyWithTargetInterface(TInterface target, IInterceptor[] interceptors);
    public sealed virtual TInterface CreateInterfaceProxyWithTargetInterface(TInterface target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public sealed virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual TInterface CreateInterfaceProxyWithoutTarget(IInterceptor interceptor);
    public sealed virtual TInterface CreateInterfaceProxyWithoutTarget(IInterceptor[] interceptors);
    public sealed virtual TInterface CreateInterfaceProxyWithoutTarget(ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, IInterceptor interceptor);
    public sealed virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, IInterceptor[] interceptors);
    public sealed virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, IInterceptor[] interceptors);
    public sealed virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual TClass CreateClassProxyWithTarget(TClass target, IInterceptor[] interceptors);
    public sealed virtual TClass CreateClassProxyWithTarget(TClass target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxyWithTarget(Type classToProxy, object target, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxyWithTarget(Type classToProxy, object target, Object[] constructorArguments, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxyWithTarget(Type classToProxy, object target, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxyWithTarget(Type classToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public sealed virtual TClass CreateClassProxy(IInterceptor[] interceptors);
    public sealed virtual TClass CreateClassProxy(ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxy(Type classToProxy, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxy(Type classToProxy, Object[] constructorArguments, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxy(Type classToProxy, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxy(Type classToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public sealed virtual object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    protected object CreateClassProxyInstance(Type proxyType, List`1<object> proxyArguments, Type classToProxy, Object[] constructorArguments);
    protected void CheckNotGenericTypeDefinition(Type type, string argumentName);
    protected void CheckNotGenericTypeDefinitions(IEnumerable`1<Type> types, string argumentName);
    protected List`1<object> BuildArgumentListForClassProxyWithTarget(object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    protected List`1<object> BuildArgumentListForClassProxy(ProxyGenerationOptions options, IInterceptor[] interceptors);
    protected Type CreateClassProxyType(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    protected Type CreateInterfaceProxyTypeWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, Type targetType, ProxyGenerationOptions options);
    protected Type CreateInterfaceProxyTypeWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    protected Type CreateInterfaceProxyTypeWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    protected Type CreateClassProxyTypeWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
}
public static class Castle.DynamicProxy.ProxyUtil : object {
    private static SynchronizedDictionary`2<Assembly, bool> internalsVisibleToDynamicProxy;
    private static ProxyUtil();
    public static TDelegate CreateDelegateToMixin(object proxy);
    public static Delegate CreateDelegateToMixin(object proxy, Type delegateType);
    public static object GetUnproxiedInstance(object instance);
    public static Type GetUnproxiedType(object instance);
    public static bool IsProxy(object instance);
    public static bool IsProxyType(Type type);
    public static bool IsAccessible(MethodBase method);
    public static bool IsAccessible(MethodBase method, String& message);
    public static bool IsAccessible(Type type);
    internal static bool AreInternalsVisibleToDynamicProxy(Assembly asm);
    internal static bool IsAccessibleType(Type target);
    internal static bool IsAccessibleMethod(MethodBase method);
    internal static bool IsInternal(MethodBase method);
    private static string CreateMessageForInaccessibleMethod(MethodBase inaccessibleMethod);
}
internal static class Castle.DynamicProxy.Serialization.ProxyTypeConstants : object {
    public static string Class;
    public static string ClassWithTarget;
    public static string InterfaceWithTarget;
    public static string InterfaceWithTargetInterface;
    public static string InterfaceWithoutTarget;
    private static ProxyTypeConstants();
}
public class Castle.DynamicProxy.StandardInterceptor : object {
    public sealed virtual void Intercept(IInvocation invocation);
    protected virtual void PerformProceed(IInvocation invocation);
    protected virtual void PreProceed(IInvocation invocation);
    protected virtual void PostProceed(IInvocation invocation);
}
internal static class Castle.DynamicProxy.Tokens.DelegateMethods : object {
    public static MethodInfo CreateDelegate;
    private static DelegateMethods();
}
internal static class Castle.DynamicProxy.Tokens.InterceptorSelectorMethods : object {
    public static MethodInfo SelectInterceptors;
    private static InterceptorSelectorMethods();
}
internal static class Castle.DynamicProxy.Tokens.InvocationMethods : object {
    public static ConstructorInfo CompositionInvocationConstructor;
    public static MethodInfo CompositionInvocationEnsureValidTarget;
    public static MethodInfo GetArgumentValue;
    public static MethodInfo GetArguments;
    public static MethodInfo GetReturnValue;
    public static ConstructorInfo InheritanceInvocationConstructor;
    public static ConstructorInfo InheritanceInvocationConstructorWithSelector;
    public static MethodInfo Proceed;
    public static FieldInfo ProxyObject;
    public static MethodInfo SetArgumentValue;
    public static MethodInfo SetGenericMethodArguments;
    public static MethodInfo SetReturnValue;
    public static FieldInfo CompositionInvocationTarget;
    public static MethodInfo ThrowOnNoTarget;
    public static MethodInfo EnsureValidTarget;
    public static FieldInfo Target;
    private static InvocationMethods();
}
internal static class Castle.DynamicProxy.Tokens.MethodBaseMethods : object {
    public static MethodInfo GetMethodFromHandle;
    private static MethodBaseMethods();
}
internal static class Castle.DynamicProxy.Tokens.TypeMethods : object {
    public static MethodInfo GetTypeFromHandle;
    public static MethodInfo StaticGetType;
    private static TypeMethods();
}
internal static class Castle.DynamicProxy.Tokens.TypeUtilMethods : object {
    public static MethodInfo Sort;
    public static MethodInfo GetTypeOrNull;
    private static TypeUtilMethods();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
