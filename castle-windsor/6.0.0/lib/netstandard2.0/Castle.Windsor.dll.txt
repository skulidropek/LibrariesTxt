[AttributeUsageAttribute("4")]
public class Castle.Core.BoundToAttribute : LifestyleAttribute {
    [CompilerGeneratedAttribute]
private Type <ScopeRootBinderType>k__BackingField;
    public Type ScopeRootBinderType { get; private set; }
    public BoundToAttribute(Type scopeRootBinderType);
    [CompilerGeneratedAttribute]
public Type get_ScopeRootBinderType();
    [CompilerGeneratedAttribute]
private void set_ScopeRootBinderType(Type value);
}
[AttributeUsageAttribute("4")]
public class Castle.Core.CastleComponentAttribute : LifestyleAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ServicesSpecifiedExplicitly>k__BackingField;
    public bool HasName { get; }
    public string Name { get; private set; }
    public Type[] Services { get; private set; }
    public bool ServicesSpecifiedExplicitly { get; private set; }
    public CastleComponentAttribute(string name);
    public CastleComponentAttribute(Type[] services);
    public CastleComponentAttribute(string name, Type[] services);
    public CastleComponentAttribute(string name, LifestyleType lifestyle, Type[] services);
    public bool get_HasName();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type[] get_Services();
    [CompilerGeneratedAttribute]
private void set_Services(Type[] value);
    [CompilerGeneratedAttribute]
public bool get_ServicesSpecifiedExplicitly();
    [CompilerGeneratedAttribute]
private void set_ServicesSpecifiedExplicitly(bool value);
    public static CastleComponentAttribute GetDefaultsFor(Type type);
}
[AttributeUsageAttribute("4")]
public class Castle.Core.ComponentActivatorAttribute : Attribute {
    private Type componentActivatorType;
    public Type ComponentActivatorType { get; }
    public ComponentActivatorAttribute(Type componentActivatorType);
    public Type get_ComponentActivatorType();
}
public class Castle.Core.ComponentDependencyModel : DependencyModel {
    public ComponentDependencyModel(string referencedComponentName);
    public ComponentDependencyModel(string referencedComponentName, Type serviceType);
    public virtual void Init(ParameterModelCollection parameters);
}
public class Castle.Core.ComponentModel : GraphNode {
    [DebuggerBrowsableAttribute("0")]
private ConstructorCandidateCollection constructors;
    [DebuggerBrowsableAttribute("0")]
private LifecycleConcernsCollection lifecycle;
    [DebuggerBrowsableAttribute("0")]
private List`1<Type> services;
    private HashSet`1<Type> servicesLookup;
    [DebuggerBrowsableAttribute("0")]
private ComponentName componentName;
    [DebuggerBrowsableAttribute("0")]
private Arguments customDependencies;
    [DebuggerBrowsableAttribute("0")]
private DependencyModelCollection dependencies;
    [DebuggerBrowsableAttribute("0")]
private Arguments extendedProperties;
    [DebuggerBrowsableAttribute("0")]
private InterceptorReferenceCollection interceptors;
    [DebuggerBrowsableAttribute("0")]
private ParameterModelCollection parameters;
    [DebuggerBrowsableAttribute("0")]
private PropertySetCollection properties;
    [CompilerGeneratedAttribute]
private IConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CustomComponentActivator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CustomLifestyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Implementation>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertiesInspectionBehavior <InspectionBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private LifestyleType <LifestyleType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresGenericArguments>k__BackingField;
    public ComponentName ComponentName { get; internal set; }
    public IConfiguration Configuration { get; public set; }
    [DebuggerDisplayAttribute("Count = {constructors.Count}")]
public ConstructorCandidateCollection Constructors { get; }
    public Type CustomComponentActivator { get; public set; }
    [DebuggerDisplayAttribute("Count = {customDependencies.Count}")]
public Arguments CustomDependencies { get; }
    public Type CustomLifestyle { get; public set; }
    [DebuggerDisplayAttribute("Count = {dependencies.dependencies.Count}")]
public DependencyModelCollection Dependencies { get; }
    [DebuggerDisplayAttribute("Count = {extendedProperties.Count}")]
public Arguments ExtendedProperties { get; }
    public bool HasClassServices { get; }
    [DebuggerBrowsableAttribute("0")]
public bool HasCustomDependencies { get; }
    [DebuggerBrowsableAttribute("0")]
public bool HasInterceptors { get; }
    [DebuggerBrowsableAttribute("0")]
public bool HasParameters { get; }
    public Type Implementation { get; public set; }
    public PropertiesInspectionBehavior InspectionBehavior { get; public set; }
    [DebuggerDisplayAttribute("Count = {interceptors.list.Count}")]
public InterceptorReferenceCollection Interceptors { get; }
    [DebuggerDisplayAttribute("Count = {(lifecycle.commission != null ? lifecycle.commission.Count : 0) + (lifecycle.decommission != null ? lifecycle.decommission.Count : 0)}")]
public LifecycleConcernsCollection Lifecycle { get; }
    public LifestyleType LifestyleType { get; public set; }
    public string Name { get; public set; }
    public ParameterModelCollection Parameters { get; }
    [DebuggerDisplayAttribute("Count = {properties.Count}")]
public PropertySetCollection Properties { get; }
    public bool RequiresGenericArguments { get; public set; }
    [DebuggerDisplayAttribute("Count = {services.Count}")]
public IEnumerable`1<Type> Services { get; }
    internal HashSet`1<Type> ServicesLookup { get; }
    [DebuggerBrowsableAttribute("0")]
internal ParameterModelCollection ParametersInternal { get; }
    public ComponentModel(ComponentName name, ICollection`1<Type> services, Type implementation, Arguments extendedProperties);
    public ComponentName get_ComponentName();
    internal void set_ComponentName(ComponentName value);
    [CompilerGeneratedAttribute]
public IConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(IConfiguration value);
    public ConstructorCandidateCollection get_Constructors();
    [CompilerGeneratedAttribute]
public Type get_CustomComponentActivator();
    [CompilerGeneratedAttribute]
public void set_CustomComponentActivator(Type value);
    public Arguments get_CustomDependencies();
    [CompilerGeneratedAttribute]
public Type get_CustomLifestyle();
    [CompilerGeneratedAttribute]
public void set_CustomLifestyle(Type value);
    public DependencyModelCollection get_Dependencies();
    public Arguments get_ExtendedProperties();
    public bool get_HasClassServices();
    public bool get_HasCustomDependencies();
    public bool get_HasInterceptors();
    public bool get_HasParameters();
    [CompilerGeneratedAttribute]
public Type get_Implementation();
    [CompilerGeneratedAttribute]
public void set_Implementation(Type value);
    [CompilerGeneratedAttribute]
public PropertiesInspectionBehavior get_InspectionBehavior();
    [CompilerGeneratedAttribute]
public void set_InspectionBehavior(PropertiesInspectionBehavior value);
    public InterceptorReferenceCollection get_Interceptors();
    public LifecycleConcernsCollection get_Lifecycle();
    [CompilerGeneratedAttribute]
public LifestyleType get_LifestyleType();
    [CompilerGeneratedAttribute]
public void set_LifestyleType(LifestyleType value);
    public string get_Name();
    public void set_Name(string value);
    public ParameterModelCollection get_Parameters();
    public PropertySetCollection get_Properties();
    [CompilerGeneratedAttribute]
public bool get_RequiresGenericArguments();
    [CompilerGeneratedAttribute]
public void set_RequiresGenericArguments(bool value);
    public IEnumerable`1<Type> get_Services();
    internal HashSet`1<Type> get_ServicesLookup();
    internal ParameterModelCollection get_ParametersInternal();
    public void AddConstructor(ConstructorCandidate constructor);
    public void AddProperty(PropertySet property);
    public void AddService(Type type);
    public void Requires(Predicate`1[] selectors);
    public void Requires();
    public virtual string ToString();
}
public class Castle.Core.ComponentName : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetByUser>k__BackingField;
    public string Name { get; private set; }
    public bool SetByUser { get; private set; }
    public ComponentName(string name, bool setByUser);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_SetByUser();
    [CompilerGeneratedAttribute]
private void set_SetByUser(bool value);
    public virtual string ToString();
    internal void SetName(string value);
    public static ComponentName DefaultFor(Type componentType);
    public static string DefaultNameFor(Type componentType);
}
[AttributeUsageAttribute("4")]
public class Castle.Core.ComponentProxyBehaviorAttribute : Attribute {
    private Type[] additionalInterfaces;
    public Type[] AdditionalInterfaces { get; public set; }
    public Type[] get_AdditionalInterfaces();
    public void set_AdditionalInterfaces(Type[] value);
}
public class Castle.Core.ConstructorCandidate : object {
    private ConstructorInfo constructorInfo;
    private ConstructorDependencyModel[] dependencies;
    public ConstructorInfo Constructor { get; }
    public ConstructorDependencyModel[] Dependencies { get; }
    public ConstructorCandidate(ConstructorInfo constructorInfo, ConstructorDependencyModel[] dependencies);
    public ConstructorInfo get_Constructor();
    public ConstructorDependencyModel[] get_Dependencies();
    private void InitParameter(ConstructorDependencyModel parameter);
    private sealed virtual override int System.IComparable<Castle.Core.ConstructorCandidate>.CompareTo(ConstructorCandidate other);
}
[DefaultMemberAttribute("Item")]
public class Castle.Core.ConstructorCandidateCollection : object {
    private SimpleSortedSet`1<ConstructorCandidate> ctors;
    public int Count { get; }
    public ConstructorCandidate Item { get; }
    public sealed virtual int get_Count();
    public ConstructorCandidate get_Item(int index);
    [DebuggerStepThroughAttribute]
public sealed virtual IEnumerator`1<ConstructorCandidate> GetEnumerator();
    [DebuggerStepThroughAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void Castle.Core.Internal.IMutableCollection<Castle.Core.ConstructorCandidate>.Add(ConstructorCandidate item);
    private sealed virtual override bool Castle.Core.Internal.IMutableCollection<Castle.Core.ConstructorCandidate>.Remove(ConstructorCandidate item);
}
public class Castle.Core.ConstructorDependencyModel : DependencyModel {
    private ConstructorCandidate constructor;
    public ConstructorCandidate Constructor { get; }
    public ConstructorDependencyModel(ParameterInfo parameter);
    public ConstructorCandidate get_Constructor();
    internal void SetParentConstructor(ConstructorCandidate ctor);
}
[AttributeUsageAttribute("4")]
public class Castle.Core.CustomLifestyleAttribute : LifestyleAttribute {
    [CompilerGeneratedAttribute]
private Type <CustomLifestyleType>k__BackingField;
    public Type CustomLifestyleType { get; }
    public CustomLifestyleAttribute(Type customLifestyleType);
    [CompilerGeneratedAttribute]
public Type get_CustomLifestyleType();
}
public class Castle.Core.DependencyModel : object {
    private Type targetItemType;
    private Type targetType;
    protected ParameterModel parameterModel;
    protected string reference;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependencyKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public object DefaultValue { get; public set; }
    public string DependencyKey { get; public set; }
    public bool HasDefaultValue { get; public set; }
    public bool IsOptional { get; public set; }
    public bool IsPrimitiveTypeDependency { get; }
    public ParameterModel Parameter { get; public set; }
    public string ReferencedComponentName { get; }
    public Type TargetItemType { get; }
    public Type TargetType { get; }
    public DependencyModel(string dependencyKey, Type targetType, bool isOptional);
    public DependencyModel(string dependencyKey, Type targetType, bool isOptional, bool hasDefaultValue, object defaultValue);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public string get_DependencyKey();
    [CompilerGeneratedAttribute]
public void set_DependencyKey(string value);
    [CompilerGeneratedAttribute]
public bool get_HasDefaultValue();
    [CompilerGeneratedAttribute]
public void set_HasDefaultValue(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
    public bool get_IsPrimitiveTypeDependency();
    public ParameterModel get_Parameter();
    public void set_Parameter(ParameterModel value);
    public string get_ReferencedComponentName();
    public Type get_TargetItemType();
    public Type get_TargetType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Init(ParameterModelCollection parameters);
    public virtual string ToString();
    private ParameterModel GetParameterModelByType(Type type, ParameterModelCollection parameters);
    private ParameterModel ObtainParameterModelByName(ParameterModelCollection parameters);
    private ParameterModel ObtainParameterModelByType(ParameterModelCollection parameters);
}
[DebuggerDisplayAttribute("Count = {dependencies.Count}")]
public class Castle.Core.DependencyModelCollection : object {
    [DebuggerBrowsableAttribute("3")]
private List`1<DependencyModel> dependencies;
    [DebuggerBrowsableAttribute("0")]
public int Count { get; }
    public sealed virtual int get_Count();
    [DebuggerStepThroughAttribute]
public sealed virtual IEnumerator`1<DependencyModel> GetEnumerator();
    public sealed virtual void Add(DependencyModel dependencyModel);
    public sealed virtual bool Remove(DependencyModel dependencyModel);
    [DebuggerStepThroughAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[AttributeUsageAttribute("32")]
public class Castle.Core.DoNotSelectAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class Castle.Core.DoNotWireAttribute : Attribute {
}
public interface Castle.Core.ICommissionConcern {
    public abstract virtual void Apply(ComponentModel model, object component);
}
public interface Castle.Core.IDecommissionConcern {
    public abstract virtual void Apply(ComponentModel model, object component);
}
public interface Castle.Core.IInitializable {
    public abstract virtual void Initialize();
}
public interface Castle.Core.Interceptor.IOnBehalfAware {
    public abstract virtual void SetInterceptedComponentModel(ComponentModel target);
}
[AttributeUsageAttribute("32767")]
public class Castle.Core.InterceptorAttribute : Attribute {
    private InterceptorReference interceptorRef;
    public InterceptorReference Interceptor { get; }
    public InterceptorAttribute(string componentKey);
    public InterceptorAttribute(Type interceptorType);
    public virtual InterceptorReference get_Interceptor();
}
public class Castle.Core.InterceptorReference : object {
    [DebuggerBrowsableAttribute("0")]
private string referencedComponentName;
    [DebuggerBrowsableAttribute("0")]
private Type referencedComponentType;
    public InterceptorReference(string referencedComponentName);
    public InterceptorReference(Type componentType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(InterceptorReference other);
    private Type ComponentType();
    private StringBuilder GetExceptionMessageOnHandlerNotFound(IKernel kernel);
    private IHandler GetInterceptorHandler(IKernel kernel);
    private CreationContext RebuildContext(Type handlerType, CreationContext current);
    private sealed virtual override void Castle.MicroKernel.IReference<Castle.DynamicProxy.IInterceptor>.Attach(ComponentModel component);
    private sealed virtual override void Castle.MicroKernel.IReference<Castle.DynamicProxy.IInterceptor>.Detach(ComponentModel component);
    private sealed virtual override IInterceptor Castle.MicroKernel.IReference<Castle.DynamicProxy.IInterceptor>.Resolve(IKernel kernel, CreationContext context);
    public static InterceptorReference ForKey(string key);
    public static InterceptorReference ForType(Type service);
    public static InterceptorReference ForType();
}
public class Castle.Core.InterceptorReferenceCollection : object {
    [DebuggerBrowsableAttribute("0")]
private ComponentModel component;
    [DebuggerBrowsableAttribute("3")]
[DebuggerDisplayAttribute("Count = {list.Count}")]
private List`1<InterceptorReference> list;
    [DebuggerBrowsableAttribute("0")]
public bool HasInterceptors { get; }
    [DebuggerBrowsableAttribute("0")]
public int Count { get; }
    public InterceptorReferenceCollection(ComponentModel component);
    public bool get_HasInterceptors();
    public sealed virtual int get_Count();
    public void AddFirst(InterceptorReference item);
    public void AddIfNotInCollection(InterceptorReference interceptorReference);
    public void AddLast(InterceptorReference item);
    public void Insert(int index, InterceptorReference item);
    public InterceptorReference[] ToArray();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual void Add(InterceptorReference item);
    private void Attach(IReference`1<IInterceptor> interceptor);
    private sealed virtual override IEnumerator`1<InterceptorReference> System.Collections.Generic.IEnumerable<Castle.Core.InterceptorReference>.GetEnumerator();
    private sealed virtual override bool Castle.Core.Internal.IMutableCollection<Castle.Core.InterceptorReference>.Remove(InterceptorReference item);
}
internal class Castle.Core.Internal.ColorsSet : object {
    private IDictionary`2<IVertex, VertexColor> items;
    public ColorsSet(IVertex[] items);
    public VertexColor ColorOf(IVertex item);
    public void Set(IVertex item, VertexColor color);
}
[ExtensionAttribute]
public static class Castle.Core.Internal.ComponentModelExtensions : object {
    [ExtensionAttribute]
public static Predicate`1<Type> GetDefaultComponentForServiceFilter(ComponentModel component);
    [ExtensionAttribute]
public static Predicate`1<Type> GetFallbackComponentForServiceFilter(ComponentModel component);
}
public class Castle.Core.Internal.ComponentServicesUtil : object {
    private static TypeByInheritanceDepthMostSpecificFirstComparer comparer;
    private static ComponentServicesUtil();
    public static void AddService(IList`1<Type> existingServices, HashSet`1<Type> lookup, Type newService);
}
public static class Castle.Core.Internal.Constants : object {
    private static string defaultComponentForServiceFilter;
    private static string fallbackComponentForServiceFilter;
    private static string genericImplementationMatchingStrategy;
    private static string genericServiceStrategy;
    private static string propertyFilters;
    private static string scopeAccessorType;
    private static string scopeRootSelector;
    public static string DefaultComponentForServiceFilter { get; }
    public static string ExceptionHelpLink { get; }
    public static string FallbackComponentForServiceFilter { get; }
    public static string GenericImplementationMatchingStrategy { get; }
    public static string GenericServiceStrategy { get; }
    public static string PropertyFilters { get; }
    public static string ScopeAccessorType { get; }
    public static string ScopeRootSelector { get; }
    public static string get_DefaultComponentForServiceFilter();
    public static string get_ExceptionHelpLink();
    public static string get_FallbackComponentForServiceFilter();
    public static string get_GenericImplementationMatchingStrategy();
    public static string get_GenericServiceStrategy();
    public static string get_PropertyFilters();
    public static string get_ScopeAccessorType();
    public static string get_ScopeRootSelector();
}
[ExtensionAttribute]
internal static class Castle.Core.Internal.EnumerableExtensions : object {
    [ExtensionAttribute]
public static TResult[] ConvertAll(T[] items, Func`2<T, TResult> converter);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> items, Action`1<T> action);
}
[ExtensionAttribute]
public static class Castle.Core.Internal.ExceptionHelper : object {
    [ExtensionAttribute]
public static Exception SetUp(Exception exception);
}
public class Castle.Core.Internal.GraphNode : object {
    private SimpleThreadSafeCollection`1<GraphNode> outgoing;
    public GraphNode[] Dependents { get; }
    private IVertex[] Castle.Core.Internal.IVertex.Adjacencies { get; }
    public void AddDependent(GraphNode node);
    public GraphNode[] get_Dependents();
    private sealed virtual override IVertex[] Castle.Core.Internal.IVertex.get_Adjacencies();
}
public static class Castle.Core.Internal.HelpfulExceptionsUtil : object {
    public static Exception TrackInstanceCalledMultipleTimes(object instance, Burden burden);
    private static bool IsUsingFactoryMethod(ComponentModel componentModel);
}
public interface Castle.Core.Internal.IAssemblyProvider {
    public abstract virtual IEnumerable`1<Assembly> GetAssemblies();
}
public interface Castle.Core.Internal.IMutableCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual void Add(T item);
    public abstract virtual bool Remove(T item);
}
public interface Castle.Core.Internal.IVertex {
    public IVertex[] Adjacencies { get; }
    public abstract virtual IVertex[] get_Adjacencies();
}
public class Castle.Core.Internal.LateBoundComponent : object {
    [DebuggerBrowsableAttribute("0")]
public static object Instance;
    private static LateBoundComponent();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Castle.Core.Internal.LifestyleExtensions : object {
    [ExtensionAttribute]
public static Type GetScopeAccessorType(ComponentModel model);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public static class Castle.Core.Internal.Must : object {
    public static T NotBeEmpty(T arg, string name);
    public static T NotBeNull(T arg, string name);
}
[ExtensionAttribute]
public static class Castle.Core.Internal.ReflectionUtil : object {
    public static Type[] OpenGenericArrayInterfaces;
    private static ConcurrentDictionary`2<ConstructorInfo, Func`2<Object[], object>> factories;
    private static ReflectionUtil();
    [ExtensionAttribute]
public static TBase CreateInstance(Type subtypeofTBase, Object[] ctorArgs);
    public static IEnumerable`1<Assembly> GetApplicationAssemblies(Assembly rootAssembly);
    public static IEnumerable`1<Assembly> GetAssemblies(IAssemblyProvider assemblyProvider);
    public static Assembly GetAssemblyNamed(string assemblyName);
    public static Assembly GetAssemblyNamed(string filePath, Predicate`1<AssemblyName> nameFilter, Predicate`1<Assembly> assemblyFilter);
    [ExtensionAttribute]
public static Type[] GetAvailableTypes(Assembly assembly, bool includeNonExported);
    [ExtensionAttribute]
public static Type[] GetAvailableTypesOrdered(Assembly assembly, bool includeNonExported);
    private static Assembly LoadAssembly(AssemblyName assemblyName);
    [ExtensionAttribute]
public static TAttribute[] GetAttributes(MemberInfo item, bool inherit);
    [ExtensionAttribute]
internal static TAttribute[] GetAttributes(Type item, bool inherit);
    [ExtensionAttribute]
public static Type GetCompatibleArrayItemType(Type type);
    [ExtensionAttribute]
public static bool HasDefaultValue(ParameterInfo item);
    [ExtensionAttribute]
public static bool Is(Type type);
    public static bool IsAssemblyFile(string filePath);
    private static Func`2<Object[], object> BuildFactory(ConstructorInfo ctor);
    private static void EnsureIsAssignable(Type subtypeofTBase);
    private static AssemblyName GetAssemblyName(string filePath);
    private static TBase Instantiate(Type subtypeofTBase, Object[] ctorArgs);
    [ExtensionAttribute]
public static object Instantiate(ConstructorInfo ctor, Object[] ctorArgs);
    private static bool IsDll(string extension);
    private static bool IsExe(string extension);
    private static void AddApplicationAssemblies(Assembly assembly, HashSet`1<Assembly> assemblies, string applicationName);
    private static bool IsApplicationAssembly(string applicationName, string assemblyName);
}
public class Castle.Core.Internal.SegmentedList`1 : object {
    private List`1[] segments;
    public SegmentedList`1(int segmentCount);
    public void AddFirst(int segmentIndex, T item);
    public void AddLast(int segmentIndex, T item);
    public T[] ToArray();
    private List`1<T> GetSegment(int segmentIndex);
}
[DefaultMemberAttribute("Item")]
public class Castle.Core.Internal.SimpleSortedSet`1 : object {
    private IComparer`1<T> comparer;
    private List`1<T> items;
    public T Item { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public SimpleSortedSet`1(IComparer`1<T> comparer);
    public SimpleSortedSet`1(IEnumerable`1<T> other, IComparer`1<T> comparer);
    public T get_Item(int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Castle.Core.Internal.SimpleThreadSafeCollection`1 : object {
    private List`1<T> implementation;
    private Lock lock;
    public int Count { get; }
    public int get_Count();
    public void Add(T item);
    public bool Remove(T item);
    public T[] ToArray();
}
public class Castle.Core.Internal.SimpleThreadSafeDictionary`2 : object {
    private Dictionary`2<TKey, TValue> inner;
    private Lock lock;
    public bool Contains(TKey key);
    public TValue[] EjectAllValues();
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> factory);
    public TValue GetOrThrow(TKey key);
}
public class Castle.Core.Internal.SimpleThreadSafeSet`1 : object {
    private HashSet`1<T> implementation;
    private Lock lock;
    public int Count { get; }
    public int get_Count();
    public bool Add(T item);
    public bool Remove(T item);
    public T[] ToArray();
}
[ExtensionAttribute]
public static class Castle.Core.Internal.StringExtensions : object {
    [ExtensionAttribute]
public static bool EqualsText(string one, string two);
}
public class Castle.Core.Internal.ThreadSafeFlag : ValueType {
    private int signaled;
    public bool Signal();
}
public class Castle.Core.Internal.ThreadSafeInit : object {
    private static int Initialized;
    private static int NotInitialized;
    private int state;
    public void EndThreadSafeOnceSection();
    public bool ExecuteThreadSafeOnce();
}
internal class Castle.Core.Internal.TimestampSet : object {
    private IDictionary`2<IVertex, int> items;
    public void Register(IVertex item, int time);
    public int TimeOf(IVertex item);
}
public abstract class Castle.Core.Internal.TopologicalSortAlgo : object {
    public static IVertex[] Sort(IVertex[] graphNodes);
    private static void Visit(IVertex node, ColorsSet colors, TimestampSet discovery, TimestampSet finish, LinkedList`1<IVertex> list, Int32& time);
}
public class Castle.Core.Internal.TypeByInheritanceDepthMostSpecificFirstComparer : object {
    public sealed virtual int Compare(Type x, Type y);
}
[ExtensionAttribute]
public static class Castle.Core.Internal.TypeUtil : object {
    [ExtensionAttribute]
internal static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool IsPrimitiveTypeOrCollection(Type type);
    [ExtensionAttribute]
public static bool IsPrimitiveType(Type type);
    [ExtensionAttribute]
public static string ToCSharpString(Type type);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static Type TryMakeGenericType(Type openGeneric, Type[] arguments);
    private static void AppendGenericParameters(StringBuilder name, Type[] genericArguments, int skip, int take);
    private static void ToCSharpString(Type type, StringBuilder name, Type startType);
}
internal enum Castle.Core.Internal.VertexColor : Enum {
    public int value__;
    public static VertexColor NotInThisSet;
    public static VertexColor White;
    public static VertexColor Gray;
    public static VertexColor Black;
}
public interface Castle.Core.IRecyclable {
    public abstract virtual void Recycle();
}
public interface Castle.Core.IStartable {
    public abstract virtual void Start();
    public abstract virtual void Stop();
}
public class Castle.Core.LifecycleConcernsCollection : object {
    [DebuggerBrowsableAttribute("0")]
private List`1<ICommissionConcern> commission;
    [DebuggerBrowsableAttribute("0")]
private List`1<IDecommissionConcern> decommission;
    public IEnumerable`1<ICommissionConcern> CommissionConcerns { get; }
    public IEnumerable`1<IDecommissionConcern> DecommissionConcerns { get; }
    [DebuggerBrowsableAttribute("0")]
public bool HasCommissionConcerns { get; }
    [DebuggerBrowsableAttribute("0")]
public bool HasDecommissionConcerns { get; }
    [DebuggerBrowsableAttribute("0")]
private List`1<ICommissionConcern> Commission { get; }
    [DebuggerBrowsableAttribute("0")]
private List`1<IDecommissionConcern> Decommission { get; }
    public IEnumerable`1<ICommissionConcern> get_CommissionConcerns();
    public IEnumerable`1<IDecommissionConcern> get_DecommissionConcerns();
    public bool get_HasCommissionConcerns();
    public bool get_HasDecommissionConcerns();
    private List`1<ICommissionConcern> get_Commission();
    private List`1<IDecommissionConcern> get_Decommission();
    public void Add(ICommissionConcern concern);
    public void Add(IDecommissionConcern concern);
    public void AddFirst(ICommissionConcern concern);
    public void AddFirst(IDecommissionConcern concern);
    public void Remove(ICommissionConcern concern);
    public void Remove(IDecommissionConcern concern);
}
[AttributeUsageAttribute("4")]
public abstract class Castle.Core.LifestyleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LifestyleType <Lifestyle>k__BackingField;
    public LifestyleType Lifestyle { get; public set; }
    protected LifestyleAttribute(LifestyleType type);
    [CompilerGeneratedAttribute]
public LifestyleType get_Lifestyle();
    [CompilerGeneratedAttribute]
public void set_Lifestyle(LifestyleType value);
}
public enum Castle.Core.LifestyleType : Enum {
    public int value__;
    public static LifestyleType Undefined;
    public static LifestyleType Singleton;
    public static LifestyleType Thread;
    public static LifestyleType Transient;
    public static LifestyleType Pooled;
    public static LifestyleType Custom;
    public static LifestyleType Scoped;
    public static LifestyleType Bound;
}
public class Castle.Core.MethodMetaModel : object {
    private IConfiguration configNode;
    public IConfiguration ConfigNode { get; }
    public MethodMetaModel(IConfiguration configNode);
    public IConfiguration get_ConfigNode();
}
public class Castle.Core.MethodMetaModelCollection : Collection`1<MethodMetaModel> {
    private IDictionary methodInfo2Model;
    public IDictionary MethodInfo2Model { get; }
    public IDictionary get_MethodInfo2Model();
}
public class Castle.Core.ParameterModel : object {
    private IConfiguration configValue;
    private string name;
    private string value;
    public IConfiguration ConfigValue { get; }
    public string Name { get; }
    public string Value { get; }
    public ParameterModel(string name, string value);
    public ParameterModel(string name, IConfiguration value);
    public IConfiguration get_ConfigValue();
    public string get_Name();
    public string get_Value();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {dictionary.Count}")]
public class Castle.Core.ParameterModelCollection : object {
    [DebuggerBrowsableAttribute("3")]
private IDictionary`2<string, ParameterModel> dictionary;
    [DebuggerBrowsableAttribute("0")]
public int Count { get; }
    public ParameterModel Item { get; }
    public int get_Count();
    public ParameterModel get_Item(string key);
    public void Add(string name, string value);
    public void Add(string name, IConfiguration configNode);
    private void Add(string key, ParameterModel value);
    [DebuggerStepThroughAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [DebuggerStepThroughAttribute]
private sealed virtual override IEnumerator`1<ParameterModel> System.Collections.Generic.IEnumerable<Castle.Core.ParameterModel>.GetEnumerator();
}
[AttributeUsageAttribute("4")]
public class Castle.Core.PerThreadAttribute : LifestyleAttribute {
}
[AttributeUsageAttribute("4")]
public class Castle.Core.PooledAttribute : LifestyleAttribute {
    private static int Initial_PoolSize;
    private static int Max_PoolSize;
    private int initialPoolSize;
    private int maxPoolSize;
    public int InitialPoolSize { get; }
    public int MaxPoolSize { get; }
    public PooledAttribute(int initialPoolSize, int maxPoolSize);
    private static PooledAttribute();
    public int get_InitialPoolSize();
    public int get_MaxPoolSize();
}
public enum Castle.Core.PropertiesInspectionBehavior : Enum {
    public int value__;
    public static PropertiesInspectionBehavior Undefined;
    public static PropertiesInspectionBehavior None;
    public static PropertiesInspectionBehavior All;
    public static PropertiesInspectionBehavior DeclaredOnly;
}
public class Castle.Core.PropertyDependencyFilter : MulticastDelegate {
    public PropertyDependencyFilter(object object, IntPtr method);
    public virtual PropertySet[] Invoke(ComponentModel model, ICollection`1<PropertyInfo> properties, PropertySetBuilder buildDependencyCallback);
    public virtual IAsyncResult BeginInvoke(ComponentModel model, ICollection`1<PropertyInfo> properties, PropertySetBuilder buildDependencyCallback, AsyncCallback callback, object object);
    public virtual PropertySet[] EndInvoke(IAsyncResult result);
}
public class Castle.Core.PropertyDependencyModel : DependencyModel {
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    public PropertyInfo Property { get; private set; }
    public PropertyDependencyModel(PropertyInfo property, bool isOptional);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(PropertyInfo value);
}
public enum Castle.Core.PropertyFilter : Enum {
    public int value__;
    public static PropertyFilter Default;
    public static PropertyFilter RequireAll;
    public static PropertyFilter RequireBase;
    public static PropertyFilter IgnoreAll;
    public static PropertyFilter IgnoreBase;
}
public class Castle.Core.PropertySet : object {
    private DependencyModel dependency;
    private PropertyInfo propertyInfo;
    public DependencyModel Dependency { get; }
    public PropertyInfo Property { get; }
    public PropertySet(PropertyInfo propertyInfo, DependencyModel dependency);
    public DependencyModel get_Dependency();
    public PropertyInfo get_Property();
    public virtual string ToString();
}
public class Castle.Core.PropertySetBuilder : MulticastDelegate {
    public PropertySetBuilder(object object, IntPtr method);
    public virtual PropertySet Invoke(PropertyInfo property, bool isOptional);
    public virtual IAsyncResult BeginInvoke(PropertyInfo property, bool isOptional, AsyncCallback callback, object object);
    public virtual PropertySet EndInvoke(IAsyncResult result);
}
public class Castle.Core.PropertySetCollection : object {
    private HashSet`1<PropertySet> properties;
    public int Count { get; }
    public sealed virtual int get_Count();
    public PropertySet FindByPropertyInfo(PropertyInfo info);
    public sealed virtual IEnumerator`1<PropertySet> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void Castle.Core.Internal.IMutableCollection<Castle.Core.PropertySet>.Add(PropertySet property);
    private sealed virtual override bool Castle.Core.Internal.IMutableCollection<Castle.Core.PropertySet>.Remove(PropertySet item);
}
[AttributeUsageAttribute("4")]
public class Castle.Core.ScopedAttribute : LifestyleAttribute {
    [CompilerGeneratedAttribute]
private Type <ScopeAccessorType>k__BackingField;
    public Type ScopeAccessorType { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ScopeAccessorType();
    [CompilerGeneratedAttribute]
public void set_ScopeAccessorType(Type value);
}
[AttributeUsageAttribute("4")]
public class Castle.Core.SingletonAttribute : LifestyleAttribute {
}
public class Castle.Core.StandardPropertyFilters : object {
    public static PropertyDependencyFilter Create(PropertyFilter filter);
    public static PropertySet[] Default(ComponentModel model, ICollection`1<PropertyInfo> properties, PropertySetBuilder propertySetBuilder);
    public static PropertyDependencyFilter FromObsoleteFunction(Func`3<ComponentModel, PropertyInfo, bool> filter, bool isRequired);
    public static ICollection`1<PropertyDependencyFilter> GetPropertyFilters(ComponentModel componentModel, bool createIfMissing);
    public static PropertySet[] IgnoreAll(ComponentModel model, ICollection`1<PropertyInfo> properties, PropertySetBuilder propertySetBuilder);
    public static PropertySet[] IgnoreBase(ComponentModel model, ICollection`1<PropertyInfo> properties, PropertySetBuilder propertySetBuilder);
    public static PropertyDependencyFilter IgnoreSelected(Func`3<ComponentModel, PropertyInfo, bool> selector);
    public static PropertySet[] RequireAll(ComponentModel model, ICollection`1<PropertyInfo> properties, PropertySetBuilder propertySetBuilder);
    public static PropertySet[] RequireBase(ComponentModel model, ICollection`1<PropertyInfo> properties, PropertySetBuilder propertySetBuilder);
    public static PropertyDependencyFilter RequireSelected(Func`3<ComponentModel, PropertyInfo, bool> selector);
}
[AttributeUsageAttribute("4")]
public class Castle.Core.TransientAttribute : LifestyleAttribute {
}
public interface Castle.Facilities.Startable.IStartFlagInternal {
    public abstract virtual void Init(StartableEvents events);
}
public class Castle.Facilities.Startable.StartableContributor : object {
    private ITypeConverter converter;
    public StartableContributor(ITypeConverter converter);
    public sealed virtual void ProcessModel(IKernel kernel, ComponentModel model);
    private void AddStart(ComponentModel model);
    private void AddStop(ComponentModel model);
    private bool HasStartableAttributeSet(ComponentModel model);
    private static bool CheckIfComponentImplementsIStartable(ComponentModel model);
}
public class Castle.Facilities.Startable.StartableFacility : AbstractFacility {
    private ITypeConverter converter;
    private StartFlag flag;
    public void DeferredStart();
    public void DeferredStart(StartFlag flag);
    public void DeferredTryStart();
    protected virtual void Init();
    private void InitFlag(IStartFlagInternal startFlag, StartableEvents events);
    public static bool IsStartable(IHandler handler);
}
[ExtensionAttribute]
public static class Castle.Facilities.Startable.StartableFacilityRegistrationExtensions : object {
    [ExtensionAttribute]
public static ComponentRegistration`1<TService> Start(ComponentRegistration`1<TService> registration);
    [ExtensionAttribute]
public static ComponentRegistration`1<TService> StartUsingMethod(ComponentRegistration`1<TService> registration, string startMethod);
    [ExtensionAttribute]
public static ComponentRegistration`1<TService> StartUsingMethod(ComponentRegistration`1<TService> registration, Expression`1<Func`2<TService, Action>> methodToUse);
    [ExtensionAttribute]
public static ComponentRegistration`1<TService> StopUsingMethod(ComponentRegistration`1<TService> registration, string stopMethod);
    [ExtensionAttribute]
public static ComponentRegistration`1<TService> StopUsingMethod(ComponentRegistration`1<TService> registration, Expression`1<Func`2<TService, Action>> methodToUse);
    private static TExpression EnsureIs(Expression expression);
    private static string ObtainMethodName(Expression`1<Func`2<TService, Action>> methodToUse);
}
public class Castle.Facilities.Startable.StartConcern : object {
    private static StartConcern instance;
    public static StartConcern Instance { get; }
    private static StartConcern();
    public sealed virtual void Apply(ComponentModel model, object component);
    public static StartConcern get_Instance();
}
public class Castle.Facilities.Startable.StartFlag : object {
    protected List`1<IHandler> waitList;
    protected StartableEvents events;
    public virtual void Signal();
    protected void CacheHandler(IHandler handler);
    protected virtual void Init();
    protected virtual void Start(IHandler handler);
    protected void StartAll();
    private sealed virtual override void Castle.Facilities.Startable.IStartFlagInternal.Init(StartableEvents events);
}
public class Castle.Facilities.Startable.StopConcern : object {
    private static StopConcern instance;
    public static StopConcern Instance { get; }
    private static StopConcern();
    public sealed virtual void Apply(ComponentModel model, object component);
    public static StopConcern get_Instance();
}
[SingletonAttribute]
public class Castle.Facilities.TypedFactory.DefaultDelegateComponentSelector : DefaultTypedFactoryComponentSelector {
    protected virtual Arguments GetArguments(MethodInfo method, Object[] arguments);
    protected virtual string GetComponentName(MethodInfo method, Object[] arguments);
    private bool IsFunc(Type type);
}
[SingletonAttribute]
public class Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector : object {
    [CompilerGeneratedAttribute]
private bool <FallbackToResolveByTypeIfNameNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GetMethodsResolveByName>k__BackingField;
    protected bool FallbackToResolveByTypeIfNameNotFound { get; protected set; }
    protected bool GetMethodsResolveByName { get; protected set; }
    public DefaultTypedFactoryComponentSelector(bool getMethodsResolveByName, bool fallbackToResolveByTypeIfNameNotFound);
    [CompilerGeneratedAttribute]
protected bool get_FallbackToResolveByTypeIfNameNotFound();
    [CompilerGeneratedAttribute]
protected void set_FallbackToResolveByTypeIfNameNotFound(bool value);
    [CompilerGeneratedAttribute]
protected bool get_GetMethodsResolveByName();
    [CompilerGeneratedAttribute]
protected void set_GetMethodsResolveByName(bool value);
    public sealed virtual Func`3<IKernelInternal, IReleasePolicy, object> SelectComponent(MethodInfo method, Type type, Object[] arguments);
    protected virtual Func`3<IKernelInternal, IReleasePolicy, object> BuildFactoryComponent(MethodInfo method, string componentName, Type componentType, Arguments additionalArguments);
    protected virtual Arguments GetArguments(MethodInfo method, Object[] arguments);
    protected virtual string GetComponentName(MethodInfo method, Object[] arguments);
    protected virtual Type GetComponentType(MethodInfo method, Object[] arguments);
}
public class Castle.Facilities.TypedFactory.DelegateFactoryActivator : AbstractComponentActivator {
    private IProxyFactoryExtension proxyFactory;
    public DelegateFactoryActivator(ComponentModel model, IKernelInternal kernel, ComponentInstanceDelegate onCreation, ComponentInstanceDelegate onDestruction);
    public sealed virtual bool CanProvideRequiredDependencies(ComponentModel component);
    public sealed virtual bool IsManagedExternally(ComponentModel component);
    protected virtual object InternalCreate(CreationContext context);
    protected virtual void InternalDestroy(object instance);
}
[AttributeUsageAttribute("5120")]
public class Castle.Facilities.TypedFactory.FactoryAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <SelectorComponentName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SelectorComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SelectorType>k__BackingField;
    public string SelectorComponentName { get; public set; }
    public Type SelectorComponentType { get; public set; }
    public Type SelectorType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SelectorComponentName();
    [CompilerGeneratedAttribute]
public void set_SelectorComponentName(string value);
    [CompilerGeneratedAttribute]
public Type get_SelectorComponentType();
    [CompilerGeneratedAttribute]
public void set_SelectorComponentType(Type value);
    [CompilerGeneratedAttribute]
public Type get_SelectorType();
    [CompilerGeneratedAttribute]
public void set_SelectorType(Type value);
}
[EditorBrowsableAttribute("1")]
public class Castle.Facilities.TypedFactory.FactoryEntry : object {
    private string creationMethod;
    private string destructionMethod;
    private Type factoryInterface;
    private string id;
    public string CreationMethod { get; }
    public string DestructionMethod { get; }
    public Type FactoryInterface { get; }
    public string Id { get; }
    public FactoryEntry(string id, Type factoryInterface, string creationMethod, string destructionMethod);
    public string get_CreationMethod();
    public string get_DestructionMethod();
    public Type get_FactoryInterface();
    public string get_Id();
}
[SingletonAttribute]
public class Castle.Facilities.TypedFactory.Internal.DelegateFactory : object {
    public sealed virtual IRegistration Load(string name, Type service, Arguments arguments);
    protected string GetName(Type service);
    public static MethodInfo ExtractInvokeMethod(Type service);
    protected static MethodInfo GetInvokeMethod(Type delegate);
    protected static bool HasReturn(MethodInfo invoke);
}
public class Castle.Facilities.TypedFactory.Internal.DelegateProxyFactory : object {
    public sealed virtual object Generate(IProxyBuilder builder, ProxyGenerationOptions options, IInterceptor[] interceptors, ComponentModel model, CreationContext context);
    private object GetInvokeDelegate(object instance, Type targetDelegateType);
    private object GetProxyInstance(Type type, IInterceptor[] interceptors);
    private Type GetProxyType(IProxyBuilder builder, Type targetDelegateType);
}
public class Castle.Facilities.TypedFactory.Internal.DelegateServiceStrategy : object {
    public static DelegateServiceStrategy Instance;
    private static DelegateServiceStrategy();
    public sealed virtual bool Supports(Type service, ComponentModel component);
}
public class Castle.Facilities.TypedFactory.Internal.Empty : object {
}
[TransientAttribute]
public class Castle.Facilities.TypedFactory.Internal.FactoryInterceptor : object {
    private IKernel kernel;
    private FactoryEntry entry;
    public FactoryInterceptor(IKernel kernel);
    public sealed virtual void Intercept(IInvocation invocation);
    public sealed virtual void SetInterceptedComponentModel(ComponentModel target);
}
public enum Castle.Facilities.TypedFactory.Internal.FactoryMethod : Enum {
    public int value__;
    public static FactoryMethod Resolve;
    public static FactoryMethod Release;
    public static FactoryMethod Dispose;
}
[TransientAttribute]
public class Castle.Facilities.TypedFactory.Internal.TypedFactoryInterceptor : object {
    private IKernelInternal kernel;
    private IReleasePolicy scope;
    private bool disposed;
    private IDictionary`2<MethodInfo, FactoryMethod> methods;
    [CompilerGeneratedAttribute]
private ITypedFactoryComponentSelector <ComponentSelector>k__BackingField;
    public ITypedFactoryComponentSelector ComponentSelector { get; private set; }
    public TypedFactoryInterceptor(IKernelInternal kernel, ITypedFactoryComponentSelector componentSelector);
    [CompilerGeneratedAttribute]
public ITypedFactoryComponentSelector get_ComponentSelector();
    [CompilerGeneratedAttribute]
private void set_ComponentSelector(ITypedFactoryComponentSelector value);
    public sealed virtual void Dispose();
    public sealed virtual void Intercept(IInvocation invocation);
    public sealed virtual void SetInterceptedComponentModel(ComponentModel target);
    private void Release(IInvocation invocation);
    private void Resolve(IInvocation invocation);
    private bool TryGetMethod(IInvocation invocation, FactoryMethod& method);
}
public interface Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector {
    public abstract virtual Func`3<IKernelInternal, IReleasePolicy, object> SelectComponent(MethodInfo method, Type type, Object[] arguments);
}
public class Castle.Facilities.TypedFactory.TypedFactoryCachingInspector : object {
    public virtual void BuildCache(ComponentModel model);
    private void BuildHandlersMap(Type service, Dictionary`2<MethodInfo, FactoryMethod> map);
    private bool IsReleaseMethod(MethodInfo methodInfo);
    private sealed virtual override void Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction.ProcessModel(IKernel kernel, ComponentModel model);
}
public class Castle.Facilities.TypedFactory.TypedFactoryComponentResolver : object {
    protected Arguments additionalArguments;
    protected string componentName;
    protected Type componentType;
    protected bool fallbackToResolveByTypeIfNameNotFound;
    private Type actualSelectorType;
    public TypedFactoryComponentResolver(string componentName, Type componentType, Arguments additionalArguments, bool fallbackToResolveByTypeIfNameNotFound, Type actualSelectorType);
    public virtual object Resolve(IKernelInternal kernel, IReleasePolicy scope);
    private bool LoadByName(IKernelInternal kernel);
}
public class Castle.Facilities.TypedFactory.TypedFactoryConfiguration : object {
    private string defaultComponentSelectorKey;
    private IReference`1<ITypedFactoryComponentSelector> selectorReference;
    internal IReference`1<ITypedFactoryComponentSelector> Reference { get; }
    public TypedFactoryConfiguration(string defaultComponentSelectorKey, Type factoryType);
    internal IReference`1<ITypedFactoryComponentSelector> get_Reference();
    public void SelectedWith(string selectorComponentName);
    public void SelectedWith();
    public void SelectedWith(Type selectorComponentType);
    public void SelectedWith(ITypedFactoryComponentSelector selector);
}
public class Castle.Facilities.TypedFactory.TypedFactoryFacility : AbstractFacility {
    public static string DelegateFactoryKey;
    public static string FactoryMapCacheKey;
    public static string InterceptorKey;
    public static string IsFactoryKey;
    internal static string DefaultDelegateSelectorKey;
    internal static string DefaultInterfaceSelectorKey;
    private static TypedFactoryFacility();
    [ObsoleteAttribute("This method is obsolete. Use AsFactory() extension method on fluent registration API instead.")]
[EditorBrowsableAttribute("1")]
public void AddTypedFactoryEntry(FactoryEntry entry);
    protected virtual void AddFactories(IConfiguration facilityConfig, ITypeConverter converter);
    protected virtual void Init();
    protected void RegisterFactory(string id, Type type, string selector);
    private void InitFacility();
    private void LegacyInit();
    private void LegacyRegisterFactory(string id, Type factoryType, string creation, string destruction);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions : object {
    [ExtensionAttribute]
public static ComponentRegistration`1<TFactoryInterface> AsFactory(ComponentRegistration`1<TFactoryInterface> registration);
    [ExtensionAttribute]
public static ComponentRegistration`1<TFactoryInterface> AsFactory(ComponentRegistration`1<TFactoryInterface> registration, string selectorComponentName);
    [ExtensionAttribute]
public static ComponentRegistration`1<TFactoryInterface> AsFactory(ComponentRegistration`1<TFactoryInterface> registration, Type selectorComponentType);
    [ExtensionAttribute]
public static ComponentRegistration`1<TFactoryInterface> AsFactory(ComponentRegistration`1<TFactoryInterface> registration, ITypedFactoryComponentSelector selector);
    [ExtensionAttribute]
public static ComponentRegistration`1<TFactoryInterface> AsFactory(ComponentRegistration`1<TFactoryInterface> registration, Action`1<TypedFactoryConfiguration> configuration);
    private static ComponentRegistration`1<TFactory> AttachConfiguration(ComponentRegistration`1<TFactory> componentRegistration, Action`1<TypedFactoryConfiguration> configuration, string defaultComponentSelectorKey);
    private static ComponentRegistration`1<TFactory> AttachFactoryInterceptor(ComponentRegistration`1<TFactory> registration);
    private static IReference`1<ITypedFactoryComponentSelector> GetSelectorReference(Action`1<TypedFactoryConfiguration> configuration, string defaultComponentSelectorKey, Type factoryType);
    private static bool HasOutArguments(Type serviceType);
    private static ComponentRegistration`1<TDelegate> RegisterDelegateBasedFactory(ComponentRegistration`1<TDelegate> registration, Action`1<TypedFactoryConfiguration> configuration, Type delegateType);
    private static ComponentRegistration`1<TFactoryInterface> RegisterInterfaceBasedFactory(ComponentRegistration`1<TFactoryInterface> registration, Action`1<TypedFactoryConfiguration> configuration);
}
public abstract class Castle.MicroKernel.AbstractSubSystem : object {
    private IKernelInternal kernel;
    protected IKernelInternal Kernel { get; }
    public virtual void Init(IKernelInternal kernel);
    public virtual void Terminate();
    protected IKernelInternal get_Kernel();
}
[DefaultMemberAttribute("Item")]
public class Castle.MicroKernel.Arguments : object {
    private static ArgumentsComparer Comparer;
    private Dictionary`2<object, object> dictionary;
    public int Count { get; }
    public object Item { get; public set; }
    public Arguments(Arguments arguments);
    private static Arguments();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<object, object>> GetEnumerator();
    public int get_Count();
    public void Add(object key, object value);
    public bool Contains(object key);
    public void Remove(object key);
    public object get_Item(object key);
    public void set_Item(object key, object value);
    public Arguments Add(IEnumerable`1<KeyValuePair`2<object, object>> arguments);
    public Arguments AddNamed(string key, object value);
    public Arguments AddNamed(IEnumerable`1<KeyValuePair`2<string, object>> arguments);
    public Arguments AddProperties(object instance);
    public Arguments AddTyped(Type key, object value);
    public Arguments AddTyped(TDependencyType value);
    public Arguments AddTyped(IEnumerable`1<object> arguments);
    public Arguments AddTyped(Object[] arguments);
    public static Arguments FromNamed(IEnumerable`1<KeyValuePair`2<string, object>> arguments);
    public static Arguments FromProperties(object instance);
    public static Arguments FromTyped(IEnumerable`1<KeyValuePair`2<Type, object>> arguments);
    public static Arguments FromTyped(IEnumerable`1<object> arguments);
    private void CheckKeyType(object key);
}
public class Castle.MicroKernel.Burden : object {
    private IHandler handler;
    private Decommission decommission;
    private List`1<Burden> dependencies;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackedExternally>k__BackingField;
    [CompilerGeneratedAttribute]
private BurdenReleaseDelegate Released;
    [CompilerGeneratedAttribute]
private BurdenReleaseDelegate Releasing;
    [CompilerGeneratedAttribute]
private BurdenReleaseDelegate GraphReleased;
    public IHandler Handler { get; }
    public object Instance { get; private set; }
    public ComponentModel Model { get; }
    public bool RequiresDecommission { get; public set; }
    public bool RequiresPolicyRelease { get; }
    public bool TrackedExternally { get; public set; }
    internal Burden(IHandler handler, bool requiresDecommission, bool trackedExternally);
    public IHandler get_Handler();
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(object value);
    public ComponentModel get_Model();
    public bool get_RequiresDecommission();
    public void set_RequiresDecommission(bool value);
    public bool get_RequiresPolicyRelease();
    [CompilerGeneratedAttribute]
public bool get_TrackedExternally();
    [CompilerGeneratedAttribute]
public void set_TrackedExternally(bool value);
    public void AddChild(Burden child);
    public bool Release();
    public void SetRootInstance(object instance);
    private bool IsLateBound(IDecommissionConcern arg);
    [CompilerGeneratedAttribute]
public void add_Released(BurdenReleaseDelegate value);
    [CompilerGeneratedAttribute]
public void remove_Released(BurdenReleaseDelegate value);
    [CompilerGeneratedAttribute]
public void add_Releasing(BurdenReleaseDelegate value);
    [CompilerGeneratedAttribute]
public void remove_Releasing(BurdenReleaseDelegate value);
    [CompilerGeneratedAttribute]
public void add_GraphReleased(BurdenReleaseDelegate value);
    [CompilerGeneratedAttribute]
public void remove_GraphReleased(BurdenReleaseDelegate value);
}
public class Castle.MicroKernel.BurdenReleaseDelegate : MulticastDelegate {
    public BurdenReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(Burden burden);
    public virtual IAsyncResult BeginInvoke(Burden burden, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.CircularDependencyException : ComponentResolutionException {
    public CircularDependencyException(string message);
    public CircularDependencyException(string message, Exception innerException);
    public CircularDependencyException(string message, ComponentModel component);
}
public abstract class Castle.MicroKernel.ComponentActivator.AbstractComponentActivator : object {
    private IKernelInternal kernel;
    private ComponentModel model;
    private ComponentInstanceDelegate onCreation;
    private ComponentInstanceDelegate onDestruction;
    public IKernelInternal Kernel { get; }
    public ComponentModel Model { get; }
    public ComponentInstanceDelegate OnCreation { get; }
    public ComponentInstanceDelegate OnDestruction { get; }
    protected AbstractComponentActivator(ComponentModel model, IKernelInternal kernel, ComponentInstanceDelegate onCreation, ComponentInstanceDelegate onDestruction);
    public IKernelInternal get_Kernel();
    public ComponentModel get_Model();
    public ComponentInstanceDelegate get_OnCreation();
    public ComponentInstanceDelegate get_OnDestruction();
    protected abstract virtual object InternalCreate(CreationContext context);
    protected abstract virtual void InternalDestroy(object instance);
    public virtual object Create(CreationContext context, Burden burden);
    public virtual void Destroy(object instance);
    protected virtual void ApplyCommissionConcerns(object instance);
    protected virtual void ApplyConcerns(IEnumerable`1<ICommissionConcern> steps, object instance);
    protected virtual void ApplyConcerns(IEnumerable`1<IDecommissionConcern> steps, object instance);
    protected virtual void ApplyDecommissionConcerns(object instance);
}
public class Castle.MicroKernel.ComponentActivator.ComponentActivatorException : ComponentResolutionException {
    [CompilerGeneratedAttribute]
private ComponentModel <ComponentModel>k__BackingField;
    public ComponentModel ComponentModel { get; private set; }
    public ComponentActivatorException(string message, ComponentModel componentComponentModel);
    public ComponentActivatorException(string message, Exception innerException, ComponentModel componentModel);
    [CompilerGeneratedAttribute]
public ComponentModel get_ComponentModel();
    [CompilerGeneratedAttribute]
private void set_ComponentModel(ComponentModel value);
}
public class Castle.MicroKernel.ComponentActivator.DefaultComponentActivator : AbstractComponentActivator {
    internal static string InstanceStash;
    public DefaultComponentActivator(ComponentModel model, IKernelInternal kernel, ComponentInstanceDelegate onCreation, ComponentInstanceDelegate onDestruction);
    protected virtual object InternalCreate(CreationContext context);
    protected virtual void InternalDestroy(object instance);
    protected virtual object Instantiate(CreationContext context);
    protected virtual object CreateInstance(CreationContext context, ConstructorCandidate constructor, Object[] arguments);
    protected object CreateInstanceCore(ConstructorCandidate constructor, Object[] arguments, Type implType);
    protected virtual ConstructorCandidate SelectEligibleConstructor(CreationContext context);
    private static bool BestScoreSoFar(int candidatePoints, int winnerPoints, ConstructorCandidate winnerCandidate);
    private static bool BestPossibleScore(ConstructorCandidate candidate, int candidatePoints);
    private bool CheckCtorCandidate(ConstructorCandidate candidate, CreationContext context, Int32& candidatePoints);
    protected virtual bool CanSatisfyDependency(CreationContext context, DependencyModel dependency);
    protected virtual Object[] CreateConstructorArguments(ConstructorCandidate constructor, CreationContext context);
    protected virtual void SetUpProperties(object instance, CreationContext context);
    private object ObtainPropertyValue(CreationContext context, PropertySet property, IDependencyResolver resolver);
}
public class Castle.MicroKernel.ComponentActivator.ExternalInstanceActivator : AbstractComponentActivator {
    public ExternalInstanceActivator(ComponentModel model, IKernelInternal kernel, ComponentInstanceDelegate onCreation, ComponentInstanceDelegate onDestruction);
    public sealed virtual bool CanProvideRequiredDependencies(ComponentModel component);
    public sealed virtual bool IsManagedExternally(ComponentModel component);
    protected virtual object InternalCreate(CreationContext context);
    protected virtual void InternalDestroy(object instance);
}
public class Castle.MicroKernel.ComponentActivator.FactoryMethodActivator`1 : DefaultComponentActivator {
    protected Func`4<IKernel, ComponentModel, CreationContext, T> creator;
    protected bool managedExternally;
    public FactoryMethodActivator`1(ComponentModel model, IKernelInternal kernel, ComponentInstanceDelegate onCreation, ComponentInstanceDelegate onDestruction);
    public sealed virtual bool CanProvideRequiredDependencies(ComponentModel component);
    public sealed virtual bool IsManagedExternally(ComponentModel component);
    protected virtual void ApplyCommissionConcerns(object instance);
    protected virtual void ApplyDecommissionConcerns(object instance);
    protected virtual object Instantiate(CreationContext context);
    protected virtual void SetUpProperties(object instance, CreationContext context);
    private bool ShouldCreateProxy(object instance);
}
public interface Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator {
    public abstract virtual bool CanProvideRequiredDependencies(ComponentModel component);
    public abstract virtual bool IsManagedExternally(ComponentModel component);
}
public class Castle.MicroKernel.ComponentActivator.NoResolvableConstructorFoundException : ComponentActivatorException {
    private Type type;
    public Type Type { get; }
    public NoResolvableConstructorFoundException(Type type, ComponentModel componentModel);
    public NoResolvableConstructorFoundException(string message, Exception innerException, ComponentModel componentModel);
    public Type get_Type();
}
public class Castle.MicroKernel.ComponentDataDelegate : MulticastDelegate {
    public ComponentDataDelegate(object object, IntPtr method);
    public virtual void Invoke(string key, IHandler handler);
    public virtual IAsyncResult BeginInvoke(string key, IHandler handler, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.ComponentInstanceDelegate : MulticastDelegate {
    public ComponentInstanceDelegate(object object, IntPtr method);
    public virtual void Invoke(ComponentModel model, object instance);
    public virtual IAsyncResult BeginInvoke(ComponentModel model, object instance, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.ComponentModelDelegate : MulticastDelegate {
    public ComponentModelDelegate(object object, IntPtr method);
    public virtual void Invoke(ComponentModel model);
    public virtual IAsyncResult BeginInvoke(ComponentModel model, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.ComponentNotFoundException : ComponentResolutionException {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Service>k__BackingField;
    public string Name { get; private set; }
    public Type Service { get; private set; }
    public ComponentNotFoundException(string name, Type service, int countOfHandlersForTheService);
    public ComponentNotFoundException(string name, string message);
    public ComponentNotFoundException(Type service, string message);
    public ComponentNotFoundException(Type service);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Service();
    [CompilerGeneratedAttribute]
private void set_Service(Type value);
    private static string BuildMessage(string name, Type service, int countOfHandlersForTheService);
}
public class Castle.MicroKernel.ComponentReference`1 : object {
    [DebuggerBrowsableAttribute("0")]
protected string referencedComponentName;
    [DebuggerBrowsableAttribute("0")]
protected Type referencedComponentType;
    [DebuggerBrowsableAttribute("0")]
protected DependencyModel dependencyModel;
    protected Type ComponentType { get; }
    public ComponentReference`1(Type componentType);
    public ComponentReference`1(string referencedComponentName);
    protected virtual Type get_ComponentType();
    public sealed virtual T Resolve(IKernel kernel, CreationContext context);
    private IHandler GetHandler(IKernel kernel);
    private CreationContext RebuildContext(IHandler handler, CreationContext current);
    private sealed virtual override void Castle.MicroKernel.IReference<T>.Attach(ComponentModel component);
    private sealed virtual override void Castle.MicroKernel.IReference<T>.Detach(ComponentModel component);
}
public class Castle.MicroKernel.ComponentRegistrationException : Exception {
    public ComponentRegistrationException(string message);
    public ComponentRegistrationException(string message, Exception innerException);
}
public class Castle.MicroKernel.ComponentResolutionException : Exception {
    [CompilerGeneratedAttribute]
private ComponentModel <Component>k__BackingField;
    public ComponentModel Component { get; private set; }
    public ComponentResolutionException(string message);
    public ComponentResolutionException(string message, Exception innerException);
    public ComponentResolutionException(string message, ComponentModel component);
    public ComponentResolutionException(string message, Exception innerException, ComponentModel component);
    public ComponentResolutionException(ComponentModel component);
    [CompilerGeneratedAttribute]
public ComponentModel get_Component();
    [CompilerGeneratedAttribute]
private void set_Component(ComponentModel value);
}
public class Castle.MicroKernel.Context.CreationContext : object {
    private ITypeConverter converter;
    private IHandler handler;
    private Stack`1<IHandler> handlerStack;
    private Type requestedType;
    private Stack`1<ResolutionContext> resolutionStack;
    private Arguments additionalArguments;
    private Arguments extendedProperties;
    private Type[] genericArguments;
    private bool isResolving;
    [CompilerGeneratedAttribute]
private IReleasePolicy <ReleasePolicy>k__BackingField;
    public Arguments AdditionalArguments { get; }
    public Type[] GenericArguments { get; }
    public IHandler Handler { get; }
    public bool HasAdditionalArguments { get; }
    public bool IsResolving { get; }
    public IReleasePolicy ReleasePolicy { get; public set; }
    public Type RequestedType { get; }
    public CreationContext(Type requestedType, CreationContext parentContext, bool propagateInlineDependencies);
    public CreationContext(IHandler handler, IReleasePolicy releasePolicy, Type requestedType, Arguments additionalArguments, ITypeConverter converter, CreationContext parent);
    public Arguments get_AdditionalArguments();
    public Type[] get_GenericArguments();
    public IHandler get_Handler();
    public bool get_HasAdditionalArguments();
    public virtual bool get_IsResolving();
    [CompilerGeneratedAttribute]
public IReleasePolicy get_ReleasePolicy();
    [CompilerGeneratedAttribute]
public void set_ReleasePolicy(IReleasePolicy value);
    public Type get_RequestedType();
    public void AttachExistingBurden(Burden burden);
    public void BuildCycleMessageFor(IHandler duplicateHandler, StringBuilder message);
    public Burden CreateBurden(IComponentActivator componentActivator, bool trackedExternally);
    public ResolutionContext EnterResolutionContext(IHandler handlerBeingResolved, bool requiresDecommission);
    public ResolutionContext EnterResolutionContext(IHandler handlerBeingResolved, bool trackContext, bool requiresDecommission);
    public object GetContextualProperty(object key);
    public bool IsInResolutionContext(IHandler handler);
    public ResolutionContext SelectScopeRoot(Func`2<IHandler[], IHandler> scopeRootSelector);
    public void SetContextualProperty(object key, object value);
    public virtual bool CanResolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    public virtual object Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    private bool CanConvertParameter(Type type);
    private bool CanResolve(DependencyModel dependency, object inlineArgument);
    private bool CanResolveByKey(DependencyModel dependency);
    private bool CanResolveByType(DependencyModel dependency);
    private void ExitResolutionContext(Burden burden, bool trackContext);
    private object Resolve(DependencyModel dependency, object inlineArgument);
    public static CreationContext CreateEmpty();
    public static CreationContext ForDependencyInspection(IHandler handler);
    private static Type[] ExtractGenericArguments(Type typeToExtractGenericArguments);
}
public interface Castle.MicroKernel.Context.IArgumentsComparer {
    public abstract virtual bool RunEqualityComparison(object x, object y, Boolean& areEqual);
    public abstract virtual bool RunHasCodeCalculation(object o, Int32& hashCode);
}
[DebuggerTypeProxyAttribute("Castle.Windsor.Diagnostics.KernelDebuggerProxy")]
public class Castle.MicroKernel.DefaultKernel : object {
    [ThreadStaticAttribute]
private static CreationContext currentCreationContext;
    [ThreadStaticAttribute]
private static bool isCheckingLazyLoaders;
    private ThreadSafeFlag disposed;
    private List`1<IKernel> childKernels;
    private List`1<IFacility> facilities;
    private Dictionary`2<string, ISubSystem> subsystems;
    private IKernel parentKernel;
    private object lazyLoadingLock;
    [CompilerGeneratedAttribute]
private IComponentModelBuilder <ComponentModelBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IHandlerFactory <HandlerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IProxyFactory <ProxyFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IReleasePolicy <ReleasePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private IDependencyResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IConversionManager <ConversionSubSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private INamingSubSystem <NamingSubSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    private object handlersChangedLock;
    private bool handlersChanged;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) handlersChangedDeferred;
    [CompilerGeneratedAttribute]
private HandlerDelegate HandlerRegistered;
    [CompilerGeneratedAttribute]
private HandlersChangedDelegate HandlersChanged;
    [CompilerGeneratedAttribute]
private ComponentDataDelegate ComponentRegistered;
    [CompilerGeneratedAttribute]
private ComponentInstanceDelegate ComponentCreated;
    [CompilerGeneratedAttribute]
private ComponentInstanceDelegate ComponentDestroyed;
    [CompilerGeneratedAttribute]
private EventHandler AddedAsChildKernel;
    [CompilerGeneratedAttribute]
private EventHandler RegistrationCompleted;
    [CompilerGeneratedAttribute]
private EventHandler RemovedAsChildKernel;
    [CompilerGeneratedAttribute]
private ComponentModelDelegate ComponentModelCreated;
    [CompilerGeneratedAttribute]
private DependencyDelegate DependencyResolving;
    [CompilerGeneratedAttribute]
private ServiceDelegate EmptyCollectionResolving;
    public IComponentModelBuilder ComponentModelBuilder { get; public set; }
    public IConfigurationStore ConfigurationStore { get; public set; }
    public GraphNode[] GraphNodes { get; }
    public IHandlerFactory HandlerFactory { get; private set; }
    public IKernel Parent { get; public set; }
    public IProxyFactory ProxyFactory { get; public set; }
    public IReleasePolicy ReleasePolicy { get; public set; }
    public IDependencyResolver Resolver { get; private set; }
    protected IConversionManager ConversionSubSystem { get; private set; }
    protected INamingSubSystem NamingSubSystem { get; private set; }
    public ILogger Logger { get; public set; }
    public DefaultKernel(IDependencyResolver resolver, IProxyFactory proxyFactory);
    public DefaultKernel(IProxyFactory proxyFactory);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentModelBuilder get_ComponentModelBuilder();
    [CompilerGeneratedAttribute]
public void set_ComponentModelBuilder(IComponentModelBuilder value);
    public virtual IConfigurationStore get_ConfigurationStore();
    public virtual void set_ConfigurationStore(IConfigurationStore value);
    public sealed virtual GraphNode[] get_GraphNodes();
    [CompilerGeneratedAttribute]
public sealed virtual IHandlerFactory get_HandlerFactory();
    [CompilerGeneratedAttribute]
private void set_HandlerFactory(IHandlerFactory value);
    public virtual IKernel get_Parent();
    public virtual void set_Parent(IKernel value);
    [CompilerGeneratedAttribute]
public sealed virtual IProxyFactory get_ProxyFactory();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProxyFactory(IProxyFactory value);
    [CompilerGeneratedAttribute]
public sealed virtual IReleasePolicy get_ReleasePolicy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReleasePolicy(IReleasePolicy value);
    [CompilerGeneratedAttribute]
public sealed virtual IDependencyResolver get_Resolver();
    [CompilerGeneratedAttribute]
private void set_Resolver(IDependencyResolver value);
    [CompilerGeneratedAttribute]
protected IConversionManager get_ConversionSubSystem();
    [CompilerGeneratedAttribute]
private void set_ConversionSubSystem(IConversionManager value);
    [CompilerGeneratedAttribute]
protected INamingSubSystem get_NamingSubSystem();
    [CompilerGeneratedAttribute]
private void set_NamingSubSystem(INamingSubSystem value);
    public virtual void Dispose();
    public virtual void AddChildKernel(IKernel childKernel);
    public virtual IHandler AddCustomComponent(ComponentModel model);
    private sealed virtual override IHandler Castle.MicroKernel.IKernelInternal.CreateHandler(ComponentModel model);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Logger(ILogger value);
    public virtual IKernel AddFacility(IFacility facility);
    public sealed virtual IKernel AddFacility();
    public sealed virtual IKernel AddFacility(Action`1<T> onCreate);
    public sealed virtual void AddHandlerSelector(IHandlerSelector selector);
    public sealed virtual void AddHandlersFilter(IHandlersFilter filter);
    public virtual void AddSubSystem(string name, ISubSystem subsystem);
    public virtual IHandler[] GetAssignableHandlers(Type service);
    public virtual IFacility[] GetFacilities();
    public virtual IHandler GetHandler(string name);
    public virtual IHandler GetHandler(Type service);
    public virtual IHandler[] GetHandlers(Type service);
    public virtual IHandler[] GetHandlers();
    public virtual ISubSystem GetSubSystem(string name);
    public virtual bool HasComponent(string name);
    public virtual bool HasComponent(Type serviceType);
    public sealed virtual IKernel Register(IRegistration[] registrations);
    public virtual void ReleaseComponent(object instance);
    public virtual void RemoveChildKernel(IKernel childKernel);
    public virtual ILifestyleManager CreateLifestyleManager(ComponentModel model, IComponentActivator activator);
    private static IScopeAccessor CreateScopeAccessor(ComponentModel model);
    private IScopeAccessor CreateScopeAccessorForBoundLifestyle(ComponentModel model);
    public virtual IComponentActivator CreateComponentActivator(ComponentModel model);
    protected CreationContext CreateCreationContext(IHandler handler, Type requestedType, Arguments additionalArguments, CreationContext parent, IReleasePolicy policy);
    protected void DisposeHandler(IHandler handler);
    private sealed virtual override void Castle.MicroKernel.IKernelInternal.RaiseEventsOnHandlerCreated(IHandler handler);
    protected virtual void RegisterSubSystems();
    protected object ResolveComponent(IHandler handler, Type service, Arguments additionalArguments, IReleasePolicy policy);
    private object ResolveComponent(IHandler handler, Type service, Arguments additionalArguments, IReleasePolicy policy, bool ignoreParentContext);
    protected virtual IHandler WrapParentHandler(IHandler parentHandler);
    private void DisposeComponentsInstancesWithinTracker();
    private void DisposeHandlers();
    private void DisposeSubKernels();
    private void HandlerRegisteredOnParentKernel(IHandler handler, Boolean& stateChanged);
    private void HandlersChangedOnParentKernel(Boolean& changed);
    private void SubscribeToParentKernel();
    private void TerminateFacilities();
    private void UnsubscribeFromParentKernel();
    private sealed virtual override IHandler Castle.MicroKernel.IKernelInternal.LoadHandlerByName(string name, Type service, Arguments arguments);
    private sealed virtual override IHandler Castle.MicroKernel.IKernelInternal.LoadHandlerByType(string name, Type service, Arguments arguments);
    public sealed virtual IDisposable OptimizeDependencyResolution();
    protected virtual void RaiseAddedAsChildKernel();
    protected virtual void RaiseComponentCreated(ComponentModel model, object instance);
    protected virtual void RaiseComponentDestroyed(ComponentModel model, object instance);
    protected virtual void RaiseComponentModelCreated(ComponentModel model);
    protected virtual void RaiseComponentRegistered(string key, IHandler handler);
    protected virtual void RaiseDependencyResolving(ComponentModel client, DependencyModel model, object dependency);
    protected virtual void RaiseHandlerRegistered(IHandler handler);
    protected virtual void RaiseHandlersChanged();
    protected virtual void RaiseRegistrationCompleted();
    protected virtual void RaiseRemovedAsChildKernel();
    private void DoActualRaisingOfHandlersChanged();
    [CompilerGeneratedAttribute]
public sealed virtual void add_HandlerRegistered(HandlerDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_HandlerRegistered(HandlerDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_HandlersChanged(HandlersChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_HandlersChanged(HandlersChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ComponentRegistered(ComponentDataDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ComponentRegistered(ComponentDataDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ComponentCreated(ComponentInstanceDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ComponentCreated(ComponentInstanceDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ComponentDestroyed(ComponentInstanceDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ComponentDestroyed(ComponentInstanceDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AddedAsChildKernel(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AddedAsChildKernel(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RegistrationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RegistrationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RemovedAsChildKernel(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RemovedAsChildKernel(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ComponentModelCreated(ComponentModelDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ComponentModelCreated(ComponentModelDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DependencyResolving(DependencyDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DependencyResolving(DependencyDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_EmptyCollectionResolving(ServiceDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_EmptyCollectionResolving(ServiceDelegate value);
    public virtual object Resolve(string key, Type service);
    public virtual object Resolve(string key, Type service, Arguments arguments);
    public sealed virtual T Resolve(Arguments arguments);
    public sealed virtual T Resolve();
    public sealed virtual T Resolve(string key);
    public sealed virtual T Resolve(string key, Arguments arguments);
    public sealed virtual object Resolve(Type service);
    public sealed virtual object Resolve(Type service, Arguments arguments);
    public sealed virtual Array ResolveAll(Type service);
    public sealed virtual Array ResolveAll(Type service, Arguments arguments);
    public sealed virtual TService[] ResolveAll(Arguments arguments);
    public sealed virtual TService[] ResolveAll();
    private sealed virtual override object Castle.MicroKernel.IKernelInternal.Resolve(string key, Type service, Arguments arguments, IReleasePolicy policy);
    private sealed virtual override object Castle.MicroKernel.IKernelInternal.Resolve(Type service, Arguments arguments, IReleasePolicy policy, bool ignoreParentContext);
    private sealed virtual override Array Castle.MicroKernel.IKernelInternal.ResolveAll(Type service, Arguments arguments, IReleasePolicy policy);
}
public class Castle.MicroKernel.DependencyDelegate : MulticastDelegate {
    public DependencyDelegate(object object, IntPtr method);
    public virtual void Invoke(ComponentModel client, DependencyModel model, object dependency);
    public virtual IAsyncResult BeginInvoke(ComponentModel client, DependencyModel model, object dependency, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class Castle.MicroKernel.Facilities.AbstractFacility : object {
    private IConfiguration facilityConfig;
    private IKernel kernel;
    protected IConfiguration FacilityConfig { get; }
    protected IKernel Kernel { get; }
    protected IConfiguration get_FacilityConfig();
    protected IKernel get_Kernel();
    protected abstract virtual void Init();
    protected virtual void Dispose();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override void Castle.MicroKernel.IFacility.Init(IKernel kernel, IConfiguration facilityConfig);
    private sealed virtual override void Castle.MicroKernel.IFacility.Terminate();
}
public class Castle.MicroKernel.Facilities.FacilityException : Exception {
    public FacilityException(string message);
    public FacilityException(string message, Exception innerException);
}
public class Castle.MicroKernel.HandlerDelegate : MulticastDelegate {
    public HandlerDelegate(object object, IntPtr method);
    public virtual void Invoke(IHandler handler, Boolean& stateChanged);
    public virtual IAsyncResult BeginInvoke(IHandler handler, Boolean& stateChanged, AsyncCallback callback, object object);
    public virtual void EndInvoke(Boolean& stateChanged, IAsyncResult result);
}
public abstract class Castle.MicroKernel.Handlers.AbstractHandler : object {
    [DebuggerBrowsableAttribute("0")]
private ComponentModel model;
    [DebuggerBrowsableAttribute("0")]
private IKernelInternal kernel;
    [DebuggerBrowsableAttribute("0")]
private SimpleThreadSafeSet`1<DependencyModel> missingDependencies;
    [DebuggerBrowsableAttribute("0")]
private HandlerState state;
    [DebuggerBrowsableAttribute("3")]
public ComponentModel ComponentModel { get; }
    public HandlerState CurrentState { get; }
    [DebuggerBrowsableAttribute("0")]
protected IKernelInternal Kernel { get; }
    protected AbstractHandler(ComponentModel model);
    public sealed virtual ComponentModel get_ComponentModel();
    public sealed virtual HandlerState get_CurrentState();
    protected IKernelInternal get_Kernel();
    public abstract virtual bool ReleaseCore(Burden burden);
    protected abstract virtual object Resolve(CreationContext context, bool instanceRequired);
    public virtual string ToString();
    public virtual void Dispose();
    public sealed virtual void ObtainDependencyDetails(IDependencyInspector inspector);
    private bool HasCustomParameter(object key);
    public virtual void Init(IKernelInternal kernel);
    protected virtual void InitDependencies();
    public sealed virtual bool IsBeingResolvedInContext(CreationContext context);
    public virtual bool Release(Burden burden);
    public sealed virtual object Resolve(CreationContext context);
    public virtual bool Supports(Type service);
    public virtual bool SupportsAssignable(Type service);
    public sealed virtual object TryResolve(CreationContext context);
    public virtual bool CanResolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    public virtual object Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    protected void AddDependency(DependencyModel dependency);
    protected void AddMissingDependency(DependencyModel dependency);
    protected bool CanResolvePendingDependencies(CreationContext context);
    private bool CanProvideDependenciesDynamically(CreationContext context);
    protected void DependencySatisfied(Boolean& stateChanged);
    protected void OnAddedAsChildKernel(object sender, EventArgs e);
    protected void SetNewState(HandlerState newState);
    private void AddGraphDependency(DependencyModel dependency);
    private IHandler GetDependencyHandler(DependencyModel dependency);
    private bool AddOptionalDependency(DependencyModel dependency);
    private bool AddResolvableDependency(DependencyModel dependency);
    private bool AllRequiredDependenciesResolvable();
    private void DisconnectEvents();
    private bool HasValidComponentFromResolver(DependencyModel dependency);
}
public class Castle.MicroKernel.Handlers.ComponentLifecycleExtension : object {
    private List`1<ComponentResolvingDelegate> resolvers;
    private IKernel kernel;
    public void AddHandler(ComponentResolvingDelegate handler);
    public sealed virtual void Init(IKernel kernel, IHandler handler);
    public sealed virtual void Intercept(ResolveInvocation invocation);
}
public class Castle.MicroKernel.Handlers.ComponentReleasingDelegate : MulticastDelegate {
    public ComponentReleasingDelegate(object object, IntPtr method);
    public virtual void Invoke(IKernel kernel);
    public virtual IAsyncResult BeginInvoke(IKernel kernel, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.Handlers.ComponentResolvingDelegate : MulticastDelegate {
    public ComponentResolvingDelegate(object object, IntPtr method);
    public virtual ComponentReleasingDelegate Invoke(IKernel kernel, CreationContext context);
    public virtual IAsyncResult BeginInvoke(IKernel kernel, CreationContext context, AsyncCallback callback, object object);
    public virtual ComponentReleasingDelegate EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.Handlers.DefaultGenericHandler : AbstractHandler {
    private IGenericImplementationMatchingStrategy implementationMatchingStrategy;
    private IGenericServiceStrategy serviceStrategy;
    private SimpleThreadSafeDictionary`2<Type, IHandler> type2SubHandler;
    public IGenericImplementationMatchingStrategy ImplementationMatchingStrategy { get; }
    public IGenericServiceStrategy ServiceStrategy { get; }
    public DefaultGenericHandler(ComponentModel model, IGenericImplementationMatchingStrategy implementationMatchingStrategy, IGenericServiceStrategy serviceStrategy);
    public IGenericImplementationMatchingStrategy get_ImplementationMatchingStrategy();
    public IGenericServiceStrategy get_ServiceStrategy();
    public virtual void Dispose();
    public virtual bool ReleaseCore(Burden burden);
    public virtual bool Supports(Type service);
    public virtual bool SupportsAssignable(Type service);
    protected virtual Type[] AdaptServices(Type closedImplementationType, Type requestedType);
    protected virtual IHandler BuildSubHandler(Type closedImplementationType, Type requestedType);
    protected IHandler GetSubHandler(Type genericType, Type requestedType);
    protected virtual void InitDependencies();
    protected virtual object Resolve(CreationContext context, bool instanceRequired);
    protected bool SupportsAssignable(Type service, Type modelService, Type[] serviceArguments);
    private void CloneParentProperties(ComponentModel newModel);
    public IHandler ConvertToClosedGenericHandler(Type service, CreationContext openGenericContext);
    private Type GetClosedImplementationType(CreationContext context, bool instanceRequired);
    private Arguments GetExtendedProperties();
    private Type[] GetGenericArguments(CreationContext context);
    private static int AdaptClassServices(Type closedImplementationType, List`1<Type> closedServices, Type[] openServices);
    private static void AdaptInterfaceServices(Type closedImplementationType, List`1<Type> closedServices, Type[] openServices, int index);
    private static void EnsureClassMappingInitialized(Type closedImplementationType, IDictionary`2& genericDefinitionToClass);
    private static void EnsureInterfaceMappingInitialized(Type closedImplementationType, IDictionary`2& genericDefinitionToInterface);
}
public class Castle.MicroKernel.Handlers.DefaultHandler : AbstractHandler {
    private ILifestyleManager lifestyleManager;
    protected ILifestyleManager LifestyleManager { get; }
    public DefaultHandler(ComponentModel model);
    protected ILifestyleManager get_LifestyleManager();
    public virtual void Dispose();
    public virtual bool ReleaseCore(Burden burden);
    protected void AssertNotWaitingForDependency();
    protected virtual void InitDependencies();
    protected virtual object Resolve(CreationContext context, bool instanceRequired);
    protected object ResolveCore(CreationContext context, bool requiresDecommission, bool instanceRequired, Burden& burden);
    private HandlerException UnresolvableHandlerException();
}
public class Castle.MicroKernel.Handlers.DefaultHandlerFactory : object {
    private IKernelInternal kernel;
    public DefaultHandlerFactory(IKernelInternal kernel);
    public virtual IHandler Create(ComponentModel model);
    private IHandler CreateHandler(ComponentModel model);
    private IGenericImplementationMatchingStrategy GenericImplementationMatchingStrategy(ComponentModel model);
    private IGenericServiceStrategy GenericServiceStrategy(ComponentModel model);
}
public class Castle.MicroKernel.Handlers.DependencyInspector : object {
    private HashSet`1<IHandler> handlersChecked;
    private StringBuilder message;
    public string Message { get; }
    public DependencyInspector(StringBuilder message);
    public string get_Message();
    public sealed virtual void Inspect(IHandler handler, DependencyModel[] missingDependencies, IKernel kernel);
    private void InspectParameterDependency(DependencyModel dependency);
    private void InspectServiceDependency(IHandler inspectingHandler, DependencyModel dependency, IKernel kernel);
    private void InspectServiceOverrideDependency(DependencyModel dependency, IKernel kernel);
}
public class Castle.MicroKernel.Handlers.ExtendedHandler : DefaultHandler {
    private IReleaseExtension[] releaseExtensions;
    private IResolveExtension[] resolveExtensions;
    public ExtendedHandler(ComponentModel model, ICollection`1<IResolveExtension> resolveExtensions, ICollection`1<IReleaseExtension> releaseExtensions);
    public virtual void Init(IKernelInternal kernel);
    public virtual bool Release(Burden burden);
    protected virtual object Resolve(CreationContext context, bool instanceRequired);
    private void InvokeReleasePipeline(int extensionIndex, ReleaseInvocation invocation);
    private void InvokeResolvePipeline(int extensionIndex, ResolveInvocation invocation);
}
public class Castle.MicroKernel.Handlers.GenericHandlerTypeMismatchException : HandlerException {
    public GenericHandlerTypeMismatchException(string message, ComponentName name);
    public GenericHandlerTypeMismatchException(string message, ComponentName name, Exception innerException);
    public GenericHandlerTypeMismatchException(IEnumerable`1<Type> argumentsUsed, ComponentModel componentModel, DefaultGenericHandler handler);
    private static string BuildMessage(String[] argumentsUsed, ComponentModel componentModel, DefaultGenericHandler handler);
}
public class Castle.MicroKernel.Handlers.HandlerException : Exception {
    [CompilerGeneratedAttribute]
private ComponentName <Name>k__BackingField;
    public ComponentName Name { get; private set; }
    public HandlerException(string message, ComponentName name);
    public HandlerException(string message, ComponentName name, Exception innerException);
    [CompilerGeneratedAttribute]
public ComponentName get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(ComponentName value);
}
[ExtensionAttribute]
public static class Castle.MicroKernel.Handlers.HandlerExtensionsUtil : object {
    public static string ReleaseExtensionsKey;
    public static string ResolveExtensionsKey;
    private static HandlerExtensionsUtil();
    [ExtensionAttribute]
public static ICollection`1<IReleaseExtension> ReleaseExtensions(ComponentModel model, bool ensureExists);
    [ExtensionAttribute]
public static ICollection`1<IResolveExtension> ResolveExtensions(ComponentModel model, bool ensureExists);
}
public interface Castle.MicroKernel.Handlers.IDependencyInspector {
    public abstract virtual void Inspect(IHandler handler, DependencyModel[] missingDependencies, IKernel kernel);
}
public interface Castle.MicroKernel.Handlers.IExposeDependencyInfo {
    public abstract virtual void ObtainDependencyDetails(IDependencyInspector inspector);
}
public interface Castle.MicroKernel.Handlers.IGenericImplementationMatchingStrategy {
    public abstract virtual Type[] GetGenericArguments(ComponentModel model, CreationContext context);
}
public interface Castle.MicroKernel.Handlers.IGenericServiceStrategy {
    public abstract virtual bool Supports(Type service, ComponentModel component);
}
public interface Castle.MicroKernel.Handlers.IReleaseExtension {
    public abstract virtual void Init(IKernel kernel, IHandler handler);
    public abstract virtual void Intercept(ReleaseInvocation invocation);
}
public interface Castle.MicroKernel.Handlers.IResolveExtension {
    public abstract virtual void Init(IKernel kernel, IHandler handler);
    public abstract virtual void Intercept(ResolveInvocation invocation);
}
public class Castle.MicroKernel.Handlers.ParentHandlerWrapper : object {
    private ISubDependencyResolver childResolver;
    private IReleasePolicy parentReleasePolicy;
    private IHandler parentHandler;
    public ComponentModel ComponentModel { get; }
    public HandlerState CurrentState { get; }
    public ParentHandlerWrapper(IHandler parentHandler, ISubDependencyResolver childResolver, IReleasePolicy parentReleasePolicy);
    public virtual ComponentModel get_ComponentModel();
    public virtual HandlerState get_CurrentState();
    public sealed virtual void Dispose();
    public virtual void Init(IKernelInternal kernel);
    public sealed virtual bool IsBeingResolvedInContext(CreationContext context);
    public virtual bool Release(Burden burden);
    public virtual object Resolve(CreationContext context);
    public sealed virtual bool Supports(Type service);
    public sealed virtual bool SupportsAssignable(Type service);
    public sealed virtual object TryResolve(CreationContext context);
    public virtual bool CanResolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    public virtual object Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    protected virtual void Dispose(bool disposing);
}
public class Castle.MicroKernel.Handlers.ReleaseInvocation : object {
    private Action proceed;
    [CompilerGeneratedAttribute]
private Burden <Burden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public Burden Burden { get; private set; }
    public object Instance { get; }
    public bool ReturnValue { get; public set; }
    public ReleaseInvocation(Burden burden);
    [CompilerGeneratedAttribute]
public Burden get_Burden();
    [CompilerGeneratedAttribute]
private void set_Burden(Burden value);
    public object get_Instance();
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public void set_ReturnValue(bool value);
    public void Proceed();
    internal void SetProceedDelegate(Action value);
}
public class Castle.MicroKernel.Handlers.ResolveInvocation : object {
    private bool decommissionRequired;
    private Action proceed;
    [CompilerGeneratedAttribute]
private Burden <Burden>k__BackingField;
    [CompilerGeneratedAttribute]
private CreationContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstanceRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ResolvedInstance>k__BackingField;
    public Burden Burden { get; public set; }
    public CreationContext Context { get; private set; }
    public bool InstanceRequired { get; private set; }
    public object ResolvedInstance { get; public set; }
    internal bool DecommissionRequired { get; }
    public ResolveInvocation(CreationContext context, bool instanceRequired);
    [CompilerGeneratedAttribute]
public Burden get_Burden();
    [CompilerGeneratedAttribute]
public void set_Burden(Burden value);
    [CompilerGeneratedAttribute]
public CreationContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(CreationContext value);
    [CompilerGeneratedAttribute]
public bool get_InstanceRequired();
    [CompilerGeneratedAttribute]
private void set_InstanceRequired(bool value);
    [CompilerGeneratedAttribute]
public object get_ResolvedInstance();
    [CompilerGeneratedAttribute]
public void set_ResolvedInstance(object value);
    internal bool get_DecommissionRequired();
    public void Proceed();
    public void RequireDecommission();
    internal void SetProceedDelegate(Action value);
}
public class Castle.MicroKernel.HandlersChangedDelegate : MulticastDelegate {
    public HandlersChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(Boolean& stateChanged);
    public virtual IAsyncResult BeginInvoke(Boolean& stateChanged, AsyncCallback callback, object object);
    public virtual void EndInvoke(Boolean& stateChanged, IAsyncResult result);
}
public enum Castle.MicroKernel.HandlerState : Enum {
    public int value__;
    public static HandlerState Valid;
    public static HandlerState WaitingDependency;
}
public class Castle.MicroKernel.HandlerStateDelegate : MulticastDelegate {
    public HandlerStateDelegate(object object, IntPtr method);
    public virtual void Invoke(object source, EventArgs args);
    public virtual IAsyncResult BeginInvoke(object source, EventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface Castle.MicroKernel.IComponentActivator {
    public abstract virtual object Create(CreationContext context, Burden burden);
    public abstract virtual void Destroy(object instance);
}
public interface Castle.MicroKernel.IComponentModelBuilder {
    public IContributeComponentModelConstruction[] Contributors { get; }
    public abstract virtual IContributeComponentModelConstruction[] get_Contributors();
    public abstract virtual void AddContributor(IContributeComponentModelConstruction contributor);
    public abstract virtual ComponentModel BuildModel(ComponentName name, Type[] services, Type classType, Arguments extendedProperties);
    public abstract virtual ComponentModel BuildModel(IComponentModelDescriptor[] customContributors);
    public abstract virtual void RemoveContributor(IContributeComponentModelConstruction contributor);
}
public interface Castle.MicroKernel.IContextLifestyleManager {
    public abstract virtual object GetContextInstance(CreationContext context);
}
public interface Castle.MicroKernel.IDependencyResolver {
    public abstract virtual void AddSubResolver(ISubDependencyResolver subResolver);
    public abstract virtual void Initialize(IKernelInternal kernel, DependencyDelegate resolving);
    public abstract virtual void RemoveSubResolver(ISubDependencyResolver subResolver);
}
public interface Castle.MicroKernel.IFacility {
    public abstract virtual void Init(IKernel kernel, IConfiguration facilityConfig);
    public abstract virtual void Terminate();
}
public interface Castle.MicroKernel.IHandler {
    public ComponentModel ComponentModel { get; }
    public HandlerState CurrentState { get; }
    public abstract virtual ComponentModel get_ComponentModel();
    public abstract virtual HandlerState get_CurrentState();
    public abstract virtual void Init(IKernelInternal kernel);
    public abstract virtual bool IsBeingResolvedInContext(CreationContext context);
    public abstract virtual bool Release(Burden burden);
    public abstract virtual object Resolve(CreationContext context);
    public abstract virtual bool Supports(Type service);
    public abstract virtual bool SupportsAssignable(Type service);
    public abstract virtual object TryResolve(CreationContext context);
}
public interface Castle.MicroKernel.IHandlerFactory {
    public abstract virtual IHandler Create(ComponentModel model);
}
public interface Castle.MicroKernel.IHandlerSelector {
    public abstract virtual bool HasOpinionAbout(string key, Type service);
    public abstract virtual IHandler SelectHandler(string key, Type service, IHandler[] handlers);
}
public interface Castle.MicroKernel.IHandlersFilter {
    public abstract virtual bool HasOpinionAbout(Type service);
    public abstract virtual IHandler[] SelectHandlers(Type service, IHandler[] handlers);
}
public interface Castle.MicroKernel.IKernel {
    public IComponentModelBuilder ComponentModelBuilder { get; }
    public IConfigurationStore ConfigurationStore { get; public set; }
    public GraphNode[] GraphNodes { get; }
    public IHandlerFactory HandlerFactory { get; }
    public IKernel Parent { get; public set; }
    public IProxyFactory ProxyFactory { get; public set; }
    public IReleasePolicy ReleasePolicy { get; public set; }
    public IDependencyResolver Resolver { get; }
    public abstract virtual IComponentModelBuilder get_ComponentModelBuilder();
    public abstract virtual IConfigurationStore get_ConfigurationStore();
    public abstract virtual void set_ConfigurationStore(IConfigurationStore value);
    public abstract virtual GraphNode[] get_GraphNodes();
    public abstract virtual IHandlerFactory get_HandlerFactory();
    public abstract virtual IKernel get_Parent();
    public abstract virtual void set_Parent(IKernel value);
    public abstract virtual IProxyFactory get_ProxyFactory();
    public abstract virtual void set_ProxyFactory(IProxyFactory value);
    public abstract virtual IReleasePolicy get_ReleasePolicy();
    public abstract virtual void set_ReleasePolicy(IReleasePolicy value);
    public abstract virtual IDependencyResolver get_Resolver();
    public abstract virtual void AddChildKernel(IKernel kernel);
    public abstract virtual IKernel AddFacility(IFacility facility);
    public abstract virtual IKernel AddFacility();
    public abstract virtual IKernel AddFacility(Action`1<T> onCreate);
    public abstract virtual void AddHandlerSelector(IHandlerSelector selector);
    public abstract virtual void AddHandlersFilter(IHandlersFilter filter);
    public abstract virtual void AddSubSystem(string name, ISubSystem subsystem);
    public abstract virtual IHandler[] GetAssignableHandlers(Type service);
    public abstract virtual IFacility[] GetFacilities();
    public abstract virtual IHandler GetHandler(string name);
    public abstract virtual IHandler GetHandler(Type service);
    public abstract virtual IHandler[] GetHandlers();
    public abstract virtual IHandler[] GetHandlers(Type service);
    public abstract virtual ISubSystem GetSubSystem(string name);
    public abstract virtual bool HasComponent(string name);
    public abstract virtual bool HasComponent(Type service);
    public abstract virtual IKernel Register(IRegistration[] registrations);
    public abstract virtual void ReleaseComponent(object instance);
    public abstract virtual void RemoveChildKernel(IKernel kernel);
    public abstract virtual object Resolve(Type service);
    public abstract virtual object Resolve(Type service, Arguments arguments);
    public abstract virtual object Resolve(string key, Type service);
    public abstract virtual T Resolve(Arguments arguments);
    public abstract virtual T Resolve();
    public abstract virtual T Resolve(string key);
    public abstract virtual T Resolve(string key, Arguments arguments);
    public abstract virtual object Resolve(string key, Type service, Arguments arguments);
    public abstract virtual Array ResolveAll(Type service);
    public abstract virtual Array ResolveAll(Type service, Arguments arguments);
    public abstract virtual TService[] ResolveAll();
    public abstract virtual TService[] ResolveAll(Arguments arguments);
}
public interface Castle.MicroKernel.IKernelEvents {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRegistered(ComponentDataDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRegistered(ComponentDataDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentModelCreated(ComponentModelDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentModelCreated(ComponentModelDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AddedAsChildKernel(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AddedAsChildKernel(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_RemovedAsChildKernel(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RemovedAsChildKernel(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentCreated(ComponentInstanceDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentCreated(ComponentInstanceDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentDestroyed(ComponentInstanceDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentDestroyed(ComponentInstanceDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_HandlerRegistered(HandlerDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_HandlerRegistered(HandlerDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_HandlersChanged(HandlersChangedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_HandlersChanged(HandlersChangedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DependencyResolving(DependencyDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DependencyResolving(DependencyDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_RegistrationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RegistrationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_EmptyCollectionResolving(ServiceDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EmptyCollectionResolving(ServiceDelegate value);
}
public interface Castle.MicroKernel.IKernelInternal {
    public ILogger Logger { get; public set; }
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual IHandler AddCustomComponent(ComponentModel model);
    public abstract virtual IComponentActivator CreateComponentActivator(ComponentModel model);
    public abstract virtual ILifestyleManager CreateLifestyleManager(ComponentModel model, IComponentActivator activator);
    public abstract virtual IHandler LoadHandlerByName(string key, Type service, Arguments arguments);
    public abstract virtual IHandler LoadHandlerByType(string key, Type service, Arguments arguments);
    public abstract virtual IDisposable OptimizeDependencyResolution();
    public abstract virtual object Resolve(Type service, Arguments arguments, IReleasePolicy policy, bool ignoreParentContext);
    public abstract virtual object Resolve(string key, Type service, Arguments arguments, IReleasePolicy policy);
    public abstract virtual Array ResolveAll(Type service, Arguments arguments, IReleasePolicy policy);
    public abstract virtual IHandler CreateHandler(ComponentModel model);
    public abstract virtual void RaiseEventsOnHandlerCreated(IHandler handler);
}
public interface Castle.MicroKernel.ILifestyleManager {
    public abstract virtual void Init(IComponentActivator componentActivator, IKernel kernel, ComponentModel model);
    public abstract virtual bool Release(object instance);
    public abstract virtual object Resolve(CreationContext context, IReleasePolicy releasePolicy);
}
public class Castle.MicroKernel.InstanceReference`1 : object {
    private T instance;
    public InstanceReference`1(T instance);
    public sealed virtual void Attach(ComponentModel component);
    public sealed virtual void Detach(ComponentModel component);
    public sealed virtual T Resolve(IKernel kernel, CreationContext context);
}
public interface Castle.MicroKernel.Internal.ILockHolder {
    public bool LockAcquired { get; }
    public abstract virtual bool get_LockAcquired();
}
[EditorBrowsableAttribute("1")]
public interface Castle.MicroKernel.Internal.IUpgradeableLockHolder {
    public abstract virtual ILockHolder Upgrade();
    public abstract virtual ILockHolder Upgrade(bool waitForLock);
}
public class Castle.MicroKernel.Internal.LazyEx`1 : Lazy`1<T> {
    private IKernel kernel;
    public LazyEx`1(IKernel kernel, Arguments arguments);
    public LazyEx`1(IKernel kernel, string overrideComponentName);
    public LazyEx`1(IKernel kernel, string overrideComponentName, Arguments arguments);
    public LazyEx`1(IKernel kernel);
    public sealed virtual void Dispose();
}
public class Castle.MicroKernel.Internal.LazyServiceStrategy : object {
    public static LazyServiceStrategy Instance;
    private static LazyServiceStrategy();
    public sealed virtual bool Supports(Type service, ComponentModel component);
}
public abstract class Castle.MicroKernel.Internal.Lock : object {
    public abstract virtual IUpgradeableLockHolder ForReadingUpgradeable();
    public abstract virtual ILockHolder ForReading();
    public abstract virtual ILockHolder ForWriting();
    public abstract virtual IUpgradeableLockHolder ForReadingUpgradeable(bool waitForLock);
    public abstract virtual ILockHolder ForReading(bool waitForLock);
    public abstract virtual ILockHolder ForWriting(bool waitForLock);
    public static Lock Create();
}
[EditorBrowsableAttribute("1")]
internal class Castle.MicroKernel.Internal.NoOpLock : object {
    public static ILockHolder Lock;
    public bool LockAcquired { get; }
    private static NoOpLock();
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
[EditorBrowsableAttribute("1")]
internal class Castle.MicroKernel.Internal.SlimReadLockHolder : object {
    private ReaderWriterLockSlim locker;
    [CompilerGeneratedAttribute]
private bool <LockAcquired>k__BackingField;
    public bool LockAcquired { get; private set; }
    public SlimReadLockHolder(ReaderWriterLockSlim locker, bool waitForLock);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_LockAcquired();
    [CompilerGeneratedAttribute]
private void set_LockAcquired(bool value);
}
public class Castle.MicroKernel.Internal.SlimReadWriteLock : Lock {
    private ReaderWriterLockSlim locker;
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public virtual IUpgradeableLockHolder ForReadingUpgradeable();
    public virtual ILockHolder ForReading();
    public virtual ILockHolder ForWriting();
    public virtual IUpgradeableLockHolder ForReadingUpgradeable(bool waitForLock);
    public virtual ILockHolder ForReading(bool waitForLock);
    public virtual ILockHolder ForWriting(bool waitForLock);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
}
internal class Castle.MicroKernel.Internal.SlimUpgradeableReadLockHolder : object {
    private ReaderWriterLockSlim locker;
    private SlimWriteLockHolder writerLock;
    private bool wasLockAlreadySelf;
    [CompilerGeneratedAttribute]
private bool <LockAcquired>k__BackingField;
    public bool LockAcquired { get; private set; }
    public SlimUpgradeableReadLockHolder(ReaderWriterLockSlim locker, bool waitForLock, bool wasLockAlreadySelf);
    public sealed virtual void Dispose();
    public sealed virtual ILockHolder Upgrade();
    public sealed virtual ILockHolder Upgrade(bool waitForLock);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_LockAcquired();
    [CompilerGeneratedAttribute]
private void set_LockAcquired(bool value);
}
internal class Castle.MicroKernel.Internal.SlimWriteLockHolder : object {
    private ReaderWriterLockSlim locker;
    private bool lockAcquired;
    public bool LockAcquired { get; }
    public SlimWriteLockHolder(ReaderWriterLockSlim locker, bool waitForLock);
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
public interface Castle.MicroKernel.IProxyFactory {
    public abstract virtual void AddInterceptorSelector(IModelInterceptorsSelector selector);
    public abstract virtual object Create(IKernel kernel, object instance, ComponentModel model, CreationContext context, Object[] constructorArguments);
    public abstract virtual object Create(IProxyFactoryExtension customFactory, IKernel kernel, ComponentModel model, CreationContext context, Object[] constructorArguments);
    public abstract virtual bool RequiresTargetInstance(IKernel kernel, ComponentModel model);
    public abstract virtual bool ShouldCreateProxy(ComponentModel model);
}
public interface Castle.MicroKernel.IProxyFactoryExtension {
    public abstract virtual object Generate(IProxyBuilder builder, ProxyGenerationOptions options, IInterceptor[] interceptors, ComponentModel model, CreationContext context);
}
public interface Castle.MicroKernel.IReference`1 {
    public abstract virtual void Attach(ComponentModel component);
    public abstract virtual void Detach(ComponentModel component);
    public abstract virtual T Resolve(IKernel kernel, CreationContext context);
}
public interface Castle.MicroKernel.IReleasePolicy {
    public abstract virtual IReleasePolicy CreateSubPolicy();
    public abstract virtual bool HasTrack(object instance);
    public abstract virtual void Release(object instance);
    public abstract virtual void Track(object instance, Burden burden);
}
public interface Castle.MicroKernel.ISubDependencyResolver {
    public abstract virtual bool CanResolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    public abstract virtual object Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
}
public interface Castle.MicroKernel.ISubSystem {
    public abstract virtual void Init(IKernelInternal kernel);
    public abstract virtual void Terminate();
}
public class Castle.MicroKernel.KernelException : Exception {
    public KernelException(string message);
    public KernelException(string message, Exception innerException);
}
public class Castle.MicroKernel.LifecycleConcerns.DisposalConcern : object {
    private static DisposalConcern instance;
    public static DisposalConcern Instance { get; }
    private static DisposalConcern();
    public static DisposalConcern get_Instance();
    public sealed virtual void Apply(ComponentModel model, object component);
}
public class Castle.MicroKernel.LifecycleConcerns.InitializationConcern : object {
    private static InitializationConcern instance;
    public static InitializationConcern Instance { get; }
    private static InitializationConcern();
    public static InitializationConcern get_Instance();
    public sealed virtual void Apply(ComponentModel model, object component);
}
public class Castle.MicroKernel.LifecycleConcerns.LateBoundCommissionConcerns : LateBoundConcerns`1<ICommissionConcern> {
    public virtual void Apply(ComponentModel model, object component);
}
public abstract class Castle.MicroKernel.LifecycleConcerns.LateBoundConcerns`1 : object {
    private IDictionary`2<Type, TConcern> concerns;
    private ConcurrentDictionary`2<Type, List`1<TConcern>> concernsCache;
    public bool HasConcerns { get; }
    public bool get_HasConcerns();
    public void AddConcern(TConcern lifecycleConcern);
    public abstract virtual void Apply(ComponentModel model, object component);
    private List`1<TConcern> BuildConcernCache(Type type);
    protected List`1<TConcern> GetComponentConcerns(Type type);
}
public class Castle.MicroKernel.LifecycleConcerns.LateBoundDecommissionConcerns : LateBoundConcerns`1<IDecommissionConcern> {
    public virtual void Apply(ComponentModel model, object component);
}
public class Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate`1 : MulticastDelegate {
    public LifecycleActionDelegate`1(object object, IntPtr method);
    public virtual void Invoke(IKernel kernel, T item);
    public virtual IAsyncResult BeginInvoke(IKernel kernel, T item, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.LifecycleConcerns.OnCreatedConcern`1 : object {
    private LifecycleActionDelegate`1<TComponent> action;
    private IKernel kernel;
    public OnCreatedConcern`1(LifecycleActionDelegate`1<TComponent> action, IKernel kernel);
    public sealed virtual void Apply(ComponentModel model, object component);
}
public class Castle.MicroKernel.LifecycleConcerns.OnDestroyConcern`1 : object {
    private LifecycleActionDelegate`1<TComponent> action;
    private IKernel kernel;
    public OnDestroyConcern`1(LifecycleActionDelegate`1<TComponent> action, IKernel kernel);
    public sealed virtual void Apply(ComponentModel model, object component);
}
public class Castle.MicroKernel.LifecycleConcerns.SupportInitializeConcern : object {
    [CompilerGeneratedAttribute]
private static SupportInitializeConcern <Instance>k__BackingField;
    public static SupportInitializeConcern Instance { get; }
    private static SupportInitializeConcern();
    public sealed virtual void Apply(ComponentModel model, object component);
    [CompilerGeneratedAttribute]
public static SupportInitializeConcern get_Instance();
}
public abstract class Castle.MicroKernel.Lifestyle.AbstractLifestyleManager : object {
    private IComponentActivator componentActivator;
    private IKernel kernel;
    private ComponentModel model;
    protected IComponentActivator ComponentActivator { get; }
    protected IKernel Kernel { get; }
    protected ComponentModel Model { get; }
    protected IComponentActivator get_ComponentActivator();
    protected IKernel get_Kernel();
    protected ComponentModel get_Model();
    public abstract virtual void Dispose();
    public virtual void Init(IComponentActivator componentActivator, IKernel kernel, ComponentModel model);
    public virtual bool Release(object instance);
    public virtual object Resolve(CreationContext context, IReleasePolicy releasePolicy);
    protected virtual Burden CreateInstance(CreationContext context, bool trackedExternally);
    protected virtual void Track(Burden burden, IReleasePolicy releasePolicy);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Castle.MicroKernel.Lifestyle.LifestyleExtensions : object {
    [ExtensionAttribute]
public static IDisposable BeginScope(IKernel kernel);
    [ExtensionAttribute]
public static IDisposable BeginScope(IWindsorContainer container);
    [ExtensionAttribute]
public static IDisposable RequireScope(IKernel kernel);
    [ExtensionAttribute]
public static IDisposable RequireScope(IWindsorContainer container);
    private static IDisposable BeginScope();
    private static IDisposable RequireScope();
}
public class Castle.MicroKernel.Lifestyle.LifetimeScopeAccessor : object {
    public sealed virtual void Dispose();
    public sealed virtual ILifetimeScope GetScope(CreationContext context);
}
public class Castle.MicroKernel.Lifestyle.Pool.DefaultPool : object {
    private Stack`1<Burden> available;
    private IComponentActivator componentActivator;
    private Dictionary`2<object, Burden> inUse;
    private int initialSize;
    private int maxsize;
    private Lock rwlock;
    private bool initialized;
    public DefaultPool(int initialSize, int maxsize, IComponentActivator componentActivator);
    public virtual void Dispose();
    public virtual bool Release(object instance);
    public virtual object Request(CreationContext context, Func`2<CreationContext, Burden> creationCallback);
    protected virtual void Intitialize(Func`2<CreationContext, Burden> createCallback, CreationContext c);
}
public class Castle.MicroKernel.Lifestyle.Pool.DefaultPoolFactory : object {
    public sealed virtual IPool Create(int initialsize, int maxSize, IComponentActivator activator);
}
public interface Castle.MicroKernel.Lifestyle.Pool.IPool {
    public abstract virtual bool Release(object instance);
    public abstract virtual object Request(CreationContext context, Func`2<CreationContext, Burden> creationCallback);
}
public interface Castle.MicroKernel.Lifestyle.Pool.IPoolFactory {
    public abstract virtual IPool Create(int initialsize, int maxSize, IComponentActivator activator);
}
public class Castle.MicroKernel.Lifestyle.Pool.PoolException : Exception {
    public PoolException(string message);
}
public class Castle.MicroKernel.Lifestyle.PoolableLifestyleManager : AbstractLifestyleManager {
    private static object poolFactoryLock;
    private ThreadSafeInit init;
    private int initialSize;
    private int maxSize;
    private IPool pool;
    protected IPool Pool { get; }
    public PoolableLifestyleManager(int initialSize, int maxSize);
    private static PoolableLifestyleManager();
    protected IPool get_Pool();
    public virtual void Dispose();
    public virtual bool Release(object instance);
    public virtual object Resolve(CreationContext context, IReleasePolicy releasePolicy);
    protected IPool CreatePool(int initialSize, int maxSize);
    protected virtual Burden PoolCreationCallback(CreationContext context, IReleasePolicy releasePolicy);
    protected virtual void Track(Burden burden, IReleasePolicy releasePolicy);
}
public class Castle.MicroKernel.Lifestyle.Scoped.CallContextLifetimeScope : object {
    private static ConcurrentDictionary`2<Guid, CallContextLifetimeScope> allScopes;
    private static AsyncLocal`1<Guid> asyncLocal;
    private Guid contextId;
    private CallContextLifetimeScope parentScope;
    private Lock lock;
    private ScopeCache cache;
    private static CallContextLifetimeScope();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    public sealed virtual Burden GetCachedInstance(ComponentModel model, ScopedInstanceActivationCallback createInstance);
    [SecuritySafeCriticalAttribute]
private static void SetCurrentScope(CallContextLifetimeScope lifetimeScope);
    [SecuritySafeCriticalAttribute]
public static CallContextLifetimeScope ObtainCurrentScope();
}
public class Castle.MicroKernel.Lifestyle.Scoped.CreationContextScopeAccessor : object {
    private static string ScopeStash;
    private ComponentModel componentModel;
    private Func`2<IHandler[], IHandler> scopeRootSelector;
    public CreationContextScopeAccessor(ComponentModel componentModel, Func`2<IHandler[], IHandler> scopeRootSelector);
    public sealed virtual void Dispose();
    public sealed virtual ILifetimeScope GetScope(CreationContext context);
    public static IHandler DefaultScopeRootSelector(IHandler[] resolutionStack);
    public static IHandler NearestScopeRootSelector(IHandler[] resolutionStack);
}
public class Castle.MicroKernel.Lifestyle.Scoped.DefaultLifetimeScope : object {
    private static Action`1<Burden> emptyOnAfterCreated;
    private Action`1<Burden> onAfterCreated;
    private IScopeCache scopeCache;
    public DefaultLifetimeScope(IScopeCache scopeCache, Action`1<Burden> onAfterCreated);
    private static DefaultLifetimeScope();
    public sealed virtual void Dispose();
    public sealed virtual Burden GetCachedInstance(ComponentModel model, ScopedInstanceActivationCallback createInstance);
}
public interface Castle.MicroKernel.Lifestyle.Scoped.ILifetimeScope {
    public abstract virtual Burden GetCachedInstance(ComponentModel model, ScopedInstanceActivationCallback createInstance);
}
public interface Castle.MicroKernel.Lifestyle.Scoped.IScopeAccessor {
    public abstract virtual ILifetimeScope GetScope(CreationContext context);
}
[DefaultMemberAttribute("Item")]
public interface Castle.MicroKernel.Lifestyle.Scoped.IScopeCache {
    public Burden Item { get; public set; }
    public abstract virtual void set_Item(object id, Burden value);
    public abstract virtual Burden get_Item(object id);
}
[DefaultMemberAttribute("Item")]
public class Castle.MicroKernel.Lifestyle.Scoped.ScopeCache : object {
    private IDictionary`2<object, Burden> cache;
    public Burden Item { get; public set; }
    public sealed virtual void set_Item(object id, Burden value);
    public sealed virtual Burden get_Item(object id);
    public sealed virtual void Dispose();
}
public class Castle.MicroKernel.Lifestyle.Scoped.ScopedInstanceActivationCallback : MulticastDelegate {
    public ScopedInstanceActivationCallback(object object, IntPtr method);
    public virtual Burden Invoke(Action`1<Burden> afterCreated);
    public virtual IAsyncResult BeginInvoke(Action`1<Burden> afterCreated, AsyncCallback callback, object object);
    public virtual Burden EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.Lifestyle.ScopedLifestyleManager : AbstractLifestyleManager {
    private IScopeAccessor accessor;
    public ScopedLifestyleManager(IScopeAccessor accessor);
    public virtual void Dispose();
    public virtual object Resolve(CreationContext context, IReleasePolicy releasePolicy);
    private ILifetimeScope GetScope(CreationContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Burden <>n__0(CreationContext context, bool trackedExternally);
}
public class Castle.MicroKernel.Lifestyle.SingletonLifestyleManager : AbstractLifestyleManager {
    private ThreadSafeInit init;
    private Burden cachedBurden;
    public virtual void Dispose();
    public virtual object Resolve(CreationContext context, IReleasePolicy releasePolicy);
    public sealed virtual object GetContextInstance(CreationContext context);
}
public class Castle.MicroKernel.Lifestyle.ThreadScopeAccessor : object {
    private SimpleThreadSafeDictionary`2<int, ILifetimeScope> items;
    public sealed virtual void Dispose();
    public sealed virtual ILifetimeScope GetScope(CreationContext context);
    protected virtual int GetCurrentThreadId();
}
public class Castle.MicroKernel.Lifestyle.TransientLifestyleManager : AbstractLifestyleManager {
    public virtual void Dispose();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Castle.MicroKernel.ModelBuilder.ComponentModelDescriptorUtil : object {
    public static string MetaDescriptorsKey;
    private static ComponentModelDescriptorUtil();
    [ExtensionAttribute]
public static ICollection`1<IMetaComponentModelDescriptor> GetMetaDescriptors(ComponentModel model, bool ensureExists);
    public static void RemoveMetaDescriptors(ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder : object {
    private List`1<IContributeComponentModelConstruction> contributors;
    private IKernel kernel;
    public IContributeComponentModelConstruction[] Contributors { get; }
    public DefaultComponentModelBuilder(IKernel kernel);
    public sealed virtual IContributeComponentModelConstruction[] get_Contributors();
    public sealed virtual void AddContributor(IContributeComponentModelConstruction contributor);
    public sealed virtual ComponentModel BuildModel(ComponentName name, Type[] services, Type classType, Arguments extendedProperties);
    public sealed virtual ComponentModel BuildModel(IComponentModelDescriptor[] customContributors);
    public sealed virtual void RemoveContributor(IContributeComponentModelConstruction contributor);
    protected virtual void InitializeContributors();
}
public abstract class Castle.MicroKernel.ModelBuilder.Descriptors.AbstractOverwriteableDescriptor`1 : object {
    [CompilerGeneratedAttribute]
private ComponentRegistration`1<TService> <Registration>k__BackingField;
    protected bool IsOverWrite { get; }
    private ComponentRegistration`1<TService> Registration { get; internal set; }
    protected bool get_IsOverWrite();
    [CompilerGeneratedAttribute]
private ComponentRegistration`1<TService> get_Registration();
    [CompilerGeneratedAttribute]
internal void set_Registration(ComponentRegistration`1<TService> value);
    public virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
    protected virtual void ApplyToConfiguration(IKernel kernel, IConfiguration configuration);
}
public abstract class Castle.MicroKernel.ModelBuilder.Descriptors.AbstractPropertyDescriptor : object {
    public abstract virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
    protected void AddParameter(ComponentModel model, string name, IConfiguration value);
    protected void AddParameter(ComponentModel model, string name, string value);
    private IConfiguration EnsureParametersConfiguration(ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.AttributeDescriptor`1 : AbstractOverwriteableDescriptor`1<S> {
    private string name;
    private string value;
    public AttributeDescriptor`1(string name, string value);
    protected virtual void ApplyToConfiguration(IKernel kernel, IConfiguration configuration);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.AttributeKeyDescriptor`1 : object {
    private ComponentRegistration`1<S> component;
    private string name;
    public AttributeKeyDescriptor`1(ComponentRegistration`1<S> component, string name);
    public ComponentRegistration`1<S> Eq(object value);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.ConfigurationDescriptor : object {
    private Node[] configNodes;
    private IConfiguration configuration;
    public ConfigurationDescriptor(Node[] configNodes);
    public ConfigurationDescriptor(IConfiguration configuration);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.CustomDependencyDescriptor : object {
    private Arguments arguments;
    private Property[] properties;
    public CustomDependencyDescriptor(Arguments arguments);
    public CustomDependencyDescriptor(Property[] properties);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.DefaultsDescriptor : object {
    private Type implementation;
    private ComponentName name;
    public DefaultsDescriptor(ComponentName name, Type implementation);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
    private void EnsureComponentConfiguration(IKernel kernel, ComponentModel model);
    private void EnsureComponentName(ComponentModel model);
    private Type FirstService(ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.DelegatingModelDescriptor : object {
    private Action`2<IKernel, ComponentModel> builder;
    private Action`2<IKernel, ComponentModel> configurer;
    public DelegatingModelDescriptor(Action`2<IKernel, ComponentModel> builder, Action`2<IKernel, ComponentModel> configurer);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.DynamicParametersDescriptor : object {
    private static string key;
    private DynamicParametersWithContextResolveDelegate resolve;
    public DynamicParametersDescriptor(DynamicParametersWithContextResolveDelegate resolve);
    private static DynamicParametersDescriptor();
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
    private ComponentLifecycleExtension GetDynamicParametersExtension(ComponentModel model);
    [CompilerGeneratedAttribute]
private ComponentReleasingDelegate <BuildComponentModel>b__3_0(IKernel k, CreationContext c);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.ExtendedPropertiesDescriptor : object {
    private IDictionary dictionary;
    private Property[] properties;
    public ExtendedPropertiesDescriptor(Property[] properties);
    public ExtendedPropertiesDescriptor(IDictionary dictionary);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.InterceptorDescriptor : object {
    private int insertIndex;
    private InterceptorReference[] interceptors;
    private Where where;
    public InterceptorDescriptor(InterceptorReference[] interceptors, Where where);
    public InterceptorDescriptor(InterceptorReference[] interceptors, int insertIndex);
    public InterceptorDescriptor(InterceptorReference[] interceptors);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.InterceptorSelectorDescriptor : object {
    private IReference`1<IInterceptorSelector> selector;
    public InterceptorSelectorDescriptor(IReference`1<IInterceptorSelector> selector);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.LifestyleDescriptor`1 : AbstractOverwriteableDescriptor`1<S> {
    private LifestyleType lifestyle;
    public LifestyleDescriptor`1(LifestyleType lifestyle);
    protected virtual void ApplyToConfiguration(IKernel kernel, IConfiguration configuration);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.OnCreateComponentDescriptor`1 : object {
    private LifecycleActionDelegate`1<S> action;
    public OnCreateComponentDescriptor`1(LifecycleActionDelegate`1<S> action);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.OnDestroyComponentDescriptor`1 : object {
    private LifecycleActionDelegate`1<S> action;
    public OnDestroyComponentDescriptor`1(LifecycleActionDelegate`1<S> action);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.ParametersDescriptor : AbstractPropertyDescriptor {
    private Parameter[] parameters;
    public ParametersDescriptor(Parameter[] parameters);
    public virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    private void Apply(ComponentModel model, Parameter parameter);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.ProxyHookDescriptor : object {
    private IReference`1<IProxyGenerationHook> hook;
    public ProxyHookDescriptor(IReference`1<IProxyGenerationHook> hook);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.ProxyInterfacesDescriptor : object {
    private Type[] interfaces;
    public ProxyInterfacesDescriptor(Type[] interfaces);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.ProxyMixInsDescriptor : object {
    private IEnumerable`1<IReference`1<object>> mixIns;
    public ProxyMixInsDescriptor(IEnumerable`1<IReference`1<object>> mixIns);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.ReferenceDependencyDescriptor : object {
    private IReference`1<object> dependency;
    public ReferenceDependencyDescriptor(IReference`1<object> dependency);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.ServiceOverrideDescriptor : AbstractPropertyDescriptor {
    private object value;
    public ServiceOverrideDescriptor(ServiceOverride[] overrides);
    public ServiceOverrideDescriptor(IDictionary dictionary);
    public virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    private void Apply(ComponentModel model, object dependencyKey, object dependencyValue, ServiceOverride override);
    private void ApplyReferenceList(ComponentModel model, object name, IEnumerable`1<string> items, ServiceOverride serviceOverride);
    private void ApplySimpleReference(ComponentModel model, object dependencyName, string componentKey);
    private string GetNameString(object key);
}
public class Castle.MicroKernel.ModelBuilder.Descriptors.ServicesDescriptor : object {
    private Type[] services;
    public ServicesDescriptor(Type[] services);
    public sealed virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public sealed virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public interface Castle.MicroKernel.ModelBuilder.IComponentModelDescriptor {
    public abstract virtual void BuildComponentModel(IKernel kernel, ComponentModel model);
    public abstract virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public interface Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction {
    public abstract virtual void ProcessModel(IKernel kernel, ComponentModel model);
}
public interface Castle.MicroKernel.ModelBuilder.IMetaComponentModelDescriptor {
    public abstract virtual void ConfigureComponentModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector : object {
    private IConversionManager converter;
    public ComponentActivatorInspector(IConversionManager converter);
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
    protected virtual bool ReadComponentActivatorFromConfiguration(ComponentModel model);
    protected virtual void ReadComponentActivatorFromType(ComponentModel model);
    protected virtual void ValidateComponentActivator(Type customComponentActivator);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector : object {
    private IConversionManager converter;
    public ComponentProxyInspector(IConversionManager converter);
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
    protected virtual ComponentProxyBehaviorAttribute ReadProxyBehaviorFromType(Type implementation);
    protected virtual void ReadProxyBehavior(IKernel kernel, ComponentModel model);
    private void ReadProxyBehaviorFromConfig(ComponentModel model, ComponentProxyBehaviorAttribute behavior);
    private static void ApplyProxyBehavior(ComponentProxyBehaviorAttribute behavior, ComponentModel model);
    private static void EnsureComponentRegisteredWithInterface(ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector : object {
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector : object {
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
    private void AddAnyServiceOverrides(ComponentModel model, IConfiguration config, ParameterModel parameter);
    private void InspectCollections(ComponentModel model);
    private bool IsArray(ParameterModel parameter);
    private bool IsList(ParameterModel parameter);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.ConstructorDependenciesModelInspector : object {
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
    protected virtual ConstructorCandidate CreateConstructorCandidate(ComponentModel model, ConstructorInfo constructor);
    private static ConstructorDependencyModel BuildParameterDependency(ParameterInfo parameter);
    protected virtual bool IsVisibleToContainer(ConstructorInfo constructor);
}
internal abstract class Castle.MicroKernel.ModelBuilder.Inspectors.ExtendedPropertiesConstants : object {
    public static int Pool_Default_InitialPoolSize;
    public static int Pool_Default_MaxPoolSize;
    public static string Pool_InitialPoolSize;
    public static string Pool_MaxPoolSize;
    private static ExtendedPropertiesConstants();
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.GenericInspector : object {
    public sealed virtual void ProcessModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.InterceptorInspector : object {
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
    protected virtual void AddInterceptor(InterceptorReference interceptorRef, InterceptorReferenceCollection interceptors);
    protected virtual void CollectFromAttributes(ComponentModel model);
    protected virtual void CollectFromConfiguration(ComponentModel model);
    protected virtual void CollectHook(IConfiguration interceptors, ProxyOptions options);
    protected virtual void CollectSelector(IConfiguration interceptors, ProxyOptions options);
    private void CollectInterceptors(ComponentModel model, IConfiguration interceptors);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector : object {
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
    private bool IsLateBoundComponent(ComponentModel model);
    private void ProcessLateBoundModel(ComponentModel model);
    private void ProcessModel(ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector : object {
    private IConversionManager converter;
    public LifestyleModelInspector(IConversionManager converter);
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
    protected virtual bool ReadLifestyleFromConfiguration(ComponentModel model);
    protected virtual void ReadLifestyleFromType(ComponentModel model);
    protected virtual void ValidateTypeFromAttribute(Type typeFromAttribute, Type expectedInterface, string attribute);
    private Func`2<IHandler[], IHandler> ExtractBinder(Type scopeRootBinderType, string name);
    private void ExtractPoolConfig(ComponentModel model);
    private Type GetMandatoryTypeFromAttribute(ComponentModel model, string attribute, LifestyleType lifestyleType);
    private Type GetTypeFromAttribute(ComponentModel model, string attribute);
    private bool IsBindMethod(MemberInfo methodMember, object _);
}
public abstract class Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector : object {
    private static BindingFlags AllMethods;
    private ITypeConverter converter;
    protected bool ShouldUseMetaModel { get; }
    private static MethodMetaInspector();
    protected virtual bool get_ShouldUseMetaModel();
    protected abstract virtual string ObtainNodeName();
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
    protected virtual bool IsValidMeta(ComponentModel model, MethodMetaModel metaModel);
    protected virtual void ProcessMeta(ComponentModel model, IList`1<MethodInfo> methods, MethodMetaModel metaModel);
    private void AssertNameIsNotNull(string name, ComponentModel model);
    private Type[] ConvertSignature(string signature);
    private void EnsureHasReferenceToConverter(IKernel kernel);
    private IList`1<MethodInfo> GetMethods(Type implementation, string name, string signature);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.MixinInspector : object {
    public sealed virtual void ProcessModel(IKernel kernel, ComponentModel model);
}
public class Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector : object {
    private IConversionManager converter;
    public PropertiesDependenciesModelInspector(IConversionManager converter);
    public virtual void ProcessModel(IKernel kernel, ComponentModel model);
    protected virtual void InspectProperties(ComponentModel model);
    private PropertySet BuildDependency(PropertyInfo property, bool isOptional);
    private PropertiesInspectionBehavior GetInspectionBehaviorFromTheConfiguration(IConfiguration config);
    private List`1<PropertyInfo> GetProperties(ComponentModel model, Type targetType);
    private static bool HasDoNotWireAttribute(PropertyInfo property);
    private static bool HasParameters(PropertyInfo property);
    private static bool IsSettable(PropertyInfo property);
    private static bool IsValidPropertyDependency(PropertyInfo property);
}
public interface Castle.MicroKernel.Proxy.IModelInterceptorsSelector {
    public abstract virtual bool HasInterceptors(ComponentModel model);
    public abstract virtual InterceptorReference[] SelectInterceptors(ComponentModel model, InterceptorReference[] interceptors);
}
public class Castle.MicroKernel.Proxy.NotSupportedProxyFactory : object {
    public sealed virtual void AddInterceptorSelector(IModelInterceptorsSelector selector);
    public sealed virtual object Create(IKernel kernel, object instance, ComponentModel mode, CreationContext context, Object[] constructorArguments);
    public sealed virtual object Create(IProxyFactoryExtension customFactory, IKernel kernel, ComponentModel model, CreationContext context, Object[] constructorArguments);
    public sealed virtual bool RequiresTargetInstance(IKernel kernel, ComponentModel model);
    public sealed virtual bool ShouldCreateProxy(ComponentModel model);
}
public abstract class Castle.MicroKernel.Proxy.ProxyConstants : object {
    public static string ProxyOptionsKey;
    private static ProxyConstants();
}
public class Castle.MicroKernel.Proxy.ProxyOptions : object {
    private IReference`1<IProxyGenerationHook> hook;
    private List`1<Type> interfaceList;
    private List`1<IReference`1<object>> mixInList;
    private IReference`1<IInterceptorSelector> selector;
    private ComponentModel component;
    [CompilerGeneratedAttribute]
private bool <AllowChangeTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitTarget>k__BackingField;
    public Type[] AdditionalInterfaces { get; }
    public bool AllowChangeTarget { get; public set; }
    public IReference`1<IProxyGenerationHook> Hook { get; public set; }
    public IEnumerable`1<IReference`1<object>> MixIns { get; }
    public bool OmitTarget { get; public set; }
    public IReference`1<IInterceptorSelector> Selector { get; public set; }
    public bool RequiresProxy { get; }
    public ProxyOptions(ComponentModel component);
    public Type[] get_AdditionalInterfaces();
    [CompilerGeneratedAttribute]
public bool get_AllowChangeTarget();
    [CompilerGeneratedAttribute]
public void set_AllowChangeTarget(bool value);
    public IReference`1<IProxyGenerationHook> get_Hook();
    public void set_Hook(IReference`1<IProxyGenerationHook> value);
    public IEnumerable`1<IReference`1<object>> get_MixIns();
    [CompilerGeneratedAttribute]
public bool get_OmitTarget();
    [CompilerGeneratedAttribute]
public void set_OmitTarget(bool value);
    public IReference`1<IInterceptorSelector> get_Selector();
    public void set_Selector(IReference`1<IInterceptorSelector> value);
    public void AddAdditionalInterfaces(Type[] interfaces);
    public void AddMixIns(Object[] mixIns);
    public void AddMixinReference(IReference`1<object> mixIn);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool AdditionalInterfacesAreEquals(ProxyOptions proxyOptions);
    public bool get_RequiresProxy();
    private int GetCollectionHashCode(IEnumerable items);
    private bool MixInsAreEquals(ProxyOptions proxyOptions);
    private void SetReferenceValue(IReference`1& reference, IReference`1<T> value);
}
[ExtensionAttribute]
public static class Castle.MicroKernel.Proxy.ProxyOptionsUtil : object {
    [ExtensionAttribute]
public static ProxyOptions ObtainProxyOptions(ComponentModel model, bool createOnDemand);
}
public class Castle.MicroKernel.Registration.AssemblyFilter : object {
    private static Assembly CastleWindsorDll;
    private string directoryName;
    private string mask;
    private Predicate`1<Assembly> assemblyFilter;
    private Predicate`1<AssemblyName> nameFilter;
    public AssemblyFilter(string directoryName, string mask);
    private static AssemblyFilter();
    public AssemblyFilter FilterByAssembly(Predicate`1<Assembly> filter);
    public AssemblyFilter FilterByName(Predicate`1<AssemblyName> filter);
    public AssemblyFilter WithKeyToken(string publicKeyToken);
    public AssemblyFilter WithKeyToken(Byte[] publicKeyToken);
    public AssemblyFilter WithKeyToken(Type typeFromAssemblySignedWithKey);
    public AssemblyFilter WithKeyToken();
    public AssemblyFilter WithKeyToken(Assembly assembly);
    private Byte[] ExtractKeyToken(string keyToken);
    private IEnumerable`1<string> GetFiles();
    private Assembly LoadAssemblyIgnoringErrors(string file);
    [IteratorStateMachineAttribute("Castle.MicroKernel.Registration.AssemblyFilter/<Castle-Core-Internal-IAssemblyProvider-GetAssemblies>d__16")]
private sealed virtual override IEnumerable`1<Assembly> Castle.Core.Internal.IAssemblyProvider.GetAssemblies();
    private static string GetFullPath(string path);
    private static bool IsTokenEqual(Byte[] actualToken, Byte[] expectedToken);
}
public class Castle.MicroKernel.Registration.Attrib : Node {
    private string value;
    internal Attrib(string name, string value);
    public virtual void ApplyTo(IConfiguration configuration);
    public static NamedAttribute ForName(string name);
}
public class Castle.MicroKernel.Registration.BasedOnDescriptor : object {
    private List`1<Type> potentialBases;
    private Action`1<ComponentRegistration> configuration;
    private FromDescriptor from;
    private ServiceDescriptor service;
    private Predicate`1<Type> ifFilter;
    private Predicate`1<Type> unlessFilter;
    public ServiceDescriptor WithService { get; }
    internal BasedOnDescriptor(IEnumerable`1<Type> basedOn, FromDescriptor from, Predicate`1<Type> additionalFilters);
    public ServiceDescriptor get_WithService();
    public FromDescriptor AllowMultipleMatches();
    public BasedOnDescriptor OrBasedOn(Type basedOn);
    public BasedOnDescriptor Configure(Action`1<ComponentRegistration> configurer);
    public BasedOnDescriptor ConfigureFor(Action`1<ComponentRegistration> configurer);
    public BasedOnDescriptor ConfigureIf(Predicate`1<ComponentRegistration> condition, Action`1<ComponentRegistration> configurer);
    public BasedOnDescriptor ConfigureIf(Predicate`1<ComponentRegistration> condition, Action`1<ComponentRegistration> configurerWhenTrue, Action`1<ComponentRegistration> configurerWhenFalse);
    public BasedOnDescriptor If(Predicate`1<Type> ifFilter);
    public BasedOnDescriptor Unless(Predicate`1<Type> unlessFilter);
    public BasedOnDescriptor WithServiceAllInterfaces();
    public BasedOnDescriptor WithServiceBase();
    public BasedOnDescriptor WithServiceDefaultInterfaces();
    public BasedOnDescriptor WithServiceFirstInterface();
    public BasedOnDescriptor WithServiceFromInterface(Type implements);
    public BasedOnDescriptor WithServiceFromInterface();
    public BasedOnDescriptor WithServiceSelect(ServiceSelector selector);
    public BasedOnDescriptor WithServiceSelf();
    public BasedOnDescriptor LifestyleCustom(Type customLifestyleType);
    public BasedOnDescriptor LifestyleCustom();
    public BasedOnDescriptor LifestylePerThread();
    public BasedOnDescriptor LifestyleScoped();
    public BasedOnDescriptor LifestyleScoped(Type scopeAccessorType);
    public BasedOnDescriptor LifestyleScoped();
    public BasedOnDescriptor LifestyleBoundTo();
    public BasedOnDescriptor LifestyleBoundToNearest();
    public BasedOnDescriptor LifestylePooled(Nullable`1<int> initialSize, Nullable`1<int> maxSize);
    public BasedOnDescriptor LifestyleSingleton();
    public BasedOnDescriptor LifestyleTransient();
    public BasedOnDescriptor WithServices(IEnumerable`1<Type> types);
    public BasedOnDescriptor WithServices(Type[] types);
    protected virtual bool Accepts(Type type, Type[]& baseTypes);
    protected bool ExecuteIfCondition(Type type);
    protected bool ExecuteUnlessCondition(Type type);
    protected bool IsBasedOn(Type type, Type[]& baseTypes);
    internal bool TryRegister(Type type, IKernel kernel);
    private static bool IsBasedOnGenericClass(Type type, Type basedOn, Type[]& baseTypes);
    private static bool IsBasedOnGenericInterface(Type type, Type basedOn, Type[]& baseTypes);
    private sealed virtual override void Castle.MicroKernel.Registration.IRegistration.Register(IKernelInternal kernel);
}
public abstract class Castle.MicroKernel.Registration.Child : object {
    public static NamedChild ForName(string name);
}
public static class Castle.MicroKernel.Registration.Classes : object {
    public static FromTypesDescriptor From(IEnumerable`1<Type> types);
    public static FromTypesDescriptor From(Type[] types);
    public static FromAssemblyDescriptor FromAssembly(Assembly assembly);
    public static FromAssemblyDescriptor FromAssemblyContaining(Type type);
    public static FromAssemblyDescriptor FromAssemblyContaining();
    public static FromAssemblyDescriptor FromAssemblyInDirectory(AssemblyFilter filter);
    public static FromAssemblyDescriptor FromAssemblyInThisApplication();
    public static FromAssemblyDescriptor FromAssemblyInThisApplication(Assembly rootAssembly);
    public static FromAssemblyDescriptor FromAssemblyNamed(string assemblyName);
    public static FromAssemblyDescriptor FromThisAssembly();
    [EditorBrowsableAttribute("1")]
internal static bool Filter(Type type);
}
public class Castle.MicroKernel.Registration.ComplexChild : Node {
    private IConfiguration configNode;
    internal ComplexChild(string name, IConfiguration configNode);
    public virtual void ApplyTo(IConfiguration configuration);
}
public static class Castle.MicroKernel.Registration.Component : object {
    public static ComponentRegistration For(Type serviceType);
    public static ComponentRegistration For(Type[] serviceTypes);
    public static ComponentRegistration For(IEnumerable`1<Type> serviceTypes);
    public static ComponentRegistration`1<TService> For();
    public static ComponentRegistration`1<TService1> For();
    public static ComponentRegistration`1<TService1> For();
    public static ComponentRegistration`1<TService1> For();
    public static ComponentRegistration`1<TService1> For();
    public static bool HasAttribute(Type type);
    public static Predicate`1<Type> HasAttribute(Predicate`1<TAttribute> filter);
    public static bool IsCastleComponent(Type type);
    public static Predicate`1<Type> IsInNamespace(string namespace);
    public static Predicate`1<Type> IsInNamespace(string namespace, bool includeSubnamespaces);
    public static Predicate`1<Type> IsInSameNamespaceAs(Type type);
    public static Predicate`1<Type> IsInSameNamespaceAs(Type type, bool includeSubnamespaces);
    public static Predicate`1<Type> IsInSameNamespaceAs();
    public static Predicate`1<Type> IsInSameNamespaceAs(bool includeSubnamespaces);
}
public class Castle.MicroKernel.Registration.ComponentRegistration : ComponentRegistration`1<object> {
    public ComponentRegistration(Type[] serviceTypes);
}
public class Castle.MicroKernel.Registration.ComponentRegistration`1 : object {
    private List`1<IComponentModelDescriptor> descriptors;
    private List`1<Type> potentialServices;
    private HashSet`1<Type> potentialServicesLookup;
    private bool ifComponentRegisteredIgnore;
    private Type implementation;
    private ComponentName name;
    private bool overwrite;
    private bool registerNewServicesOnly;
    private bool registered;
    public Type Implementation { get; }
    [EditorBrowsableAttribute("2")]
public LifestyleGroup`1<TService> LifeStyle { get; }
    public string Name { get; }
    public ProxyGroup`1<TService> Proxy { get; }
    protected internal IList`1<Type> Services { get; }
    protected internal int ServicesCount { get; }
    internal bool IsOverWrite { get; }
    public ComponentRegistration`1(Type[] services);
    public Type get_Implementation();
    public LifestyleGroup`1<TService> get_LifeStyle();
    public string get_Name();
    public ProxyGroup`1<TService> get_Proxy();
    protected internal IList`1<Type> get_Services();
    protected internal int get_ServicesCount();
    internal bool get_IsOverWrite();
    public ComponentRegistration`1<TService> Activator();
    public ComponentRegistration`1<TService> AddAttributeDescriptor(string key, string value);
    public ComponentRegistration`1<TService> AddDescriptor(IComponentModelDescriptor descriptor);
    public AttributeKeyDescriptor`1<TService> Attribute(string key);
    public ComponentRegistration`1<TService> Configuration(Node[] configNodes);
    public ComponentRegistration`1<TService> Configuration(IConfiguration configuration);
    public ComponentRegistration`1<TService> DependsOn(Dependency dependency);
    public ComponentRegistration`1<TService> DependsOn(Dependency[] dependencies);
    public ComponentRegistration`1<TService> DependsOn(Arguments dependencies);
    public ComponentRegistration`1<TService> DependsOn(IDictionary dependencies);
    public ComponentRegistration`1<TService> DependsOn(object dependenciesAsAnonymousType);
    public ComponentRegistration`1<TService> DependsOn(DynamicParametersDelegate resolve);
    public ComponentRegistration`1<TService> DependsOn(DynamicParametersResolveDelegate resolve);
    public ComponentRegistration`1<TService> DependsOn(DynamicParametersWithContextResolveDelegate resolve);
    public ComponentRegistration`1<TService> DynamicParameters(DynamicParametersDelegate resolve);
    public ComponentRegistration`1<TService> DynamicParameters(DynamicParametersResolveDelegate resolve);
    public ComponentRegistration`1<TService> DynamicParameters(DynamicParametersWithContextResolveDelegate resolve);
    public ComponentRegistration`1<TService> ExtendedProperties(Property[] properties);
    public ComponentRegistration`1<TService> ExtendedProperties(Property property);
    public ComponentRegistration`1<TService> ExtendedProperties(object anonymous);
    public ComponentRegistration`1<TService> Forward(Type[] types);
    public ComponentRegistration`1<TService> Forward();
    public ComponentRegistration`1<TService> Forward();
    public ComponentRegistration`1<TService> Forward();
    public ComponentRegistration`1<TService> Forward();
    public ComponentRegistration`1<TService> Forward(IEnumerable`1<Type> types);
    public ComponentRegistration`1<TService> ImplementedBy();
    public ComponentRegistration`1<TService> ImplementedBy(Type type);
    public ComponentRegistration`1<TService> ImplementedBy(Type type, IGenericImplementationMatchingStrategy genericImplementationMatchingStrategy);
    public ComponentRegistration`1<TService> ImplementedBy(Type type, IGenericServiceStrategy genericServiceStrategy);
    public ComponentRegistration`1<TService> ImplementedBy(Type type, IGenericImplementationMatchingStrategy genericImplementationMatchingStrategy, IGenericServiceStrategy genericServiceStrategy);
    public ComponentRegistration`1<TService> Instance(TService instance);
    public InterceptorGroup`1<TService> Interceptors(InterceptorReference[] interceptors);
    public ComponentRegistration`1<TService> Interceptors(Type[] interceptors);
    public ComponentRegistration`1<TService> Interceptors();
    public ComponentRegistration`1<TService> Interceptors();
    public ComponentRegistration`1<TService> Interceptors(String[] keys);
    public ComponentRegistration`1<TService> LifestyleCustom(Type customLifestyleType);
    public ComponentRegistration`1<TService> LifestyleCustom();
    public ComponentRegistration`1<TService> LifestylePerThread();
    public ComponentRegistration`1<TService> LifestyleScoped(Type scopeAccessorType);
    public ComponentRegistration`1<TService> LifestyleScoped();
    public ComponentRegistration`1<TService> LifestyleBoundTo();
    public ComponentRegistration`1<TService> LifestyleBoundToNearest();
    public ComponentRegistration`1<TService> LifestyleBoundTo(Func`2<IHandler[], IHandler> scopeRootBinder);
    public ComponentRegistration`1<TService> LifestylePooled(Nullable`1<int> initialSize, Nullable`1<int> maxSize);
    public ComponentRegistration`1<TService> LifestyleSingleton();
    public ComponentRegistration`1<TService> LifestyleTransient();
    public ComponentRegistration`1<TService> Named(string name);
    public ComponentRegistration`1<TService> NamedAutomatically(string name);
    public ComponentRegistration`1<TService> OnCreate(Action`1[] actions);
    public ComponentRegistration`1<TService> OnCreate(LifecycleActionDelegate`1[] actions);
    public ComponentRegistration`1<TService> OnDestroy(Action`1[] actions);
    public ComponentRegistration`1<TService> OnDestroy(LifecycleActionDelegate`1[] actions);
    public ComponentRegistration`1<TService> OnlyNewServices();
    [EditorBrowsableAttribute("1")]
public ComponentRegistration`1<TService> OverWrite();
    public ComponentRegistration`1<TService> SelectInterceptorsWith(IInterceptorSelector selector);
    public ComponentRegistration`1<TService> SelectInterceptorsWith(Action`1<ItemRegistration`1<IInterceptorSelector>> selector);
    public ComponentRegistration`1<TService> UsingFactory(Func`2<TFactory, TServiceImpl> factory);
    public ComponentRegistration`1<TService> UsingFactoryMethod(Func`1<TImpl> factoryMethod, bool managedExternally);
    public ComponentRegistration`1<TService> UsingFactoryMethod(Func`2<IKernel, TImpl> factoryMethod, bool managedExternally);
    public ComponentRegistration`1<TService> UsingFactoryMethod(Func`4<IKernel, ComponentModel, CreationContext, TImpl> factoryMethod, bool managedExternally);
    public ComponentRegistration`1<TService> UsingFactoryMethod(Func`3<IKernel, CreationContext, TImpl> factoryMethod);
    internal void RegisterOptionally();
    private Type[] FilterServices(IKernel kernel);
    private IComponentModelDescriptor[] GetContributors(Type[] services);
    private bool SkipRegistration(IKernelInternal internalKernel, ComponentModel componentModel);
    private sealed virtual override void Castle.MicroKernel.Registration.IRegistration.Register(IKernelInternal kernel);
    public ComponentRegistration`1<TService> IsDefault(Predicate`1<Type> serviceFilter);
    public ComponentRegistration`1<TService> IsDefault();
    public ComponentRegistration`1<TService> IsFallback(Predicate`1<Type> serviceFilter);
    public ComponentRegistration`1<TService> IsFallback();
    public ComponentRegistration`1<TService> PropertiesIgnore(Func`2<PropertyInfo, bool> propertySelector);
    public ComponentRegistration`1<TService> PropertiesRequire(Func`2<PropertyInfo, bool> propertySelector);
    public ComponentRegistration`1<TService> PropertiesIgnore(Func`3<ComponentModel, PropertyInfo, bool> propertySelector);
    public ComponentRegistration`1<TService> PropertiesRequire(Func`3<ComponentModel, PropertyInfo, bool> propertySelector);
    public ComponentRegistration`1<TService> Properties(PropertyFilter filter);
}
public class Castle.MicroKernel.Registration.CompoundChild : Node {
    private Node[] childNodes;
    internal CompoundChild(string name, Node[] childNodes);
    public virtual void ApplyTo(IConfiguration configuration);
}
public class Castle.MicroKernel.Registration.Dependency : object {
    private object item;
    internal Dependency(object item);
    public static Parameter OnConfigValue(string dependencyName, string valueAsString);
    public static Parameter OnConfigValue(string dependencyName, IConfiguration value);
    public static ServiceOverride OnComponent(string dependencyName, string componentName);
    public static ServiceOverride OnComponent(Type dependencyType, string componentName);
    public static ServiceOverride OnComponent(string dependencyName, Type componentType);
    public static ServiceOverride OnComponent(Type dependencyType, Type componentType);
    public static ServiceOverride OnComponent();
    public static ServiceOverride OnComponentCollection(string collectionDependencyName, String[] componentNames);
    public static ServiceOverride OnComponentCollection(Type collectionDependencyType, String[] componentNames);
    public static ServiceOverride OnComponentCollection(String[] componentNames);
    public static ServiceOverride OnComponentCollection(string collectionDependencyName, Type[] componentTypes);
    public static ServiceOverride OnComponentCollection(Type collectionDependencyType, Type[] componentTypes);
    public static ServiceOverride OnComponentCollection(Type[] componentTypes);
    public static Property OnValue(string dependencyName, object value);
    public static Property OnValue(Type dependencyType, object value);
    public static Property OnValue(object value);
    internal bool Accept(ICollection`1<TItem> items);
    public static Property OnResource(string dependencyName, string resourceName);
    public static Property OnResource(string dependencyName, ResourceManager resourceManager, string resourceName);
}
public class Castle.MicroKernel.Registration.DynamicParametersDelegate : MulticastDelegate {
    public DynamicParametersDelegate(object object, IntPtr method);
    public virtual void Invoke(IKernel kernel, Arguments arguments);
    public virtual IAsyncResult BeginInvoke(IKernel kernel, Arguments arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.Registration.DynamicParametersResolveDelegate : MulticastDelegate {
    public DynamicParametersResolveDelegate(object object, IntPtr method);
    public virtual ComponentReleasingDelegate Invoke(IKernel kernel, Arguments arguments);
    public virtual IAsyncResult BeginInvoke(IKernel kernel, Arguments arguments, AsyncCallback callback, object object);
    public virtual ComponentReleasingDelegate EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.Registration.DynamicParametersWithContextResolveDelegate : MulticastDelegate {
    public DynamicParametersWithContextResolveDelegate(object object, IntPtr method);
    public virtual ComponentReleasingDelegate Invoke(IKernel kernel, CreationContext creationContext, Arguments arguments);
    public virtual IAsyncResult BeginInvoke(IKernel kernel, CreationContext creationContext, Arguments arguments, AsyncCallback callback, object object);
    public virtual ComponentReleasingDelegate EndInvoke(IAsyncResult result);
}
public class Castle.MicroKernel.Registration.FromAssemblyDescriptor : FromDescriptor {
    protected IEnumerable`1<Assembly> assemblies;
    protected bool nonPublicTypes;
    protected internal FromAssemblyDescriptor(Assembly assembly, Predicate`1<Type> additionalFilters);
    protected internal FromAssemblyDescriptor(IEnumerable`1<Assembly> assemblies, Predicate`1<Type> additionalFilters);
    public FromAssemblyDescriptor IncludeNonPublicTypes();
    protected virtual IEnumerable`1<Type> SelectedTypes(IKernel kernel);
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <SelectedTypes>b__5_0(Assembly a);
}
public abstract class Castle.MicroKernel.Registration.FromDescriptor : object {
    private Predicate`1<Type> additionalFilters;
    private IList`1<BasedOnDescriptor> criterias;
    private bool allowMultipleMatches;
    protected FromDescriptor(Predicate`1<Type> additionalFilters);
    protected abstract virtual IEnumerable`1<Type> SelectedTypes(IKernel kernel);
    public FromDescriptor AllowMultipleMatches();
    public BasedOnDescriptor BasedOn();
    public BasedOnDescriptor BasedOn(Type basedOn);
    public BasedOnDescriptor BasedOn(Type[] basedOn);
    public BasedOnDescriptor BasedOn(IEnumerable`1<Type> basedOn);
    public BasedOnDescriptor InNamespace(string namespace);
    public BasedOnDescriptor InNamespace(string namespace, bool includeSubnamespaces);
    public BasedOnDescriptor InSameNamespaceAs(Type type);
    public BasedOnDescriptor InSameNamespaceAs(Type type, bool includeSubnamespaces);
    public BasedOnDescriptor InSameNamespaceAs();
    public BasedOnDescriptor InSameNamespaceAs(bool includeSubnamespaces);
    public BasedOnDescriptor Pick();
    public BasedOnDescriptor Where(Predicate`1<Type> accepted);
    private sealed virtual override void Castle.MicroKernel.Registration.IRegistration.Register(IKernelInternal kernel);
}
public class Castle.MicroKernel.Registration.FromTypesDescriptor : FromDescriptor {
    private IEnumerable`1<Type> types;
    internal FromTypesDescriptor(IEnumerable`1<Type> types, Predicate`1<Type> additionalFilters);
    protected virtual IEnumerable`1<Type> SelectedTypes(IKernel kernel);
}
public class Castle.MicroKernel.Registration.Interceptor.InterceptorGroup`1 : RegistrationGroup`1<S> {
    private InterceptorReference[] interceptors;
    public ComponentRegistration`1<S> Anywhere { get; }
    public ComponentRegistration`1<S> First { get; }
    public ComponentRegistration`1<S> Last { get; }
    public InterceptorGroup`1(ComponentRegistration`1<S> registration, InterceptorReference[] interceptors);
    public ComponentRegistration`1<S> get_Anywhere();
    public ComponentRegistration`1<S> get_First();
    public ComponentRegistration`1<S> get_Last();
    public ComponentRegistration`1<S> AtIndex(int index);
    public InterceptorGroup`1<S> SelectedWith(IInterceptorSelector selector);
}
public interface Castle.MicroKernel.Registration.IRegistration {
    public abstract virtual void Register(IKernelInternal kernel);
}
public interface Castle.MicroKernel.Registration.IWindsorInstaller {
    public abstract virtual void Install(IWindsorContainer container, IConfigurationStore store);
}
public class Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1 : RegistrationGroup`1<TService> {
    public ComponentRegistration`1<TService> Transient { get; }
    public ComponentRegistration`1<TService> Singleton { get; }
    public ComponentRegistration`1<TService> PerThread { get; }
    public ComponentRegistration`1<TService> Pooled { get; }
    public LifestyleGroup`1(ComponentRegistration`1<TService> registration);
    public ComponentRegistration`1<TService> Is(LifestyleType type);
    private ArgumentOutOfRangeException InvalidValue(LifestyleType type, string message);
    public ComponentRegistration`1<TService> get_Transient();
    public ComponentRegistration`1<TService> get_Singleton();
    public ComponentRegistration`1<TService> get_PerThread();
    public ComponentRegistration`1<TService> get_Pooled();
    public ComponentRegistration`1<TService> PooledWithSize(Nullable`1<int> initialSize, Nullable`1<int> maxSize);
    public ComponentRegistration`1<TService> Scoped();
    public ComponentRegistration`1<TService> Scoped(Type scopeAccessorType);
    public ComponentRegistration`1<TService> Scoped();
    public ComponentRegistration`1<TService> BoundTo();
    public ComponentRegistration`1<TService> BoundToNearest();
    public ComponentRegistration`1<TService> BoundTo(Func`2<IHandler[], IHandler> scopeRootBinder);
    public ComponentRegistration`1<TService> Custom(Type customLifestyleType);
    public ComponentRegistration`1<TService> Custom();
}
public class Castle.MicroKernel.Registration.NamedAttribute : object {
    private string name;
    internal NamedAttribute(string name);
    public Attrib Eq(string value);
    public Attrib Eq(object value);
}
public class Castle.MicroKernel.Registration.NamedChild : Node {
    internal NamedChild(string name);
    public virtual void ApplyTo(IConfiguration configuration);
    public SimpleChild Eq(string value);
    public SimpleChild Eq(object value);
    public ComplexChild Eq(IConfiguration configNode);
    public CompoundChild Eq(Node[] childNodes);
}
public abstract class Castle.MicroKernel.Registration.Node : object {
    private string name;
    protected string Name { get; }
    protected Node(string name);
    protected string get_Name();
    public abstract virtual void ApplyTo(IConfiguration configuration);
}
public class Castle.MicroKernel.Registration.Parameter : object {
    private string key;
    private object value;
    public IConfiguration ConfigNode { get; }
    public string Key { get; }
    public string Value { get; }
    internal Parameter(string key, string value);
    internal Parameter(string key, IConfiguration configNode);
    public IConfiguration get_ConfigNode();
    public string get_Key();
    public string get_Value();
    public static ParameterKey ForKey(string key);
    public static Dependency op_Implicit(Parameter parameter);
}
public class Castle.MicroKernel.Registration.ParameterKey : object {
    private string name;
    public string Name { get; }
    internal ParameterKey(string name);
    public string get_Name();
    public Parameter Eq(string value);
    public Parameter Eq(IConfiguration configNode);
}
public class Castle.MicroKernel.Registration.Property : object {
    private object key;
    private object value;
    public object Key { get; }
    public object Value { get; }
    public Property(object key, object value);
    public object get_Key();
    public object get_Value();
    public static PropertyKey ForKey(string key);
    public static PropertyKey ForKey(Type key);
    public static PropertyKey ForKey();
    public static Dependency op_Implicit(Property item);
}
public class Castle.MicroKernel.Registration.PropertyKey : object {
    private object key;
    public object Key { get; }
    internal PropertyKey(object key);
    public object get_Key();
    public Property Eq(object value);
    public ServiceOverride Is(string componentName);
    public ServiceOverride Is(Type componentImplementation);
    public ServiceOverride Is();
    private ServiceOverrideKey GetServiceOverrideKey();
}
public class Castle.MicroKernel.Registration.Proxy.ItemRegistration`1 : object {
    private IReference`1<TItem> item;
    internal IReference`1<TItem> Item { get; }
    internal IReference`1<TItem> get_Item();
    public ItemRegistration`1<TItem> Instance(TItem instance);
    public ItemRegistration`1<TItem> Service();
    public ItemRegistration`1<TItem> Service(Type serviceType);
    public ItemRegistration`1<TItem> Service(string name);
}
public class Castle.MicroKernel.Registration.Proxy.MixinRegistration : object {
    private IList`1<IReference`1<object>> items;
    public MixinRegistration Component();
    public MixinRegistration Component(Type serviceType);
    public MixinRegistration Component(string name);
    public MixinRegistration Objects(Object[] objects);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<IReference`1<object>> System.Collections.Generic.IEnumerable<Castle.MicroKernel.IReference<System.Object>>.GetEnumerator();
}
public class Castle.MicroKernel.Registration.Proxy.ProxyGroup`1 : RegistrationGroup`1<S> {
    public ComponentRegistration`1<S> AsMarshalByRefClass { get; }
    public ProxyGroup`1(ComponentRegistration`1<S> registration);
    public ComponentRegistration`1<S> get_AsMarshalByRefClass();
    public ComponentRegistration`1<S> AdditionalInterfaces(Type[] interfaces);
    public ComponentRegistration`1<S> Hook(IProxyGenerationHook hook);
    public ComponentRegistration`1<S> Hook(Action`1<ItemRegistration`1<IProxyGenerationHook>> hookRegistration);
    public ComponentRegistration`1<S> MixIns(Object[] mixIns);
    public ComponentRegistration`1<S> MixIns(Action`1<MixinRegistration> mixinRegistration);
}
public abstract class Castle.MicroKernel.Registration.RegistrationGroup`1 : object {
    private ComponentRegistration`1<S> registration;
    public ComponentRegistration`1<S> Registration { get; }
    public RegistrationGroup`1(ComponentRegistration`1<S> registration);
    public ComponentRegistration`1<S> get_Registration();
    protected ComponentRegistration`1<S> AddAttributeDescriptor(string name, string value);
    protected ComponentRegistration`1<S> AddDescriptor(IComponentModelDescriptor descriptor);
}
public class Castle.MicroKernel.Registration.ServiceDescriptor : object {
    private BasedOnDescriptor basedOnDescriptor;
    private ServiceSelector serviceSelector;
    internal ServiceDescriptor(BasedOnDescriptor basedOnDescriptor);
    public BasedOnDescriptor AllInterfaces();
    public BasedOnDescriptor Base();
    public BasedOnDescriptor DefaultInterfaces();
    public BasedOnDescriptor FirstInterface();
    public BasedOnDescriptor FromInterface(Type implements);
    public BasedOnDescriptor FromInterface();
    public BasedOnDescriptor Select(ServiceSelector selector);
    public BasedOnDescriptor Select(IEnumerable`1<Type> types);
    public BasedOnDescriptor Self();
    internal ICollection`1<Type> GetServices(Type type, Type[] baseType);
    private void AddFromInterface(Type type, Type implements, ICollection`1<Type> matches);
    private string GetInterfaceName(Type interface);
    private IEnumerable`1<Type> GetTopLevelInterfaces(Type type);
    private static Type WorkaroundCLRBug(Type serviceType);
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <DefaultInterfaces>b__5_0(Type type, Type[] base);
}
public class Castle.MicroKernel.Registration.ServiceOverride : object {
    [CompilerGeneratedAttribute]
private object <DependencyKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object DependencyKey { get; private set; }
    public Type Type { get; private set; }
    public object Value { get; private set; }
    internal ServiceOverride(object dependencyKey, object value);
    internal ServiceOverride(object dependencyKey, object value, Type type);
    [CompilerGeneratedAttribute]
public object get_DependencyKey();
    [CompilerGeneratedAttribute]
private void set_DependencyKey(object value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public static ServiceOverrideKey ForKey(string key);
    public static ServiceOverrideKey ForKey(Type key);
    public static ServiceOverrideKey ForKey();
    public static Dependency op_Implicit(ServiceOverride item);
}
public class Castle.MicroKernel.Registration.ServiceOverrideKey : object {
    private object key;
    internal ServiceOverrideKey(string key);
    internal ServiceOverrideKey(Type key);
    public ServiceOverride Eq(string value);
    public ServiceOverride Eq(String[] value);
    public ServiceOverride Eq(String[] value);
    public ServiceOverride Eq(IEnumerable`1<string> value);
    public ServiceOverride Eq(IEnumerable`1<string> value);
    public ServiceOverride Eq(Type[] componentTypes);
    public ServiceOverride Eq(Type[] componentTypes);
}
public class Castle.MicroKernel.Registration.SimpleChild : Node {
    private string value;
    internal SimpleChild(string name, string value);
    public virtual void ApplyTo(IConfiguration configuration);
}
public static class Castle.MicroKernel.Registration.Types : object {
    public static FromTypesDescriptor From(IEnumerable`1<Type> types);
    public static FromTypesDescriptor From(Type[] types);
    public static FromAssemblyDescriptor FromAssembly(Assembly assembly);
    public static FromAssemblyDescriptor FromAssemblyContaining(Type type);
    public static FromAssemblyDescriptor FromAssemblyContaining();
    public static FromAssemblyDescriptor FromAssemblyInDirectory(AssemblyFilter filter);
    public static FromAssemblyDescriptor FromAssemblyInThisApplication();
    public static FromAssemblyDescriptor FromAssemblyInThisApplication(Assembly rootAssembly);
    public static FromAssemblyDescriptor FromAssemblyNamed(string assemblyName);
    public static FromAssemblyDescriptor FromThisAssembly();
}
public class Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy : object {
    private Dictionary`2<object, Burden> instance2Burden;
    private Lock lock;
    private ITrackedComponentsPerformanceCounter perfCounter;
    private ITrackedComponentsDiagnostic trackedComponentsDiagnostic;
    private Burden[] TrackedObjects { get; }
    public LifecycledComponentsReleasePolicy(IKernel kernel);
    public LifecycledComponentsReleasePolicy(ITrackedComponentsDiagnostic trackedComponentsDiagnostic, ITrackedComponentsPerformanceCounter trackedComponentsPerformanceCounter);
    private LifecycledComponentsReleasePolicy(LifecycledComponentsReleasePolicy parent);
    private Burden[] get_TrackedObjects();
    public sealed virtual void Dispose();
    public sealed virtual IReleasePolicy CreateSubPolicy();
    public sealed virtual bool HasTrack(object instance);
    public sealed virtual void Release(object instance);
    public virtual void Track(object instance, Burden burden);
    private void OnInstanceReleased(Burden burden);
    private void trackedComponentsDiagnostic_TrackedInstancesRequested(object sender, TrackedInstancesEventArgs e);
    public static ITrackedComponentsDiagnostic GetTrackedComponentsDiagnostic(IKernel kernel);
    [SecuritySafeCriticalAttribute]
public static ITrackedComponentsPerformanceCounter GetTrackedComponentsPerformanceCounter(IPerformanceMetricsFactory perfMetricsFactory);
}
[ObsoleteAttribute("This class is a hack, will be removed in the future release and should be avoided. Please implement proper lifecycle management instead.")]
public class Castle.MicroKernel.Releasers.NoTrackingReleasePolicy : object {
    public sealed virtual void Dispose();
    public sealed virtual IReleasePolicy CreateSubPolicy();
    public sealed virtual bool HasTrack(object instance);
    public sealed virtual void Release(object instance);
    public sealed virtual void Track(object instance, Burden burden);
}
public class Castle.MicroKernel.Resolvers.DefaultDependencyResolver : object {
    private IList`1<ISubDependencyResolver> subResolvers;
    private ITypeConverter converter;
    private DependencyDelegate dependencyResolvingDelegate;
    private IKernelInternal kernel;
    public sealed virtual void AddSubResolver(ISubDependencyResolver subResolver);
    public sealed virtual void Initialize(IKernelInternal kernel, DependencyDelegate dependencyDelegate);
    public sealed virtual void RemoveSubResolver(ISubDependencyResolver subResolver);
    public sealed virtual bool CanResolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    public sealed virtual object Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    protected virtual bool CanResolveFromKernel(CreationContext context, ComponentModel model, DependencyModel dependency);
    protected virtual CreationContext RebuildContextForParameter(CreationContext current, Type parameterType);
    protected virtual object ResolveFromKernel(CreationContext context, ComponentModel model, DependencyModel dependency);
    private bool CanResolveFromContext(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    private bool CanResolveFromContextHandlerResolver(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    private bool CanResolveFromHandler(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    private bool CanResolveFromSubResolvers(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    private bool HasAnyComponentInValidState(Type service, DependencyModel dependency, CreationContext context);
    private void RebuildOpenGenericHandlersWithClosedGenericSubHandlers(Type service, CreationContext context, List`1<IHandler> nonResolvingHandlers);
    private bool HasComponentInValidState(string key, DependencyModel dependency, CreationContext context);
    private bool TryResolveCore(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency, Object& value);
    private object ResolveFromKernelByName(CreationContext context, ComponentModel model, DependencyModel dependency);
    private object ResolveFromKernelByType(CreationContext context, ComponentModel model, DependencyModel dependency);
    private object ResolveFromParameter(CreationContext context, ComponentModel model, DependencyModel dependency);
    private bool TryGetHandlerFromKernel(DependencyModel dependency, CreationContext context, IHandler& handler);
    private static bool IsHandlerInValidState(IHandler handler);
}
public class Castle.MicroKernel.Resolvers.DependencyResolverException : Exception {
    public DependencyResolverException(string message, Exception innerException);
    public DependencyResolverException(string message);
}
public interface Castle.MicroKernel.Resolvers.ILazyComponentLoader {
    public abstract virtual IRegistration Load(string name, Type service, Arguments arguments);
}
[SingletonAttribute]
public class Castle.MicroKernel.Resolvers.LazyOfTComponentLoader : object {
    public sealed virtual IRegistration Load(string name, Type service, Arguments arguments);
}
public class Castle.MicroKernel.Resolvers.SpecializedResolvers.ArrayResolver : CollectionResolver {
    public ArrayResolver(IKernel kernel);
    public ArrayResolver(IKernel kernel, bool allowEmptyArray);
    protected virtual Type GetItemType(Type targetItemType);
}
public class Castle.MicroKernel.Resolvers.SpecializedResolvers.CollectionResolver : object {
    protected bool allowEmptyCollections;
    protected IKernel kernel;
    public CollectionResolver(IKernel kernel, bool allowEmptyCollections);
    public virtual bool CanResolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    public virtual object Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    protected virtual bool CanSatisfy(Type itemType);
    protected virtual Type GetItemType(Type targetItemType);
    protected virtual bool HasParameter(DependencyModel dependency);
}
public class Castle.MicroKernel.Resolvers.SpecializedResolvers.ListResolver : CollectionResolver {
    public ListResolver(IKernel kernel);
    public ListResolver(IKernel kernel, bool allowEmptyList);
    public virtual object Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency);
    protected virtual Type GetItemType(Type targetItemType);
    private Type BuildListType(DependencyModel dependency);
}
public class Castle.MicroKernel.ServiceDelegate : MulticastDelegate {
    public ServiceDelegate(object object, IntPtr method);
    public virtual void Invoke(Type service);
    public virtual IAsyncResult BeginInvoke(Type service, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class Castle.MicroKernel.SubSystemConstants : object {
    public static string ConfigurationStoreKey;
    public static string ConversionManagerKey;
    public static string DiagnosticsKey;
    public static string NamingKey;
    public static string ResourceKey;
    private static SubSystemConstants();
}
public class Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore : AbstractSubSystem {
    private IDictionary`2<string, IConfiguration> childContainers;
    private IDictionary`2<string, IConfiguration> components;
    private IDictionary`2<string, IConfiguration> facilities;
    private ICollection`1<IConfiguration> installers;
    private object syncLock;
    public sealed virtual void AddChildContainerConfiguration(string key, IConfiguration config);
    public sealed virtual void AddComponentConfiguration(string key, IConfiguration config);
    public sealed virtual void AddFacilityConfiguration(string key, IConfiguration config);
    public sealed virtual void AddInstallerConfiguration(IConfiguration config);
    public sealed virtual IConfiguration GetChildContainerConfiguration(string key);
    public sealed virtual IConfiguration GetComponentConfiguration(string key);
    public sealed virtual IConfiguration[] GetComponents();
    public sealed virtual IConfiguration[] GetConfigurationForChildContainers();
    public sealed virtual IConfiguration[] GetFacilities();
    public sealed virtual IConfiguration GetFacilityConfiguration(string key);
    public sealed virtual IConfiguration[] GetInstallers();
    public sealed virtual IResource GetResource(string resourceUri, IResource resource);
    public virtual void Terminate();
}
public interface Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore {
    public abstract virtual void AddChildContainerConfiguration(string name, IConfiguration config);
    public abstract virtual void AddComponentConfiguration(string key, IConfiguration config);
    public abstract virtual void AddFacilityConfiguration(string key, IConfiguration config);
    public abstract virtual void AddInstallerConfiguration(IConfiguration config);
    public abstract virtual IConfiguration GetChildContainerConfiguration(string key);
    public abstract virtual IConfiguration GetComponentConfiguration(string key);
    public abstract virtual IConfiguration[] GetComponents();
    public abstract virtual IConfiguration[] GetConfigurationForChildContainers();
    public abstract virtual IConfiguration[] GetFacilities();
    public abstract virtual IConfiguration GetFacilityConfiguration(string key);
    public abstract virtual IConfiguration[] GetInstallers();
    public abstract virtual IResource GetResource(string resourceUri, IResource resource);
}
public abstract class Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter : object {
    [CompilerGeneratedAttribute]
private ITypeConverterContext <Context>k__BackingField;
    public ITypeConverterContext Context { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ITypeConverterContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Context(ITypeConverterContext value);
    public abstract virtual bool CanHandleType(Type type);
    public abstract virtual object PerformConversion(string value, Type targetType);
    public abstract virtual object PerformConversion(IConfiguration configuration, Type targetType);
    public virtual bool CanHandleType(Type type, IConfiguration configuration);
    public sealed virtual TTarget PerformConversion(string value);
    public sealed virtual TTarget PerformConversion(IConfiguration configuration);
}
public class Castle.MicroKernel.SubSystems.Conversion.ArrayConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
}
public class Castle.MicroKernel.SubSystems.Conversion.AttributeAwareConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
    private ITypeConverter GetConverterInstance(Type type);
    private ITypeConverter TryGetConverterInstance(Type type);
}
public class Castle.MicroKernel.SubSystems.Conversion.ComponentConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type, IConfiguration configuration);
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
}
public class Castle.MicroKernel.SubSystems.Conversion.ComponentModelConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
}
public class Castle.MicroKernel.SubSystems.Conversion.ConverterException : Exception {
    public ConverterException(string message);
    public ConverterException(string message, Exception innerException);
}
[AttributeUsageAttribute("1036")]
public class Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute : Attribute {
    private Type converterType;
    public Type ConverterType { get; }
    public ConvertibleAttribute(Type converterType);
    public Type get_ConverterType();
}
public class Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter : AbstractTypeConverter {
    private IConversionManager conversionManager;
    private IConversionManager ConversionManager { get; }
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
    public virtual object PerformConversion(string value, Type targetType);
    private object CreateInstance(Type type, IConfiguration configuration);
    private Type ObtainImplementation(Type type, IConfiguration configuration);
    private ConstructorInfo ChooseConstructor(Type type);
    private Object[] ConvertConstructorParameters(ConstructorInfo constructor, IConfiguration configuration);
    private void ConvertPropertyValues(object instance, Type type, IConfiguration configuration);
    private object ConvertChildParameter(IConfiguration config, Type type);
    private IConversionManager get_ConversionManager();
    private IConfiguration FindChildIgnoreCase(IConfiguration config, string name);
}
public class Castle.MicroKernel.SubSystems.Conversion.DefaultConversionManager : AbstractSubSystem {
    [ThreadStaticAttribute]
private static Stack`1<Tuple`2<ComponentModel, CreationContext>> slot;
    private IList`1<ITypeConverter> converters;
    private IList`1<ITypeConverter> standAloneConverters;
    public ITypeConverterContext Context { get; public set; }
    private IKernelInternal Castle.MicroKernel.SubSystems.Conversion.ITypeConverterContext.Kernel { get; }
    public ComponentModel CurrentModel { get; }
    public CreationContext CurrentCreationContext { get; }
    public ITypeConverter Composition { get; }
    private Stack`1<Tuple`2<ComponentModel, CreationContext>> CurrentStack { get; }
    protected virtual void InitDefaultConverters();
    public sealed virtual void Add(ITypeConverter converter);
    public sealed virtual ITypeConverterContext get_Context();
    public sealed virtual void set_Context(ITypeConverterContext value);
    public sealed virtual bool CanHandleType(Type type);
    public sealed virtual bool CanHandleType(Type type, IConfiguration configuration);
    public sealed virtual object PerformConversion(string value, Type targetType);
    public sealed virtual object PerformConversion(IConfiguration configuration, Type targetType);
    public sealed virtual TTarget PerformConversion(string value);
    public sealed virtual TTarget PerformConversion(IConfiguration configuration);
    private sealed virtual override IKernelInternal Castle.MicroKernel.SubSystems.Conversion.ITypeConverterContext.get_Kernel();
    public sealed virtual void Push(ComponentModel model, CreationContext context);
    public sealed virtual void Pop();
    public sealed virtual ComponentModel get_CurrentModel();
    public sealed virtual CreationContext get_CurrentCreationContext();
    public sealed virtual ITypeConverter get_Composition();
    private Stack`1<Tuple`2<ComponentModel, CreationContext>> get_CurrentStack();
}
public class Castle.MicroKernel.SubSystems.Conversion.DictionaryConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
}
public class Castle.MicroKernel.SubSystems.Conversion.EnumConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
}
public class Castle.MicroKernel.SubSystems.Conversion.GenericDictionaryConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
}
public class Castle.MicroKernel.SubSystems.Conversion.GenericListConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
}
public interface Castle.MicroKernel.SubSystems.Conversion.IConversionManager {
    public abstract virtual void Add(ITypeConverter converter);
}
public interface Castle.MicroKernel.SubSystems.Conversion.IGenericCollectionConverterHelper {
    public abstract virtual object ConvertConfigurationToCollection(IConfiguration configuration);
}
public interface Castle.MicroKernel.SubSystems.Conversion.IKernelDependentConverter {
}
public interface Castle.MicroKernel.SubSystems.Conversion.ITypeConverter {
    public ITypeConverterContext Context { get; public set; }
    public abstract virtual ITypeConverterContext get_Context();
    public abstract virtual void set_Context(ITypeConverterContext value);
    public abstract virtual bool CanHandleType(Type type);
    public abstract virtual bool CanHandleType(Type type, IConfiguration configuration);
    public abstract virtual object PerformConversion(string value, Type targetType);
    public abstract virtual object PerformConversion(IConfiguration configuration, Type targetType);
    public abstract virtual TTarget PerformConversion(string value);
    public abstract virtual TTarget PerformConversion(IConfiguration configuration);
}
public interface Castle.MicroKernel.SubSystems.Conversion.ITypeConverterContext {
    public ITypeConverter Composition { get; }
    public CreationContext CurrentCreationContext { get; }
    public ComponentModel CurrentModel { get; }
    public IKernelInternal Kernel { get; }
    public abstract virtual ITypeConverter get_Composition();
    public abstract virtual CreationContext get_CurrentCreationContext();
    public abstract virtual ComponentModel get_CurrentModel();
    public abstract virtual IKernelInternal get_Kernel();
    public abstract virtual void Pop();
    public abstract virtual void Push(ComponentModel model, CreationContext context);
}
public interface Castle.MicroKernel.SubSystems.Conversion.ITypeNameParser {
    public abstract virtual TypeName Parse(string name);
}
public class Castle.MicroKernel.SubSystems.Conversion.ListConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
    private Type GetConvertToType(IConfiguration configuration);
}
public class Castle.MicroKernel.SubSystems.Conversion.PrimitiveConverter : AbstractTypeConverter {
    private Type[] types;
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
}
[ExtensionAttribute]
public static class Castle.MicroKernel.SubSystems.Conversion.SubSystemExtensions : object {
    [ExtensionAttribute]
public static IConversionManager GetConversionManager(IKernel kernel);
}
public class Castle.MicroKernel.SubSystems.Conversion.TimeSpanConverter : AbstractTypeConverter {
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
}
public class Castle.MicroKernel.SubSystems.Conversion.TypeName : object {
    private string assemblyQualifiedName;
    private TypeName[] genericTypes;
    private string name;
    private string namespace;
    private string FullName { get; }
    private bool HasGenericParameters { get; }
    private bool HasNamespace { get; }
    private bool IsAssemblyQualified { get; }
    private string Name { get; }
    public TypeName(string namespace, string name, TypeName[] genericTypes);
    public TypeName(string assemblyQualifiedName);
    private string get_FullName();
    private bool get_HasGenericParameters();
    private bool get_HasNamespace();
    private bool get_IsAssemblyQualified();
    private string get_Name();
    public string ExtractAssemblyName();
    public Type GetType(TypeNameConverter converter);
}
public class Castle.MicroKernel.SubSystems.Conversion.TypeNameConverter : AbstractTypeConverter {
    private static Assembly mscorlib;
    private HashSet`1<Assembly> assemblies;
    private IDictionary`2<string, MultiType> fullName2Type;
    private IDictionary`2<string, MultiType> justName2Type;
    private ITypeNameParser parser;
    public TypeNameConverter(ITypeNameParser parser);
    private static TypeNameConverter();
    public virtual bool CanHandleType(Type type);
    public virtual object PerformConversion(string value, Type targetType);
    private Type GetType(string name);
    private bool InitializeAppDomainAssemblies(bool forceLoad);
    protected virtual bool ShouldSkipAssembly(Assembly assembly);
    protected virtual bool ShouldSkipAssembly(AssemblyName assemblyName);
    private void Scan(Assembly assembly);
    private void Insert(IDictionary`2<string, MultiType> collection, string key, Type value);
    private TypeName ParseName(string name);
    public virtual object PerformConversion(IConfiguration configuration, Type targetType);
    public Type GetTypeByFullName(string fullName);
    public Type GetTypeByName(string justName);
    private Type GetUniqueType(string name, IDictionary`2<string, MultiType> map, string description);
    private void EnsureUnique(MultiType type, string value, string missingInformation);
}
public class Castle.MicroKernel.SubSystems.Conversion.TypeNameParser : object {
    public sealed virtual TypeName Parse(string name);
    private TypeName BuildName(string name, TypeName[] genericTypes);
    private int MoveToBeginning(int location, string text);
    private int MoveToEnd(int location, string text);
    private TypeName[] ParseNames(string substring, int count);
}
public class Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem : AbstractSubSystem {
    protected Lock lock;
    protected Dictionary`2<string, IHandler> name2Handler;
    protected Dictionary`2<Type, HandlerWithPriority> service2Handler;
    protected IList`1<IHandlersFilter> filters;
    protected IList`1<IHandlerSelector> selectors;
    private IDictionary`2<Type, IHandler[]> assignableHandlerListsByTypeCache;
    protected IDictionary`2<Type, IHandler[]> handlerListsByTypeCache;
    private Dictionary`2<string, IHandler> handlerByNameCache;
    private Dictionary`2<Type, IHandler> handlerByServiceCache;
    public int ComponentCount { get; }
    protected IDictionary`2<string, IHandler> HandlerByNameCache { get; }
    protected IDictionary`2<Type, IHandler> HandlerByServiceCache { get; }
    public virtual int get_ComponentCount();
    protected IDictionary`2<string, IHandler> get_HandlerByNameCache();
    protected IDictionary`2<Type, IHandler> get_HandlerByServiceCache();
    public sealed virtual void AddHandlerSelector(IHandlerSelector selector);
    public sealed virtual void AddHandlersFilter(IHandlersFilter filter);
    public virtual bool Contains(string name);
    public virtual bool Contains(Type service);
    public virtual IHandler[] GetAllHandlers();
    public virtual IHandler[] GetAssignableHandlers(Type service);
    public virtual IHandler GetHandler(string name);
    public virtual IHandler GetHandler(Type service);
    public virtual IHandler[] GetHandlers(Type service);
    public virtual void Register(IHandler handler);
    protected IHandler[] GetAssignableHandlersNoFiltering(Type service);
    protected virtual IHandler[] GetFiltersOpinion(Type service);
    protected virtual IHandler GetSelectorsOpinion(string name, Type type);
    protected void InvalidateCache();
    private IHandler[] GetHandlersNoLock(Type service);
    private Func`2<Type, HandlerWithPriority> GetServiceSelector(IHandler handler);
    private bool IsDefault(IHandler handler, Type service);
    private bool IsFallback(IHandler handler, Type service);
}
public interface Castle.MicroKernel.SubSystems.Naming.INamingSubSystem {
    public int ComponentCount { get; }
    public abstract virtual int get_ComponentCount();
    public abstract virtual void AddHandlerSelector(IHandlerSelector selector);
    public abstract virtual void AddHandlersFilter(IHandlersFilter filter);
    public abstract virtual bool Contains(string name);
    public abstract virtual bool Contains(Type service);
    public abstract virtual IHandler[] GetAllHandlers();
    public abstract virtual IHandler[] GetAssignableHandlers(Type service);
    public abstract virtual IHandler GetHandler(string name);
    public abstract virtual IHandler GetHandler(Type service);
    public abstract virtual IHandler[] GetHandlers(Type service);
    public abstract virtual void Register(IHandler handler);
}
public class Castle.MicroKernel.SubSystems.Resource.DefaultResourceSubSystem : AbstractSubSystem {
    private List`1<IResourceFactory> resourceFactories;
    public sealed virtual IResource CreateResource(string resource);
    public sealed virtual IResource CreateResource(string resource, string basePath);
    public sealed virtual IResource CreateResource(CustomUri uri);
    public sealed virtual IResource CreateResource(CustomUri uri, string basePath);
    public sealed virtual void RegisterResourceFactory(IResourceFactory resourceFactory);
    protected virtual void InitDefaultResourceFactories();
}
public interface Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem {
    public abstract virtual IResource CreateResource(CustomUri uri);
    public abstract virtual IResource CreateResource(CustomUri uri, string basePath);
    public abstract virtual IResource CreateResource(string resource);
    public abstract virtual IResource CreateResource(string resource, string basePath);
    public abstract virtual void RegisterResourceFactory(IResourceFactory resourceFactory);
}
public abstract class Castle.MicroKernel.Util.ReferenceExpressionUtil : object {
    public static string BuildReference(string value);
    public static string ExtractComponentName(string value);
    public static bool IsReference(string value);
}
public class Castle.MicroKernel.Util.SimpleMethodEqualityComparer : object {
    public sealed virtual bool Equals(MethodInfo x, MethodInfo y);
    public sealed virtual int GetHashCode(MethodInfo obj);
}
public class Castle.MicroKernel.Util.SimpleTypeEqualityComparer : object {
    private static SimpleTypeEqualityComparer instance;
    public static SimpleTypeEqualityComparer Instance { get; }
    private static SimpleTypeEqualityComparer();
    public sealed virtual bool Equals(Type x, Type y);
    public sealed virtual int GetHashCode(Type obj);
    public static SimpleTypeEqualityComparer get_Instance();
}
public interface Castle.Windsor.Configuration.IConfigurationInterpreter {
    public string EnvironmentName { get; public set; }
    public IResource Source { get; }
    public abstract virtual string get_EnvironmentName();
    public abstract virtual void set_EnvironmentName(string value);
    public abstract virtual IResource get_Source();
    public abstract virtual void ProcessResource(IResource resource, IConfigurationStore store, IKernel kernel);
}
public abstract class Castle.Windsor.Configuration.Interpreters.AbstractInterpreter : object {
    protected static string ContainersNodeName;
    protected static string ContainerNodeName;
    protected static string FacilitiesNodeName;
    protected static string FacilityNodeName;
    protected static string ComponentsNodeName;
    protected static string ComponentNodeName;
    protected static string InstallersNodeName;
    protected static string InstallNodeName;
    private IResource source;
    private Stack`1<IResource> resourceStack;
    [CompilerGeneratedAttribute]
private string <EnvironmentName>k__BackingField;
    protected IResource CurrentResource { get; }
    public IResource Source { get; }
    public string EnvironmentName { get; public set; }
    protected AbstractInterpreter(IResource source);
    public AbstractInterpreter(string filename);
    private static AbstractInterpreter();
    public abstract virtual void ProcessResource(IResource resource, IConfigurationStore store, IKernel kernel);
    protected void PushResource(IResource resource);
    protected void PopResource();
    protected IResource get_CurrentResource();
    public sealed virtual IResource get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EnvironmentName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EnvironmentName(string value);
    protected static void AddChildContainerConfig(string name, IConfiguration childContainer, IConfigurationStore store);
    protected static void AddFacilityConfig(string id, IConfiguration facility, IConfigurationStore store);
    protected static void AddComponentConfig(string id, IConfiguration component, IConfigurationStore store);
    protected static void AddInstallerConfig(IConfiguration installer, IConfigurationStore store);
    private static void AssertValidId(string id);
}
public class Castle.Windsor.Configuration.Interpreters.ConfigurationProcessingException : Exception {
    public ConfigurationProcessingException(string message);
    public ConfigurationProcessingException(string message, Exception innerException);
}
public class Castle.Windsor.Configuration.Interpreters.XmlInterpreter : AbstractInterpreter {
    public XmlInterpreter(string filename);
    public XmlInterpreter(IResource source);
    public virtual void ProcessResource(IResource source, IConfigurationStore store, IKernel kernel);
    protected static void Deserialize(XmlNode section, IConfigurationStore store, IConversionManager converter);
    private static void AssertNodeName(XmlNode node, IEquatable`1<string> expectedName);
    private static void DeserializeComponent(XmlNode node, IConfigurationStore store, IConversionManager converter);
    private static void DeserializeComponents(XmlNodeList nodes, IConfigurationStore store, IConversionManager converter);
    private static void DeserializeContainer(XmlNode node, IConfigurationStore store);
    private static void DeserializeContainers(XmlNodeList nodes, IConfigurationStore store);
    private static void DeserializeElement(XmlNode node, IConfigurationStore store, IConversionManager converter);
    private static void DeserializeFacilities(XmlNodeList nodes, IConfigurationStore store, IConversionManager converter);
    private static void DeserializeFacility(XmlNode node, IConfigurationStore store, IConversionManager converter);
    private static void DeserializeInstaller(XmlNode node, IConfigurationStore store);
    private static void DeserializeInstallers(XmlNodeList nodes, IConfigurationStore store);
    private static string GetRequiredAttributeValue(IConfiguration configuration, string attributeName);
    private static void ThrowIfFacilityConfigurationHasIdAttribute(IConfiguration config);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine : object {
    private IXmlNodeProcessor defaultElementProcessor;
    private Regex flagPattern;
    private IDictionary`2<string, bool> flags;
    private IDictionary`2<XmlNodeType, IDictionary`2<string, IXmlNodeProcessor>> nodeProcessors;
    private IDictionary`2<string, XmlElement> properties;
    private Stack`1<IResource> resourceStack;
    private IResourceSubSystem resourceSubSystem;
    public DefaultXmlProcessorEngine(string environmentName);
    public DefaultXmlProcessorEngine(string environmentName, IResourceSubSystem resourceSubSystem);
    public sealed virtual void AddFlag(string flag);
    public sealed virtual void AddNodeProcessor(Type type);
    public sealed virtual void AddProperty(XmlElement content);
    public sealed virtual void DispatchProcessAll(IXmlProcessorNodeList nodeList);
    public sealed virtual void DispatchProcessCurrent(IXmlProcessorNodeList nodeList);
    public sealed virtual XmlElement GetProperty(string key);
    public sealed virtual IResource GetResource(string uri);
    public sealed virtual bool HasFlag(string flag);
    public sealed virtual bool HasProperty(string name);
    public sealed virtual bool HasSpecialProcessor(XmlNode node);
    public sealed virtual void PopResource();
    public sealed virtual void PushResource(IResource resource);
    public sealed virtual void RemoveFlag(string flag);
    private void AddEnvNameAsFlag(string environmentName);
    private string GetCanonicalFlagName(string flag);
    private IXmlNodeProcessor GetProcessor(XmlNode node);
    private void RegisterProcessor(XmlNodeType type, IXmlNodeProcessor processor);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorNodeList : object {
    private IList`1<XmlNode> nodes;
    private int index;
    public int Count { get; }
    public XmlNode Current { get; }
    public int CurrentPosition { get; public set; }
    public bool HasCurrent { get; }
    public DefaultXmlProcessorNodeList(XmlNode node);
    public DefaultXmlProcessorNodeList(IList`1<XmlNode> nodes);
    public DefaultXmlProcessorNodeList(XmlNodeList nodes);
    public sealed virtual int get_Count();
    public sealed virtual XmlNode get_Current();
    public sealed virtual int get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(int value);
    public sealed virtual bool get_HasCurrent();
    public sealed virtual bool MoveNext();
    protected IList`1<XmlNode> CloneNodeList(XmlNodeList nodeList);
}
public abstract class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractStatementElementProcessor : AbstractXmlNodeProcessor {
    private static string DefinedAttrName;
    private static string NotDefinedAttrName;
    private static AbstractStatementElementProcessor();
    protected bool ProcessStatement(XmlElement element, IXmlProcessorEngine engine);
}
public abstract class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractXmlNodeProcessor : object {
    private static XmlNodeType[] acceptNodes;
    public string Name { get; }
    public XmlNodeType[] AcceptNodeTypes { get; }
    private static AbstractXmlNodeProcessor();
    public abstract virtual string get_Name();
    public virtual XmlNodeType[] get_AcceptNodeTypes();
    public abstract virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
    public virtual bool Accept(XmlNode node);
    protected void AppendChild(XmlNode element, XmlNodeList nodes);
    protected void AppendChild(XmlNode element, string text);
    protected void AppendChild(XmlNode element, XmlNode child);
    protected XmlDocumentFragment CreateFragment(XmlNode parentNode);
    protected XmlText CreateText(XmlNode node, string content);
    protected XmlElement GetNodeAsElement(XmlElement element, XmlNode child);
    protected string GetRequiredAttribute(XmlElement element, string attribute);
    protected virtual bool IgnoreNode(XmlNode node);
    protected XmlNode ImportNode(XmlNode targetElement, XmlNode node);
    protected bool IsTextNode(XmlNode node);
    protected void MoveChildNodes(XmlDocumentFragment fragment, XmlElement element);
    protected void RemoveItSelf(XmlNode node);
    protected void ReplaceItself(XmlNode newNode, XmlNode oldNode);
    protected void ReplaceNode(XmlNode element, XmlNode newNode, XmlNode oldNode);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AttributesElementProcessor : AbstractXmlNodeProcessor {
    public string Name { get; }
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
    protected void AppendElementAsAttribute(XmlNode parentElement, XmlElement element);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.ChooseElementProcessor : AbstractStatementElementProcessor {
    private static string OtherwiseElemName;
    private static string WhenElemName;
    public string Name { get; }
    private static ChooseElementProcessor();
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultElementProcessor : AbstractXmlNodeProcessor {
    private static string IncludeAttrName;
    private static IncludeElementProcessor includeProcessor;
    private static DefaultTextNodeProcessor textProcessor;
    public string Name { get; }
    private static DefaultElementProcessor();
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
    private static void ProcessAttributes(XmlElement element, IXmlProcessorEngine engine);
    private static void ProcessIncludeAttribute(XmlElement element, IXmlProcessorEngine engine);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultTextNodeProcessor : AbstractXmlNodeProcessor {
    private static Regex PropertyValidationRegExp;
    private static XmlNodeType[] acceptNodes;
    public XmlNodeType[] AcceptNodeTypes { get; }
    public string Name { get; }
    private static DefaultTextNodeProcessor();
    public virtual XmlNodeType[] get_AcceptNodeTypes();
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
    public void ProcessString(XmlNode node, string value, IXmlProcessorEngine engine);
    private bool IsRequiredProperty(string propRef);
    private void MoveAttributes(XmlElement targetElement, XmlElement srcElement);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefinedProcessingInstructionProcessor : AbstractXmlNodeProcessor {
    private static XmlNodeType[] acceptNodes;
    public XmlNodeType[] AcceptNodeTypes { get; }
    public string Name { get; }
    private static DefinedProcessingInstructionProcessor();
    public virtual XmlNodeType[] get_AcceptNodeTypes();
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefineElementProcessor : AbstractXmlNodeProcessor {
    private static string FlagAttrName;
    public string Name { get; }
    private static DefineElementProcessor();
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
    protected virtual void Process(string flag, IXmlProcessorEngine engine);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.EvalProcessingInstructionProcessor : AbstractXmlNodeProcessor {
    private static XmlNodeType[] acceptNodes;
    public XmlNodeType[] AcceptNodeTypes { get; }
    public string Name { get; }
    private static EvalProcessingInstructionProcessor();
    public virtual XmlNodeType[] get_AcceptNodeTypes();
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.IfElementProcessor : AbstractStatementElementProcessor {
    public string Name { get; }
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.IfProcessingInstructionProcessor : AbstractXmlNodeProcessor {
    private static string ElsePiName;
    private static string ElsifPiName;
    private static string EndPiName;
    private static string IfPiName;
    private static XmlNodeType[] acceptNodes;
    public XmlNodeType[] AcceptNodeTypes { get; }
    public string Name { get; }
    private static IfProcessingInstructionProcessor();
    public virtual XmlNodeType[] get_AcceptNodeTypes();
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
    private void AssertData(XmlProcessingInstruction pi, bool requireData);
    private void ProcessElseElement(XmlProcessingInstruction pi, IXmlProcessorEngine engine, StatementState& state);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.IncludeElementProcessor : AbstractXmlNodeProcessor {
    public string Name { get; }
    public virtual string get_Name();
    public virtual bool Accept(XmlNode node);
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
    public XmlNode ProcessInclude(XmlElement element, string includeUri, IXmlProcessorEngine engine);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.PropertiesElementProcessor : AbstractXmlNodeProcessor {
    public string Name { get; }
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
}
internal enum Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.StatementState : Enum {
    public int value__;
    public static StatementState Init;
    public static StatementState Collect;
    public static StatementState Finished;
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.UndefElementProcessor : DefineElementProcessor {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual void Process(string flag, IXmlProcessorEngine engine);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.UndefProcessingInstructionProcessor : AbstractStatementElementProcessor {
    public XmlNodeType[] AcceptNodeTypes { get; }
    public string Name { get; }
    public virtual XmlNodeType[] get_AcceptNodeTypes();
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.UsingElementProcessor : AbstractXmlNodeProcessor {
    public string Name { get; }
    public virtual string get_Name();
    public virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
}
public interface Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlNodeProcessor {
    public XmlNodeType[] AcceptNodeTypes { get; }
    public string Name { get; }
    public abstract virtual XmlNodeType[] get_AcceptNodeTypes();
    public abstract virtual string get_Name();
    public abstract virtual bool Accept(XmlNode node);
    public abstract virtual void Process(IXmlProcessorNodeList nodeList, IXmlProcessorEngine engine);
}
public interface Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine {
    public abstract virtual void AddFlag(string flag);
    public abstract virtual void AddNodeProcessor(Type type);
    public abstract virtual void AddProperty(XmlElement element);
    public abstract virtual void DispatchProcessAll(IXmlProcessorNodeList nodeList);
    public abstract virtual void DispatchProcessCurrent(IXmlProcessorNodeList nodeList);
    public abstract virtual XmlElement GetProperty(string name);
    public abstract virtual IResource GetResource(string uri);
    public abstract virtual bool HasFlag(string flag);
    public abstract virtual bool HasProperty(string name);
    public abstract virtual bool HasSpecialProcessor(XmlNode node);
    public abstract virtual void PopResource();
    public abstract virtual void PushResource(IResource resource);
    public abstract virtual void RemoveFlag(string flag);
}
public interface Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList {
    public int Count { get; }
    public XmlNode Current { get; }
    public int CurrentPosition { get; public set; }
    public bool HasCurrent { get; }
    public abstract virtual int get_Count();
    public abstract virtual XmlNode get_Current();
    public abstract virtual int get_CurrentPosition();
    public abstract virtual void set_CurrentPosition(int value);
    public abstract virtual bool get_HasCurrent();
    public abstract virtual bool MoveNext();
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor : object {
    private IXmlProcessorEngine engine;
    public XmlProcessor(string environmentName, IResourceSubSystem resourceSubSystem);
    public XmlProcessor(string environmentName);
    public XmlNode Process(XmlNode node);
    public XmlNode Process(IResource resource);
    protected void AddElementProcessor(Type t);
    protected virtual void RegisterProcessors();
}
public class Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessorException : Exception {
    public XmlProcessorException(string message, Object[] args);
    public XmlProcessorException(string message, Exception innerException);
}
public class Castle.Windsor.Diagnostics.AllComponentsDiagnostic : object {
    private IKernel kernel;
    public AllComponentsDiagnostic(IKernel kernel);
    public sealed virtual IHandler[] Inspect();
}
public class Castle.Windsor.Diagnostics.AllServicesDiagnostic : object {
    private IKernel kernel;
    public AllServicesDiagnostic(IKernel kernel);
    public sealed virtual ILookup`2<Type, IHandler> Inspect();
}
public class Castle.Windsor.Diagnostics.ComponentDebuggerExtension : object {
    private Object[] items;
    public ComponentDebuggerExtension(Object[] items);
    public sealed virtual IEnumerable`1<object> Attach();
}
[DebuggerDisplayAttribute("{description,nq}")]
public class Castle.Windsor.Diagnostics.DebuggerViews.ComponentDebuggerView : object {
    [DebuggerBrowsableAttribute("0")]
private string description;
    [DebuggerBrowsableAttribute("0")]
private IComponentDebuggerExtension[] extension;
    [DebuggerBrowsableAttribute("0")]
private string name;
    [DebuggerBrowsableAttribute("0")]
public string Description { get; }
    [DebuggerBrowsableAttribute("3")]
public Object[] Extensions { get; }
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public ComponentDebuggerView(IHandler handler, string description, IComponentDebuggerExtension[] defaultExtension);
    public string get_Description();
    public Object[] get_Extensions();
    public string get_Name();
    public static ComponentDebuggerView BuildFor(IHandler handler, string description);
    public static ComponentDebuggerView BuildRawFor(IHandler handler, string description, IComponentDebuggerExtension[] extensions);
    public static ComponentDebuggerView BuildRawFor(IHandler handler, string description, Object[] items);
    private static IEnumerable`1<IComponentDebuggerExtension> GetExtensions(IHandler handler);
}
[DebuggerDisplayAttribute("{description,nq}")]
public class Castle.Windsor.Diagnostics.DebuggerViews.DebuggerViewItem : object {
    [DebuggerBrowsableAttribute("0")]
private object description;
    [DebuggerBrowsableAttribute("0")]
private string name;
    [DebuggerBrowsableAttribute("3")]
private object value;
    [DebuggerBrowsableAttribute("0")]
public object Description { get; }
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    [DebuggerBrowsableAttribute("0")]
public object Value { get; }
    public DebuggerViewItem(string name, string description, object value);
    public DebuggerViewItem(string name, object value);
    public object get_Description();
    public string get_Name();
    public object get_Value();
}
[DebuggerDisplayAttribute("{description,nq}")]
public class Castle.Windsor.Diagnostics.DebuggerViews.DebuggerViewItemWithDetails : object {
    [DebuggerBrowsableAttribute("0")]
private object description;
    [DebuggerBrowsableAttribute("0")]
private string name;
    [CompilerGeneratedAttribute]
private string <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Items>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
public object Description { get; }
    public string Details { get; private set; }
    [DebuggerBrowsableAttribute("3")]
public Object[] Items { get; public set; }
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public DebuggerViewItemWithDetails(string name, string description, string details, Object[] items);
    public object get_Description();
    [CompilerGeneratedAttribute]
public string get_Details();
    [CompilerGeneratedAttribute]
private void set_Details(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(Object[] value);
    public string get_Name();
}
public class Castle.Windsor.Diagnostics.DebuggerViews.MasterDetailsDebuggerViewItem : object {
    [DebuggerBrowsableAttribute("0")]
private Object[] details;
    [DebuggerBrowsableAttribute("0")]
private object master;
    [DebuggerBrowsableAttribute("0")]
private string masterDescription;
    [DebuggerBrowsableAttribute("0")]
private string masterName;
    [DebuggerDisplayAttribute("{masterDescription,nq}")]
public object AMaster { get; }
    [DebuggerBrowsableAttribute("3")]
public Object[] Details { get; }
    public MasterDetailsDebuggerViewItem(object master, string masterDescription, string masterName, Object[] details);
    public object get_AMaster();
    public Object[] get_Details();
}
public class Castle.Windsor.Diagnostics.DefaultDiagnosticsSubSystem : AbstractSubSystem {
    private IDictionary`2<Type, IDiagnostic`1<object>> diagnostics;
    private IList`1<IContainerDebuggerExtension> extensions;
    public virtual void Terminate();
    public sealed virtual void AddDiagnostic(TDiagnostic diagnostic);
    public sealed virtual TDiagnostic GetDiagnostic();
    public virtual void Init(IKernelInternal kernel);
    public sealed virtual void Add(IContainerDebuggerExtension item);
    public sealed virtual IEnumerator`1<IContainerDebuggerExtension> GetEnumerator();
    protected virtual void InitStandardExtensions();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Castle.Windsor.Diagnostics.DependencyDuplicate : object {
    [CompilerGeneratedAttribute]
private DependencyModel <Dependency1>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyModel <Dependency2>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyDuplicationReason <Reason>k__BackingField;
    public DependencyModel Dependency1 { get; private set; }
    public DependencyModel Dependency2 { get; private set; }
    public DependencyDuplicationReason Reason { get; private set; }
    public DependencyDuplicate(DependencyModel dependency1, DependencyModel dependency2, DependencyDuplicationReason reason);
    [CompilerGeneratedAttribute]
public DependencyModel get_Dependency1();
    [CompilerGeneratedAttribute]
private void set_Dependency1(DependencyModel value);
    [CompilerGeneratedAttribute]
public DependencyModel get_Dependency2();
    [CompilerGeneratedAttribute]
private void set_Dependency2(DependencyModel value);
    [CompilerGeneratedAttribute]
public DependencyDuplicationReason get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(DependencyDuplicationReason value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected bool Equals(DependencyDuplicate other);
}
public enum Castle.Windsor.Diagnostics.DependencyDuplicationReason : Enum {
    public int value__;
    public static DependencyDuplicationReason Unspecified;
    public static DependencyDuplicationReason Name;
    public static DependencyDuplicationReason Type;
    public static DependencyDuplicationReason NameAndType;
    public static DependencyDuplicationReason Reference;
}
public class Castle.Windsor.Diagnostics.DuplicatedDependenciesDiagnostic : object {
    private IKernel kernel;
    public DuplicatedDependenciesDiagnostic(IKernel kernel);
    public string GetDetails(DependencyDuplicate duplicates);
    public sealed virtual Tuple`2[] Inspect();
    private void CollectDuplicatesBetween(DependencyModel[] array, ICollection`1<DependencyDuplicate> duplicates);
    private void CollectDuplicatesBetweenConstructorParameters(ConstructorCandidateCollection constructors, ICollection`1<DependencyDuplicate> duplicates);
    private void CollectDuplicatesBetweenProperties(DependencyModel[] properties, ICollection`1<DependencyDuplicate> duplicates);
    private void CollectDuplicatesBetweenPropertiesAndConstructors(ConstructorCandidateCollection constructors, DependencyModel[] properties, ICollection`1<DependencyDuplicate> duplicates);
    private DependencyDuplicate[] FindDuplicateDependenciesFor(IHandler handler);
    private DependencyDuplicationReason IsDuplicate(DependencyModel foo, DependencyModel bar);
    private static void Describe(StringBuilder details, DependencyModel dependency);
}
public abstract class Castle.Windsor.Diagnostics.Extensions.AbstractContainerDebuggerExtension : object {
    public abstract virtual IEnumerable`1<DebuggerViewItem> Attach();
    public abstract virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
    protected ComponentDebuggerView DefaultComponentView(IHandler handler);
    protected ComponentDebuggerView DefaultComponentView(IHandler handler, string description);
}
public class Castle.Windsor.Diagnostics.Extensions.AllComponents : AbstractContainerDebuggerExtension {
    private static string name;
    private IAllComponentsDiagnostic diagnostic;
    public static string Name { get; }
    public virtual IEnumerable`1<DebuggerViewItem> Attach();
    public virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
    public static string get_Name();
}
public class Castle.Windsor.Diagnostics.Extensions.AllServices : AbstractContainerDebuggerExtension {
    private static string name;
    private IAllServicesDiagnostic diagnostic;
    public virtual IEnumerable`1<DebuggerViewItem> Attach();
    public virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
    private DebuggerViewItem BuildServiceView(IEnumerable`1<IHandler> handlers, string name);
    [CompilerGeneratedAttribute]
private DebuggerViewItem <Attach>b__2_0(IGrouping`2<Type, IHandler> p);
}
public class Castle.Windsor.Diagnostics.Extensions.DuplicatedDependenciesDebuggerExtension : AbstractContainerDebuggerExtension {
    private static string name;
    private DuplicatedDependenciesDiagnostic diagnostic;
    public static string Name { get; }
    public virtual IEnumerable`1<DebuggerViewItem> Attach();
    public virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
    private ComponentDebuggerView[] BuildItems(Tuple`2[] results);
    private ComponentDebuggerView ComponentWithDuplicateDependenciesView(Tuple`2<IHandler, DependencyDuplicate[]> input);
    private DebuggerViewItemWithDetails MismatchView(DependencyDuplicate input);
    public static string get_Name();
    private static string Description(DependencyModel dependencyModel);
}
public class Castle.Windsor.Diagnostics.Extensions.Facilities : object {
    private IKernel kernel;
    [IteratorStateMachineAttribute("Castle.Windsor.Diagnostics.Extensions.Facilities/<Attach>d__1")]
public sealed virtual IEnumerable`1<DebuggerViewItem> Attach();
    public sealed virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
}
public class Castle.Windsor.Diagnostics.Extensions.PotentialLifestyleMismatches : AbstractContainerDebuggerExtension {
    private static string name;
    private IPotentialLifestyleMismatchesDiagnostic diagnostic;
    public static string Name { get; }
    public virtual IEnumerable`1<DebuggerViewItem> Attach();
    public virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
    private string GetKey(IHandler root);
    private string GetMismatchMessage(IHandler[] handlers);
    private string GetName(IHandler[] handlers, IHandler root);
    private string GetNameDescription(ComponentModel componentModel);
    private object MismatchedComponentView(IHandler[] handlers);
    public static string get_Name();
}
public class Castle.Windsor.Diagnostics.Extensions.PotentiallyMisconfiguredComponents : AbstractContainerDebuggerExtension {
    private static string name;
    private IPotentiallyMisconfiguredComponentsDiagnostic diagnostic;
    public static string Name { get; }
    public virtual IEnumerable`1<DebuggerViewItem> Attach();
    public virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
    public static string get_Name();
}
public class Castle.Windsor.Diagnostics.Extensions.ReleasePolicyTrackedObjects : AbstractContainerDebuggerExtension {
    private static string name;
    private TrackedComponentsDiagnostic diagnostic;
    public static string Name { get; }
    public virtual IEnumerable`1<DebuggerViewItem> Attach();
    public virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
    private DebuggerViewItem BuildItem(ILookup`2<IHandler, object> results);
    public static string get_Name();
}
public class Castle.Windsor.Diagnostics.Extensions.UsingContainerAsServiceLocator : AbstractContainerDebuggerExtension {
    private static string name;
    private IUsingContainerAsServiceLocatorDiagnostic diagnostic;
    public virtual IEnumerable`1<DebuggerViewItem> Attach();
    public virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
}
public class Castle.Windsor.Diagnostics.Helpers.DefaultComponentViewBuilder : object {
    private IHandler handler;
    public DefaultComponentViewBuilder(IHandler handler);
    [IteratorStateMachineAttribute("Castle.Windsor.Diagnostics.Helpers.DefaultComponentViewBuilder/<Attach>d__2")]
public sealed virtual IEnumerable`1<object> Attach();
    private object GetImplementation();
    private object GetStatus();
    private string GetStatusDetails(IExposeDependencyInfo info);
    private bool HasInterceptors();
}
[ExtensionAttribute]
public static class Castle.Windsor.Diagnostics.Helpers.DescriptionUtil : object {
    [ExtensionAttribute]
public static string GetComponentName(IHandler handler);
    [ExtensionAttribute]
public static string GetLifestyleDescription(ComponentModel componentModel);
    [ExtensionAttribute]
public static string GetLifestyleDescriptionLong(ComponentModel componentModel);
    [ExtensionAttribute]
public static string GetServicesDescription(IHandler handler);
}
public interface Castle.Windsor.Diagnostics.IAllComponentsDiagnostic {
}
public interface Castle.Windsor.Diagnostics.IAllServicesDiagnostic {
}
public interface Castle.Windsor.Diagnostics.IComponentDebuggerExtension {
    public abstract virtual IEnumerable`1<object> Attach();
}
public interface Castle.Windsor.Diagnostics.IContainerDebuggerExtension {
    public abstract virtual IEnumerable`1<DebuggerViewItem> Attach();
    public abstract virtual void Init(IKernel kernel, IDiagnosticsHost diagnosticsHost);
}
public interface Castle.Windsor.Diagnostics.IContainerDebuggerExtensionHost {
    public abstract virtual void Add(IContainerDebuggerExtension extension);
}
public interface Castle.Windsor.Diagnostics.IDiagnostic`1 {
    public abstract virtual T Inspect();
}
public interface Castle.Windsor.Diagnostics.IDiagnosticsHost {
    public abstract virtual void AddDiagnostic(TDiagnostic diagnostic);
    public abstract virtual TDiagnostic GetDiagnostic();
}
public interface Castle.Windsor.Diagnostics.IDiagnosticsInspector`2 {
    public abstract virtual void Inspect(TData data, TContext context);
}
public interface Castle.Windsor.Diagnostics.IDiagnosticsSource`1 {
    public abstract virtual TResult Inspect(IKernel kernel);
}
public interface Castle.Windsor.Diagnostics.IDuplicatedDependenciesDiagnostic {
}
public interface Castle.Windsor.Diagnostics.IExposeDiagnostics`1 {
    public abstract virtual void Visit(IDiagnosticsInspector`2<TData, TContext> inspector, TContext context);
}
public interface Castle.Windsor.Diagnostics.Inspectors.ITrackedObjectsInspector {
}
public class Castle.Windsor.Diagnostics.Inspectors.TrackedObjects : object {
    private IReleasePolicy[] subScopes;
    private Burden[] trackedObjects;
    public IReleasePolicy[] SubScopes { get; }
    public Burden[] TrackedObjectBurdens { get; }
    public TrackedObjects(Burden[] trackedObjects, IReleasePolicy[] subScopes);
    public IReleasePolicy[] get_SubScopes();
    public Burden[] get_TrackedObjectBurdens();
}
public interface Castle.Windsor.Diagnostics.IPerformanceMetricsFactory {
    public abstract virtual ITrackedComponentsPerformanceCounter CreateInstancesTrackedByReleasePolicyCounter(string name);
}
public interface Castle.Windsor.Diagnostics.IPotentialLifestyleMismatchesDiagnostic {
}
public interface Castle.Windsor.Diagnostics.IPotentiallyMisconfiguredComponentsDiagnostic {
}
public interface Castle.Windsor.Diagnostics.ITrackedComponentsDiagnostic {
    [CompilerGeneratedAttribute]
public abstract virtual void add_TrackedInstancesRequested(EventHandler`1<TrackedInstancesEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TrackedInstancesRequested(EventHandler`1<TrackedInstancesEventArgs> value);
}
public interface Castle.Windsor.Diagnostics.ITrackedComponentsPerformanceCounter {
    public abstract virtual void DecrementTrackedInstancesCount();
    public abstract virtual void IncrementTrackedInstancesCount();
}
public interface Castle.Windsor.Diagnostics.IUsingContainerAsServiceLocatorDiagnostic {
}
[DebuggerDisplayAttribute("")]
internal class Castle.Windsor.Diagnostics.KernelDebuggerProxy : object {
    private IEnumerable`1<IContainerDebuggerExtension> extensions;
    [DebuggerDisplayAttribute("")]
[DebuggerBrowsableAttribute("3")]
public DebuggerViewItem[] Extensions { get; }
    public KernelDebuggerProxy(IWindsorContainer container);
    public KernelDebuggerProxy(IKernel kernel);
    public DebuggerViewItem[] get_Extensions();
}
public class Castle.Windsor.Diagnostics.NullPerformanceCounter : object {
    public static ITrackedComponentsPerformanceCounter Instance;
    private static NullPerformanceCounter();
    public sealed virtual void DecrementTrackedInstancesCount();
    public sealed virtual void IncrementTrackedInstancesCount();
}
public class Castle.Windsor.Diagnostics.PotentialLifestyleMismatchesDiagnostic : object {
    private IKernel kernel;
    public PotentialLifestyleMismatchesDiagnostic(IKernel kernel);
    public sealed virtual IHandler[][] Inspect();
    [IteratorStateMachineAttribute("Castle.Windsor.Diagnostics.PotentialLifestyleMismatchesDiagnostic/<GetMismatch>d__3")]
private IEnumerable`1<MismatchedLifestyleDependency> GetMismatch(MismatchedLifestyleDependency parent, ComponentModel component, IDictionary`2<ComponentModel, IHandler> model2Handler);
    [IteratorStateMachineAttribute("Castle.Windsor.Diagnostics.PotentialLifestyleMismatchesDiagnostic/<GetMismatches>d__4")]
private IEnumerable`1<MismatchedLifestyleDependency> GetMismatches(IHandler handler, IDictionary`2<ComponentModel, IHandler> model2Handler);
    private bool IsSingleton(IHandler component);
}
public class Castle.Windsor.Diagnostics.PotentiallyMisconfiguredComponentsDiagnostic : object {
    private IKernel kernel;
    public PotentiallyMisconfiguredComponentsDiagnostic(IKernel kernel);
    public sealed virtual IHandler[] Inspect();
    private bool IsWaitingForDependencies(IHandler handler);
}
public class Castle.Windsor.Diagnostics.TrackedComponentsDiagnostic : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<TrackedInstancesEventArgs> TrackedInstancesRequested;
    public sealed virtual ILookup`2<IHandler, object> Inspect();
    [CompilerGeneratedAttribute]
public sealed virtual void add_TrackedInstancesRequested(EventHandler`1<TrackedInstancesEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TrackedInstancesRequested(EventHandler`1<TrackedInstancesEventArgs> value);
}
public class Castle.Windsor.Diagnostics.TrackedInstancesEventArgs : EventArgs {
    private List`1<Burden> burdens;
    public Burden[] Items { get; }
    public Burden[] get_Items();
    public void AddRange(IEnumerable`1<Burden> burden);
}
public class Castle.Windsor.Diagnostics.UsingContainerAsServiceLocatorDiagnostic : object {
    public static Type[] ContainerTypes;
    public static Predicate`1[] ExceptionsToTheRule;
    private IKernel kernel;
    public UsingContainerAsServiceLocatorDiagnostic(IKernel kernel);
    private static UsingContainerAsServiceLocatorDiagnostic();
    public sealed virtual IHandler[] Inspect();
    private bool HasDependencyOnTheContainer(IHandler handler);
}
public interface Castle.Windsor.IComponentsInstaller {
    public abstract virtual void SetUp(IWindsorContainer container, IConfigurationStore store);
}
public interface Castle.Windsor.IContainerAccessor {
    public IWindsorContainer Container { get; }
    public abstract virtual IWindsorContainer get_Container();
}
public interface Castle.Windsor.IEnvironmentInfo {
    public abstract virtual string GetEnvironmentName();
}
public class Castle.Windsor.Installer.AssemblyInstaller : object {
    private Assembly assembly;
    private InstallerFactory factory;
    public AssemblyInstaller(Assembly assembly, InstallerFactory factory);
    public sealed virtual void Install(IWindsorContainer container, IConfigurationStore store);
    private IEnumerable`1<Type> FilterInstallerTypes(IEnumerable`1<Type> types);
}
public class Castle.Windsor.Installer.CompositeInstaller : object {
    private HashSet`1<IWindsorInstaller> installers;
    public void Add(IWindsorInstaller instance);
    public sealed virtual void Install(IWindsorContainer container, IConfigurationStore store);
}
public static class Castle.Windsor.Installer.Configuration : object {
    public static ConfigurationInstaller FromXml(IResource resource);
    public static ConfigurationInstaller FromXmlFile(string file);
}
public class Castle.Windsor.Installer.ConfigurationInstaller : object {
    private IConfigurationInterpreter interpreter;
    private EnvironmentDelegate environment;
    public ConfigurationInstaller(IConfigurationInterpreter interpreter);
    public ConfigurationInstaller Environment(string environmentName);
    public ConfigurationInstaller Environment(EnvironmentDelegate environment);
    private sealed virtual override void Castle.MicroKernel.Registration.IWindsorInstaller.Install(IWindsorContainer container, IConfigurationStore store);
}
public class Castle.Windsor.Installer.DefaultComponentInstaller : object {
    private string assemblyName;
    public sealed virtual void SetUp(IWindsorContainer container, IConfigurationStore store);
    protected virtual void SetUpInstallers(IConfiguration[] installers, IWindsorContainer container, IConversionManager converter);
    private void AddInstaller(IConfiguration installer, Dictionary`2<Type, IWindsorInstaller> cache, IConversionManager conversionManager, ICollection`1<Assembly> assemblies);
    private void GetAssemblyInstallers(Dictionary`2<Type, IWindsorInstaller> cache, Assembly assembly);
    private IEnumerable`1<Type> InstallerTypes(IEnumerable`1<Type> types);
    private bool IsInstaller(Type type);
    private void AddInstaller(Dictionary`2<Type, IWindsorInstaller> cache, Type type);
    protected virtual void SetUpFacilities(IConfiguration[] configurations, IWindsorContainer container, IConversionManager converter);
    private void AssertImplementsService(IConfiguration id, Type service, Type implementation);
    protected virtual void SetUpComponents(IConfiguration[] configurations, IWindsorContainer container, IConversionManager converter);
    private static string GetName(CastleComponentAttribute defaults, IConfiguration component);
    private Type GetType(IConversionManager converter, string typeName);
    private void CollectAdditionalServices(IConfiguration component, IConversionManager converter, ICollection`1<Type> services);
    private static void SetUpChildContainers(IConfiguration[] configurations, IWindsorContainer parentContainer);
}
public class Castle.Windsor.Installer.EnvironmentDelegate : MulticastDelegate {
    public EnvironmentDelegate(object object, IntPtr method);
    public virtual string Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class Castle.Windsor.Installer.FromAssembly : object {
    public static IWindsorInstaller Containing(Type type);
    public static IWindsorInstaller Containing(Type type, InstallerFactory installerFactory);
    public static IWindsorInstaller Containing();
    public static IWindsorInstaller Containing(InstallerFactory installerFactory);
    public static IWindsorInstaller InDirectory(AssemblyFilter filter);
    public static IWindsorInstaller InDirectory(AssemblyFilter filter, InstallerFactory installerFactory);
    public static IWindsorInstaller InThisApplication();
    public static IWindsorInstaller InThisApplication(Assembly rootAssembly);
    public static IWindsorInstaller InThisApplication(InstallerFactory installerFactory);
    public static IWindsorInstaller InThisApplication(Assembly rootAssembly, InstallerFactory installerFactory);
    public static IWindsorInstaller Instance(Assembly assembly);
    public static IWindsorInstaller Instance(Assembly assembly, InstallerFactory installerFactory);
    public static IWindsorInstaller Named(string assemblyName);
    public static IWindsorInstaller Named(string assemblyName, InstallerFactory installerFactory);
    public static IWindsorInstaller This();
    public static IWindsorInstaller This(InstallerFactory installerFactory);
    private static IWindsorInstaller ApplicationAssemblies(Assembly rootAssembly, InstallerFactory installerFactory);
}
public class Castle.Windsor.Installer.InstallerFactory : object {
    public virtual IWindsorInstaller CreateInstance(Type installerType);
    public virtual IEnumerable`1<Type> Select(IEnumerable`1<Type> installerTypes);
}
internal class Castle.Windsor.Installer.PartialConfigurationStore : object {
    private IConfigurationStore inner;
    private IConfigurationStore partial;
    public PartialConfigurationStore(IKernelInternal kernel);
    public sealed virtual void AddChildContainerConfiguration(string name, IConfiguration config);
    public sealed virtual void AddComponentConfiguration(string key, IConfiguration config);
    public sealed virtual void AddFacilityConfiguration(string key, IConfiguration config);
    public sealed virtual void AddInstallerConfiguration(IConfiguration config);
    public sealed virtual IConfiguration GetChildContainerConfiguration(string key);
    public sealed virtual IConfiguration GetComponentConfiguration(string key);
    public sealed virtual IConfiguration[] GetComponents();
    public sealed virtual IConfiguration[] GetConfigurationForChildContainers();
    public sealed virtual IConfiguration[] GetFacilities();
    public sealed virtual IConfiguration GetFacilityConfiguration(string key);
    public sealed virtual IConfiguration[] GetInstallers();
    public sealed virtual IResource GetResource(string resourceUri, IResource resource);
    public sealed virtual void Dispose();
    public sealed virtual void Init(IKernelInternal kernel);
    public sealed virtual void Terminate();
}
public interface Castle.Windsor.IWindsorContainer {
    public IKernel Kernel { get; }
    public string Name { get; }
    public IWindsorContainer Parent { get; public set; }
    public abstract virtual IKernel get_Kernel();
    public abstract virtual string get_Name();
    public abstract virtual IWindsorContainer get_Parent();
    public abstract virtual void set_Parent(IWindsorContainer value);
    public abstract virtual void AddChildContainer(IWindsorContainer childContainer);
    public abstract virtual IWindsorContainer AddFacility(IFacility facility);
    public abstract virtual IWindsorContainer AddFacility();
    public abstract virtual IWindsorContainer AddFacility(Action`1<TFacility> onCreate);
    public abstract virtual IWindsorContainer GetChildContainer(string name);
    public abstract virtual IWindsorContainer Install(IWindsorInstaller[] installers);
    public abstract virtual IWindsorContainer Register(IRegistration[] registrations);
    public abstract virtual void Release(object instance);
    public abstract virtual void RemoveChildContainer(IWindsorContainer childContainer);
    public abstract virtual object Resolve(string key, Type service);
    public abstract virtual object Resolve(Type service);
    public abstract virtual object Resolve(Type service, Arguments arguments);
    public abstract virtual T Resolve();
    public abstract virtual T Resolve(Arguments arguments);
    public abstract virtual T Resolve(string key);
    public abstract virtual T Resolve(string key, Arguments arguments);
    public abstract virtual object Resolve(string key, Type service, Arguments arguments);
    public abstract virtual T[] ResolveAll();
    public abstract virtual Array ResolveAll(Type service);
    public abstract virtual Array ResolveAll(Type service, Arguments arguments);
    public abstract virtual T[] ResolveAll(Arguments arguments);
}
public abstract class Castle.Windsor.Proxy.AbstractProxyFactory : object {
    private List`1<IModelInterceptorsSelector> selectors;
    public abstract virtual object Create(IKernel kernel, object instance, ComponentModel model, CreationContext context, Object[] constructorArguments);
    public abstract virtual object Create(IProxyFactoryExtension customFactory, IKernel kernel, ComponentModel model, CreationContext context, Object[] constructorArguments);
    public abstract virtual bool RequiresTargetInstance(IKernel kernel, ComponentModel model);
    public sealed virtual void AddInterceptorSelector(IModelInterceptorsSelector selector);
    public sealed virtual bool ShouldCreateProxy(ComponentModel model);
    protected IEnumerable`1<InterceptorReference> GetInterceptorsFor(ComponentModel model);
    protected IInterceptor[] ObtainInterceptors(IKernel kernel, ComponentModel model, CreationContext context);
    protected static void SetOnBehalfAware(IOnBehalfAware onBehalfAware, ComponentModel target);
}
public class Castle.Windsor.Proxy.DefaultProxyFactory : AbstractProxyFactory {
    protected ProxyGenerator generator;
    public DefaultProxyFactory(bool disableSignedModule);
    public DefaultProxyFactory(ProxyGenerator generator);
    public virtual object Create(IProxyFactoryExtension customFactory, IKernel kernel, ComponentModel model, CreationContext context, Object[] constructorArguments);
    private void ReleaseHook(ProxyGenerationOptions proxyGenOptions, IKernel kernel);
    public virtual object Create(IKernel kernel, object target, ComponentModel model, CreationContext context, Object[] constructorArguments);
    protected static ProxyGenerationOptions CreateProxyGenerationOptionsFrom(ProxyOptions proxyOptions, IKernel kernel, CreationContext context, ComponentModel model);
    protected virtual void CustomizeProxy(object proxy, ProxyGenerationOptions options, IKernel kernel, ComponentModel model);
    protected virtual void CustomizeOptions(ProxyGenerationOptions options, IKernel kernel, ComponentModel model, Object[] arguments);
    public virtual bool RequiresTargetInstance(IKernel kernel, ComponentModel model);
    public sealed virtual void OnDeserialization(object sender);
}
[DebuggerDisplayAttribute("{name,nq}")]
[DebuggerTypeProxyAttribute("Castle.Windsor.Diagnostics.KernelDebuggerProxy")]
public class Castle.Windsor.WindsorContainer : object {
    private static string CastleUnicode;
    private static int instanceCount;
    private IKernel kernel;
    private string name;
    private IComponentsInstaller installer;
    private IWindsorContainer parent;
    private Dictionary`2<string, IWindsorContainer> childContainers;
    private object childContainersLocker;
    public IComponentsInstaller Installer { get; }
    public IKernel Kernel { get; }
    public string Name { get; }
    public IWindsorContainer Parent { get; public set; }
    public WindsorContainer(IConfigurationStore store);
    public WindsorContainer(IConfigurationInterpreter interpreter);
    public WindsorContainer(IConfigurationInterpreter interpreter, IEnvironmentInfo environmentInfo);
    public WindsorContainer(string configurationUri);
    public WindsorContainer(IKernel kernel, IComponentsInstaller installer);
    public WindsorContainer(string name, IKernel kernel, IComponentsInstaller installer);
    public WindsorContainer(IProxyFactory proxyFactory);
    public WindsorContainer(IWindsorContainer parent, IConfigurationInterpreter interpreter);
    public WindsorContainer(string name, IWindsorContainer parent, IConfigurationInterpreter interpreter);
    public IComponentsInstaller get_Installer();
    public virtual IKernel get_Kernel();
    public sealed virtual string get_Name();
    public virtual IWindsorContainer get_Parent();
    public virtual void set_Parent(IWindsorContainer value);
    protected virtual void RunInstaller();
    private void Install(IWindsorInstaller[] installers, DefaultComponentInstaller scope);
    public virtual void Dispose();
    public virtual void AddChildContainer(IWindsorContainer childContainer);
    public sealed virtual IWindsorContainer AddFacility(IFacility facility);
    public sealed virtual IWindsorContainer AddFacility();
    public sealed virtual IWindsorContainer AddFacility(Action`1<T> onCreate);
    public sealed virtual IWindsorContainer GetChildContainer(string name);
    public sealed virtual IWindsorContainer Install(IWindsorInstaller[] installers);
    public sealed virtual IWindsorContainer Register(IRegistration[] registrations);
    public virtual void Release(object instance);
    public virtual void RemoveChildContainer(IWindsorContainer childContainer);
    public virtual object Resolve(Type service, Arguments arguments);
    public virtual object Resolve(Type service);
    public virtual object Resolve(string key, Type service);
    public virtual object Resolve(string key, Type service, Arguments arguments);
    public sealed virtual T Resolve(Arguments arguments);
    public virtual T Resolve(string key, Arguments arguments);
    public sealed virtual T Resolve();
    public virtual T Resolve(string key);
    public sealed virtual T[] ResolveAll();
    public sealed virtual Array ResolveAll(Type service);
    public sealed virtual Array ResolveAll(Type service, Arguments arguments);
    public sealed virtual T[] ResolveAll(Arguments arguments);
    private XmlInterpreter GetInterpreter(string configurationUri);
    private static string MakeUniqueName();
}
[ExtensionAttribute]
public static class Castle.Windsor.WindsorContainerExtensions : object {
    [ExtensionAttribute]
public static object Resolve(IWindsorContainer container, Type service, IEnumerable`1<KeyValuePair`2<string, object>> arguments);
    [ExtensionAttribute]
public static object Resolve(IWindsorContainer container, string key, Type service, IEnumerable`1<KeyValuePair`2<string, object>> arguments);
    [ExtensionAttribute]
public static T Resolve(IWindsorContainer container, IEnumerable`1<KeyValuePair`2<string, object>> arguments);
    [ExtensionAttribute]
public static T Resolve(IWindsorContainer container, string key, IEnumerable`1<KeyValuePair`2<string, object>> arguments);
    [ExtensionAttribute]
public static Array ResolveAll(IWindsorContainer container, Type service, IEnumerable`1<KeyValuePair`2<string, object>> arguments);
    [ExtensionAttribute]
public static T[] ResolveAll(IWindsorContainer container, IEnumerable`1<KeyValuePair`2<string, object>> arguments);
}
public class Castle.Windsor.WindsorServiceProvider : object {
    private IKernelInternal kernel;
    public IKernel Kernel { get; }
    public WindsorServiceProvider(IWindsorContainer container);
    public IKernel get_Kernel();
    public sealed virtual object GetService(Type serviceType);
    public sealed virtual T GetService();
}
