[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class ServiceStack.AssignmentDefinition : object {
    [CompilerGeneratedAttribute]
private Type <FromType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ToType>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, AssignmentEntry> <AssignmentMemberMap>k__BackingField;
    public Type FromType { get; public set; }
    public Type ToType { get; public set; }
    public Dictionary`2<string, AssignmentEntry> AssignmentMemberMap { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_FromType();
    [CompilerGeneratedAttribute]
public void set_FromType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ToType();
    [CompilerGeneratedAttribute]
public void set_ToType(Type value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, AssignmentEntry> get_AssignmentMemberMap();
    [CompilerGeneratedAttribute]
public void set_AssignmentMemberMap(Dictionary`2<string, AssignmentEntry> value);
    public void AddMatch(string name, AssignmentMember readMember, AssignmentMember writeMember);
    public void PopulateFromPropertiesWithAttribute(object to, object from, Type attributeType);
    public void PopulateFromPropertiesWithoutAttribute(object to, object from, Type attributeType);
    public void PopulateWithNonDefaultValues(object to, object from);
    public void Populate(object to, object from);
    public void Populate(object to, object from, Func`2<PropertyInfo, bool> propertyInfoPredicate, Func`3<object, Type, bool> valuePredicate);
}
public class ServiceStack.AssignmentEntry : object {
    public string Name;
    public AssignmentMember From;
    public AssignmentMember To;
    public GetMemberDelegate GetValueFn;
    public SetMemberDelegate SetValueFn;
    public GetMemberDelegate ConvertValueFn;
    public AssignmentEntry(string name, AssignmentMember from, AssignmentMember to);
}
public class ServiceStack.AssignmentMember : object {
    public Type Type;
    public PropertyInfo PropertyInfo;
    public FieldInfo FieldInfo;
    public MethodInfo MethodInfo;
    public AssignmentMember(Type type, PropertyInfo propertyInfo);
    public AssignmentMember(Type type, FieldInfo fieldInfo);
    public AssignmentMember(Type type, MethodInfo methodInfo);
    public GetMemberDelegate CreateGetter();
    public SetMemberDelegate CreateSetter();
}
public static class ServiceStack.AutoMapping : object {
    public static void RegisterConverter(Func`2<From, To> converter);
    public static void IgnoreMapping();
    public static void IgnoreMapping(Type fromType, Type toType);
    public static void RegisterPopulator(Action`2<Target, Source> populator);
}
[ExtensionAttribute]
public static class ServiceStack.AutoMappingUtils : object {
    internal static ConcurrentDictionary`2<Tuple`2<Type, Type>, GetMemberDelegate> converters;
    internal static ConcurrentDictionary`2<Tuple`2<Type, Type>, PopulateMemberDelegate> populators;
    internal static ConcurrentDictionary`2<Tuple`2<Type, Type>, bool> ignoreMappings;
    private static Dictionary`2<Type, List`1<string>> TypePropertyNamesMap;
    private static Dictionary`2<Type, object> DefaultValueTypes;
    private static ConcurrentDictionary`2<string, AssignmentDefinition> AssignmentDefinitionCache;
    private static int MaxRecursionLevelForDefaultValues;
    private static AutoMappingUtils();
    public static void Reset();
    public static bool ShouldIgnoreMapping(Type fromType, Type toType);
    public static GetMemberDelegate GetConverter(Type fromType, Type toType);
    public static PopulateMemberDelegate GetPopulator(Type targetType, Type sourceType);
    [ExtensionAttribute]
public static T ConvertTo(object from, T defaultValue);
    [ExtensionAttribute]
public static T ConvertTo(object from);
    [ExtensionAttribute]
public static T ConvertTo(object from, bool skipConverters);
    [ExtensionAttribute]
public static T CreateCopy(T from);
    [ExtensionAttribute]
public static To ThenDo(To to, Action`1<To> fn);
    [ExtensionAttribute]
public static object ConvertTo(object from, Type toType);
    [ExtensionAttribute]
public static object ConvertTo(object from, Type toType, bool skipConverters);
    public static MethodInfo GetImplicitCastMethod(Type fromType, Type toType);
    public static MethodInfo GetExplicitCastMethod(Type fromType, Type toType);
    public static object ChangeValueType(object from, Type toType);
    [ExtensionAttribute]
public static object ChangeTo(string strValue, Type type);
    [ExtensionAttribute]
public static List`1<string> GetPropertyNames(Type type);
    [ExtensionAttribute]
public static string GetAssemblyPath(Type source);
    [ExtensionAttribute]
public static bool IsDebugBuild(Assembly assembly);
    public static object PopulateWith(object obj);
    private static object PopulateObjectInternal(object obj, Dictionary`2<Type, int> recursionInfo);
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
    public static bool IsDefaultValue(object value);
    public static bool IsDefaultValue(object value, Type valueType);
    internal static AssignmentDefinition GetAssignmentDefinition(Type toType, Type fromType);
    internal static string CreateCacheKey(Type fromType, Type toType);
    private static Dictionary`2<string, AssignmentMember> GetMembers(Type type, bool isReadable);
    [ExtensionAttribute]
public static To PopulateWith(To to, From from);
    [ExtensionAttribute]
public static To PopulateWithNonDefaultValues(To to, From from);
    [ExtensionAttribute]
public static To PopulateFromPropertiesWithAttribute(To to, From from, Type attributeType);
    [ExtensionAttribute]
public static To PopulateFromPropertiesWithoutAttribute(To to, From from, Type attributeType);
    [ExtensionAttribute]
public static void SetProperty(PropertyInfo propertyInfo, object obj, object value);
    [ExtensionAttribute]
public static object GetProperty(PropertyInfo propertyInfo, object obj);
    public static void SetValue(FieldInfo fieldInfo, PropertyInfo propertyInfo, object obj, object value);
    public static bool IsUnsettableValue(FieldInfo fieldInfo, PropertyInfo propertyInfo);
    public static Object[] CreateDefaultValues(IEnumerable`1<Type> types, Dictionary`2<Type, int> recursionInfo);
    public static object CreateDefaultValue(Type type, Dictionary`2<Type, int> recursionInfo);
    public static void SetGenericCollection(Type realizedListType, object genericObj, Dictionary`2<Type, int> recursionInfo);
    public static Array PopulateArray(Type type, Dictionary`2<Type, int> recursionInfo);
    public static bool CanCast(Type toType, Type fromType);
    [IteratorStateMachineAttribute("ServiceStack.AutoMappingUtils/<GetPropertyAttributes>d__46`1")]
public static IEnumerable`1<KeyValuePair`2<PropertyInfo, T>> GetPropertyAttributes(Type fromType);
    public static object TryConvertCollections(Type fromType, Type toType, object fromValue);
}
[ExtensionAttribute]
public static class ServiceStack.CollectionExtensions : object {
    public static ICollection`1<T> CreateAndPopulate(Type ofCollectionType, T[] withItems);
    [ExtensionAttribute]
public static T[] ToArray(ICollection`1<T> collection);
    public static object Convert(object objCollection, Type toCollectionType);
}
internal class ServiceStack.Common.Support.AssemblyTypeDefinition : object {
    private static char TypeDefinitionSeperator;
    private static int TypeNameIndex;
    private static int AssemblyNameIndex;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    public string TypeName { get; public set; }
    public string AssemblyName { get; public set; }
    public AssemblyTypeDefinition(string typeDefinition);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
}
public static class ServiceStack.CompressionTypes : object {
    public static String[] AllCompressionTypes;
    public static string Default;
    public static string Deflate;
    public static string GZip;
    private static CompressionTypes();
    public static bool IsValid(string compressionType);
    public static void AssertIsValid(string compressionType);
    public static string GetExtension(string compressionType);
}
[DataContractAttribute]
public class ServiceStack.CustomHttpResult : object {
}
public class ServiceStack.Defer : ValueType {
    private Action fn;
    public Defer(Action fn);
    public sealed virtual void Dispose();
}
public static class ServiceStack.DeserializeDynamic`1 : object {
    private static ITypeSerializer Serializer;
    private static ParseStringSpanDelegate CachedParseFn;
    public static ParseStringDelegate Parse { get; }
    public static ParseStringSpanDelegate ParseStringSpan { get; }
    private static DeserializeDynamic`1();
    public static ParseStringDelegate get_Parse();
    public static ParseStringSpanDelegate get_ParseStringSpan();
    public static IDynamicMetaObjectProvider ParseDynamic(string value);
    public static IDynamicMetaObjectProvider ParseDynamic(ReadOnlySpan`1<char> value);
    private static int VerifyAndGetStartIndex(ReadOnlySpan`1<char> value, Type createMapType);
}
public class ServiceStack.DynamicByte : object {
    public static DynamicByte Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicByte();
    public sealed virtual Type get_Type();
    public byte Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.DynamicDecimal : object {
    public static DynamicDecimal Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicDecimal();
    public sealed virtual Type get_Type();
    public decimal Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.DynamicDouble : object {
    public static DynamicDouble Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicDouble();
    public sealed virtual Type get_Type();
    public double Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.DynamicFloat : object {
    public static DynamicFloat Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicFloat();
    public sealed virtual Type get_Type();
    public float Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.DynamicInt : object {
    public static DynamicInt Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicInt();
    public sealed virtual Type get_Type();
    public int Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.DynamicJson : DynamicObject {
    private IDictionary`2<string, object> _hash;
    public DynamicJson(IEnumerable`1<KeyValuePair`2<string, object>> hash);
    public static string Serialize(object instance);
    public static object Deserialize(string json);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual string ToString();
    private bool YieldMember(string name, Object& result);
    internal static string Underscored(string pascalCase);
    internal static string Underscored(IEnumerable`1<char> pascalCase);
}
public class ServiceStack.DynamicLong : object {
    public static DynamicLong Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicLong();
    public sealed virtual Type get_Type();
    public long Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public static class ServiceStack.DynamicNumber : object {
    private static Dictionary`2<int, IDynamicNumber> RankNumbers;
    private static DynamicNumber();
    public static bool IsNumber(Type type);
    public static bool TryGetRanking(Type type, Int32& ranking);
    public static IDynamicNumber GetNumber(Type type);
    public static IDynamicNumber Get(object obj);
    public static IDynamicNumber GetNumber(object lhs, object rhs);
    public static IDynamicNumber AssertNumbers(string name, object lhs, object rhs);
    public static object Add(object lhs, object rhs);
    public static object Sub(object lhs, object rhs);
    public static object Subtract(object lhs, object rhs);
    public static object Mul(object lhs, object rhs);
    public static object Multiply(object lhs, object rhs);
    public static object Div(object lhs, object rhs);
    public static object Divide(object lhs, object rhs);
    public static object Mod(object lhs, object rhs);
    public static object Min(object lhs, object rhs);
    public static object Max(object lhs, object rhs);
    public static object Pow(object lhs, object rhs);
    public static object Log(object lhs, object rhs);
    public static int CompareTo(object lhs, object rhs);
    public static object BitwiseAnd(object lhs, object rhs);
    public static object BitwiseOr(object lhs, object rhs);
    public static object BitwiseXOr(object lhs, object rhs);
    public static object BitwiseLeftShift(object lhs, object rhs);
    public static object BitwiseRightShift(object lhs, object rhs);
    public static object BitwiseNot(object lhs);
    public static bool TryParse(string strValue, Object& result);
    public static bool TryParseIntoBestFit(string strValue, Object& result);
}
[ExtensionAttribute]
internal static class ServiceStack.DynamicNumberExtensions : object {
    [ExtensionAttribute]
internal static object ParseString(IDynamicNumber number, object value);
}
public class ServiceStack.DynamicSByte : object {
    public static DynamicSByte Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicSByte();
    public sealed virtual Type get_Type();
    public sbyte Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.DynamicShort : object {
    public static DynamicShort Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicShort();
    public sealed virtual Type get_Type();
    public short Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.DynamicUInt : object {
    public static DynamicUInt Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicUInt();
    public sealed virtual Type get_Type();
    public UInt32 Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.DynamicULong : object {
    public static DynamicULong Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicULong();
    public sealed virtual Type get_Type();
    public ulong Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.DynamicUShort : object {
    public static DynamicUShort Instance;
    public Type Type { get; }
    public object DefaultValue { get; }
    private static DynamicUShort();
    public sealed virtual Type get_Type();
    public ushort Convert(object value);
    public sealed virtual object ConvertFrom(object value);
    public sealed virtual bool TryParse(string str, Object& result);
    public sealed virtual string ToString(object value);
    public sealed virtual object get_DefaultValue();
    public sealed virtual object add(object lhs, object rhs);
    public sealed virtual object sub(object lhs, object rhs);
    public sealed virtual object mul(object lhs, object rhs);
    public sealed virtual object div(object lhs, object rhs);
    public sealed virtual object mod(object lhs, object rhs);
    public sealed virtual object min(object lhs, object rhs);
    public sealed virtual object max(object lhs, object rhs);
    public sealed virtual object pow(object lhs, object rhs);
    public sealed virtual object log(object lhs, object rhs);
    public sealed virtual int compareTo(object lhs, object rhs);
    public sealed virtual object bitwiseAnd(object lhs, object rhs);
    public sealed virtual object bitwiseOr(object lhs, object rhs);
    public sealed virtual object bitwiseXOr(object lhs, object rhs);
    public sealed virtual object bitwiseLeftShift(object lhs, object rhs);
    public sealed virtual object bitwiseRightShift(object lhs, object rhs);
    public sealed virtual object bitwiseNot(object target);
}
public class ServiceStack.EmptyCtorDelegate : MulticastDelegate {
    public EmptyCtorDelegate(object object, IntPtr method);
    public virtual object Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class ServiceStack.EmptyCtorFactoryDelegate : MulticastDelegate {
    public EmptyCtorFactoryDelegate(object object, IntPtr method);
    public virtual EmptyCtorDelegate Invoke(Type type);
    public virtual IAsyncResult BeginInvoke(Type type, AsyncCallback callback, object object);
    public virtual EmptyCtorDelegate EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class ServiceStack.Extensions.ServiceStackExtensions : object {
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> Trim(ReadOnlyMemory`1<char> span);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> TrimStart(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> TrimEnd(ReadOnlyMemory`1<char> value);
}
public class ServiceStack.FieldAccessor : object {
    [CompilerGeneratedAttribute]
private FieldInfo <FieldInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private GetMemberDelegate <PublicGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private SetMemberDelegate <PublicSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private SetMemberRefDelegate <PublicSetterRef>k__BackingField;
    public FieldInfo FieldInfo { get; }
    public GetMemberDelegate PublicGetter { get; }
    public SetMemberDelegate PublicSetter { get; }
    public SetMemberRefDelegate PublicSetterRef { get; }
    public FieldAccessor(FieldInfo fieldInfo, GetMemberDelegate publicGetter, SetMemberDelegate publicSetter, SetMemberRefDelegate publicSetterRef);
    [CompilerGeneratedAttribute]
public FieldInfo get_FieldInfo();
    [CompilerGeneratedAttribute]
public GetMemberDelegate get_PublicGetter();
    [CompilerGeneratedAttribute]
public SetMemberDelegate get_PublicSetter();
    [CompilerGeneratedAttribute]
public SetMemberRefDelegate get_PublicSetterRef();
}
[ExtensionAttribute]
public static class ServiceStack.FieldInvoker : object {
    [ExtensionAttribute]
public static GetMemberDelegate CreateGetter(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static GetMemberDelegate`1<T> CreateGetter(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static SetMemberDelegate CreateSetter(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static SetMemberDelegate`1<T> CreateSetter(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static SetMemberRefDelegate`1<T> SetExpressionRef(FieldInfo fieldInfo);
}
public class ServiceStack.GetMemberDelegate : MulticastDelegate {
    public GetMemberDelegate(object object, IntPtr method);
    public virtual object Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class ServiceStack.GetMemberDelegate`1 : MulticastDelegate {
    public GetMemberDelegate`1(object object, IntPtr method);
    public virtual object Invoke(T instance);
    public virtual IAsyncResult BeginInvoke(T instance, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public static class ServiceStack.HttpHeaders : object {
    public static string XParamOverridePrefix;
    public static string XHttpMethodOverride;
    public static string XAutoBatchCompleted;
    public static string XTag;
    public static string XUserAuthId;
    public static string XTrigger;
    public static string XForwardedFor;
    public static string XForwardedPort;
    public static string XForwardedProtocol;
    public static string XRealIp;
    public static string XLocation;
    public static string XStatus;
    public static string XPoweredBy;
    public static string Referer;
    public static string CacheControl;
    public static string IfModifiedSince;
    public static string IfUnmodifiedSince;
    public static string IfNoneMatch;
    public static string IfMatch;
    public static string LastModified;
    public static string Accept;
    public static string AcceptEncoding;
    public static string ContentType;
    public static string ContentEncoding;
    public static string ContentLength;
    public static string ContentDisposition;
    public static string Location;
    public static string SetCookie;
    public static string ETag;
    public static string Age;
    public static string Expires;
    public static string Vary;
    public static string Authorization;
    public static string WwwAuthenticate;
    public static string AllowOrigin;
    public static string AllowMethods;
    public static string AllowHeaders;
    public static string AllowCredentials;
    public static string ExposeHeaders;
    public static string AccessControlMaxAge;
    public static string Origin;
    public static string RequestMethod;
    public static string RequestHeaders;
    public static string AcceptRanges;
    public static string ContentRange;
    public static string Range;
    public static string SOAPAction;
    public static string Allow;
    public static string AcceptCharset;
    public static string AcceptLanguage;
    public static string Connection;
    public static string Cookie;
    public static string ContentLanguage;
    public static string Expect;
    public static string Pragma;
    public static string ProxyAuthenticate;
    public static string ProxyAuthorization;
    public static string ProxyConnection;
    public static string SetCookie2;
    public static string TE;
    public static string Trailer;
    public static string TransferEncoding;
    public static string Upgrade;
    public static string Via;
    public static string Warning;
    public static string Date;
    public static string Host;
    public static string UserAgent;
    public static HashSet`1<string> RestrictedHeaders;
    private static HttpHeaders();
}
public static class ServiceStack.HttpMethods : object {
    private static String[] allVerbs;
    public static HashSet`1<string> AllVerbs;
    public static string Get;
    public static string Put;
    public static string Post;
    public static string Delete;
    public static string Options;
    public static string Head;
    public static string Patch;
    private static HttpMethods();
    public static bool Exists(string httpMethod);
    public static bool HasVerb(string httpVerb);
}
public class ServiceStack.HttpResultsFilter : object {
    private IHttpResultsFilter previousFilter;
    [CompilerGeneratedAttribute]
private string <StringResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <BytesResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<HttpWebRequest, string, string> <StringResultFn>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<HttpWebRequest, Byte[], Byte[]> <BytesResultFn>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<HttpWebRequest, Stream, string> <UploadFileFn>k__BackingField;
    public string StringResult { get; public set; }
    public Byte[] BytesResult { get; public set; }
    public Func`3<HttpWebRequest, string, string> StringResultFn { get; public set; }
    public Func`3<HttpWebRequest, Byte[], Byte[]> BytesResultFn { get; public set; }
    public Action`3<HttpWebRequest, Stream, string> UploadFileFn { get; public set; }
    public HttpResultsFilter(string stringResult, Byte[] bytesResult);
    [CompilerGeneratedAttribute]
public string get_StringResult();
    [CompilerGeneratedAttribute]
public void set_StringResult(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_BytesResult();
    [CompilerGeneratedAttribute]
public void set_BytesResult(Byte[] value);
    [CompilerGeneratedAttribute]
public Func`3<HttpWebRequest, string, string> get_StringResultFn();
    [CompilerGeneratedAttribute]
public void set_StringResultFn(Func`3<HttpWebRequest, string, string> value);
    [CompilerGeneratedAttribute]
public Func`3<HttpWebRequest, Byte[], Byte[]> get_BytesResultFn();
    [CompilerGeneratedAttribute]
public void set_BytesResultFn(Func`3<HttpWebRequest, Byte[], Byte[]> value);
    [CompilerGeneratedAttribute]
public Action`3<HttpWebRequest, Stream, string> get_UploadFileFn();
    [CompilerGeneratedAttribute]
public void set_UploadFileFn(Action`3<HttpWebRequest, Stream, string> value);
    public sealed virtual void Dispose();
    public sealed virtual string GetString(HttpWebRequest webReq, string reqBody);
    public sealed virtual Byte[] GetBytes(HttpWebRequest webReq, Byte[] reqBody);
    public sealed virtual void UploadStream(HttpWebRequest webRequest, Stream fileStream, string fileName);
}
public static class ServiceStack.HttpStatus : object {
    private static String[][] Descriptions;
    private static HttpStatus();
    public static string GetStatusDescription(int statusCode);
}
[ExtensionAttribute]
public static class ServiceStack.HttpUtils : object {
    public static string UserAgent;
    [CompilerGeneratedAttribute]
private static Encoding <UseEncoding>k__BackingField;
    [ThreadStaticAttribute]
public static IHttpResultsFilter ResultsFilter;
    public static Encoding UseEncoding { get; public set; }
    private static HttpUtils();
    [CompilerGeneratedAttribute]
public static Encoding get_UseEncoding();
    [CompilerGeneratedAttribute]
public static void set_UseEncoding(Encoding value);
    [ExtensionAttribute]
public static string AddQueryParam(string url, string key, object val, bool encode);
    [ExtensionAttribute]
public static string AddQueryParam(string url, object key, string val, bool encode);
    [ExtensionAttribute]
public static string AddQueryParam(string url, string key, string val, bool encode);
    [ExtensionAttribute]
public static string SetQueryParam(string url, string key, string val);
    [ExtensionAttribute]
public static string AddHashParam(string url, string key, object val);
    [ExtensionAttribute]
public static string AddHashParam(string url, string key, string val);
    [ExtensionAttribute]
public static string SetHashParam(string url, string key, string val);
    public static bool HasRequestBody(string httpMethod);
    [ExtensionAttribute]
public static string GetJsonFromUrl(string url, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> GetJsonFromUrlAsync(string url, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string GetXmlFromUrl(string url, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> GetXmlFromUrlAsync(string url, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string GetCsvFromUrl(string url, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> GetCsvFromUrlAsync(string url, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string GetStringFromUrl(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> GetStringFromUrlAsync(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PostStringToUrl(string url, string requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PostStringToUrlAsync(string url, string requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PostToUrl(string url, string formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PostToUrlAsync(string url, string formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PostToUrl(string url, object formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PostToUrlAsync(string url, object formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PostJsonToUrl(string url, string json, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PostJsonToUrlAsync(string url, string json, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PostJsonToUrl(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PostJsonToUrlAsync(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PostXmlToUrl(string url, string xml, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PostXmlToUrlAsync(string url, string xml, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PostCsvToUrl(string url, string csv, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PostCsvToUrlAsync(string url, string csv, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PutStringToUrl(string url, string requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PutStringToUrlAsync(string url, string requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PutToUrl(string url, string formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PutToUrlAsync(string url, string formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PutToUrl(string url, object formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PutToUrlAsync(string url, object formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PutJsonToUrl(string url, string json, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PutJsonToUrlAsync(string url, string json, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PutJsonToUrl(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PutJsonToUrlAsync(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PutXmlToUrl(string url, string xml, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PutXmlToUrlAsync(string url, string xml, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PutCsvToUrl(string url, string csv, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PutCsvToUrlAsync(string url, string csv, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PatchStringToUrl(string url, string requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PatchStringToUrlAsync(string url, string requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PatchToUrl(string url, string formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PatchToUrlAsync(string url, string formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PatchToUrl(string url, object formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PatchToUrlAsync(string url, object formData, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PatchJsonToUrl(string url, string json, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PatchJsonToUrlAsync(string url, string json, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string PatchJsonToUrl(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> PatchJsonToUrlAsync(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string DeleteFromUrl(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> DeleteFromUrlAsync(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string OptionsFromUrl(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> OptionsFromUrlAsync(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string HeadFromUrl(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<string> HeadFromUrlAsync(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static string SendStringToUrl(string url, string method, string requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<SendStringToUrlAsync>d__67")]
[ExtensionAttribute]
public static Task`1<string> SendStringToUrlAsync(string url, string method, string requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static Byte[] GetBytesFromUrl(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<Byte[]> GetBytesFromUrlAsync(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static Byte[] PostBytesToUrl(string url, Byte[] requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<Byte[]> PostBytesToUrlAsync(string url, Byte[] requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static Byte[] PutBytesToUrl(string url, Byte[] requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<Byte[]> PutBytesToUrlAsync(string url, Byte[] requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static Byte[] SendBytesToUrl(string url, string method, Byte[] requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<SendBytesToUrlAsync>d__75")]
[ExtensionAttribute]
public static Task`1<Byte[]> SendBytesToUrlAsync(string url, string method, Byte[] requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static Stream GetStreamFromUrl(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<Stream> GetStreamFromUrlAsync(string url, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static Stream PostStreamToUrl(string url, Stream requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<Stream> PostStreamToUrlAsync(string url, Stream requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static Stream PutStreamToUrl(string url, Stream requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static Task`1<Stream> PutStreamToUrlAsync(string url, Stream requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static Stream SendStreamToUrl(string url, string method, Stream requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<SendStreamToUrlAsync>d__83")]
[ExtensionAttribute]
public static Task`1<Stream> SendStreamToUrlAsync(string url, string method, Stream requestBody, string contentType, string accept, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter, CancellationToken token);
    [ExtensionAttribute]
public static bool IsAny300(Exception ex);
    [ExtensionAttribute]
public static bool IsAny400(Exception ex);
    [ExtensionAttribute]
public static bool IsAny500(Exception ex);
    [ExtensionAttribute]
public static bool IsNotModified(Exception ex);
    [ExtensionAttribute]
public static bool IsBadRequest(Exception ex);
    [ExtensionAttribute]
public static bool IsNotFound(Exception ex);
    [ExtensionAttribute]
public static bool IsUnauthorized(Exception ex);
    [ExtensionAttribute]
public static bool IsForbidden(Exception ex);
    [ExtensionAttribute]
public static bool IsInternalServerError(Exception ex);
    [ExtensionAttribute]
public static Nullable`1<HttpStatusCode> GetResponseStatus(string url);
    [ExtensionAttribute]
public static Nullable`1<HttpStatusCode> GetStatus(Exception ex);
    [ExtensionAttribute]
public static Nullable`1<HttpStatusCode> GetStatus(WebException webEx);
    [ExtensionAttribute]
public static bool HasStatus(Exception ex, HttpStatusCode statusCode);
    [ExtensionAttribute]
public static string GetResponseBody(Exception ex);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<GetResponseBodyAsync>d__98")]
[ExtensionAttribute]
public static Task`1<string> GetResponseBodyAsync(Exception ex, CancellationToken token);
    [ExtensionAttribute]
public static string ReadToEnd(WebResponse webRes);
    [ExtensionAttribute]
public static Task`1<string> ReadToEndAsync(WebResponse webRes);
    [IteratorStateMachineAttribute("ServiceStack.HttpUtils/<ReadLines>d__101")]
[ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(WebResponse webRes);
    [ExtensionAttribute]
public static HttpWebResponse GetErrorResponse(string url);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<GetErrorResponseAsync>d__103")]
[ExtensionAttribute]
public static Task`1<HttpWebResponse> GetErrorResponseAsync(string url);
    [ExtensionAttribute]
public static Task`1<Stream> GetRequestStreamAsync(WebRequest request);
    [ExtensionAttribute]
public static Task`1<Stream> GetRequestStreamAsync(HttpWebRequest request);
    [ExtensionAttribute]
public static Task`1<TBase> ConvertTo(Task`1<TDerived> task);
    [ExtensionAttribute]
public static Task`1<WebResponse> GetResponseAsync(WebRequest request);
    [ExtensionAttribute]
public static Task`1<HttpWebResponse> GetResponseAsync(HttpWebRequest request);
    private static Byte[] GetHeaderBytes(string fileName, string mimeType, string field, string boundary);
    [ExtensionAttribute]
public static void UploadFile(WebRequest webRequest, Stream fileStream, string fileName, string mimeType, string accept, Action`1<HttpWebRequest> requestFilter, string method, string field);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<UploadFileAsync>d__111")]
[ExtensionAttribute]
public static Task UploadFileAsync(WebRequest webRequest, Stream fileStream, string fileName, string mimeType, string accept, Action`1<HttpWebRequest> requestFilter, string method, string field, CancellationToken token);
    [ExtensionAttribute]
public static void UploadFile(WebRequest webRequest, Stream fileStream, string fileName);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<UploadFileAsync>d__113")]
[ExtensionAttribute]
public static Task UploadFileAsync(WebRequest webRequest, Stream fileStream, string fileName, CancellationToken token);
    [ExtensionAttribute]
public static string PostXmlToUrl(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static string PostCsvToUrl(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static string PutXmlToUrl(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static string PutCsvToUrl(string url, object data, Action`1<HttpWebRequest> requestFilter, Action`1<HttpWebResponse> responseFilter);
    [ExtensionAttribute]
public static WebResponse PostFileToUrl(string url, FileInfo uploadFileInfo, string uploadFileMimeType, string accept, Action`1<HttpWebRequest> requestFilter);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<PostFileToUrlAsync>d__119")]
[ExtensionAttribute]
public static Task`1<WebResponse> PostFileToUrlAsync(string url, FileInfo uploadFileInfo, string uploadFileMimeType, string accept, Action`1<HttpWebRequest> requestFilter, CancellationToken token);
    [ExtensionAttribute]
public static WebResponse PutFileToUrl(string url, FileInfo uploadFileInfo, string uploadFileMimeType, string accept, Action`1<HttpWebRequest> requestFilter);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<PutFileToUrlAsync>d__121")]
[ExtensionAttribute]
public static Task`1<WebResponse> PutFileToUrlAsync(string url, FileInfo uploadFileInfo, string uploadFileMimeType, string accept, Action`1<HttpWebRequest> requestFilter, CancellationToken token);
    [ExtensionAttribute]
public static WebResponse UploadFile(WebRequest webRequest, FileInfo uploadFileInfo, string uploadFileMimeType);
    [AsyncStateMachineAttribute("ServiceStack.HttpUtils/<UploadFileAsync>d__123")]
[ExtensionAttribute]
public static Task`1<WebResponse> UploadFileAsync(WebRequest webRequest, FileInfo uploadFileInfo, string uploadFileMimeType);
}
public interface ServiceStack.IDynamicNumber {
    public Type Type { get; }
    public object DefaultValue { get; }
    public abstract virtual Type get_Type();
    public abstract virtual object ConvertFrom(object value);
    public abstract virtual bool TryParse(string str, Object& result);
    public abstract virtual string ToString(object value);
    public abstract virtual object get_DefaultValue();
    public abstract virtual object add(object lhs, object rhs);
    public abstract virtual object sub(object lhs, object rhs);
    public abstract virtual object mul(object lhs, object rhs);
    public abstract virtual object div(object lhs, object rhs);
    public abstract virtual object mod(object lhs, object rhs);
    public abstract virtual object pow(object lhs, object rhs);
    public abstract virtual object log(object lhs, object rhs);
    public abstract virtual object min(object lhs, object rhs);
    public abstract virtual object max(object lhs, object rhs);
    public abstract virtual int compareTo(object lhs, object rhs);
    public abstract virtual object bitwiseAnd(object lhs, object rhs);
    public abstract virtual object bitwiseOr(object lhs, object rhs);
    public abstract virtual object bitwiseXOr(object lhs, object rhs);
    public abstract virtual object bitwiseLeftShift(object lhs, object rhs);
    public abstract virtual object bitwiseRightShift(object lhs, object rhs);
    public abstract virtual object bitwiseNot(object target);
}
public interface ServiceStack.IHasStatusCode {
    public int StatusCode { get; }
    public abstract virtual int get_StatusCode();
}
public interface ServiceStack.IHasStatusDescription {
    public string StatusDescription { get; }
    public abstract virtual string get_StatusDescription();
}
public interface ServiceStack.IHttpResultsFilter {
    public abstract virtual string GetString(HttpWebRequest webReq, string reqBody);
    public abstract virtual Byte[] GetBytes(HttpWebRequest webReq, Byte[] reqBody);
    public abstract virtual void UploadStream(HttpWebRequest webRequest, Stream fileStream, string fileName);
}
public class ServiceStack.KeyValuePairs : List`1<KeyValuePair`2<string, object>> {
    public KeyValuePairs(int capacity);
    public KeyValuePairs(IEnumerable`1<KeyValuePair`2<string, object>> collection);
    public static KeyValuePair`2<string, object> Create(string key, object value);
}
public class ServiceStack.KeyValueStrings : List`1<KeyValuePair`2<string, string>> {
    public KeyValueStrings(int capacity);
    public KeyValueStrings(IEnumerable`1<KeyValuePair`2<string, string>> collection);
    public static KeyValuePair`2<string, string> Create(string key, string value);
}
public class ServiceStack.LicenseException : Exception {
    public LicenseException(string message);
    public LicenseException(string message, Exception innerException);
}
[FlagsAttribute]
public enum ServiceStack.LicenseFeature : Enum {
    public long value__;
    public static LicenseFeature None;
    public static LicenseFeature All;
    public static LicenseFeature RedisSku;
    public static LicenseFeature OrmLiteSku;
    public static LicenseFeature AwsSku;
    public static LicenseFeature Free;
    public static LicenseFeature Premium;
    public static LicenseFeature Text;
    public static LicenseFeature Client;
    public static LicenseFeature Common;
    public static LicenseFeature Redis;
    public static LicenseFeature OrmLite;
    public static LicenseFeature ServiceStack;
    public static LicenseFeature Server;
    public static LicenseFeature Razor;
    public static LicenseFeature Admin;
    public static LicenseFeature Aws;
}
public class ServiceStack.LicenseKey : object {
    [CompilerGeneratedAttribute]
private string <Ref>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Meta>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expiry>k__BackingField;
    public string Ref { get; public set; }
    public string Name { get; public set; }
    public LicenseType Type { get; public set; }
    public long Meta { get; public set; }
    public string Hash { get; public set; }
    public DateTime Expiry { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Ref();
    [CompilerGeneratedAttribute]
public void set_Ref(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public LicenseType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(LicenseType value);
    [CompilerGeneratedAttribute]
public long get_Meta();
    [CompilerGeneratedAttribute]
public void set_Meta(long value);
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public void set_Hash(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Expiry();
    [CompilerGeneratedAttribute]
public void set_Expiry(DateTime value);
}
[FlagsAttribute]
public enum ServiceStack.LicenseMeta : Enum {
    public long value__;
    public static LicenseMeta None;
    public static LicenseMeta Subscription;
    public static LicenseMeta Cores;
}
public enum ServiceStack.LicenseType : Enum {
    public int value__;
    public static LicenseType Free;
    public static LicenseType Indie;
    public static LicenseType Business;
    public static LicenseType Enterprise;
    public static LicenseType TextIndie;
    public static LicenseType TextBusiness;
    public static LicenseType OrmLiteIndie;
    public static LicenseType OrmLiteBusiness;
    public static LicenseType RedisIndie;
    public static LicenseType RedisBusiness;
    public static LicenseType AwsIndie;
    public static LicenseType AwsBusiness;
    public static LicenseType Trial;
    public static LicenseType Site;
    public static LicenseType TextSite;
    public static LicenseType RedisSite;
    public static LicenseType OrmLiteSite;
}
[ExtensionAttribute]
public static class ServiceStack.LicenseUtils : object {
    public static string RuntimePublicKey;
    public static string LicensePublicKey;
    private static string ContactDetails;
    [CompilerGeneratedAttribute]
private static bool <HasInit>k__BackingField;
    private static Int32[] revokedSubs;
    [CompilerGeneratedAttribute]
private static string <LicenseWarningMessage>k__BackingField;
    private static __ActivatedLicense __activatedLicense;
    public static bool HasInit { get; private set; }
    public static string LicenseWarningMessage { get; private set; }
    private static LicenseUtils();
    [CompilerGeneratedAttribute]
public static bool get_HasInit();
    [CompilerGeneratedAttribute]
private static void set_HasInit(bool value);
    public static void Init();
    public static void AssertEvaluationLicense();
    [CompilerGeneratedAttribute]
public static string get_LicenseWarningMessage();
    [CompilerGeneratedAttribute]
private static void set_LicenseWarningMessage(string value);
    private static string GetLicenseWarningMessage();
    public static void RegisterLicense(string licenseKeyText);
    private static void ValidateLicenseKey(LicenseKey key);
    public static void RemoveLicense();
    public static LicenseFeature ActivatedLicenseFeatures();
    public static void ApprovedUsage(LicenseFeature licenseFeature, LicenseFeature requestedFeature, int allowedUsage, int actualUsage, string message);
    public static bool HasLicensedFeature(LicenseFeature feature);
    public static void AssertValidUsage(LicenseFeature feature, QuotaType quotaType, int count);
    [ExtensionAttribute]
public static LicenseFeature GetLicensedFeatures(LicenseKey key);
    [ExtensionAttribute]
public static LicenseKey ToLicenseKey(string licenseKeyText);
    [ExtensionAttribute]
public static LicenseKey ToLicenseKeyFallback(string licenseKeyText);
    [ExtensionAttribute]
public static string GetHashKeyToSign(LicenseKey key);
    [ExtensionAttribute]
public static Exception GetInnerMostException(Exception ex);
    public static bool VerifySignedHash(Byte[] DataToVerify, Byte[] SignedData, RSAParameters Key);
    public static LicenseKey VerifyLicenseKeyText(string licenseKeyText);
    [ExtensionAttribute]
private static void FromXml(RSA rsa, string xml);
    [ExtensionAttribute]
public static bool VerifyLicenseKeyText(string licenseKeyText, LicenseKey& key);
    [ExtensionAttribute]
public static bool VerifyLicenseKeyTextFallback(string licenseKeyText, LicenseKey& key);
    [ExtensionAttribute]
public static bool VerifySha1Data(RSACryptoServiceProvider RSAalg, Byte[] unsignedData, Byte[] encryptedData);
}
public static class ServiceStack.Licensing : object {
    public static void RegisterLicense(string licenseKeyText);
    public static void RegisterLicenseFromFile(string filePath);
    public static void RegisterLicenseFromFileIfExists(string filePath);
}
[ExtensionAttribute]
public static class ServiceStack.ListExtensions : object {
    [ExtensionAttribute]
public static string Join(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<T> values, string seperator);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(List`1<T> list);
    [ExtensionAttribute]
public static IEnumerable`1<TFrom> SafeWhere(List`1<TFrom> list, Func`2<TFrom, bool> predicate);
    [ExtensionAttribute]
public static int NullableCount(List`1<T> list);
    [ExtensionAttribute]
public static void AddIfNotExists(List`1<T> list, T item);
    [ExtensionAttribute]
public static T[] NewArray(T[] array, T with, T without);
    [ExtensionAttribute]
public static List`1<T> InList(T value);
    [ExtensionAttribute]
public static T[] InArray(T value);
    [ExtensionAttribute]
public static List`1<Type> Add(List`1<Type> types);
}
[ExtensionAttribute]
public static class ServiceStack.MapExtensions : object {
    [ExtensionAttribute]
public static string Join(Dictionary`2<K, V> values);
    [ExtensionAttribute]
public static string Join(Dictionary`2<K, V> values, string itemSeperator, string keySeperator);
}
public static class ServiceStack.MimeTypes : object {
    public static Dictionary`2<string, string> ExtensionMimeTypes;
    public static string Utf8Suffix;
    public static string Html;
    public static string HtmlUtf8;
    public static string Css;
    public static string Xml;
    public static string XmlText;
    public static string Json;
    public static string ProblemJson;
    public static string JsonText;
    public static string Jsv;
    public static string JsvText;
    public static string Csv;
    public static string ProtoBuf;
    public static string JavaScript;
    public static string WebAssembly;
    public static string Jar;
    public static string Dmg;
    public static string Pkg;
    public static string FormUrlEncoded;
    public static string MultiPartFormData;
    public static string JsonReport;
    public static string Soap11;
    public static string Soap12;
    public static string Yaml;
    public static string YamlText;
    public static string PlainText;
    public static string MarkdownText;
    public static string MsgPack;
    public static string Wire;
    public static string Compressed;
    public static string NetSerializer;
    public static string Excel;
    public static string MsWord;
    public static string Cert;
    public static string ImagePng;
    public static string ImageGif;
    public static string ImageJpg;
    public static string ImageSvg;
    public static string Bson;
    public static string Binary;
    public static string ServerSentEvents;
    [CompilerGeneratedAttribute]
private static Func`2<string, Nullable`1<bool>> <IsBinaryFilter>k__BackingField;
    public static Func`2<string, Nullable`1<bool>> IsBinaryFilter { get; public set; }
    private static MimeTypes();
    public static string GetExtension(string mimeType);
    public static string GetRealContentType(string contentType);
    public static bool MatchesContentType(string contentType, string matchesContentType);
    [CompilerGeneratedAttribute]
public static Func`2<string, Nullable`1<bool>> get_IsBinaryFilter();
    [CompilerGeneratedAttribute]
public static void set_IsBinaryFilter(Func`2<string, Nullable`1<bool>> value);
    public static bool IsBinary(string contentType);
    public static string GetMimeType(string fileNameOrExt);
}
public class ServiceStack.Net45PclExport : PclExport {
    public static Net45PclExport Provider;
    public static string AppSettingsKey;
    public static string EnvironmentKey;
    private static Net45PclExport();
    public static PclExport Configure();
    public virtual string ReadAllText(string filePath);
    public virtual string ToInvariantUpper(char value);
    public virtual bool IsAnonymousType(Type type);
    public virtual bool FileExists(string filePath);
    public virtual bool DirectoryExists(string dirPath);
    public virtual void CreateDirectory(string dirPath);
    public virtual String[] GetFileNames(string dirPath, string searchPattern);
    public virtual String[] GetDirectoryNames(string dirPath, string searchPattern);
    public virtual void RegisterLicenseFromConfig();
    public virtual string GetEnvironmentVariable(string name);
    public virtual void WriteLine(string line);
    public virtual void WriteLine(string format, Object[] args);
    [AsyncStateMachineAttribute("ServiceStack.Net45PclExport/<WriteAndFlushAsync>d__17")]
public virtual Task WriteAndFlushAsync(Stream stream, Byte[] bytes);
    public virtual void AddCompression(WebRequest webReq);
    public virtual Stream GetRequestStream(WebRequest webRequest);
    public virtual WebResponse GetResponse(WebRequest webRequest);
    public virtual bool IsDebugBuild(Assembly assembly);
    public virtual string MapAbsolutePath(string relativePath, string appendPartialPathModifier);
    public virtual Assembly LoadAssembly(string assemblyPath);
    public virtual void AddHeader(WebRequest webReq, string name, string value);
    public virtual Assembly[] GetAllAssemblies();
    public virtual Type FindType(string typeName, string assemblyName);
    public virtual string GetAssemblyCodeBase(Assembly assembly);
    public virtual string GetAssemblyPath(Type source);
    public virtual string GetAsciiString(Byte[] bytes, int index, int count);
    public virtual Byte[] GetAsciiBytes(string str);
    public virtual bool InSameAssembly(Type t1, Type t2);
    public virtual Type GetGenericCollectionType(Type type);
    public virtual string ToXsdDateTimeString(DateTime dateTime);
    public virtual string ToLocalXsdDateTimeString(DateTime dateTime);
    public virtual DateTime ParseXsdDateTime(string dateTimeStr);
    public virtual DateTime ParseXsdDateTimeAsUtc(string dateTimeStr);
    public virtual DateTime ToStableUniversalTime(DateTime dateTime);
    public virtual ParseStringDelegate GetDictionaryParseMethod(Type type);
    public virtual ParseStringSpanDelegate GetDictionaryParseStringSpanMethod(Type type);
    public virtual ParseStringDelegate GetSpecializedCollectionParseMethod(Type type);
    public virtual ParseStringSpanDelegate GetSpecializedCollectionParseStringSpanMethod(Type type);
    public virtual ParseStringDelegate GetJsReaderParseMethod(Type type);
    public virtual ParseStringSpanDelegate GetJsReaderParseStringSpanMethod(Type type);
    public virtual void InitHttpWebRequest(HttpWebRequest httpReq, Nullable`1<long> contentLength, bool allowAutoRedirect, bool keepAlive);
    public virtual void CloseStream(Stream stream);
    public virtual LicenseKey VerifyLicenseKeyText(string licenseKeyText);
    public virtual void BeginThreadAffinity();
    public virtual void EndThreadAffinity();
    public virtual void Config(HttpWebRequest req, Nullable`1<bool> allowAutoRedirect, Nullable`1<TimeSpan> timeout, Nullable`1<TimeSpan> readWriteTimeout, string userAgent, Nullable`1<bool> preAuthenticate);
    public virtual void SetUserAgent(HttpWebRequest httpReq, string value);
    public virtual void SetContentLength(HttpWebRequest httpReq, long value);
    public virtual void SetAllowAutoRedirect(HttpWebRequest httpReq, bool value);
    public virtual void SetKeepAlive(HttpWebRequest httpReq, bool value);
    public virtual string GetStackTrace();
    public virtual DataContractAttribute GetWeakDataContract(Type type);
    public virtual DataMemberAttribute GetWeakDataMember(PropertyInfo pi);
    public virtual DataMemberAttribute GetWeakDataMember(FieldInfo pi);
}
public class ServiceStack.ObjectDictionary : Dictionary`2<string, object> {
    public ObjectDictionary(int capacity);
    public ObjectDictionary(IEqualityComparer`1<string> comparer);
    public ObjectDictionary(int capacity, IEqualityComparer`1<string> comparer);
    public ObjectDictionary(IDictionary`2<string, object> dictionary);
    public ObjectDictionary(IDictionary`2<string, object> dictionary, IEqualityComparer`1<string> comparer);
    protected ObjectDictionary(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class ServiceStack.PathUtils : object {
    private static Char[] Slashes;
    private static PathUtils();
    [ExtensionAttribute]
public static string MapAbsolutePath(string relativePath, string appendPartialPathModifier);
    [ExtensionAttribute]
public static string MapProjectPath(string relativePath);
    [ExtensionAttribute]
public static string MapProjectPlatformPath(string relativePath);
    [ExtensionAttribute]
public static string MapAbsolutePath(string relativePath);
    [ExtensionAttribute]
public static string MapHostAbsolutePath(string relativePath);
    internal static string CombinePaths(StringBuilder sb, String[] paths);
    public static void AppendPaths(StringBuilder sb, String[] paths);
    public static string CombinePaths(String[] paths);
    [ExtensionAttribute]
public static string AssertDir(string dirPath);
    [ExtensionAttribute]
private static string TrimEndIf(string path, Char[] chars);
    [ExtensionAttribute]
public static string CombineWith(string path, string withPath);
    [ExtensionAttribute]
public static string CombineWith(string path, String[] thesePaths);
    [ExtensionAttribute]
public static string CombineWith(string path, Object[] thesePaths);
    [ExtensionAttribute]
public static string ResolvePaths(string path);
    public static String[] ToStrings(Object[] thesePaths);
    internal static List`1<To> Map(IEnumerable items, Func`2<object, To> converter);
}
public abstract class ServiceStack.PclExport : object {
    public static PclExport Instance;
    public Task EmptyTask;
    public char DirSep;
    public char AltDirSep;
    public static Char[] DirSeps;
    public string PlatformName;
    public RegexOptions RegexOptions;
    public StringComparison InvariantComparison;
    public StringComparison InvariantComparisonIgnoreCase;
    public StringComparer InvariantComparer;
    public StringComparer InvariantComparerIgnoreCase;
    public static ReflectionOptimizer Reflection { get; }
    private static PclExport();
    public static ReflectionOptimizer get_Reflection();
    public static bool ConfigureProvider(string typeName);
    public static void Configure(PclExport instance);
    public abstract virtual string ReadAllText(string filePath);
    public virtual bool IsAnonymousType(Type type);
    public virtual string ToInvariantUpper(char value);
    public virtual bool FileExists(string filePath);
    public virtual bool DirectoryExists(string dirPath);
    public virtual void CreateDirectory(string dirPath);
    public virtual void RegisterLicenseFromConfig();
    public virtual string GetEnvironmentVariable(string name);
    public virtual String[] GetFileNames(string dirPath, string searchPattern);
    public virtual String[] GetDirectoryNames(string dirPath, string searchPattern);
    public virtual void WriteLine(string line);
    public virtual void WriteLine(string line, Object[] args);
    public virtual HttpWebRequest CreateWebRequest(string requestUri, Nullable`1<bool> emulateHttpViaPost);
    public virtual void Config(HttpWebRequest req, Nullable`1<bool> allowAutoRedirect, Nullable`1<TimeSpan> timeout, Nullable`1<TimeSpan> readWriteTimeout, string userAgent, Nullable`1<bool> preAuthenticate);
    public virtual void AddCompression(WebRequest webRequest);
    public virtual Stream GetRequestStream(WebRequest webRequest);
    public virtual WebResponse GetResponse(WebRequest webRequest);
    public virtual Task`1<WebResponse> GetResponseAsync(WebRequest webRequest);
    public virtual bool IsDebugBuild(Assembly assembly);
    public virtual string MapAbsolutePath(string relativePath, string appendPartialPathModifier);
    public virtual Assembly LoadAssembly(string assemblyPath);
    public virtual void AddHeader(WebRequest webReq, string name, string value);
    public virtual void SetUserAgent(HttpWebRequest httpReq, string value);
    public virtual void SetContentLength(HttpWebRequest httpReq, long value);
    public virtual void SetAllowAutoRedirect(HttpWebRequest httpReq, bool value);
    public virtual void SetKeepAlive(HttpWebRequest httpReq, bool value);
    public virtual Assembly[] GetAllAssemblies();
    public virtual Type FindType(string typeName, string assemblyName);
    public virtual string GetAssemblyCodeBase(Assembly assembly);
    public virtual string GetAssemblyPath(Type source);
    public virtual string GetAsciiString(Byte[] bytes);
    public virtual string GetAsciiString(Byte[] bytes, int index, int count);
    public virtual Byte[] GetAsciiBytes(string str);
    public virtual Encoding GetUTF8Encoding(bool emitBom);
    [ObsoleteAttribute("ReflectionOptimizer.CreateGetter")]
public GetMemberDelegate CreateGetter(PropertyInfo propertyInfo);
    [ObsoleteAttribute("ReflectionOptimizer.CreateGetter")]
public GetMemberDelegate`1<T> CreateGetter(PropertyInfo propertyInfo);
    [ObsoleteAttribute("ReflectionOptimizer.CreateSetter")]
public SetMemberDelegate CreateSetter(PropertyInfo propertyInfo);
    [ObsoleteAttribute("ReflectionOptimizer.CreateSetter")]
public SetMemberDelegate`1<T> CreateSetter(PropertyInfo propertyInfo);
    [ObsoleteAttribute("ReflectionOptimizer.CreateGetter")]
public virtual GetMemberDelegate CreateGetter(FieldInfo fieldInfo);
    [ObsoleteAttribute("ReflectionOptimizer.CreateGetter")]
public virtual GetMemberDelegate`1<T> CreateGetter(FieldInfo fieldInfo);
    [ObsoleteAttribute("ReflectionOptimizer.CreateSetter")]
public virtual SetMemberDelegate CreateSetter(FieldInfo fieldInfo);
    [ObsoleteAttribute("ReflectionOptimizer.CreateSetter")]
public virtual SetMemberDelegate`1<T> CreateSetter(FieldInfo fieldInfo);
    public virtual bool InSameAssembly(Type t1, Type t2);
    public virtual Type GetGenericCollectionType(Type type);
    public virtual string ToXsdDateTimeString(DateTime dateTime);
    public virtual string ToLocalXsdDateTimeString(DateTime dateTime);
    public virtual DateTime ParseXsdDateTime(string dateTimeStr);
    public virtual DateTime ParseXsdDateTimeAsUtc(string dateTimeStr);
    public virtual DateTime ToStableUniversalTime(DateTime dateTime);
    public virtual ParseStringDelegate GetDictionaryParseMethod(Type type);
    public virtual ParseStringSpanDelegate GetDictionaryParseStringSpanMethod(Type type);
    public virtual ParseStringDelegate GetSpecializedCollectionParseMethod(Type type);
    public virtual ParseStringSpanDelegate GetSpecializedCollectionParseStringSpanMethod(Type type);
    public virtual ParseStringDelegate GetJsReaderParseMethod(Type type);
    public virtual ParseStringSpanDelegate GetJsReaderParseStringSpanMethod(Type type);
    public virtual void InitHttpWebRequest(HttpWebRequest httpReq, Nullable`1<long> contentLength, bool allowAutoRedirect, bool keepAlive);
    public virtual void CloseStream(Stream stream);
    public virtual void ResetStream(Stream stream);
    public virtual LicenseKey VerifyLicenseKeyText(string licenseKeyText);
    public virtual LicenseKey VerifyLicenseKeyTextFallback(string licenseKeyText);
    public virtual void BeginThreadAffinity();
    public virtual void EndThreadAffinity();
    public virtual DataContractAttribute GetWeakDataContract(Type type);
    public virtual DataMemberAttribute GetWeakDataMember(PropertyInfo pi);
    public virtual DataMemberAttribute GetWeakDataMember(FieldInfo pi);
    public virtual void RegisterForAot();
    public virtual string GetStackTrace();
    public virtual Task WriteAndFlushAsync(Stream stream, Byte[] bytes);
}
[ExtensionAttribute]
public static class ServiceStack.PclExportExt : object {
    private static string DataContract;
    public static void CompressToStream(TXmlDto from, Stream stream);
    public static Byte[] Compress(TXmlDto from);
    [ExtensionAttribute]
public static DataContractAttribute GetWeakDataContract(Type type);
    [ExtensionAttribute]
public static DataMemberAttribute GetWeakDataMember(PropertyInfo pi);
    [ExtensionAttribute]
public static DataMemberAttribute GetWeakDataMember(FieldInfo pi);
}
[ExtensionAttribute]
public static class ServiceStack.PlatformExtensions : object {
    private static ConcurrentDictionary`2<Tuple`2<MemberInfo, Type>, bool> hasAttributeCache;
    private static ConcurrentDictionary`2<Tuple`2<MemberInfo, Type>, bool> hasAttributeOfCache;
    private static string DataContract;
    private static Dictionary`2<string, List`1<Attribute>> propertyAttributesMap;
    private static Dictionary`2<Type, List`1<Attribute>> typeAttributesMap;
    private static Dictionary`2<string, Type> GenericTypeCache;
    private static ConcurrentDictionary`2<Type, ObjectDictionaryDefinition> toObjectMapCache;
    private static PlatformExtensions();
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsInterface")]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsArray")]
public static bool IsArray(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsValueType")]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsGenericType")]
public static bool IsGeneric(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.BaseType")]
public static Type BaseType(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use pi.ReflectedType")]
public static Type ReflectedType(PropertyInfo pi);
    [ExtensionAttribute]
[ObsoleteAttribute("Use fi.ReflectedType")]
public static Type ReflectedType(FieldInfo fi);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetGenericTypeDefinition()")]
public static Type GenericTypeDefinition(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetInterfaces()")]
public static Type[] GetTypeInterfaces(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetGenericArguments()")]
public static Type[] GetTypeGenericArguments(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetConstructor(Type.EmptyTypes)")]
public static ConstructorInfo GetEmptyConstructor(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetConstructors()")]
public static IEnumerable`1<ConstructorInfo> GetAllConstructors(Type type);
    [ExtensionAttribute]
internal static PropertyInfo[] GetTypesPublicProperties(Type subType);
    [ExtensionAttribute]
internal static PropertyInfo[] GetTypesProperties(Type subType);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.Assembly")]
public static Assembly GetAssembly(Type type);
    [ExtensionAttribute]
public static FieldInfo[] Fields(Type type);
    [ExtensionAttribute]
public static PropertyInfo[] Properties(Type type);
    [ExtensionAttribute]
public static FieldInfo[] GetAllFields(Type type);
    [ExtensionAttribute]
public static FieldInfo[] GetPublicFields(Type type);
    [ExtensionAttribute]
public static MemberInfo[] GetPublicMembers(Type type);
    [ExtensionAttribute]
public static MemberInfo[] GetAllPublicMembers(Type type);
    [ExtensionAttribute]
public static MethodInfo GetStaticMethod(Type type, string methodName);
    [ExtensionAttribute]
public static MethodInfo GetInstanceMethod(Type type, string methodName);
    [ExtensionAttribute]
[ObsoleteAttribute("Use fn.Method")]
public static MethodInfo Method(Delegate fn);
    [ExtensionAttribute]
public static bool HasAttribute(Type type);
    [ExtensionAttribute]
public static bool HasAttributeOf(Type type);
    [ExtensionAttribute]
public static bool HasAttribute(PropertyInfo pi);
    [ExtensionAttribute]
public static bool HasAttributeOf(PropertyInfo pi);
    [ExtensionAttribute]
public static bool HasAttribute(FieldInfo fi);
    [ExtensionAttribute]
public static bool HasAttributeOf(FieldInfo fi);
    [ExtensionAttribute]
public static bool HasAttribute(MethodInfo mi);
    [ExtensionAttribute]
public static bool HasAttributeOf(MethodInfo mi);
    [ExtensionAttribute]
public static bool HasAttributeCached(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool HasAttributeOfCached(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool HasAttributeNamed(Type type, string name);
    [ExtensionAttribute]
public static bool HasAttributeNamed(PropertyInfo pi, string name);
    [ExtensionAttribute]
public static bool HasAttributeNamed(FieldInfo fi, string name);
    [ExtensionAttribute]
public static bool HasAttributeNamed(MemberInfo mi, string name);
    [ExtensionAttribute]
public static bool IsDto(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use pi.GetGetMethod(nonPublic)")]
public static MethodInfo PropertyGetMethod(PropertyInfo pi, bool nonPublic);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetInterfaces()")]
public static Type[] Interfaces(Type type);
    [ExtensionAttribute]
public static PropertyInfo[] AllProperties(Type type);
    public static void ClearRuntimeAttributes();
    [ExtensionAttribute]
internal static string UniqueKey(PropertyInfo pi);
    [ExtensionAttribute]
public static Type AddAttributes(Type type, Attribute[] attrs);
    [ExtensionAttribute]
public static PropertyInfo AddAttributes(PropertyInfo propertyInfo, Attribute[] attrs);
    [ExtensionAttribute]
public static PropertyInfo ReplaceAttribute(PropertyInfo propertyInfo, Attribute attr);
    [ExtensionAttribute]
public static List`1<TAttr> GetAttributes(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static List`1<Attribute> GetAttributes(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static List`1<Attribute> GetAttributes(PropertyInfo propertyInfo, Type attrType);
    [ExtensionAttribute]
public static Object[] AllAttributes(PropertyInfo propertyInfo);
    [IteratorStateMachineAttribute("ServiceStack.PlatformExtensions/<AllAttributesLazy>d__56")]
[ExtensionAttribute]
public static IEnumerable`1<object> AllAttributesLazy(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static Object[] AllAttributes(PropertyInfo propertyInfo, Type attrType);
    [IteratorStateMachineAttribute("ServiceStack.PlatformExtensions/<AllAttributesLazy>d__58")]
[ExtensionAttribute]
public static IEnumerable`1<object> AllAttributesLazy(PropertyInfo propertyInfo, Type attrType);
    [ExtensionAttribute]
public static Object[] AllAttributes(ParameterInfo paramInfo);
    [ExtensionAttribute]
public static Object[] AllAttributes(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static Object[] AllAttributes(MemberInfo memberInfo);
    [ExtensionAttribute]
public static Object[] AllAttributes(ParameterInfo paramInfo, Type attrType);
    [ExtensionAttribute]
public static Object[] AllAttributes(MemberInfo memberInfo, Type attrType);
    [ExtensionAttribute]
public static Object[] AllAttributes(FieldInfo fieldInfo, Type attrType);
    [ExtensionAttribute]
public static Object[] AllAttributes(Type type);
    [IteratorStateMachineAttribute("ServiceStack.PlatformExtensions/<AllAttributesLazy>d__66")]
[ExtensionAttribute]
public static IEnumerable`1<object> AllAttributesLazy(Type type);
    [ExtensionAttribute]
public static Object[] AllAttributes(Type type, Type attrType);
    [ExtensionAttribute]
public static Object[] AllAttributes(Assembly assembly);
    [ExtensionAttribute]
public static TAttr[] AllAttributes(ParameterInfo pi);
    [ExtensionAttribute]
public static TAttr[] AllAttributes(MemberInfo mi);
    [ExtensionAttribute]
public static TAttr[] AllAttributes(FieldInfo fi);
    [ExtensionAttribute]
public static TAttr[] AllAttributes(PropertyInfo pi);
    [ExtensionAttribute]
public static IEnumerable`1<TAttr> AllAttributesLazy(PropertyInfo pi);
    [ExtensionAttribute]
private static IEnumerable`1<T> GetRuntimeAttributes(Type type);
    [ExtensionAttribute]
private static IEnumerable`1<Attribute> GetRuntimeAttributes(Type type, Type attrType);
    [ExtensionAttribute]
public static TAttr[] AllAttributes(Type type);
    [IteratorStateMachineAttribute("ServiceStack.PlatformExtensions/<AllAttributesLazy>d__77`1")]
[ExtensionAttribute]
public static IEnumerable`1<TAttr> AllAttributesLazy(Type type);
    [ExtensionAttribute]
public static TAttr FirstAttribute(Type type);
    [ExtensionAttribute]
public static TAttribute FirstAttribute(MemberInfo memberInfo);
    [ExtensionAttribute]
public static TAttribute FirstAttribute(ParameterInfo paramInfo);
    [ExtensionAttribute]
public static TAttribute FirstAttribute(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static Type FirstGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsDynamic(Assembly assembly);
    [ExtensionAttribute]
public static MethodInfo GetStaticMethod(Type type, string methodName, Type[] types);
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Type type, string methodName, Type[] types);
    [ExtensionAttribute]
public static object InvokeMethod(Delegate fn, object instance, Object[] parameters);
    [ExtensionAttribute]
public static FieldInfo GetPublicStaticField(Type type, string fieldName);
    [ExtensionAttribute]
public static Delegate MakeDelegate(MethodInfo mi, Type delegateType, bool throwOnBindFailure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetGenericArguments()")]
public static Type[] GenericTypeArguments(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetConstructors()")]
public static ConstructorInfo[] DeclaredConstructors(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsAssignableFrom(fromType)")]
public static bool AssignableFrom(Type type, Type fromType);
    [ExtensionAttribute]
public static bool IsStandardClass(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsAbstract")]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetProperty(propertyName)")]
public static PropertyInfo GetPropertyInfo(Type type, string propertyName);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetField(fieldName)")]
public static FieldInfo GetFieldInfo(Type type, string fieldName);
    [ExtensionAttribute]
public static FieldInfo[] GetWritableFields(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use pi.GetSetMethod(nonPublic)")]
public static MethodInfo SetMethod(PropertyInfo pi, bool nonPublic);
    [ExtensionAttribute]
[ObsoleteAttribute("Use pi.GetGetMethod(nonPublic)")]
public static MethodInfo GetMethodInfo(PropertyInfo pi, bool nonPublic);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsInstanceOfType(instance)")]
public static bool InstanceOfType(Type type, object instance);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsAssignableFrom(fromType)")]
public static bool IsAssignableFromType(Type type, Type fromType);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsClass")]
public static bool IsClass(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsEnum")]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsEnumFlags(Type type);
    [ExtensionAttribute]
public static bool IsUnderlyingEnum(Type type);
    [ExtensionAttribute]
public static MethodInfo[] GetInstanceMethods(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetMethods()")]
public static MethodInfo[] GetMethodInfos(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetProperties()")]
public static PropertyInfo[] GetPropertyInfos(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsGenericTypeDefinition")]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.IsGenericType")]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.ContainsGenericParameters")]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static string GetDeclaringTypeName(Type type);
    [ExtensionAttribute]
public static string GetDeclaringTypeName(MemberInfo mi);
    [ExtensionAttribute]
public static Delegate CreateDelegate(MethodInfo methodInfo, Type delegateType);
    [ExtensionAttribute]
public static Delegate CreateDelegate(MethodInfo methodInfo, Type delegateType, object target);
    [ExtensionAttribute]
[ObsoleteAttribute("Use type.GetElementType()")]
public static Type ElementType(Type type);
    [ExtensionAttribute]
public static Type GetCollectionType(Type type);
    [ExtensionAttribute]
public static Type GetCachedGenericType(Type type, Type[] argTypes);
    private static Dictionary`2<string, object> ConvertToDictionary(IEnumerable`1<KeyValuePair`2<string, T>> collection, Func`3<string, object, object> mapper);
    [ExtensionAttribute]
private static Dictionary`2<string, object> MapToDictionary(Func`3<string, object, object> mapper, IEnumerable`1<KeyValuePair`2<string, T>> collection);
    [ExtensionAttribute]
public static Dictionary`2<string, object> ToObjectDictionary(object obj);
    [ExtensionAttribute]
public static Dictionary`2<string, object> ToObjectDictionary(object obj, Func`3<string, object, object> mapper);
    [ExtensionAttribute]
public static Type GetKeyValuePairsTypeDef(Type dictType);
    [ExtensionAttribute]
public static Type GetKeyValuePairTypeDef(Type genericEnumType);
    [ExtensionAttribute]
public static bool GetKeyValuePairsTypes(Type dictType, Type& keyType, Type& valueType);
    [ExtensionAttribute]
public static bool GetKeyValuePairsTypes(Type dictType, Type& keyType, Type& valueType, Type& kvpType);
    [ExtensionAttribute]
public static bool GetKeyValuePairTypes(Type kvpType, Type& keyType, Type& valueType);
    [ExtensionAttribute]
public static object FromObjectDictionary(IEnumerable`1<KeyValuePair`2<string, object>> values, Type type);
    [ExtensionAttribute]
public static void PopulateInstance(IEnumerable`1<KeyValuePair`2<string, object>> values, object instance);
    private static void PopulateInstanceInternal(IEnumerable`1<KeyValuePair`2<string, object>> values, object to, Type type);
    [ExtensionAttribute]
public static void PopulateInstance(IEnumerable`1<KeyValuePair`2<string, string>> values, object instance);
    private static void PopulateInstanceInternal(IEnumerable`1<KeyValuePair`2<string, string>> values, object to, Type type);
    [ExtensionAttribute]
public static T FromObjectDictionary(IEnumerable`1<KeyValuePair`2<string, object>> values);
    private static ObjectDictionaryDefinition CreateObjectDictionaryDefinition(Type type);
    [ExtensionAttribute]
public static Dictionary`2<string, object> ToSafePartialObjectDictionary(T instance);
    [ExtensionAttribute]
public static Dictionary`2<string, object> MergeIntoObjectDictionary(object obj, Object[] sources);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToStringDictionary(IEnumerable`1<KeyValuePair`2<string, object>> from);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToStringDictionary(IEnumerable`1<KeyValuePair`2<string, object>> from, IEqualityComparer`1<string> comparer);
}
public class ServiceStack.PopulateMemberDelegate : MulticastDelegate {
    public PopulateMemberDelegate(object object, IntPtr method);
    public virtual void Invoke(object target, object source);
    public virtual IAsyncResult BeginInvoke(object target, object source, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ServiceStack.PropertyAccessor : object {
    [CompilerGeneratedAttribute]
private PropertyInfo <PropertyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private GetMemberDelegate <PublicGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private SetMemberDelegate <PublicSetter>k__BackingField;
    public PropertyInfo PropertyInfo { get; }
    public GetMemberDelegate PublicGetter { get; }
    public SetMemberDelegate PublicSetter { get; }
    public PropertyAccessor(PropertyInfo propertyInfo, GetMemberDelegate publicGetter, SetMemberDelegate publicSetter);
    [CompilerGeneratedAttribute]
public PropertyInfo get_PropertyInfo();
    [CompilerGeneratedAttribute]
public GetMemberDelegate get_PublicGetter();
    [CompilerGeneratedAttribute]
public SetMemberDelegate get_PublicSetter();
}
[ExtensionAttribute]
public static class ServiceStack.PropertyInvoker : object {
    [ExtensionAttribute]
public static GetMemberDelegate CreateGetter(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static GetMemberDelegate`1<T> CreateGetter(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static SetMemberDelegate CreateSetter(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static SetMemberDelegate`1<T> CreateSetter(PropertyInfo propertyInfo);
}
internal class ServiceStack.PropertyTypeConfig : object {
    public TypeConfig TypeConfig;
    public Action`3<string, TextWriter, object> WriteFn;
}
internal class ServiceStack.PropertyTypeConfig`1 : object {
    public static PropertyTypeConfig Config;
    private static PropertyTypeConfig`1();
}
public static class ServiceStack.QueryStringSerializer : object {
    internal static JsWriter`1<JsvTypeSerializer> Instance;
    private static Dictionary`2<Type, WriteObjectDelegate> WriteFnCache;
    [CompilerGeneratedAttribute]
private static WriteComplexTypeDelegate <ComplexTypeStrategy>k__BackingField;
    public static WriteComplexTypeDelegate ComplexTypeStrategy { get; public set; }
    private static QueryStringSerializer();
    [CompilerGeneratedAttribute]
public static WriteComplexTypeDelegate get_ComplexTypeStrategy();
    [CompilerGeneratedAttribute]
public static void set_ComplexTypeStrategy(WriteComplexTypeDelegate value);
    internal static WriteObjectDelegate GetWriteFn(Type type);
    public static void WriteLateBoundObject(TextWriter writer, object value);
    internal static WriteObjectDelegate GetValueTypeToStringMethod(Type type);
    public static string SerializeToString(T value);
    public static void InitAot();
}
public static class ServiceStack.QueryStringStrategy : object {
    private static ConcurrentDictionary`2<Type, PropertyTypeConfig> typeConfigCache;
    private static QueryStringStrategy();
    public static bool FormUrlEncoded(TextWriter writer, string propertyName, object obj);
}
public static class ServiceStack.QueryStringWriter`1 : object {
    private static WriteObjectDelegate CacheFn;
    private static ITypeSerializer Serializer;
    private static QueryStringWriter`1();
    public static WriteObjectDelegate WriteFn();
    public static void WriteObject(TextWriter writer, object value);
    public static void WriteIDictionary(TextWriter writer, object oMap);
}
public enum ServiceStack.QuotaType : Enum {
    public int value__;
    public static QuotaType Operations;
    public static QuotaType Types;
    public static QuotaType Fields;
    public static QuotaType RequestsPerHour;
    public static QuotaType Tables;
    public static QuotaType PremiumFeature;
}
[ExtensionAttribute]
public static class ServiceStack.ReflectionExtensions : object {
    private static Dictionary`2<Type, EmptyCtorDelegate> ConstructorMethods;
    private static Dictionary`2<string, EmptyCtorDelegate> TypeNamesMap;
    public static string DataMember;
    internal static String[] IgnoreAttributesNamed;
    private static ReflectionExtensions();
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool IsInstanceOf(Type type, Type thisOrBaseType);
    [ExtensionAttribute]
public static bool HasGenericType(Type type);
    [ExtensionAttribute]
public static Type FirstGenericType(Type type);
    [ExtensionAttribute]
public static Type GetTypeWithGenericTypeDefinitionOfAny(Type type, Type[] genericTypeDefinitions);
    [ExtensionAttribute]
public static bool IsOrHasGenericInterfaceTypeOf(Type type, Type genericTypeDefinition);
    [ExtensionAttribute]
public static Type GetTypeWithGenericTypeDefinitionOf(Type type, Type genericTypeDefinition);
    [ExtensionAttribute]
public static Type GetTypeWithInterfaceOf(Type type, Type interfaceType);
    [ExtensionAttribute]
public static bool HasInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static bool AllHaveInterfacesOfType(Type assignableFromType, Type[] types);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static TypeCode GetUnderlyingTypeCode(Type type);
    [ExtensionAttribute]
public static bool IsNumericType(Type type);
    [ExtensionAttribute]
public static bool IsIntegerType(Type type);
    [ExtensionAttribute]
public static bool IsRealNumberType(Type type);
    [ExtensionAttribute]
public static Type GetTypeWithGenericInterfaceOf(Type type, Type genericInterfaceType);
    [ExtensionAttribute]
public static bool HasAnyTypeDefinitionsOf(Type genericType, Type[] theseGenericTypes);
    [ExtensionAttribute]
public static Type[] GetGenericArgumentsIfBothHaveSameGenericDefinitionTypeAndArguments(Type assignableFromType, Type typeA, Type typeB);
    [ExtensionAttribute]
public static TypePair GetGenericArgumentsIfBothHaveConvertibleGenericDefinitionTypeAndArguments(Type assignableFromType, Type typeA, Type typeB);
    public static bool AreAllStringOrValueTypes(Type[] types);
    public static EmptyCtorDelegate GetConstructorMethod(Type type);
    public static EmptyCtorDelegate GetConstructorMethod(string typeName);
    public static EmptyCtorDelegate GetConstructorMethodToCache(Type type);
    public static object CreateInstance();
    [ExtensionAttribute]
public static T New(Type type);
    [ExtensionAttribute]
public static object New(Type type);
    [ExtensionAttribute]
public static object CreateInstance(Type type);
    [ExtensionAttribute]
public static T CreateInstance(Type type);
    public static object CreateInstance(string typeName);
    [ExtensionAttribute]
public static Module GetModule(Type type);
    [ExtensionAttribute]
public static PropertyInfo[] GetAllProperties(Type type);
    [ExtensionAttribute]
public static PropertyInfo[] GetPublicProperties(Type type);
    internal static void Reset();
    [ExtensionAttribute]
public static PropertyInfo[] GetSerializableProperties(Type type);
    [ExtensionAttribute]
public static PropertyInfo[] OnlySerializableProperties(PropertyInfo[] properties, Type type);
    public static Func`4<object, string, object, object> GetOnDeserializing();
    [ExtensionAttribute]
public static FieldInfo[] GetSerializableFields(Type type);
    [ExtensionAttribute]
public static DataContractAttribute GetDataContract(Type type);
    [ExtensionAttribute]
public static DataMemberAttribute GetDataMember(PropertyInfo pi);
    [ExtensionAttribute]
public static DataMemberAttribute GetDataMember(FieldInfo pi);
    [ExtensionAttribute]
public static string GetDataMemberName(PropertyInfo pi);
    [ExtensionAttribute]
public static string GetDataMemberName(FieldInfo fi);
}
internal class ServiceStack.SerializerUtils`1 : object {
    private static ITypeSerializer Serializer;
    private static SerializerUtils`1();
    private static int VerifyAndGetStartIndex(ReadOnlySpan`1<char> value, Type createMapType);
    public static Hashtable ParseHashtable(string value);
    public static Hashtable ParseHashtable(ReadOnlySpan`1<char> value);
    public static StringCollection ParseStringCollection(string value);
    public static StringCollection ParseStringCollection(ReadOnlySpan`1<char> value);
    public static StringCollection ToStringCollection(List`1<string> items);
}
public class ServiceStack.SetMemberDelegate : MulticastDelegate {
    public SetMemberDelegate(object object, IntPtr method);
    public virtual void Invoke(object instance, object value);
    public virtual IAsyncResult BeginInvoke(object instance, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ServiceStack.SetMemberDelegate`1 : MulticastDelegate {
    public SetMemberDelegate`1(object object, IntPtr method);
    public virtual void Invoke(T instance, object value);
    public virtual IAsyncResult BeginInvoke(T instance, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ServiceStack.SetMemberRefDelegate : MulticastDelegate {
    public SetMemberRefDelegate(object object, IntPtr method);
    public virtual void Invoke(Object& instance, object propertyValue);
    public virtual IAsyncResult BeginInvoke(Object& instance, object propertyValue, AsyncCallback callback, object object);
    public virtual void EndInvoke(Object& instance, IAsyncResult result);
}
public class ServiceStack.SetMemberRefDelegate`1 : MulticastDelegate {
    public SetMemberRefDelegate`1(object object, IntPtr method);
    public virtual void Invoke(T& instance, object value);
    public virtual IAsyncResult BeginInvoke(T& instance, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(T& instance, IAsyncResult result);
}
[ExtensionAttribute]
public static class ServiceStack.StreamExtensions : object {
    public static int DefaultBufferSize;
    public static int AsyncBufferSize;
    private static StreamExtensions();
    [ExtensionAttribute]
public static long WriteTo(Stream inStream, Stream outStream);
    [IteratorStateMachineAttribute("ServiceStack.StreamExtensions/<ReadLines>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(Stream stream);
    [ExtensionAttribute]
public static Byte[] ReadFully(Stream input);
    [ExtensionAttribute]
public static Byte[] ReadFully(Stream input, int bufferSize);
    [ExtensionAttribute]
public static Byte[] ReadFully(Stream input, Byte[] buffer);
    [ExtensionAttribute]
public static Task`1<Byte[]> ReadFullyAsync(Stream input, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.StreamExtensions/<ReadFullyAsync>d__7")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadFullyAsync(Stream input, int bufferSize, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.StreamExtensions/<ReadFullyAsync>d__8")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadFullyAsync(Stream input, Byte[] buffer, CancellationToken token);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> ReadFullyAsMemory(Stream input);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> ReadFullyAsMemory(Stream input, int bufferSize);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> ReadFullyAsMemory(Stream input, Byte[] buffer);
    [ExtensionAttribute]
public static Task`1<ReadOnlyMemory`1<byte>> ReadFullyAsMemoryAsync(Stream input, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.StreamExtensions/<ReadFullyAsMemoryAsync>d__13")]
[ExtensionAttribute]
public static Task`1<ReadOnlyMemory`1<byte>> ReadFullyAsMemoryAsync(Stream input, int bufferSize, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.StreamExtensions/<ReadFullyAsMemoryAsync>d__14")]
[ExtensionAttribute]
public static Task`1<ReadOnlyMemory`1<byte>> ReadFullyAsMemoryAsync(Stream input, Byte[] buffer, CancellationToken token);
    [ExtensionAttribute]
public static long CopyTo(Stream input, Stream output);
    [ExtensionAttribute]
public static long CopyTo(Stream input, Stream output, int bufferSize);
    [ExtensionAttribute]
public static long CopyTo(Stream input, Stream output, Byte[] buffer);
    [AsyncStateMachineAttribute("ServiceStack.StreamExtensions/<CopyToAsync>d__18")]
[ExtensionAttribute]
public static Task`1<long> CopyToAsync(Stream input, Stream output, Byte[] buffer, CancellationToken token);
    [ExtensionAttribute]
public static Byte[] ReadExactly(Stream input, int bytesToRead);
    [ExtensionAttribute]
public static Byte[] ReadExactly(Stream input, Byte[] buffer);
    [ExtensionAttribute]
public static Byte[] ReadExactly(Stream input, Byte[] buffer, int bytesToRead);
    [ExtensionAttribute]
public static Byte[] ReadExactly(Stream input, Byte[] buffer, int startIndex, int bytesToRead);
    private static Byte[] ReadExactlyFast(Stream fromStream, Byte[] intoBuffer, int startAtIndex, int bytesToRead);
    [ExtensionAttribute]
public static string CollapseWhitespace(string str);
    [ExtensionAttribute]
public static Byte[] Combine(Byte[] bytes, Byte[][] withBytes);
    [ExtensionAttribute]
public static Task WriteAsync(Stream stream, ReadOnlyMemory`1<byte> value, CancellationToken token);
    [ExtensionAttribute]
public static Task WriteAsync(Stream stream, Byte[] bytes, CancellationToken token);
    [ExtensionAttribute]
public static Task CopyToAsync(Stream input, Stream output, CancellationToken token);
    [ExtensionAttribute]
public static Task WriteAsync(Stream stream, string text, CancellationToken token);
    [ExtensionAttribute]
public static string ToMd5Hash(Stream stream);
    [ExtensionAttribute]
public static string ToMd5Hash(Byte[] bytes);
    [ExtensionAttribute]
public static MemoryStream InMemoryStream(Byte[] bytes);
    [ExtensionAttribute]
public static string ReadToEnd(MemoryStream ms);
    [ExtensionAttribute]
public static string ReadToEnd(MemoryStream ms, Encoding encoding);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> GetBufferAsMemory(MemoryStream ms);
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> GetBufferAsSpan(MemoryStream ms);
    [ExtensionAttribute]
public static Byte[] GetBufferAsBytes(MemoryStream ms);
    [ExtensionAttribute]
public static Task`1<string> ReadToEndAsync(MemoryStream ms);
    [ExtensionAttribute]
public static Task`1<string> ReadToEndAsync(MemoryStream ms, Encoding encoding);
    [ExtensionAttribute]
public static string ReadToEnd(Stream stream);
    [ExtensionAttribute]
public static string ReadToEnd(Stream stream, Encoding encoding);
    [ExtensionAttribute]
public static Task`1<string> ReadToEndAsync(Stream stream);
    [ExtensionAttribute]
public static Task`1<string> ReadToEndAsync(Stream stream, Encoding encoding);
    [ExtensionAttribute]
public static Task WriteToAsync(MemoryStream stream, Stream output, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.StreamExtensions/<WriteToAsync>d__46")]
[ExtensionAttribute]
public static Task WriteToAsync(MemoryStream stream, Stream output, Encoding encoding, CancellationToken token);
    [ExtensionAttribute]
public static Task WriteToAsync(Stream stream, Stream output, CancellationToken token);
    [ExtensionAttribute]
public static Task WriteToAsync(Stream stream, Stream output, Encoding encoding, CancellationToken token);
    [ExtensionAttribute]
public static MemoryStream CopyToNewMemoryStream(Stream stream);
    [AsyncStateMachineAttribute("ServiceStack.StreamExtensions/<CopyToNewMemoryStreamAsync>d__50")]
[ExtensionAttribute]
public static Task`1<MemoryStream> CopyToNewMemoryStreamAsync(Stream stream);
}
public class ServiceStack.StringDictionary : Dictionary`2<string, string> {
    public StringDictionary(int capacity);
    public StringDictionary(IEqualityComparer`1<string> comparer);
    public StringDictionary(int capacity, IEqualityComparer`1<string> comparer);
    public StringDictionary(IDictionary`2<string, string> dictionary);
    public StringDictionary(IDictionary`2<string, string> dictionary, IEqualityComparer`1<string> comparer);
    protected StringDictionary(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class ServiceStack.StringExtensions : object {
    private static Char[] UrlPathDelims;
    private static Regex StripHtmlRegEx;
    private static Regex StripBracketsRegEx;
    private static Regex StripBracesRegEx;
    private static int LowerCaseOffset;
    private static Regex InvalidVarCharsRegex;
    private static Regex ValidVarCharsRegex;
    private static Regex InvalidVarRefCharsRegex;
    private static Regex ValidVarRefCharsRegex;
    private static Regex SplitCamelCaseRegex;
    private static Regex HttpRegex;
    private static Char[] SystemTypeChars;
    private static StringExtensions();
    [ExtensionAttribute]
public static string BaseConvert(string source, int from, int to);
    [ExtensionAttribute]
public static string EncodeXml(string value);
    [ExtensionAttribute]
public static string EncodeJson(string value);
    [ExtensionAttribute]
public static string EncodeJsv(string value);
    [ExtensionAttribute]
public static string DecodeJsv(string value);
    [ExtensionAttribute]
public static string UrlEncode(string text, bool upperCase);
    [ExtensionAttribute]
public static string UrlDecode(string text);
    [ExtensionAttribute]
public static string HexUnescape(string text, Char[] anyCharOf);
    [ExtensionAttribute]
public static string UrlFormat(string url, String[] urlComponents);
    [ExtensionAttribute]
public static string ToRot13(string value);
    [ExtensionAttribute]
public static string UrlWithTrailingSlash(string url);
    [ExtensionAttribute]
public static string WithTrailingSlash(string path);
    [ExtensionAttribute]
public static string AppendPath(string uri, String[] uriComponents);
    [ExtensionAttribute]
public static string AppendUrlPaths(string uri, String[] uriComponents);
    [ExtensionAttribute]
public static string AppendUrlPathsRaw(string uri, String[] uriComponents);
    [ExtensionAttribute]
public static string FromUtf8Bytes(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] ToUtf8Bytes(string value);
    [ExtensionAttribute]
public static Byte[] ToUtf8Bytes(int intVal);
    [ExtensionAttribute]
public static Byte[] ToUtf8Bytes(long longVal);
    [ExtensionAttribute]
public static Byte[] ToUtf8Bytes(ulong ulongVal);
    [ExtensionAttribute]
public static Byte[] ToUtf8Bytes(double doubleVal);
    [ExtensionAttribute]
public static string WithoutBom(string value);
    [ExtensionAttribute]
public static string ToBase64UrlSafe(Byte[] input);
    [ExtensionAttribute]
public static string ToBase64UrlSafe(MemoryStream ms);
    [ExtensionAttribute]
public static Byte[] FromBase64UrlSafe(string input);
    private static Byte[] FastToUtf8Bytes(string strVal);
    [ExtensionAttribute]
public static string LeftPart(string strVal, char needle);
    [ExtensionAttribute]
public static string LeftPart(string strVal, string needle);
    [ExtensionAttribute]
public static string RightPart(string strVal, char needle);
    [ExtensionAttribute]
public static string RightPart(string strVal, string needle);
    [ExtensionAttribute]
public static string LastLeftPart(string strVal, char needle);
    [ExtensionAttribute]
public static string LastLeftPart(string strVal, string needle);
    [ExtensionAttribute]
public static string LastRightPart(string strVal, char needle);
    [ExtensionAttribute]
public static string LastRightPart(string strVal, string needle);
    [ExtensionAttribute]
public static String[] SplitOnFirst(string strVal, char needle);
    [ExtensionAttribute]
public static String[] SplitOnFirst(string strVal, string needle);
    [ExtensionAttribute]
public static String[] SplitOnLast(string strVal, char needle);
    [ExtensionAttribute]
public static String[] SplitOnLast(string strVal, string needle);
    [ExtensionAttribute]
public static string WithoutExtension(string filePath);
    [ExtensionAttribute]
public static string GetExtension(string filePath);
    [ExtensionAttribute]
public static string ParentDirectory(string filePath);
    [ExtensionAttribute]
public static string ToJsv(T obj);
    [ExtensionAttribute]
public static string ToSafeJsv(T obj);
    [ExtensionAttribute]
public static T FromJsv(string jsv);
    [ExtensionAttribute]
public static T FromJsvSpan(ReadOnlySpan`1<char> jsv);
    [ExtensionAttribute]
public static string ToJson(T obj);
    [ExtensionAttribute]
public static string ToSafeJson(T obj);
    [ExtensionAttribute]
public static T FromJson(string json);
    [ExtensionAttribute]
public static T FromJsonSpan(ReadOnlySpan`1<char> json);
    [ExtensionAttribute]
public static string ToCsv(T obj);
    [ExtensionAttribute]
public static T FromCsv(string csv);
    [ExtensionAttribute]
public static string FormatWith(string text, Object[] args);
    [ExtensionAttribute]
public static string Fmt(string text, Object[] args);
    [ExtensionAttribute]
public static string Fmt(string text, IFormatProvider provider, Object[] args);
    [ExtensionAttribute]
public static string Fmt(string text, object arg1);
    [ExtensionAttribute]
public static string Fmt(string text, object arg1, object arg2);
    [ExtensionAttribute]
public static string Fmt(string text, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
public static bool StartsWithIgnoreCase(string text, string startsWith);
    [ExtensionAttribute]
public static bool EndsWithIgnoreCase(string text, string endsWith);
    [ExtensionAttribute]
public static string ReadAllText(string filePath);
    [ExtensionAttribute]
public static bool FileExists(string filePath);
    [ExtensionAttribute]
public static bool DirectoryExists(string dirPath);
    [ExtensionAttribute]
public static void CreateDirectory(string dirPath);
    [ExtensionAttribute]
public static int IndexOfAny(string text, String[] needles);
    [ExtensionAttribute]
public static int IndexOfAny(string text, int startIndex, String[] needles);
    [ExtensionAttribute]
public static string ExtractContents(string fromText, string startAfter, string endAt);
    [ExtensionAttribute]
public static string ExtractContents(string fromText, string uniqueMarker, string startAfter, string endAt);
    [ExtensionAttribute]
public static string StripHtml(string html);
    [ExtensionAttribute]
public static string Quoted(string text);
    [ExtensionAttribute]
public static string StripQuotes(string text);
    [ExtensionAttribute]
public static string StripMarkdownMarkup(string markdown);
    [ExtensionAttribute]
public static string ToCamelCase(string value);
    [ExtensionAttribute]
public static string ToPascalCase(string value);
    [ExtensionAttribute]
public static string ToTitleCase(string value);
    [ExtensionAttribute]
public static string ToLowercaseUnderscore(string value);
    [ExtensionAttribute]
public static string ToLowerSafe(string value);
    [ExtensionAttribute]
public static string ToUpperSafe(string value);
    [ExtensionAttribute]
public static string SafeSubstring(string value, int startIndex);
    [ExtensionAttribute]
public static string SafeSubstring(string value, int startIndex, int length);
    [ExtensionAttribute]
[ObsoleteAttribute("typo")]
public static string SubstringWithElipsis(string value, int startIndex, int length);
    [ExtensionAttribute]
public static string SubstringWithEllipsis(string value, int startIndex, int length);
    [ExtensionAttribute]
public static bool IsAnonymousType(Type type);
    [ExtensionAttribute]
public static int CompareIgnoreCase(string strA, string strB);
    [ExtensionAttribute]
public static bool EndsWithInvariant(string str, string endsWith);
    [ExtensionAttribute]
public static T ToEnum(string value);
    [ExtensionAttribute]
public static T ToEnumOrDefault(string value, T defaultValue);
    [ExtensionAttribute]
public static string SplitCamelCase(string value);
    [ExtensionAttribute]
public static string ToInvariantUpper(char value);
    [ExtensionAttribute]
public static string ToEnglish(string camelCase);
    [ExtensionAttribute]
public static string ToHttps(string url);
    [ExtensionAttribute]
public static bool IsEmpty(string value);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static bool EqualsIgnoreCase(string value, string other);
    [ExtensionAttribute]
public static string ReplaceFirst(string haystack, string needle, string replacement);
    [ExtensionAttribute]
[ObsoleteAttribute("Use built-in string.Replace()")]
public static string ReplaceAll(string haystack, string needle, string replacement);
    [ExtensionAttribute]
public static bool ContainsAny(string text, String[] testMatches);
    [ExtensionAttribute]
public static bool ContainsAny(string text, String[] testMatches, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool IsValidVarName(string name);
    [ExtensionAttribute]
public static bool IsValidVarRef(string name);
    [ExtensionAttribute]
public static string SafeVarName(string text);
    [ExtensionAttribute]
public static string SafeVarRef(string text);
    [ExtensionAttribute]
public static string Join(List`1<string> items);
    [ExtensionAttribute]
public static string Join(List`1<string> items, string delimeter);
    [ExtensionAttribute]
public static string ToParentPath(string path);
    [ExtensionAttribute]
public static string RemoveCharFlags(string text, Boolean[] charFlags);
    [ExtensionAttribute]
public static string ToNullIfEmpty(string text);
    [ExtensionAttribute]
public static bool IsUserType(Type type);
    [ExtensionAttribute]
public static bool IsUserEnum(Type type);
    [ExtensionAttribute]
public static bool IsSystemType(Type type);
    [ExtensionAttribute]
public static bool IsTuple(Type type);
    [ExtensionAttribute]
public static bool IsInt(string text);
    [ExtensionAttribute]
public static int ToInt(string text);
    [ExtensionAttribute]
public static int ToInt(string text, int defaultValue);
    [ExtensionAttribute]
public static long ToLong(string text);
    [ExtensionAttribute]
public static long ToInt64(string text);
    [ExtensionAttribute]
public static long ToLong(string text, long defaultValue);
    [ExtensionAttribute]
public static long ToInt64(string text, long defaultValue);
    [ExtensionAttribute]
public static float ToFloat(string text);
    [ExtensionAttribute]
public static float ToFloatInvariant(string text);
    [ExtensionAttribute]
public static float ToFloat(string text, float defaultValue);
    [ExtensionAttribute]
public static double ToDouble(string text);
    [ExtensionAttribute]
public static double ToDoubleInvariant(string text);
    [ExtensionAttribute]
public static double ToDouble(string text, double defaultValue);
    [ExtensionAttribute]
public static decimal ToDecimal(string text);
    [ExtensionAttribute]
public static decimal ToDecimalInvariant(string text);
    [ExtensionAttribute]
public static decimal ToDecimal(string text, decimal defaultValue);
    [ExtensionAttribute]
public static bool Matches(string value, string pattern);
    [ExtensionAttribute]
public static bool Glob(string value, string pattern);
    [ExtensionAttribute]
public static bool GlobPath(string filePath, string pattern);
    [ExtensionAttribute]
public static string TrimPrefixes(string fromString, String[] prefixes);
    [ExtensionAttribute]
public static string FromAsciiBytes(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] ToAsciiBytes(string value);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ParseKeyValueText(string text, string delimiter);
    [ExtensionAttribute]
public static List`1<KeyValuePair`2<string, string>> ParseAsKeyValues(string text, string delimiter);
    [IteratorStateMachineAttribute("ServiceStack.StringExtensions/<ReadLines>d__146")]
[ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(string text);
    [ExtensionAttribute]
public static int CountOccurrencesOf(string text, char needle);
    [ExtensionAttribute]
public static string NormalizeNewLines(string text);
    [ExtensionAttribute]
public static string HexEscape(string text, Char[] anyCharOf);
    [ExtensionAttribute]
public static string ToXml(T obj);
    [ExtensionAttribute]
public static T FromXml(string json);
    [ExtensionAttribute]
public static string ToHex(Byte[] hashBytes, bool upper);
    private static char GetHexValue(int i, bool upper);
}
[ExtensionAttribute]
public static class ServiceStack.TaskExtensions : object {
    [ExtensionAttribute]
public static Task`1<T> Success(Task`1<T> task, Action`1<T> fn, bool onUiThread, TaskContinuationOptions taskOptions);
    [ExtensionAttribute]
public static Task Success(Task task, Action fn, bool onUiThread, TaskContinuationOptions taskOptions);
    [ExtensionAttribute]
public static Task`1<T> Error(Task`1<T> task, Action`1<Exception> fn, bool onUiThread, TaskContinuationOptions taskOptions);
    [ExtensionAttribute]
public static Task Error(Task task, Action`1<Exception> fn, bool onUiThread, TaskContinuationOptions taskOptions);
    [ExtensionAttribute]
public static Exception UnwrapIfSingleException(Task`1<T> task);
    [ExtensionAttribute]
public static Exception UnwrapIfSingleException(Task task);
    [ExtensionAttribute]
public static Exception UnwrapIfSingleException(Exception ex);
}
public static class ServiceStack.TaskResult : object {
    public static Task`1<int> Zero;
    public static Task`1<int> One;
    public static Task`1<bool> True;
    public static Task`1<bool> False;
    public static Task Finished;
    public static Task Canceled;
    private static TaskResult();
}
internal class ServiceStack.TaskResult`1 : object {
    public static Task`1<T> Canceled;
    public static Task`1<T> Default;
    private static TaskResult`1();
}
[ExtensionAttribute]
public static class ServiceStack.TaskUtils : object {
    public static Task`1<T> FromResult(T result);
    [ExtensionAttribute]
public static Task`1<T> InTask(T result);
    [ExtensionAttribute]
public static Task`1<T> InTask(Exception ex);
    [ExtensionAttribute]
public static bool IsSuccess(Task task);
    [ExtensionAttribute]
public static Task`1<To> Cast(Task`1<From> task);
    public static TaskScheduler SafeTaskScheduler();
    [ExtensionAttribute]
public static Task`1<To> Then(Task`1<From> task, Func`2<From, To> fn);
    [ExtensionAttribute]
public static Task Then(Task task, Func`2<Task, Task> fn);
    [ExtensionAttribute]
public static Task EachAsync(IEnumerable`1<T> items, Func`3<T, int, Task> fn);
    private static void StartNextIteration(TaskCompletionSource`1<object> tcs, Func`3<T, int, Task> fn, IEnumerator`1<T> enumerator, Int32& i, Action`1<Task> next);
    public static void Sleep(int timeMs);
    public static void Sleep(TimeSpan time);
}
[ExtensionAttribute]
public static class ServiceStack.Text.AssemblyUtils : object {
    private static string FileUri;
    private static char UriSeperator;
    private static Dictionary`2<string, Type> TypeCache;
    private static Regex versionRegEx;
    private static AssemblyUtils();
    public static Type FindType(string typeName);
    public static Type MainInterface();
    public static Type FindType(string typeName, string assemblyName);
    public static Type FindTypeFromLoadedAssemblies(string typeName);
    public static Assembly LoadAssembly(string assemblyPath);
    public static string GetAssemblyBinPath(Assembly assembly);
    [ExtensionAttribute]
public static string ToTypeString(Type type);
    public static string WriteType(Type type);
}
public class ServiceStack.Text.CachedTypeInfo : object {
    private static Dictionary`2<Type, CachedTypeInfo> CacheMap;
    [CompilerGeneratedAttribute]
private EnumInfo <EnumInfo>k__BackingField;
    public EnumInfo EnumInfo { get; }
    public CachedTypeInfo(Type type);
    private static CachedTypeInfo();
    public static CachedTypeInfo Get(Type type);
    [CompilerGeneratedAttribute]
public EnumInfo get_EnumInfo();
}
[ExtensionAttribute]
public static class ServiceStack.Text.CharMemoryExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> Advance(ReadOnlyMemory`1<char> text, int to);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AdvancePastWhitespace(ReadOnlyMemory`1<char> literal);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AdvancePastChar(ReadOnlyMemory`1<char> literal, char delim);
    [ExtensionAttribute]
public static bool ParseBoolean(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static bool TryParseBoolean(ReadOnlyMemory`1<char> value, Boolean& result);
    [ExtensionAttribute]
public static bool TryParseDecimal(ReadOnlyMemory`1<char> value, Decimal& result);
    [ExtensionAttribute]
public static bool TryParseFloat(ReadOnlyMemory`1<char> value, Single& result);
    [ExtensionAttribute]
public static bool TryParseDouble(ReadOnlyMemory`1<char> value, Double& result);
    [ExtensionAttribute]
public static decimal ParseDecimal(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static float ParseFloat(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static double ParseDouble(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static sbyte ParseSByte(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static byte ParseByte(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static short ParseInt16(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static ushort ParseUInt16(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static int ParseInt32(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static UInt32 ParseUInt32(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static long ParseInt64(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static ulong ParseUInt64(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static Guid ParseGuid(ReadOnlyMemory`1<char> value);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> LeftPart(ReadOnlyMemory`1<char> strVal, char needle);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> LeftPart(ReadOnlyMemory`1<char> strVal, string needle);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> RightPart(ReadOnlyMemory`1<char> strVal, char needle);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> RightPart(ReadOnlyMemory`1<char> strVal, string needle);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> LastLeftPart(ReadOnlyMemory`1<char> strVal, char needle);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> LastLeftPart(ReadOnlyMemory`1<char> strVal, string needle);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> LastRightPart(ReadOnlyMemory`1<char> strVal, char needle);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> LastRightPart(ReadOnlyMemory`1<char> strVal, string needle);
    [ExtensionAttribute]
public static bool TryReadLine(ReadOnlyMemory`1<char> text, ReadOnlyMemory`1& line, Int32& startIndex);
    [ExtensionAttribute]
public static bool TryReadPart(ReadOnlyMemory`1<char> text, ReadOnlyMemory`1<char> needle, ReadOnlyMemory`1& part, Int32& startIndex);
    [ExtensionAttribute]
public static void SplitOnFirst(ReadOnlyMemory`1<char> strVal, char needle, ReadOnlyMemory`1& first, ReadOnlyMemory`1& last);
    [ExtensionAttribute]
public static void SplitOnFirst(ReadOnlyMemory`1<char> strVal, ReadOnlyMemory`1<char> needle, ReadOnlyMemory`1& first, ReadOnlyMemory`1& last);
    [ExtensionAttribute]
public static void SplitOnLast(ReadOnlyMemory`1<char> strVal, char needle, ReadOnlyMemory`1& first, ReadOnlyMemory`1& last);
    [ExtensionAttribute]
public static void SplitOnLast(ReadOnlyMemory`1<char> strVal, ReadOnlyMemory`1<char> needle, ReadOnlyMemory`1& first, ReadOnlyMemory`1& last);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlyMemory`1<char> value, char needle);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlyMemory`1<char> value, string needle);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlyMemory`1<char> value, char needle, int start);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlyMemory`1<char> value, string needle, int start);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlyMemory`1<char> value, char needle);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlyMemory`1<char> value, string needle);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlyMemory`1<char> value, char needle, int start);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlyMemory`1<char> value, string needle, int start);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlyMemory`1<char> value, string other);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlyMemory`1<char> value, string other, StringComparison comparison);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlyMemory`1<char> value, string other);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlyMemory`1<char> value, string other, StringComparison comparison);
    [ExtensionAttribute]
public static bool EqualsOrdinal(ReadOnlyMemory`1<char> value, string other);
    [ExtensionAttribute]
public static bool EqualsOrdinal(ReadOnlyMemory`1<char> value, ReadOnlyMemory`1<char> other);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> SafeSlice(ReadOnlyMemory`1<char> value, int startIndex);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> SafeSlice(ReadOnlyMemory`1<char> value, int startIndex, int length);
    [ExtensionAttribute]
public static string SubstringWithEllipsis(ReadOnlyMemory`1<char> value, int startIndex, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> ToUtf8(ReadOnlyMemory`1<char> chars);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> FromUtf8(ReadOnlyMemory`1<byte> bytes);
}
public class ServiceStack.Text.Common.ConvertInstanceDelegate : MulticastDelegate {
    public ConvertInstanceDelegate(object object, IntPtr method);
    public virtual object Invoke(object obj, Type type);
    public virtual IAsyncResult BeginInvoke(object obj, Type type, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class ServiceStack.Text.Common.ConvertObjectDelegate : MulticastDelegate {
    public ConvertObjectDelegate(object object, IntPtr method);
    public virtual object Invoke(object fromObject);
    public virtual IAsyncResult BeginInvoke(object fromObject, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class ServiceStack.Text.Common.DateTimeSerializer : object {
    public static string CondensedDateTimeFormat;
    public static string ShortDateTimeFormat;
    public static string DefaultDateTimeFormat;
    public static string DefaultDateTimeFormatWithFraction;
    public static string XsdDateTimeFormat;
    public static string XsdDateTimeFormat3F;
    public static string XsdDateTimeFormatSeconds;
    public static string DateTimeFormatSecondsUtcOffset;
    public static string DateTimeFormatSecondsNoOffset;
    public static string DateTimeFormatTicksUtcOffset;
    public static string DateTimeFormatTicksNoUtcOffset;
    public static string EscapedWcfJsonPrefix;
    public static string EscapedWcfJsonSuffix;
    public static string WcfJsonPrefix;
    public static char WcfJsonSuffix;
    public static string UnspecifiedOffset;
    public static string UtcOffset;
    private static char XsdTimeSeparator;
    private static int XsdTimeSeparatorIndex;
    private static string XsdUtcSuffix;
    private static Char[] DateTimeSeparators;
    private static Regex UtcOffsetInfoRegex;
    [CompilerGeneratedAttribute]
private static Func`3<string, Exception, DateTime> <OnParseErrorFn>k__BackingField;
    private static Char[] TimeZoneChars;
    private static string MinDateTimeOffsetWcfValue;
    private static string MaxDateTimeOffsetWcfValue;
    internal static TimeZoneInfo LocalTimeZone;
    public static Func`3<string, Exception, DateTime> OnParseErrorFn { get; public set; }
    private static DateTimeSerializer();
    [CompilerGeneratedAttribute]
public static Func`3<string, Exception, DateTime> get_OnParseErrorFn();
    [CompilerGeneratedAttribute]
public static void set_OnParseErrorFn(Func`3<string, Exception, DateTime> value);
    [ExtensionAttribute]
public static DateTime Prepare(DateTime dateTime, bool parsedAsUtc);
    public static Nullable`1<DateTime> ParseShortestNullableXsdDateTime(string dateTimeStr);
    public static DateTime ParseRFC1123DateTime(string dateTimeStr);
    public static DateTime ParseShortestXsdDateTime(string dateTimeStr);
    private static string RemoveUtcOffsets(string dateTimeStr, DateTimeKind& kind);
    private static string RepairXsdTimeSeparator(string dateTimeStr);
    public static Nullable`1<DateTime> ParseManual(string dateTimeStr);
    public static Nullable`1<DateTime> ParseManual(string dateTimeStr, DateTimeKind dateKind);
    public static string ToDateTimeString(DateTime dateTime);
    public static DateTime ParseDateTime(string dateTimeStr);
    public static DateTimeOffset ParseDateTimeOffset(string dateTimeOffsetStr);
    public static Nullable`1<DateTimeOffset> ParseNullableDateTimeOffset(string dateTimeOffsetStr);
    public static string ToXsdDateTimeString(DateTime dateTime);
    public static string ToLocalXsdDateTimeString(DateTime dateTime);
    public static string ToXsdTimeSpanString(TimeSpan timeSpan);
    public static string ToXsdTimeSpanString(Nullable`1<TimeSpan> timeSpan);
    public static DateTime ParseXsdDateTime(string dateTimeStr);
    public static TimeSpan ParseTimeSpan(string dateTimeStr);
    public static TimeSpan ParseNSTimeInterval(string doubleInSecs);
    public static Nullable`1<TimeSpan> ParseNullableTimeSpan(string dateTimeStr);
    public static TimeSpan ParseXsdTimeSpan(string dateTimeStr);
    public static Nullable`1<TimeSpan> ParseXsdNullableTimeSpan(string dateTimeStr);
    public static string ToShortestXsdDateTimeString(DateTime dateTime);
    public static DateTimeOffset ParseWcfJsonDateOffset(string wcfJsonDate);
    public static DateTime ParseWcfJsonDate(string wcfJsonDate);
    public static TimeZoneInfo GetLocalTimeZoneInfo();
    [ExtensionAttribute]
private static DateTime UseConfigSpecifiedSetting(DateTime dateTime);
    public static void WriteWcfJsonDate(TextWriter writer, DateTime dateTime);
    public static string ToWcfJsonDate(DateTime dateTime);
    public static void WriteWcfJsonDateTimeOffset(TextWriter writer, DateTimeOffset dateTimeOffset);
    public static string ToWcfJsonDateTimeOffset(DateTimeOffset dateTimeOffset);
}
public class ServiceStack.Text.Common.DeserializationErrorDelegate : MulticastDelegate {
    public DeserializationErrorDelegate(object object, IntPtr method);
    public virtual void Invoke(object instance, Type propertyType, string propertyName, string propertyValueStr, Exception ex);
    public virtual IAsyncResult BeginInvoke(object instance, Type propertyType, string propertyName, string propertyValueStr, Exception ex, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class ServiceStack.Text.Common.DeserializeArray`1 : object {
    private static Dictionary`2<Type, ParseStringSpanDelegate> ParseDelegateCache;
    private static DeserializeArray`1();
    public static ParseStringDelegate GetParseFn(Type type);
    public static ParseStringSpanDelegate GetParseStringSpanFn(Type type);
}
internal static class ServiceStack.Text.Common.DeserializeArray`2 : object {
    private static ITypeSerializer Serializer;
    private static ParseStringSpanDelegate CacheFn;
    public static ParseStringDelegate Parse { get; }
    public static ParseStringSpanDelegate ParseStringSpan { get; }
    private static DeserializeArray`2();
    public static ParseStringDelegate get_Parse();
    public static ParseStringSpanDelegate get_ParseStringSpan();
    public static ParseStringDelegate GetParseFn();
    public static ParseStringSpanDelegate GetParseStringSpanFn();
    public static String[] ParseStringArray(ReadOnlySpan`1<char> value);
    public static String[] ParseStringArray(string value);
    public static Byte[] ParseByteArray(string value);
    public static Byte[] ParseByteArray(ReadOnlySpan`1<char> value);
}
public static class ServiceStack.Text.Common.DeserializeArrayWithElements`1 : object {
    private static Dictionary`2<Type, ParseArrayOfElementsDelegate<TSerializer>> ParseDelegateCache;
    private static Type[] signature;
    private static DeserializeArrayWithElements`1();
    public static Func`3<string, ParseStringDelegate, object> GetParseFn(Type type);
    public static ParseArrayOfElementsDelegate<TSerializer> GetParseStringSpanFn(Type type);
}
public static class ServiceStack.Text.Common.DeserializeArrayWithElements`2 : object {
    private static ITypeSerializer Serializer;
    private static DeserializeArrayWithElements`2();
    public static T[] ParseGenericArray(string value, ParseStringDelegate elementParseFn);
    public static T[] ParseGenericArray(ReadOnlySpan`1<char> value, ParseStringSpanDelegate elementParseFn);
}
public static class ServiceStack.Text.Common.DeserializeBuiltin`1 : object {
    private static ParseStringSpanDelegate CachedParseFn;
    public static ParseStringDelegate Parse { get; }
    public static ParseStringSpanDelegate ParseStringSpan { get; }
    private static DeserializeBuiltin`1();
    public static ParseStringDelegate get_Parse();
    public static ParseStringSpanDelegate get_ParseStringSpan();
    private static ParseStringDelegate GetParseFn();
    private static ParseStringSpanDelegate GetParseStringSpanFn();
}
internal static class ServiceStack.Text.Common.DeserializeCollection`1 : object {
    private static ITypeSerializer Serializer;
    private static Dictionary`2<Type, ParseCollectionDelegate<TSerializer>> ParseDelegateCache;
    private static Type[] arguments;
    private static DeserializeCollection`1();
    public static ParseStringDelegate GetParseMethod(Type type);
    public static ParseStringSpanDelegate GetParseStringSpanMethod(Type type);
    public static ICollection`1<string> ParseStringCollection(string value, Type createType);
    public static ICollection`1<string> ParseStringCollection(ReadOnlySpan`1<char> value, Type createType);
    public static ICollection`1<int> ParseIntCollection(string value, Type createType);
    public static ICollection`1<int> ParseIntCollection(ReadOnlySpan`1<char> value, Type createType);
    public static ICollection`1<T> ParseCollection(string value, Type createType, ParseStringDelegate parseFn);
    public static ICollection`1<T> ParseCollection(ReadOnlySpan`1<char> value, Type createType, ParseStringSpanDelegate parseFn);
    public static object ParseCollectionType(string value, Type createType, Type elementType, ParseStringDelegate parseFn);
    public static object ParseCollectionType(ReadOnlySpan`1<char> value, Type createType, Type elementType, ParseStringSpanDelegate parseFn);
}
internal static class ServiceStack.Text.Common.DeserializeCustomGenericType`1 : object {
    private static ITypeSerializer Serializer;
    private static DeserializeCustomGenericType`1();
    public static ParseStringDelegate GetParseMethod(Type type);
    public static ParseStringSpanDelegate GetParseStringSpanMethod(Type type);
    public static object ParseTuple(Type tupleType, string value);
    public static object ParseTuple(Type tupleType, ReadOnlySpan`1<char> value);
}
public static class ServiceStack.Text.Common.DeserializeDictionary`1 : object {
    private static ITypeSerializer Serializer;
    private static int KeyIndex;
    private static int ValueIndex;
    private static Dictionary`2<TypesKey<TSerializer>, ParseDictionaryDelegate<TSerializer>> ParseDelegateCache;
    private static Type[] signature;
    private static DeserializeDictionary`1();
    public static ParseStringDelegate GetParseMethod(Type type);
    public static ParseStringSpanDelegate GetParseStringSpanMethod(Type type);
    public static JsonObject ParseJsonObject(string value);
    public static T ParseInheritedJsonObject(ReadOnlySpan`1<char> value);
    public static JsonObject ParseJsonObject(ReadOnlySpan`1<char> value);
    public static Dictionary`2<string, string> ParseStringDictionary(string value);
    public static Dictionary`2<string, string> ParseStringDictionary(ReadOnlySpan`1<char> value);
    public static IDictionary ParseIDictionary(string value, Type dictType);
    public static IDictionary ParseIDictionary(ReadOnlySpan`1<char> value, Type dictType);
    public static IDictionary`2<TKey, TValue> ParseDictionary(string value, Type createMapType, ParseStringDelegate parseKeyFn, ParseStringDelegate parseValueFn);
    public static IDictionary`2<TKey, TValue> ParseDictionary(ReadOnlySpan`1<char> value, Type createMapType, ParseStringSpanDelegate parseKeyFn, ParseStringSpanDelegate parseValueFn);
    private static int VerifyAndGetStartIndex(ReadOnlySpan`1<char> value, Type createMapType);
    public static object ParseDictionaryType(string value, Type createMapType, Type[] argTypes, ParseStringDelegate keyParseFn, ParseStringDelegate valueParseFn);
    public static object ParseDictionaryType(ReadOnlySpan`1<char> value, Type createMapType, Type[] argTypes, ParseStringSpanDelegate keyParseFn, ParseStringSpanDelegate valueParseFn);
}
internal static class ServiceStack.Text.Common.DeserializeEnumerable`2 : object {
    private static ParseStringSpanDelegate CacheFn;
    public static ParseStringDelegate Parse { get; }
    public static ParseStringSpanDelegate ParseStringSpan { get; }
    private static DeserializeEnumerable`2();
    public static ParseStringDelegate get_Parse();
    public static ParseStringSpanDelegate get_ParseStringSpan();
    public static ParseStringDelegate GetParseFn();
    public static ParseStringSpanDelegate GetParseStringSpanFn();
}
internal static class ServiceStack.Text.Common.DeserializeKeyValuePair`1 : object {
    private static ITypeSerializer Serializer;
    private static int KeyIndex;
    private static int ValueIndex;
    private static Dictionary`2<string, ParseKeyValuePairDelegate<TSerializer>> ParseDelegateCache;
    private static Type[] signature;
    private static DeserializeKeyValuePair`1();
    public static ParseStringDelegate GetParseMethod(Type type);
    public static ParseStringSpanDelegate GetParseStringSpanMethod(Type type);
    public static object ParseKeyValuePair(string value, Type createMapType, ParseStringDelegate parseKeyFn, ParseStringDelegate parseValueFn);
    public static object ParseKeyValuePair(ReadOnlySpan`1<char> value, Type createMapType, ParseStringSpanDelegate parseKeyFn, ParseStringSpanDelegate parseValueFn);
    private static int VerifyAndGetStartIndex(ReadOnlySpan`1<char> value, Type createMapType);
    public static object ParseKeyValuePairType(string value, Type createMapType, Type[] argTypes, ParseStringDelegate keyParseFn, ParseStringDelegate valueParseFn);
    public static object ParseKeyValuePairType(ReadOnlySpan`1<char> value, Type createMapType, Type[] argTypes, ParseStringSpanDelegate keyParseFn, ParseStringSpanDelegate valueParseFn);
    private static string GetTypesKey(Type[] types);
}
public static class ServiceStack.Text.Common.DeserializeList`2 : object {
    private static ParseStringSpanDelegate CacheFn;
    public static ParseStringDelegate Parse { get; }
    public static ParseStringSpanDelegate ParseStringSpan { get; }
    private static DeserializeList`2();
    public static ParseStringDelegate get_Parse();
    public static ParseStringSpanDelegate get_ParseStringSpan();
    public static ParseStringDelegate GetParseFn();
    public static ParseStringSpanDelegate GetParseStringSpanFn();
}
public static class ServiceStack.Text.Common.DeserializeListWithElements`1 : object {
    internal static ITypeSerializer Serializer;
    private static Dictionary`2<Type, ParseListDelegate<TSerializer>> ParseDelegateCache;
    private static Type[] signature;
    private static DeserializeListWithElements`1();
    public static Func`4<string, Type, ParseStringDelegate, object> GetListTypeParseFn(Type createListType, Type elementType, ParseStringDelegate parseFn);
    public static ParseListDelegate<TSerializer> GetListTypeParseStringSpanFn(Type createListType, Type elementType, ParseStringSpanDelegate parseFn);
    public static ReadOnlySpan`1<char> StripList(ReadOnlySpan`1<char> value);
    public static List`1<string> ParseStringList(string value);
    public static List`1<string> ParseStringList(ReadOnlySpan`1<char> value);
    public static List`1<int> ParseIntList(string value);
    public static List`1<int> ParseIntList(ReadOnlySpan`1<char> value);
    public static List`1<byte> ParseByteList(string value);
    public static List`1<byte> ParseByteList(ReadOnlySpan`1<char> value);
}
public static class ServiceStack.Text.Common.DeserializeListWithElements`2 : object {
    private static ITypeSerializer Serializer;
    private static DeserializeListWithElements`2();
    public static ICollection`1<T> ParseGenericList(string value, Type createListType, ParseStringDelegate parseFn);
    public static ICollection`1<T> ParseGenericList(ReadOnlySpan`1<char> value, Type createListType, ParseStringSpanDelegate parseFn);
}
internal static class ServiceStack.Text.Common.DeserializeSpecializedCollections`2 : object {
    private static ParseStringSpanDelegate CacheFn;
    public static ParseStringDelegate Parse { get; }
    public static ParseStringSpanDelegate ParseStringSpan { get; }
    private static DeserializeSpecializedCollections`2();
    public static ParseStringDelegate get_Parse();
    public static ParseStringSpanDelegate get_ParseStringSpan();
    public static ParseStringDelegate GetParseFn();
    public static ParseStringSpanDelegate GetParseStringSpanFn();
    public static Queue`1<string> ParseStringQueue(string value);
    public static Queue`1<string> ParseStringQueue(ReadOnlySpan`1<char> value);
    public static Queue`1<int> ParseIntQueue(string value);
    public static Queue`1<int> ParseIntQueue(ReadOnlySpan`1<char> value);
    internal static ParseStringSpanDelegate GetGenericQueueParseFn();
    public static Stack`1<string> ParseStringStack(string value);
    public static Stack`1<string> ParseStringStack(ReadOnlySpan`1<char> value);
    public static Stack`1<int> ParseIntStack(string value);
    public static Stack`1<int> ParseIntStack(ReadOnlySpan`1<char> value);
    internal static ParseStringSpanDelegate GetGenericStackParseFn();
    public static ParseStringDelegate GetEnumerableParseFn();
    public static ParseStringSpanDelegate GetEnumerableParseStringSpanFn();
    public static ParseStringDelegate GetGenericEnumerableParseFn();
    public static ParseStringSpanDelegate GetGenericEnumerableParseStringSpanFn();
}
public class ServiceStack.Text.Common.DeserializeStringSpanDelegate : MulticastDelegate {
    public DeserializeStringSpanDelegate(object object, IntPtr method);
    public virtual object Invoke(Type type, ReadOnlySpan`1<char> source);
    public virtual IAsyncResult BeginInvoke(Type type, ReadOnlySpan`1<char> source, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public static class ServiceStack.Text.Common.DeserializeType`1 : object {
    private static ITypeSerializer Serializer;
    private static DeserializeType`1();
    internal static ParseStringDelegate GetParseMethod(TypeConfig typeConfig);
    internal static ParseStringSpanDelegate GetParseStringSpanMethod(TypeConfig typeConfig);
    public static object ObjectStringToType(ReadOnlySpan`1<char> strType);
    public static Type ExtractType(string strType);
    public static Type ExtractType(ReadOnlySpan`1<char> strType);
    public static object ParseAbstractType(ReadOnlySpan`1<char> value);
    public static object ParseQuotedPrimitive(string value);
    public static object ParsePrimitive(string value);
    public static object ParsePrimitive(ReadOnlySpan`1<char> value);
    internal static object ParsePrimitive(string value, char firstChar);
}
[ExtensionAttribute]
public static class ServiceStack.Text.Common.DeserializeTypeExensions : object {
    [ExtensionAttribute]
public static bool Has(ParseAsType flags, ParseAsType flag);
    [ExtensionAttribute]
public static object ParseNumber(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static object ParseNumber(ReadOnlySpan`1<char> value, bool bestFit);
}
internal static class ServiceStack.Text.Common.DeserializeTypeRef : object {
    private static Dictionary`2<Type, KeyValuePair`2[]> TypeAccessorsCache;
    private static DeserializeTypeRef();
    internal static SerializationException CreateSerializationError(Type type, string strType);
    internal static SerializationException GetSerializationException(string propertyName, string propertyValueString, Type propertyType, Exception e);
    internal static KeyValuePair`2[] GetCachedTypeAccessors(Type type, ITypeSerializer serializer);
    internal static KeyValuePair`2[] GetTypeAccessors(TypeConfig typeConfig, ITypeSerializer serializer);
}
internal static class ServiceStack.Text.Common.DeserializeTypeRefJson : object {
    private static JsonTypeSerializer Serializer;
    private static DeserializeTypeRefJson();
    internal static object StringToType(ReadOnlySpan`1<char> strType, TypeConfig typeConfig, EmptyCtorDelegate ctorFn, KeyValuePair`2[] typeAccessors);
}
internal static class ServiceStack.Text.Common.DeserializeTypeRefJsv : object {
    private static JsvTypeSerializer Serializer;
    private static ReadOnlyMemory`1<char> typeAttr;
    private static DeserializeTypeRefJsv();
    internal static object StringToType(ReadOnlySpan`1<char> strType, TypeConfig typeConfig, EmptyCtorDelegate ctorFn, KeyValuePair`2[] typeAccessors);
}
public class ServiceStack.Text.Common.DeserializeTypeUtils : object {
    public static ParseStringDelegate GetParseMethod(Type type);
    public static ParseStringSpanDelegate GetParseStringSpanMethod(Type type);
    public static ConstructorInfo GetTypeStringConstructor(Type type);
}
public interface ServiceStack.Text.Common.ITypeSerializer {
    public ObjectDeserializerDelegate ObjectDeserializer { get; public set; }
    public bool IncludeNullValues { get; }
    public bool IncludeNullValuesInDictionaries { get; }
    public string TypeAttrInObject { get; }
    public abstract virtual ObjectDeserializerDelegate get_ObjectDeserializer();
    public abstract virtual void set_ObjectDeserializer(ObjectDeserializerDelegate value);
    public abstract virtual bool get_IncludeNullValues();
    public abstract virtual bool get_IncludeNullValuesInDictionaries();
    public abstract virtual string get_TypeAttrInObject();
    public abstract virtual WriteObjectDelegate GetWriteFn();
    public abstract virtual WriteObjectDelegate GetWriteFn(Type type);
    public abstract virtual TypeInfo GetTypeInfo(Type type);
    public abstract virtual void WriteRawString(TextWriter writer, string value);
    public abstract virtual void WritePropertyName(TextWriter writer, string value);
    public abstract virtual void WriteBuiltIn(TextWriter writer, object value);
    public abstract virtual void WriteObjectString(TextWriter writer, object value);
    public abstract virtual void WriteException(TextWriter writer, object value);
    public abstract virtual void WriteString(TextWriter writer, string value);
    public abstract virtual void WriteFormattableObjectString(TextWriter writer, object value);
    public abstract virtual void WriteDateTime(TextWriter writer, object oDateTime);
    public abstract virtual void WriteNullableDateTime(TextWriter writer, object dateTime);
    public abstract virtual void WriteDateTimeOffset(TextWriter writer, object oDateTimeOffset);
    public abstract virtual void WriteNullableDateTimeOffset(TextWriter writer, object dateTimeOffset);
    public abstract virtual void WriteTimeSpan(TextWriter writer, object timeSpan);
    public abstract virtual void WriteNullableTimeSpan(TextWriter writer, object timeSpan);
    public abstract virtual void WriteGuid(TextWriter writer, object oValue);
    public abstract virtual void WriteNullableGuid(TextWriter writer, object oValue);
    public abstract virtual void WriteBytes(TextWriter writer, object oByteValue);
    public abstract virtual void WriteChar(TextWriter writer, object charValue);
    public abstract virtual void WriteByte(TextWriter writer, object byteValue);
    public abstract virtual void WriteSByte(TextWriter writer, object sbyteValue);
    public abstract virtual void WriteInt16(TextWriter writer, object intValue);
    public abstract virtual void WriteUInt16(TextWriter writer, object intValue);
    public abstract virtual void WriteInt32(TextWriter writer, object intValue);
    public abstract virtual void WriteUInt32(TextWriter writer, object uintValue);
    public abstract virtual void WriteInt64(TextWriter writer, object longValue);
    public abstract virtual void WriteUInt64(TextWriter writer, object ulongValue);
    public abstract virtual void WriteBool(TextWriter writer, object boolValue);
    public abstract virtual void WriteFloat(TextWriter writer, object floatValue);
    public abstract virtual void WriteDouble(TextWriter writer, object doubleValue);
    public abstract virtual void WriteDecimal(TextWriter writer, object decimalValue);
    public abstract virtual void WriteEnum(TextWriter writer, object enumValue);
    public abstract virtual ParseStringDelegate GetParseFn();
    public abstract virtual ParseStringSpanDelegate GetParseStringSpanFn();
    public abstract virtual ParseStringDelegate GetParseFn(Type type);
    public abstract virtual ParseStringSpanDelegate GetParseStringSpanFn(Type type);
    public abstract virtual string ParseRawString(string value);
    public abstract virtual string ParseString(string value);
    public abstract virtual string ParseString(ReadOnlySpan`1<char> value);
    public abstract virtual string UnescapeString(string value);
    public abstract virtual ReadOnlySpan`1<char> UnescapeString(ReadOnlySpan`1<char> value);
    public abstract virtual object UnescapeStringAsObject(ReadOnlySpan`1<char> value);
    public abstract virtual string UnescapeSafeString(string value);
    public abstract virtual ReadOnlySpan`1<char> UnescapeSafeString(ReadOnlySpan`1<char> value);
    public abstract virtual string EatTypeValue(string value, Int32& i);
    public abstract virtual ReadOnlySpan`1<char> EatTypeValue(ReadOnlySpan`1<char> value, Int32& i);
    public abstract virtual bool EatMapStartChar(string value, Int32& i);
    public abstract virtual bool EatMapStartChar(ReadOnlySpan`1<char> value, Int32& i);
    public abstract virtual string EatMapKey(string value, Int32& i);
    public abstract virtual ReadOnlySpan`1<char> EatMapKey(ReadOnlySpan`1<char> value, Int32& i);
    public abstract virtual bool EatMapKeySeperator(string value, Int32& i);
    public abstract virtual bool EatMapKeySeperator(ReadOnlySpan`1<char> value, Int32& i);
    public abstract virtual void EatWhitespace(string value, Int32& i);
    public abstract virtual void EatWhitespace(ReadOnlySpan`1<char> value, Int32& i);
    public abstract virtual string EatValue(string value, Int32& i);
    public abstract virtual ReadOnlySpan`1<char> EatValue(ReadOnlySpan`1<char> value, Int32& i);
    public abstract virtual bool EatItemSeperatorOrMapEndChar(string value, Int32& i);
    public abstract virtual bool EatItemSeperatorOrMapEndChar(ReadOnlySpan`1<char> value, Int32& i);
}
public class ServiceStack.Text.Common.JsReader`1 : object {
    private static ITypeSerializer Serializer;
    private static JsReader`1();
    public ParseStringDelegate GetParseFn();
    public ParseStringSpanDelegate GetParseStringSpanFn();
    private ParseStringDelegate GetCoreParseFn();
    private ParseStringSpanDelegate GetCoreParseStringSpanFn();
    public static void InitAot();
    [CompilerGeneratedAttribute]
private object <GetCoreParseFn>b__3_0(string v);
}
internal static class ServiceStack.Text.Common.JsState : object {
    [ThreadStaticAttribute]
internal static int WritingKeyCount;
    [ThreadStaticAttribute]
internal static bool IsWritingValue;
    [ThreadStaticAttribute]
internal static bool IsWritingDynamic;
    [ThreadStaticAttribute]
internal static bool IsRuntimeType;
    [ThreadStaticAttribute]
internal static bool QueryStringMode;
    [ThreadStaticAttribute]
internal static int Depth;
    [ThreadStaticAttribute]
internal static bool IsCsv;
    [ThreadStaticAttribute]
internal static HashSet`1<Type> InSerializerFns;
    [ThreadStaticAttribute]
internal static HashSet`1<Type> InDeserializerFns;
    private static JsState();
    internal static void RegisterSerializer();
    internal static void UnRegisterSerializer();
    internal static bool InSerializer();
    internal static void RegisterDeserializer();
    internal static void UnRegisterDeserializer();
    internal static bool InDeserializer();
    internal static bool Traverse(object value);
    internal static void UnTraverse();
    internal static void Reset();
}
public static class ServiceStack.Text.Common.JsWriter : object {
    public static string TypeAttr;
    public static char MapStartChar;
    public static char MapKeySeperator;
    public static char ItemSeperator;
    public static char MapEndChar;
    public static string MapNullValue;
    public static string EmptyMap;
    public static char ListStartChar;
    public static char ListEndChar;
    public static char ReturnChar;
    public static char LineFeedChar;
    public static char QuoteChar;
    public static string QuoteString;
    public static string EscapedQuoteString;
    public static string ItemSeperatorString;
    public static string MapKeySeperatorString;
    public static Char[] CsvChars;
    public static Char[] EscapeChars;
    private static int LengthFromLargestChar;
    private static Boolean[] EscapeCharFlags;
    private static JsWriter();
    public static void WriteDynamic(Action callback);
    public static bool HasAnyEscapeChars(string value);
    internal static void WriteItemSeperatorIfRanOnce(TextWriter writer, Boolean& ranOnce);
    internal static bool ShouldUseDefaultToStringMethod(Type type);
    public static ITypeSerializer GetTypeSerializer();
    public static void WriteEnumFlags(TextWriter writer, object enumFlagValue);
    public static bool ShouldAllowRuntimeType(Type type);
    public static void AssertAllowedRuntimeType(Type type);
}
public class ServiceStack.Text.Common.JsWriter`1 : object {
    private static ITypeSerializer Serializer;
    public Dictionary`2<Type, WriteObjectDelegate> SpecialTypes;
    private static JsWriter`1();
    public WriteObjectDelegate GetValueTypeToStringMethod(Type type);
    public WriteObjectDelegate GetWriteFn();
    public void WriteValue(TextWriter writer, object value);
    private void ThrowTaskNotSupported(TextWriter writer, object value);
    private WriteObjectDelegate GetCoreWriteFn();
    public WriteObjectDelegate GetSpecialWriteFn(Type type);
    public void WriteType(TextWriter writer, object value);
    public static void InitAot();
}
public class ServiceStack.Text.Common.ObjectDeserializerDelegate : MulticastDelegate {
    public ObjectDeserializerDelegate(object object, IntPtr method);
    public virtual object Invoke(ReadOnlySpan`1<char> value);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<char> value, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class ServiceStack.Text.Common.ParseDelegate : MulticastDelegate {
    public ParseDelegate(object object, IntPtr method);
    public virtual object Invoke(string value);
    public virtual IAsyncResult BeginInvoke(string value, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class ServiceStack.Text.Common.ParseFactoryDelegate : MulticastDelegate {
    public ParseFactoryDelegate(object object, IntPtr method);
    public virtual ParseStringSpanDelegate Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual ParseStringSpanDelegate EndInvoke(IAsyncResult result);
}
internal static class ServiceStack.Text.Common.ParseMethodUtilities : object {
    public static ParseStringDelegate GetParseFn(string parseMethod);
    public static ParseStringSpanDelegate GetParseStringSpanFn(string parseMethod);
}
public class ServiceStack.Text.Common.ParseStringDelegate : MulticastDelegate {
    public ParseStringDelegate(object object, IntPtr method);
    public virtual object Invoke(string stringValue);
    public virtual IAsyncResult BeginInvoke(string stringValue, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class ServiceStack.Text.Common.ParseStringSpanDelegate : MulticastDelegate {
    public ParseStringSpanDelegate(object object, IntPtr method);
    public virtual object Invoke(ReadOnlySpan`1<char> value);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<char> value, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal static class ServiceStack.Text.Common.ParseUtils : object {
    public static object NullValueType(Type type);
    public static object ParseObject(string value);
    public static object ParseEnum(Type type, string value);
    public static ParseStringDelegate GetSpecialParseMethod(Type type);
    public static Type ParseType(string assemblyQualifiedName);
    public static object TryParseEnum(Type enumType, string str);
}
internal class ServiceStack.Text.Common.SpecializedEnumerableElements`2 : object {
    public static ConvertObjectDelegate ConvertFn;
    private static SpecializedEnumerableElements`2();
    public static object Convert(object enumerable);
    public static object ConvertFromCollection(object enumerable);
}
internal class ServiceStack.Text.Common.SpecializedQueueElements`1 : object {
    public static Queue`1<T> ConvertToQueue(object enumerable);
    public static Stack`1<T> ConvertToStack(object enumerable);
}
public static class ServiceStack.Text.Common.StaticParseMethod`1 : object {
    private static string ParseMethod;
    private static string ParseStringSpanMethod;
    private static ParseStringDelegate CacheFn;
    private static ParseStringSpanDelegate CacheStringSpanFn;
    public static ParseStringDelegate Parse { get; }
    public static ParseStringSpanDelegate ParseStringSpan { get; }
    private static StaticParseMethod`1();
    public static ParseStringDelegate get_Parse();
    public static ParseStringSpanDelegate get_ParseStringSpan();
}
internal static class ServiceStack.Text.Common.StaticParseRefTypeMethod`2 : object {
    private static string ParseMethod;
    private static string ParseStringSpanMethod;
    private static ParseStringDelegate CacheFn;
    private static ParseStringSpanDelegate CacheStringSpanFn;
    public static ParseStringDelegate Parse { get; }
    public static ParseStringSpanDelegate ParseStringSpan { get; }
    private static StaticParseRefTypeMethod`2();
    public static ParseStringDelegate get_Parse();
    public static ParseStringSpanDelegate get_ParseStringSpan();
}
public static class ServiceStack.Text.Common.ToStringDictionaryMethods`3 : object {
    private static ITypeSerializer Serializer;
    private static ToStringDictionaryMethods`3();
    public static void WriteIDictionary(TextWriter writer, object oMap, WriteObjectDelegate writeKeyFn, WriteObjectDelegate writeValueFn);
    public static void WriteGenericIDictionary(TextWriter writer, IDictionary`2<TKey, TValue> map, WriteObjectDelegate writeKeyFn, WriteObjectDelegate writeValueFn);
}
internal class ServiceStack.Text.Common.TypeAccessor : object {
    internal ParseStringSpanDelegate GetProperty;
    internal SetMemberDelegate SetProperty;
    internal Type PropertyType;
    public static Type ExtractType(ITypeSerializer Serializer, string strType);
    public static Type ExtractType(ITypeSerializer Serializer, ReadOnlySpan`1<char> strType);
    public static TypeAccessor Create(ITypeSerializer serializer, TypeConfig typeConfig, PropertyInfo propertyInfo);
    internal static ParseStringSpanDelegate GetPropertyMethod(ITypeSerializer serializer, PropertyInfo propertyInfo);
    private static SetMemberDelegate GetSetPropertyMethod(TypeConfig typeConfig, PropertyInfo propertyInfo);
    public static TypeAccessor Create(ITypeSerializer serializer, TypeConfig typeConfig, FieldInfo fieldInfo);
    private static SetMemberDelegate GetSetFieldMethod(TypeConfig typeConfig, FieldInfo fieldInfo);
}
[ExtensionAttribute]
internal static class ServiceStack.Text.Common.TypeAccessorUtils : object {
    [ExtensionAttribute]
internal static TypeAccessor Get(KeyValuePair`2[] accessors, ReadOnlySpan`1<char> propertyName, bool lenient);
    private static TypeAccessor FindPropertyAccessor(KeyValuePair`2[] accessors, ReadOnlySpan`1<char> propertyName);
}
internal class ServiceStack.Text.Common.WriteDelegate : MulticastDelegate {
    public WriteDelegate(object object, IntPtr method);
    public virtual void Invoke(TextWriter writer, object value);
    public virtual IAsyncResult BeginInvoke(TextWriter writer, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class ServiceStack.Text.Common.WriteDictionary`1 : object {
    private static ITypeSerializer Serializer;
    private static Dictionary`2<MapKey<TSerializer>, WriteMapDelegate> CacheFns;
    private static WriteDictionary`1();
    public static Action`4<TextWriter, object, WriteObjectDelegate, WriteObjectDelegate> GetWriteGenericDictionary(Type keyType, Type valueType);
    public static void WriteIDictionary(TextWriter writer, object oMap);
}
internal class ServiceStack.Text.Common.WriteGenericListDelegate`1 : MulticastDelegate {
    public WriteGenericListDelegate`1(object object, IntPtr method);
    public virtual void Invoke(TextWriter writer, IList`1<T> list, WriteObjectDelegate toStringFn);
    public virtual IAsyncResult BeginInvoke(TextWriter writer, IList`1<T> list, WriteObjectDelegate toStringFn, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class ServiceStack.Text.Common.WriteListDelegate : MulticastDelegate {
    public WriteListDelegate(object object, IntPtr method);
    public virtual void Invoke(TextWriter writer, object oList, WriteObjectDelegate toStringFn);
    public virtual IAsyncResult BeginInvoke(TextWriter writer, object oList, WriteObjectDelegate toStringFn, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class ServiceStack.Text.Common.WriteLists : object {
    public static void WriteListString(ITypeSerializer serializer, TextWriter writer, object list);
    public static void WriteListString(ITypeSerializer serializer, TextWriter writer, List`1<string> list);
    public static void WriteIListString(ITypeSerializer serializer, TextWriter writer, object list);
    public static void WriteIListString(ITypeSerializer serializer, TextWriter writer, IList`1<string> list);
    public static void WriteBytes(ITypeSerializer serializer, TextWriter writer, object byteValue);
    public static void WriteStringArray(ITypeSerializer serializer, TextWriter writer, object oList);
}
internal static class ServiceStack.Text.Common.WriteLists`2 : object {
    private static WriteObjectDelegate CacheFn;
    private static ITypeSerializer Serializer;
    public static WriteObjectDelegate Write { get; }
    private static WriteLists`2();
    public static WriteObjectDelegate get_Write();
    public static WriteObjectDelegate GetWriteFn();
}
public static class ServiceStack.Text.Common.WriteListsOfElements`1 : object {
    private static ITypeSerializer Serializer;
    private static Dictionary`2<Type, WriteObjectDelegate> ListCacheFns;
    private static Dictionary`2<Type, WriteObjectDelegate> IListCacheFns;
    private static Dictionary`2<Type, WriteObjectDelegate> CacheFns;
    private static Dictionary`2<Type, WriteObjectDelegate> EnumerableCacheFns;
    private static Dictionary`2<Type, WriteObjectDelegate> ListValueTypeCacheFns;
    private static Dictionary`2<Type, WriteObjectDelegate> IListValueTypeCacheFns;
    private static WriteListsOfElements`1();
    public static WriteObjectDelegate GetListWriteFn(Type elementType);
    public static WriteObjectDelegate GetIListWriteFn(Type elementType);
    public static WriteObjectDelegate GetGenericWriteArray(Type elementType);
    public static WriteObjectDelegate GetGenericWriteEnumerable(Type elementType);
    public static WriteObjectDelegate GetWriteListValueType(Type elementType);
    public static WriteObjectDelegate GetWriteIListValueType(Type elementType);
    public static void WriteIEnumerable(TextWriter writer, object oValueCollection);
}
public static class ServiceStack.Text.Common.WriteListsOfElements`2 : object {
    private static WriteObjectDelegate ElementWriteFn;
    private static WriteListsOfElements`2();
    public static void WriteList(TextWriter writer, object oList);
    public static void WriteGenericList(TextWriter writer, List`1<T> list);
    public static void WriteListValueType(TextWriter writer, object list);
    public static void WriteGenericListValueType(TextWriter writer, List`1<T> list);
    public static void WriteIList(TextWriter writer, object oList);
    public static void WriteGenericIList(TextWriter writer, IList`1<T> list);
    public static void WriteIListValueType(TextWriter writer, object list);
    public static void WriteGenericIListValueType(TextWriter writer, IList`1<T> list);
    public static void WriteArray(TextWriter writer, object oArrayValue);
    public static void WriteGenericArrayValueType(TextWriter writer, object oArray);
    public static void WriteGenericArrayValueType(TextWriter writer, T[] array);
    private static void WriteGenericArrayMultiDimension(TextWriter writer, Array array, int rank, Int32[] indices);
    public static void WriteGenericArray(TextWriter writer, Array array);
    public static void WriteEnumerable(TextWriter writer, object oEnumerable);
    public static void WriteGenericEnumerable(TextWriter writer, IEnumerable`1<T> enumerable);
    public static void WriteGenericEnumerableValueType(TextWriter writer, IEnumerable`1<T> enumerable);
}
internal class ServiceStack.Text.Common.WriteMapDelegate : MulticastDelegate {
    public WriteMapDelegate(object object, IntPtr method);
    public virtual void Invoke(TextWriter writer, object oMap, WriteObjectDelegate writeKeyFn, WriteObjectDelegate writeValueFn);
    public virtual IAsyncResult BeginInvoke(TextWriter writer, object oMap, WriteObjectDelegate writeKeyFn, WriteObjectDelegate writeValueFn, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ServiceStack.Text.Common.WriteObjectDelegate : MulticastDelegate {
    public WriteObjectDelegate(object object, IntPtr method);
    public virtual void Invoke(TextWriter writer, object obj);
    public virtual IAsyncResult BeginInvoke(TextWriter writer, object obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class ServiceStack.Text.Common.WriteType`2 : object {
    private static ITypeSerializer Serializer;
    private static WriteObjectDelegate CacheFn;
    internal static TypePropertyWriter[] PropertyWriters;
    private static WriteObjectDelegate WriteTypeInfo;
    private static Char[] ArrayBrackets;
    private static bool IsIncluded { get; }
    private static bool IsExcluded { get; }
    public static WriteObjectDelegate Write { get; }
    private static WriteType`2();
    private static bool get_IsIncluded();
    private static bool get_IsExcluded();
    public static void TypeInfoWriter(TextWriter writer, object obj);
    private static bool ShouldSkipType();
    private static bool TryWriteSelfType(TextWriter writer);
    private static bool TryWriteTypeInfo(TextWriter writer, object obj);
    public static WriteObjectDelegate get_Write();
    private static WriteObjectDelegate GetWriteFn();
    private static Func`2<T, bool> GetShouldSerializeMethod(MemberInfo member);
    private static Func`3<T, string, Nullable`1<bool>> ShouldSerialize(Type type);
    private static bool Init();
    public static void WriteObjectType(TextWriter writer, object value);
    public static void WriteEmptyType(TextWriter writer, object value);
    public static void WriteAbstractProperties(TextWriter writer, object value);
    public static void WriteProperties(TextWriter writer, object instance);
    private static void WriteLateboundProperties(TextWriter writer, object value, Type valueType);
    internal static string GetPropertyName(string propertyName, Config config);
    public static void WriteComplexQueryStringProperties(string typeName, TextWriter writer, object instance);
    public static void WriteQueryString(TextWriter writer, object instance);
}
public class ServiceStack.Text.Config : object {
    private static Config instance;
    internal static bool HasInit;
    private static string InitStackTrace;
    [CompilerGeneratedAttribute]
private bool <ConvertObjectTypesIntoStringDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TryToParsePrimitiveTypeValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TryToParseNumericType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TryParseIntoBestFit>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseAsType <ParsePrimitiveFloatingPointTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseAsType <ParsePrimitiveIntegerTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeDefaultValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeNullValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeNullValuesInDictionaries>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDefaultEnums>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatEnumAsInteger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Indent>k__BackingField;
    private string typeAttr;
    private Nullable`1<ReadOnlyMemory`1<char>> typeAttrSpan;
    [CompilerGeneratedAttribute]
private string <DateTimeFormat>k__BackingField;
    private string jsonTypeAttrInObject;
    private string jsvTypeAttrInObject;
    [CompilerGeneratedAttribute]
private Func`2<Type, string> <TypeWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, Type> <TypeFinder>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, object> <ParsePrimitiveFn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateHandler <DateHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanHandler <TimeSpanHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyConvention <PropertyConvention>k__BackingField;
    [CompilerGeneratedAttribute]
private TextCase <TextCase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipDateTimeConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysUseUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssumeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppendUtcOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferInterfaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePublicFields>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private DeserializationErrorDelegate <OnDeserializationError>k__BackingField;
    [CompilerGeneratedAttribute]
private EmptyCtorFactoryDelegate <ModelFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExcludePropertyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<Type> <ExcludeTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ExcludeTypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeUnicode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeHtmlChars>k__BackingField;
    internal static Config Instance { get; }
    public bool ConvertObjectTypesIntoStringDictionary { get; public set; }
    public bool TryToParsePrimitiveTypeValues { get; public set; }
    public bool TryToParseNumericType { get; public set; }
    public bool TryParseIntoBestFit { get; public set; }
    public ParseAsType ParsePrimitiveFloatingPointTypes { get; public set; }
    public ParseAsType ParsePrimitiveIntegerTypes { get; public set; }
    public bool ExcludeDefaultValues { get; public set; }
    public bool IncludeNullValues { get; public set; }
    public bool IncludeNullValuesInDictionaries { get; public set; }
    public bool IncludeDefaultEnums { get; public set; }
    public bool TreatEnumAsInteger { get; public set; }
    public bool ExcludeTypeInfo { get; public set; }
    public bool IncludeTypeInfo { get; public set; }
    public bool Indent { get; public set; }
    public string TypeAttr { get; public set; }
    public ReadOnlyMemory`1<char> TypeAttrMemory { get; }
    public string DateTimeFormat { get; public set; }
    internal string JsonTypeAttrInObject { get; }
    internal string JsvTypeAttrInObject { get; }
    public Func`2<Type, string> TypeWriter { get; public set; }
    public Func`2<string, Type> TypeFinder { get; public set; }
    public Func`2<string, object> ParsePrimitiveFn { get; public set; }
    public DateHandler DateHandler { get; public set; }
    public TimeSpanHandler TimeSpanHandler { get; public set; }
    public PropertyConvention PropertyConvention { get; public set; }
    public TextCase TextCase { get; public set; }
    [ObsoleteAttribute("Use TextCase = TextCase.CamelCase")]
public bool EmitCamelCaseNames { get; public set; }
    [ObsoleteAttribute("Use TextCase = TextCase.SnakeCase")]
public bool EmitLowercaseUnderscoreNames { get; public set; }
    public bool ThrowOnError { get; public set; }
    public bool SkipDateTimeConversion { get; public set; }
    public bool AlwaysUseUtc { get; public set; }
    public bool AssumeUtc { get; public set; }
    public bool AppendUtcOffset { get; public set; }
    public bool PreferInterfaces { get; public set; }
    public bool IncludePublicFields { get; public set; }
    public int MaxDepth { get; public set; }
    public DeserializationErrorDelegate OnDeserializationError { get; public set; }
    public EmptyCtorFactoryDelegate ModelFactory { get; public set; }
    public String[] ExcludePropertyReferences { get; public set; }
    public HashSet`1<Type> ExcludeTypes { get; public set; }
    public HashSet`1<string> ExcludeTypeNames { get; public set; }
    public bool EscapeUnicode { get; public set; }
    public bool EscapeHtmlChars { get; public set; }
    public static Config Defaults { get; }
    private Config(Config config);
    internal static Config get_Instance();
    public static Config AssertNotInit();
    public static void Init();
    public static void Init(Config config);
    public static void UnsafeInit(Config config);
    internal static void Reset();
    [CompilerGeneratedAttribute]
public bool get_ConvertObjectTypesIntoStringDictionary();
    [CompilerGeneratedAttribute]
public void set_ConvertObjectTypesIntoStringDictionary(bool value);
    [CompilerGeneratedAttribute]
public bool get_TryToParsePrimitiveTypeValues();
    [CompilerGeneratedAttribute]
public void set_TryToParsePrimitiveTypeValues(bool value);
    [CompilerGeneratedAttribute]
public bool get_TryToParseNumericType();
    [CompilerGeneratedAttribute]
public void set_TryToParseNumericType(bool value);
    [CompilerGeneratedAttribute]
public bool get_TryParseIntoBestFit();
    [CompilerGeneratedAttribute]
public void set_TryParseIntoBestFit(bool value);
    [CompilerGeneratedAttribute]
public ParseAsType get_ParsePrimitiveFloatingPointTypes();
    [CompilerGeneratedAttribute]
public void set_ParsePrimitiveFloatingPointTypes(ParseAsType value);
    [CompilerGeneratedAttribute]
public ParseAsType get_ParsePrimitiveIntegerTypes();
    [CompilerGeneratedAttribute]
public void set_ParsePrimitiveIntegerTypes(ParseAsType value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeDefaultValues();
    [CompilerGeneratedAttribute]
public void set_ExcludeDefaultValues(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeNullValues();
    [CompilerGeneratedAttribute]
public void set_IncludeNullValues(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeNullValuesInDictionaries();
    [CompilerGeneratedAttribute]
public void set_IncludeNullValuesInDictionaries(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeDefaultEnums();
    [CompilerGeneratedAttribute]
public void set_IncludeDefaultEnums(bool value);
    [CompilerGeneratedAttribute]
public bool get_TreatEnumAsInteger();
    [CompilerGeneratedAttribute]
public void set_TreatEnumAsInteger(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeTypeInfo();
    [CompilerGeneratedAttribute]
public void set_ExcludeTypeInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeTypeInfo();
    [CompilerGeneratedAttribute]
public void set_IncludeTypeInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_Indent();
    [CompilerGeneratedAttribute]
public void set_Indent(bool value);
    public string get_TypeAttr();
    public void set_TypeAttr(string value);
    public ReadOnlyMemory`1<char> get_TypeAttrMemory();
    [CompilerGeneratedAttribute]
public string get_DateTimeFormat();
    [CompilerGeneratedAttribute]
public void set_DateTimeFormat(string value);
    internal string get_JsonTypeAttrInObject();
    internal string get_JsvTypeAttrInObject();
    [CompilerGeneratedAttribute]
public Func`2<Type, string> get_TypeWriter();
    [CompilerGeneratedAttribute]
public void set_TypeWriter(Func`2<Type, string> value);
    [CompilerGeneratedAttribute]
public Func`2<string, Type> get_TypeFinder();
    [CompilerGeneratedAttribute]
public void set_TypeFinder(Func`2<string, Type> value);
    [CompilerGeneratedAttribute]
public Func`2<string, object> get_ParsePrimitiveFn();
    [CompilerGeneratedAttribute]
public void set_ParsePrimitiveFn(Func`2<string, object> value);
    [CompilerGeneratedAttribute]
public DateHandler get_DateHandler();
    [CompilerGeneratedAttribute]
public void set_DateHandler(DateHandler value);
    [CompilerGeneratedAttribute]
public TimeSpanHandler get_TimeSpanHandler();
    [CompilerGeneratedAttribute]
public void set_TimeSpanHandler(TimeSpanHandler value);
    [CompilerGeneratedAttribute]
public PropertyConvention get_PropertyConvention();
    [CompilerGeneratedAttribute]
public void set_PropertyConvention(PropertyConvention value);
    [CompilerGeneratedAttribute]
public TextCase get_TextCase();
    [CompilerGeneratedAttribute]
public void set_TextCase(TextCase value);
    public bool get_EmitCamelCaseNames();
    public void set_EmitCamelCaseNames(bool value);
    public bool get_EmitLowercaseUnderscoreNames();
    public void set_EmitLowercaseUnderscoreNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnError();
    [CompilerGeneratedAttribute]
public void set_ThrowOnError(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipDateTimeConversion();
    [CompilerGeneratedAttribute]
public void set_SkipDateTimeConversion(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlwaysUseUtc();
    [CompilerGeneratedAttribute]
public void set_AlwaysUseUtc(bool value);
    [CompilerGeneratedAttribute]
public bool get_AssumeUtc();
    [CompilerGeneratedAttribute]
public void set_AssumeUtc(bool value);
    [CompilerGeneratedAttribute]
public bool get_AppendUtcOffset();
    [CompilerGeneratedAttribute]
public void set_AppendUtcOffset(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreferInterfaces();
    [CompilerGeneratedAttribute]
public void set_PreferInterfaces(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludePublicFields();
    [CompilerGeneratedAttribute]
public void set_IncludePublicFields(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxDepth();
    [CompilerGeneratedAttribute]
public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
public DeserializationErrorDelegate get_OnDeserializationError();
    [CompilerGeneratedAttribute]
public void set_OnDeserializationError(DeserializationErrorDelegate value);
    [CompilerGeneratedAttribute]
public EmptyCtorFactoryDelegate get_ModelFactory();
    [CompilerGeneratedAttribute]
public void set_ModelFactory(EmptyCtorFactoryDelegate value);
    [CompilerGeneratedAttribute]
public String[] get_ExcludePropertyReferences();
    [CompilerGeneratedAttribute]
public void set_ExcludePropertyReferences(String[] value);
    [CompilerGeneratedAttribute]
public HashSet`1<Type> get_ExcludeTypes();
    [CompilerGeneratedAttribute]
public void set_ExcludeTypes(HashSet`1<Type> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ExcludeTypeNames();
    [CompilerGeneratedAttribute]
public void set_ExcludeTypeNames(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_EscapeUnicode();
    [CompilerGeneratedAttribute]
public void set_EscapeUnicode(bool value);
    [CompilerGeneratedAttribute]
public bool get_EscapeHtmlChars();
    [CompilerGeneratedAttribute]
public void set_EscapeHtmlChars(bool value);
    public static Config get_Defaults();
    public Config Populate(Config config);
}
public class ServiceStack.Text.Controller.CommandProcessor : object {
    [CompilerGeneratedAttribute]
private Object[] <Controllers>k__BackingField;
    private Dictionary`2<string, object> contextMap;
    private Object[] Controllers { get; private set; }
    public CommandProcessor(Object[] controllers);
    [CompilerGeneratedAttribute]
private Object[] get_Controllers();
    [CompilerGeneratedAttribute]
private void set_Controllers(Object[] value);
    public void Invoke(string commandUri);
    private static Object[] ConvertValuesToTypes(IList`1<string> values, IList`1<Type> types);
}
public class ServiceStack.Text.Controller.PathInfo : object {
    [CompilerGeneratedAttribute]
private string <ControllerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Options>k__BackingField;
    public string ControllerName { get; private set; }
    public string ActionName { get; private set; }
    public List`1<string> Arguments { get; private set; }
    public Dictionary`2<string, string> Options { get; private set; }
    public string FirstArgument { get; }
    public PathInfo(string actionName, String[] arguments);
    public PathInfo(string actionName, List`1<string> arguments, Dictionary`2<string, string> options);
    [CompilerGeneratedAttribute]
public string get_ControllerName();
    [CompilerGeneratedAttribute]
private void set_ControllerName(string value);
    [CompilerGeneratedAttribute]
public string get_ActionName();
    [CompilerGeneratedAttribute]
private void set_ActionName(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(List`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(Dictionary`2<string, string> value);
    public string get_FirstArgument();
    public T GetArgumentValue(int index);
    public static PathInfo Parse(string pathUri);
}
public class ServiceStack.Text.ConvertibleTypeKey : object {
    [CompilerGeneratedAttribute]
private Type <ToInstanceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <FromElementType>k__BackingField;
    public Type ToInstanceType { get; public set; }
    public Type FromElementType { get; public set; }
    public ConvertibleTypeKey(Type toInstanceType, Type fromElementType);
    [CompilerGeneratedAttribute]
public Type get_ToInstanceType();
    [CompilerGeneratedAttribute]
public void set_ToInstanceType(Type value);
    [CompilerGeneratedAttribute]
public Type get_FromElementType();
    [CompilerGeneratedAttribute]
public void set_FromElementType(Type value);
    public bool Equals(ConvertibleTypeKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("12")]
public class ServiceStack.Text.CsvAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CsvBehavior <CsvBehavior>k__BackingField;
    public CsvBehavior CsvBehavior { get; public set; }
    public CsvAttribute(CsvBehavior csvBehavior);
    [CompilerGeneratedAttribute]
public CsvBehavior get_CsvBehavior();
    [CompilerGeneratedAttribute]
public void set_CsvBehavior(CsvBehavior value);
}
public enum ServiceStack.Text.CsvBehavior : Enum {
    public int value__;
    public static CsvBehavior FirstEnumerable;
}
public static class ServiceStack.Text.CsvConfig : object {
    private static CultureInfo sRealNumberCultureInfo;
    [ThreadStaticAttribute]
private static string tsItemSeperatorString;
    private static string sItemSeperatorString;
    [ThreadStaticAttribute]
private static string tsItemDelimiterString;
    private static string sItemDelimiterString;
    private static string DefaultEscapedItemDelimiterString;
    [ThreadStaticAttribute]
private static string tsEscapedItemDelimiterString;
    private static string sEscapedItemDelimiterString;
    private static String[] defaultEscapeStrings;
    [ThreadStaticAttribute]
private static String[] tsEscapeStrings;
    private static String[] sEscapeStrings;
    [ThreadStaticAttribute]
private static string tsRowSeparatorString;
    private static string sRowSeparatorString;
    public static CultureInfo RealNumberCultureInfo { get; public set; }
    public static string ItemSeperatorString { get; public set; }
    public static string ItemDelimiterString { get; public set; }
    internal static string EscapedItemDelimiterString { get; internal set; }
    public static String[] EscapeStrings { get; private set; }
    public static string RowSeparatorString { get; public set; }
    private static CsvConfig();
    public static CultureInfo get_RealNumberCultureInfo();
    public static void set_RealNumberCultureInfo(CultureInfo value);
    public static string get_ItemSeperatorString();
    public static void set_ItemSeperatorString(string value);
    public static string get_ItemDelimiterString();
    public static void set_ItemDelimiterString(string value);
    internal static string get_EscapedItemDelimiterString();
    internal static void set_EscapedItemDelimiterString(string value);
    public static String[] get_EscapeStrings();
    private static void set_EscapeStrings(String[] value);
    private static String[] GetEscapeStrings();
    private static void ResetEscapeStrings();
    public static string get_RowSeparatorString();
    public static void set_RowSeparatorString(string value);
    public static void Reset();
}
public static class ServiceStack.Text.CsvConfig`1 : object {
    [CompilerGeneratedAttribute]
private static bool <OmitHeaders>k__BackingField;
    private static Dictionary`2<string, string> customHeadersMap;
    public static bool OmitHeaders { get; public set; }
    public static Dictionary`2<string, string> CustomHeadersMap { get; public set; }
    unknown static object CustomHeaders {public set; }
    [CompilerGeneratedAttribute]
public static bool get_OmitHeaders();
    [CompilerGeneratedAttribute]
public static void set_OmitHeaders(bool value);
    public static Dictionary`2<string, string> get_CustomHeadersMap();
    public static void set_CustomHeadersMap(Dictionary`2<string, string> value);
    public static void set_CustomHeaders(object value);
    public static void Reset();
}
internal class ServiceStack.Text.CsvDictionaryWriter : object {
    public static void WriteRow(TextWriter writer, IEnumerable`1<string> row);
    public static void WriteObjectRow(TextWriter writer, IEnumerable`1<object> row);
    public static void Write(TextWriter writer, IEnumerable`1<KeyValuePair`2<string, object>> records);
    public static void Write(TextWriter writer, IEnumerable`1<KeyValuePair`2<string, string>> records);
    public static void Write(TextWriter writer, IEnumerable`1<IDictionary`2<string, object>> records);
    public static void Write(TextWriter writer, IEnumerable`1<IDictionary`2<string, string>> records);
}
public class ServiceStack.Text.CsvReader : object {
    public static List`1<string> ParseLines(string csv);
    public static List`1<string> ParseFields(string line);
    public static List`1<string> ParseFields(string line, Func`2<string, string> parseFn);
    public static string EatValue(string value, Int32& i);
}
public class ServiceStack.Text.CsvReader`1 : object {
    [CompilerGeneratedAttribute]
private static List`1<string> <Headers>k__BackingField;
    internal static List`1<SetMemberDelegate`1<T>> PropertySetters;
    internal static Dictionary`2<string, SetMemberDelegate`1<T>> PropertySettersMap;
    internal static List`1<ParseStringDelegate> PropertyConverters;
    internal static Dictionary`2<string, ParseStringDelegate> PropertyConvertersMap;
    public static List`1<string> Headers { get; public set; }
    private static CsvReader`1();
    [CompilerGeneratedAttribute]
public static List`1<string> get_Headers();
    [CompilerGeneratedAttribute]
public static void set_Headers(List`1<string> value);
    internal static void Reset();
    internal static void ConfigureCustomHeaders(Dictionary`2<string, string> customHeadersMap);
    private static List`1<T> GetSingleRow(IEnumerable`1<string> rows, Type recordType);
    public static List`1<T> GetRows(IEnumerable`1<string> records);
    public static object ReadObject(string csv);
    public static object ReadObjectRow(string csv);
    public static List`1<Dictionary`2<string, string>> ReadStringDictionary(IEnumerable`1<string> rows);
    public static List`1<T> Read(List`1<string> rows);
    public static T ReadRow(string value);
}
public class ServiceStack.Text.CsvSerializer : object {
    [CompilerGeneratedAttribute]
private static Encoding <UseEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<object> <OnSerialize>k__BackingField;
    private static Dictionary`2<Type, WriteObjectDelegate> WriteFnCache;
    private static Dictionary`2<Type, ParseStringDelegate> ReadFnCache;
    public static Encoding UseEncoding { get; public set; }
    public static Action`1<object> OnSerialize { get; public set; }
    private static CsvSerializer();
    [CompilerGeneratedAttribute]
public static Encoding get_UseEncoding();
    [CompilerGeneratedAttribute]
public static void set_UseEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public static Action`1<object> get_OnSerialize();
    [CompilerGeneratedAttribute]
public static void set_OnSerialize(Action`1<object> value);
    internal static WriteObjectDelegate GetWriteFn(Type type);
    internal static ParseStringDelegate GetReadFn(Type type);
    public static string SerializeToCsv(IEnumerable`1<T> records);
    public static string SerializeToString(T value);
    public static void SerializeToWriter(T value, TextWriter writer);
    public static void SerializeToStream(T value, Stream stream);
    public static void SerializeToStream(object obj, Stream stream);
    public static T DeserializeFromStream(Stream stream);
    public static object DeserializeFromStream(Type type, Stream stream);
    public static T DeserializeFromReader(TextReader reader);
    public static T DeserializeFromString(string text);
    public static object DeserializeFromString(Type type, string text);
    public static void WriteLateBoundObject(TextWriter writer, object value);
    public static object ReadLateBoundObject(Type type, string value);
    internal static T ConvertFrom(object results);
    internal static object ConvertFrom(Type type, object results);
    public static void InitAot();
}
public static class ServiceStack.Text.CsvSerializer`1 : object {
    private static WriteObjectDelegate WriteCacheFn;
    private static ParseStringDelegate ReadCacheFn;
    private static string IgnoreResponseStatus;
    private static GetMemberDelegate valueGetter;
    private static WriteObjectDelegate writeElementFn;
    private static SetMemberDelegate valueSetter;
    private static ParseStringDelegate readElementFn;
    private static CsvSerializer`1();
    public static WriteObjectDelegate WriteFn();
    private static WriteObjectDelegate GetWriteFn();
    private static WriteObjectDelegate CreateWriteFn(Type elementType);
    private static WriteObjectDelegate CreateWriteRowFn(Type elementType);
    private static WriteObjectDelegate CreateCsvWriterFn(Type elementType, string methodName);
    public static void WriteEnumerableType(TextWriter writer, object obj);
    public static void WriteSelf(TextWriter writer, object obj);
    public static void WriteEnumerableProperty(TextWriter writer, object obj);
    public static void WriteNonEnumerableType(TextWriter writer, object obj);
    public static void WriteObject(TextWriter writer, object value);
    public static ParseStringDelegate ReadFn();
    private static ParseStringDelegate GetReadFn();
    private static ParseStringDelegate CreateReadFn(Type elementType);
    private static ParseStringDelegate CreateReadRowFn(Type elementType);
    private static ParseStringDelegate CreateCsvReadFn(Type elementType, string methodName);
    public static object ReadEnumerableType(string value);
    public static object ReadSelf(string value);
    public static object ReadEnumerableProperty(string row);
    public static object ReadNonEnumerableType(string row);
    public static object ReadObject(string value);
}
[ExtensionAttribute]
public static class ServiceStack.Text.CsvStreamExtensions : object {
    [ExtensionAttribute]
public static void WriteCsv(Stream outputStream, IEnumerable`1<T> records);
    [ExtensionAttribute]
public static void WriteCsv(TextWriter writer, IEnumerable`1<T> records);
}
public static class ServiceStack.Text.CsvWriter : object {
    public static bool HasAnyEscapeChars(string value);
    internal static void WriteItemSeperatorIfRanOnce(TextWriter writer, Boolean& ranOnce);
}
public class ServiceStack.Text.CsvWriter`1 : object {
    public static char DelimiterChar;
    [CompilerGeneratedAttribute]
private static List`1<string> <Headers>k__BackingField;
    internal static List`1<GetMemberDelegate`1<T>> PropertyGetters;
    internal static List`1<PropertyInfo> PropertyInfos;
    private static WriteObjectDelegate OptimizedWriter;
    public static List`1<string> Headers { get; public set; }
    private static CsvWriter`1();
    [CompilerGeneratedAttribute]
public static List`1<string> get_Headers();
    [CompilerGeneratedAttribute]
public static void set_Headers(List`1<string> value);
    internal static void Reset();
    internal static void ConfigureCustomHeaders(Dictionary`2<string, string> customHeadersMap);
    private static List`1<string> GetSingleRow(IEnumerable`1<T> records, Type recordType);
    public static List`1<List`1<string>> GetRows(IEnumerable`1<T> records);
    public static void WriteObject(TextWriter writer, object records);
    public static void WriteObjectRow(TextWriter writer, object record);
    public static void Write(TextWriter writer, IEnumerable`1<T> records);
    public static void WriteRow(TextWriter writer, T row);
    public static void WriteRow(TextWriter writer, IEnumerable`1<string> row);
    public static void Write(TextWriter writer, IEnumerable`1<List`1<string>> rows);
}
public enum ServiceStack.Text.DateHandler : Enum {
    public int value__;
    public static DateHandler TimestampOffset;
    public static DateHandler DCJSCompatible;
    public static DateHandler ISO8601;
    public static DateHandler ISO8601DateOnly;
    public static DateHandler ISO8601DateTime;
    public static DateHandler RFC1123;
    public static DateHandler UnixTime;
    public static DateHandler UnixTimeMs;
}
[ExtensionAttribute]
public static class ServiceStack.Text.DateTimeExtensions : object {
    public static long UnixEpoch;
    private static DateTime UnixEpochDateTimeUtc;
    private static DateTime UnixEpochDateTimeUnspecified;
    private static DateTime MinDateTimeUtc;
    private static DateTimeExtensions();
    [ExtensionAttribute]
public static DateTime FromUnixTime(int unixTime);
    [ExtensionAttribute]
public static DateTime FromUnixTime(double unixTime);
    [ExtensionAttribute]
public static DateTime FromUnixTime(long unixTime);
    [ExtensionAttribute]
public static long ToUnixTimeMsAlt(DateTime dateTime);
    [ExtensionAttribute]
public static long ToUnixTimeMs(DateTime dateTime);
    [ExtensionAttribute]
public static long ToUnixTime(DateTime dateTime);
    [ExtensionAttribute]
private static TimeSpan ToDateTimeSinceUnixEpoch(DateTime dateTime);
    [ExtensionAttribute]
public static long ToUnixTimeMs(long ticks);
    [ExtensionAttribute]
public static DateTime FromUnixTimeMs(double msSince1970);
    [ExtensionAttribute]
public static DateTime FromUnixTimeMs(long msSince1970);
    [ExtensionAttribute]
public static DateTime FromUnixTimeMs(long msSince1970, TimeSpan offset);
    [ExtensionAttribute]
public static DateTime FromUnixTimeMs(double msSince1970, TimeSpan offset);
    public static DateTime FromUnixTimeMs(string msSince1970);
    public static DateTime FromUnixTimeMs(string msSince1970, TimeSpan offset);
    [ExtensionAttribute]
public static DateTime RoundToMs(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime RoundToSecond(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime Truncate(DateTime dateTime, TimeSpan timeSpan);
    [ExtensionAttribute]
public static string ToShortestXsdDateTimeString(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime FromShortestXsdDateTimeString(string xsdDateTime);
    [ExtensionAttribute]
public static bool IsEqualToTheSecond(DateTime dateTime, DateTime otherDateTime);
    [ExtensionAttribute]
public static string ToTimeOffsetString(TimeSpan offset, string seperator);
    [ExtensionAttribute]
public static TimeSpan FromTimeOffsetString(string offsetString);
    [ExtensionAttribute]
public static DateTime ToStableUniversalTime(DateTime dateTime);
    [ExtensionAttribute]
public static string FmtSortableDate(DateTime from);
    [ExtensionAttribute]
public static string FmtSortableDateTime(DateTime from);
    [ExtensionAttribute]
public static DateTime LastMonday(DateTime from);
    [ExtensionAttribute]
public static DateTime StartOfLastMonth(DateTime from);
    [ExtensionAttribute]
public static DateTime EndOfLastMonth(DateTime from);
}
public class ServiceStack.Text.DefaultMemory : MemoryProvider {
    private static DefaultMemory provider;
    private static Byte[] lo16;
    private static Byte[] hi16;
    public static DefaultMemory Provider { get; }
    private static DefaultMemory();
    public static DefaultMemory get_Provider();
    public static void Configure();
    public virtual bool ParseBoolean(ReadOnlySpan`1<char> value);
    public virtual bool TryParseBoolean(ReadOnlySpan`1<char> value, Boolean& result);
    public virtual bool TryParseDecimal(ReadOnlySpan`1<char> value, Decimal& result);
    public virtual decimal ParseDecimal(ReadOnlySpan`1<char> value);
    public virtual decimal ParseDecimal(ReadOnlySpan`1<char> value, bool allowThousands);
    public virtual bool TryParseFloat(ReadOnlySpan`1<char> value, Single& result);
    public virtual float ParseFloat(ReadOnlySpan`1<char> value);
    public virtual bool TryParseDouble(ReadOnlySpan`1<char> value, Double& result);
    public virtual double ParseDouble(ReadOnlySpan`1<char> value);
    public virtual sbyte ParseSByte(ReadOnlySpan`1<char> value);
    public virtual byte ParseByte(ReadOnlySpan`1<char> value);
    public virtual short ParseInt16(ReadOnlySpan`1<char> value);
    public virtual ushort ParseUInt16(ReadOnlySpan`1<char> value);
    public virtual int ParseInt32(ReadOnlySpan`1<char> value);
    public virtual UInt32 ParseUInt32(ReadOnlySpan`1<char> value);
    public virtual UInt32 ParseUInt32(ReadOnlySpan`1<char> value, NumberStyles style);
    public virtual long ParseInt64(ReadOnlySpan`1<char> value);
    public virtual ulong ParseUInt64(ReadOnlySpan`1<char> value);
    internal static Exception CreateOverflowException(long maxValue);
    internal static Exception CreateOverflowException(ulong maxValue);
    private static string SignedMaxValueToIntType(long maxValue);
    private static string UnsignedMaxValueToIntType(ulong maxValue);
    public static bool TryParseDecimal(ReadOnlySpan`1<char> value, bool allowThousands, Decimal& result);
    public virtual Guid ParseGuid(ReadOnlySpan`1<char> value);
    public virtual void Write(Stream stream, ReadOnlyMemory`1<char> value);
    public virtual void Write(Stream stream, ReadOnlyMemory`1<byte> value);
    public virtual Task WriteAsync(Stream stream, ReadOnlySpan`1<char> value, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Text.DefaultMemory/<WriteAsyncAndReturn>d__34")]
private static Task WriteAsyncAndReturn(Stream stream, Byte[] bytes, int offset, int count, CancellationToken token);
    public virtual Task WriteAsync(Stream stream, ReadOnlyMemory`1<char> value, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Text.DefaultMemory/<WriteAsync>d__36")]
public virtual Task WriteAsync(Stream stream, ReadOnlyMemory`1<byte> value, CancellationToken token);
    public virtual object Deserialize(Stream stream, Type type, DeserializeStringSpanDelegate deserializer);
    [AsyncStateMachineAttribute("ServiceStack.Text.DefaultMemory/<DeserializeAsync>d__38")]
public virtual Task`1<object> DeserializeAsync(Stream stream, Type type, DeserializeStringSpanDelegate deserializer);
    private static object Deserialize(MemoryStream ms, bool fromPool, Type type, DeserializeStringSpanDelegate deserializer);
    public virtual Byte[] ParseBase64(ReadOnlySpan`1<char> value);
    public virtual string ToBase64(ReadOnlyMemory`1<byte> value);
    public virtual StringBuilder Append(StringBuilder sb, ReadOnlySpan`1<char> value);
    public virtual int GetUtf8CharCount(ReadOnlySpan`1<byte> bytes);
    public virtual int GetUtf8ByteCount(ReadOnlySpan`1<char> chars);
    public virtual ReadOnlyMemory`1<byte> ToUtf8(ReadOnlySpan`1<char> source);
    public virtual ReadOnlyMemory`1<char> FromUtf8(ReadOnlySpan`1<byte> source);
    public virtual int ToUtf8(ReadOnlySpan`1<char> source, Span`1<byte> destination);
    public virtual int FromUtf8(ReadOnlySpan`1<byte> source, Span`1<char> destination);
    public virtual Byte[] ToUtf8Bytes(ReadOnlySpan`1<char> source);
    public virtual string FromUtf8Bytes(ReadOnlySpan`1<byte> source);
    public virtual MemoryStream ToMemoryStream(ReadOnlySpan`1<byte> source);
    private static Guid ParseGeneralStyleGuid(ReadOnlySpan`1<char> value, Int32& len);
    private static byte ParseHexByte(char c1, char c2);
}
public class ServiceStack.Text.DirectStreamWriter : TextWriter {
    private static int optimizedBufferLength;
    private static int maxBufferLength;
    private Stream stream;
    private StreamWriter writer;
    private Byte[] curChar;
    private bool needFlush;
    private Encoding encoding;
    public Encoding Encoding { get; }
    public DirectStreamWriter(Stream stream, Encoding encoding);
    public virtual Encoding get_Encoding();
    public virtual void Write(string s);
    public virtual void Write(char c);
    public virtual void Flush();
}
public static class ServiceStack.Text.DynamicProxy : object {
    private static ModuleBuilder ModuleBuilder;
    private static AssemblyBuilder DynamicAssembly;
    private static Type[] EmptyTypes;
    private static DynamicProxy();
    public static T GetInstanceFor();
    public static object GetInstanceFor(Type targetType);
    private static string ProxyName(Type targetType);
    private static Type GetConstructedType(Type targetType);
    private static void IncludeType(Type typeOfT, TypeBuilder typeBuilder);
    private static void BindMethod(TypeBuilder typeBuilder, MethodInfo methodInfo);
    public static void BindProperty(TypeBuilder typeBuilder, MethodInfo methodInfo);
}
public class ServiceStack.Text.EmitReflectionOptimizer : ReflectionOptimizer {
    private static EmitReflectionOptimizer provider;
    private static Type[] DynamicGetMethodArgs;
    private static Type[] DynamicSetMethodArgs;
    public static EmitReflectionOptimizer Provider { get; }
    private static EmitReflectionOptimizer();
    public static EmitReflectionOptimizer get_Provider();
    public virtual Type UseType(Type type);
    internal static DynamicMethod CreateDynamicGetMethod(MemberInfo memberInfo);
    public virtual GetMemberDelegate CreateGetter(PropertyInfo propertyInfo);
    public virtual GetMemberDelegate`1<T> CreateGetter(PropertyInfo propertyInfo);
    public virtual SetMemberDelegate CreateSetter(PropertyInfo propertyInfo);
    public virtual SetMemberDelegate`1<T> CreateSetter(PropertyInfo propertyInfo);
    public virtual GetMemberDelegate CreateGetter(FieldInfo fieldInfo);
    public virtual GetMemberDelegate`1<T> CreateGetter(FieldInfo fieldInfo);
    public virtual SetMemberDelegate CreateSetter(FieldInfo fieldInfo);
    internal static DynamicMethod CreateDynamicGetMethod(MemberInfo memberInfo);
    public virtual SetMemberDelegate`1<T> CreateSetter(FieldInfo fieldInfo);
    public virtual SetMemberRefDelegate`1<T> CreateSetterRef(FieldInfo fieldInfo);
    public virtual bool IsDynamic(Assembly assembly);
    public virtual EmptyCtorDelegate CreateConstructor(Type type);
    internal static DynamicMethod CreateDynamicSetMethod(MemberInfo memberInfo);
}
public class ServiceStack.Text.EnumInfo : object {
    private Type enumType;
    private bool isEnumFlag;
    private Dictionary`2<object, string> enumMemberValues;
    private Dictionary`2<string, object> enumMemberReverseLookup;
    private EnumInfo(Type enumType);
    public static EnumInfo GetEnumInfo(Type type);
    public object GetSerializedValue(object enumValue);
    public object Parse(string serializedValue);
}
[ExtensionAttribute]
public static class ServiceStack.Text.Env : object {
    [CompilerGeneratedAttribute]
private static string <VersionString>k__BackingField;
    public static decimal ServiceStackVersion;
    [CompilerGeneratedAttribute]
private static bool <IsLinux>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOSX>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsUnix>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsWindows>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsMono>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsIOS>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsAndroid>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNetNative>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsUWP>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNetStandard>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNetCore21>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNet6>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNetStandard20>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNetCore>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsNetCore3>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsEmit>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsDynamic>k__BackingField;
    private static bool strictMode;
    [CompilerGeneratedAttribute]
private static string <ServerUserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <HasMultiplePlatformTargets>k__BackingField;
    private static DateTime __releaseDate;
    private static string referenceAssemblyPath;
    public static bool ContinueOnCapturedContext;
    public static string VersionString { get; public set; }
    public static bool IsLinux { get; public set; }
    public static bool IsOSX { get; public set; }
    public static bool IsUnix { get; public set; }
    public static bool IsWindows { get; public set; }
    public static bool IsMono { get; public set; }
    public static bool IsIOS { get; public set; }
    public static bool IsAndroid { get; public set; }
    public static bool IsNetNative { get; public set; }
    public static bool IsUWP { get; private set; }
    public static bool IsNetStandard { get; public set; }
    public static bool IsNetCore21 { get; public set; }
    public static bool IsNet6 { get; public set; }
    public static bool IsNetStandard20 { get; public set; }
    public static bool IsNetFramework { get; public set; }
    public static bool IsNetCore { get; public set; }
    public static bool IsNetCore3 { get; public set; }
    public static bool SupportsExpressions { get; private set; }
    public static bool SupportsEmit { get; private set; }
    public static bool SupportsDynamic { get; private set; }
    public static bool StrictMode { get; public set; }
    public static string ServerUserAgent { get; public set; }
    public static bool HasMultiplePlatformTargets { get; public set; }
    [ObsoleteAttribute("Use ReferenceAssemblyPath")]
public static string ReferenceAssembyPath { get; }
    public static string ReferenceAssemblyPath { get; public set; }
    private static Env();
    [CompilerGeneratedAttribute]
public static string get_VersionString();
    [CompilerGeneratedAttribute]
public static void set_VersionString(string value);
    [CompilerGeneratedAttribute]
public static bool get_IsLinux();
    [CompilerGeneratedAttribute]
public static void set_IsLinux(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsOSX();
    [CompilerGeneratedAttribute]
public static void set_IsOSX(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsUnix();
    [CompilerGeneratedAttribute]
public static void set_IsUnix(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsWindows();
    [CompilerGeneratedAttribute]
public static void set_IsWindows(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsMono();
    [CompilerGeneratedAttribute]
public static void set_IsMono(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsIOS();
    [CompilerGeneratedAttribute]
public static void set_IsIOS(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsAndroid();
    [CompilerGeneratedAttribute]
public static void set_IsAndroid(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsNetNative();
    [CompilerGeneratedAttribute]
public static void set_IsNetNative(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsUWP();
    [CompilerGeneratedAttribute]
private static void set_IsUWP(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsNetStandard();
    [CompilerGeneratedAttribute]
public static void set_IsNetStandard(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsNetCore21();
    [CompilerGeneratedAttribute]
public static void set_IsNetCore21(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsNet6();
    [CompilerGeneratedAttribute]
public static void set_IsNet6(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsNetStandard20();
    [CompilerGeneratedAttribute]
public static void set_IsNetStandard20(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsNetFramework();
    [CompilerGeneratedAttribute]
public static void set_IsNetFramework(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsNetCore();
    [CompilerGeneratedAttribute]
public static void set_IsNetCore(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsNetCore3();
    [CompilerGeneratedAttribute]
public static void set_IsNetCore3(bool value);
    [CompilerGeneratedAttribute]
public static bool get_SupportsExpressions();
    [CompilerGeneratedAttribute]
private static void set_SupportsExpressions(bool value);
    [CompilerGeneratedAttribute]
public static bool get_SupportsEmit();
    [CompilerGeneratedAttribute]
private static void set_SupportsEmit(bool value);
    [CompilerGeneratedAttribute]
public static bool get_SupportsDynamic();
    [CompilerGeneratedAttribute]
private static void set_SupportsDynamic(bool value);
    public static bool get_StrictMode();
    public static void set_StrictMode(bool value);
    [CompilerGeneratedAttribute]
public static string get_ServerUserAgent();
    [CompilerGeneratedAttribute]
public static void set_ServerUserAgent(string value);
    [CompilerGeneratedAttribute]
public static bool get_HasMultiplePlatformTargets();
    [CompilerGeneratedAttribute]
public static void set_HasMultiplePlatformTargets(bool value);
    public static DateTime GetReleaseDate();
    public static string get_ReferenceAssembyPath();
    public static string get_ReferenceAssemblyPath();
    public static void set_ReferenceAssemblyPath(string value);
    [ExtensionAttribute]
public static ConfiguredTaskAwaitable ConfigAwait(Task task);
    [ExtensionAttribute]
public static ConfiguredTaskAwaitable`1<T> ConfigAwait(Task`1<T> task);
}
[AttributeUsageAttribute("64")]
public class ServiceStack.Text.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    public EventLevel Level { get; public set; }
    public EventAttribute(int id);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
}
public enum ServiceStack.Text.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
}
public enum ServiceStack.Text.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
public class ServiceStack.Text.EventSource : object {
    public void WriteEvent(Object[] unused);
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
}
[AttributeUsageAttribute("4")]
public class ServiceStack.Text.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    public string Name { get; public set; }
    public string Guid { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
}
public class ServiceStack.Text.ExpressionReflectionOptimizer : ReflectionOptimizer {
    private static ExpressionReflectionOptimizer provider;
    private static MethodInfo setFieldMethod;
    public static ExpressionReflectionOptimizer Provider { get; }
    private static ExpressionReflectionOptimizer();
    public static ExpressionReflectionOptimizer get_Provider();
    public virtual Type UseType(Type type);
    public virtual GetMemberDelegate CreateGetter(PropertyInfo propertyInfo);
    public static Expression`1<GetMemberDelegate> GetExpressionLambda(PropertyInfo propertyInfo);
    public virtual GetMemberDelegate`1<T> CreateGetter(PropertyInfo propertyInfo);
    public static Expression`1<GetMemberDelegate`1<T>> GetExpressionLambda(PropertyInfo propertyInfo);
    public virtual SetMemberDelegate CreateSetter(PropertyInfo propertyInfo);
    public virtual SetMemberDelegate`1<T> CreateSetter(PropertyInfo propertyInfo);
    public static Expression`1<SetMemberDelegate`1<T>> SetExpressionLambda(PropertyInfo propertyInfo);
    public virtual GetMemberDelegate CreateGetter(FieldInfo fieldInfo);
    private static Expression GetCastOrConvertExpression(Expression expression, Type targetType);
    public virtual GetMemberDelegate`1<T> CreateGetter(FieldInfo fieldInfo);
    internal static void SetField(TValue& field, TValue newValue);
    public virtual SetMemberDelegate CreateSetter(FieldInfo fieldInfo);
    public virtual SetMemberDelegate`1<T> CreateSetter(FieldInfo fieldInfo);
    public virtual SetMemberRefDelegate`1<T> CreateSetterRef(FieldInfo fieldInfo);
    public virtual bool IsDynamic(Assembly assembly);
    public virtual EmptyCtorDelegate CreateConstructor(Type type);
}
[DefaultMemberAttribute("Item")]
public abstract class ServiceStack.Text.FastMember.ObjectAccessor : object {
    public object Item { get; public set; }
    public object Target { get; }
    public abstract virtual object get_Item(string name);
    public abstract virtual void set_Item(string name, object value);
    public abstract virtual object get_Target();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static ObjectAccessor Create(object target);
}
[DefaultMemberAttribute("Item")]
public abstract class ServiceStack.Text.FastMember.TypeAccessor : object {
    private static Hashtable typeLookyp;
    private static AssemblyBuilder assembly;
    private static ModuleBuilder module;
    private static int counter;
    private static MethodInfo strinqEquals;
    public bool CreateNewSupported { get; }
    public object Item { get; public set; }
    private static TypeAccessor();
    public virtual bool get_CreateNewSupported();
    public virtual object CreateNew();
    public static TypeAccessor Create(Type type);
    private static void WriteGetter(ILGenerator il, Type type, PropertyInfo[] props, FieldInfo[] fields, bool isStatic);
    private static void WriteSetter(ILGenerator il, Type type, PropertyInfo[] props, FieldInfo[] fields, bool isStatic);
    private static bool IsFullyPublic(Type type);
    private static TypeAccessor CreateNew(Type type);
    private static void Cast(ILGenerator il, Type type, LocalBuilder addr);
    public abstract virtual object get_Item(object target, string name);
    public abstract virtual void set_Item(object target, string name, object value);
}
public interface ServiceStack.Text.IRuntimeSerializable {
}
public interface ServiceStack.Text.IStringSerializer {
    public abstract virtual To DeserializeFromString(string serializedText);
    public abstract virtual object DeserializeFromString(string serializedText, Type type);
    public abstract virtual string SerializeToString(TFrom from);
}
public interface ServiceStack.Text.ITracer {
    public abstract virtual void WriteDebug(string error);
    public abstract virtual void WriteDebug(string format, Object[] args);
    public abstract virtual void WriteWarning(string warning);
    public abstract virtual void WriteWarning(string format, Object[] args);
    public abstract virtual void WriteError(Exception ex);
    public abstract virtual void WriteError(string error);
    public abstract virtual void WriteError(string format, Object[] args);
}
public interface ServiceStack.Text.ITypeSerializer`1 {
    public abstract virtual bool CanCreateFromString(Type type);
    public abstract virtual T DeserializeFromString(string value);
    public abstract virtual T DeserializeFromReader(TextReader reader);
    public abstract virtual string SerializeToString(T value);
    public abstract virtual void SerializeToWriter(T value, TextWriter writer);
}
public interface ServiceStack.Text.IValueWriter {
    public abstract virtual void WriteTo(ITypeSerializer serializer, TextWriter writer);
}
[ExtensionAttribute]
public static class ServiceStack.Text.JsConfig : object {
    [CompilerGeneratedAttribute]
private static UTF8Encoding <UTF8Encoding>k__BackingField;
    internal static HashSet`1<Type> HasSerializeFn;
    internal static HashSet`1<Type> HasIncludeDefaultValue;
    public static HashSet`1<Type> TreatValueAsRefTypes;
    [CompilerGeneratedAttribute]
private static HashSet`1<string> <AllowRuntimeTypeWithAttributesNamed>k__BackingField;
    [CompilerGeneratedAttribute]
private static HashSet`1<string> <AllowRuntimeTypeWithInterfacesNamed>k__BackingField;
    [CompilerGeneratedAttribute]
private static HashSet`1<string> <AllowRuntimeTypeInTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static HashSet`1<string> <AllowRuntimeTypeInTypesWithNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> <AllowRuntimeType>k__BackingField;
    internal static HashSet`1<Type> __uniqueTypes;
    internal static int __uniqueTypesCount;
    public static bool HasInit { get; }
    public static UTF8Encoding UTF8Encoding { get; public set; }
    public static string DateTimeFormat { get; public set; }
    public static bool ConvertObjectTypesIntoStringDictionary { get; public set; }
    public static bool TryToParsePrimitiveTypeValues { get; public set; }
    public static bool TryToParseNumericType { get; public set; }
    public static bool TryParseIntoBestFit { get; public set; }
    public static ParseAsType ParsePrimitiveFloatingPointTypes { get; public set; }
    public static ParseAsType ParsePrimitiveIntegerTypes { get; public set; }
    public static String[] ExcludePropertyReferences { get; public set; }
    public static bool ExcludeDefaultValues { get; public set; }
    public static bool IncludeNullValues { get; public set; }
    public static bool IncludeNullValuesInDictionaries { get; public set; }
    public static bool IncludeDefaultEnums { get; public set; }
    public static bool TreatEnumAsInteger { get; public set; }
    public static bool ExcludeTypeInfo { get; public set; }
    public static bool IncludeTypeInfo { get; public set; }
    public static bool Indent { get; public set; }
    public static string TypeAttr { get; public set; }
    internal static string JsonTypeAttrInObject { get; }
    internal static string JsvTypeAttrInObject { get; }
    public static Func`2<Type, string> TypeWriter { get; public set; }
    public static Func`2<string, Type> TypeFinder { get; public set; }
    public static Func`2<string, object> ParsePrimitiveFn { get; public set; }
    public static DateHandler DateHandler { get; public set; }
    public static TimeSpanHandler TimeSpanHandler { get; public set; }
    public static TextCase TextCase { get; public set; }
    [ObsoleteAttribute("Use TextCase = TextCase.CamelCase")]
public static bool EmitCamelCaseNames { get; public set; }
    [ObsoleteAttribute("Use TextCase = TextCase.SnakeCase")]
public static bool EmitLowercaseUnderscoreNames { get; public set; }
    public static PropertyConvention PropertyConvention { get; public set; }
    public static bool ThrowOnError { get; public set; }
    [ObsoleteAttribute("Renamed to ThrowOnError")]
public static bool ThrowOnDeserializationError { get; public set; }
    public static bool AlwaysUseUtc { get; public set; }
    public static bool SkipDateTimeConversion { get; public set; }
    public static bool AssumeUtc { get; public set; }
    public static bool AppendUtcOffset { get; public set; }
    public static bool EscapeUnicode { get; public set; }
    public static bool EscapeHtmlChars { get; public set; }
    public static DeserializationErrorDelegate OnDeserializationError { get; public set; }
    public static bool PreferInterfaces { get; public set; }
    public static bool IncludePublicFields { get; public set; }
    public static int MaxDepth { get; public set; }
    public static EmptyCtorFactoryDelegate ModelFactory { get; public set; }
    public static HashSet`1<Type> ExcludeTypes { get; public set; }
    public static HashSet`1<string> ExcludeTypeNames { get; public set; }
    public static String[] IgnoreAttributesNamed { get; public set; }
    public static HashSet`1<string> AllowRuntimeTypeWithAttributesNamed { get; public set; }
    public static HashSet`1<string> AllowRuntimeTypeWithInterfacesNamed { get; public set; }
    public static HashSet`1<string> AllowRuntimeTypeInTypes { get; public set; }
    public static HashSet`1<string> AllowRuntimeTypeInTypesWithNamespaces { get; public set; }
    public static Func`2<Type, bool> AllowRuntimeType { get; public set; }
    private static JsConfig();
    public static void InitStatics();
    public static void Init();
    public static void Init(Config config);
    public static bool get_HasInit();
    public static JsConfigScope BeginScope();
    public static JsConfigScope CreateScope(string config, JsConfigScope scope);
    [CompilerGeneratedAttribute]
public static UTF8Encoding get_UTF8Encoding();
    [CompilerGeneratedAttribute]
public static void set_UTF8Encoding(UTF8Encoding value);
    public static JsConfigScope With(Config config);
    [ObsoleteAttribute("Use JsConfig.With(new Config { })")]
public static JsConfigScope With(Nullable`1<bool> convertObjectTypesIntoStringDictionary, Nullable`1<bool> tryToParsePrimitiveTypeValues, Nullable`1<bool> tryToParseNumericType, Nullable`1<ParseAsType> parsePrimitiveFloatingPointTypes, Nullable`1<ParseAsType> parsePrimitiveIntegerTypes, Nullable`1<bool> excludeDefaultValues, Nullable`1<bool> includeNullValues, Nullable`1<bool> includeNullValuesInDictionaries, Nullable`1<bool> includeDefaultEnums, Nullable`1<bool> excludeTypeInfo, Nullable`1<bool> includeTypeInfo, Nullable`1<bool> emitCamelCaseNames, Nullable`1<bool> emitLowercaseUnderscoreNames, Nullable`1<DateHandler> dateHandler, Nullable`1<TimeSpanHandler> timeSpanHandler, Nullable`1<PropertyConvention> propertyConvention, Nullable`1<bool> preferInterfaces, Nullable`1<bool> throwOnDeserializationError, string typeAttr, string dateTimeFormat, Func`2<Type, string> typeWriter, Func`2<string, Type> typeFinder, Nullable`1<bool> treatEnumAsInteger, Nullable`1<bool> skipDateTimeConversion, Nullable`1<bool> alwaysUseUtc, Nullable`1<bool> assumeUtc, Nullable`1<bool> appendUtcOffset, Nullable`1<bool> escapeUnicode, Nullable`1<bool> includePublicFields, Nullable`1<int> maxDepth, EmptyCtorFactoryDelegate modelFactory, String[] excludePropertyReferences, Nullable`1<bool> useSystemParseMethods);
    public static string get_DateTimeFormat();
    public static void set_DateTimeFormat(string value);
    public static bool get_ConvertObjectTypesIntoStringDictionary();
    public static void set_ConvertObjectTypesIntoStringDictionary(bool value);
    public static bool get_TryToParsePrimitiveTypeValues();
    public static void set_TryToParsePrimitiveTypeValues(bool value);
    public static bool get_TryToParseNumericType();
    public static void set_TryToParseNumericType(bool value);
    public static bool get_TryParseIntoBestFit();
    public static void set_TryParseIntoBestFit(bool value);
    public static ParseAsType get_ParsePrimitiveFloatingPointTypes();
    public static void set_ParsePrimitiveFloatingPointTypes(ParseAsType value);
    public static ParseAsType get_ParsePrimitiveIntegerTypes();
    public static void set_ParsePrimitiveIntegerTypes(ParseAsType value);
    public static String[] get_ExcludePropertyReferences();
    public static void set_ExcludePropertyReferences(String[] value);
    public static bool get_ExcludeDefaultValues();
    public static void set_ExcludeDefaultValues(bool value);
    public static bool get_IncludeNullValues();
    public static void set_IncludeNullValues(bool value);
    public static bool get_IncludeNullValuesInDictionaries();
    public static void set_IncludeNullValuesInDictionaries(bool value);
    public static bool get_IncludeDefaultEnums();
    public static void set_IncludeDefaultEnums(bool value);
    public static bool get_TreatEnumAsInteger();
    public static void set_TreatEnumAsInteger(bool value);
    public static bool get_ExcludeTypeInfo();
    public static void set_ExcludeTypeInfo(bool value);
    public static bool get_IncludeTypeInfo();
    public static void set_IncludeTypeInfo(bool value);
    public static bool get_Indent();
    public static void set_Indent(bool value);
    public static string get_TypeAttr();
    public static void set_TypeAttr(string value);
    internal static string get_JsonTypeAttrInObject();
    internal static string get_JsvTypeAttrInObject();
    public static Func`2<Type, string> get_TypeWriter();
    public static void set_TypeWriter(Func`2<Type, string> value);
    public static Func`2<string, Type> get_TypeFinder();
    public static void set_TypeFinder(Func`2<string, Type> value);
    public static Func`2<string, object> get_ParsePrimitiveFn();
    public static void set_ParsePrimitiveFn(Func`2<string, object> value);
    public static DateHandler get_DateHandler();
    public static void set_DateHandler(DateHandler value);
    public static TimeSpanHandler get_TimeSpanHandler();
    public static void set_TimeSpanHandler(TimeSpanHandler value);
    public static TextCase get_TextCase();
    public static void set_TextCase(TextCase value);
    public static bool get_EmitCamelCaseNames();
    public static void set_EmitCamelCaseNames(bool value);
    public static bool get_EmitLowercaseUnderscoreNames();
    public static void set_EmitLowercaseUnderscoreNames(bool value);
    public static Config GetConfig();
    public static PropertyConvention get_PropertyConvention();
    public static void set_PropertyConvention(PropertyConvention value);
    public static bool get_ThrowOnError();
    public static void set_ThrowOnError(bool value);
    public static bool get_ThrowOnDeserializationError();
    public static void set_ThrowOnDeserializationError(bool value);
    public static bool get_AlwaysUseUtc();
    public static void set_AlwaysUseUtc(bool value);
    public static bool get_SkipDateTimeConversion();
    public static void set_SkipDateTimeConversion(bool value);
    public static bool get_AssumeUtc();
    public static void set_AssumeUtc(bool value);
    public static bool get_AppendUtcOffset();
    public static void set_AppendUtcOffset(bool value);
    public static bool get_EscapeUnicode();
    public static void set_EscapeUnicode(bool value);
    public static bool get_EscapeHtmlChars();
    public static void set_EscapeHtmlChars(bool value);
    public static DeserializationErrorDelegate get_OnDeserializationError();
    public static void set_OnDeserializationError(DeserializationErrorDelegate value);
    public static bool get_PreferInterfaces();
    public static void set_PreferInterfaces(bool value);
    internal static bool TreatAsRefType(Type valueType);
    public static bool get_IncludePublicFields();
    public static void set_IncludePublicFields(bool value);
    public static int get_MaxDepth();
    public static void set_MaxDepth(int value);
    public static EmptyCtorFactoryDelegate get_ModelFactory();
    public static void set_ModelFactory(EmptyCtorFactoryDelegate value);
    public static HashSet`1<Type> get_ExcludeTypes();
    public static void set_ExcludeTypes(HashSet`1<Type> value);
    public static HashSet`1<string> get_ExcludeTypeNames();
    public static void set_ExcludeTypeNames(HashSet`1<string> value);
    public static void set_IgnoreAttributesNamed(String[] value);
    public static String[] get_IgnoreAttributesNamed();
    [CompilerGeneratedAttribute]
public static HashSet`1<string> get_AllowRuntimeTypeWithAttributesNamed();
    [CompilerGeneratedAttribute]
public static void set_AllowRuntimeTypeWithAttributesNamed(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public static HashSet`1<string> get_AllowRuntimeTypeWithInterfacesNamed();
    [CompilerGeneratedAttribute]
public static void set_AllowRuntimeTypeWithInterfacesNamed(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public static HashSet`1<string> get_AllowRuntimeTypeInTypes();
    [CompilerGeneratedAttribute]
public static void set_AllowRuntimeTypeInTypes(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public static HashSet`1<string> get_AllowRuntimeTypeInTypesWithNamespaces();
    [CompilerGeneratedAttribute]
public static void set_AllowRuntimeTypeInTypesWithNamespaces(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public static Func`2<Type, bool> get_AllowRuntimeType();
    [CompilerGeneratedAttribute]
public static void set_AllowRuntimeType(Func`2<Type, bool> value);
    public static void Reset();
    private static void Reset(Type cachesForType);
    [ExtensionAttribute]
internal static void InvokeReset(Type genericType);
    internal static void AddUniqueType(Type type);
}
public class ServiceStack.Text.JsConfig`1 : object {
    public static Nullable`1<bool> IncludeTypeInfo;
    public static Nullable`1<bool> ExcludeTypeInfo;
    [CompilerGeneratedAttribute]
private static TextCase <TextCase>k__BackingField;
    private static Func`2<T, string> serializeFn;
    private static Func`2<T, string> rawSerializeFn;
    private static Func`2<T, T> onSerializingFn;
    private static Action`1<T> onSerializedFn;
    private static Func`2<string, T> deSerializeFn;
    private static Func`2<string, T> rawDeserializeFn;
    private static Func`2<T, T> onDeserializedFn;
    private static Func`4<T, string, object, object> onDeserializingFn;
    public static String[] ExcludePropertyNames;
    public static TextCase TextCase { get; public set; }
    [ObsoleteAttribute("Use TextCase = TextCase.CamelCase")]
public static Nullable`1<bool> EmitCamelCaseNames { get; public set; }
    [ObsoleteAttribute("Use TextCase = TextCase.SnakeCase")]
public static Nullable`1<bool> EmitLowercaseUnderscoreNames { get; public set; }
    public static bool IncludeDefaultValue { get; public set; }
    public static Func`2<T, string> SerializeFn { get; public set; }
    public static bool TreatValueAsRefType { get; public set; }
    public static bool HasSerializeFn { get; }
    public static Func`2<T, string> RawSerializeFn { get; public set; }
    public static Func`2<T, T> OnSerializingFn { get; public set; }
    public static Action`1<T> OnSerializedFn { get; public set; }
    public static Func`2<string, T> DeSerializeFn { get; public set; }
    public static Func`2<string, T> RawDeserializeFn { get; public set; }
    public static bool HasDeserializeFn { get; }
    public static Func`2<T, T> OnDeserializedFn { get; public set; }
    public static bool HasDeserializingFn { get; }
    public static Func`4<T, string, object, object> OnDeserializingFn { get; public set; }
    private static JsConfig`1();
    internal static Config GetConfig();
    [CompilerGeneratedAttribute]
public static TextCase get_TextCase();
    [CompilerGeneratedAttribute]
public static void set_TextCase(TextCase value);
    public static Nullable`1<bool> get_EmitCamelCaseNames();
    public static void set_EmitCamelCaseNames(Nullable`1<bool> value);
    public static Nullable`1<bool> get_EmitLowercaseUnderscoreNames();
    public static void set_EmitLowercaseUnderscoreNames(Nullable`1<bool> value);
    public static bool get_IncludeDefaultValue();
    public static void set_IncludeDefaultValue(bool value);
    public static Func`2<T, string> get_SerializeFn();
    public static void set_SerializeFn(Func`2<T, string> value);
    public static bool get_TreatValueAsRefType();
    public static void set_TreatValueAsRefType(bool value);
    public static bool get_HasSerializeFn();
    public static Func`2<T, string> get_RawSerializeFn();
    public static void set_RawSerializeFn(Func`2<T, string> value);
    public static Func`2<T, T> get_OnSerializingFn();
    public static void set_OnSerializingFn(Func`2<T, T> value);
    public static Action`1<T> get_OnSerializedFn();
    public static void set_OnSerializedFn(Action`1<T> value);
    public static Func`2<string, T> get_DeSerializeFn();
    public static void set_DeSerializeFn(Func`2<string, T> value);
    public static Func`2<string, T> get_RawDeserializeFn();
    public static void set_RawDeserializeFn(Func`2<string, T> value);
    public static bool get_HasDeserializeFn();
    public static Func`2<T, T> get_OnDeserializedFn();
    public static void set_OnDeserializedFn(Func`2<T, T> value);
    public static bool get_HasDeserializingFn();
    public static Func`4<T, string, object, object> get_OnDeserializingFn();
    public static void set_OnDeserializingFn(Func`4<T, string, object, object> value);
    public static void WriteFn(TextWriter writer, object obj);
    public static object ParseFn(string str);
    internal static object ParseFn(ITypeSerializer serializer, string str);
    internal static void ClearFnCaches();
    public static void Reset();
    public static void RefreshRead();
    public static void RefreshWrite();
}
public class ServiceStack.Text.JsConfigScope : Config {
    private bool disposed;
    private JsConfigScope parent;
    [ThreadStaticAttribute]
private static JsConfigScope head;
    internal static JsConfigScope Current { get; }
    internal static JsConfigScope get_Current();
    public sealed virtual void Dispose();
}
public static class ServiceStack.Text.Json.JsonReader : object {
    public static JsReader`1<JsonTypeSerializer> Instance;
    private static Dictionary`2<Type, ParseFactoryDelegate> ParseFnCache;
    private static JsonReader();
    internal static ParseStringDelegate GetParseFn(Type type);
    internal static ParseStringSpanDelegate GetParseSpanFn(Type type);
    internal static ParseStringSpanDelegate GetParseStringSpanFn(Type type);
    public static void InitAot();
}
internal static class ServiceStack.Text.Json.JsonReader`1 : object {
    private static ParseStringSpanDelegate ReadFn;
    private static JsonReader`1();
    public static void Refresh();
    public static ParseStringDelegate GetParseFn();
    public static ParseStringSpanDelegate GetParseStringSpanFn();
    public static object Parse(string value);
    public static object Parse(ReadOnlySpan`1<char> value);
}
public class ServiceStack.Text.Json.JsonTypeSerializer : ValueType {
    public static ITypeSerializer Instance;
    [CompilerGeneratedAttribute]
private ObjectDeserializerDelegate <ObjectDeserializer>k__BackingField;
    private static Char[] IsSafeJsonChars;
    public ObjectDeserializerDelegate ObjectDeserializer { get; public set; }
    public bool IncludeNullValues { get; }
    public bool IncludeNullValuesInDictionaries { get; }
    public string TypeAttrInObject { get; }
    private static JsonTypeSerializer();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ObjectDeserializerDelegate get_ObjectDeserializer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ObjectDeserializer(ObjectDeserializerDelegate value);
    public sealed virtual bool get_IncludeNullValues();
    public sealed virtual bool get_IncludeNullValuesInDictionaries();
    public sealed virtual string get_TypeAttrInObject();
    internal static string GetTypeAttrInObject(string typeAttr);
    public sealed virtual WriteObjectDelegate GetWriteFn();
    public sealed virtual WriteObjectDelegate GetWriteFn(Type type);
    public sealed virtual TypeInfo GetTypeInfo(Type type);
    public sealed virtual void WriteRawString(TextWriter writer, string value);
    public sealed virtual void WritePropertyName(TextWriter writer, string value);
    public sealed virtual void WriteString(TextWriter writer, string value);
    public sealed virtual void WriteBuiltIn(TextWriter writer, object value);
    public sealed virtual void WriteObjectString(TextWriter writer, object value);
    public sealed virtual void WriteFormattableObjectString(TextWriter writer, object value);
    public sealed virtual void WriteException(TextWriter writer, object value);
    public sealed virtual void WriteDateTime(TextWriter writer, object oDateTime);
    public sealed virtual void WriteNullableDateTime(TextWriter writer, object dateTime);
    public sealed virtual void WriteDateTimeOffset(TextWriter writer, object oDateTimeOffset);
    public sealed virtual void WriteNullableDateTimeOffset(TextWriter writer, object dateTimeOffset);
    public sealed virtual void WriteTimeSpan(TextWriter writer, object oTimeSpan);
    public sealed virtual void WriteNullableTimeSpan(TextWriter writer, object oTimeSpan);
    public sealed virtual void WriteGuid(TextWriter writer, object oValue);
    public sealed virtual void WriteNullableGuid(TextWriter writer, object oValue);
    public sealed virtual void WriteBytes(TextWriter writer, object oByteValue);
    public sealed virtual void WriteChar(TextWriter writer, object charValue);
    public sealed virtual void WriteByte(TextWriter writer, object byteValue);
    public sealed virtual void WriteSByte(TextWriter writer, object sbyteValue);
    public sealed virtual void WriteInt16(TextWriter writer, object intValue);
    public sealed virtual void WriteUInt16(TextWriter writer, object intValue);
    public sealed virtual void WriteInt32(TextWriter writer, object intValue);
    public sealed virtual void WriteUInt32(TextWriter writer, object uintValue);
    public sealed virtual void WriteInt64(TextWriter writer, object integerValue);
    public sealed virtual void WriteUInt64(TextWriter writer, object ulongValue);
    public sealed virtual void WriteBool(TextWriter writer, object boolValue);
    public sealed virtual void WriteFloat(TextWriter writer, object floatValue);
    public sealed virtual void WriteDouble(TextWriter writer, object doubleValue);
    public sealed virtual void WriteDecimal(TextWriter writer, object decimalValue);
    public sealed virtual void WriteEnum(TextWriter writer, object enumValue);
    public sealed virtual ParseStringDelegate GetParseFn();
    public sealed virtual ParseStringSpanDelegate GetParseStringSpanFn();
    public sealed virtual ParseStringDelegate GetParseFn(Type type);
    public sealed virtual ParseStringSpanDelegate GetParseStringSpanFn(Type type);
    public sealed virtual string ParseRawString(string value);
    public sealed virtual string ParseString(ReadOnlySpan`1<char> value);
    public sealed virtual string ParseString(string value);
    public static bool IsEmptyMap(ReadOnlySpan`1<char> value, int i);
    internal static ReadOnlySpan`1<char> ParseString(ReadOnlySpan`1<char> json, Int32& index);
    public sealed virtual string UnescapeString(string value);
    public sealed virtual ReadOnlySpan`1<char> UnescapeString(ReadOnlySpan`1<char> value);
    public sealed virtual object UnescapeStringAsObject(ReadOnlySpan`1<char> value);
    public sealed virtual string UnescapeSafeString(string value);
    public sealed virtual ReadOnlySpan`1<char> UnescapeSafeString(ReadOnlySpan`1<char> value);
    internal static ReadOnlySpan`1<char> ParseJsonString(ReadOnlySpan`1<char> json, Int32& index);
    private static string UnescapeJsonString(string json, Int32& index);
    private static ReadOnlySpan`1<char> UnescapeJsonString(ReadOnlySpan`1<char> json, Int32& index);
    public static ReadOnlySpan`1<char> UnescapeJsString(ReadOnlySpan`1<char> json, char quoteChar);
    public static ReadOnlySpan`1<char> UnescapeJsString(ReadOnlySpan`1<char> json, char quoteChar, bool removeQuotes, Int32& index);
    public static string Unescape(string input);
    public static string Unescape(string input, bool removeQuotes);
    public static ReadOnlySpan`1<char> Unescape(ReadOnlySpan`1<char> input);
    public static ReadOnlySpan`1<char> Unescape(ReadOnlySpan`1<char> input, bool removeQuotes);
    public static ReadOnlySpan`1<char> Unescape(ReadOnlySpan`1<char> input, bool removeQuotes, char quoteChar);
    public static string ConvertFromUtf32(int utf32);
    public sealed virtual string EatTypeValue(string value, Int32& i);
    public sealed virtual ReadOnlySpan`1<char> EatTypeValue(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual bool EatMapStartChar(string value, Int32& i);
    public sealed virtual bool EatMapStartChar(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual string EatMapKey(string value, Int32& i);
    public sealed virtual ReadOnlySpan`1<char> EatMapKey(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual bool EatMapKeySeperator(string value, Int32& i);
    public sealed virtual bool EatMapKeySeperator(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual bool EatItemSeperatorOrMapEndChar(string value, Int32& i);
    public sealed virtual bool EatItemSeperatorOrMapEndChar(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual void EatWhitespace(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual void EatWhitespace(string value, Int32& i);
    public sealed virtual string EatValue(string value, Int32& i);
    public sealed virtual ReadOnlySpan`1<char> EatValue(ReadOnlySpan`1<char> value, Int32& i);
}
[ExtensionAttribute]
public static class ServiceStack.Text.Json.JsonUtils : object {
    public static long MaxInteger;
    public static long MinInteger;
    public static char EscapeChar;
    public static char QuoteChar;
    public static string Null;
    public static string True;
    public static string False;
    public static char SpaceChar;
    public static char TabChar;
    public static char CarriageReturnChar;
    public static char LineFeedChar;
    public static char FormFeedChar;
    public static char BackspaceChar;
    private static Char[] EscapedBackslash;
    private static Char[] EscapedTab;
    private static Char[] EscapedCarriageReturn;
    private static Char[] EscapedLineFeed;
    private static Char[] EscapedFormFeed;
    private static Char[] EscapedBackspace;
    private static Char[] EscapedQuote;
    public static Char[] WhiteSpaceChars;
    private static JsonUtils();
    public static bool IsWhiteSpace(char c);
    public static void WriteString(TextWriter writer, string value);
    [ExtensionAttribute]
private static bool IsPrintable(char c);
    private static bool HasAnyEscapeChars(string value, bool escapeHtmlChars);
    public static void IntToHex(int intValue, Char[] hex);
    public static bool IsJsObject(string value);
    public static bool IsJsObject(ReadOnlySpan`1<char> value);
    public static bool IsJsArray(string value);
    public static bool IsJsArray(ReadOnlySpan`1<char> value);
}
public static class ServiceStack.Text.Json.JsonWriter : object {
    public static JsWriter`1<JsonTypeSerializer> Instance;
    private static Dictionary`2<Type, WriteObjectDelegate> WriteFnCache;
    private static Dictionary`2<Type, TypeInfo> JsonTypeInfoCache;
    private static JsonWriter();
    internal static void RemoveCacheFn(Type forType);
    internal static WriteObjectDelegate GetWriteFn(Type type);
    internal static TypeInfo GetTypeInfo(Type type);
    internal static void WriteLateBoundObject(TextWriter writer, object value);
    internal static WriteObjectDelegate GetValueTypeToStringMethod(Type type);
    public static void InitAot();
}
public static class ServiceStack.Text.Json.JsonWriter`1 : object {
    internal static TypeInfo TypeInfo;
    private static WriteObjectDelegate CacheFn;
    private static JsonWriter`1();
    public static void Reset();
    public static void Refresh();
    public static WriteObjectDelegate WriteFn();
    public static TypeInfo GetTypeInfo();
    public static void WriteObject(TextWriter writer, object value);
    public static void WriteRootObject(TextWriter writer, object value);
    public static WriteObjectDelegate GetRootObjectWriteFn(object value);
}
public class ServiceStack.Text.Json.TypeInfo : object {
    internal bool EncodeMapKey;
}
public class ServiceStack.Text.JsonArrayObjects : List`1<JsonObject> {
    public static JsonArrayObjects Parse(string json);
}
[ExtensionAttribute]
public static class ServiceStack.Text.JsonExtensions : object {
    [ExtensionAttribute]
public static T JsonTo(Dictionary`2<string, string> map, string key);
    [ExtensionAttribute]
public static T Get(Dictionary`2<string, string> map, string key, T defaultValue);
    [ExtensionAttribute]
public static T[] GetArray(Dictionary`2<string, string> map, string key);
    [ExtensionAttribute]
public static string Get(Dictionary`2<string, string> map, string key);
    [ExtensionAttribute]
public static JsonArrayObjects ArrayObjects(string json);
    [ExtensionAttribute]
public static List`1<T> ConvertAll(JsonArrayObjects jsonArrayObjects, Func`2<JsonObject, T> converter);
    [ExtensionAttribute]
public static T ConvertTo(JsonObject jsonObject, Func`2<JsonObject, T> convertFn);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToDictionary(JsonObject jsonObject);
}
[DefaultMemberAttribute("Item")]
public class ServiceStack.Text.JsonObject : Dictionary`2<string, string> {
    public string Item { get; public set; }
    public string get_Item(string key);
    public void set_Item(string key, string value);
    public Enumerator<string, string> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, string>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.String>>.GetEnumerator();
    public Dictionary`2<string, string> ToUnescapedDictionary();
    public static JsonObject Parse(string json);
    public static JsonArrayObjects ParseArray(string json);
    public JsonArrayObjects ArrayObjects(string propertyName);
    public JsonObject Object(string propertyName);
    public string GetUnescaped(string key);
    public string Child(string key);
    public static void WriteValue(TextWriter writer, object value);
    private static bool IsJavaScriptNumber(string strValue);
    public T ConvertTo();
    public object ConvertTo(Type type);
}
public static class ServiceStack.Text.JsonSerializer : object {
    public static int BufferSize;
    [CompilerGeneratedAttribute]
private static Action`1<object> <OnSerialize>k__BackingField;
    [ObsoleteAttribute("Use JsConfig.UTF8Encoding")]
public static UTF8Encoding UTF8Encoding { get; public set; }
    public static Action`1<object> OnSerialize { get; public set; }
    private static JsonSerializer();
    public static UTF8Encoding get_UTF8Encoding();
    public static void set_UTF8Encoding(UTF8Encoding value);
    [CompilerGeneratedAttribute]
public static Action`1<object> get_OnSerialize();
    [CompilerGeneratedAttribute]
public static void set_OnSerialize(Action`1<object> value);
    public static T DeserializeFromString(string value);
    public static T DeserializeFromSpan(ReadOnlySpan`1<char> value);
    public static T DeserializeFromReader(TextReader reader);
    public static object DeserializeFromSpan(Type type, ReadOnlySpan`1<char> value);
    public static object DeserializeFromString(string value, Type type);
    public static object DeserializeFromReader(TextReader reader, Type type);
    public static string SerializeToString(T value);
    public static string SerializeToString(object value, Type type);
    public static void SerializeToWriter(T value, TextWriter writer);
    public static void SerializeToWriter(object value, Type type, TextWriter writer);
    public static void SerializeToStream(T value, Stream stream);
    public static void SerializeToStream(object value, Type type, Stream stream);
    private static void WriteObjectToWriter(object value, WriteObjectDelegate serializeFn, TextWriter writer);
    public static T DeserializeFromStream(Stream stream);
    public static object DeserializeFromStream(Type type, Stream stream);
    public static Task`1<object> DeserializeFromStreamAsync(Type type, Stream stream);
    [AsyncStateMachineAttribute("ServiceStack.Text.JsonSerializer/<DeserializeFromStreamAsync>d__25`1")]
public static Task`1<T> DeserializeFromStreamAsync(Stream stream);
    public static T DeserializeResponse(WebRequest webRequest);
    public static object DeserializeResponse(Type type, WebRequest webRequest);
    public static T DeserializeRequest(WebRequest webRequest);
    public static object DeserializeRequest(Type type, WebRequest webRequest);
    public static T DeserializeResponse(WebResponse webResponse);
    public static object DeserializeResponse(Type type, WebResponse webResponse);
}
public class ServiceStack.Text.JsonSerializer`1 : object {
    public sealed virtual bool CanCreateFromString(Type type);
    public sealed virtual T DeserializeFromString(string value);
    public sealed virtual T DeserializeFromReader(TextReader reader);
    public sealed virtual string SerializeToString(T value);
    public sealed virtual void SerializeToWriter(T value, TextWriter writer);
}
public class ServiceStack.Text.JsonStringSerializer : object {
    public sealed virtual To DeserializeFromString(string serializedText);
    public sealed virtual object DeserializeFromString(string serializedText, Type type);
    public sealed virtual string SerializeToString(TFrom from);
}
public class ServiceStack.Text.JsonValue : ValueType {
    private string json;
    public JsonValue(string json);
    public T As();
    public virtual string ToString();
    public sealed virtual void WriteTo(ITypeSerializer serializer, TextWriter writer);
}
public static class ServiceStack.Text.Jsv.JsvReader : object {
    internal static JsReader`1<JsvTypeSerializer> Instance;
    private static Dictionary`2<Type, ParseFactoryDelegate> ParseFnCache;
    private static JsvReader();
    public static ParseStringDelegate GetParseFn(Type type);
    public static ParseStringSpanDelegate GetParseSpanFn(Type type);
    public static ParseStringSpanDelegate GetParseStringSpanFn(Type type);
    public static void InitAot();
}
internal static class ServiceStack.Text.Jsv.JsvReader`1 : object {
    private static ParseStringSpanDelegate ReadFn;
    private static JsvReader`1();
    public static void Refresh();
    public static ParseStringDelegate GetParseFn();
    public static ParseStringSpanDelegate GetParseStringSpanFn();
    public static object Parse(string value);
    public static object Parse(ReadOnlySpan`1<char> value);
}
internal class ServiceStack.Text.Jsv.JsvSerializer`1 : object {
    private Dictionary`2<Type, ParseStringDelegate> DeserializerCache;
    public T DeserializeFromString(string value, Type type);
    public T DeserializeFromString(string value);
    public void SerializeToWriter(T value, TextWriter writer);
    public string SerializeToString(T value);
}
public class ServiceStack.Text.Jsv.JsvTypeSerializer : ValueType {
    public static ITypeSerializer Instance;
    [CompilerGeneratedAttribute]
private ObjectDeserializerDelegate <ObjectDeserializer>k__BackingField;
    private static TypeInfo DefaultTypeInfo;
    public ObjectDeserializerDelegate ObjectDeserializer { get; public set; }
    public bool IncludeNullValues { get; }
    public bool IncludeNullValuesInDictionaries { get; }
    public string TypeAttrInObject { get; }
    private static JsvTypeSerializer();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ObjectDeserializerDelegate get_ObjectDeserializer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ObjectDeserializer(ObjectDeserializerDelegate value);
    public sealed virtual bool get_IncludeNullValues();
    public sealed virtual bool get_IncludeNullValuesInDictionaries();
    public sealed virtual string get_TypeAttrInObject();
    internal static string GetTypeAttrInObject(string typeAttr);
    public sealed virtual WriteObjectDelegate GetWriteFn();
    public sealed virtual WriteObjectDelegate GetWriteFn(Type type);
    public sealed virtual TypeInfo GetTypeInfo(Type type);
    public sealed virtual void WriteRawString(TextWriter writer, string value);
    public sealed virtual void WritePropertyName(TextWriter writer, string value);
    public sealed virtual void WriteBuiltIn(TextWriter writer, object value);
    public sealed virtual void WriteObjectString(TextWriter writer, object value);
    public sealed virtual void WriteException(TextWriter writer, object value);
    public sealed virtual void WriteString(TextWriter writer, string value);
    public sealed virtual void WriteFormattableObjectString(TextWriter writer, object value);
    public sealed virtual void WriteDateTime(TextWriter writer, object oDateTime);
    public sealed virtual void WriteNullableDateTime(TextWriter writer, object dateTime);
    public sealed virtual void WriteDateTimeOffset(TextWriter writer, object oDateTimeOffset);
    public sealed virtual void WriteNullableDateTimeOffset(TextWriter writer, object dateTimeOffset);
    public sealed virtual void WriteTimeSpan(TextWriter writer, object oTimeSpan);
    public sealed virtual void WriteNullableTimeSpan(TextWriter writer, object oTimeSpan);
    public sealed virtual void WriteGuid(TextWriter writer, object oValue);
    public sealed virtual void WriteNullableGuid(TextWriter writer, object oValue);
    public sealed virtual void WriteBytes(TextWriter writer, object oByteValue);
    public sealed virtual void WriteChar(TextWriter writer, object charValue);
    public sealed virtual void WriteByte(TextWriter writer, object byteValue);
    public sealed virtual void WriteSByte(TextWriter writer, object sbyteValue);
    public sealed virtual void WriteInt16(TextWriter writer, object intValue);
    public sealed virtual void WriteUInt16(TextWriter writer, object intValue);
    public sealed virtual void WriteInt32(TextWriter writer, object intValue);
    public sealed virtual void WriteUInt32(TextWriter writer, object uintValue);
    public sealed virtual void WriteUInt64(TextWriter writer, object ulongValue);
    public sealed virtual void WriteInt64(TextWriter writer, object longValue);
    public sealed virtual void WriteBool(TextWriter writer, object boolValue);
    public sealed virtual void WriteFloat(TextWriter writer, object floatValue);
    public sealed virtual void WriteDouble(TextWriter writer, object doubleValue);
    public sealed virtual void WriteDecimal(TextWriter writer, object decimalValue);
    public sealed virtual void WriteEnum(TextWriter writer, object enumValue);
    public sealed virtual ParseStringDelegate GetParseFn();
    public sealed virtual ParseStringDelegate GetParseFn(Type type);
    public sealed virtual ParseStringSpanDelegate GetParseStringSpanFn();
    public sealed virtual ParseStringSpanDelegate GetParseStringSpanFn(Type type);
    public sealed virtual object UnescapeStringAsObject(ReadOnlySpan`1<char> value);
    public sealed virtual string UnescapeSafeString(string value);
    public sealed virtual ReadOnlySpan`1<char> UnescapeSafeString(ReadOnlySpan`1<char> value);
    public sealed virtual string ParseRawString(string value);
    public sealed virtual string ParseString(string value);
    public sealed virtual string ParseString(ReadOnlySpan`1<char> value);
    public sealed virtual string UnescapeString(string value);
    public sealed virtual ReadOnlySpan`1<char> UnescapeString(ReadOnlySpan`1<char> value);
    public sealed virtual string EatTypeValue(string value, Int32& i);
    public sealed virtual ReadOnlySpan`1<char> EatTypeValue(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual bool EatMapStartChar(string value, Int32& i);
    public sealed virtual bool EatMapStartChar(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual string EatMapKey(string value, Int32& i);
    public sealed virtual ReadOnlySpan`1<char> EatMapKey(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual bool EatMapKeySeperator(string value, Int32& i);
    public sealed virtual bool EatMapKeySeperator(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual bool EatItemSeperatorOrMapEndChar(string value, Int32& i);
    public sealed virtual bool EatItemSeperatorOrMapEndChar(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual void EatWhitespace(string value, Int32& i);
    public sealed virtual void EatWhitespace(ReadOnlySpan`1<char> value, Int32& i);
    public sealed virtual string EatValue(string value, Int32& i);
    public sealed virtual ReadOnlySpan`1<char> EatValue(ReadOnlySpan`1<char> value, Int32& i);
}
public static class ServiceStack.Text.Jsv.JsvWriter : object {
    public static JsWriter`1<JsvTypeSerializer> Instance;
    private static Dictionary`2<Type, WriteObjectDelegate> WriteFnCache;
    private static JsvWriter();
    internal static void RemoveCacheFn(Type forType);
    public static WriteObjectDelegate GetWriteFn(Type type);
    public static void WriteLateBoundObject(TextWriter writer, object value);
    public static WriteObjectDelegate GetValueTypeToStringMethod(Type type);
    public static void InitAot();
}
public static class ServiceStack.Text.Jsv.JsvWriter`1 : object {
    private static WriteObjectDelegate CacheFn;
    private static JsvWriter`1();
    public static void Reset();
    public static void Refresh();
    public static WriteObjectDelegate WriteFn();
    public static void WriteObject(TextWriter writer, object value);
    public static void WriteRootObject(TextWriter writer, object value);
}
public static class ServiceStack.Text.JsvFormatter : object {
    public static string Format(string serializedText);
    private static void AppendTabLine(StringBuilder sb, int tabCount);
}
public class ServiceStack.Text.JsvStringSerializer : object {
    public sealed virtual To DeserializeFromString(string serializedText);
    public sealed virtual object DeserializeFromString(string serializedText, Type type);
    public sealed virtual string SerializeToString(TFrom from);
}
internal class ServiceStack.Text.Marc.Link`2 : object {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Link`2<TKey, TValue> <Tail>k__BackingField;
    public TKey Key { get; private set; }
    public TValue Value { get; private set; }
    public Link`2<TKey, TValue> Tail { get; private set; }
    private Link`2(TKey key, TValue value, Link`2<TKey, TValue> tail);
    public static bool TryGet(Link`2<TKey, TValue> link, TKey key, TValue& value);
    public static bool TryAdd(Link`2& head, TKey key, TValue& value);
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(TKey value);
    [CompilerGeneratedAttribute]
public TValue get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(TValue value);
    [CompilerGeneratedAttribute]
public Link`2<TKey, TValue> get_Tail();
    [CompilerGeneratedAttribute]
private void set_Tail(Link`2<TKey, TValue> value);
}
public abstract class ServiceStack.Text.MemoryProvider : object {
    public static MemoryProvider Instance;
    internal static string BadFormat;
    internal static string OverflowMessage;
    private static MemoryProvider();
    public abstract virtual bool TryParseBoolean(ReadOnlySpan`1<char> value, Boolean& result);
    public abstract virtual bool ParseBoolean(ReadOnlySpan`1<char> value);
    public abstract virtual bool TryParseDecimal(ReadOnlySpan`1<char> value, Decimal& result);
    public abstract virtual decimal ParseDecimal(ReadOnlySpan`1<char> value);
    public abstract virtual decimal ParseDecimal(ReadOnlySpan`1<char> value, bool allowThousands);
    public abstract virtual bool TryParseFloat(ReadOnlySpan`1<char> value, Single& result);
    public abstract virtual float ParseFloat(ReadOnlySpan`1<char> value);
    public abstract virtual bool TryParseDouble(ReadOnlySpan`1<char> value, Double& result);
    public abstract virtual double ParseDouble(ReadOnlySpan`1<char> value);
    public abstract virtual sbyte ParseSByte(ReadOnlySpan`1<char> value);
    public abstract virtual byte ParseByte(ReadOnlySpan`1<char> value);
    public abstract virtual short ParseInt16(ReadOnlySpan`1<char> value);
    public abstract virtual ushort ParseUInt16(ReadOnlySpan`1<char> value);
    public abstract virtual int ParseInt32(ReadOnlySpan`1<char> value);
    public abstract virtual UInt32 ParseUInt32(ReadOnlySpan`1<char> value);
    public abstract virtual UInt32 ParseUInt32(ReadOnlySpan`1<char> value, NumberStyles style);
    public abstract virtual long ParseInt64(ReadOnlySpan`1<char> value);
    public abstract virtual ulong ParseUInt64(ReadOnlySpan`1<char> value);
    public abstract virtual Guid ParseGuid(ReadOnlySpan`1<char> value);
    public abstract virtual Byte[] ParseBase64(ReadOnlySpan`1<char> value);
    public abstract virtual string ToBase64(ReadOnlyMemory`1<byte> value);
    public abstract virtual void Write(Stream stream, ReadOnlyMemory`1<char> value);
    public abstract virtual void Write(Stream stream, ReadOnlyMemory`1<byte> value);
    public abstract virtual Task WriteAsync(Stream stream, ReadOnlyMemory`1<char> value, CancellationToken token);
    public abstract virtual Task WriteAsync(Stream stream, ReadOnlyMemory`1<byte> value, CancellationToken token);
    public abstract virtual Task WriteAsync(Stream stream, ReadOnlySpan`1<char> value, CancellationToken token);
    public abstract virtual object Deserialize(Stream stream, Type type, DeserializeStringSpanDelegate deserializer);
    public abstract virtual Task`1<object> DeserializeAsync(Stream stream, Type type, DeserializeStringSpanDelegate deserializer);
    public abstract virtual StringBuilder Append(StringBuilder sb, ReadOnlySpan`1<char> value);
    public abstract virtual int GetUtf8CharCount(ReadOnlySpan`1<byte> bytes);
    public abstract virtual int GetUtf8ByteCount(ReadOnlySpan`1<char> chars);
    public abstract virtual ReadOnlyMemory`1<byte> ToUtf8(ReadOnlySpan`1<char> source);
    public abstract virtual ReadOnlyMemory`1<char> FromUtf8(ReadOnlySpan`1<byte> source);
    public abstract virtual int ToUtf8(ReadOnlySpan`1<char> source, Span`1<byte> destination);
    public abstract virtual int FromUtf8(ReadOnlySpan`1<byte> source, Span`1<char> destination);
    public abstract virtual Byte[] ToUtf8Bytes(ReadOnlySpan`1<char> source);
    public abstract virtual string FromUtf8Bytes(ReadOnlySpan`1<byte> source);
    public abstract virtual MemoryStream ToMemoryStream(ReadOnlySpan`1<byte> source);
}
public static class ServiceStack.Text.MemoryStreamFactory : object {
    [CompilerGeneratedAttribute]
private static bool <UseRecyclableMemoryStream>k__BackingField;
    public static RecyclableMemoryStreamManager RecyclableInstance;
    public static bool UseRecyclableMemoryStream { get; public set; }
    private static MemoryStreamFactory();
    [CompilerGeneratedAttribute]
public static bool get_UseRecyclableMemoryStream();
    [CompilerGeneratedAttribute]
public static void set_UseRecyclableMemoryStream(bool value);
    public static MemoryStream GetStream();
    public static MemoryStream GetStream(int capacity);
    public static MemoryStream GetStream(Byte[] bytes);
    public static MemoryStream GetStream(Byte[] bytes, int index, int count);
}
public class ServiceStack.Text.MurmurHash2 : object {
    private static UInt32 m;
    private static int r;
    public static UInt32 Hash(string data);
    public static UInt32 Hash(Byte[] data);
    public static UInt32 Hash(Byte[] data, UInt32 seed);
}
[FlagsAttribute]
public enum ServiceStack.Text.ParseAsType : Enum {
    public int value__;
    public static ParseAsType None;
    public static ParseAsType Bool;
    public static ParseAsType Byte;
    public static ParseAsType SByte;
    public static ParseAsType Int16;
    public static ParseAsType Int32;
    public static ParseAsType Int64;
    public static ParseAsType UInt16;
    public static ParseAsType UInt32;
    public static ParseAsType UInt64;
    public static ParseAsType Decimal;
    public static ParseAsType Double;
    public static ParseAsType Single;
}
internal enum ServiceStack.Text.ParseState : Enum {
    public int value__;
    public static ParseState LeadingWhite;
    public static ParseState Sign;
    public static ParseState Number;
    public static ParseState DecimalPoint;
    public static ParseState FractionNumber;
    public static ParseState Exponent;
    public static ParseState ExponentSign;
    public static ParseState ExponentValue;
    public static ParseState TrailingWhite;
}
public class ServiceStack.Text.Pools.BufferPool : object {
    private static int POOL_SIZE;
    public static int BUFFER_LENGTH;
    private static CachedBuffer[] Pool;
    private static int MaxByteArraySize;
    private static BufferPool();
    public static void Flush();
    public static Byte[] GetBuffer();
    public static Byte[] GetBuffer(int minSize);
    public static Byte[] GetCachedBuffer(int minSize);
    public static void ResizeAndFlushLeft(Byte[]& buffer, int toFitAtLeastBytes, int copyFromIndex, int copyBytes);
    public static void ReleaseBufferToPool(Byte[]& buffer);
}
public class ServiceStack.Text.Pools.CharPool : object {
    private static int POOL_SIZE;
    public static int BUFFER_LENGTH;
    private static CachedBuffer[] Pool;
    private static int MaxcharArraySize;
    private static CharPool();
    public static void Flush();
    public static Char[] GetBuffer();
    public static Char[] GetBuffer(int minSize);
    public static Char[] GetCachedBuffer(int minSize);
    public static void ResizeAndFlushLeft(Char[]& buffer, int toFitAtLeastchars, int copyFromIndex, int copychars);
    public static void ReleaseBufferToPool(Char[]& buffer);
}
internal class ServiceStack.Text.Pools.Helpers : object {
    [ConditionalAttribute("DEBUG")]
internal static void DebugAssert(bool condition);
}
public class ServiceStack.Text.Pools.ObjectPool`1 : object {
    private T _firstItem;
    private Element[] _items;
    private Factory<T> _factory;
    public ObjectPool`1(Factory<T> factory);
    public ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    public T Allocate();
    private T AllocateSlow();
    public void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
public void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
public class ServiceStack.Text.Pools.PooledObject`1 : ValueType {
    private Action`2<ObjectPool`1<T>, T> _releaser;
    private ObjectPool`1<T> _pool;
    private T _pooledObject;
    public T Object { get; }
    public PooledObject`1(ObjectPool`1<T> pool, Func`2<ObjectPool`1<T>, T> allocator, Action`2<ObjectPool`1<T>, T> releaser);
    public T get_Object();
    public sealed virtual void Dispose();
    public static PooledObject`1<StringBuilder> Create(ObjectPool`1<StringBuilder> pool);
    public static PooledObject`1<Stack`1<TItem>> Create(ObjectPool`1<Stack`1<TItem>> pool);
    public static PooledObject`1<Queue`1<TItem>> Create(ObjectPool`1<Queue`1<TItem>> pool);
    public static PooledObject`1<HashSet`1<TItem>> Create(ObjectPool`1<HashSet`1<TItem>> pool);
    public static PooledObject`1<Dictionary`2<TKey, TValue>> Create(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    public static PooledObject`1<List`1<TItem>> Create(ObjectPool`1<List`1<TItem>> pool);
    private static StringBuilder Allocator(ObjectPool`1<StringBuilder> pool);
    private static void Releaser(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    private static Stack`1<TItem> Allocator(ObjectPool`1<Stack`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Stack`1<TItem>> pool, Stack`1<TItem> obj);
    private static Queue`1<TItem> Allocator(ObjectPool`1<Queue`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Queue`1<TItem>> pool, Queue`1<TItem> obj);
    private static HashSet`1<TItem> Allocator(ObjectPool`1<HashSet`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1<TItem> obj);
    private static Dictionary`2<TKey, TValue> Allocator(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    private static void Releaser(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> obj);
    private static List`1<TItem> Allocator(ObjectPool`1<List`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<List`1<TItem>> pool, List`1<TItem> obj);
}
[ExtensionAttribute]
internal static class ServiceStack.Text.Pools.SharedPoolExtensions : object {
    private static int Threshold;
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Queue`1<TItem>> GetPooledObject(ObjectPool`1<Queue`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<T> GetPooledObject(ObjectPool`1<T> pool);
    [ExtensionAttribute]
public static StringBuilder AllocateAndClear(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static Stack`1<T> AllocateAndClear(ObjectPool`1<Stack`1<T>> pool);
    [ExtensionAttribute]
public static Queue`1<T> AllocateAndClear(ObjectPool`1<Queue`1<T>> pool);
    [ExtensionAttribute]
public static HashSet`1<T> AllocateAndClear(ObjectPool`1<HashSet`1<T>> pool);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AllocateAndClear(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static List`1<T> AllocateAndClear(ObjectPool`1<List`1<T>> pool);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<HashSet`1<T>> pool, HashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Stack`1<T>> pool, Stack`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Queue`1<T>> pool, Queue`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<List`1<T>> pool, List`1<T> list);
}
public static class ServiceStack.Text.Pools.SharedPools : object {
    public static ObjectPool`1<HashSet`1<string>> StringIgnoreCaseHashSet;
    public static ObjectPool`1<HashSet`1<string>> StringHashSet;
    public static ObjectPool`1<Byte[]> ByteArray;
    public static int ByteBufferSize;
    private static int ByteBufferCount;
    public static ObjectPool`1<Byte[]> AsyncByteArray;
    private static SharedPools();
    public static ObjectPool`1<T> BigDefault();
    public static ObjectPool`1<T> Default();
    public static ObjectPool`1<Dictionary`2<string, T>> StringIgnoreCaseDictionary();
}
public static class ServiceStack.Text.Pools.StringBuilderPool : object {
    public static StringBuilder Allocate();
    public static void Free(StringBuilder builder);
    public static string ReturnAndFree(StringBuilder builder);
}
public enum ServiceStack.Text.PropertyConvention : Enum {
    public int value__;
    public static PropertyConvention Strict;
    public static PropertyConvention Lenient;
}
public class ServiceStack.Text.RecyclableMemoryStream : MemoryStream {
    private static long MaxStreamLength;
    private static Byte[] emptyArray;
    private List`1<Byte[]> blocks;
    private Guid id;
    private RecyclableMemoryStreamManager memoryManager;
    private string tag;
    private List`1<Byte[]> dirtyBuffers;
    private long disposedState;
    private Byte[] largeBuffer;
    [CompilerGeneratedAttribute]
private string <AllocationStack>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisposeStack>k__BackingField;
    private int length;
    private int position;
    internal Guid Id { get; }
    internal string Tag { get; }
    internal RecyclableMemoryStreamManager MemoryManager { get; }
    internal string AllocationStack { get; }
    internal string DisposeStack { get; private set; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    private bool Disposed { get; }
    public RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager);
    public RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager, Guid id);
    public RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager, string tag);
    public RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager, Guid id, string tag);
    public RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager, string tag, int requestedSize);
    public RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager, Guid id, string tag, int requestedSize);
    internal RecyclableMemoryStream(RecyclableMemoryStreamManager memoryManager, Guid id, string tag, int requestedSize, Byte[] initialLargeBuffer);
    private static RecyclableMemoryStream();
    internal Guid get_Id();
    internal string get_Tag();
    internal RecyclableMemoryStreamManager get_MemoryManager();
    [CompilerGeneratedAttribute]
internal string get_AllocationStack();
    [CompilerGeneratedAttribute]
internal string get_DisposeStack();
    [CompilerGeneratedAttribute]
private void set_DisposeStack(string value);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual Byte[] GetBuffer();
    public bool TryGetBuffer(ArraySegment`1& buffer);
    [ObsoleteAttribute("This method has degraded performance vs. GetBuffer and should be avoided.")]
public virtual Byte[] ToArray();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public int SafeRead(Byte[] buffer, int offset, int count, Int32& streamPosition);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual string ToString();
    public virtual void WriteByte(byte value);
    public virtual int ReadByte();
    public int SafeReadByte(Int32& streamPosition);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void WriteTo(Stream stream);
    public void WriteTo(Stream stream, int offset, int count);
    private bool get_Disposed();
    private void CheckDisposed();
    private void ThrowDisposedException();
    private int InternalRead(Byte[] buffer, int offset, int count, int fromPosition);
    private BlockAndOffset GetBlockAndRelativeOffset(int offset);
    private void EnsureCapacity(int newCapacity);
    private void ReleaseLargeBuffer();
}
public class ServiceStack.Text.RecyclableMemoryStreamManager : object {
    public static int DefaultBlockSize;
    public static int DefaultLargeBufferMultiple;
    public static int DefaultMaximumBufferSize;
    private Int64[] largeBufferFreeSize;
    private Int64[] largeBufferInUseSize;
    private ConcurrentStack`1[] largePools;
    private ConcurrentStack`1<Byte[]> smallPool;
    private long smallPoolFreeSize;
    private long smallPoolInUseSize;
    [CompilerGeneratedAttribute]
private int <BlockSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LargeBufferMultiple>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseExponentialLargeBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaximumFreeSmallPoolBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaximumFreeLargePoolBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaximumStreamCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateCallStacks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AggressiveBufferReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowExceptionOnToArray>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler BlockCreated;
    [CompilerGeneratedAttribute]
private EventHandler BlockDiscarded;
    [CompilerGeneratedAttribute]
private EventHandler LargeBufferCreated;
    [CompilerGeneratedAttribute]
private EventHandler StreamCreated;
    [CompilerGeneratedAttribute]
private EventHandler StreamDisposed;
    [CompilerGeneratedAttribute]
private EventHandler StreamFinalized;
    [CompilerGeneratedAttribute]
private StreamLengthReportHandler StreamLength;
    [CompilerGeneratedAttribute]
private EventHandler StreamConvertedToArray;
    [CompilerGeneratedAttribute]
private LargeBufferDiscardedEventHandler LargeBufferDiscarded;
    [CompilerGeneratedAttribute]
private UsageReportEventHandler UsageReport;
    public int BlockSize { get; }
    public int LargeBufferMultiple { get; }
    public bool UseMultipleLargeBuffer { get; }
    public bool UseExponentialLargeBuffer { get; }
    public int MaximumBufferSize { get; }
    public long SmallPoolFreeSize { get; }
    public long SmallPoolInUseSize { get; }
    public long LargePoolFreeSize { get; }
    public long LargePoolInUseSize { get; }
    public long SmallBlocksFree { get; }
    public long LargeBuffersFree { get; }
    public long MaximumFreeSmallPoolBytes { get; public set; }
    public long MaximumFreeLargePoolBytes { get; public set; }
    public long MaximumStreamCapacity { get; public set; }
    public bool GenerateCallStacks { get; public set; }
    public bool AggressiveBufferReturn { get; public set; }
    public bool ThrowExceptionOnToArray { get; public set; }
    public RecyclableMemoryStreamManager(int blockSize, int largeBufferMultiple, int maximumBufferSize);
    public RecyclableMemoryStreamManager(int blockSize, int largeBufferMultiple, int maximumBufferSize, bool useExponentialLargeBuffer);
    [CompilerGeneratedAttribute]
public int get_BlockSize();
    [CompilerGeneratedAttribute]
public int get_LargeBufferMultiple();
    public bool get_UseMultipleLargeBuffer();
    [CompilerGeneratedAttribute]
public bool get_UseExponentialLargeBuffer();
    [CompilerGeneratedAttribute]
public int get_MaximumBufferSize();
    public long get_SmallPoolFreeSize();
    public long get_SmallPoolInUseSize();
    public long get_LargePoolFreeSize();
    public long get_LargePoolInUseSize();
    public long get_SmallBlocksFree();
    public long get_LargeBuffersFree();
    [CompilerGeneratedAttribute]
public long get_MaximumFreeSmallPoolBytes();
    [CompilerGeneratedAttribute]
public void set_MaximumFreeSmallPoolBytes(long value);
    [CompilerGeneratedAttribute]
public long get_MaximumFreeLargePoolBytes();
    [CompilerGeneratedAttribute]
public void set_MaximumFreeLargePoolBytes(long value);
    [CompilerGeneratedAttribute]
public long get_MaximumStreamCapacity();
    [CompilerGeneratedAttribute]
public void set_MaximumStreamCapacity(long value);
    [CompilerGeneratedAttribute]
public bool get_GenerateCallStacks();
    [CompilerGeneratedAttribute]
public void set_GenerateCallStacks(bool value);
    [CompilerGeneratedAttribute]
public bool get_AggressiveBufferReturn();
    [CompilerGeneratedAttribute]
public void set_AggressiveBufferReturn(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThrowExceptionOnToArray();
    [CompilerGeneratedAttribute]
public void set_ThrowExceptionOnToArray(bool value);
    internal Byte[] GetBlock();
    internal Byte[] GetLargeBuffer(int requiredSize, string tag);
    private int RoundToLargeBufferSize(int requiredSize);
    private bool IsLargeBufferSize(int value);
    private int GetPoolIndex(int length);
    internal void ReturnLargeBuffer(Byte[] buffer, string tag);
    internal void ReturnBlocks(ICollection`1<Byte[]> blocks, string tag);
    internal void ReportBlockCreated();
    internal void ReportBlockDiscarded();
    internal void ReportLargeBufferCreated();
    internal void ReportLargeBufferDiscarded(MemoryStreamDiscardReason reason);
    internal void ReportStreamCreated();
    internal void ReportStreamDisposed();
    internal void ReportStreamFinalized();
    internal void ReportStreamLength(long bytes);
    internal void ReportStreamToArray();
    internal void ReportUsageReport(long smallPoolInUseBytes, long smallPoolFreeBytes, long largePoolInUseBytes, long largePoolFreeBytes);
    public MemoryStream GetStream();
    public MemoryStream GetStream(Guid id);
    public MemoryStream GetStream(string tag);
    public MemoryStream GetStream(Guid id, string tag);
    public MemoryStream GetStream(string tag, int requiredSize);
    public MemoryStream GetStream(Guid id, string tag, int requiredSize);
    public MemoryStream GetStream(Guid id, string tag, int requiredSize, bool asContiguousBuffer);
    public MemoryStream GetStream(string tag, int requiredSize, bool asContiguousBuffer);
    public MemoryStream GetStream(Guid id, string tag, Byte[] buffer, int offset, int count);
    public MemoryStream GetStream(Byte[] buffer);
    public MemoryStream GetStream(string tag, Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
public void add_BlockCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BlockCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_BlockDiscarded(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BlockDiscarded(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_LargeBufferCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LargeBufferCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamCreated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamDisposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamDisposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamFinalized(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamFinalized(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamLength(StreamLengthReportHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamLength(StreamLengthReportHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamConvertedToArray(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamConvertedToArray(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_LargeBufferDiscarded(LargeBufferDiscardedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LargeBufferDiscarded(LargeBufferDiscardedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UsageReport(UsageReportEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UsageReport(UsageReportEventHandler value);
}
public abstract class ServiceStack.Text.ReflectionOptimizer : object {
    public static ReflectionOptimizer Instance;
    private static ReflectionOptimizer();
    public abstract virtual Type UseType(Type type);
    public abstract virtual GetMemberDelegate CreateGetter(PropertyInfo propertyInfo);
    public abstract virtual GetMemberDelegate`1<T> CreateGetter(PropertyInfo propertyInfo);
    public abstract virtual SetMemberDelegate CreateSetter(PropertyInfo propertyInfo);
    public abstract virtual SetMemberDelegate`1<T> CreateSetter(PropertyInfo propertyInfo);
    public abstract virtual GetMemberDelegate CreateGetter(FieldInfo fieldInfo);
    public abstract virtual GetMemberDelegate`1<T> CreateGetter(FieldInfo fieldInfo);
    public abstract virtual SetMemberDelegate CreateSetter(FieldInfo fieldInfo);
    public abstract virtual SetMemberDelegate`1<T> CreateSetter(FieldInfo fieldInfo);
    public abstract virtual SetMemberRefDelegate`1<T> CreateSetterRef(FieldInfo fieldInfo);
    public abstract virtual bool IsDynamic(Assembly assembly);
    public abstract virtual EmptyCtorDelegate CreateConstructor(Type type);
}
public class ServiceStack.Text.RuntimeReflectionOptimizer : ReflectionOptimizer {
    private static RuntimeReflectionOptimizer provider;
    public static RuntimeReflectionOptimizer Provider { get; }
    public static RuntimeReflectionOptimizer get_Provider();
    public virtual Type UseType(Type type);
    public virtual GetMemberDelegate CreateGetter(PropertyInfo propertyInfo);
    public virtual GetMemberDelegate`1<T> CreateGetter(PropertyInfo propertyInfo);
    public virtual SetMemberDelegate CreateSetter(PropertyInfo propertyInfo);
    public virtual SetMemberDelegate`1<T> CreateSetter(PropertyInfo propertyInfo);
    public virtual GetMemberDelegate CreateGetter(FieldInfo fieldInfo);
    public virtual GetMemberDelegate`1<T> CreateGetter(FieldInfo fieldInfo);
    public virtual SetMemberDelegate CreateSetter(FieldInfo fieldInfo);
    public virtual SetMemberDelegate`1<T> CreateSetter(FieldInfo fieldInfo);
    public virtual SetMemberRefDelegate`1<T> CreateSetterRef(FieldInfo fieldInfo);
    public virtual bool IsDynamic(Assembly assembly);
    public virtual EmptyCtorDelegate CreateConstructor(Type type);
}
[AttributeUsageAttribute("4")]
public class ServiceStack.Text.RuntimeSerializableAttribute : Attribute {
}
internal static class ServiceStack.Text.SignedInteger`1 : object {
    private static TypeCode typeCode;
    private static long minValue;
    private static long maxValue;
    private static SignedInteger`1();
    internal static object ParseNullableObject(ReadOnlySpan`1<char> value);
    internal static object ParseObject(ReadOnlySpan`1<char> value);
    public static sbyte ParseSByte(ReadOnlySpan`1<char> value);
    public static short ParseInt16(ReadOnlySpan`1<char> value);
    public static int ParseInt32(ReadOnlySpan`1<char> value);
    public static long ParseInt64(ReadOnlySpan`1<char> value);
}
public static class ServiceStack.Text.StringBuilderCache : object {
    [ThreadStaticAttribute]
private static StringBuilder cache;
    public static StringBuilder Allocate();
    public static void Free(StringBuilder sb);
    public static string ReturnAndFree(StringBuilder sb);
}
public static class ServiceStack.Text.StringBuilderCacheAlt : object {
    [ThreadStaticAttribute]
private static StringBuilder cache;
    public static StringBuilder Allocate();
    public static void Free(StringBuilder sb);
    public static string ReturnAndFree(StringBuilder sb);
}
internal static class ServiceStack.Text.StringBuilderThreadStatic : object {
    [ThreadStaticAttribute]
private static StringBuilder cache;
    public static StringBuilder Allocate();
    public static void Free(StringBuilder sb);
    public static string ReturnAndFree(StringBuilder sb);
}
[ExtensionAttribute]
public static class ServiceStack.Text.StringSpanExtensions : object {
    [ExtensionAttribute]
public static string Value(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static object Value(object obj);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
[ObsoleteAttribute("Use value[index]")]
public static char GetChar(ReadOnlySpan`1<char> value, int index);
    [ExtensionAttribute]
public static string Substring(ReadOnlySpan`1<char> value, int pos);
    [ExtensionAttribute]
public static string Substring(ReadOnlySpan`1<char> value, int pos, int length);
    [ExtensionAttribute]
public static bool CompareIgnoreCase(ReadOnlySpan`1<char> value, ReadOnlySpan`1<char> text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> FromCsvField(ReadOnlySpan`1<char> text);
    [ExtensionAttribute]
public static bool ParseBoolean(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static bool TryParseBoolean(ReadOnlySpan`1<char> value, Boolean& result);
    [ExtensionAttribute]
public static bool TryParseDecimal(ReadOnlySpan`1<char> value, Decimal& result);
    [ExtensionAttribute]
public static bool TryParseFloat(ReadOnlySpan`1<char> value, Single& result);
    [ExtensionAttribute]
public static bool TryParseDouble(ReadOnlySpan`1<char> value, Double& result);
    [ExtensionAttribute]
public static decimal ParseDecimal(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static decimal ParseDecimal(ReadOnlySpan`1<char> value, bool allowThousands);
    [ExtensionAttribute]
public static float ParseFloat(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static double ParseDouble(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static sbyte ParseSByte(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static byte ParseByte(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static short ParseInt16(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static ushort ParseUInt16(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static int ParseInt32(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static UInt32 ParseUInt32(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static long ParseInt64(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static ulong ParseUInt64(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static Guid ParseGuid(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static object ParseSignedInteger(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static bool TryReadLine(ReadOnlySpan`1<char> text, ReadOnlySpan`1& line, Int32& startIndex);
    [ExtensionAttribute]
public static bool TryReadPart(ReadOnlySpan`1<char> text, string needle, ReadOnlySpan`1& part, Int32& startIndex);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Advance(ReadOnlySpan`1<char> text, int to);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AdvancePastWhitespace(ReadOnlySpan`1<char> literal);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AdvancePastChar(ReadOnlySpan`1<char> literal, char delim);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Slice()")]
public static ReadOnlySpan`1<char> Subsegment(ReadOnlySpan`1<char> text, int startPos);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Slice()")]
public static ReadOnlySpan`1<char> Subsegment(ReadOnlySpan`1<char> text, int startPos, int length);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> LeftPart(ReadOnlySpan`1<char> strVal, char needle);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> LeftPart(ReadOnlySpan`1<char> strVal, string needle);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> RightPart(ReadOnlySpan`1<char> strVal, char needle);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> RightPart(ReadOnlySpan`1<char> strVal, string needle);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> LastLeftPart(ReadOnlySpan`1<char> strVal, char needle);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> LastLeftPart(ReadOnlySpan`1<char> strVal, string needle);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> LastRightPart(ReadOnlySpan`1<char> strVal, char needle);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> LastRightPart(ReadOnlySpan`1<char> strVal, string needle);
    [ExtensionAttribute]
public static void SplitOnFirst(ReadOnlySpan`1<char> strVal, char needle, ReadOnlySpan`1& first, ReadOnlySpan`1& last);
    [ExtensionAttribute]
public static void SplitOnFirst(ReadOnlySpan`1<char> strVal, string needle, ReadOnlySpan`1& first, ReadOnlySpan`1& last);
    [ExtensionAttribute]
public static void SplitOnLast(ReadOnlySpan`1<char> strVal, char needle, ReadOnlySpan`1& first, ReadOnlySpan`1& last);
    [ExtensionAttribute]
public static void SplitOnLast(ReadOnlySpan`1<char> strVal, string needle, ReadOnlySpan`1& first, ReadOnlySpan`1& last);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> WithoutExtension(ReadOnlySpan`1<char> filePath);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> GetExtension(ReadOnlySpan`1<char> filePath);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParentDirectory(ReadOnlySpan`1<char> filePath);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> value, Char[] trimChars);
    [ExtensionAttribute]
private static ReadOnlySpan`1<char> TrimHelper(ReadOnlySpan`1<char> value, int trimType);
    [ExtensionAttribute]
private static ReadOnlySpan`1<char> TrimHelper(ReadOnlySpan`1<char> value, Char[] trimChars, int trimType);
    [ExtensionAttribute]
private static ReadOnlySpan`1<char> CreateTrimmedString(ReadOnlySpan`1<char> value, int start, int end);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> SafeSlice(ReadOnlySpan`1<char> value, int startIndex);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> SafeSlice(ReadOnlySpan`1<char> value, int startIndex, int length);
    [ExtensionAttribute]
public static string SubstringWithEllipsis(ReadOnlySpan`1<char> value, int startIndex, int length);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> value, string other);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> value, string needle, int start);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<char> value, string other);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<char> value, string needle, int start);
    [ExtensionAttribute]
public static bool EqualTo(ReadOnlySpan`1<char> value, string other);
    [ExtensionAttribute]
public static bool EqualTo(ReadOnlySpan`1<char> value, ReadOnlySpan`1<char> other);
    [ExtensionAttribute]
public static bool EqualsOrdinal(ReadOnlySpan`1<char> value, string other);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> value, string other);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> value, string other, StringComparison comparison);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> value, string other, StringComparison comparison);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> value, string other);
    [ExtensionAttribute]
public static bool EqualsIgnoreCase(ReadOnlySpan`1<char> value, ReadOnlySpan`1<char> other);
    [ExtensionAttribute]
public static bool StartsWithIgnoreCase(ReadOnlySpan`1<char> value, ReadOnlySpan`1<char> other);
    [ExtensionAttribute]
public static bool EndsWithIgnoreCase(ReadOnlySpan`1<char> value, ReadOnlySpan`1<char> other);
    [ExtensionAttribute]
public static Task WriteAsync(Stream stream, ReadOnlySpan`1<char> value, CancellationToken token);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> SafeSubstring(ReadOnlySpan`1<char> value, int startIndex);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> SafeSubstring(ReadOnlySpan`1<char> value, int startIndex, int length);
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder sb, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static Byte[] ParseBase64(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> ToUtf8(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> FromUtf8(ReadOnlySpan`1<byte> value);
    [ExtensionAttribute]
public static Byte[] ToUtf8Bytes(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static string FromUtf8Bytes(ReadOnlySpan`1<byte> value);
    [ExtensionAttribute]
public static List`1<string> ToStringList(IEnumerable`1<ReadOnlyMemory`1<char>> from);
    [ExtensionAttribute]
public static int CountOccurrencesOf(ReadOnlySpan`1<char> value, char needle);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> WithoutBom(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> WithoutBom(ReadOnlySpan`1<byte> value);
}
[ExtensionAttribute]
public static class ServiceStack.Text.StringTextExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use ConvertTo<T>")]
public static T To(string value);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ConvertTo<T>")]
public static T To(string value, T defaultValue);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ConvertTo<T>")]
public static T ToOrDefaultValue(string value);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ConvertTo<T>")]
public static object To(string value, Type type);
}
public static class ServiceStack.Text.StringWriterCache : object {
    [ThreadStaticAttribute]
private static StringWriter cache;
    public static StringWriter Allocate();
    public static void Free(StringWriter writer);
    public static string ReturnAndFree(StringWriter writer);
}
public static class ServiceStack.Text.StringWriterCacheAlt : object {
    [ThreadStaticAttribute]
private static StringWriter cache;
    public static StringWriter Allocate();
    public static void Free(StringWriter writer);
    public static string ReturnAndFree(StringWriter writer);
}
internal static class ServiceStack.Text.StringWriterThreadStatic : object {
    [ThreadStaticAttribute]
private static StringWriter cache;
    public static StringWriter Allocate();
    public static void Free(StringWriter writer);
    public static string ReturnAndFree(StringWriter writer);
}
public class ServiceStack.Text.Support.DoubleConverter : object {
    public static string ToExactString(double d);
}
public class ServiceStack.Text.Support.TimeSpanConverter : object {
    private static string MinSerializedValue;
    private static string MaxSerializedValue;
    public static string ToXsdDuration(TimeSpan timeSpan);
    public static TimeSpan FromXsdDuration(string xsdDuration);
}
public class ServiceStack.Text.Support.TypePair : object {
    [CompilerGeneratedAttribute]
private Type[] <Args1>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <Arg2>k__BackingField;
    public Type[] Args1 { get; public set; }
    public Type[] Arg2 { get; public set; }
    public TypePair(Type[] arg1, Type[] arg2);
    [CompilerGeneratedAttribute]
public Type[] get_Args1();
    [CompilerGeneratedAttribute]
public void set_Args1(Type[] value);
    [CompilerGeneratedAttribute]
public Type[] get_Arg2();
    [CompilerGeneratedAttribute]
public void set_Arg2(Type[] value);
    public bool Equals(TypePair other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class ServiceStack.Text.SystemTime : object {
    public static Func`1<DateTime> UtcDateTimeResolver;
    public static DateTime Now { get; }
    public static DateTime UtcNow { get; }
    public static DateTime get_Now();
    public static DateTime get_UtcNow();
}
public enum ServiceStack.Text.TextCase : Enum {
    public int value__;
    public static TextCase Default;
    public static TextCase PascalCase;
    public static TextCase CamelCase;
    public static TextCase SnakeCase;
}
public enum ServiceStack.Text.TimeSpanHandler : Enum {
    public int value__;
    public static TimeSpanHandler DurationFormat;
    public static TimeSpanHandler StandardFormat;
}
public class ServiceStack.Text.Tracer : object {
    public static ITracer Instance;
    private static Tracer();
}
[ExtensionAttribute]
public static class ServiceStack.Text.TracerExceptions : object {
    [ExtensionAttribute]
public static T Trace(T ex);
}
public class ServiceStack.Text.TranslateListWithConvertibleElements`2 : object {
    private static Func`2<TFrom, TTo> ConvertFn;
    private static TranslateListWithConvertibleElements`2();
    public static object LateBoundTranslateToGenericICollection(object fromList, Type toInstanceOfType);
    public static ICollection`1<TTo> TranslateToGenericICollection(ICollection`1<TFrom> fromList, Type toInstanceOfType);
    private static Func`2<TFrom, TTo> GetConvertFn();
}
public static class ServiceStack.Text.TranslateListWithElements : object {
    private static Dictionary`2<Type, ConvertInstanceDelegate> TranslateICollectionCache;
    private static Dictionary`2<ConvertibleTypeKey, ConvertInstanceDelegate> TranslateConvertibleICollectionCache;
    private static TranslateListWithElements();
    public static object TranslateToGenericICollectionCache(object from, Type toInstanceOfType, Type elementType);
    public static object TranslateToConvertibleGenericICollectionCache(object from, Type toInstanceOfType, Type fromElementType);
    public static object TryTranslateCollections(Type fromPropertyType, Type toPropertyType, object fromValue);
}
public class ServiceStack.Text.TranslateListWithElements`1 : object {
    public static object CreateInstance(Type toInstanceOfType);
    public static IList TranslateToIList(IList fromList, Type toInstanceOfType);
    public static object LateBoundTranslateToGenericICollection(object fromList, Type toInstanceOfType);
    public static ICollection`1<T> TranslateToGenericICollection(IEnumerable fromList, Type toInstanceOfType);
}
internal class ServiceStack.Text.TypeConfig : object {
    internal Type Type;
    internal bool EnableAnonymousFieldSetters;
    internal PropertyInfo[] Properties;
    internal FieldInfo[] Fields;
    internal Func`4<object, string, object, object> OnDeserializing;
    [CompilerGeneratedAttribute]
private bool <IsUserType>k__BackingField;
    internal bool IsUserType { get; internal set; }
    internal TypeConfig(Type type);
    [CompilerGeneratedAttribute]
internal bool get_IsUserType();
    [CompilerGeneratedAttribute]
internal void set_IsUserType(bool value);
}
public static class ServiceStack.Text.TypeConfig`1 : object {
    internal static TypeConfig config;
    private static TypeConfig Config { get; }
    public static PropertyInfo[] Properties { get; public set; }
    public static FieldInfo[] Fields { get; public set; }
    public static bool EnableAnonymousFieldSetters { get; public set; }
    public static bool IsUserType { get; public set; }
    public static Func`4<object, string, object, object> OnDeserializing { get; public set; }
    private static TypeConfig`1();
    private static TypeConfig get_Config();
    public static PropertyInfo[] get_Properties();
    public static void set_Properties(PropertyInfo[] value);
    public static FieldInfo[] get_Fields();
    public static void set_Fields(FieldInfo[] value);
    public static bool get_EnableAnonymousFieldSetters();
    public static void set_EnableAnonymousFieldSetters(bool value);
    public static bool get_IsUserType();
    public static void set_IsUserType(bool value);
    internal static void Init();
    public static Func`4<object, string, object, object> get_OnDeserializing();
    public static void set_OnDeserializing(Func`4<object, string, object, object> value);
    private static TypeConfig Create();
    public static void Reset();
    internal static TypeConfig GetState();
}
[ExtensionAttribute]
public static class ServiceStack.Text.TypeSerializer : object {
    [CompilerGeneratedAttribute]
private static Action`1<object> <OnSerialize>k__BackingField;
    public static string DoubleQuoteString;
    private static string Indent;
    [ObsoleteAttribute("Use JsConfig.UTF8Encoding")]
public static UTF8Encoding UTF8Encoding { get; public set; }
    public static Action`1<object> OnSerialize { get; public set; }
    private static TypeSerializer();
    public static UTF8Encoding get_UTF8Encoding();
    public static void set_UTF8Encoding(UTF8Encoding value);
    [CompilerGeneratedAttribute]
public static Action`1<object> get_OnSerialize();
    [CompilerGeneratedAttribute]
public static void set_OnSerialize(Action`1<object> value);
    public static bool CanCreateFromString(Type type);
    public static T DeserializeFromString(string value);
    public static T DeserializeFromSpan(ReadOnlySpan`1<char> value);
    public static T DeserializeFromReader(TextReader reader);
    public static object DeserializeFromString(string value, Type type);
    public static object DeserializeFromSpan(Type type, ReadOnlySpan`1<char> value);
    public static object DeserializeFromReader(TextReader reader, Type type);
    public static string SerializeToString(T value);
    public static string SerializeToString(object value, Type type);
    public static void SerializeToWriter(T value, TextWriter writer);
    public static void SerializeToWriter(object value, Type type, TextWriter writer);
    public static void SerializeToStream(T value, Stream stream);
    public static void SerializeToStream(object value, Type type, Stream stream);
    public static T Clone(T value);
    public static T DeserializeFromStream(Stream stream);
    public static object DeserializeFromStream(Type type, Stream stream);
    public static Task`1<object> DeserializeFromStreamAsync(Type type, Stream stream);
    [AsyncStateMachineAttribute("ServiceStack.Text.TypeSerializer/<DeserializeFromStreamAsync>d__26`1")]
public static Task`1<T> DeserializeFromStreamAsync(Stream stream);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToStringDictionary(object obj);
    [ExtensionAttribute]
public static string Dump(T instance);
    [ExtensionAttribute]
public static void PrintDump(T instance);
    [ExtensionAttribute]
public static void Print(string text, Object[] args);
    [ExtensionAttribute]
public static void Print(int intValue);
    [ExtensionAttribute]
public static void Print(long longValue);
    [ExtensionAttribute]
public static string SerializeAndFormat(T instance);
    [ExtensionAttribute]
public static string Dump(Delegate fn);
    public static bool HasCircularReferences(object value);
    private static bool HasCircularReferences(object value, Stack`1<object> parentValues);
    private static void times(int count, Action fn);
    [ExtensionAttribute]
public static string IndentJson(string json);
    [CompilerGeneratedAttribute]
internal static bool <HasCircularReferences>g__CheckValue|36_0(object key, <>c__DisplayClass36_0& );
}
public class ServiceStack.Text.TypeSerializer`1 : object {
    public sealed virtual bool CanCreateFromString(Type type);
    public sealed virtual T DeserializeFromString(string value);
    public sealed virtual T DeserializeFromReader(TextReader reader);
    public sealed virtual string SerializeToString(T value);
    public sealed virtual void SerializeToWriter(T value, TextWriter writer);
}
internal static class ServiceStack.Text.UnsignedInteger`1 : object {
    private static TypeCode typeCode;
    private static ulong maxValue;
    private static UnsignedInteger`1();
    internal static object ParseNullableObject(ReadOnlySpan`1<char> value);
    internal static object ParseObject(ReadOnlySpan`1<char> value);
    public static byte ParseByte(ReadOnlySpan`1<char> value);
    public static ushort ParseUInt16(ReadOnlySpan`1<char> value);
    public static UInt32 ParseUInt32(ReadOnlySpan`1<char> value);
    internal static ulong ParseUInt64(ReadOnlySpan`1<char> value);
}
public class ServiceStack.Text.XmlSerializer : object {
    public static XmlWriterSettings XmlWriterSettings;
    public static XmlReaderSettings XmlReaderSettings;
    public static XmlSerializer Instance;
    public XmlSerializer(bool omitXmlDeclaration, int maxCharsInDocument);
    private static XmlSerializer();
    private static object Deserialize(string xml, Type type);
    public static object DeserializeFromString(string xml, Type type);
    public static T DeserializeFromString(string xml);
    public static T DeserializeFromReader(TextReader reader);
    public static T DeserializeFromStream(Stream stream);
    public static object DeserializeFromStream(Type type, Stream stream);
    public static string SerializeToString(T from);
    public static void SerializeToWriter(T value, TextWriter writer);
    public static void SerializeToStream(object obj, Stream stream);
}
[ExtensionAttribute]
public static class ServiceStack.TextExtensions : object {
    [ExtensionAttribute]
public static string ToCsvField(string text);
    [ExtensionAttribute]
public static object ToCsvField(object text);
    [ExtensionAttribute]
public static string FromCsvField(string text);
    [ExtensionAttribute]
public static List`1<string> FromCsvFields(IEnumerable`1<string> texts);
    public static String[] FromCsvFields(String[] texts);
    [ExtensionAttribute]
public static string SerializeToString(T value);
}
[ExtensionAttribute]
public static class ServiceStack.TypeConstants : object {
    public static Task`1<int> ZeroTask;
    public static Task`1<bool> TrueTask;
    public static Task`1<bool> FalseTask;
    public static Task`1<object> EmptyTask;
    public static object EmptyObject;
    public static char NonWidthWhiteSpace;
    public static Char[] NonWidthWhiteSpaceChars;
    public static String[] EmptyStringArray;
    public static Int64[] EmptyLongArray;
    public static Int32[] EmptyIntArray;
    public static Char[] EmptyCharArray;
    public static Boolean[] EmptyBoolArray;
    public static Byte[] EmptyByteArray;
    public static Object[] EmptyObjectArray;
    public static Type[] EmptyTypeArray;
    public static FieldInfo[] EmptyFieldInfoArray;
    public static PropertyInfo[] EmptyPropertyInfoArray;
    public static Byte[][] EmptyByteArrayArray;
    public static Dictionary`2<string, string> EmptyStringDictionary;
    public static Dictionary`2<string, object> EmptyObjectDictionary;
    public static List`1<string> EmptyStringList;
    public static List`1<long> EmptyLongList;
    public static List`1<int> EmptyIntList;
    public static List`1<char> EmptyCharList;
    public static List`1<bool> EmptyBoolList;
    public static List`1<byte> EmptyByteList;
    public static List`1<object> EmptyObjectList;
    public static List`1<Type> EmptyTypeList;
    public static List`1<FieldInfo> EmptyFieldInfoList;
    public static List`1<PropertyInfo> EmptyPropertyInfoList;
    public static ReadOnlySpan`1<char> NullStringSpan { get; }
    public static ReadOnlySpan`1<char> EmptyStringSpan { get; }
    public static ReadOnlyMemory`1<char> NullStringMemory { get; }
    public static ReadOnlyMemory`1<char> EmptyStringMemory { get; }
    private static TypeConstants();
    [ExtensionAttribute]
private static Task`1<T> InTask(T result);
    public static ReadOnlySpan`1<char> get_NullStringSpan();
    public static ReadOnlySpan`1<char> get_EmptyStringSpan();
    public static ReadOnlyMemory`1<char> get_NullStringMemory();
    public static ReadOnlyMemory`1<char> get_EmptyStringMemory();
}
public static class ServiceStack.TypeConstants`1 : object {
    public static T[] EmptyArray;
    public static List`1<T> EmptyList;
    public static HashSet`1<T> EmptyHashSet;
    private static TypeConstants`1();
}
internal static class ServiceStack.TypeConverter : object {
    public static GetMemberDelegate CreateTypeConverter(Type fromType, Type toType);
}
public abstract class ServiceStack.TypeFields : object {
    private static Dictionary`2<Type, TypeFields> CacheMap;
    public static Type FactoryType;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Dictionary`2<string, FieldAccessor> FieldsMap;
    [CompilerGeneratedAttribute]
private FieldInfo[] <PublicFieldInfos>k__BackingField;
    public Type Type { get; protected set; }
    public FieldInfo[] PublicFieldInfos { get; protected set; }
    private static TypeFields();
    public static TypeFields Get(Type type);
    public FieldAccessor GetAccessor(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(Type value);
    [CompilerGeneratedAttribute]
public FieldInfo[] get_PublicFieldInfos();
    [CompilerGeneratedAttribute]
protected void set_PublicFieldInfos(FieldInfo[] value);
    public virtual FieldInfo GetPublicField(string name);
    public virtual GetMemberDelegate GetPublicGetter(FieldInfo fi);
    public virtual GetMemberDelegate GetPublicGetter(string name);
    public virtual SetMemberDelegate GetPublicSetter(FieldInfo fi);
    public virtual SetMemberDelegate GetPublicSetter(string name);
    public virtual SetMemberRefDelegate GetPublicSetterRef(string name);
}
public class ServiceStack.TypeFields`1 : TypeFields {
    public static TypeFields`1<T> Instance;
    private static TypeFields`1();
    public static FieldAccessor GetAccessor(string propertyName);
}
public abstract class ServiceStack.TypeProperties : object {
    private static Dictionary`2<Type, TypeProperties> CacheMap;
    public static Type FactoryType;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Dictionary`2<string, PropertyAccessor> PropertyMap;
    [CompilerGeneratedAttribute]
private PropertyInfo[] <PublicPropertyInfos>k__BackingField;
    public Type Type { get; protected set; }
    public PropertyInfo[] PublicPropertyInfos { get; protected set; }
    private static TypeProperties();
    public static TypeProperties Get(Type type);
    public PropertyAccessor GetAccessor(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(Type value);
    [CompilerGeneratedAttribute]
public PropertyInfo[] get_PublicPropertyInfos();
    [CompilerGeneratedAttribute]
protected void set_PublicPropertyInfos(PropertyInfo[] value);
    public PropertyInfo GetPublicProperty(string name);
    public GetMemberDelegate GetPublicGetter(PropertyInfo pi);
    public GetMemberDelegate GetPublicGetter(string name);
    public SetMemberDelegate GetPublicSetter(PropertyInfo pi);
    public SetMemberDelegate GetPublicSetter(string name);
}
public class ServiceStack.TypeProperties`1 : TypeProperties {
    public static TypeProperties`1<T> Instance;
    private static TypeProperties`1();
    public static PropertyAccessor GetAccessor(string propertyName);
}
public class ServiceStack.WriteComplexTypeDelegate : MulticastDelegate {
    public WriteComplexTypeDelegate(object object, IntPtr method);
    public virtual bool Invoke(TextWriter writer, string propertyName, object obj);
    public virtual IAsyncResult BeginInvoke(TextWriter writer, string propertyName, object obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
