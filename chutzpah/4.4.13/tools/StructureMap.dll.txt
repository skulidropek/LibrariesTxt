[AttributeUsageAttribute("1028")]
public class StructureMap.AlwaysUniqueAttribute : StructureMapAttribute {
    public virtual void Alter(PluginFamily family);
    public virtual void Alter(IConfiguredInstance instance);
}
[DebuggerStepThroughAttribute]
internal static class StructureMap.ArgumentChecker : object {
    public static void ThrowIfNull(string argumentName, object value);
    public static void ThrowIfNullOrEmptyString(string argumentName, string value);
}
[AttributeUsageAttribute("128")]
public class StructureMap.Attributes.SetterPropertyAttribute : Attribute {
}
internal class StructureMap.AutoMocking.ArrayBuilder`1 : object {
    private IContainer _container;
    public ArrayBuilder`1(IContainer container);
    public sealed virtual object ToEnumerable();
}
public class StructureMap.AutoMocking.AutoMockedContainer : Container {
    private ServiceLocator _locator;
    private bool StructureMap.Graph.IFamilyPolicy.AppliesToHasFamilyChecks { get; }
    public AutoMockedContainer(ServiceLocator locator);
    private void nameContainer(IContainer container);
    private sealed virtual override PluginFamily StructureMap.Graph.IFamilyPolicy.Build(Type pluginType);
    private sealed virtual override bool StructureMap.Graph.IFamilyPolicy.get_AppliesToHasFamilyChecks();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(ConfigurationExpression x);
}
public class StructureMap.AutoMocking.AutoMocker`1 : object {
    private TTargetClass _classUnderTest;
    [CompilerGeneratedAttribute]
private ServiceLocator <ServiceLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private AutoMockedContainer <Container>k__BackingField;
    protected ServiceLocator ServiceLocator { get; protected set; }
    public AutoMockedContainer Container { get; protected set; }
    public TTargetClass ClassUnderTest { get; }
    public AutoMocker`1(ServiceLocator serviceLocator);
    [CompilerGeneratedAttribute]
protected ServiceLocator get_ServiceLocator();
    [CompilerGeneratedAttribute]
protected void set_ServiceLocator(ServiceLocator value);
    public sealed virtual void UseMockForType();
    [CompilerGeneratedAttribute]
public sealed virtual AutoMockedContainer get_Container();
    [CompilerGeneratedAttribute]
protected void set_Container(AutoMockedContainer value);
    public sealed virtual TTargetClass get_ClassUnderTest();
    public sealed virtual void PartialMockTheClassUnderTest();
    public sealed virtual T Get();
    public sealed virtual void Inject(Type pluginType, object stub);
    public sealed virtual void Inject(T target);
    public sealed virtual T AddAdditionalMockFor();
    public sealed virtual void UseConcreteClassFor();
    public sealed virtual T[] CreateMockArrayFor(int count);
    public sealed virtual void InjectArray(T[] stubs);
    private Object[] getConstructorArgs();
}
internal class StructureMap.AutoMocking.EnumerableBuilder`1 : object {
    private IContainer _container;
    public EnumerableBuilder`1(IContainer container);
    public sealed virtual object ToEnumerable();
}
public interface StructureMap.AutoMocking.IAutoMocker`1 {
    public TTargetClass ClassUnderTest { get; }
    public AutoMockedContainer Container { get; }
    public abstract virtual TTargetClass get_ClassUnderTest();
    public abstract virtual void UseMockForType();
    public abstract virtual AutoMockedContainer get_Container();
    public abstract virtual void PartialMockTheClassUnderTest();
    public abstract virtual T Get();
    public abstract virtual void Inject(Type pluginType, object stub);
    public abstract virtual void Inject(T target);
    public abstract virtual T AddAdditionalMockFor();
    public abstract virtual void UseConcreteClassFor();
    public abstract virtual T[] CreateMockArrayFor(int count);
    public abstract virtual void InjectArray(T[] stubs);
}
internal interface StructureMap.AutoMocking.IEnumerableBuilder {
    public abstract virtual object ToEnumerable();
}
public interface StructureMap.AutoMocking.ServiceLocator {
    public abstract virtual T Service();
    public abstract virtual object Service(Type serviceType);
    public abstract virtual T PartialMock(Object[] args);
}
[ExtensionAttribute]
internal static class StructureMap.BasicExtensions : object {
    [ExtensionAttribute]
public static TReturn FirstValue(IEnumerable`1<TItem> enumerable, Func`2<TItem, TReturn> func);
    [ExtensionAttribute]
public static string ToName(ILifecycle lifecycle);
    [ExtensionAttribute]
public static void Fill(IList`1<T> list, T value);
    [ExtensionAttribute]
public static void SafeDispose(object target);
    [ExtensionAttribute]
public static void TryGet(IDictionary`2<TKey, TValue> dictionary, TKey key, Action`1<TValue> action);
    [ExtensionAttribute]
internal static T As(object target);
    [ExtensionAttribute]
public static bool IsIn(T target, IList`1<T> list);
}
public class StructureMap.Building.AllPossibleValuesDependencySource : object {
    public static MethodInfo ContextMethod;
    public static MethodInfo ToArrayMethod;
    private Type _enumerationType;
    private Type _elementType;
    public string Description { get; }
    public Type ReturnedType { get; }
    public Type ElementType { get; }
    public AllPossibleValuesDependencySource(Type enumerationType);
    private static AllPossibleValuesDependencySource();
    public sealed virtual string get_Description();
    public sealed virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    public sealed virtual Type get_ReturnedType();
    public sealed virtual void AcceptVisitor(IDependencyVisitor visitor);
    public Type get_ElementType();
    protected bool Equals(AllPossibleValuesDependencySource other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class StructureMap.Building.ArrayDependencySource : object {
    private Type _itemType;
    private List`1<IDependencySource> _items;
    public Type ItemType { get; }
    public IEnumerable`1<IDependencySource> Items { get; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public ArrayDependencySource(Type itemType, IDependencySource[] items);
    public sealed virtual Type get_ItemType();
    public void Add(IDependencySource item);
    public sealed virtual IEnumerable`1<IDependencySource> get_Items();
    public virtual string get_Description();
    public virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    public sealed virtual Type get_ReturnedType();
    public sealed virtual void AcceptVisitor(IDependencyVisitor visitor);
}
public class StructureMap.Building.BuildPlan : object {
    private IInterceptionPlan _interceptionPlan;
    private Func`3<IBuildSession, IContext, object> _func;
    [CompilerGeneratedAttribute]
private Type <PluginType>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private IDependencySource <Inner>k__BackingField;
    public Type PluginType { get; }
    public Instance Instance { get; }
    public IDependencySource Inner { get; }
    public IInterceptionPlan InterceptionPlan { get; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public BuildPlan(Type pluginType, Instance instance, IDependencySource inner, Policies policies, IEnumerable`1<IInterceptor> interceptors);
    public BuildPlan(Type pluginType, Instance instance, IDependencySource inner, IInterceptionPlan interceptionPlan);
    [CompilerGeneratedAttribute]
public Type get_PluginType();
    [CompilerGeneratedAttribute]
public Instance get_Instance();
    [CompilerGeneratedAttribute]
public IDependencySource get_Inner();
    public IInterceptionPlan get_InterceptionPlan();
    public sealed virtual void AcceptVisitor(IBuildPlanVisitor visitor);
    public Delegate ToDelegate();
    public sealed virtual string get_Description();
    public sealed virtual object Build(IBuildSession session, IContext context);
    public sealed virtual Type get_ReturnedType();
}
public class StructureMap.Building.BuildUpPlan : object {
    private Type _concreteType;
    private IList`1<Setter> _setters;
    private Lazy`1<ISetterActions> _buildups;
    public Type ConcreteType { get; }
    public IEnumerable`1<Setter> Setters { get; }
    public BuildUpPlan(Type concreteType);
    public sealed virtual Type get_ConcreteType();
    private void resetBuildups();
    public IEnumerable`1<Setter> get_Setters();
    public sealed virtual void Add(Setter setter);
    public sealed virtual void Add(Type setterType, MemberInfo member, IDependencySource value);
    public void BuildUp(IBuildSession session, IContext context, object object);
    [CompilerGeneratedAttribute]
private ISetterActions <resetBuildups>b__6_0();
}
public class StructureMap.Building.BuildUpPlan`1 : BuildUpPlan {
    public void Set(Expression`1<Func`2<T, TValue>> expression, TValue value);
    public void Set(Expression`1<Func`2<T, object>> expression, IDependencySource step);
}
public class StructureMap.Building.ConcreteBuild : object {
    private IList`1<Setter> _setters;
    [CompilerGeneratedAttribute]
private Type <ConcreteType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorStep <Constructor>k__BackingField;
    public Type ConcreteType { get; }
    public ConstructorStep Constructor { get; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public ConcreteBuild(Type concreteType);
    public ConcreteBuild(Type concreteType, ConstructorStep constructor);
    protected ConcreteBuild(Type concreteType, ConstructorInfo constructor);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ConcreteType();
    public sealed virtual void Add(Setter setter);
    public sealed virtual void Add(Type setterType, MemberInfo member, IDependencySource value);
    [CompilerGeneratedAttribute]
public ConstructorStep get_Constructor();
    public object Build(IBuildSession session, IContext context);
    public T Build(IBuildSession session);
    public sealed virtual string get_Description();
    public Delegate ToDelegate();
    public sealed virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    private Expression buildInnerExpression(ParameterExpression session, ParameterExpression context);
    public sealed virtual Type get_ReturnedType();
    public sealed virtual void AcceptVisitor(IDependencyVisitor visitor);
    public bool IsValid();
    public sealed virtual void AcceptVisitor(IBuildPlanVisitor visitor);
}
public class StructureMap.Building.ConcreteBuild`1 : ConcreteBuild {
    public ConcreteBuild`1(ConstructorInfo constructor);
    public static ConcreteBuild`1<T> For(Expression`1<Func`1<T>> expression);
    public void Set(Expression`1<Func`2<T, TValue>> expression, TValue value);
    public void Set(Expression`1<Func`2<T, object>> expression, IDependencySource step);
    public ConcreteBuild`1<T> ConstructorArgs(Object[] args);
    [CompilerGeneratedAttribute]
private void <ConstructorArgs>b__5_0(object a);
}
public static class StructureMap.Building.ConcreteType : object {
    public static string ConstructorArgument;
    public static string SetterProperty;
    public static string MissingPrimitiveWarning;
    public static string CastingError;
    public static string UnableToDetermineDependency;
    public static ConcreteBuild BuildSource(Type pluggedType, ConstructorInfo constructor, DependencyCollection dependencies, Policies policies);
    public static BuildUpPlan BuildUpPlan(Type pluggedType, DependencyCollection dependencies, Policies policies);
    private static void determineSetterSources(Type pluggedType, DependencyCollection dependencies, Policies policies, IHasSetters plan);
    public static PropertyInfo[] GetSetters(Type pluggedType);
    private static void determineSetterSource(DependencyCollection dependencies, Policies policies, PropertyInfo setter, IHasSetters plan);
    public static ConstructorStep BuildConstructorStep(Type pluggedType, ConstructorInfo constructor, DependencyCollection dependencies, Policies policies);
    private static Type[] findTypesWithMultipleParametersRequired(ConstructorInfo ctor);
    public static IDependencySource SourceFor(Policies policies, string ctorOrSetter, string name, Type dependencyType, object value);
    public static object ConvertType(object value, Type dependencyType);
}
public class StructureMap.Building.Constant : object {
    private Type _argumentType;
    private object _value;
    public Type ReturnedType { get; }
    public object Value { get; }
    public string Description { get; }
    public Constant(Type argumentType, object value);
    public static Constant ForObject(object o);
    public static Constant For(T value);
    public sealed virtual Type get_ReturnedType();
    public sealed virtual void AcceptVisitor(IDependencyVisitor visitor);
    public object get_Value();
    public sealed virtual string get_Description();
    public sealed virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    protected bool Equals(Constant other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class StructureMap.Building.ConstructorStep : object {
    private ConstructorInfo _constructor;
    private List`1<CtorArgument> _arguments;
    public IEnumerable`1<CtorArgument> Arguments { get; }
    public ConstructorInfo Constructor { get; }
    public string Description { get; }
    public ConstructorStep(ConstructorInfo constructor);
    public void Add(IDependencySource dependency);
    public IEnumerable`1<CtorArgument> get_Arguments();
    public ConstructorInfo get_Constructor();
    public string get_Description();
    public static string ToDescription(ConstructorInfo constructor);
    public NewExpression ToExpression(ParameterExpression session, ParameterExpression context);
    public void Add(IEnumerable`1<IDependencySource> dependencies);
}
public class StructureMap.Building.CtorArgument : object {
    public ParameterInfo Parameter;
    public IDependencySource Dependency;
    public string Title { get; }
    public string get_Title();
    public string Fullname();
    public string ShortName();
    public string Description();
    public virtual string ToString();
}
public class StructureMap.Building.DefaultDependencySource : object {
    private Type _dependencyType;
    public static MethodInfo ContextMethod;
    public Type DependencyType { get; }
    public Type ReturnedType { get; }
    public string Description { get; }
    public DefaultDependencySource(Type dependencyType);
    private static DefaultDependencySource();
    public Type get_DependencyType();
    public sealed virtual Type get_ReturnedType();
    public sealed virtual void AcceptVisitor(IDependencyVisitor visitor);
    public sealed virtual string get_Description();
    public sealed virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
}
[ExtensionAttribute]
public static class StructureMap.Building.DelegateExtensions : object {
    [ExtensionAttribute]
public static Func`3<IBuildSession, IContext, T> BuilderOf(Delegate delegate);
    [ExtensionAttribute]
public static T Build(IBuildPlan plan, IBuildSession session);
    [ExtensionAttribute]
public static LambdaExpression ReplaceParameter(LambdaExpression expression, Type acceptsType, ParameterExpression newParam);
}
public class StructureMap.Building.DependencyProblem : object {
    public string Name;
    public string Message;
    public string Type;
    [CompilerGeneratedAttribute]
private Type <ReturnedType>k__BackingField;
    public string Description { get; }
    public Type ReturnedType { get; public set; }
    public sealed virtual string get_Description();
    public sealed virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ReturnedType();
    [CompilerGeneratedAttribute]
public void set_ReturnedType(Type value);
    public sealed virtual void AcceptVisitor(IDependencyVisitor visitor);
}
public interface StructureMap.Building.IBuildPlan {
    public Type ReturnedType { get; }
    public abstract virtual object Build(IBuildSession session, IContext context);
    public abstract virtual Type get_ReturnedType();
}
public interface StructureMap.Building.IBuildPlanVisitable {
    public abstract virtual void AcceptVisitor(IBuildPlanVisitor visitor);
}
public interface StructureMap.Building.IDependencySource {
    public Type ReturnedType { get; }
    public abstract virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    public abstract virtual Type get_ReturnedType();
    public abstract virtual void AcceptVisitor(IDependencyVisitor visitor);
}
public interface StructureMap.Building.IDescribed {
    public string Description { get; }
    public abstract virtual string get_Description();
}
public interface StructureMap.Building.IEnumerableDependencySource {
    public Type ItemType { get; }
    public IEnumerable`1<IDependencySource> Items { get; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public abstract virtual Type get_ItemType();
    public abstract virtual IEnumerable`1<IDependencySource> get_Items();
    public abstract virtual string get_Description();
    public abstract virtual Type get_ReturnedType();
}
public interface StructureMap.Building.IHasSetters {
    public Type ConcreteType { get; }
    public abstract virtual Type get_ConcreteType();
    public abstract virtual void Add(Setter setter);
    public abstract virtual void Add(Type setterType, MemberInfo member, IDependencySource value);
}
public class StructureMap.Building.Interception.ActivatorInterceptor`1 : object {
    private LambdaExpression _action;
    private string _description;
    public string Description { get; }
    public InterceptorRole Role { get; }
    public Type Accepts { get; }
    public Type Returns { get; }
    public ActivatorInterceptor`1(Expression`1<Action`1<T>> action, string description);
    public ActivatorInterceptor`1(Expression`1<Action`2<IContext, T>> action, string description);
    public IInterceptorPolicy ToPolicy();
    public sealed virtual string get_Description();
    public sealed virtual InterceptorRole get_Role();
    public sealed virtual Expression ToExpression(Policies policies, ParameterExpression context, ParameterExpression variable);
    public sealed virtual Type get_Accepts();
    public sealed virtual Type get_Returns();
    protected bool Equals(ActivatorInterceptor`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class StructureMap.Building.Interception.BlockPlan : object {
    private List`1<Expression> _expressions;
    private List`1<ParameterExpression> _variables;
    public IEnumerable`1<ParameterExpression> Variables { get; }
    public static BlockPlan op_Addition(BlockPlan plan, Expression expression);
    public void Add(Expression[] expressions);
    public BlockExpression ToExpression();
    public void AddVariable(ParameterExpression variable);
    public void AddVariables(IEnumerable`1<ParameterExpression> variables);
    public IEnumerable`1<ParameterExpression> get_Variables();
    public ParameterExpression FindVariableOfType(Type type);
}
public class StructureMap.Building.Interception.DecoratorInterceptor : object {
    private Type _pluginType;
    private bool _hasAppliedPolicies;
    [CompilerGeneratedAttribute]
private IConfiguredInstance <Instance>k__BackingField;
    public string Description { get; }
    public IConfiguredInstance Instance { get; }
    public InterceptorRole Role { get; }
    public Type Accepts { get; }
    public Type Returns { get; }
    public DecoratorInterceptor(Type pluginType, IConfiguredInstance instance);
    public DecoratorInterceptor(Type pluginType, Type pluggedType);
    public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public IConfiguredInstance get_Instance();
    public sealed virtual InterceptorRole get_Role();
    public sealed virtual Expression ToExpression(Policies policies, ParameterExpression session, ParameterExpression variable);
    public ConcreteBuild ToConcreteBuild(Policies policies, ParameterExpression variable);
    public sealed virtual Type get_Accepts();
    public sealed virtual Type get_Returns();
}
public class StructureMap.Building.Interception.DecoratorPolicy : object {
    private Type _pluginType;
    private ConfiguredInstance _instance;
    private Func`2<Instance, bool> _filter;
    public string Description { get; }
    public DecoratorPolicy(Type pluginType, Type pluggedType, Func`2<Instance, bool> filter);
    public DecoratorPolicy(Type pluginType, ConfiguredInstance instance, Func`2<Instance, bool> filter);
    public sealed virtual string get_Description();
    [IteratorStateMachineAttribute("StructureMap.Building.Interception.DecoratorPolicy/<DetermineInterceptors>d__7")]
public sealed virtual IEnumerable`1<IInterceptor> DetermineInterceptors(Type pluginType, Instance instance);
}
public class StructureMap.Building.Interception.FuncInterceptor`1 : object {
    private LambdaExpression _expression;
    private string _description;
    public string Description { get; }
    public InterceptorRole Role { get; }
    public Type Accepts { get; }
    public Type Returns { get; }
    public FuncInterceptor`1(Expression`1<Func`2<T, T>> expression, string description);
    public FuncInterceptor`1(Expression`1<Func`3<IContext, T, T>> expression, string description);
    public virtual string get_Description();
    public sealed virtual InterceptorRole get_Role();
    public sealed virtual Expression ToExpression(Policies policies, ParameterExpression context, ParameterExpression variable);
    public IInterceptorPolicy ToPolicy();
    public sealed virtual Type get_Accepts();
    public sealed virtual Type get_Returns();
    protected bool Equals(FuncInterceptor`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public interface StructureMap.Building.Interception.IInterceptionPlan {
}
public interface StructureMap.Building.Interception.IInterceptor {
    public InterceptorRole Role { get; }
    public Type Accepts { get; }
    public Type Returns { get; }
    public abstract virtual InterceptorRole get_Role();
    public abstract virtual Expression ToExpression(Policies policies, ParameterExpression session, ParameterExpression variable);
    public abstract virtual Type get_Accepts();
    public abstract virtual Type get_Returns();
}
public interface StructureMap.Building.Interception.IInterceptorPolicy {
    public abstract virtual IEnumerable`1<IInterceptor> DetermineInterceptors(Type pluginType, Instance instance);
}
public class StructureMap.Building.Interception.InterceptionPlan : object {
    private Policies _policies;
    private IEnumerable`1<IInterceptor> _interceptors;
    private ParameterExpression _variable;
    private IEnumerable`1<ActivatorGroup> _activators;
    private IEnumerable`1<IInterceptor> _decorators;
    [CompilerGeneratedAttribute]
private IDependencySource <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnedType>k__BackingField;
    public IDependencySource Inner { get; }
    public Type ReturnedType { get; }
    public string Description { get; }
    public InterceptionPlan(Type pluginType, IDependencySource inner, Policies policies, IEnumerable`1<IInterceptor> interceptors);
    [CompilerGeneratedAttribute]
public IDependencySource get_Inner();
    public Func`3<IBuildSession, IContext, T> ToBuilder();
    public sealed virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ReturnedType();
    private sealed virtual override void StructureMap.Building.IDependencySource.AcceptVisitor(IDependencyVisitor visitor);
    public sealed virtual void AcceptVisitor(IBuildPlanVisitor visitor);
    private void addDecorators(ParameterExpression context, ParameterExpression pluginTypeVariable, BlockPlan plan);
    private ParameterExpression addPluginTypeVariable(BlockPlan plan);
    private void createTheReturnValue(ParameterExpression variable, BlockPlan plan);
    private void addActivations(BlockPlan plan);
    private IEnumerable`1<ActivatorGroup> findActivatorGroups();
    public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private IEnumerable`1<ParameterExpression> <addActivations>b__19_0(ActivatorGroup x);
    [CompilerGeneratedAttribute]
private IEnumerable`1<Expression> <addActivations>b__19_1(ActivatorGroup x);
}
public static class StructureMap.Building.Interception.InterceptorFactory : object {
    public static IInterceptor ForAction(string description, Action`1<T> action);
    public static IInterceptor ForAction(string description, Action`2<IContext, T> action);
    public static IInterceptor ForFunc(string description, Func`2<T, T> func);
    public static IInterceptor ForFunc(string description, Func`3<IContext, T, T> func);
}
public class StructureMap.Building.Interception.InterceptorPolicy`1 : object {
    private IInterceptor _interceptor;
    private Func`2<Instance, bool> _filter;
    public Func`2<Instance, bool> Filter { get; public set; }
    public string Description { get; }
    public InterceptorPolicy`1(IInterceptor interceptor, Func`2<Instance, bool> filter);
    public Func`2<Instance, bool> get_Filter();
    public void set_Filter(Func`2<Instance, bool> value);
    public sealed virtual string get_Description();
    [IteratorStateMachineAttribute("StructureMap.Building.Interception.InterceptorPolicy`1/<DetermineInterceptors>d__8")]
public sealed virtual IEnumerable`1<IInterceptor> DetermineInterceptors(Type pluginType, Instance instance);
    protected bool Equals(InterceptorPolicy`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum StructureMap.Building.Interception.InterceptorRole : Enum {
    public int value__;
    public static InterceptorRole Activates;
    public static InterceptorRole Decorates;
}
public class StructureMap.Building.Interception.ParameterRewriter : ExpressionVisitor {
    private ParameterExpression _before;
    private ParameterExpression _after;
    public ParameterRewriter(ParameterExpression before, ParameterExpression after);
    public static LambdaExpression ReplaceParameter(Type acceptsType, LambdaExpression expression, ParameterExpression newParam);
    protected virtual Expression VisitParameter(ParameterExpression node);
}
public class StructureMap.Building.LifecycleDependencySource : object {
    public static MethodInfo SessionMethod;
    private Type _pluginType;
    private Instance _instance;
    public Type PluginType { get; }
    public Instance Instance { get; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public LifecycleDependencySource(Type pluginType, Instance instance);
    private static LifecycleDependencySource();
    public Type get_PluginType();
    public Instance get_Instance();
    public sealed virtual string get_Description();
    public sealed virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    public sealed virtual Type get_ReturnedType();
    public sealed virtual void AcceptVisitor(IDependencyVisitor visitor);
}
public class StructureMap.Building.ListDependencySource : ArrayDependencySource {
    public static MethodInfo ToListMethod;
    public string Description { get; }
    public ListDependencySource(Type itemType, IDependencySource[] items);
    private static ListDependencySource();
    public virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    public static Expression ToExpression(Type itemType, Expression arrayExpression);
    public virtual string get_Description();
}
public static class StructureMap.Building.Parameters : object {
    public static ParameterExpression Session;
    public static ParameterExpression Context;
    private static Parameters();
    public static Expression SessionToContext();
}
public static class StructureMap.Building.PushPopWrapper : object {
    public static MethodInfo PushMethod;
    public static MethodInfo PopMethod;
    private static PushPopWrapper();
    public static Expression WrapFunc(Type returnType, Instance instance, Expression inner);
}
public class StructureMap.Building.ReferencedDependencySource : object {
    private Type _dependencyType;
    private string _name;
    public static MethodInfo ContextMethod;
    public Type DependencyType { get; }
    public string Name { get; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public ReferencedDependencySource(Type dependencyType, string name);
    private static ReferencedDependencySource();
    public Type get_DependencyType();
    public string get_Name();
    public sealed virtual string get_Description();
    public sealed virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    public sealed virtual Type get_ReturnedType();
    public sealed virtual void AcceptVisitor(IDependencyVisitor visitor);
    public virtual string ToString();
    protected bool Equals(ReferencedDependencySource other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class StructureMap.Building.Setter : object {
    private Type _setterType;
    private MemberInfo _member;
    [CompilerGeneratedAttribute]
private IDependencySource <AssignedValue>k__BackingField;
    public IDependencySource AssignedValue { get; private set; }
    public Type SetterType { get; }
    public string Description { get; }
    public string Title { get; }
    public Setter(Type setterType, MemberInfo member, IDependencySource value);
    [CompilerGeneratedAttribute]
public IDependencySource get_AssignedValue();
    [CompilerGeneratedAttribute]
private void set_AssignedValue(IDependencySource value);
    public Type get_SetterType();
    public sealed virtual string get_Description();
    public string get_Title();
    public MemberBinding ToBinding(ParameterExpression session, ParameterExpression context);
    public LambdaExpression ToSetterLambda(Type concreteType, ParameterExpression target);
}
public class StructureMap.Building.StructureMapBuildException : StructureMapException {
    public StructureMapBuildException(string message, Exception innerException);
    public StructureMapBuildException(string message);
}
public class StructureMap.Building.StructureMapInterceptorException : StructureMapBuildException {
    public StructureMapInterceptorException(string message, Exception innerException);
    public StructureMapInterceptorException(string message);
}
public static class StructureMap.Building.TryCatchWrapper : object {
    public static ParameterExpression EX;
    public static MethodInfo DescriptionMethod;
    private static LightweightCache`2<Type, ConstructorInfo> _constructors;
    private static TryCatchWrapper();
    public static Expression WrapAction(string message, Expression expression, Expression`1<Func`1<string>> descriptionSource);
    public static Expression WrapFunc(string message, Type returnType, Expression expression, Expression`1<Func`1<string>> descriptionSource);
    public static Expression WrapAction(string message, Expression expression, IDescribed described);
    public static Expression WrapFunc(string message, Type returnType, Expression expression, IDescribed described);
    public static Expression WrapAction(string message, Expression expression, string descriptionString);
    public static Expression WrapFunc(string message, Type returnType, Expression expression, string descriptionString);
    private static Expression wrap(string message, Type returnType, Expression expression, Expression description);
}
public class StructureMap.BuildSession : object {
    public static string DEFAULT;
    private ISessionCache _sessionCache;
    private Stack`1<Instance> _instances;
    [CompilerGeneratedAttribute]
private IPipelineGraph <pipelineGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestedName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RootType>k__BackingField;
    protected IPipelineGraph pipelineGraph { get; }
    public string RequestedName { get; public set; }
    public Type ParentType { get; }
    public Type RootType { get; internal set; }
    public Policies Policies { get; }
    public BuildSession(IPipelineGraph pipelineGraph, string requestedName, ExplicitArguments args);
    private BuildSession(IPipelineGraph pipelineGraph, string requestedName, ExplicitArguments args, Stack`1<Instance> buildStack);
    private static BuildSession();
    [CompilerGeneratedAttribute]
protected IPipelineGraph get_pipelineGraph();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RequestedName();
    [CompilerGeneratedAttribute]
public void set_RequestedName(string value);
    public sealed virtual void BuildUp(object target);
    public sealed virtual T GetInstance();
    public sealed virtual object GetInstance(Type pluginType);
    public sealed virtual T GetInstance(string name);
    public sealed virtual object GetInstance(Type pluginType, string name);
    public sealed virtual T TryGetInstance();
    public sealed virtual T TryGetInstance(string name);
    public sealed virtual object TryGetInstance(Type pluginType);
    public sealed virtual object TryGetInstance(Type pluginType, string name);
    public sealed virtual IEnumerable`1<T> All();
    public sealed virtual object ResolveFromLifecycle(Type pluginType, Instance instance);
    public sealed virtual object BuildNewInSession(Type pluginType, Instance instance);
    public sealed virtual object BuildUnique(Type pluginType, Instance instance);
    public sealed virtual object BuildNewInOriginalContext(Type pluginType, Instance instance);
    public sealed virtual IEnumerable`1<T> GetAllInstances();
    public sealed virtual IEnumerable`1<object> GetAllInstances(Type pluginType);
    public static BuildSession ForPluginGraph(PluginGraph graph, ExplicitArguments args);
    public static BuildSession Empty(ExplicitArguments args);
    public virtual object CreateInstance(Type pluginType, string name);
    public sealed virtual void Push(Instance instance);
    public sealed virtual void Pop();
    public sealed virtual Type get_ParentType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_RootType();
    [CompilerGeneratedAttribute]
internal void set_RootType(Type value);
    public virtual object FindObject(Type pluginType, Instance instance);
    public object BuildWithExplicitArgs(Type pluginType, Instance instance);
    public sealed virtual Policies get_Policies();
    [CompilerGeneratedAttribute]
private T <GetAllInstances>b__26_0(Instance x);
}
public class StructureMap.CloseGenericTypeExpression : object {
    private IContainer _container;
    private object _subject;
    private Type _pluginType;
    public CloseGenericTypeExpression(object subject, IContainer container);
    private sealed virtual override IList`1<T> StructureMap.OpenGenericTypeListSpecificationExpression.As();
    private sealed virtual override T StructureMap.OpenGenericTypeSpecificationExpression.As();
    public OpenGenericTypeSpecificationExpression GetClosedTypeOf(Type type);
    private void closeType(Type type);
    public OpenGenericTypeListSpecificationExpression GetAllClosedTypesOf(Type type);
}
public class StructureMap.ComplexInstanceGraph : object {
    private IPipelineGraph _parent;
    private PluginGraph _pluginGraph;
    [CompilerGeneratedAttribute]
private ContainerRole <Role>k__BackingField;
    public ContainerRole Role { get; private set; }
    public PluginGraph ImmediatePluginGraph { get; }
    public ComplexInstanceGraph(IPipelineGraph parent, PluginGraph pluginGraph, ContainerRole role);
    public sealed virtual Instance GetDefault(Type pluginType);
    public sealed virtual bool HasDefaultForPluginType(Type pluginType);
    public sealed virtual bool HasInstance(Type pluginType, string instanceKey);
    public sealed virtual void EachInstance(Action`2<Type, Instance> action);
    public sealed virtual IEnumerable`1<Instance> GetAllInstances();
    public sealed virtual IEnumerable`1<Instance> GetAllInstances(Type pluginType);
    public sealed virtual Instance FindInstance(Type pluginType, string name);
    [IteratorStateMachineAttribute("StructureMap.ComplexInstanceGraph/<UniqueFamilies>d__10")]
public sealed virtual IEnumerable`1<PluginFamily> UniqueFamilies();
    public sealed virtual ILifecycle DefaultLifecycleFor(Type pluginType);
    [CompilerGeneratedAttribute]
public sealed virtual ContainerRole get_Role();
    [CompilerGeneratedAttribute]
private void set_Role(ContainerRole value);
    public sealed virtual IEnumerable`1<Instance> ImmediateInstances();
    public sealed virtual PluginGraph get_ImmediatePluginGraph();
    [CompilerGeneratedAttribute]
private bool <UniqueFamilies>b__10_0(PluginFamily x);
}
public static class StructureMap.Configuration.ConfigurationConstants : object {
    public static string CONFIGURED_DEFAULT_KEY_CANNOT_BE_FOUND;
    public static string COULD_NOT_CREATE_INSTANCE;
    public static string COULD_NOT_CREATE_MEMENTO_SOURCE;
    public static string COULD_NOT_LOAD_ASSEMBLY;
    public static string COULD_NOT_LOAD_TYPE;
    public static string FATAL_ERROR;
    public static string INVALID_ENUMERATION_VALUE;
    public static string INVALID_PLUGIN;
    public static string INVALID_PLUGIN_FAMILY;
    public static string INVALID_PROPERTY_CAST;
    public static string INVALID_SETTER;
    public static string MEMENTO_PROPERTY_IS_MISSING;
    public static string MEMENTO_SOURCE_CANNOT_RETRIEVE;
    public static string MISSING_CHILD;
    public static string MISSING_INSTANCE_KEY;
    public static string NO_DEFAULT_INSTANCE_CONFIGURED;
    public static string NO_MATCHING_INSTANCE_CONFIGURED;
    public static string PLUGIN_CANNOT_READ_CONSTRUCTOR_PROPERTIES;
    public static string PLUGIN_FAMILY_CANNOT_BE_FOUND_FOR_INSTANCE;
    public static string PLUGIN_IS_MISSING_CONCRETE_KEY;
    public static string UNKNOWN_PLUGIN_PROBLEM;
    public static string VALIDATION_METHOD_FAILURE;
}
public class StructureMap.Configuration.DSL.Expressions.ConfigureConventionExpression : object {
    private ConfigurableRegistrationConvention _convention;
    internal ConfigureConventionExpression(ConfigurableRegistrationConvention convention);
    public ConfigureConventionExpression OnAddedPluginTypes(Action`1<GenericFamilyExpression> configurePluginType);
}
public class StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1 : object {
    private List`1<Action`1<PluginFamily>> _alterations;
    private List`1<Action`1<PluginGraph>> _children;
    private Type _pluginType;
    public InstanceExpression`1<TPluginType> MissingNamedInstanceIs { get; }
    unknown Action`1<PluginFamily> alter {private set; }
    public CreatePluginFamilyExpression`1(Registry registry, ILifecycle scope);
    public void Configure(Action`1<PluginFamily> configuration);
    public InstanceExpression`1<TPluginType> get_MissingNamedInstanceIs();
    public CreatePluginFamilyExpression`1<TPluginType> AddInstances(Action`1<IInstanceExpression`1<TPluginType>> action);
    public CreatePluginFamilyExpression`1<TPluginType> AddSpecial(Action`1<IInstanceExpression`1<TPluginType>> configure);
    public SmartInstance`2<TConcreteType, TPluginType> Use();
    public LambdaInstance`2<T, TPluginType> Use(Expression`1<Func`2<IContext, T>> expression);
    public LambdaInstance`2<T, TPluginType> Use(string description, Func`2<IContext, T> func);
    public LambdaInstance`2<T, TPluginType> Use(Expression`1<Func`1<T>> expression);
    public LambdaInstance`2<T, TPluginType> Use(string description, Func`1<T> func);
    public void UseInstance(Instance instance);
    public ObjectInstance`2<TReturned, TPluginType> Use(TReturned object);
    public ReferencedInstance Use(string instanceName);
    public SmartInstance`2<TConcreteType, TPluginType> UseIfNone();
    public LambdaInstance`2<T, TPluginType> UseIfNone(Expression`1<Func`2<IContext, T>> func);
    public ObjectInstance UseIfNone(TPluginType value);
    public LambdaInstance`2<T, TPluginType> UseIfNone(string description, Func`2<IContext, T> func);
    public LambdaInstance`2<T, TPluginType> UseIfNone(Expression`1<Func`1<T>> func);
    public LambdaInstance`2<T, TPluginType> UseIfNone(string description, Func`1<T> func);
    public CreatePluginFamilyExpression`1<TPluginType> Singleton();
    public CreatePluginFamilyExpression`1<TPluginType> ContainerScoped();
    public CreatePluginFamilyExpression`1<TPluginType> Transient();
    public CreatePluginFamilyExpression`1<TPluginType> OnCreationForAll(Expression`1<Action`1<TPluginType>> handler, Func`2<Instance, bool> filter);
    public CreatePluginFamilyExpression`1<TPluginType> OnCreationForAll(string description, Action`1<TPluginType> handler, Func`2<Instance, bool> filter);
    public CreatePluginFamilyExpression`1<TPluginType> OnCreationForAll(Expression`1<Action`2<IContext, TPluginType>> handler, Func`2<Instance, bool> filter);
    public CreatePluginFamilyExpression`1<TPluginType> OnCreationForAll(string description, Action`2<IContext, TPluginType> handler, Func`2<Instance, bool> filter);
    public CreatePluginFamilyExpression`1<TPluginType> InterceptWith(IInterceptor interceptor, Func`2<Instance, bool> filter);
    public SmartInstance`2<TDecoratorType, TPluginType> DecorateAllWith(Func`2<Instance, bool> filter);
    public CreatePluginFamilyExpression`1<TPluginType> DecorateAllWith(Expression`1<Func`2<TPluginType, TPluginType>> handler, Func`2<Instance, bool> filter);
    public CreatePluginFamilyExpression`1<TPluginType> DecorateAllWith(string description, Func`2<TPluginType, TPluginType> handler, Func`2<Instance, bool> filter);
    public CreatePluginFamilyExpression`1<TPluginType> DecorateAllWith(Expression`1<Func`3<IContext, TPluginType, TPluginType>> handler, Func`2<Instance, bool> filter);
    public CreatePluginFamilyExpression`1<TPluginType> DecorateAllWith(string description, Func`3<IContext, TPluginType, TPluginType> handler, Func`2<Instance, bool> filter);
    public CreatePluginFamilyExpression`1<TPluginType> LifecycleIs(ILifecycle lifecycle);
    public CreatePluginFamilyExpression`1<TPluginType> LifecycleIs();
    public CreatePluginFamilyExpression`1<TPluginType> AlwaysUnique();
    public ObjectInstance`2<TReturned, TPluginType> Add(TReturned object);
    public SmartInstance`2<TPluggedType, TPluginType> Add();
    public LambdaInstance`2<T, TPluginType> Add(Expression`1<Func`1<T>> func);
    public LambdaInstance`2<T, TPluginType> Add(string description, Func`1<T> func);
    public LambdaInstance`2<T, TPluginType> Add(Expression`1<Func`2<IContext, T>> func);
    public LambdaInstance`2<T, TPluginType> Add(string description, Func`2<IContext, T> func);
    public void AddInstance(Instance instance);
    private CreatePluginFamilyExpression`1<TPluginType> lifecycleIs(ILifecycle lifecycle);
    private void registerDefault(Instance instance);
    private void registerFallBack(Instance instance);
    private void set_alter(Action`1<PluginFamily> value);
    public CreatePluginFamilyExpression`1<TPluginType> ClearAll();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(PluginGraph graph);
    [CompilerGeneratedAttribute]
private void <get_MissingNamedInstanceIs>b__6_0(Instance i);
}
public class StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression : object {
    private Type _pluginType;
    private Registry _registry;
    public GenericFamilyExpression(Type pluginType, ILifecycle scope, Registry registry);
    private GenericFamilyExpression alterAndContinue(Action`1<PluginFamily> action);
    public void Use(Instance instance);
    public ConfiguredInstance Use(Type concreteType);
    public GenericFamilyExpression MissingNamedInstanceIs(Instance instance);
    public LambdaInstance`1<object> Use(Expression`1<Func`2<IContext, object>> func);
    public LambdaInstance`1<object> Use(string description, Func`2<IContext, object> func);
    public LambdaInstance`1<object> Add(Expression`1<Func`2<IContext, object>> func);
    public LambdaInstance`1<object> Add(string description, Func`2<IContext, object> func);
    public ObjectInstance Use(object value);
    public ReferencedInstance Use(string instanceKey);
    public ConfiguredInstance Add(Type concreteType);
    public GenericFamilyExpression Add(Instance instance);
    public ObjectInstance Add(object object);
    public GenericFamilyExpression LifecycleIs(ILifecycle lifecycle);
    public GenericFamilyExpression Singleton();
    public GenericFamilyExpression ContainerScoped();
    public ConfiguredInstance DecorateAllWith(Type decoratorType, Func`2<Instance, bool> filter);
    public GenericFamilyExpression ClearAll();
    public void Configure(Action`1<PluginFamily> configure);
}
public class StructureMap.Configuration.DSL.Expressions.GenericIsExpression : object {
    private Action`1<Instance> _action;
    public GenericIsExpression(Action`1<Instance> action);
    public ConfiguredInstance Is(Type concreteType);
    public ReferencedInstance TheInstanceNamed(string name);
}
public interface StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1 {
    public abstract virtual void Instance(Instance instance);
    public abstract virtual ObjectInstance`2<TReturned, T> Object(TReturned theObject);
    public abstract virtual SmartInstance`2<TPluggedType, T> Type();
    public abstract virtual ConfiguredInstance Type(Type type);
    public abstract virtual LambdaInstance`2<TReturned, T> ConstructedBy(Expression`1<Func`1<TReturned>> func);
    public abstract virtual LambdaInstance`2<TReturned, T> ConstructedBy(string description, Func`1<TReturned> func);
    public abstract virtual LambdaInstance`2<TReturned, T> ConstructedBy(Expression`1<Func`2<IContext, TReturned>> func);
    public abstract virtual LambdaInstance`2<TReturned, T> ConstructedBy(string description, Func`2<IContext, TReturned> func);
    public abstract virtual ReferencedInstance TheInstanceNamed(string name);
    public abstract virtual DefaultInstance TheDefault();
}
public class StructureMap.Configuration.DSL.Expressions.InstanceExpression`1 : object {
    private Action`1<Instance> _action;
    private IInstanceExpression`1<T> StructureMap.Configuration.DSL.Expressions.IsExpression<T>.Is { get; }
    internal InstanceExpression`1(Action`1<Instance> action);
    private sealed virtual override IInstanceExpression`1<T> StructureMap.Configuration.DSL.Expressions.IsExpression<T>.get_Is();
    public sealed virtual void IsThis(Instance instance);
    public sealed virtual ObjectInstance`2<TReturned, T> IsThis(TReturned obj);
    public sealed virtual void Instance(Instance instance);
    public sealed virtual SmartInstance`2<TPluggedType, T> Type();
    public sealed virtual ConfiguredInstance Type(Type type);
    public sealed virtual ObjectInstance`2<TReturned, T> Object(TReturned theObject);
    public sealed virtual ReferencedInstance TheInstanceNamed(string name);
    public sealed virtual DefaultInstance TheDefault();
    public sealed virtual LambdaInstance`2<TReturned, T> ConstructedBy(Expression`1<Func`1<TReturned>> func);
    public sealed virtual LambdaInstance`2<TReturned, T> ConstructedBy(string description, Func`1<TReturned> func);
    public sealed virtual LambdaInstance`2<TReturned, T> ConstructedBy(Expression`1<Func`2<IContext, TReturned>> func);
    public sealed virtual LambdaInstance`2<TReturned, T> ConstructedBy(string description, Func`2<IContext, TReturned> func);
    private TInstance returnInstance(TInstance instance);
}
public interface StructureMap.Configuration.DSL.Expressions.IsExpression`1 {
    public IInstanceExpression`1<T> Is { get; }
    public abstract virtual IInstanceExpression`1<T> get_Is();
    public abstract virtual void IsThis(Instance instance);
    public abstract virtual ObjectInstance`2<TReturned, T> IsThis(TReturned obj);
}
public class StructureMap.Configuration.DSL.SetterConvention : object {
    private IList`1<Func`2<PropertyInfo, bool>> _rules;
    public void OfType();
    public void TypeMatches(Predicate`1<Type> predicate);
    public void Matching(Func`2<PropertyInfo, bool> rule);
    public void WithAnyTypeFromNamespace(string nameSpace);
    public void WithAnyTypeFromNamespaceContainingType();
    public void NameMatches(Predicate`1<string> rule);
    private sealed virtual override void StructureMap.Configuration.DSL.SetterConventionRule.Configure(SetterRules rules);
}
public interface StructureMap.Configuration.DSL.SetterConventionRule {
    public abstract virtual void Configure(SetterRules rules);
}
public interface StructureMap.Configuration.ITypeReader`1 {
    public abstract virtual bool CanProcess(Type pluginType);
    public abstract virtual Instance Read(T node, Type pluginType);
}
public class StructureMap.Configuration.MalformedAliasException : Exception {
    public MalformedAliasException(string xml);
}
public class StructureMap.ConfigurationExpression : Registry {
    private PluginGraphBuilder _builder;
    private IList`1<Registry> _registries;
    internal IList`1<Registry> Registries { get; }
    internal IList`1<Registry> get_Registries();
    internal bool HasPolicyChanges();
    public void AddRegistry();
    public void AddRegistry(Registry registry);
    internal PluginGraph BuildGraph();
    protected bool Equals(ConfigurationExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class StructureMap.ConfiguredInstancePolicy : object {
    public sealed virtual void Apply(Type pluginType, Instance instance);
    protected abstract virtual void apply(Type pluginType, IConfiguredInstance instance);
}
internal class StructureMap.ConstructorFinderVisitor : ExpressionVisitorBase {
    private Type _type;
    private ConstructorInfo _constructor;
    public ConstructorInfo Constructor { get; }
    public ConstructorFinderVisitor(Type type);
    public ConstructorInfo get_Constructor();
    protected virtual NewExpression VisitNew(NewExpression nex);
}
public class StructureMap.Container : object {
    private ConcurrentBag`1<Container> _children;
    private IPipelineGraph _pipelineGraph;
    private object _syncLock;
    private bool _disposedLatch;
    private ContainerRole _role;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DisposalLock <DisposalLock>k__BackingField;
    public IModel Model { get; }
    public string ProfileName { get; }
    public string Name { get; public set; }
    public ContainerRole Role { get; }
    public ITransientTracking TransientTracking { get; }
    public DisposalLock DisposalLock { get; public set; }
    public Container(Action`1<ConfigurationExpression> action);
    public Container(Registry registry);
    public Container(PluginGraph pluginGraph);
    internal Container(IPipelineGraph pipelineGraph);
    public static IContainer For();
    private void assertNotDisposed();
    public sealed virtual IModel get_Model();
    public sealed virtual T GetInstance(string instanceKey);
    public sealed virtual T GetInstance(Instance instance);
    public sealed virtual T GetInstance(ExplicitArguments args);
    public sealed virtual T GetInstance(ExplicitArguments args, string instanceKey);
    public sealed virtual object GetInstance(Type pluginType, ExplicitArguments args);
    private object DoGetInstance(Type pluginType, ExplicitArguments args);
    public sealed virtual object GetInstance(Type pluginType, ExplicitArguments args, string instanceKey);
    private object DoGetInstance(Type pluginType, ExplicitArguments args, string instanceKey);
    public sealed virtual T TryGetInstance(ExplicitArguments args);
    public sealed virtual T TryGetInstance(ExplicitArguments args, string instanceKey);
    public sealed virtual object TryGetInstance(Type pluginType, ExplicitArguments args);
    private object DoTryGetInstance(Type pluginType, ExplicitArguments args);
    public sealed virtual object TryGetInstance(Type pluginType, ExplicitArguments args, string instanceKey);
    private object DoTryGetInstance(Type pluginType, ExplicitArguments args, string instanceKey);
    public sealed virtual IEnumerable GetAllInstances(Type pluginType, ExplicitArguments args);
    public sealed virtual IEnumerable`1<T> GetAllInstances(ExplicitArguments args);
    public sealed virtual T GetInstance();
    public sealed virtual IEnumerable`1<T> GetAllInstances();
    public sealed virtual object GetInstance(Type pluginType, string instanceKey);
    private object DoGetInstance(Type pluginType, string instanceKey);
    public sealed virtual object TryGetInstance(Type pluginType, string instanceKey);
    private object DoTryGetInstance(Type pluginType, string instanceKey);
    public sealed virtual object TryGetInstance(Type pluginType);
    private object DoTryGetInstance(Type pluginType);
    public sealed virtual T TryGetInstance();
    public sealed virtual void BuildUp(object target);
    public sealed virtual T TryGetInstance(string instanceKey);
    public sealed virtual object GetInstance(Type pluginType);
    private object DoGetInstance(Type pluginType);
    public sealed virtual object GetInstance(Type pluginType, Instance instance);
    private object DoGetInstance(Type pluginType, Instance instance);
    public sealed virtual IEnumerable GetAllInstances(Type pluginType);
    public sealed virtual void Configure(Action`1<ConfigurationExpression> configure);
    internal static void CorrectSingletonLifecycleForChild(IPipelineGraph pipelineGraph);
    public sealed virtual IContainer GetProfile(string profileName);
    public sealed virtual IContainer CreateChildContainer();
    public sealed virtual string get_ProfileName();
    public sealed virtual string WhatDoIHave(Type pluginType, Assembly assembly, string namespace, string typeName);
    public sealed virtual string WhatDidIScan();
    public sealed virtual ExplicitArgsExpression With(T arg);
    public sealed virtual ExplicitArgsExpression With(Type pluginType, object arg);
    public sealed virtual IExplicitProperty With(string argName);
    public sealed virtual void AssertConfigurationIsValid();
    public sealed virtual void EjectAllInstancesOf();
    public sealed virtual OpenGenericTypeExpression ForGenericType(Type templateType);
    public sealed virtual CloseGenericTypeExpression ForObject(object subject);
    public sealed virtual IContainer GetNestedContainer();
    public sealed virtual IContainer GetNestedContainer(TypeArguments arguments);
    public sealed virtual IContainer GetNestedContainer(string profileName);
    private IContainer GetNestedContainer(IPipelineGraph pipeline);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual void Inject(T instance);
    public sealed virtual void Inject(Type pluginType, object instance);
    private object BuildInstanceWithArgs(Type pluginType, Instance defaultInstance, ExplicitArguments args, string requestedName);
    public sealed virtual ExplicitArgsExpression With(Action`1<IExplicitArgsExpression> action);
    public void Inject(Type pluginType, Instance instance);
    public sealed virtual ContainerRole get_Role();
    public sealed virtual ITransientTracking get_TransientTracking();
    public sealed virtual void Release(object object);
    [CompilerGeneratedAttribute]
public sealed virtual DisposalLock get_DisposalLock();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisposalLock(DisposalLock value);
}
public enum StructureMap.ContainerRole : Enum {
    public int value__;
    public static ContainerRole Root;
    public static ContainerRole ProfileOrChild;
    public static ContainerRole Nested;
}
[AttributeUsageAttribute("32")]
public class StructureMap.DefaultConstructorAttribute : Attribute {
    public static ConstructorInfo GetConstructor(Type ExportedType);
}
public class StructureMap.Diagnostics.BuildDependency : object {
    public Instance Instance;
    public Type PluginType;
    public BuildDependency(Type pluginType, Instance instance);
    public sealed virtual bool Equals(BuildDependency buildDependency);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class StructureMap.Diagnostics.BuildError : object {
    private List`1<BuildDependency> _dependencies;
    private Instance _instance;
    private Type _pluginType;
    [CompilerGeneratedAttribute]
private StructureMapException <Exception>k__BackingField;
    public List`1<BuildDependency> Dependencies { get; }
    public Instance Instance { get; }
    public Type PluginType { get; }
    public StructureMapException Exception { get; public set; }
    public Guid RootInstance { get; }
    public BuildError(Type pluginType, Instance instance);
    public List`1<BuildDependency> get_Dependencies();
    public Instance get_Instance();
    public Type get_PluginType();
    [CompilerGeneratedAttribute]
public StructureMapException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(StructureMapException value);
    public Guid get_RootInstance();
    public void AddDependency(BuildDependency dependency);
    public void Write(StringWriter writer);
}
public class StructureMap.Diagnostics.BuildPlanVisualizer : object {
    private IPipelineGraph _pipeline;
    private TreeWriter _writer;
    private int _maxLevels;
    private int _level;
    private Stack`1<Instance> _instanceStack;
    public int MaxLevels { get; }
    public BuildPlanVisualizer(IPipelineGraph pipeline, bool deep, int levels);
    public int get_MaxLevels();
    public void VisitNextLevel(Action action);
    public void ShowDefault(Type pluginType);
    public void ShowReferenced(Type pluginType, string name);
    public sealed virtual void Constructor(ConstructorStep constructor);
    public sealed virtual void Setter(Setter setter);
    public sealed virtual void Activator(IInterceptor interceptor);
    public sealed virtual void Decorator(IInterceptor interceptor);
    public sealed virtual void Instance(Type pluginType, Instance instance);
    public sealed virtual void InnerBuilder(IDependencySource inner);
    public void Write(TextWriter writer);
    [CompilerGeneratedAttribute]
private void <Constructor>b__10_0(CtorArgument arg);
}
internal class StructureMap.Diagnostics.CharacterWidth : object {
    private int _width;
    internal int Width { get; }
    internal int get_Width();
    internal static CharacterWidth[] For(int count);
    internal void SetWidth(int width);
    internal void Add(int add);
}
public class StructureMap.Diagnostics.DependencyVisualizer : object {
    private TitledWriter _writer;
    private BuildPlanVisualizer _buildPlanVisitor;
    public DependencyVisualizer(string title, TreeWriter writer, BuildPlanVisualizer buildPlanVisitor);
    public sealed virtual void Constant(Constant constant);
    public sealed virtual void Default(Type pluginType);
    public sealed virtual void Referenced(ReferencedDependencySource source);
    public sealed virtual void InlineEnumerable(IEnumerableDependencySource source);
    public sealed virtual void AllPossibleOf(Type pluginType);
    public sealed virtual void Concrete(ConcreteBuild build);
    public sealed virtual void Lifecycled(LifecycleDependencySource source);
    public sealed virtual void Dependency(IDependencySource source);
    public sealed virtual void Problem(DependencyProblem problem);
    public sealed virtual void Dispose();
}
internal class StructureMap.Diagnostics.DividerLine : object {
    private char _character;
    internal DividerLine(char character);
    public sealed virtual void OverwriteCounts(CharacterWidth[] widths);
    public sealed virtual void Write(TextWriter writer, CharacterWidth[] widths);
}
public class StructureMap.Diagnostics.Error : object {
    private string _message;
    private string _stackTrace;
    public InstanceToken Instance;
    public string Source;
    public string Message { get; }
    public Error(string message);
    public Error(Exception exception);
    public string get_Message();
    public sealed virtual bool Equals(Error error);
    private void writeStackTrace(Exception exception);
    public virtual string ToString();
    public void Write(StringWriter writer);
}
public interface StructureMap.Diagnostics.IBuildPlanVisitor {
    public abstract virtual void Constructor(ConstructorStep constructor);
    public abstract virtual void Setter(Setter setter);
    public abstract virtual void Activator(IInterceptor interceptor);
    public abstract virtual void Decorator(IInterceptor interceptor);
    public abstract virtual void Instance(Type pluginType, Instance instance);
    public abstract virtual void InnerBuilder(IDependencySource inner);
}
public interface StructureMap.Diagnostics.IDependencyVisitor {
    public abstract virtual void Constant(Constant constant);
    public abstract virtual void Default(Type pluginType);
    public abstract virtual void Referenced(ReferencedDependencySource source);
    public abstract virtual void InlineEnumerable(IEnumerableDependencySource source);
    public abstract virtual void AllPossibleOf(Type pluginType);
    public abstract virtual void Concrete(ConcreteBuild build);
    public abstract virtual void Lifecycled(LifecycleDependencySource source);
    public abstract virtual void Dependency(IDependencySource source);
    public abstract virtual void Problem(DependencyProblem problem);
}
public class StructureMap.Diagnostics.InstanceToken : object {
    private string _description;
    private string _name;
    public string Name { get; }
    public string Description { get; }
    public InstanceToken(string name, string description);
    public string get_Name();
    public string get_Description();
    public sealed virtual bool Equals(InstanceToken instanceToken);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal interface StructureMap.Diagnostics.Line {
    public abstract virtual void OverwriteCounts(CharacterWidth[] widths);
    public abstract virtual void Write(TextWriter writer, CharacterWidth[] widths);
}
public class StructureMap.Diagnostics.ModelQuery : object {
    public string Namespace;
    public Type PluginType;
    public Assembly Assembly;
    public string TypeName;
    public IEnumerable`1<IPluginTypeConfiguration> Query(IModel model);
    [CompilerGeneratedAttribute]
private bool <Query>b__4_0(IPluginTypeConfiguration x);
    [CompilerGeneratedAttribute]
private bool <Query>b__4_1(IPluginTypeConfiguration x);
    [CompilerGeneratedAttribute]
private bool <Query>b__4_2(IPluginTypeConfiguration x);
    [CompilerGeneratedAttribute]
private bool <Query>b__4_3(IPluginTypeConfiguration x);
}
public class StructureMap.Diagnostics.PipelineGraphValidator : object {
    private IList`1<Guid> _buildPlanFailureIds;
    private IList`1<ProfileReport> _reports;
    public static void AssertNoErrors(IPipelineGraph graph);
    public void AssertIsValid();
    [IteratorStateMachineAttribute("StructureMap.Diagnostics.PipelineGraphValidator/<findPipelines>d__4")]
private static IEnumerable`1<IPipelineGraph> findPipelines(IPipelineGraph graph);
    public void Validate(IPipelineGraph pipeline, Policies policies);
    private void tryBuildInstance(Type pluginType, Instance instance, IPipelineGraph pipeline, ProfileReport report);
    private void tryCreateBuildPlan(Type pluginType, InstanceRef instanceRef, Policies policies, ProfileReport report);
    private void validate(Type pluginType, Instance instance, object builtObject, ProfileReport report);
    [CompilerGeneratedAttribute]
private bool <Validate>b__5_4(InstanceRef x);
    [CompilerGeneratedAttribute]
private void <tryBuildInstance>b__6_0(Guid x);
}
internal class StructureMap.Diagnostics.PlainLine : object {
    [CompilerGeneratedAttribute]
private string <Contents>k__BackingField;
    public string Contents { get; public set; }
    public PlainLine(string contents);
    [CompilerGeneratedAttribute]
public string get_Contents();
    [CompilerGeneratedAttribute]
public void set_Contents(string value);
    public sealed virtual void OverwriteCounts(CharacterWidth[] widths);
    public sealed virtual void Write(TextWriter writer, CharacterWidth[] widths);
}
public class StructureMap.Diagnostics.ProfileReport : object {
    private ContainerRole _role;
    private string _profile;
    private IList`1<BuildError> _errors;
    private IList`1<ValidationError> _validations;
    public ContainerRole Role { get; }
    public string Profile { get; }
    public IEnumerable`1<BuildError> Errors { get; }
    public IEnumerable`1<ValidationError> Validations { get; }
    public ProfileReport(IPipelineGraph pipelineGraph);
    public ContainerRole get_Role();
    public string get_Profile();
    public void AddError(Type pluginType, Instance instance, StructureMapException ex);
    public bool HasAnyErrors();
    public void AddValidationError(ValidationError error);
    public void WriteErrorMessages(StringWriter writer);
    public IEnumerable`1<BuildError> get_Errors();
    public IEnumerable`1<ValidationError> get_Validations();
}
internal class StructureMap.Diagnostics.TextLine : object {
    private String[] _contents;
    internal TextLine(String[] contents);
    public sealed virtual void OverwriteCounts(CharacterWidth[] widths);
    public sealed virtual void Write(TextWriter writer, CharacterWidth[] widths);
}
public class StructureMap.Diagnostics.TextReportWriter : object {
    private int _columnCount;
    private List`1<Line> _lines;
    public TextReportWriter(int columnCount);
    public void AddDivider(char character);
    public void AddText(String[] contents);
    public void AddContent(string contents);
    public void Write(StringWriter writer);
    public string Write();
    public void DumpToDebug();
}
public class StructureMap.Diagnostics.TreeView.Astericks : Section {
    private string _buffer;
    public int TabWidth { get; }
    public Astericks(int tabWidth);
    public virtual int get_TabWidth();
    protected virtual void applyBuffer(Line line, int index);
}
public class StructureMap.Diagnostics.TreeView.LeftBorder : Section {
    private string _buffer;
    public int TabWidth { get; }
    public LeftBorder(int tabWidth);
    public virtual int get_TabWidth();
    protected virtual void applyBuffer(Line line, int index);
}
public class StructureMap.Diagnostics.TreeView.Line : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    public int Length { get; }
    public Line(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    public void Prepend(string buffer);
    public int get_Length();
}
public class StructureMap.Diagnostics.TreeView.Numbered : Section {
    private int _tabWidth;
    private int _count;
    public int TabWidth { get; }
    public Numbered(int tabWidth);
    public virtual int get_TabWidth();
    protected virtual void applyBufferingToChildSectionLines(IEnumerable`1<Line> sectionLines, int index);
    protected virtual void applyBuffer(Line line, int index);
}
public class StructureMap.Diagnostics.TreeView.Outline : Section {
    private int _tabWidth;
    public int TabWidth { get; }
    public Outline(int tabWidth);
    public virtual int get_TabWidth();
    protected virtual void applyBufferingToChildSectionLines(IEnumerable`1<Line> sectionLines, int index);
    protected virtual void applyBuffer(Line line, int index);
}
public class StructureMap.Diagnostics.TreeView.Section : object {
    protected List`1<object> items;
    public int TabWidth { get; }
    public virtual int get_TabWidth();
    public virtual void Write(string format, Object[] parameters);
    public void ChildSection(Section section);
    [IteratorStateMachineAttribute("StructureMap.Diagnostics.TreeView.Section/<ToLines>d__5")]
public virtual IEnumerable`1<Line> ToLines();
    protected bool isSubsequentLine(int index);
    protected virtual void applyBufferingToChildSectionLines(IEnumerable`1<Line> sectionLines, int index);
    protected virtual void applyBuffer(Line line, int index);
    [CompilerGeneratedAttribute]
private void <applyBufferingToChildSectionLines>b__7_0(Line x);
}
public class StructureMap.Diagnostics.TreeView.Tabbed : Section {
    private string _buffer;
    public int TabWidth { get; }
    public Tabbed(int tabWidth);
    public virtual int get_TabWidth();
    protected virtual void applyBuffer(Line line, int index);
}
public class StructureMap.Diagnostics.TreeView.TitledWriter : object {
    private string _title;
    private TreeWriter _writer;
    private bool _hasWrittenTitle;
    public TreeWriter Writer { get; }
    public TitledWriter(string title, TreeWriter writer);
    public TreeWriter get_Writer();
    public void Line(string format, Object[] parameters);
    public sealed virtual void Dispose();
}
public class StructureMap.Diagnostics.TreeView.TreeWriter : object {
    private Section _top;
    private Stack`1<Section> _sections;
    public Section CurrentSection { get; }
    public TreeWriter(Section top);
    public void StartSection(Section section);
    public void StartSection();
    public void EndSection();
    public Section get_CurrentSection();
    public virtual void Line(string text, Object[] parameters);
    public void WriteAll(TextWriter writer);
    public void BlankLines(int count);
    public void StartSection(int tabWidth);
}
public class StructureMap.Diagnostics.ValidationError : object {
    public Exception Exception;
    public Instance Instance;
    public string MethodName;
    public Type PluginType;
    public ValidationError(Type pluginType, Instance instance, Exception exception, MethodInfo method);
    public void Write(StringWriter writer);
}
public class StructureMap.Diagnostics.WhatDoIHaveWriter : object {
    private IPipelineGraph _graph;
    private List`1<Instance> _instances;
    private TextReportWriter _writer;
    private StringWriter _stringWriter;
    public WhatDoIHaveWriter(IPipelineGraph graph);
    public string GetText(ModelQuery query, string title);
    private void writeContentsOfPluginTypes(IEnumerable`1<IPluginTypeConfiguration> pluginTypes);
    private void writePluginType(IPluginTypeConfiguration pluginType);
    private void writeInstance(InstanceRef instance, string name);
    private void setContents(String[] contents, InstanceRef instance, string name);
}
[ExtensionAttribute]
public static class StructureMap.Diagnostics.WriterExtensions : object {
    [ExtensionAttribute]
public static void WriteLine(TextWriter writer, int spaces, string text);
    [ExtensionAttribute]
public static string Line(int length, char character);
}
public enum StructureMap.DisposalLock : Enum {
    public int value__;
    public static DisposalLock Ignore;
    public static DisposalLock Unlocked;
    public static DisposalLock ThrowOnDispose;
}
public class StructureMap.ExplicitArgsExpression : object {
    private ExplicitArguments _args;
    private IContainer _container;
    private string _lastArgName;
    internal ExplicitArgsExpression(IContainer container);
    private sealed virtual override ExplicitArgsExpression StructureMap.IExplicitProperty.EqualTo(object value);
    public sealed virtual ExplicitArgsExpression With(T arg);
    public sealed virtual ExplicitArgsExpression With(Type pluginType, object arg);
    public sealed virtual IExplicitProperty With(string argName);
    public T GetInstance();
    public T GetInstance(string name);
    public object GetInstance(Type type);
    public object GetInstance(Type type, string name);
    public IEnumerable`1<T> GetAllInstances();
    public IEnumerable GetAllInstances(Type type);
    public T TryGetInstance();
    public T TryGetInstance(string name);
    public object TryGetInstance(Type pluginType);
    public object TryGetInstance(Type pluginType, string name);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public abstract class StructureMap.ExpressionVisitorBase : object {
    public virtual Expression Visit(Expression exp);
    protected virtual MemberBinding VisitBinding(MemberBinding binding);
    protected virtual ElementInit VisitElementInitializer(ElementInit initializer);
    protected virtual Expression VisitUnary(UnaryExpression u);
    protected virtual Expression VisitBinary(BinaryExpression b);
    protected virtual Expression VisitTypeIs(TypeBinaryExpression b);
    protected virtual Expression VisitConstant(ConstantExpression c);
    protected virtual Expression VisitConditional(ConditionalExpression c);
    protected virtual Expression VisitParameter(ParameterExpression p);
    protected virtual Expression VisitMemberAccess(MemberExpression m);
    protected virtual Expression VisitMethodCall(MethodCallExpression m);
    protected virtual ReadOnlyCollection`1<Expression> VisitList(ReadOnlyCollection`1<Expression> original);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual IEnumerable`1<MemberBinding> VisitBindingList(ReadOnlyCollection`1<MemberBinding> original);
    protected virtual IEnumerable`1<ElementInit> VisitElementInitializerList(ReadOnlyCollection`1<ElementInit> original);
    protected virtual Expression VisitLambda(LambdaExpression lambda);
    protected virtual NewExpression VisitNew(NewExpression nex);
    protected virtual Expression VisitMemberInit(MemberInitExpression init);
    protected virtual Expression VisitListInit(ListInitExpression init);
    protected virtual Expression VisitNewArray(NewArrayExpression na);
    protected virtual Expression VisitInvocation(InvocationExpression iv);
}
public class StructureMap.Graph.AllPossibleInstance : Instance {
    private Type _returnedType;
    public string Description { get; }
    public Type ReturnedType { get; }
    public AllPossibleInstance(Type returnedType);
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual string get_Description();
    public virtual Type get_ReturnedType();
}
public static class StructureMap.Graph.AssemblyFinder : object {
    public static IEnumerable`1<Assembly> FindAssemblies(Action`1<string> logFailure, bool includeExeFiles);
    [IteratorStateMachineAttribute("StructureMap.Graph.AssemblyFinder/<FindAssemblies>d__1")]
public static IEnumerable`1<Assembly> FindAssemblies(string assemblyPath, Action`1<string> logFailure, bool includeExeFiles);
    public static IEnumerable`1<Assembly> FindAssemblies(Func`2<Assembly, bool> filter, Action`1<string> onDirectoryFound, bool includeExeFiles);
}
public class StructureMap.Graph.AssemblyScanner : object {
    private List`1<Assembly> _assemblies;
    private CompositeFilter`1<Type> _filter;
    private List`1<AssemblyScanRecord> _records;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IRegistrationConvention> <Conventions>k__BackingField;
    public int Count { get; }
    public string Description { get; public set; }
    public List`1<IRegistrationConvention> Conventions { get; }
    public int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Description(string value);
    public sealed virtual void Assembly(Assembly assembly);
    public sealed virtual void Assembly(string assemblyName);
    [CompilerGeneratedAttribute]
public List`1<IRegistrationConvention> get_Conventions();
    public sealed virtual void Convention();
    public sealed virtual void LookForRegistries();
    public sealed virtual void AssemblyContainingType();
    public sealed virtual void AssemblyContainingType(Type type);
    public sealed virtual FindAllTypesFilter AddAllTypesOf();
    public sealed virtual FindAllTypesFilter AddAllTypesOf(Type pluginType);
    public sealed virtual void Exclude(Func`2<Type, bool> exclude);
    public sealed virtual void ExcludeNamespace(string nameSpace);
    public sealed virtual void ExcludeNamespaceContainingType();
    public sealed virtual void Include(Func`2<Type, bool> predicate);
    public sealed virtual void IncludeNamespace(string nameSpace);
    public sealed virtual void IncludeNamespaceContainingType();
    public sealed virtual void ExcludeType();
    public sealed virtual void With(IRegistrationConvention convention);
    public sealed virtual ConfigureConventionExpression WithDefaultConventions();
    public sealed virtual ConfigureConventionExpression ConnectImplementationsToTypesClosing(Type openGenericType);
    public sealed virtual ConfigureConventionExpression RegisterConcreteTypesAgainstTheFirstInterface();
    public sealed virtual ConfigureConventionExpression SingleImplementationsOfInterface();
    public void Describe(StringWriter writer);
    public Task`1<Registry> ScanForTypes();
    public bool Contains(string assemblyName);
    public bool HasAssemblies();
    public sealed virtual void TheCallingAssembly();
    public sealed virtual void AssembliesFromApplicationBaseDirectory();
    public sealed virtual void AssembliesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    public sealed virtual void AssembliesAndExecutablesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    public sealed virtual void AssembliesAndExecutablesFromPath(string path);
    public sealed virtual void AssembliesFromPath(string path);
    public sealed virtual void AssembliesAndExecutablesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public sealed virtual void AssembliesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    private static Assembly findTheCallingAssembly();
    [CompilerGeneratedAttribute]
private bool <ScanForTypes>b__33_0(Type type);
    [CompilerGeneratedAttribute]
private Registry <ScanForTypes>b__33_1(Task`1<TypeSet> t);
}
public class StructureMap.Graph.CloseGenericFamilyPolicy : object {
    private PluginGraph _graph;
    public bool AppliesToHasFamilyChecks { get; }
    public CloseGenericFamilyPolicy(PluginGraph graph);
    public sealed virtual PluginFamily Build(Type type);
    private PluginFamily tryToConnect(Type type);
    public sealed virtual bool get_AppliesToHasFamilyChecks();
    public bool Matches(Type type);
}
public class StructureMap.Graph.CompositeFilter`1 : object {
    private CompositePredicate`1<T> _excludes;
    private CompositePredicate`1<T> _includes;
    public CompositePredicate`1<T> Includes { get; public set; }
    public CompositePredicate`1<T> Excludes { get; public set; }
    public CompositePredicate`1<T> get_Includes();
    public void set_Includes(CompositePredicate`1<T> value);
    public CompositePredicate`1<T> get_Excludes();
    public void set_Excludes(CompositePredicate`1<T> value);
    public bool Matches(T target);
}
public class StructureMap.Graph.CompositePredicate`1 : object {
    private List`1<Func`2<T, bool>> _list;
    private Func`2<T, bool> _matchesAll;
    private Func`2<T, bool> _matchesAny;
    private Func`2<T, bool> _matchesNone;
    public void Add(Func`2<T, bool> filter);
    public static CompositePredicate`1<T> op_Addition(CompositePredicate`1<T> invokes, Func`2<T, bool> filter);
    public bool MatchesAll(T target);
    public bool MatchesAny(T target);
    public bool MatchesNone(T target);
    public bool DoesNotMatcheAny(T target);
    [CompilerGeneratedAttribute]
private bool <Add>b__4_0(T x);
    [CompilerGeneratedAttribute]
private bool <Add>b__4_2(T x);
    [CompilerGeneratedAttribute]
private bool <Add>b__4_4(T x);
}
public abstract class StructureMap.Graph.ConfigurableRegistrationConvention : object {
    protected Action`1<GenericFamilyExpression> ConfigureFamily;
    public void SetFamilyConfigurationAction(Action`1<GenericFamilyExpression> configureFamily);
    public abstract virtual void ScanTypes(TypeSet types, Registry registry);
}
public class StructureMap.Graph.DefaultConventionScanner : ConfigurableRegistrationConvention {
    public virtual void ScanTypes(TypeSet types, Registry registry);
    public virtual Type FindPluginType(Type concreteType);
    public virtual string ToString();
}
public class StructureMap.Graph.EnumerableFamilyPolicy : object {
    public bool AppliesToHasFamilyChecks { get; }
    public sealed virtual PluginFamily Build(Type type);
    public sealed virtual bool get_AppliesToHasFamilyChecks();
}
public class StructureMap.Graph.FindAllTypesFilter : object {
    private Type _pluginType;
    private Func`2<Type, string> _getName;
    public FindAllTypesFilter(Type pluginType);
    public bool Matches(Type type);
    public sealed virtual void ScanTypes(TypeSet types, Registry registry);
    private Type GetLeastSpecificButValidType(Type pluginType, Type type);
    public void NameBy(Func`2<Type, string> getName);
    public virtual string ToString();
}
public class StructureMap.Graph.FindRegistriesScanner : object {
    public sealed virtual void ScanTypes(TypeSet types, Registry registry);
}
public class StructureMap.Graph.FirstInterfaceConvention : ConfigurableRegistrationConvention {
    public virtual void ScanTypes(TypeSet types, Registry registry);
    public virtual string ToString();
}
public class StructureMap.Graph.FuncBuildByNamePolicy : object {
    public bool AppliesToHasFamilyChecks { get; }
    public sealed virtual PluginFamily Build(Type type);
    public sealed virtual bool get_AppliesToHasFamilyChecks();
}
public class StructureMap.Graph.FuncByNameInstance`1 : LambdaInstance`1<Func`2<string, T>> {
}
public class StructureMap.Graph.GenericConnectionScanner : ConfigurableRegistrationConvention {
    private IList`1<Type> _concretions;
    private IList`1<Type> _interfaces;
    private Type _openType;
    public GenericConnectionScanner(Type openType);
    public virtual string ToString();
    public virtual void ScanTypes(TypeSet types, Registry registry);
    private void addConcretionsThatCouldBeClosed(Type interface, GenericFamilyExpression expression);
    [CompilerGeneratedAttribute]
private void <ScanTypes>b__5_0(Type type);
}
public static class StructureMap.Graph.GenericsPluginGraph : object {
    public static bool CanBeCast(Type pluginType, Type pluggedType);
    private static bool checkGenericType(Type pluggedType, Type pluginType);
}
public abstract class StructureMap.Graph.HasLifecycle : object {
    private ILifecycle _lifecycle;
    public ILifecycle Lifecycle { get; }
    protected void copyLifecycle(HasLifecycle other);
    public sealed virtual void SetLifecycleTo();
    public sealed virtual void SetLifecycleTo(ILifecycle lifecycle);
    public sealed virtual ILifecycle get_Lifecycle();
}
public interface StructureMap.Graph.IAssemblyScanner {
    public string Description { get; public set; }
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual void Assembly(Assembly assembly);
    public abstract virtual void Assembly(string assemblyName);
    public abstract virtual void AssemblyContainingType();
    public abstract virtual void AssemblyContainingType(Type type);
    public abstract virtual void LookForRegistries();
    public abstract virtual FindAllTypesFilter AddAllTypesOf();
    public abstract virtual FindAllTypesFilter AddAllTypesOf(Type pluginType);
    public abstract virtual void Exclude(Func`2<Type, bool> exclude);
    public abstract virtual void ExcludeNamespace(string nameSpace);
    public abstract virtual void ExcludeNamespaceContainingType();
    public abstract virtual void Include(Func`2<Type, bool> predicate);
    public abstract virtual void IncludeNamespace(string nameSpace);
    public abstract virtual void IncludeNamespaceContainingType();
    public abstract virtual void ExcludeType();
    public abstract virtual void Convention();
    public abstract virtual void With(IRegistrationConvention convention);
    public abstract virtual ConfigureConventionExpression WithDefaultConventions();
    public abstract virtual ConfigureConventionExpression ConnectImplementationsToTypesClosing(Type openGenericType);
    public abstract virtual ConfigureConventionExpression RegisterConcreteTypesAgainstTheFirstInterface();
    public abstract virtual ConfigureConventionExpression SingleImplementationsOfInterface();
    public abstract virtual void TheCallingAssembly();
    public abstract virtual void AssembliesFromApplicationBaseDirectory();
    public abstract virtual void AssembliesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void AssembliesAndExecutablesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void AssembliesAndExecutablesFromPath(string path);
    public abstract virtual void AssembliesFromPath(string path);
    public abstract virtual void AssembliesAndExecutablesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void AssembliesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
}
[DefaultMemberAttribute("Item")]
public interface StructureMap.Graph.IFamilyCollection {
    public PluginFamily Item { get; public set; }
    public abstract virtual PluginFamily get_Item(Type pluginType);
    public abstract virtual void set_Item(Type pluginType, PluginFamily value);
    public abstract virtual bool Has(Type pluginType);
}
public interface StructureMap.Graph.IFamilyPolicy {
    public bool AppliesToHasFamilyChecks { get; }
    public abstract virtual PluginFamily Build(Type type);
    public abstract virtual bool get_AppliesToHasFamilyChecks();
}
public class StructureMap.Graph.ImplementationMap : ConfigurableRegistrationConvention {
    public virtual void ScanTypes(TypeSet types, Registry registry);
    public virtual string ToString();
}
public interface StructureMap.Graph.IPluginGraph {
    public abstract virtual void AddType(Type pluginType, Type concreteType);
    public abstract virtual void AddType(Type pluginType, Type concreteType, string name);
}
public interface StructureMap.Graph.IRegistrationConvention {
    public abstract virtual void ScanTypes(TypeSet types, Registry registry);
}
public class StructureMap.Graph.PluginFamily : HasLifecycle {
    private LightweightCache`2<string, Instance> _instances;
    private Type _pluginType;
    private Lazy`1<Instance> _defaultInstance;
    private Instance _missingInstance;
    [CompilerGeneratedAttribute]
private PluginGraph <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance <Fallback>k__BackingField;
    public PluginGraph Owner { get; internal set; }
    public IEnumerable`1<Instance> Instances { get; }
    public bool IsGenericTemplate { get; }
    public Instance MissingInstance { get; public set; }
    public Type PluginType { get; }
    public Instance Fallback { get; public set; }
    public Policies Policies { get; }
    private PluginFamily(Type pluginType, object default);
    public PluginFamily(Type pluginType);
    [CompilerGeneratedAttribute]
public PluginGraph get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(PluginGraph value);
    public IEnumerable`1<Instance> get_Instances();
    public bool get_IsGenericTemplate();
    public Instance get_MissingInstance();
    public void set_MissingInstance(Instance value);
    public Type get_PluginType();
    private sealed virtual override void System.IDisposable.Dispose();
    private void resetDefault();
    public void AddInstance(Instance instance);
    private void assertInstanceIsValidForThisPluginType(Instance instance);
    public void SetDefault(Instance instance);
    [CompilerGeneratedAttribute]
public Instance get_Fallback();
    [CompilerGeneratedAttribute]
public void set_Fallback(Instance value);
    public Instance GetInstance(string name);
    public Instance GetDefaultInstance();
    private Instance determineDefault();
    public PluginFamily CreateTemplatedClone(Type[] templateTypes);
    private bool hasType(Type concreteType);
    public void AddType(Type concreteType);
    public Policies get_Policies();
    public void AddType(Type concreteType, string name);
    public void RemoveInstance(Instance instance);
    public void RemoveAll();
    internal static PluginFamily ExplicitOverride(Type pluginType, object default);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(StructureMapAttribute a);
    [CompilerGeneratedAttribute]
private Instance <.ctor>b__5_1(string name);
}
public class StructureMap.Graph.PluginGraph : object {
    private ConcurrentDictionary`2<Type, PluginFamily> _families;
    private IList`1<IFamilyPolicy> _policies;
    private ConcurrentDictionary`2<Type, bool> _missingTypes;
    private List`1<Registry> _registries;
    private LifecycleObjectCache _singletonCache;
    private LightweightCache`2<string, PluginGraph> _profiles;
    public TransientTracking TransientTracking;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Policies Policies;
    public IList`1<Type> ConnectedConcretions;
    [CompilerGeneratedAttribute]
private PluginGraph <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProfileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRunningConfigure>k__BackingField;
    public Queue`1<Registry> QueuedRegistries;
    public string Name { get; public set; }
    public PluginGraph Parent { get; private set; }
    public string ProfileName { get; private set; }
    public LifecycleObjectCache SingletonCache { get; }
    public IEnumerable`1<PluginGraph> Profiles { get; }
    private PluginFamily StructureMap.Graph.IFamilyCollection.Item { get; private set; }
    internal List`1<Registry> Registries { get; }
    public IFamilyCollection Families { get; }
    public PluginGraph Root { get; }
    internal bool IsRunningConfigure { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public static PluginGraph CreateRoot(string profile);
    internal void addCloseGenericPolicyTo();
    internal PluginGraph NewChild();
    internal PluginGraph ToNestedGraph();
    [CompilerGeneratedAttribute]
public PluginGraph get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(PluginGraph value);
    [CompilerGeneratedAttribute]
public string get_ProfileName();
    [CompilerGeneratedAttribute]
private void set_ProfileName(string value);
    public LifecycleObjectCache get_SingletonCache();
    public PluginGraph Profile(string name);
    public IEnumerable`1<PluginGraph> get_Profiles();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<PluginFamily> System.Collections.Generic.IEnumerable<StructureMap.Graph.PluginFamily>.GetEnumerator();
    private sealed virtual override PluginFamily StructureMap.Graph.IFamilyCollection.get_Item(Type pluginType);
    private sealed virtual override void StructureMap.Graph.IFamilyCollection.set_Item(Type pluginType, PluginFamily value);
    private sealed virtual override bool StructureMap.Graph.IFamilyCollection.Has(Type pluginType);
    public void AddFamilyPolicy(IFamilyPolicy policy);
    internal List`1<Registry> get_Registries();
    public IFamilyCollection get_Families();
    public PluginGraph get_Root();
    [CompilerGeneratedAttribute]
internal bool get_IsRunningConfigure();
    [CompilerGeneratedAttribute]
internal void set_IsRunningConfigure(bool value);
    public virtual void AddType(Type pluginType, Type concreteType);
    public virtual void AddType(Type pluginType, Type concreteType, string name);
    public void ImportRegistry(Type type);
    public void ImportRegistry(Registry registry);
    public void AddFamily(PluginFamily family);
    public bool HasInstance(Type pluginType, string name);
    internal PluginFamily FindExistingOrCreateFamily(Type pluginType);
    public bool HasFamily(Type pluginType);
    public bool HasDefaultForPluginType(Type pluginType);
    public void EjectFamily(Type pluginType);
    internal void EachInstance(Action`2<Type, Instance> action);
    public Instance FindInstance(Type pluginType, string name);
    public IEnumerable`1<Instance> AllInstances(Type pluginType);
    private sealed virtual override void System.IDisposable.Dispose();
    internal void ClearTypeMisses();
    [CompilerGeneratedAttribute]
private PluginGraph <.ctor>b__17_0(string name);
    [CompilerGeneratedAttribute]
private PluginFamily <StructureMap.Graph.IFamilyCollection.get_Item>b__34_0(Type type);
    [CompilerGeneratedAttribute]
private void <System.IDisposable.Dispose>b__62_0(KeyValuePair`2<Type, PluginFamily> family);
}
public class StructureMap.Graph.Scanning.AssemblyScanRecord : object {
    public string Name;
    public Exception LoadException;
    public virtual string ToString();
}
public class StructureMap.Graph.Scanning.AssemblyShelf : object {
    public IList`1<Type> Interfaces;
    public IList`1<Type> Concretes;
    public IList`1<Type> Abstracts;
    [IteratorStateMachineAttribute("StructureMap.Graph.Scanning.AssemblyShelf/<SelectLists>d__3")]
public IEnumerable`1<IList`1<Type>> SelectLists(TypeClassification classification);
    public IEnumerable`1<Type> AllTypes();
    public void Add(Type type);
}
public class StructureMap.Graph.Scanning.AssemblyTypes : object {
    private AssemblyScanRecord _record;
    public AssemblyShelf ClosedTypes;
    public AssemblyShelf OpenTypes;
    public AssemblyScanRecord Record { get; }
    public AssemblyTypes(Assembly assembly);
    public AssemblyTypes(string name, Func`1<IEnumerable`1<Type>> typeSource);
    public AssemblyScanRecord get_Record();
    public IEnumerable`1<Type> FindTypes(TypeClassification classification);
    private IEnumerable`1<Type> allTypes(IList`1[] shelves);
    private IEnumerable`1<IList`1<Type>> selectGroups(TypeClassification classification);
    [IteratorStateMachineAttribute("StructureMap.Graph.Scanning.AssemblyTypes/<selectShelves>d__10")]
private IEnumerable`1<AssemblyShelf> selectShelves(TypeClassification classification);
}
[FlagsAttribute]
public enum StructureMap.Graph.Scanning.TypeClassification : Enum {
    public short value__;
    public static TypeClassification All;
    public static TypeClassification Open;
    public static TypeClassification Closed;
    public static TypeClassification Interfaces;
    public static TypeClassification Abstracts;
    public static TypeClassification Concretes;
}
public class StructureMap.Graph.Scanning.TypeQuery : object {
    private TypeClassification _classification;
    public Func`2<Type, bool> Filter;
    public TypeQuery(TypeClassification classification, Func`2<Type, bool> filter);
    public IEnumerable`1<Type> Find(AssemblyTypes assembly);
}
public static class StructureMap.Graph.Scanning.TypeRepository : object {
    private static ConcurrentDictionary`2<Assembly, Task`1<AssemblyTypes>> _assemblies;
    private static TypeRepository();
    public static void ClearAll();
    public static void AssertNoTypeScanningFailures();
    public static IEnumerable`1<AssemblyTypes> FailedAssemblies();
    public static Task`1<AssemblyTypes> ForAssembly(Assembly assembly);
    public static Task`1<TypeSet> FindTypes(IEnumerable`1<Assembly> assemblies, Func`2<Type, bool> filter);
    public static Task`1<IEnumerable`1<Type>> FindTypes(IEnumerable`1<Assembly> assemblies, TypeClassification classification, Func`2<Type, bool> filter);
    public static Task`1<IEnumerable`1<Type>> FindTypes(Assembly assembly, TypeClassification classification, Func`2<Type, bool> filter);
}
public class StructureMap.Graph.Scanning.TypeSet : object {
    private IEnumerable`1<AssemblyTypes> _allTypes;
    private Func`2<Type, bool> _filter;
    public IEnumerable`1<AssemblyScanRecord> Records { get; }
    public TypeSet(IEnumerable`1<AssemblyTypes> allTypes, Func`2<Type, bool> filter);
    public IEnumerable`1<AssemblyScanRecord> get_Records();
    public IEnumerable`1<Type> FindTypes(TypeClassification classification);
    public IEnumerable`1<Type> AllTypes();
}
public class StructureMap.Graph.SetterRules : object {
    private List`1<Func`2<PropertyInfo, bool>> _setterRules;
    public void Clear();
    public void Add(Func`2<PropertyInfo, bool> predicate);
    public void Add(IEnumerable`1<Func`2<PropertyInfo, bool>> rules);
    public bool IsMandatory(PropertyInfo propertyInfo);
}
internal class StructureMap.GraphEjector : object {
    private PluginGraph _pluginGraph;
    private ILifecycleContext _lifecycles;
    public GraphEjector(PluginGraph pluginGraph, ILifecycleContext lifecycles);
    public sealed virtual void EjectAllInstancesOf();
    public sealed virtual void RemoveCompletely(Func`2<Type, bool> filter);
    public sealed virtual void RemoveCompletely(Type pluginType);
    public sealed virtual void RemoveFromLifecycle(Type pluginType, Instance instance);
    public sealed virtual void RemoveCompletely(Type pluginType, Instance instance);
}
public interface StructureMap.IBuildSession {
    public Policies Policies { get; }
    public abstract virtual object BuildNewInSession(Type pluginType, Instance instance);
    public abstract virtual object BuildNewInOriginalContext(Type pluginType, Instance instance);
    public abstract virtual object ResolveFromLifecycle(Type pluginType, Instance instance);
    public abstract virtual Policies get_Policies();
    public abstract virtual object CreateInstance(Type pluginType, string name);
    public abstract virtual void Push(Instance instance);
    public abstract virtual void Pop();
    public abstract virtual object BuildUnique(Type pluginType, Instance instance);
}
public interface StructureMap.IContainer {
    public IModel Model { get; }
    public string Name { get; public set; }
    public ContainerRole Role { get; }
    public string ProfileName { get; }
    public ITransientTracking TransientTracking { get; }
    public DisposalLock DisposalLock { get; public set; }
    public abstract virtual IModel get_Model();
    public abstract virtual T GetInstance();
    public abstract virtual T GetInstance(string instanceKey);
    public abstract virtual T GetInstance(Instance instance);
    public abstract virtual object GetInstance(Type pluginType);
    public abstract virtual object GetInstance(Type pluginType, string instanceKey);
    public abstract virtual object GetInstance(Type pluginType, Instance instance);
    public abstract virtual IEnumerable`1<T> GetAllInstances();
    public abstract virtual IEnumerable GetAllInstances(Type pluginType);
    public abstract virtual T TryGetInstance();
    public abstract virtual T TryGetInstance(string instanceKey);
    public abstract virtual object TryGetInstance(Type pluginType);
    public abstract virtual object TryGetInstance(Type pluginType, string instanceKey);
    public abstract virtual IEnumerable`1<T> GetAllInstances(ExplicitArguments args);
    public abstract virtual IEnumerable GetAllInstances(Type pluginType, ExplicitArguments args);
    public abstract virtual T GetInstance(ExplicitArguments args);
    public abstract virtual T GetInstance(ExplicitArguments args, string instanceKey);
    public abstract virtual object GetInstance(Type pluginType, ExplicitArguments args);
    public abstract virtual object GetInstance(Type pluginType, ExplicitArguments args, string instanceKey);
    public abstract virtual T TryGetInstance(ExplicitArguments args);
    public abstract virtual T TryGetInstance(ExplicitArguments args, string instanceKey);
    public abstract virtual object TryGetInstance(Type pluginType, ExplicitArguments args);
    public abstract virtual object TryGetInstance(Type pluginType, ExplicitArguments args, string instanceKey);
    public abstract virtual void EjectAllInstancesOf();
    public abstract virtual void BuildUp(object target);
    public abstract virtual OpenGenericTypeExpression ForGenericType(Type templateType);
    public abstract virtual ExplicitArgsExpression With(Type pluginType, object arg);
    public abstract virtual ExplicitArgsExpression With(Action`1<IExplicitArgsExpression> action);
    public abstract virtual ExplicitArgsExpression With(T arg);
    public abstract virtual IExplicitProperty With(string argName);
    public abstract virtual CloseGenericTypeExpression ForObject(object subject);
    public abstract virtual void Configure(Action`1<ConfigurationExpression> configure);
    public abstract virtual void Inject(T instance);
    public abstract virtual void Inject(Type pluginType, object instance);
    public abstract virtual IContainer GetProfile(string profileName);
    public abstract virtual string WhatDoIHave(Type pluginType, Assembly assembly, string namespace, string typeName);
    public abstract virtual string WhatDidIScan();
    public abstract virtual void AssertConfigurationIsValid();
    public abstract virtual IContainer GetNestedContainer();
    public abstract virtual IContainer GetNestedContainer(string profileName);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual ContainerRole get_Role();
    public abstract virtual string get_ProfileName();
    public abstract virtual IContainer CreateChildContainer();
    public abstract virtual ITransientTracking get_TransientTracking();
    public abstract virtual void Release(object object);
    public abstract virtual DisposalLock get_DisposalLock();
    public abstract virtual void set_DisposalLock(DisposalLock value);
    public abstract virtual IContainer GetNestedContainer(TypeArguments arguments);
}
public interface StructureMap.IContext {
    public string RequestedName { get; }
    public Type ParentType { get; }
    public Type RootType { get; }
    public abstract virtual string get_RequestedName();
    public abstract virtual void BuildUp(object target);
    public abstract virtual T GetInstance();
    public abstract virtual T GetInstance(string name);
    public abstract virtual object GetInstance(Type pluginType);
    public abstract virtual object GetInstance(Type pluginType, string instanceKey);
    public abstract virtual T TryGetInstance();
    public abstract virtual T TryGetInstance(string name);
    public abstract virtual object TryGetInstance(Type pluginType);
    public abstract virtual object TryGetInstance(Type pluginType, string instanceKey);
    public abstract virtual IEnumerable`1<T> All();
    public abstract virtual IEnumerable`1<T> GetAllInstances();
    public abstract virtual IEnumerable`1<object> GetAllInstances(Type pluginType);
    public abstract virtual Type get_ParentType();
    public abstract virtual Type get_RootType();
}
public interface StructureMap.IExplicitArgsExpression {
    public abstract virtual ExplicitArgsExpression With(T arg);
    public abstract virtual ExplicitArgsExpression With(Type pluginType, object arg);
    public abstract virtual IExplicitProperty With(string argName);
}
public interface StructureMap.IExplicitProperty {
    public abstract virtual ExplicitArgsExpression EqualTo(object value);
}
public interface StructureMap.IGraphEjector {
    public abstract virtual void EjectAllInstancesOf();
    public abstract virtual void RemoveCompletely(Func`2<Type, bool> filter);
    public abstract virtual void RemoveCompletely(Type pluginType);
    public abstract virtual void RemoveFromLifecycle(Type pluginType, Instance instance);
    public abstract virtual void RemoveCompletely(Type pluginType, Instance instance);
}
public interface StructureMap.IInstanceGraph {
    public ContainerRole Role { get; }
    public PluginGraph ImmediatePluginGraph { get; }
    public abstract virtual Instance GetDefault(Type pluginType);
    public abstract virtual bool HasDefaultForPluginType(Type pluginType);
    public abstract virtual bool HasInstance(Type pluginType, string instanceKey);
    public abstract virtual void EachInstance(Action`2<Type, Instance> action);
    public abstract virtual IEnumerable`1<Instance> GetAllInstances();
    public abstract virtual IEnumerable`1<Instance> GetAllInstances(Type pluginType);
    public abstract virtual Instance FindInstance(Type pluginType, string name);
    public abstract virtual IEnumerable`1<PluginFamily> UniqueFamilies();
    public abstract virtual ILifecycle DefaultLifecycleFor(Type pluginType);
    public abstract virtual ContainerRole get_Role();
    public abstract virtual IEnumerable`1<Instance> ImmediateInstances();
    public abstract virtual PluginGraph get_ImmediatePluginGraph();
}
public interface StructureMap.IInstancePolicy {
    public abstract virtual void Apply(Type pluginType, Instance instance);
}
public interface StructureMap.ILifecycleContext {
    public IObjectCache Singletons { get; }
    public ITransientTracking Transients { get; }
    public IObjectCache ContainerCache { get; }
    public abstract virtual IObjectCache get_Singletons();
    public abstract virtual ITransientTracking get_Transients();
    public abstract virtual IObjectCache get_ContainerCache();
    public abstract virtual ILifecycle DetermineLifecycle(Type pluginType, Instance instance);
}
internal class StructureMap.InterceptionPolicy : object {
    [CompilerGeneratedAttribute]
private IInterceptorPolicy <Inner>k__BackingField;
    public IInterceptorPolicy Inner { get; }
    public InterceptionPolicy(IInterceptorPolicy inner);
    public sealed virtual void Apply(Type pluginType, Instance instance);
    [CompilerGeneratedAttribute]
public IInterceptorPolicy get_Inner();
}
public interface StructureMap.IPipelineGraph {
    public IInstanceGraph Instances { get; }
    public string Profile { get; }
    public ContainerRole Role { get; }
    public IGraphEjector Ejector { get; }
    public Policies Policies { get; }
    public Profiles Profiles { get; }
    public abstract virtual IInstanceGraph get_Instances();
    public abstract virtual IModel ToModel();
    public abstract virtual string get_Profile();
    public abstract virtual ContainerRole get_Role();
    public abstract virtual IGraphEjector get_Ejector();
    public abstract virtual Policies get_Policies();
    public abstract virtual IPipelineGraph Root();
    public abstract virtual Profiles get_Profiles();
    public abstract virtual IPipelineGraph ToNestedGraph(TypeArguments arguments);
    public abstract virtual void RegisterContainer(IContainer container);
    public abstract virtual void Configure(Action`1<ConfigurationExpression> configure);
    public abstract virtual void ValidateValidNestedScoping();
    public abstract virtual void TrackDisposable(IDisposable disposable);
}
public interface StructureMap.IProfileRegistry {
    public abstract virtual void Forward();
    public abstract virtual CreatePluginFamilyExpression`1<TPluginType> For(ILifecycle lifecycle);
    public abstract virtual GenericFamilyExpression For(Type pluginType, ILifecycle lifecycle);
    public abstract virtual LambdaInstance`2<T, T> Redirect();
}
public interface StructureMap.IRegistry {
    public PoliciesExpression Policies { get; }
    public abstract virtual void AddType(Type pluginType, Type concreteType);
    public abstract virtual void AddType(Type pluginType, Type concreteType, string name);
    public abstract virtual void IncludeRegistry();
    public abstract virtual void IncludeRegistry(Registry registry);
    public abstract virtual BuildWithExpression`1<T> ForConcreteType();
    public abstract virtual CreatePluginFamilyExpression`1<TPluginType> ForSingletonOf();
    public abstract virtual GenericFamilyExpression ForSingletonOf(Type pluginType);
    public abstract virtual void Profile(string profileName, Action`1<IProfileRegistry> action);
    public abstract virtual void Scan(Action`1<IAssemblyScanner> action);
    public abstract virtual void Configure(Action`1<PluginGraph> configure);
    public abstract virtual PoliciesExpression get_Policies();
}
public interface StructureMap.ISessionCache {
    public abstract virtual object GetDefault(Type pluginType, IPipelineGraph pipelineGraph);
    public abstract virtual object GetObject(Type pluginType, Instance instance, ILifecycle lifecycle);
    public abstract virtual object TryGetDefault(Type pluginType, IPipelineGraph pipelineGraph);
    public abstract virtual IEnumerable`1<T> All();
}
public interface StructureMap.OpenGenericTypeListSpecificationExpression {
    public abstract virtual IList`1<T> As();
}
public interface StructureMap.OpenGenericTypeSpecificationExpression {
    public abstract virtual T As();
}
public class StructureMap.Pipeline.Argument : object {
    public string Name;
    public Type Type;
    public object Dependency;
    public Argument CloseType(Type[] types);
    public virtual string ToString();
}
public class StructureMap.Pipeline.ArrayCoercion`1 : object {
    public Type ElementType { get; }
    public sealed virtual object Convert(IEnumerable`1<object> enumerable);
    public sealed virtual Type get_ElementType();
}
public class StructureMap.Pipeline.ArrayDefinitionExpression`2 : object {
    private TInstance _instance;
    private string _propertyName;
    internal ArrayDefinitionExpression`2(TInstance instance, string propertyName);
    public TInstance Contains(Action`1<IInstanceExpression`1<TElementType>> action);
    public TInstance Contains(Instance[] children);
}
public class StructureMap.Pipeline.AttributeConstructorSelector : object {
    public sealed virtual ConstructorInfo Find(Type pluggedType, DependencyCollection dependencies, PluginGraph graph);
}
public class StructureMap.Pipeline.ChildContainerSingletonLifecycle : LifecycleBase {
    private IObjectCache _cache;
    public ChildContainerSingletonLifecycle(IObjectCache cache);
    public virtual void EjectAll(ILifecycleContext context);
    public virtual IObjectCache FindCache(ILifecycleContext context);
}
public class StructureMap.Pipeline.ConfiguredInstance : ConstructorInstance`1<ConfiguredInstance> {
    protected ConfiguredInstance thisInstance { get; }
    public ConfiguredInstance(Type pluggedType, string name);
    public ConfiguredInstance(Type pluggedType);
    public ConfiguredInstance(Type templateType, Type[] types);
    public ConfiguredInstance(Type pluggedType, string name, DependencyCollection dependencies, IEnumerable`1<IInterceptor> interceptors, ConstructorInfo constructor);
    protected virtual ConfiguredInstance thisObject();
    protected virtual ConfiguredInstance get_thisInstance();
}
[ExtensionAttribute]
public static class StructureMap.Pipeline.ConfiguredInstanceExtensions : object {
    [ExtensionAttribute]
public static IConfiguredInstance Singleton(IConfiguredInstance instance);
    [ExtensionAttribute]
public static IConfiguredInstance DefaultLifecycle(IConfiguredInstance instance);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> SettableProperties(IConfiguredInstance instance);
}
public class StructureMap.Pipeline.ConstructorInstance : ConstructorInstance`1<ConstructorInstance> {
    protected ConstructorInstance thisInstance { get; }
    public ConstructorInstance(Type concreteType);
    public ConstructorInstance(Type pluggedType, string name);
    protected virtual ConstructorInstance get_thisInstance();
    protected virtual ConstructorInstance thisObject();
}
public abstract class StructureMap.Pipeline.ConstructorInstance`1 : ExpressedInstance`1<TThis> {
    [CompilerGeneratedAttribute]
private ConstructorInfo <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PluggedType>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyCollection <Dependencies>k__BackingField;
    public ConstructorInfo Constructor { get; public set; }
    public Type PluggedType { get; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public DependencyCollection Dependencies { get; }
    public ConstructorInstance`1(Type concreteType);
    public ConstructorInstance`1(Type pluggedType, string name);
    public virtual Instance ToNamedClone(string name);
    [CompilerGeneratedAttribute]
public sealed virtual ConstructorInfo get_Constructor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Constructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_PluggedType();
    public virtual IDependencySource ToBuilder(Type pluginType, Policies policies);
    public sealed virtual Instance Override(ExplicitArguments arguments);
    public virtual string get_Description();
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual Type get_ReturnedType();
    public static ConstructorInstance For();
    public virtual Instance CloseType(Type[] types);
    [CompilerGeneratedAttribute]
public sealed virtual DependencyCollection get_Dependencies();
    public virtual string ToString();
    public DependencyExpression`2<TThis, TCtorType> Ctor();
    public DependencyExpression`2<TThis, TCtorType> Ctor(string constructorArg);
    protected abstract virtual TThis thisObject();
    public DependencyExpression`2<TThis, TSetterType> Setter();
    public DependencyExpression`2<TThis, TSetterType> Setter(string setterName);
    public ArrayDefinitionExpression`2<TThis, TElement> EnumerableOf();
    public ArrayDefinitionExpression`2<TThis, TElement> EnumerableOf(string ctorOrPropertyName);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0_0(StructureMapAttribute x);
}
public class StructureMap.Pipeline.ConstructorSelector : ConfiguredInstancePolicy {
    private PluginGraph _graph;
    private IList`1<IConstructorSelector> _selectors;
    private IConstructorSelector[] _defaults;
    public ConstructorSelector(PluginGraph graph);
    protected virtual void apply(Type pluginType, IConfiguredInstance instance);
    public void Add(IConstructorSelector selector);
    public ConstructorInfo Select(Type pluggedType, DependencyCollection dependencies);
}
public class StructureMap.Pipeline.ContainerLifecycle : LifecycleBase {
    public virtual void EjectAll(ILifecycleContext context);
    public virtual IObjectCache FindCache(ILifecycleContext context);
}
public class StructureMap.Pipeline.ContainerSpecificObjectCache : LifecycleObjectCache {
    public IEnumerable`1<object> Tracked { get; }
    protected virtual object buildWithSession(Type pluginType, Instance instance, IBuildSession session);
    public sealed virtual void Release(object o);
    public sealed virtual IEnumerable`1<object> get_Tracked();
}
public class StructureMap.Pipeline.DefaultInstance : Instance {
    public Type ReturnedType { get; }
    public string Description { get; }
    public virtual Type get_ReturnedType();
    public virtual string get_Description();
    public virtual Instance ToNamedClone(string name);
    public virtual IDependencySource ToDependencySource(Type pluginType);
}
public class StructureMap.Pipeline.DependencyCollection : object {
    private List`1<Argument> _dependencies;
    public void AddForConstructorParameter(ParameterInfo parameter, object valueOrInstance);
    public void AddForProperty(PropertyInfo property, object valueOrInstance);
    public object FindByTypeOrName(Type argumentType, string name);
    private Argument findByName(string name);
    private Argument findByTypeOnly(Type argumentType);
    private Argument findByAll(Type argumentType, string name);
    private bool isMatchOnNullableInnerType(Type argumentType, Type dependencyType);
    public void Add(T valueOrInstance);
    public void Add(Instance instance);
    public void Add(Type type, object dependency);
    public void Add(string name, IEnumerable`1<Instance> items);
    public void Add(string name, object dependency);
    public void Insert(Argument argument);
    public void Add(string name, Type type, object dependency);
    public void RemoveByName(string name);
    public bool Has(string propertyName);
    public DependencyCollection Clone();
    public void CopyTo(DependencyCollection peer);
    public sealed virtual IEnumerator`1<Argument> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(Argument argument);
    public object Get(string name);
    public object FindByTypeAndName(Type propertyType, string name);
    public bool HasAny();
}
public class StructureMap.Pipeline.DependencyExpression`2 : object {
    private TInstance _instance;
    private string _propertyName;
    internal DependencyExpression`2(TInstance instance, string propertyName);
    public TInstance IsSpecial(Action`1<IInstanceExpression`1<TChild>> action);
    public TInstance Is(Expression`1<Func`1<TChild>> func);
    public TInstance Is(string description, Func`1<TChild> func);
    public TInstance Is(Expression`1<Func`2<IContext, TChild>> func);
    public TInstance Is(string description, Func`2<IContext, TChild> func);
    public TInstance Is(Instance instance);
    public TInstance Is(TChild value);
    public TInstance IsTheDefault();
    public TInstance IsNamedInstance(string instanceKey);
    public TInstance Is();
    public TInstance Is(Action`1<SmartInstance`2<TConcreteType, TChild>> configure);
    public TInstance Named(string name);
    [CompilerGeneratedAttribute]
private void <IsSpecial>b__3_0(Instance i);
}
public class StructureMap.Pipeline.EnumerableInstance : Instance {
    private static List`1<Type> _enumerableTypes;
    private IEnumerable`1<Instance> _children;
    public Type ReturnedType { get; }
    public static IEnumerable`1<Type> OpenEnumerableTypes { get; }
    public IEnumerable`1<Instance> Children { get; }
    public string Description { get; }
    public EnumerableInstance(IEnumerable`1<Instance> children);
    private static EnumerableInstance();
    public virtual Type get_ReturnedType();
    public static IEnumerable`1<Type> get_OpenEnumerableTypes();
    public static Type DetermineElementType(Type pluginType);
    public IEnumerable`1<Instance> get_Children();
    public static IEnumerableCoercion DetermineCoercion(Type propertyType);
    private static Type determineCoercionType(Type propertyType);
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual string get_Description();
    public static bool IsEnumerable(Type type);
}
public class StructureMap.Pipeline.ExplicitArguments : object {
    private IDictionary`2<string, object> _args;
    [CompilerGeneratedAttribute]
private IDictionary`2<Type, object> <Defaults>k__BackingField;
    public IDictionary`2<Type, object> Defaults { get; }
    public ExplicitArguments(IDictionary`2<string, object> args);
    [CompilerGeneratedAttribute]
public IDictionary`2<Type, object> get_Defaults();
    public T Get();
    public object Get(Type type);
    public ExplicitArguments Set(T arg);
    public ExplicitArguments Set(Type pluginType, object arg);
    public void SetArg(string key, object argValue);
    public object GetArg(string key);
    public void Configure(IConfiguredInstance instance);
    public bool Has(Type type);
    public bool Has(string propertyName);
    public virtual string ToString();
    public bool OnlyNeedsDefaults();
}
public abstract class StructureMap.Pipeline.ExpressedInstance`1 : Instance {
    protected T thisInstance { get; }
    protected abstract virtual T get_thisInstance();
    public T Named(string instanceKey);
    public T InterceptWith(IInterceptor interceptor);
    public T Singleton();
    public T ContainerScoped();
    public T AlwaysUnique();
    public T Transient();
    public T LifecycleIs();
}
public abstract class StructureMap.Pipeline.ExpressedInstance`3 : ExpressedInstance`1<T> {
    public T OnCreation(Expression`1<Action`1<TReturned>> handler);
    public T OnCreation(string description, Action`1<TReturned> handler);
    public T OnCreation(Expression`1<Action`2<IContext, TReturned>> handler);
    public T OnCreation(string description, Action`2<IContext, TReturned> handler);
    public T DecorateWith(Expression`1<Func`2<TPluginType, TPluginType>> handler);
    public T DecorateWith(string description, Func`2<TPluginType, TPluginType> handler);
    public T DecorateWith(Expression`1<Func`3<IContext, TPluginType, TPluginType>> handler);
    public T DecorateWith(string description, Func`3<IContext, TPluginType, TPluginType> handler);
}
public class StructureMap.Pipeline.FirstConstructor : object {
    public sealed virtual ConstructorInfo Find(Type pluggedType, DependencyCollection dependencies, PluginGraph graph);
}
public class StructureMap.Pipeline.GreediestConstructorSelector : object {
    public sealed virtual ConstructorInfo Find(Type pluggedType, DependencyCollection dependencies, PluginGraph graph);
    public static bool HasMissingPrimitives(ConstructorInfo ctor, DependencyCollection dependencies);
}
public interface StructureMap.Pipeline.IAppropriateForNestedContainer {
}
public interface StructureMap.Pipeline.IConfiguredInstance {
    public string Name { get; public set; }
    public Type PluggedType { get; }
    public DependencyCollection Dependencies { get; }
    public ILifecycle Lifecycle { get; }
    public ConstructorInfo Constructor { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual Type get_PluggedType();
    public abstract virtual DependencyCollection get_Dependencies();
    public abstract virtual void AddInterceptor(IInterceptor interceptor);
    public abstract virtual void SetLifecycleTo();
    public abstract virtual void SetLifecycleTo(ILifecycle lifecycle);
    public abstract virtual ILifecycle get_Lifecycle();
    public abstract virtual ConstructorInfo get_Constructor();
    public abstract virtual void set_Constructor(ConstructorInfo value);
    public abstract virtual bool HasBuildPlan();
    public abstract virtual void ClearBuildPlan();
}
public interface StructureMap.Pipeline.IConstructorSelector {
    public abstract virtual ConstructorInfo Find(Type pluggedType, DependencyCollection dependencies, PluginGraph graph);
}
public interface StructureMap.Pipeline.IEnumerableCoercion {
    public Type ElementType { get; }
    public abstract virtual Type get_ElementType();
    public abstract virtual object Convert(IEnumerable`1<object> enumerable);
}
public interface StructureMap.Pipeline.ILifecycle {
    public string Description { get; }
    public abstract virtual string get_Description();
    public abstract virtual void EjectAll(ILifecycleContext context);
    public abstract virtual IObjectCache FindCache(ILifecycleContext context);
}
public interface StructureMap.Pipeline.ILocationPolicy {
    public abstract virtual object Build(BuildSession session, Instance instance);
}
public abstract class StructureMap.Pipeline.Instance : HasLifecycle {
    internal IList`1<IInstancePolicy> AppliedPolicies;
    private string _originalName;
    private int _hashCode;
    private string _name;
    private IList`1<IInterceptor> _interceptors;
    private ConcurrentDictionary`2<Type, int> _hashCodes;
    private object _buildLock;
    private IBuildPlan _plan;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public IEnumerable`1<IInterceptor> Interceptors { get; }
    public string Name { get; public set; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public Guid Id { get; private set; }
    public sealed virtual void AddInterceptor(IInterceptor interceptor);
    public abstract virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual IDependencySource ToBuilder(Type pluginType, Policies policies);
    public IEnumerable`1<IInterceptor> get_Interceptors();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public abstract virtual string get_Description();
    public InstanceToken CreateToken();
    public abstract virtual Type get_ReturnedType();
    public virtual bool HasExplicitName();
    public virtual Instance CloseType(Type[] types);
    public IBuildPlan ResolveBuildPlan(Type pluginType, Policies policies);
    public sealed virtual void ClearBuildPlan();
    public sealed virtual bool HasBuildPlan();
    private string toDescription(Type pluginType);
    public void ApplyAllPolicies(Type pluginType, Policies policies);
    protected virtual IBuildPlan buildPlan(Type pluginType, Policies policies);
    public int InstanceKey(Type pluginType);
    public ILifecycle DetermineLifecycle(ILifecycle parent);
    protected bool Equals(Instance other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    public virtual Instance ToNamedClone(string name);
}
public interface StructureMap.Pipeline.IObjectCache {
    public int Count { get; }
    public abstract virtual object Get(Type pluginType, Instance instance, IBuildSession session);
    public abstract virtual int get_Count();
    public abstract virtual bool Has(Type pluginType, Instance instance);
    public abstract virtual void Eject(Type pluginType, Instance instance);
    public abstract virtual void DisposeAndClear();
}
internal interface StructureMap.Pipeline.IOverridableInstance {
    public abstract virtual Instance Override(ExplicitArguments arguments);
}
public interface StructureMap.Pipeline.ITransientTracking {
    public IEnumerable`1<object> Tracked { get; }
    public abstract virtual void Release(object o);
    public abstract virtual IEnumerable`1<object> get_Tracked();
}
public interface StructureMap.Pipeline.IValue {
    public object Value { get; }
    public abstract virtual object get_Value();
}
public interface StructureMap.Pipeline.LambdaInstance {
    public Type ReturnedType { get; }
    public abstract virtual Type get_ReturnedType();
}
public class StructureMap.Pipeline.LambdaInstance`1 : LambdaInstance`2<T, T> {
    public LambdaInstance`1(Expression`1<Func`2<IContext, T>> builder);
    public LambdaInstance`1(Expression`1<Func`1<T>> func);
    public LambdaInstance`1(string description, Func`2<IContext, T> builder);
    public LambdaInstance`1(string description, Func`1<T> builder);
}
public class StructureMap.Pipeline.LambdaInstance`2 : ExpressedInstance`3<LambdaInstance`2<T, TPluginType>, T, TPluginType> {
    private Expression _builder;
    private string _description;
    protected LambdaInstance`2<T, TPluginType> thisInstance { get; }
    public Type ReturnedType { get; }
    public string Description { get; }
    public LambdaInstance`2(Expression`1<Func`2<IContext, T>> builder);
    private LambdaInstance`2(string description, Expression builder);
    public LambdaInstance`2(Expression`1<Func`1<T>> func);
    public LambdaInstance`2(string description, Func`2<IContext, T> builder);
    public LambdaInstance`2(string description, Func`1<T> builder);
    public virtual Instance ToNamedClone(string name);
    protected virtual LambdaInstance`2<T, TPluginType> get_thisInstance();
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public sealed virtual Expression ToExpression(ParameterExpression session, ParameterExpression context);
    public virtual Type get_ReturnedType();
    private sealed virtual override void StructureMap.Building.IDependencySource.AcceptVisitor(IDependencyVisitor visitor);
    public virtual string get_Description();
    public virtual Instance CloseType(Type[] types);
}
public class StructureMap.Pipeline.Lazy.FuncFactoryTemplate : Instance {
    public string Description { get; }
    public Type ReturnedType { get; }
    public virtual string get_Description();
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual IDependencySource ToBuilder(Type pluginType, Policies policies);
    public virtual Type get_ReturnedType();
    public virtual Instance CloseType(Type[] types);
}
public class StructureMap.Pipeline.Lazy.FuncInstance`1 : LambdaInstance`1<Func`1<T>> {
    public string Description { get; }
    public virtual string get_Description();
}
public class StructureMap.Pipeline.Lazy.FuncWithArgFactoryTemplate : Instance {
    public string Description { get; }
    public Type ReturnedType { get; }
    public virtual string get_Description();
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual IDependencySource ToBuilder(Type pluginType, Policies policies);
    public virtual Type get_ReturnedType();
    public virtual Instance CloseType(Type[] types);
}
public class StructureMap.Pipeline.Lazy.FuncWithArgInstance`2 : LambdaInstance`1<Func`2<TIn, T>> {
    public string Description { get; }
    public virtual string get_Description();
}
public class StructureMap.Pipeline.Lazy.LazyFactoryTemplate : Instance {
    public string Description { get; }
    public Type ReturnedType { get; }
    public virtual string get_Description();
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual IDependencySource ToBuilder(Type pluginType, Policies policies);
    public virtual Type get_ReturnedType();
    public virtual Instance CloseType(Type[] types);
}
public class StructureMap.Pipeline.Lazy.LazyInstance`1 : LambdaInstance`1<Lazy`1<T>> {
    public string Description { get; }
    public virtual string get_Description();
}
[DebuggerDisplayAttribute("IsValueCreated={IsValueCreated}, Value={ValueForDebugView}")]
[DebuggerTypeProxyAttribute("StructureMap.Pipeline.LazyLifecycleObjectDebugView`1")]
public class StructureMap.Pipeline.LazyLifecycleObject`1 : object {
    private static object _usedThreadSafeObj;
    private static Func`1<T> _usedValueFactory;
    private Boxed<T> _boxed;
    private object _threadSafeObj;
    private Func`1<T> _valueFactory;
    public bool IsValueCreated { get; }
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    internal T ValueForDebugView { get; }
    public LazyLifecycleObject`1(Func`1<T> valueFactory);
    private static LazyLifecycleObject`1();
    public bool get_IsValueCreated();
    public T get_Value();
    internal T get_ValueForDebugView();
    public virtual string ToString();
    private T CreateValue();
}
[ExtensionAttribute]
public static class StructureMap.Pipeline.LazyLifecycleObjectCacheExtensions : object {
    [ExtensionAttribute]
public static TValue AddOrUpdate(ConcurrentDictionary`2<TKey, LazyLifecycleObject`1<TValue>> cache, TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    [ExtensionAttribute]
public static TValue GetOrAdd(ConcurrentDictionary`2<TKey, LazyLifecycleObject`1<TValue>> cache, TKey key, Func`2<TKey, TValue> valueFactory);
    [ExtensionAttribute]
public static bool TryGetValue(ConcurrentDictionary`2<TKey, LazyLifecycleObject`1<TValue>> cache, TKey key, TValue& value);
    [ExtensionAttribute]
public static bool TryRemove(ConcurrentDictionary`2<TKey, LazyLifecycleObject`1<TValue>> cache, TKey key, TValue& value);
}
internal class StructureMap.Pipeline.LazyLifecycleObjectDebugView`1 : object {
    private LazyLifecycleObject`1<T> _lazy;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public LazyLifecycleObjectDebugView`1(LazyLifecycleObject`1<T> lazy);
    public bool get_IsValueCreated();
    public T get_Value();
}
public abstract class StructureMap.Pipeline.LifecycleBase : object {
    public string Description { get; }
    public sealed virtual string get_Description();
    public abstract virtual void EjectAll(ILifecycleContext context);
    public abstract virtual IObjectCache FindCache(ILifecycleContext context);
}
public class StructureMap.Pipeline.LifecycleObjectCache : object {
    private ConcurrentDictionary`2<int, LazyLifecycleObject`1<object>> _objects;
    public int Count { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool Has(Type pluginType, Instance instance);
    public sealed virtual void Eject(Type pluginType, Instance instance);
    public sealed virtual object Get(Type pluginType, Instance instance, IBuildSession session);
    protected virtual object buildWithSession(Type pluginType, Instance instance, IBuildSession session);
    public sealed virtual void DisposeAndClear();
    public void Set(Type pluginType, Instance instance, object value);
}
public static class StructureMap.Pipeline.Lifecycles : object {
    private static LightweightCache`2<Type, ILifecycle> _lifecycles;
    public static ILifecycle Transient;
    public static ILifecycle Singleton;
    public static ILifecycle Unique;
    public static ILifecycle ThreadLocal;
    public static ILifecycle Container;
    private static Lifecycles();
    public static ILifecycle Register();
    public static ILifecycle Get();
}
public class StructureMap.Pipeline.LightweightObjectInstance : Instance {
    [CompilerGeneratedAttribute]
private object <Object>k__BackingField;
    public object Object { get; public set; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public LightweightObjectInstance(object object);
    [CompilerGeneratedAttribute]
public object get_Object();
    [CompilerGeneratedAttribute]
public void set_Object(object value);
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual string get_Description();
    public sealed virtual object Build(IBuildSession session, IContext context);
    public virtual Type get_ReturnedType();
    public sealed virtual void AcceptVisitor(IBuildPlanVisitor visitor);
    protected virtual IBuildPlan buildPlan(Type pluginType, Policies policies);
}
public class StructureMap.Pipeline.ListCoercion`1 : object {
    public Type ElementType { get; }
    public sealed virtual object Convert(IEnumerable`1<object> enumerable);
    public sealed virtual Type get_ElementType();
}
public class StructureMap.Pipeline.NullInstance : Instance {
    public string Description { get; }
    public Type ReturnedType { get; }
    public virtual string get_Description();
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual Type get_ReturnedType();
}
public class StructureMap.Pipeline.NulloTransientCache : object {
    public object Locker { get; }
    public int Count { get; }
    public IEnumerable`1<object> Tracked { get; }
    public object get_Locker();
    public sealed virtual int get_Count();
    public sealed virtual bool Has(Type pluginType, Instance instance);
    public sealed virtual void Eject(Type pluginType, Instance instance);
    public sealed virtual object Get(Type pluginType, Instance instance, IBuildSession session);
    public sealed virtual void DisposeAndClear();
    public sealed virtual void Release(object o);
    public sealed virtual IEnumerable`1<object> get_Tracked();
}
public class StructureMap.Pipeline.ObjectInstance : ObjectInstance`2<object, object> {
    public ObjectInstance(object anObject);
}
public class StructureMap.Pipeline.ObjectInstance`2 : ExpressedInstance`3<ObjectInstance`2<TReturned, TPluginType>, TReturned, TPluginType> {
    [CompilerGeneratedAttribute]
private TReturned <Object>k__BackingField;
    private object StructureMap.Pipeline.IValue.Value { get; }
    protected ObjectInstance`2<TReturned, TPluginType> thisInstance { get; }
    public TReturned Object { get; private set; }
    public string Description { get; }
    public Type ReturnedType { get; }
    public ObjectInstance`2(TReturned anObject);
    public virtual Instance ToNamedClone(string name);
    private sealed virtual override object StructureMap.Pipeline.IValue.get_Value();
    protected virtual ObjectInstance`2<TReturned, TPluginType> get_thisInstance();
    [CompilerGeneratedAttribute]
public TReturned get_Object();
    [CompilerGeneratedAttribute]
private void set_Object(TReturned value);
    public sealed virtual void Dispose();
    public virtual string get_Description();
    public virtual string ToString();
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual Type get_ReturnedType();
    protected virtual IBuildPlan buildPlan(Type pluginType, Policies policies);
    private sealed virtual override void StructureMap.Building.IBuildPlanVisitable.AcceptVisitor(IBuildPlanVisitor visitor);
    private sealed virtual override object StructureMap.Building.IBuildPlan.Build(IBuildSession session, IContext context);
}
public class StructureMap.Pipeline.ObjectLifecycle : LifecycleBase {
    public virtual void EjectAll(ILifecycleContext context);
    public virtual IObjectCache FindCache(ILifecycleContext context);
}
[ExtensionAttribute]
public static class StructureMap.Pipeline.ReaderWriterLockExtensions : object {
    [ExtensionAttribute]
public static void Write(ReaderWriterLockSlim rwLock, Action action);
    [ExtensionAttribute]
public static T Read(ReaderWriterLockSlim rwLock, Func`1<T> func);
    [ExtensionAttribute]
public static void MaybeWrite(ReaderWriterLockSlim theLock, Action action);
    [ExtensionAttribute]
public static T MaybeWrite(ReaderWriterLockSlim theLock, Func`1<T> answer, Func`1<bool> missingTest, Action write);
}
public class StructureMap.Pipeline.ReferencedInstance : Instance {
    private string _referenceKey;
    public string ReferenceKey { get; }
    public Type ReturnedType { get; }
    public string Description { get; }
    public ReferencedInstance(string referenceKey);
    public string get_ReferenceKey();
    public sealed virtual bool Equals(ReferencedInstance referencedInstance);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual Type get_ReturnedType();
    public virtual string get_Description();
    public virtual Instance CloseType(Type[] types);
    public virtual Instance ToNamedClone(string name);
}
public class StructureMap.Pipeline.SingletonLifecycle : LifecycleBase {
    public virtual void EjectAll(ILifecycleContext context);
    public virtual IObjectCache FindCache(ILifecycleContext context);
}
public class StructureMap.Pipeline.SmartInstance`1 : SmartInstance`2<T, T> {
    public SmartInstance`1(Expression`1<Func`1<T>> constructorSelection);
}
public class StructureMap.Pipeline.SmartInstance`2 : ExpressedInstance`3<SmartInstance`2<T, TPluginType>, T, TPluginType> {
    private ConstructorInstance _inner;
    protected SmartInstance`2<T, TPluginType> thisInstance { get; }
    public string Name { get; public set; }
    public string Description { get; }
    public Type ReturnedType { get; }
    private Type StructureMap.Pipeline.IConfiguredInstance.PluggedType { get; }
    private DependencyCollection StructureMap.Pipeline.IConfiguredInstance.Dependencies { get; }
    private ConstructorInfo StructureMap.Pipeline.IConfiguredInstance.Constructor { get; private set; }
    public SmartInstance`2(Expression`1<Func`1<T>> constructorSelection);
    public SmartInstance`2<T, TPluginType> SelectConstructor(Expression`1<Func`1<T>> constructor);
    protected virtual SmartInstance`2<T, TPluginType> get_thisInstance();
    public virtual Instance ToNamedClone(string name);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual bool HasExplicitName();
    public SmartInstance`2<T, TPluginType> SetProperty(Action`1<T> action);
    public DependencyExpression`2<SmartInstance`2<T, TPluginType>, TSettertype> Setter(Expression`1<Func`2<T, TSettertype>> expression);
    public virtual IDependencySource ToDependencySource(Type pluginType);
    public virtual IDependencySource ToBuilder(Type pluginType, Policies policies);
    public virtual string get_Description();
    public virtual Type get_ReturnedType();
    private sealed virtual override Type StructureMap.Pipeline.IConfiguredInstance.get_PluggedType();
    private sealed virtual override DependencyCollection StructureMap.Pipeline.IConfiguredInstance.get_Dependencies();
    private sealed virtual override Instance StructureMap.Pipeline.IOverridableInstance.Override(ExplicitArguments arguments);
    private sealed virtual override ConstructorInfo StructureMap.Pipeline.IConfiguredInstance.get_Constructor();
    private sealed virtual override void StructureMap.Pipeline.IConfiguredInstance.set_Constructor(ConstructorInfo value);
    public DependencyExpression`2<SmartInstance`2<T, TPluginType>, TCtorType> Ctor();
    public DependencyExpression`2<SmartInstance`2<T, TPluginType>, TCtorType> Ctor(string constructorArg);
    public DependencyExpression`2<SmartInstance`2<T, TPluginType>, TSetterType> Setter();
    public DependencyExpression`2<SmartInstance`2<T, TPluginType>, TSetterType> Setter(string setterName);
    public ArrayDefinitionExpression`2<SmartInstance`2<T, TPluginType>, TElement> EnumerableOf();
    public ArrayDefinitionExpression`2<SmartInstance`2<T, TPluginType>, TElement> EnumerableOf(string ctorOrPropertyName);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(StructureMapAttribute x);
}
public class StructureMap.Pipeline.ThreadLocalStorageLifecycle : LifecycleBase {
    private static ThreadLocal`1<IObjectCache> Cache;
    private static ThreadLocalStorageLifecycle();
    public virtual void EjectAll(ILifecycleContext context);
    public virtual IObjectCache FindCache(ILifecycleContext context);
    public static void RefreshCache();
}
public class StructureMap.Pipeline.TrackingTransientCache : object {
    private IList`1<object> _tracked;
    public TransientTracking Style { get; }
    public int Count { get; }
    public IEnumerable`1<object> Tracked { get; }
    public TransientTracking get_Style();
    public sealed virtual object Get(Type pluginType, Instance instance, IBuildSession session);
    public sealed virtual int get_Count();
    public sealed virtual bool Has(Type pluginType, Instance instance);
    public sealed virtual void Eject(Type pluginType, Instance instance);
    public sealed virtual void DisposeAndClear();
    public sealed virtual void Release(object o);
    public sealed virtual IEnumerable`1<object> get_Tracked();
}
public class StructureMap.Pipeline.TransientLifecycle : LifecycleBase {
    public virtual void EjectAll(ILifecycleContext context);
    public virtual IObjectCache FindCache(ILifecycleContext context);
}
public enum StructureMap.Pipeline.TransientTracking : Enum {
    public int value__;
    public static TransientTracking DefaultNotTrackedAtRoot;
    public static TransientTracking ExplicitReleaseMode;
}
public class StructureMap.Pipeline.TypeArguments : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<Type, object> <Defaults>k__BackingField;
    public IDictionary`2<Type, object> Defaults { get; }
    [CompilerGeneratedAttribute]
public IDictionary`2<Type, object> get_Defaults();
    public TypeArguments Set(T arg);
    public TypeArguments Set(Type pluginType, object arg);
    public bool Has(Type type);
    public T Get();
}
public class StructureMap.Pipeline.UniquePerRequestLifecycle : LifecycleBase {
    public virtual void EjectAll(ILifecycleContext context);
    public virtual IObjectCache FindCache(ILifecycleContext context);
}
public class StructureMap.PipelineGraph : object {
    private PluginGraph _pluginGraph;
    private IInstanceGraph _instances;
    private IPipelineGraph _root;
    private IObjectCache _singletons;
    private ITransientTracking _transients;
    private Profiles _profiles;
    private bool _wasDisposed;
    private IList`1<IDisposable> _trackedDisposables;
    [CompilerGeneratedAttribute]
private IObjectCache <ContainerCache>k__BackingField;
    public IObjectCache ContainerCache { get; private set; }
    public Profiles Profiles { get; }
    public IInstanceGraph Instances { get; }
    public IObjectCache Singletons { get; }
    public ITransientTracking Transients { get; }
    public string Profile { get; }
    public ContainerRole Role { get; }
    public IGraphEjector Ejector { get; }
    public Policies Policies { get; }
    public PipelineGraph(PluginGraph pluginGraph, IInstanceGraph instances, IPipelineGraph root, IObjectCache singletons, ITransientTracking transients);
    public static IPipelineGraph For(Action`1<ConfigurationExpression> action);
    public static IPipelineGraph BuildRoot(PluginGraph pluginGraph);
    private static ITransientTracking chooseTransientTracking(PluginGraph pluginGraph);
    public static IPipelineGraph BuildEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual IObjectCache get_ContainerCache();
    [CompilerGeneratedAttribute]
private void set_ContainerCache(IObjectCache value);
    public sealed virtual IPipelineGraph Root();
    public sealed virtual Profiles get_Profiles();
    public sealed virtual IInstanceGraph get_Instances();
    public sealed virtual IObjectCache get_Singletons();
    public sealed virtual ITransientTracking get_Transients();
    public sealed virtual IModel ToModel();
    public sealed virtual string get_Profile();
    public sealed virtual ContainerRole get_Role();
    public sealed virtual IGraphEjector get_Ejector();
    public sealed virtual Policies get_Policies();
    public sealed virtual void Dispose();
    public sealed virtual void RegisterContainer(IContainer container);
    public sealed virtual IPipelineGraph ToNestedGraph(TypeArguments arguments);
    public sealed virtual void Configure(Action`1<ConfigurationExpression> configure);
    private void changeTransientTracking(TransientTracking transientTracking);
    public sealed virtual void ValidateValidNestedScoping();
    public sealed virtual void TrackDisposable(IDisposable disposable);
    public sealed virtual ILifecycle DetermineLifecycle(Type pluginType, Instance instance);
}
public class StructureMap.PluginGraphBuilder : object {
    private PluginGraph _graph;
    public PluginGraphBuilder(PluginGraph graph);
    public PluginGraphBuilder Add(Registry registry);
    public PluginGraph Build();
    public void RunConfigurations();
    [CompilerGeneratedAttribute]
private void <RunConfigurations>b__5_2(Task`1<Registry> x);
}
public class StructureMap.Policies : object {
    public SetterRules SetterRules;
    public ConstructorSelector ConstructorSelector;
    private object _buildLock;
    private IDictionary`2<Type, BuildUpPlan> _buildUpPlans;
    private IList`1<IInstancePolicy> _policies;
    public Policies(PluginGraph pluginGraph);
    public static Policies Default();
    public void Add(IInstancePolicy policy);
    public void Add(IInterceptorPolicy interception);
    public IEnumerable`1<IInterceptorPolicy> Interception();
    public void Apply(Type pluginType, Instance instance);
    public BuildUpPlan ToBuildUpPlan(Type pluggedType, Func`1<IConfiguredInstance> findInstance);
    public bool CanBeAutoFilled(Type concreteType);
    public bool IsMandatorySetter(PropertyInfo propertyInfo);
    public ConstructorInfo SelectConstructor(Type pluggedType, DependencyCollection dependencies);
}
public class StructureMap.Profiles : object {
    private PluginGraph _pluginGraph;
    private IPipelineGraph _root;
    private ConcurrentDictionary`2<string, IPipelineGraph> _profiles;
    public Profiles(PluginGraph pluginGraph, IPipelineGraph root);
    public IPipelineGraph NewChild(PluginGraph parent);
    public IEnumerable`1<IPipelineGraph> AllProfiles();
    public IPipelineGraph For(string profileName, object syncLock);
}
public class StructureMap.Query.ClosedPluginTypeConfiguration : object {
    private PluginFamily _family;
    private IPipelineGraph _pipelineGraph;
    public string ProfileName { get; }
    public IPipelineGraph Pipeline { get; }
    private Type StructureMap.Query.IFamily.PluginType { get; }
    private Type StructureMap.Query.IPluginTypeConfiguration.PluginType { get; }
    public InstanceRef Default { get; }
    public ILifecycle Lifecycle { get; }
    public IEnumerable`1<InstanceRef> Instances { get; }
    public InstanceRef Fallback { get; }
    public InstanceRef MissingNamedInstance { get; }
    public ClosedPluginTypeConfiguration(PluginFamily family, IPipelineGraph pipelineGraph);
    public sealed virtual void Eject(Instance instance);
    public sealed virtual object Build(Instance instance);
    public sealed virtual bool HasBeenCreated(Instance instance);
    public sealed virtual string get_ProfileName();
    public sealed virtual IPipelineGraph get_Pipeline();
    private sealed virtual override Type StructureMap.Query.IFamily.get_PluginType();
    private sealed virtual override Type StructureMap.Query.IPluginTypeConfiguration.get_PluginType();
    public sealed virtual InstanceRef get_Default();
    public sealed virtual ILifecycle get_Lifecycle();
    [IteratorStateMachineAttribute("StructureMap.Query.ClosedPluginTypeConfiguration/<get_Instances>d__19")]
public sealed virtual IEnumerable`1<InstanceRef> get_Instances();
    public sealed virtual bool HasImplementations();
    public sealed virtual void EjectAndRemove(Instance instance);
    public sealed virtual void EjectAndRemove(InstanceRef instance);
    public sealed virtual void EjectAndRemoveAll();
    public sealed virtual InstanceRef get_Fallback();
    public sealed virtual InstanceRef get_MissingNamedInstance();
}
public class StructureMap.Query.EmptyConfiguration : object {
    private Type _pluginType;
    public string ProfileName { get; }
    public Type PluginType { get; }
    public InstanceRef Default { get; }
    public ILifecycle Lifecycle { get; }
    public IEnumerable`1<InstanceRef> Instances { get; }
    public InstanceRef Fallback { get; }
    public InstanceRef MissingNamedInstance { get; }
    public EmptyConfiguration(Type pluginType);
    public sealed virtual string get_ProfileName();
    public sealed virtual Type get_PluginType();
    public sealed virtual InstanceRef get_Default();
    public sealed virtual ILifecycle get_Lifecycle();
    public sealed virtual IEnumerable`1<InstanceRef> get_Instances();
    public sealed virtual bool HasImplementations();
    public sealed virtual void EjectAndRemove(InstanceRef instance);
    public sealed virtual void EjectAndRemoveAll();
    public sealed virtual InstanceRef get_Fallback();
    public sealed virtual InstanceRef get_MissingNamedInstance();
}
public class StructureMap.Query.GenericFamilyConfiguration : object {
    private PluginFamily _family;
    private IPipelineGraph _pipeline;
    private PluginGraph _graph;
    public IPipelineGraph Pipeline { get; }
    public string ProfileName { get; }
    public Type PluginType { get; }
    public InstanceRef Default { get; }
    public ILifecycle Lifecycle { get; }
    public IEnumerable`1<InstanceRef> Instances { get; }
    public InstanceRef Fallback { get; }
    public InstanceRef MissingNamedInstance { get; }
    public GenericFamilyConfiguration(PluginFamily family, IPipelineGraph pipeline);
    public sealed virtual IPipelineGraph get_Pipeline();
    public sealed virtual string get_ProfileName();
    private sealed virtual override void StructureMap.Query.IFamily.Eject(Instance instance);
    private sealed virtual override object StructureMap.Query.IFamily.Build(Instance instance);
    private sealed virtual override bool StructureMap.Query.IFamily.HasBeenCreated(Instance instance);
    public sealed virtual Type get_PluginType();
    public sealed virtual InstanceRef get_Default();
    public sealed virtual ILifecycle get_Lifecycle();
    public sealed virtual IEnumerable`1<InstanceRef> get_Instances();
    public sealed virtual bool HasImplementations();
    public sealed virtual void EjectAndRemove(InstanceRef instance);
    public sealed virtual void EjectAndRemove(Instance instance);
    public sealed virtual void EjectAndRemoveAll();
    public sealed virtual InstanceRef get_Fallback();
    public sealed virtual InstanceRef get_MissingNamedInstance();
    [CompilerGeneratedAttribute]
private InstanceRef <get_Instances>b__18_0(Instance x);
}
public interface StructureMap.Query.IFamily {
    public ILifecycle Lifecycle { get; }
    public Type PluginType { get; }
    public IPipelineGraph Pipeline { get; }
    public abstract virtual void Eject(Instance instance);
    public abstract virtual void EjectAndRemove(Instance instance);
    public abstract virtual object Build(Instance instance);
    public abstract virtual bool HasBeenCreated(Instance instance);
    public abstract virtual ILifecycle get_Lifecycle();
    public abstract virtual Type get_PluginType();
    public abstract virtual IPipelineGraph get_Pipeline();
}
public interface StructureMap.Query.IModel {
    public IEnumerable`1<IPluginTypeConfiguration> PluginTypes { get; }
    public IPipelineGraph Pipeline { get; }
    public IEnumerable`1<InstanceRef> AllInstances { get; }
    public IEnumerable`1<AssemblyScanner> Scanners { get; }
    public IEnumerable`1<Registry> Registries { get; }
    public abstract virtual IEnumerable`1<IPluginTypeConfiguration> get_PluginTypes();
    public abstract virtual IPipelineGraph get_Pipeline();
    public abstract virtual IEnumerable`1<InstanceRef> get_AllInstances();
    public abstract virtual bool HasDefaultImplementationFor(Type pluginType);
    public abstract virtual bool HasDefaultImplementationFor();
    public abstract virtual IEnumerable`1<InstanceRef> InstancesOf(Type pluginType);
    public abstract virtual IEnumerable`1<InstanceRef> InstancesOf();
    public abstract virtual bool HasImplementationsFor(Type pluginType);
    public abstract virtual bool HasImplementationsFor();
    public abstract virtual Type DefaultTypeFor();
    public abstract virtual Type DefaultTypeFor(Type pluginType);
    public abstract virtual IPluginTypeConfiguration For();
    public abstract virtual IPluginTypeConfiguration For(Type type);
    public abstract virtual void EjectAndRemoveTypes(Func`2<Type, bool> filter);
    public abstract virtual void EjectAndRemovePluginTypes(Func`2<Type, bool> filter);
    public abstract virtual void EjectAndRemove(Type pluginType);
    public abstract virtual void EjectAndRemove();
    public abstract virtual IEnumerable`1<T> GetAllPossible();
    public abstract virtual InstanceRef Find(string name);
    public abstract virtual IEnumerable`1<AssemblyScanner> get_Scanners();
    public abstract virtual IEnumerable`1<Registry> get_Registries();
}
public class StructureMap.Query.InstanceRef : object {
    private IFamily _family;
    private Instance _instance;
    public Instance Instance { get; }
    public ILifecycle Lifecycle { get; }
    public string Name { get; }
    public Type ReturnedType { get; }
    public string Description { get; }
    public Type PluginType { get; }
    public InstanceRef(Instance instance, IFamily family);
    public Instance get_Instance();
    public ILifecycle get_Lifecycle();
    public string get_Name();
    public Type get_ReturnedType();
    public string get_Description();
    public Type get_PluginType();
    public void EjectObject();
    public void EjectAndRemove();
    public T Get();
    public bool ObjectHasBeenCreated();
    public string DescribeBuildPlan(int maxLevels);
}
public interface StructureMap.Query.IPluginTypeConfiguration {
    public string ProfileName { get; }
    public Type PluginType { get; }
    public InstanceRef Default { get; }
    public ILifecycle Lifecycle { get; }
    public IEnumerable`1<InstanceRef> Instances { get; }
    public InstanceRef Fallback { get; }
    public InstanceRef MissingNamedInstance { get; }
    public abstract virtual string get_ProfileName();
    public abstract virtual Type get_PluginType();
    public abstract virtual InstanceRef get_Default();
    public abstract virtual ILifecycle get_Lifecycle();
    public abstract virtual IEnumerable`1<InstanceRef> get_Instances();
    public abstract virtual bool HasImplementations();
    public abstract virtual void EjectAndRemove(InstanceRef instance);
    public abstract virtual void EjectAndRemoveAll();
    public abstract virtual InstanceRef get_Fallback();
    public abstract virtual InstanceRef get_MissingNamedInstance();
}
public class StructureMap.Query.Model : object {
    private IPipelineGraph _graph;
    [CompilerGeneratedAttribute]
private PluginGraph <PluginGraph>k__BackingField;
    public IPipelineGraph Pipeline { get; }
    private IEnumerable`1<IPluginTypeConfiguration> pluginTypes { get; }
    public IEnumerable`1<IPluginTypeConfiguration> PluginTypes { get; }
    public PluginGraph PluginGraph { get; private set; }
    public IEnumerable`1<AssemblyScanner> Scanners { get; }
    public IEnumerable`1<Registry> Registries { get; }
    public IEnumerable`1<InstanceRef> AllInstances { get; }
    internal Model(IPipelineGraph graph, PluginGraph pluginGraph);
    public sealed virtual IPipelineGraph get_Pipeline();
    [IteratorStateMachineAttribute("StructureMap.Query.Model/<get_pluginTypes>d__5")]
private IEnumerable`1<IPluginTypeConfiguration> get_pluginTypes();
    public sealed virtual bool HasDefaultImplementationFor(Type pluginType);
    public sealed virtual bool HasDefaultImplementationFor();
    public sealed virtual Type DefaultTypeFor();
    public sealed virtual Type DefaultTypeFor(Type pluginType);
    public sealed virtual IEnumerable`1<IPluginTypeConfiguration> get_PluginTypes();
    [CompilerGeneratedAttribute]
public PluginGraph get_PluginGraph();
    [CompilerGeneratedAttribute]
private void set_PluginGraph(PluginGraph value);
    public sealed virtual IPluginTypeConfiguration For();
    public sealed virtual IPluginTypeConfiguration For(Type type);
    public sealed virtual void EjectAndRemoveTypes(Func`2<Type, bool> filter);
    public sealed virtual void EjectAndRemovePluginTypes(Func`2<Type, bool> filter);
    public sealed virtual void EjectAndRemove(Type pluginType);
    public sealed virtual void EjectAndRemove();
    public sealed virtual IEnumerable`1<T> GetAllPossible();
    public sealed virtual InstanceRef Find(string name);
    public sealed virtual IEnumerable`1<AssemblyScanner> get_Scanners();
    public sealed virtual IEnumerable`1<Registry> get_Registries();
    public sealed virtual IEnumerable`1<InstanceRef> InstancesOf(Type pluginType);
    public sealed virtual IEnumerable`1<InstanceRef> InstancesOf();
    public sealed virtual bool HasImplementationsFor(Type pluginType);
    public sealed virtual bool HasImplementationsFor();
    public sealed virtual IEnumerable`1<InstanceRef> get_AllInstances();
    private T findForFamily(Type pluginType, Func`2<IPluginTypeConfiguration, T> func, T defaultValue);
    private T findForFamily(Type pluginType, Func`2<IPluginTypeConfiguration, T> func);
}
[ExtensionAttribute]
public static class StructureMap.Query.PluginTypeConfigurationExtensions : object {
    [ExtensionAttribute]
public static InstanceRef Find(IPluginTypeConfiguration configuration, string instanceName);
    [ExtensionAttribute]
public static void EjectAndRemove(IPluginTypeConfiguration configuration, string instanceName);
    [ExtensionAttribute]
public static void EjectAndRemove(IPluginTypeConfiguration configuration, Func`2<InstanceRef, bool> filter);
}
internal static class StructureMap.ReflectionHelper : object {
    public static PropertyInfo GetProperty(Expression`1<Func`2<T, object>> expression);
    public static PropertyInfo GetProperty(Expression`1<Func`2<TModel, T>> expression);
    public static MemberInfo GetMember(Expression`1<Func`2<T, object>> expression);
    public static MemberInfo GetMember(Expression`1<Func`2<TModel, T>> expression);
    private static MemberExpression getMemberExpression(Expression`1<Func`2<TModel, T>> expression);
    public static MethodInfo GetMethod(Expression`1<Func`2<T, object>> expression);
    public static MethodInfo GetMethod(Expression`1<Func`2<T, U>> expression);
    public static MethodInfo GetMethod(Expression`1<Func`3<T, U, V>> expression);
}
public class StructureMap.Registry : object {
    private IList`1<Action`1<PluginGraph>> _actions;
    internal IList`1<AssemblyScanner> Scanners;
    [CompilerGeneratedAttribute]
private bool <PoliciesChanged>k__BackingField;
    private static int mutation;
    private Nullable`1<TransientTracking> _transients;
    unknown Action`1<PluginGraph> alter {internal set; }
    unknown TransientTracking TransientTracking {public set; }
    public PoliciesExpression Policies { get; }
    internal bool PoliciesChanged { get; internal set; }
    private static Registry();
    internal void set_alter(Action`1<PluginGraph> value);
    public sealed virtual void AddType(Type pluginType, Type concreteType);
    public virtual void AddType(Type pluginType, Type concreteType, string name);
    public sealed virtual void IncludeRegistry();
    public sealed virtual void IncludeRegistry(Registry registry);
    public sealed virtual BuildWithExpression`1<T> ForConcreteType();
    public sealed virtual CreatePluginFamilyExpression`1<TPluginType> ForSingletonOf();
    public sealed virtual GenericFamilyExpression ForSingletonOf(Type pluginType);
    public sealed virtual void Profile(string profileName, Action`1<IProfileRegistry> action);
    public sealed virtual void Scan(Action`1<IAssemblyScanner> action);
    public sealed virtual void Forward();
    public sealed virtual CreatePluginFamilyExpression`1<TPluginType> For(ILifecycle lifecycle);
    public sealed virtual GenericFamilyExpression For(Type pluginType, ILifecycle lifecycle);
    public sealed virtual LambdaInstance`2<T, T> Redirect();
    public sealed virtual void Configure(Action`1<PluginGraph> configure);
    internal void Configure(PluginGraph graph);
    public void set_TransientTracking(TransientTracking value);
    internal Nullable`1<TransientTracking> GetTransientTracking();
    internal static bool IsPublicRegistry(Type type);
    public bool Equals(Registry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual PoliciesExpression get_Policies();
    [CompilerGeneratedAttribute]
internal bool get_PoliciesChanged();
    [CompilerGeneratedAttribute]
internal void set_PoliciesChanged(bool value);
    public static bool RegistryExists(IEnumerable`1<Registry> all, Registry registry);
}
public class StructureMap.RootInstanceGraph : object {
    private PluginGraph _pluginGraph;
    public ContainerRole Role { get; }
    public PluginGraph ImmediatePluginGraph { get; }
    public RootInstanceGraph(PluginGraph pluginGraph);
    public sealed virtual Instance GetDefault(Type pluginType);
    public sealed virtual bool HasDefaultForPluginType(Type pluginType);
    public sealed virtual bool HasInstance(Type pluginType, string instanceKey);
    public sealed virtual void EachInstance(Action`2<Type, Instance> action);
    public sealed virtual IEnumerable`1<Instance> GetAllInstances();
    public sealed virtual IEnumerable`1<Instance> GetAllInstances(Type pluginType);
    public sealed virtual Instance FindInstance(Type pluginType, string name);
    public sealed virtual IEnumerable`1<PluginFamily> UniqueFamilies();
    public sealed virtual ILifecycle DefaultLifecycleFor(Type pluginType);
    public sealed virtual ContainerRole get_Role();
    public sealed virtual IEnumerable`1<Instance> ImmediateInstances();
    public sealed virtual PluginGraph get_ImmediatePluginGraph();
}
public class StructureMap.SessionCache : object {
    private IDictionary`2<int, object> _cachedObjects;
    private IDictionary`2<Type, object> _defaults;
    private IBuildSession _resolver;
    private bool _hasExplicitArguments;
    public SessionCache(IBuildSession resolver);
    public SessionCache(IBuildSession resolver, ExplicitArguments arguments);
    public sealed virtual object GetDefault(Type pluginType, IPipelineGraph pipelineGraph);
    public sealed virtual object GetObject(Type pluginType, Instance instance, ILifecycle lifecycle);
    public sealed virtual object TryGetDefault(Type pluginType, IPipelineGraph pipelineGraph);
    public sealed virtual IEnumerable`1<T> All();
}
[AttributeUsageAttribute("1028")]
public class StructureMap.SingletonAttribute : StructureMapAttribute {
    public virtual void Alter(PluginFamily family);
    public virtual void Alter(IConfiguredInstance instance);
}
[ExtensionAttribute]
internal static class StructureMap.StringExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> Each(IEnumerable`1<T> enumerable, Action`1<T> action);
    [ExtensionAttribute]
public static bool IsEmpty(string value);
    [ExtensionAttribute]
public static bool IsNotEmpty(string value);
    [ExtensionAttribute]
public static string ToFormat(string template, Object[] parameters);
    [ExtensionAttribute]
public static String[] ToDelimitedArray(string content);
}
public abstract class StructureMap.StructureMapAttribute : Attribute {
    public virtual void Alter(PluginFamily family);
    public virtual void Alter(IConfiguredInstance instance);
    public virtual void Alter(IConfiguredInstance instance, PropertyInfo property);
    public virtual void Alter(IConfiguredInstance instance, ParameterInfo parameter);
}
public class StructureMap.StructureMapBuildPlanException : StructureMapException {
    public StructureMapBuildPlanException(string message);
    public StructureMapBuildPlanException(string message, Exception innerException);
}
public class StructureMap.StructureMapConfigurationException : StructureMapException {
    public StructureMapConfigurationException(string message, Object[] parameters);
    public StructureMapConfigurationException(string message, Exception innerException);
}
public class StructureMap.StructureMapException : Exception {
    public static ConstructorInfo Constructor;
    public static MethodInfo PushMethod;
    private Queue`1<string> _descriptions;
    private string _title;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    public IList`1<Guid> Instances;
    public string Message { get; }
    public string Context { get; public set; }
    public string Title { get; }
    public StructureMapException(string message);
    public StructureMapException(string message, Exception innerException);
    private static StructureMapException();
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    public void Push(string description, Object[] parameters);
    public string get_Title();
}
public static class StructureMap.TypeRules.AssemblyLoader : object {
    public static Assembly ByName(string assemblyName);
}
[ExtensionAttribute]
public static class StructureMap.TypeRules.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsConcreteWithDefaultCtor(Type type);
    [ExtensionAttribute]
public static bool HasAttribute(MemberInfo provider);
    [ExtensionAttribute]
internal static void ForAttribute(MemberInfo provider, Action`1<T> action);
    [ExtensionAttribute]
internal static void ForAttribute(ParameterInfo provider, Action`1<T> action);
    [ExtensionAttribute]
internal static T GetAttribute(MemberInfo provider);
    [ExtensionAttribute]
public static T CloseAndBuildAs(Type openType, Type[] parameterTypes);
    [ExtensionAttribute]
public static T CloseAndBuildAs(Type openType, object ctorArgument, Type[] parameterTypes);
    [ExtensionAttribute]
public static bool Closes(Type type, Type openType);
    [ExtensionAttribute]
public static bool IsInNamespace(Type type, string nameSpace);
    [ExtensionAttribute]
public static bool IsOpenGeneric(Type type);
    [ExtensionAttribute]
public static bool IsConcreteAndAssignableTo(Type TPluggedType, Type pluginType);
    [ExtensionAttribute]
public static bool ImplementsInterfaceTemplate(Type TPluggedType, Type templateType);
    [ExtensionAttribute]
public static Type FindFirstInterfaceThatCloses(Type TPluggedType, Type templateType);
    [ExtensionAttribute]
public static IEnumerable`1<Type> FindInterfacesThatClose(Type TPluggedType, Type templateType);
    [IteratorStateMachineAttribute("StructureMap.TypeRules.TypeExtensions/<rawFindInterfacesThatCloses>d__14")]
private static IEnumerable`1<Type> rawFindInterfacesThatCloses(Type TPluggedType, Type templateType);
    [ExtensionAttribute]
public static bool IsNullable(Type type);
    [ExtensionAttribute]
public static Type GetInnerTypeFromNullable(Type nullableType);
    [ExtensionAttribute]
public static string GetName(Type type);
    [ExtensionAttribute]
public static string GetFullName(Type type);
    [ExtensionAttribute]
public static string GetTypeName(Type type);
    private static string GetGenericName(Type type);
    [ExtensionAttribute]
public static bool CanBeCreated(Type type);
    [IteratorStateMachineAttribute("StructureMap.TypeRules.TypeExtensions/<AllInterfaces>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<Type> AllInterfaces(Type type);
    [ExtensionAttribute]
public static bool CanBeCastTo(Type pluggedType, Type pluginType);
    [ExtensionAttribute]
public static bool CanBeCastTo(Type pluggedType);
    [ExtensionAttribute]
public static bool CouldCloseTo(Type openConcretion, Type closedInterface);
    [ExtensionAttribute]
public static bool IsString(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsSimple(Type type);
    [ExtensionAttribute]
public static bool IsInterfaceOrAbstract(Type type);
    [ExtensionAttribute]
public static bool IsChild(Type type);
    [ExtensionAttribute]
public static bool IsChildArray(Type type);
    [ExtensionAttribute]
public static bool IsPrimitiveArray(Type type);
    [ExtensionAttribute]
public static bool IsConcrete(Type type);
    [ExtensionAttribute]
public static bool IsAutoFillable(Type type);
    [ExtensionAttribute]
public static bool HasConstructors(Type type);
    [ExtensionAttribute]
public static bool IsVoidReturn(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetSettableProperties(Type type);
    [ExtensionAttribute]
public static IReadOnlyList`1<ConstructorInfo> GetConstructors(Type type);
    [ExtensionAttribute]
public static bool HasAttribute(Assembly assembly);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetInterfaces(Type type);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructor(Type type, Type[] argumentTypes);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name, Type[] arguments);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo pi);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo pi);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetExportedTypes(Assembly assembly);
    [ExtensionAttribute]
private static bool ParametersMatch(MethodBase method, ICollection`1<Type> parameterTypes);
}
internal static class StructureMap.Util.ExpressionCompiler : object {
    private static Type[] _emptyTypes;
    private static ExpressionCompiler();
    public static Func`1<T> Compile(Expression`1<Func`1<T>> lambdaExpr);
    public static TDelegate Compile(LambdaExpression lambdaExpr);
    public static TDelegate TryCompile(LambdaExpression lambdaExpr);
    private static Type[] GetParamExprTypes(IList`1<ParameterExpression> paramExprs);
    public static TDelegate TryCompile(Expression bodyExpr, IList`1<ParameterExpression> paramExprs, Type[] paramTypes, Type returnType);
    private static object TryCompile(ClosureInfo& closureInfo, Type delegateType, Type[] paramTypes, Type returnType, Expression bodyExpr, IList`1<ParameterExpression> paramExprs);
    private static DynamicMethod GetDynamicMethod(Type[] paramTypes, Type returnType, ClosureInfo closureInfo);
    private static Type[] GetClosureAndParamTypes(Type[] paramTypes, Type closureType);
    private static bool IsBoundConstant(object value);
    private static bool TryCollectBoundConstants(ClosureInfo& closure, Expression expr, IList`1<ParameterExpression> paramExprs);
    private static bool TryCollectBoundConstants(ClosureInfo& closure, IList`1<Expression> exprs, IList`1<ParameterExpression> paramExprs);
}
[DefaultMemberAttribute("Item")]
public class StructureMap.Util.LightweightCache`2 : object {
    private IDictionary`2<TKey, TValue> _values;
    private Func`2<TValue, TKey> _getKey;
    private Func`2<TKey, TValue> _onMissing;
    unknown Func`2<TKey, TValue> OnMissing {public set; }
    public Func`2<TValue, TKey> GetKey { get; public set; }
    public int Count { get; }
    public TValue First { get; }
    public TValue Item { get; public set; }
    public LightweightCache`2(Func`2<TKey, TValue> onMissing);
    public LightweightCache`2(IDictionary`2<TKey, TValue> dictionary, Func`2<TKey, TValue> onMissing);
    public LightweightCache`2(IDictionary`2<TKey, TValue> dictionary);
    public void set_OnMissing(Func`2<TKey, TValue> value);
    public Func`2<TValue, TKey> get_GetKey();
    public void set_GetKey(Func`2<TValue, TKey> value);
    public int get_Count();
    public TValue get_First();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    public void FillDefault(TKey key);
    public void Fill(TKey key, TValue value);
    public bool TryRetrieve(TKey key, TValue& value);
    public void Each(Action`1<TValue> action);
    public void Each(Action`2<TKey, TValue> action);
    public bool Has(TKey key);
    public bool Exists(Predicate`1<TValue> predicate);
    public TValue Find(Predicate`1<TValue> predicate);
    public TValue[] GetAll();
    public void Remove(TKey key);
    public void Clear();
    public void WithValue(TKey key, Action`1<TValue> action);
    public void ClearAll();
}
[AttributeUsageAttribute("64")]
public class StructureMap.ValidationMethodAttribute : Attribute {
    public static MethodInfo[] GetValidationMethods(Type objectType);
}
