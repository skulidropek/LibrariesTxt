[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class CliWrap.Buffered.BufferedCommandExtensions : object {
    [ExtensionAttribute]
public static CommandTask`1<BufferedCommandResult> ExecuteBufferedAsync(Command command, Encoding standardOutputEncoding, Encoding standardErrorEncoding, CancellationToken forcefulCancellationToken, CancellationToken gracefulCancellationToken);
    [ExtensionAttribute]
public static CommandTask`1<BufferedCommandResult> ExecuteBufferedAsync(Command command, Encoding standardOutputEncoding, Encoding standardErrorEncoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static CommandTask`1<BufferedCommandResult> ExecuteBufferedAsync(Command command, Encoding encoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static CommandTask`1<BufferedCommandResult> ExecuteBufferedAsync(Command command, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CliWrap.Buffered.BufferedCommandResult : CommandResult {
    [CompilerGeneratedAttribute]
private string <StandardOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardError>k__BackingField;
    public string StandardOutput { get; }
    public string StandardError { get; }
    public BufferedCommandResult(int exitCode, DateTimeOffset startTime, DateTimeOffset exitTime, string standardOutput, string standardError);
    [CompilerGeneratedAttribute]
public string get_StandardOutput();
    [CompilerGeneratedAttribute]
public string get_StandardError();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CliWrap.Builders.ArgumentsBuilder : object {
    private static IFormatProvider DefaultFormatProvider;
    private StringBuilder _buffer;
    private static ArgumentsBuilder();
    public ArgumentsBuilder Add(string value, bool escape);
    public ArgumentsBuilder Add(string value);
    public ArgumentsBuilder Add(IEnumerable`1<string> values, bool escape);
    public ArgumentsBuilder Add(IEnumerable`1<string> values);
    public ArgumentsBuilder Add(IFormattable value, IFormatProvider formatProvider, bool escape);
    public ArgumentsBuilder Add(IFormattable value, CultureInfo cultureInfo, bool escape);
    public ArgumentsBuilder Add(IFormattable value, CultureInfo cultureInfo);
    public ArgumentsBuilder Add(IFormattable value, bool escape);
    public ArgumentsBuilder Add(IFormattable value);
    public ArgumentsBuilder Add(IEnumerable`1<IFormattable> values, IFormatProvider formatProvider, bool escape);
    public ArgumentsBuilder Add(IEnumerable`1<IFormattable> values, CultureInfo cultureInfo, bool escape);
    public ArgumentsBuilder Add(IEnumerable`1<IFormattable> values, CultureInfo cultureInfo);
    public ArgumentsBuilder Add(IEnumerable`1<IFormattable> values, bool escape);
    public ArgumentsBuilder Add(IEnumerable`1<IFormattable> values);
    public string Build();
    private static string Escape(string argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CliWrap.Builders.CredentialsBuilder : object {
    [NullableAttribute("2")]
private string _domain;
    [NullableAttribute("2")]
private string _userName;
    [NullableAttribute("2")]
private string _password;
    private bool _loadUserProfile;
    public CredentialsBuilder SetDomain(string domain);
    public CredentialsBuilder SetUserName(string userName);
    public CredentialsBuilder SetPassword(string password);
    public CredentialsBuilder LoadUserProfile(bool loadUserProfile);
    public Credentials Build();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CliWrap.Builders.EnvironmentVariablesBuilder : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> _envVars;
    public EnvironmentVariablesBuilder Set(string name, string value);
    public EnvironmentVariablesBuilder Set(IEnumerable`1<KeyValuePair`2<string, string>> variables);
    public EnvironmentVariablesBuilder Set(IReadOnlyDictionary`2<string, string> variables);
    public IReadOnlyDictionary`2<string, string> Build();
}
public static class CliWrap.Cli : object {
    [NullableContextAttribute("1")]
public static Command Wrap(string targetFilePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CliWrap.Command : object {
    [CompilerGeneratedAttribute]
private string <TargetFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Credentials <Credentials>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandResultValidation <Validation>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeSource <StandardInputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeTarget <StandardOutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeTarget <StandardErrorPipe>k__BackingField;
    public string TargetFilePath { get; }
    public string Arguments { get; }
    public string WorkingDirPath { get; }
    public Credentials Credentials { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, string> EnvironmentVariables { get; }
    public CommandResultValidation Validation { get; }
    public PipeSource StandardInputPipe { get; }
    public PipeTarget StandardOutputPipe { get; }
    public PipeTarget StandardErrorPipe { get; }
    public Command(string targetFilePath, string arguments, string workingDirPath, Credentials credentials, IReadOnlyDictionary`2<string, string> environmentVariables, CommandResultValidation validation, PipeSource standardInputPipe, PipeTarget standardOutputPipe, PipeTarget standardErrorPipe);
    public Command(string targetFilePath);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFilePath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Arguments();
    [CompilerGeneratedAttribute]
public sealed virtual string get_WorkingDirPath();
    [CompilerGeneratedAttribute]
public sealed virtual Credentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public sealed virtual CommandResultValidation get_Validation();
    [CompilerGeneratedAttribute]
public sealed virtual PipeSource get_StandardInputPipe();
    [CompilerGeneratedAttribute]
public sealed virtual PipeTarget get_StandardOutputPipe();
    [CompilerGeneratedAttribute]
public sealed virtual PipeTarget get_StandardErrorPipe();
    public Command WithTargetFile(string targetFilePath);
    public Command WithArguments(string arguments);
    public Command WithArguments(IEnumerable`1<string> arguments, bool escape);
    public Command WithArguments(IEnumerable`1<string> arguments);
    public Command WithArguments(Action`1<ArgumentsBuilder> configure);
    public Command WithWorkingDirectory(string workingDirPath);
    public Command WithCredentials(Credentials credentials);
    public Command WithCredentials(Action`1<CredentialsBuilder> configure);
    public Command WithEnvironmentVariables(IReadOnlyDictionary`2<string, string> environmentVariables);
    public Command WithEnvironmentVariables(Action`1<EnvironmentVariablesBuilder> configure);
    public Command WithValidation(CommandResultValidation validation);
    public Command WithStandardInputPipe(PipeSource source);
    public Command WithStandardOutputPipe(PipeTarget target);
    public Command WithStandardErrorPipe(PipeTarget target);
    [ExcludeFromCodeCoverageAttribute]
public virtual string ToString();
    private string GetOptimallyQualifiedTargetFilePath();
    private ProcessStartInfo CreateStartInfo();
    [AsyncStateMachineAttribute("CliWrap.Command/<PipeStandardInputAsync>d__46")]
private Task PipeStandardInputAsync(ProcessEx process, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("CliWrap.Command/<PipeStandardOutputAsync>d__47")]
private Task PipeStandardOutputAsync(ProcessEx process, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("CliWrap.Command/<PipeStandardErrorAsync>d__48")]
private Task PipeStandardErrorAsync(ProcessEx process, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("CliWrap.Command/<ExecuteAsync>d__49")]
private Task`1<CommandResult> ExecuteAsync(ProcessEx process, CancellationToken forcefulCancellationToken, CancellationToken gracefulCancellationToken);
    public CommandTask`1<CommandResult> ExecuteAsync(CancellationToken forcefulCancellationToken, CancellationToken gracefulCancellationToken);
    public CommandTask`1<CommandResult> ExecuteAsync(CancellationToken cancellationToken);
    public static Command op_BitwiseOr(Command source, PipeTarget target);
    public static Command op_BitwiseOr(Command source, Stream target);
    public static Command op_BitwiseOr(Command source, StringBuilder target);
    public static Command op_BitwiseOr(Command source, Func`3<string, CancellationToken, Task> target);
    public static Command op_BitwiseOr(Command source, Func`2<string, Task> target);
    public static Command op_BitwiseOr(Command source, Action`1<string> target);
    public static Command op_BitwiseOr(Command source, ValueTuple`2<PipeTarget, PipeTarget> targets);
    public static Command op_BitwiseOr(Command source, ValueTuple`2<Stream, Stream> targets);
    public static Command op_BitwiseOr(Command source, ValueTuple`2<StringBuilder, StringBuilder> targets);
    public static Command op_BitwiseOr(Command source, ValueTuple`2<Func`3<string, CancellationToken, Task>, Func`3<string, CancellationToken, Task>> targets);
    public static Command op_BitwiseOr(Command source, ValueTuple`2<Func`2<string, Task>, Func`2<string, Task>> targets);
    public static Command op_BitwiseOr(Command source, ValueTuple`2<Action`1<string>, Action`1<string>> targets);
    public static Command op_BitwiseOr(PipeSource source, Command target);
    public static Command op_BitwiseOr(Stream source, Command target);
    public static Command op_BitwiseOr(ReadOnlyMemory`1<byte> source, Command target);
    public static Command op_BitwiseOr(Byte[] source, Command target);
    public static Command op_BitwiseOr(string source, Command target);
    public static Command op_BitwiseOr(Command source, Command target);
    [IteratorStateMachineAttribute("CliWrap.Command/<<GetOptimallyQualifiedTargetFilePath>g__GetProbeDirectoryPaths|44_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetOptimallyQualifiedTargetFilePath>g__GetProbeDirectoryPaths|44_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <GetOptimallyQualifiedTargetFilePath>b__44_2(string probeDirPath);
}
public class CliWrap.CommandResult : object {
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExitTime>k__BackingField;
    public int ExitCode { get; }
    public bool IsSuccess { get; }
    public DateTimeOffset StartTime { get; }
    public DateTimeOffset ExitTime { get; }
    public TimeSpan RunTime { get; }
    public CommandResult(int exitCode, DateTimeOffset startTime, DateTimeOffset exitTime);
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    public bool get_IsSuccess();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExitTime();
    public TimeSpan get_RunTime();
}
[FlagsAttribute]
public enum CliWrap.CommandResultValidation : Enum {
    public int value__;
    public static CommandResultValidation None;
    public static CommandResultValidation ZeroExitCode;
}
[ExtensionAttribute]
internal static class CliWrap.CommandResultValidationExtensions : object {
    [ExtensionAttribute]
public static bool IsZeroExitCodeValidationEnabled(CommandResultValidation validation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CliWrap.CommandTask`1 : object {
    [CompilerGeneratedAttribute]
private Task`1<TResult> <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    public Task`1<TResult> Task { get; }
    public int ProcessId { get; }
    public CommandTask`1(Task`1<TResult> task, int processId);
    [CompilerGeneratedAttribute]
public Task`1<TResult> get_Task();
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    internal CommandTask`1<T> Bind(Func`2<Task`1<TResult>, Task`1<T>> transform);
    public CommandTask`1<T> Select(Func`2<TResult, T> transform);
    public TaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public sealed virtual void Dispose();
    public static Task`1<TResult> op_Implicit(CommandTask`1<TResult> commandTask);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class CliWrap.Credentials : object {
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LoadUserProfile>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static Credentials <Default>k__BackingField;
    public string Domain { get; }
    public string UserName { get; }
    public string Password { get; }
    public bool LoadUserProfile { get; }
    [NullableAttribute("1")]
public static Credentials Default { get; }
    public Credentials(string domain, string userName, string password, bool loadUserProfile);
    [ExcludeFromCodeCoverageAttribute]
public Credentials(string domain, string username, string password);
    private static Credentials();
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public bool get_LoadUserProfile();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static Credentials get_Default();
}
public abstract class CliWrap.EventStream.CommandEvent : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class CliWrap.EventStream.EventStreamCommandExtensions : object {
    [AsyncIteratorStateMachineAttribute("CliWrap.EventStream.EventStreamCommandExtensions/<ListenAsync>d__0")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<CommandEvent> ListenAsync(Command command, Encoding standardOutputEncoding, Encoding standardErrorEncoding, CancellationToken forcefulCancellationToken, CancellationToken gracefulCancellationToken);
    [ExtensionAttribute]
public static IAsyncEnumerable`1<CommandEvent> ListenAsync(Command command, Encoding standardOutputEncoding, Encoding standardErrorEncoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAsyncEnumerable`1<CommandEvent> ListenAsync(Command command, Encoding encoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAsyncEnumerable`1<CommandEvent> ListenAsync(Command command, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IObservable`1<CommandEvent> Observe(Command command, Encoding standardOutputEncoding, Encoding standardErrorEncoding, CancellationToken forcefulCancellationToken, CancellationToken gracefulCancellationToken);
    [ExtensionAttribute]
public static IObservable`1<CommandEvent> Observe(Command command, Encoding standardOutputEncoding, Encoding standardErrorEncoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IObservable`1<CommandEvent> Observe(Command command, Encoding encoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IObservable`1<CommandEvent> Observe(Command command, CancellationToken cancellationToken);
}
public class CliWrap.EventStream.ExitedCommandEvent : CommandEvent {
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    public int ExitCode { get; }
    public ExitedCommandEvent(int exitCode);
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [NullableContextAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CliWrap.EventStream.StandardErrorCommandEvent : CommandEvent {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public StandardErrorCommandEvent(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    [ExcludeFromCodeCoverageAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CliWrap.EventStream.StandardOutputCommandEvent : CommandEvent {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public StandardOutputCommandEvent(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    [ExcludeFromCodeCoverageAttribute]
public virtual string ToString();
}
public class CliWrap.EventStream.StartedCommandEvent : CommandEvent {
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    public int ProcessId { get; }
    public StartedCommandEvent(int processId);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    [NullableContextAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class CliWrap.Exceptions.CliWrapException : Exception {
    protected CliWrapException(string message, Exception innerException);
    [ExcludeFromCodeCoverageAttribute]
protected CliWrapException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CliWrap.Exceptions.CommandExecutionException : CliWrapException {
    [CompilerGeneratedAttribute]
private ICommandConfiguration <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    public ICommandConfiguration Command { get; }
    public int ExitCode { get; }
    public CommandExecutionException(ICommandConfiguration command, int exitCode, string message, Exception innerException);
    [ExcludeFromCodeCoverageAttribute]
public CommandExecutionException(ICommandConfiguration command, int exitCode, string message);
    [CompilerGeneratedAttribute]
public ICommandConfiguration get_Command();
    [CompilerGeneratedAttribute]
public int get_ExitCode();
}
[NullableContextAttribute("1")]
public interface CliWrap.ICommandConfiguration {
    public string TargetFilePath { get; }
    public string Arguments { get; }
    public string WorkingDirPath { get; }
    public Credentials Credentials { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, string> EnvironmentVariables { get; }
    public CommandResultValidation Validation { get; }
    public PipeSource StandardInputPipe { get; }
    public PipeTarget StandardOutputPipe { get; }
    public PipeTarget StandardErrorPipe { get; }
    public abstract virtual string get_TargetFilePath();
    public abstract virtual string get_Arguments();
    public abstract virtual string get_WorkingDirPath();
    public abstract virtual Credentials get_Credentials();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_EnvironmentVariables();
    public abstract virtual CommandResultValidation get_Validation();
    public abstract virtual PipeSource get_StandardInputPipe();
    public abstract virtual PipeTarget get_StandardOutputPipe();
    public abstract virtual PipeTarget get_StandardErrorPipe();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class CliWrap.PipeSource : object {
    [CompilerGeneratedAttribute]
private static PipeSource <Null>k__BackingField;
    public static PipeSource Null { get; }
    private static PipeSource();
    public abstract virtual Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public static PipeSource get_Null();
    public static PipeSource Create(Func`3<Stream, CancellationToken, Task> handlePipeAsync);
    public static PipeSource Create(Action`1<Stream> handlePipe);
    public static PipeSource FromStream(Stream stream, bool autoFlush);
    public static PipeSource FromStream(Stream stream);
    public static PipeSource FromFile(string filePath);
    [NullableContextAttribute("0")]
public static PipeSource FromBytes(ReadOnlyMemory`1<byte> data);
    public static PipeSource FromBytes(Byte[] data);
    [NullableContextAttribute("0")]
[ObsoleteAttribute("Use FromBytes(ReadOnlyMemory<byte>) instead")]
[ExcludeFromCodeCoverageAttribute]
public static PipeSource FromMemory(ReadOnlyMemory`1<byte> data);
    public static PipeSource FromString(string str, Encoding encoding);
    public static PipeSource FromString(string str);
    public static PipeSource FromCommand(Command command);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class CliWrap.PipeTarget : object {
    [CompilerGeneratedAttribute]
private static PipeTarget <Null>k__BackingField;
    public static PipeTarget Null { get; }
    private static PipeTarget();
    public abstract virtual Task CopyFromAsync(Stream origin, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public static PipeTarget get_Null();
    public static PipeTarget Create(Func`3<Stream, CancellationToken, Task> handlePipeAsync);
    public static PipeTarget Create(Action`1<Stream> handlePipe);
    public static PipeTarget ToStream(Stream stream, bool autoFlush);
    public static PipeTarget ToStream(Stream stream);
    public static PipeTarget ToFile(string filePath);
    public static PipeTarget ToStringBuilder(StringBuilder stringBuilder, Encoding encoding);
    public static PipeTarget ToStringBuilder(StringBuilder stringBuilder);
    public static PipeTarget ToDelegate(Func`3<string, CancellationToken, Task> handleLineAsync, Encoding encoding);
    public static PipeTarget ToDelegate(Func`3<string, CancellationToken, Task> handleLineAsync);
    public static PipeTarget ToDelegate(Func`2<string, Task> handleLineAsync, Encoding encoding);
    public static PipeTarget ToDelegate(Func`2<string, Task> handleLineAsync);
    public static PipeTarget ToDelegate(Action`1<string> handleLine, Encoding encoding);
    public static PipeTarget ToDelegate(Action`1<string> handleLine);
    public static PipeTarget Merge(IEnumerable`1<PipeTarget> targets);
    public static PipeTarget Merge(PipeTarget[] targets);
    [CompilerGeneratedAttribute]
internal static void <Merge>g__FlattenTargets|19_0(IEnumerable`1<PipeTarget> targets, ICollection`1<PipeTarget> output);
    [CompilerGeneratedAttribute]
internal static IReadOnlyList`1<PipeTarget> <Merge>g__OptimizeTargets|19_1(IEnumerable`1<PipeTarget> targets);
}
internal static class CliWrap.Utils.BufferSizes : object {
    public static int Stream;
    public static int StreamReader;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class CliWrap.Utils.Channel`1 : object {
    private SemaphoreSlim _writeLock;
    private SemaphoreSlim _readLock;
    private bool _isItemAvailable;
    private T _item;
    [AsyncStateMachineAttribute("CliWrap.Utils.Channel`1/<PublishAsync>d__4")]
public Task PublishAsync(T item, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("CliWrap.Utils.Channel`1/<ReceiveAsync>d__5")]
public IAsyncEnumerable`1<T> ReceiveAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("CliWrap.Utils.Channel`1/<ReportCompletionAsync>d__6")]
public Task ReportCompletionAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class CliWrap.Utils.Disposable : object {
    [CompilerGeneratedAttribute]
private Action <dispose>P;
    [CompilerGeneratedAttribute]
private static IDisposable <Null>k__BackingField;
    public static IDisposable Null { get; }
    public Disposable(Action dispose);
    private static Disposable();
    [CompilerGeneratedAttribute]
public static IDisposable get_Null();
    public static IDisposable Create(Action dispose);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class CliWrap.Utils.EnvironmentEx : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<string> ProcessPathLazy;
    public static string ProcessPath { get; }
    private static EnvironmentEx();
    public static string get_ProcessPath();
}
[ExtensionAttribute]
internal static class CliWrap.Utils.Extensions.AssemblyExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void ExtractManifestResource(Assembly assembly, string resourceName, string destFilePath);
}
[ExtensionAttribute]
internal static class CliWrap.Utils.Extensions.AsyncDisposableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IAsyncDisposable ToAsyncDisposable(IDisposable disposable);
}
[ExtensionAttribute]
internal static class CliWrap.Utils.Extensions.CancellationTokenExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void ThrowIfCancellationRequested(CancellationToken cancellationToken, string message);
}
[ExtensionAttribute]
internal static class CliWrap.Utils.Extensions.ExceptionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Exception TryGetSingle(AggregateException exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class CliWrap.Utils.Extensions.StreamExtensions : object {
    [AsyncStateMachineAttribute("CliWrap.Utils.Extensions.StreamExtensions/<CopyToAsync>d__0")]
[ExtensionAttribute]
public static Task CopyToAsync(Stream source, Stream destination, bool autoFlush, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("CliWrap.Utils.Extensions.StreamExtensions/<ReadAllLinesAsync>d__1")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<string> ReadAllLinesAsync(StreamReader reader, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class CliWrap.Utils.Extensions.StringExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SecureString ToSecureString(string str);
}
[ExtensionAttribute]
internal static class CliWrap.Utils.Extensions.TaskExtensions : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("CliWrap.Utils.Extensions.TaskExtensions/<Select>d__0`2")]
[ExtensionAttribute]
public static Task`1<TDestination> Select(Task`1<TSource> task, Func`2<TSource, TDestination> transform);
}
internal static class CliWrap.Utils.NativeMethods : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class CliWrap.Utils.Observable : object {
    public static IObservable`1<T> Create(Func`2<IObserver`1<T>, IDisposable> subscribe);
    public static IObservable`1<T> CreateSynchronized(Func`2<IObserver`1<T>, IDisposable> subscribe, object syncRoot);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class CliWrap.Utils.Observable`1 : object {
    [CompilerGeneratedAttribute]
private Func`2<IObserver`1<T>, IDisposable> <subscribe>P;
    public Observable`1(Func`2<IObserver`1<T>, IDisposable> subscribe);
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class CliWrap.Utils.ProcessEx : object {
    private Process _nativeProcess;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TaskCompletionSource`1<object> _exitTcs;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExitTime>k__BackingField;
    public int Id { get; }
    public string Name { get; }
    public Stream StandardInput { get; }
    public Stream StandardOutput { get; }
    public Stream StandardError { get; }
    public DateTimeOffset StartTime { get; private set; }
    public DateTimeOffset ExitTime { get; private set; }
    public int ExitCode { get; }
    public ProcessEx(ProcessStartInfo startInfo);
    public int get_Id();
    public string get_Name();
    public Stream get_StandardInput();
    public Stream get_StandardOutput();
    public Stream get_StandardError();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExitTime();
    [CompilerGeneratedAttribute]
private void set_ExitTime(DateTimeOffset value);
    public int get_ExitCode();
    public void Start();
    public void Interrupt();
    public void Kill();
    [AsyncStateMachineAttribute("CliWrap.Utils.ProcessEx/<WaitUntilExitAsync>d__26")]
public Task WaitUntilExitAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <Start>b__23_0(object _, EventArgs _);
    [CompilerGeneratedAttribute]
private bool <Interrupt>g__TryInterrupt|24_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class CliWrap.Utils.SimplexStream : Stream {
    private SemaphoreSlim _writeLock;
    private SemaphoreSlim _readLock;
    private IMemoryOwner`1<byte> _sharedBuffer;
    private int _sharedBufferBytes;
    private int _sharedBufferBytesRead;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [ExcludeFromCodeCoverageAttribute]
public bool CanRead { get; }
    [ExcludeFromCodeCoverageAttribute]
public bool CanSeek { get; }
    [ExcludeFromCodeCoverageAttribute]
public bool CanWrite { get; }
    [ExcludeFromCodeCoverageAttribute]
public long Position { get; public set; }
    [ExcludeFromCodeCoverageAttribute]
public long Length { get; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
public virtual long get_Position();
    [CompilerGeneratedAttribute]
public virtual void set_Position(long value);
    public virtual long get_Length();
    [AsyncStateMachineAttribute("CliWrap.Utils.SimplexStream/<WriteAsync>d__17")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("CliWrap.Utils.SimplexStream/<ReadAsync>d__18")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("CliWrap.Utils.SimplexStream/<ReportCompletionAsync>d__19")]
public Task ReportCompletionAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [ExcludeFromCodeCoverageAttribute]
public virtual int Read(Byte[] buffer, int offset, int count);
    [ExcludeFromCodeCoverageAttribute]
public virtual void Write(Byte[] buffer, int offset, int count);
    [ExcludeFromCodeCoverageAttribute]
public virtual void Flush();
    [ExcludeFromCodeCoverageAttribute]
public virtual long Seek(long offset, SeekOrigin origin);
    [ExcludeFromCodeCoverageAttribute]
public virtual void SetLength(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class CliWrap.Utils.SynchronizedObserver`1 : object {
    [CompilerGeneratedAttribute]
private IObserver`1<T> <observer>P;
    private object _syncRoot;
    public SynchronizedObserver`1(IObserver`1<T> observer, object syncRoot);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class CliWrap.Utils.WindowsSignaler : object {
    [CompilerGeneratedAttribute]
private string <filePath>P;
    public WindowsSignaler(string filePath);
    public bool TrySend(int processId, int signalId);
    public sealed virtual void Dispose();
    public static WindowsSignaler Deploy();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class PolyfillExtensions : object {
    [AsyncStateMachineAttribute("PolyfillExtensions/<GetStreamAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Stream> GetStreamAsync(HttpClient httpClient, string requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<GetStreamAsync>d__1")]
[ExtensionAttribute]
public static Task`1<Stream> GetStreamAsync(HttpClient httpClient, Uri requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<GetByteArrayAsync>d__2")]
[ExtensionAttribute]
public static Task`1<Byte[]> GetByteArrayAsync(HttpClient httpClient, string requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<GetByteArrayAsync>d__3")]
[ExtensionAttribute]
public static Task`1<Byte[]> GetByteArrayAsync(HttpClient httpClient, Uri requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<GetStringAsync>d__4")]
[ExtensionAttribute]
public static Task`1<string> GetStringAsync(HttpClient httpClient, string requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<GetStringAsync>d__5")]
[ExtensionAttribute]
public static Task`1<string> GetStringAsync(HttpClient httpClient, Uri requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadAsStreamAsync>d__6")]
[ExtensionAttribute]
public static Task`1<Stream> ReadAsStreamAsync(HttpContent httpContent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadAsByteArrayAsync>d__7")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadAsByteArrayAsync(HttpContent httpContent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadAsStringAsync>d__8")]
[ExtensionAttribute]
public static Task`1<string> ReadAsStringAsync(HttpContent httpContent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitForExitAsync>d__9")]
[ExtensionAttribute]
public static Task WaitForExitAsync(Process process, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type type, Type otherType);
    [ExtensionAttribute]
public static string ReplaceLineEndings(string str, string replacementText);
    [ExtensionAttribute]
public static string ReplaceLineEndings(string str);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__13")]
[ExtensionAttribute]
public static Task WaitAsync(Task task, TimeSpan timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__14")]
[ExtensionAttribute]
public static Task WaitAsync(Task task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__15")]
[ExtensionAttribute]
public static Task WaitAsync(Task task, TimeSpan timeout);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__16`1")]
[ExtensionAttribute]
public static Task`1<T> WaitAsync(Task`1<T> task, TimeSpan timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__17`1")]
[ExtensionAttribute]
public static Task`1<T> WaitAsync(Task`1<T> task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__18`1")]
[ExtensionAttribute]
public static Task`1<T> WaitAsync(Task`1<T> task, TimeSpan timeout);
    [ExtensionAttribute]
public static int ReadAtLeast(Stream stream, Byte[] buffer, int minimumBytes, bool throwOnEndOfStream);
    [ExtensionAttribute]
public static void ReadExactly(Stream stream, Byte[] buffer, int offset, int count);
    [ExtensionAttribute]
public static void ReadExactly(Stream stream, Byte[] buffer);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadAtLeastAsync>d__22")]
[ExtensionAttribute]
public static Task`1<int> ReadAtLeastAsync(Stream stream, Byte[] buffer, int minimumBytes, bool throwOnEndOfStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadExactlyAsync>d__23")]
[ExtensionAttribute]
public static Task ReadExactlyAsync(Stream stream, Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadExactlyAsync>d__24")]
[ExtensionAttribute]
public static Task ReadExactlyAsync(Stream stream, Byte[] buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int ReadAtLeast(Stream stream, Span`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void ReadExactly(Stream stream, Span`1<byte> buffer);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadAtLeastAsync>d__27")]
[ExtensionAttribute]
public static Task`1<int> ReadAtLeastAsync(Stream stream, Memory`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadExactlyAsync>d__28")]
[ExtensionAttribute]
public static Task ReadExactlyAsync(Stream stream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task CancelAsync(CancellationTokenSource cts);
    [ExtensionAttribute]
public static void Deconstruct(DictionaryEntry entry, Object& key, Object& value);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
    [ExtensionAttribute]
public static IEnumerable`1<Match> AsEnumerable(MatchCollection matchCollection);
    [ExtensionAttribute]
public static IEnumerator`1<Match> GetEnumerator(MatchCollection matchCollection);
    [ExtensionAttribute]
public static Match[] ToArray(MatchCollection matchCollection);
    [ExtensionAttribute]
public static bool StartsWith(string str, char c);
    [ExtensionAttribute]
public static bool EndsWith(string str, char c);
    [ExtensionAttribute]
public static bool Contains(string str, char c);
    [ExtensionAttribute]
public static string Replace(string str, string oldValue, string newValue, StringComparison comparison);
    [ExtensionAttribute]
public static string Replace(string str, string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    [ExtensionAttribute]
public static String[] Split(string str, char separator, int count, StringSplitOptions options);
    [ExtensionAttribute]
public static String[] Split(string str, char separator, StringSplitOptions options);
    [ExtensionAttribute]
public static String[] Split(string str, string separator, int count, StringSplitOptions options);
    [ExtensionAttribute]
public static String[] Split(string str, string separator, StringSplitOptions options);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void NextBytes(Random random, Span`1<byte> buffer);
    [ExtensionAttribute]
public static int Read(Stream stream, Byte[] buffer);
    [ExtensionAttribute]
public static void Write(Stream stream, Byte[] buffer);
    [AsyncStateMachineAttribute("PolyfillExtensions/<CopyToAsync>d__47")]
[ExtensionAttribute]
public static Task CopyToAsync(Stream stream, Stream destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadAsync>d__48")]
[ExtensionAttribute]
public static Task`1<int> ReadAsync(Stream stream, Byte[] buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WriteAsync>d__49")]
[ExtensionAttribute]
public static Task WriteAsync(Stream stream, Byte[] buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int Read(Stream stream, Span`1<byte> buffer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void Write(Stream stream, ReadOnlySpan`1<byte> buffer);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadAsync>d__52")]
[ExtensionAttribute]
public static Task`1<int> ReadAsync(Stream stream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WriteAsync>d__53")]
[ExtensionAttribute]
public static Task WriteAsync(Stream stream, ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static int Read(StreamReader reader, Char[] buffer);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadAsync>d__55")]
[ExtensionAttribute]
public static Task`1<int> ReadAsync(StreamReader reader, Char[] buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int Read(StreamReader reader, Span`1<char> buffer);
    [AsyncStateMachineAttribute("PolyfillExtensions/<ReadAsync>d__57")]
[ExtensionAttribute]
public static Task`1<int> ReadAsync(StreamReader reader, Memory`1<char> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void Write(StreamWriter writer, ReadOnlySpan`1<char> buffer);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WriteAsync>d__59")]
[ExtensionAttribute]
public static Task WriteAsync(StreamWriter writer, Memory`1<char> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool Contains(string str, char c, StringComparison comparison);
    [ExtensionAttribute]
public static bool Contains(string str, string sub, StringComparison comparison);
    private static void KillProcessTree(int processId);
    [ExtensionAttribute]
public static void Kill(Process process, bool entireProcessTree);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Generic.PolyfillExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("28108")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes All;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    public StringSyntaxAttribute(string syntax);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
internal class System.HashCode : object {
    private int _hash;
    private void Add(int hashCode);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    public int ToHashCode();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Index : ValueType {
    private int _value;
    public int Value { get; }
    public bool IsFromEnd { get; }
    public static Index Start { get; }
    public static Index End { get; }
    public Index(int value);
    public Index(int value, bool fromEnd);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public static Index op_Implicit(int value);
}
internal static class System.IO.PolyfillExtensions : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Linq.PolyfillExtensions : object {
    [ExtensionAttribute]
public static T ElementAt(IEnumerable`1<T> source, Index index);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T ElementAtOrDefault(IEnumerable`1<T> source, Index index);
    [ExtensionAttribute]
public static T FirstOrDefault(IEnumerable`1<T> source, T defaultValue);
    [ExtensionAttribute]
public static T FirstOrDefault(IEnumerable`1<T> source, Func`2<T, bool> predicate, T defaultValue);
    [ExtensionAttribute]
public static T LastOrDefault(IEnumerable`1<T> source, T defaultValue);
    [ExtensionAttribute]
public static T LastOrDefault(IEnumerable`1<T> source, Func`2<T, bool> predicate, T defaultValue);
    [ExtensionAttribute]
public static T SingleOrDefault(IEnumerable`1<T> source, T defaultValue);
    [ExtensionAttribute]
public static T SingleOrDefault(IEnumerable`1<T> source, Func`2<T, bool> predicate, T defaultValue);
    [ExtensionAttribute]
public static IEnumerable`1<T> Take(IEnumerable`1<T> source, Range range);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T Min(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T MinBy(IEnumerable`1<T> source, Func`2<T, TKey> keySelector, IComparer`1<TKey> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T MinBy(IEnumerable`1<T> source, Func`2<T, TKey> keySelector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T Max(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T MaxBy(IEnumerable`1<T> source, Func`2<T, TKey> keySelector, IComparer`1<TKey> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T MaxBy(IEnumerable`1<T> source, Func`2<T, TKey> keySelector);
    [ExtensionAttribute]
public static IEnumerable`1<T> DistinctBy(IEnumerable`1<T> source, Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> DistinctBy(IEnumerable`1<T> source, Func`2<T, TKey> keySelector);
    [IteratorStateMachineAttribute("System.Linq.PolyfillExtensions/<ExceptBy>d__17`2")]
[ExtensionAttribute]
public static IEnumerable`1<T> ExceptBy(IEnumerable`1<T> source, IEnumerable`1<TKey> other, Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> ExceptBy(IEnumerable`1<T> source, IEnumerable`1<TKey> other, Func`2<T, TKey> keySelector);
    [IteratorStateMachineAttribute("System.Linq.PolyfillExtensions/<IntersectBy>d__19`2")]
[ExtensionAttribute]
public static IEnumerable`1<T> IntersectBy(IEnumerable`1<T> source, IEnumerable`1<TKey> other, Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> IntersectBy(IEnumerable`1<T> source, IEnumerable`1<TKey> other, Func`2<T, TKey> keySelector);
    [IteratorStateMachineAttribute("System.Linq.PolyfillExtensions/<UnionBy>d__21`2")]
[ExtensionAttribute]
public static IEnumerable`1<T> UnionBy(IEnumerable`1<T> source, IEnumerable`1<T> other, Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> UnionBy(IEnumerable`1<T> source, IEnumerable`1<T> other, Func`2<T, TKey> keySelector);
    [IteratorStateMachineAttribute("System.Linq.PolyfillExtensions/<Chunk>d__23`1")]
[ExtensionAttribute]
public static IEnumerable`1<T[]> Chunk(IEnumerable`1<T> source, int size);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> Order(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderDescending(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderDescending(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> TakeLast(IEnumerable`1<T> source, int count);
    [ExtensionAttribute]
public static IEnumerable`1<T> SkipLast(IEnumerable`1<T> source, int count);
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<TFirst, TSecond>> Zip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second);
}
internal static class System.Management.PolyfillExtensions : object {
}
internal static class System.Net.Http.PolyfillExtensions : object {
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[ExcludeFromCodeCoverageAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
internal static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    [NullableContextAttribute("1")]
public static T[] GetSubArray(T[] array, Range range);
}
[AttributeUsageAttribute("1774")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.InteropServices.LibraryImportAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetLastError>k__BackingField;
    [CompilerGeneratedAttribute]
private StringMarshalling <StringMarshalling>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StringMarshallingCustomType>k__BackingField;
    [NullableAttribute("1")]
public string LibraryName { get; }
    public string EntryPoint { get; public set; }
    public bool SetLastError { get; public set; }
    public StringMarshalling StringMarshalling { get; public set; }
    public Type StringMarshallingCustomType { get; public set; }
    [NullableContextAttribute("1")]
public LibraryImportAttribute(string libraryName);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public bool get_SetLastError();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SetLastError(bool value);
    [CompilerGeneratedAttribute]
public StringMarshalling get_StringMarshalling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StringMarshalling(StringMarshalling value);
    [CompilerGeneratedAttribute]
public Type get_StringMarshallingCustomType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StringMarshallingCustomType(Type value);
}
internal enum System.Runtime.InteropServices.StringMarshalling : Enum {
    public int value__;
    public static StringMarshalling Custom;
    public static StringMarshalling Utf8;
    public static StringMarshalling Utf16;
}
internal static class System.Threading.Tasks.PolyfillExtensions : object {
}
