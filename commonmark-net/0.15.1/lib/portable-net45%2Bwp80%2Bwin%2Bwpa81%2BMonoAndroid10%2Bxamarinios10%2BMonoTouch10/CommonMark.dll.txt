[FlagsAttribute]
public enum CommonMark.CommonMarkAdditionalFeatures : Enum {
    public int value__;
    public static CommonMarkAdditionalFeatures None;
    public static CommonMarkAdditionalFeatures StrikethroughTilde;
    public static CommonMarkAdditionalFeatures PlaceholderBracket;
    public static CommonMarkAdditionalFeatures All;
}
public static class CommonMark.CommonMarkConverter : object {
    private static Lazy`1<Assembly> _assembly;
    private static Lazy`1<Version> _version;
    private static Assembly Assembly { get; }
    public static Version Version { get; }
    [ObsoleteAttribute("Use Version property instead.", "False")]
[DebuggerBrowsableAttribute("0")]
[EditorBrowsableAttribute("1")]
public static Version AssemblyVersion { get; }
    private static CommonMarkConverter();
    private static Assembly get_Assembly();
    private static Assembly InitializeAssembly();
    public static Version get_Version();
    private static Version InitializeVersion();
    public static Version get_AssemblyVersion();
    [EditorBrowsableAttribute("2")]
public static Block ProcessStage1(TextReader source, CommonMarkSettings settings);
    [EditorBrowsableAttribute("2")]
public static void ProcessStage2(Block document, CommonMarkSettings settings);
    [EditorBrowsableAttribute("2")]
public static void ProcessStage3(Block document, TextWriter target, CommonMarkSettings settings);
    public static Block Parse(TextReader source, CommonMarkSettings settings);
    public static Block Parse(string source, CommonMarkSettings settings);
    public static void Convert(TextReader source, TextWriter target, CommonMarkSettings settings);
    public static string Convert(string source, CommonMarkSettings settings);
}
public class CommonMark.CommonMarkException : Exception {
    [CompilerGeneratedAttribute]
private Block <BlockElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Inline <InlineElement>k__BackingField;
    public Block BlockElement { get; private set; }
    public Inline InlineElement { get; private set; }
    public CommonMarkException(string message);
    public CommonMarkException(string message, Exception innerException);
    public CommonMarkException(string message, Inline inline, Exception innerException);
    public CommonMarkException(string message, Block block, Exception innerException);
    [CompilerGeneratedAttribute]
public Block get_BlockElement();
    [CompilerGeneratedAttribute]
private void set_BlockElement(Block value);
    [CompilerGeneratedAttribute]
public Inline get_InlineElement();
    [CompilerGeneratedAttribute]
private void set_InlineElement(Inline value);
}
public class CommonMark.CommonMarkSettings : object {
    [CompilerGeneratedAttribute]
private OutputFormat <OutputFormat>k__BackingField;
    private Action`3<Block, TextWriter, CommonMarkSettings> _outputDelegate;
    [CompilerGeneratedAttribute]
private bool <RenderSoftLineBreaksAsLineBreaks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackSourcePosition>k__BackingField;
    private CommonMarkAdditionalFeatures _additionalFeatures;
    private Func`2<string, string> _uriResolver;
    private static CommonMarkSettings _default;
    private Func`2[] _inlineParsers;
    private Char[] _inlineParserSpecialCharacters;
    public OutputFormat OutputFormat { get; public set; }
    public Action`3<Block, TextWriter, CommonMarkSettings> OutputDelegate { get; public set; }
    public bool RenderSoftLineBreaksAsLineBreaks { get; public set; }
    public bool TrackSourcePosition { get; public set; }
    public CommonMarkAdditionalFeatures AdditionalFeatures { get; public set; }
    public Func`2<string, string> UriResolver { get; public set; }
    public static CommonMarkSettings Default { get; }
    internal Func`2[] InlineParsers { get; }
    internal Char[] InlineParserSpecialCharacters { get; }
    private static CommonMarkSettings();
    [CompilerGeneratedAttribute]
public OutputFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
public void set_OutputFormat(OutputFormat value);
    public Action`3<Block, TextWriter, CommonMarkSettings> get_OutputDelegate();
    public void set_OutputDelegate(Action`3<Block, TextWriter, CommonMarkSettings> value);
    [CompilerGeneratedAttribute]
public bool get_RenderSoftLineBreaksAsLineBreaks();
    [CompilerGeneratedAttribute]
public void set_RenderSoftLineBreaksAsLineBreaks(bool value);
    [CompilerGeneratedAttribute]
public bool get_TrackSourcePosition();
    [CompilerGeneratedAttribute]
public void set_TrackSourcePosition(bool value);
    public CommonMarkAdditionalFeatures get_AdditionalFeatures();
    public void set_AdditionalFeatures(CommonMarkAdditionalFeatures value);
    public Func`2<string, string> get_UriResolver();
    public void set_UriResolver(Func`2<string, string> value);
    public static CommonMarkSettings get_Default();
    public CommonMarkSettings Clone();
    internal Func`2[] get_InlineParsers();
    internal Char[] get_InlineParserSpecialCharacters();
}
public class CommonMark.Formatters.HtmlFormatter : object {
    private HtmlTextWriter _target;
    private CommonMarkSettings _settings;
    private Stack`1<bool> _renderTightParagraphs;
    private Stack`1<bool> _renderPlainTextInlines;
    private Stack`1<char> _endPlaceholders;
    private Func`2<string, string> _placeholderResolver;
    protected Stack`1<bool> RenderTightParagraphs { get; }
    protected Stack`1<bool> RenderPlainTextInlines { get; }
    protected CommonMarkSettings Settings { get; }
    public Func`2<string, string> PlaceholderResolver { get; public set; }
    public HtmlFormatter(TextWriter target, CommonMarkSettings settings);
    protected Stack`1<bool> get_RenderTightParagraphs();
    protected Stack`1<bool> get_RenderPlainTextInlines();
    protected CommonMarkSettings get_Settings();
    public void WriteDocument(Block document);
    protected virtual void WriteBlock(Block block, bool isOpening, bool isClosing, Boolean& ignoreChildNodes);
    protected virtual void WriteInline(Inline inline, bool isOpening, bool isClosing, Boolean& ignoreChildNodes);
    protected void Write(string text);
    private void Write(StringPart text);
    protected void Write(StringContent text);
    protected void Write(char c);
    protected void EnsureNewLine();
    protected void WriteLine();
    protected void WriteLine(string text);
    protected void WriteEncodedHtml(StringContent text);
    protected void WriteEncodedHtml(string text);
    private void WriteEncodedHtml(StringPart text);
    protected void WriteEncodedUrl(string url);
    protected void WritePositionAttribute(Block block);
    protected void WritePositionAttribute(Inline inline);
    public Func`2<string, string> get_PlaceholderResolver();
    public void set_PlaceholderResolver(Func`2<string, string> value);
}
internal static class CommonMark.Formatters.HtmlFormatterSlim : object {
    private static Char[] EscapeHtmlCharacters;
    private static string HexCharacters;
    private static Char[] EscapeHtmlLessThan;
    private static Char[] EscapeHtmlGreaterThan;
    private static Char[] EscapeHtmlAmpersand;
    private static Char[] EscapeHtmlQuote;
    private static String[] HeadingOpenerTags;
    private static String[] HeadingCloserTags;
    private static Boolean[] UrlSafeCharacters;
    private static HtmlFormatterSlim();
    internal static void EscapeUrl(string input, HtmlTextWriter target);
    internal static void EscapeHtml(StringPart input, HtmlTextWriter target);
    internal static void EscapeHtml(StringContent inp, HtmlTextWriter target);
    public static void BlocksToHtml(TextWriter writer, Block block, CommonMarkSettings settings);
    internal static void PrintPosition(HtmlTextWriter writer, Block block);
    internal static void PrintPosition(HtmlTextWriter writer, Inline inline);
    private static void BlocksToHtmlInner(HtmlTextWriter writer, Block block, CommonMarkSettings settings);
    private static void InlinesToPlainText(HtmlTextWriter writer, Inline inline, Stack`1<InlineStackEntry> stack);
    private static void InlinesToHtml(HtmlTextWriter writer, Inline inline, CommonMarkSettings settings, Stack`1<InlineStackEntry> stack);
}
internal class CommonMark.Formatters.HtmlTextWriter : object {
    private TextWriter _inner;
    private char _last;
    private bool _windowsNewLine;
    private Char[] _newline;
    internal Char[] Buffer;
    public HtmlTextWriter(TextWriter inner);
    public void WriteLine();
    public void WriteLine(char data);
    public void Write(StringPart value);
    public void WriteConstant(Char[] value);
    public void WriteConstant(Char[] value, int startIndex, int length);
    public void WriteConstant(string value);
    public void WriteLineConstant(string value);
    public void Write(Char[] value, int index, int count);
    public void Write(char value);
    public void EnsureLine();
}
internal static class CommonMark.Formatters.Printer : object {
    private static string format_str(string s, StringBuilder buffer);
    private static void PrintPosition(bool enabled, TextWriter writer, Block block);
    private static void PrintPosition(bool enabled, TextWriter writer, Inline inline);
    public static void PrintBlocks(TextWriter writer, Block block, CommonMarkSettings settings);
    private static void PrintInlines(TextWriter writer, Inline inline, int indent, Stack`1<InlineStackEntry> stack, StringBuilder buffer, bool trackPositions);
}
public enum CommonMark.OutputFormat : Enum {
    public int value__;
    public static OutputFormat Html;
    public static OutputFormat SyntaxTree;
    public static OutputFormat CustomDelegate;
}
internal static class CommonMark.Parser.BlockMethods : object {
    private static int CODE_INDENT;
    private static int TabSize;
    private static string Spaces;
    private static bool CanContain(BlockTag parent_type, BlockTag child_type);
    private static bool AcceptsLines(BlockTag block_type);
    private static void AddLine(Block block, LineInfo lineInfo, string ln, int offset, int remainingSpaces, int length);
    private static bool EndsWithBlankLine(Block block);
    public static void Finalize(Block b, LineInfo line);
    public static Block CreateChildBlock(Block parent, LineInfo line, BlockTag blockType, int startColumn);
    private static void AdjustInlineSourcePosition(Inline inline, PositionTracker tracker, Stack`1& stack);
    public static void ProcessInlines(Block block, DocumentData data, CommonMarkSettings settings);
    private static int ParseListMarker(string ln, int pos, bool interruptsParagraph, ListData& data);
    private static bool ListsMatch(ListData listData, ListData itemData);
    private static bool AdvanceOptionalSpace(string line, Int32& offset, Int32& column, Int32& remainingSpaces);
    private static void AdvanceOffset(string line, int count, bool columns, Int32& offset, Int32& column, Int32& remainingSpaces);
    public static void IncorporateLine(LineInfo line, Block& curptr);
    private static void FindFirstNonspace(string ln, int offset, int column, Int32& first_nonspace, Int32& first_nonspace_column, Char& curChar);
}
internal static class CommonMark.Parser.EntityDecoder : object {
    private static Dictionary`2<string, string> _entityMap;
    private static EntityDecoder();
    public static string DecodeEntity(string entity);
    public static string DecodeEntity(int utf32);
}
internal static class CommonMark.Parser.InlineMethods : object {
    private static Char[] WhiteSpaceCharacters;
    private static Char[] BracketSpecialCharacters;
    private static InlineMethods();
    internal static Func`2[] InitializeParsers(CommonMarkSettings settings);
    private static string NormalizeReference(StringPart s);
    private static Reference LookupReference(DocumentData data, StringPart lab);
    private static void AddReference(Dictionary`2<string, Reference> refmap, StringPart label, string url, string title);
    private static char peek_char(Subject subj);
    private static int ScanToClosingBackticks(Subject subj, int openticklength);
    internal static string NormalizeWhitespace(string s, int startIndex, int count);
    private static Inline handle_backticks(Subject subj);
    private static int ScanEmphasisDelimiters(Subject subj, char delimiter, Boolean& canOpen, Boolean& canClose);
    internal static int MatchInlineStack(InlineStack opener, Subject subj, int closingDelimiterCount, InlineStack closer, InlineTag singleCharTag, InlineTag doubleCharTag);
    private static Inline HandleEmphasis(Subject subj);
    private static Inline HandleTilde(Subject subj);
    private static Inline HandleOpenerCloser(Subject subj, InlineTag singleCharTag, InlineTag doubleCharTag);
    private static Inline HandleExclamation(Subject subj);
    private static Inline HandleLeftSquareBracket(Subject subj);
    private static Inline HandleLeftSquareBracket(Subject subj, bool isImage);
    internal static void MatchSquareBracketStack(InlineStack opener, Subject subj, Reference details);
    private static Inline HandleRightSquareBracket(Subject subj, bool supportPlaceholderBrackets);
    private static Inline handle_backslash(Subject subj);
    private static Inline HandleEntity(Subject subj);
    private static string ParseEntity(Subject subj);
    private static Inline ParseStringEntities(string s);
    public static string Unescape(string url);
    private static string CleanUrl(string url);
    private static string CleanTitle(string title);
    private static Inline handle_pointy_brace(Subject subj);
    private static Reference ParseLinkDetails(Subject subj, bool supportPlaceholderBrackets);
    private static Inline handle_newline(Subject subj);
    public static Inline ParseInline(Subject subj, Func`2[] parsers, Char[] specialCharacters);
    public static Inline parse_inlines(Subject subj, Func`2[] parsers, Char[] specialCharacters);
    private static void spnl(Subject subj);
    private static Nullable`1<StringPart> ParseReferenceLabel(Subject subj);
    public static int ParseReference(Subject subj);
}
internal class CommonMark.Parser.InlineStack : object {
    public InlineStackPriority Priority;
    public InlineStack Previous;
    public InlineStack Next;
    public Inline StartingInline;
    public int DelimiterCount;
    public char Delimiter;
    public int StartPosition;
    public InlineStackFlags Flags;
    public static InlineStack FindMatchingOpener(InlineStack searchBackwardsFrom, InlineStackPriority priority, char delimiter, int closerDelimiterCount, bool closerCanOpen, Boolean& canClose);
    public static void AppendStackEntry(InlineStack entry, Subject subj);
    public static void RemoveStackEntry(InlineStack first, Subject subj, InlineStack last);
    public static void PostProcessInlineStack(Subject subj, InlineStack first, InlineStack last, InlineStackPriority ignorePriority);
}
internal class CommonMark.Parser.LineInfo : object {
    public bool IsTrackingPositions;
    public string Line;
    public int LineOffset;
    public int LineNumber;
    public PositionOffset[] Offsets;
    public int OffsetCount;
    public LineInfo(bool trackPositions);
    public void AddOffset(int position, int offset);
    public virtual string ToString();
    public int CalculateOrigin(int position, bool isStartPosition);
}
internal class CommonMark.Parser.PositionOffset : ValueType {
    public int Position;
    public int Offset;
    public PositionOffset(int position, int offset);
    public virtual string ToString();
}
internal class CommonMark.Parser.PositionTracker : object {
    private static PositionOffset EmptyPositionOffset;
    private int _blockOffset;
    private PositionOffset[] Offsets;
    private int OffsetCount;
    public PositionTracker(int blockOffset);
    private static PositionTracker();
    public void AddBlockOffset(int offset);
    public void AddOffset(LineInfo line, int startIndex, int length);
    public int CalculateInlineOrigin(int position, bool isStartPosition);
    internal static int CalculateOrigin(PositionOffset[] offsets, int offsetCount, int position, bool includeReduce, bool isStart);
}
internal static class CommonMark.Parser.Scanner : object {
    private static String[] blockTagNames;
    private static Scanner();
    public static HtmlBlockType scan_html_block_start(string s, int pos, int sourceLength);
    public static HtmlBlockType scan_html_block_start_7(string s, int pos, int sourceLength);
    public static bool scan_html_block_end(HtmlBlockType type, string s, int pos, int sourceLength);
    private static bool _scan_html_block_end_1(string s, int pos, int sourceLength);
    private static bool _scan_html_block_end_2(string s, int pos, int sourceLength);
    private static bool _scan_html_block_end_3(string s, int pos, int sourceLength);
    private static bool _scan_html_block_end_4(string s, int pos, int sourceLength);
    private static bool _scan_html_block_end_5(string s, int pos, int sourceLength);
    private static int _scanHtmlTagCloseTag(string s, int pos, int sourceLength);
    private static int _scanHtmlTagProcessingInstruction(string s, int pos, int sourceLength);
    private static int _scanHtmlTagHtmlComment(string s, int pos, int sourceLength);
    private static int _scanHtmlTagCData(string s, int pos, int sourceLength);
    private static int _scanHtmlTagDeclaration(string s, int pos, int sourceLength);
    private static int _scanHtmlTagOpenTag(string s, int pos, int sourceLength);
    public static int scan_html_tag(string s, int pos, int sourceLength);
    public static int scan_autolink_uri(string s, int pos, int sourceLength);
    public static int scan_autolink_email(string s, int pos, int sourceLength);
    public static int scan_link_url(string s, int pos, int sourceLength);
    public static int scan_link_title(string s, int pos, int sourceLength);
    public static int scan_spacechars(string s, int pos, int sourceLength);
    public static int scan_atx_heading_start(string s, int pos, int sourceLength, Int32& headingLevel);
    public static int scan_setext_heading_line(string s, int pos, int sourceLength);
    public static int scan_thematic_break(string s, int pos, int sourceLength);
    public static int scan_open_code_fence(string s, int pos, int sourceLength);
    public static int scan_close_code_fence(string s, int pos, int len, int sourceLength);
    public static int scan_entity(string s, int pos, int length, String& namedEntity, Int32& numericEntity);
    public static bool HasNonWhitespace(StringPart part);
}
internal static class CommonMark.Parser.ScannerCharacterMatcher : object {
    internal static bool MatchWhitespaces(string data, Char& currentCharacter, Int32& currentPosition, int lastPosition);
    internal static bool MatchAsciiLetter(string data, Char& currentCharacter, Int32& currentPosition, int lastPosition);
    internal static bool MatchHtmlTagNameCharacter(string data, Char& currentCharacter, Int32& currentPosition, int lastPosition);
    internal static bool MatchAsciiLetterOrDigit(string data, Char& currentCharacter, Int32& currentPosition, int lastPosition, char valid1, char valid2, char valid3, char valid4);
    internal static bool MatchAsciiLetterOrDigit(string data, Char& currentCharacter, Int32& currentPosition, int lastPosition, char valid1);
    internal static bool MatchAsciiLetter(string data, Char& currentCharacter, Int32& currentPosition, int lastPosition, char valid1, char valid2);
    internal static bool MatchAnythingExcept(string data, Char& currentCharacter, Int32& currentPosition, int lastPosition, char invalid1);
    internal static bool MatchAnythingExceptWhitespaces(string data, Char& currentCharacter, Int32& currentPosition, int lastPosition, char invalid1, char invalid2, char invalid3, char invalid4, char invalid5, char invalid6);
}
[DebuggerDisplayAttribute("{DebugToString()}")]
internal class CommonMark.Parser.Subject : object {
    public string Buffer;
    public int Position;
    public int Length;
    public Inline LastInline;
    public InlineStack LastPendingInline;
    public InlineStack FirstPendingInline;
    public StringBuilder ReusableStringBuilder;
    public DocumentData DocumentData;
    public Subject(DocumentData documentData);
    public Subject(string buffer, DocumentData documentData);
    private string DebugToString();
}
internal class CommonMark.Parser.TabTextReader : object {
    private static int _bufferSize;
    private TextReader _inner;
    private Char[] _buffer;
    private int _bufferLength;
    private int _bufferPosition;
    private int _previousBufferLength;
    private StringBuilder _builder;
    private bool _endOfStream;
    public TabTextReader(TextReader inner);
    private bool ReadBuffer();
    public void ReadLine(LineInfo line);
    public bool EndOfStream();
}
public class CommonMark.Syntax.Block : object {
    [CompilerGeneratedAttribute]
private BlockTag <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private HtmlBlockType <HtmlBlockType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourcePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourceLastPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastLineBlank>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <FirstChild>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <LastChild>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private StringContent <StringContent>k__BackingField;
    [CompilerGeneratedAttribute]
private Inline <InlineContent>k__BackingField;
    [CompilerGeneratedAttribute]
private ListData <ListData>k__BackingField;
    [CompilerGeneratedAttribute]
private FencedCodeData <FencedCodeData>k__BackingField;
    [CompilerGeneratedAttribute]
private HeadingData <Heading>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentData <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <NextSibling>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <Previous>k__BackingField;
    public BlockTag Tag { get; public set; }
    public HtmlBlockType HtmlBlockType { get; public set; }
    [ObsoleteAttribute("This is deprecated in favor of SourcePosition/SourceLength and will be removed in future. If you have a use case where this property cannot be replaced with the new ones, please log an issue at https://github.com/Knagis/CommonMark.NET", "False")]
[DebuggerBrowsableAttribute("0")]
[EditorBrowsableAttribute("1")]
public int StartLine { get; public set; }
    [ObsoleteAttribute("This is deprecated in favor of SourcePosition/SourceLength and will be removed in future. If you have a use case where this property cannot be replaced with the new ones, please log an issue at https://github.com/Knagis/CommonMark.NET", "False")]
[DebuggerBrowsableAttribute("0")]
[EditorBrowsableAttribute("1")]
public int StartColumn { get; public set; }
    [ObsoleteAttribute("This is deprecated in favor of SourcePosition/SourceLength and will be removed in future. If you have a use case where this property cannot be replaced with the new ones, please log an issue at https://github.com/Knagis/CommonMark.NET", "False")]
[DebuggerBrowsableAttribute("0")]
[EditorBrowsableAttribute("1")]
public int EndLine { get; public set; }
    public int SourcePosition { get; public set; }
    internal int SourceLastPosition { get; internal set; }
    public int SourceLength { get; public set; }
    public bool IsOpen { get; public set; }
    public bool IsLastLineBlank { get; public set; }
    public Block FirstChild { get; public set; }
    public Block LastChild { get; public set; }
    public Block Parent { get; public set; }
    public Block Top { get; public set; }
    public StringContent StringContent { get; public set; }
    public Inline InlineContent { get; public set; }
    public ListData ListData { get; public set; }
    public FencedCodeData FencedCodeData { get; public set; }
    public HeadingData Heading { get; public set; }
    [ObsoleteAttribute("Use Heading instead.")]
public int HeaderLevel { get; public set; }
    public DocumentData Document { get; public set; }
    [ObsoleteAttribute("Use Document instead.")]
public Dictionary`2<string, Reference> ReferenceMap { get; public set; }
    public Block NextSibling { get; public set; }
    [ObsoleteAttribute("This property will be removed in future. If you have a use case where this property is required, please log an issue at https://github.com/Knagis/CommonMark.NET", "False")]
[DebuggerBrowsableAttribute("0")]
[EditorBrowsableAttribute("1")]
public Block Previous { get; public set; }
    public Block(BlockTag tag, int sourcePosition);
    [ObsoleteAttribute("StartLine/StartColumn are deprecated in favor of SourcePosition/SourceLength and will be removed in future. If you have a use case where this property cannot be replaced with the new ones, please log an issue at https://github.com/Knagis/CommonMark.NET", "False")]
public Block(BlockTag tag, int startLine, int startColumn, int sourcePosition);
    public IEnumerable`1<EnumeratorEntry> AsEnumerable();
    internal static Block CreateDocument();
    [CompilerGeneratedAttribute]
public BlockTag get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(BlockTag value);
    [CompilerGeneratedAttribute]
public HtmlBlockType get_HtmlBlockType();
    [CompilerGeneratedAttribute]
public void set_HtmlBlockType(HtmlBlockType value);
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public void set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public void set_StartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_SourcePosition();
    [CompilerGeneratedAttribute]
public void set_SourcePosition(int value);
    [CompilerGeneratedAttribute]
internal int get_SourceLastPosition();
    [CompilerGeneratedAttribute]
internal void set_SourceLastPosition(int value);
    public int get_SourceLength();
    public void set_SourceLength(int value);
    [CompilerGeneratedAttribute]
public bool get_IsOpen();
    [CompilerGeneratedAttribute]
public void set_IsOpen(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastLineBlank();
    [CompilerGeneratedAttribute]
public void set_IsLastLineBlank(bool value);
    [CompilerGeneratedAttribute]
public Block get_FirstChild();
    [CompilerGeneratedAttribute]
public void set_FirstChild(Block value);
    [CompilerGeneratedAttribute]
public Block get_LastChild();
    [CompilerGeneratedAttribute]
public void set_LastChild(Block value);
    [CompilerGeneratedAttribute]
public Block get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(Block value);
    [CompilerGeneratedAttribute]
public Block get_Top();
    [CompilerGeneratedAttribute]
public void set_Top(Block value);
    [CompilerGeneratedAttribute]
public StringContent get_StringContent();
    [CompilerGeneratedAttribute]
public void set_StringContent(StringContent value);
    [CompilerGeneratedAttribute]
public Inline get_InlineContent();
    [CompilerGeneratedAttribute]
public void set_InlineContent(Inline value);
    [CompilerGeneratedAttribute]
public ListData get_ListData();
    [CompilerGeneratedAttribute]
public void set_ListData(ListData value);
    [CompilerGeneratedAttribute]
public FencedCodeData get_FencedCodeData();
    [CompilerGeneratedAttribute]
public void set_FencedCodeData(FencedCodeData value);
    [CompilerGeneratedAttribute]
public HeadingData get_Heading();
    [CompilerGeneratedAttribute]
public void set_Heading(HeadingData value);
    public int get_HeaderLevel();
    public void set_HeaderLevel(int value);
    [CompilerGeneratedAttribute]
public DocumentData get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(DocumentData value);
    public Dictionary`2<string, Reference> get_ReferenceMap();
    public void set_ReferenceMap(Dictionary`2<string, Reference> value);
    [CompilerGeneratedAttribute]
public Block get_NextSibling();
    [CompilerGeneratedAttribute]
public void set_NextSibling(Block value);
    [CompilerGeneratedAttribute]
public Block get_Previous();
    [CompilerGeneratedAttribute]
public void set_Previous(Block value);
}
public enum CommonMark.Syntax.BlockTag : Enum {
    public byte value__;
    public static BlockTag Document;
    public static BlockTag BlockQuote;
    public static BlockTag List;
    public static BlockTag ListItem;
    public static BlockTag FencedCode;
    public static BlockTag IndentedCode;
    public static BlockTag HtmlBlock;
    public static BlockTag Paragraph;
    public static BlockTag AtxHeading;
    [ObsoleteAttribute("Use AtxHeading instead.")]
public static BlockTag AtxHeader;
    public static BlockTag SetextHeading;
    [ObsoleteAttribute("Use SetextHeading instead.")]
public static BlockTag SETextHeader;
    public static BlockTag ThematicBreak;
    [ObsoleteAttribute("Use ThematicBreak instead.")]
public static BlockTag HorizontalRuler;
    public static BlockTag ReferenceDefinition;
}
public class CommonMark.Syntax.DocumentData : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Reference> <ReferenceMap>k__BackingField;
    public Dictionary`2<string, Reference> ReferenceMap { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Reference> get_ReferenceMap();
    [CompilerGeneratedAttribute]
public void set_ReferenceMap(Dictionary`2<string, Reference> value);
}
public class CommonMark.Syntax.EmphasisData : ValueType {
    [CompilerGeneratedAttribute]
private char <DelimiterCharacter>k__BackingField;
    public char DelimiterCharacter { get; public set; }
    public EmphasisData(char delimiterCharacter);
    [CompilerGeneratedAttribute]
public char get_DelimiterCharacter();
    [CompilerGeneratedAttribute]
public void set_DelimiterCharacter(char value);
}
internal class CommonMark.Syntax.Enumerable : object {
    private Block _root;
    public Enumerable(Block root);
    public sealed virtual IEnumerator`1<EnumeratorEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class CommonMark.Syntax.EnumeratorEntry : object {
    [CompilerGeneratedAttribute]
private bool <IsOpening>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClosing>k__BackingField;
    [CompilerGeneratedAttribute]
private Inline <Inline>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <Block>k__BackingField;
    public bool IsOpening { get; private set; }
    public bool IsClosing { get; private set; }
    public Inline Inline { get; private set; }
    public Block Block { get; private set; }
    public EnumeratorEntry(bool opening, bool closing, Block block);
    public EnumeratorEntry(bool opening, bool closing, Inline inline);
    [CompilerGeneratedAttribute]
public bool get_IsOpening();
    [CompilerGeneratedAttribute]
private void set_IsOpening(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsClosing();
    [CompilerGeneratedAttribute]
private void set_IsClosing(bool value);
    [CompilerGeneratedAttribute]
public Inline get_Inline();
    [CompilerGeneratedAttribute]
private void set_Inline(Inline value);
    [CompilerGeneratedAttribute]
public Block get_Block();
    [CompilerGeneratedAttribute]
private void set_Block(Block value);
    public virtual string ToString();
}
public class CommonMark.Syntax.FencedCodeData : object {
    [CompilerGeneratedAttribute]
private int <FenceLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FenceOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private char <FenceChar>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Info>k__BackingField;
    public int FenceLength { get; public set; }
    public int FenceOffset { get; public set; }
    public char FenceChar { get; public set; }
    public string Info { get; public set; }
    [CompilerGeneratedAttribute]
public int get_FenceLength();
    [CompilerGeneratedAttribute]
public void set_FenceLength(int value);
    [CompilerGeneratedAttribute]
public int get_FenceOffset();
    [CompilerGeneratedAttribute]
public void set_FenceOffset(int value);
    [CompilerGeneratedAttribute]
public char get_FenceChar();
    [CompilerGeneratedAttribute]
public void set_FenceChar(char value);
    [CompilerGeneratedAttribute]
public string get_Info();
    [CompilerGeneratedAttribute]
public void set_Info(string value);
}
public class CommonMark.Syntax.HeadingData : ValueType {
    [CompilerGeneratedAttribute]
private byte <Level>k__BackingField;
    public byte Level { get; public set; }
    public HeadingData(int level);
    [CompilerGeneratedAttribute]
public byte get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(byte value);
}
public enum CommonMark.Syntax.HtmlBlockType : Enum {
    public int value__;
    public static HtmlBlockType None;
    public static HtmlBlockType InterruptingBlockWithEmptyLines;
    public static HtmlBlockType Comment;
    public static HtmlBlockType ProcessingInstruction;
    public static HtmlBlockType DocumentType;
    public static HtmlBlockType CData;
    public static HtmlBlockType InterruptingBlock;
    public static HtmlBlockType NonInterruptingBlock;
}
public class CommonMark.Syntax.Inline : object {
    [CompilerGeneratedAttribute]
private InlineTag <Tag>k__BackingField;
    internal StringPart LiteralContentValue;
    [CompilerGeneratedAttribute]
private string <TargetUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Inline <FirstChild>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourcePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourceLastPosition>k__BackingField;
    private Inline _next;
    [CompilerGeneratedAttribute]
private EmphasisData <Emphasis>k__BackingField;
    public InlineTag Tag { get; public set; }
    public string LiteralContent { get; public set; }
    public string TargetUrl { get; public set; }
    public Inline FirstChild { get; public set; }
    public int SourcePosition { get; public set; }
    internal int SourceLastPosition { get; internal set; }
    public int SourceLength { get; public set; }
    [ObsoleteAttribute("The link properties have been moved to TargetUrl and LiteralContent (previously Title) properties to reduce number of objects created. This property will be removed in future versions.", "False")]
[DebuggerBrowsableAttribute("0")]
[EditorBrowsableAttribute("1")]
public InlineContentLinkable Linkable { get; }
    public Inline NextSibling { get; public set; }
    public Inline LastSibling { get; }
    public EmphasisData Emphasis { get; }
    public Inline(InlineTag tag);
    public Inline(InlineTag tag, string content);
    internal Inline(InlineTag tag, string content, int startIndex, int length);
    public Inline(string content);
    internal Inline(string content, int sourcePosition, int sourceLastPosition);
    internal Inline(string content, int startIndex, int length, int sourcePosition, int sourceLastPosition, char delimiterCharacter);
    public Inline(InlineTag tag, Inline content);
    internal static Inline CreateLink(Inline label, string url, string title);
    [CompilerGeneratedAttribute]
public InlineTag get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(InlineTag value);
    public string get_LiteralContent();
    public void set_LiteralContent(string value);
    [CompilerGeneratedAttribute]
public string get_TargetUrl();
    [CompilerGeneratedAttribute]
public void set_TargetUrl(string value);
    [CompilerGeneratedAttribute]
public Inline get_FirstChild();
    [CompilerGeneratedAttribute]
public void set_FirstChild(Inline value);
    [CompilerGeneratedAttribute]
public int get_SourcePosition();
    [CompilerGeneratedAttribute]
public void set_SourcePosition(int value);
    [CompilerGeneratedAttribute]
internal int get_SourceLastPosition();
    [CompilerGeneratedAttribute]
internal void set_SourceLastPosition(int value);
    public int get_SourceLength();
    public void set_SourceLength(int value);
    public InlineContentLinkable get_Linkable();
    public Inline get_NextSibling();
    public void set_NextSibling(Inline value);
    public Inline get_LastSibling();
    [CompilerGeneratedAttribute]
public EmphasisData get_Emphasis();
}
[ObsoleteAttribute("These properties have been moved directly into the Inline element.")]
[EditorBrowsableAttribute("1")]
public class CommonMark.Syntax.InlineContentLinkable : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Url { get; public set; }
    public string Title { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
}
public enum CommonMark.Syntax.InlineTag : Enum {
    public byte value__;
    public static InlineTag String;
    public static InlineTag SoftBreak;
    public static InlineTag LineBreak;
    public static InlineTag Code;
    public static InlineTag RawHtml;
    public static InlineTag Emphasis;
    public static InlineTag Strong;
    public static InlineTag Link;
    public static InlineTag Image;
    public static InlineTag Strikethrough;
    public static InlineTag Placeholder;
}
public class CommonMark.Syntax.ListData : object {
    [CompilerGeneratedAttribute]
private int <MarkerOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Padding>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private char <BulletChar>k__BackingField;
    [CompilerGeneratedAttribute]
private ListType <ListType>k__BackingField;
    [CompilerGeneratedAttribute]
private ListDelimiter <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTight>k__BackingField;
    public int MarkerOffset { get; public set; }
    public int Padding { get; public set; }
    public int Start { get; public set; }
    public char BulletChar { get; public set; }
    public ListType ListType { get; public set; }
    public ListDelimiter Delimiter { get; public set; }
    public bool IsTight { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MarkerOffset();
    [CompilerGeneratedAttribute]
public void set_MarkerOffset(int value);
    [CompilerGeneratedAttribute]
public int get_Padding();
    [CompilerGeneratedAttribute]
public void set_Padding(int value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public char get_BulletChar();
    [CompilerGeneratedAttribute]
public void set_BulletChar(char value);
    [CompilerGeneratedAttribute]
public ListType get_ListType();
    [CompilerGeneratedAttribute]
public void set_ListType(ListType value);
    [CompilerGeneratedAttribute]
public ListDelimiter get_Delimiter();
    [CompilerGeneratedAttribute]
public void set_Delimiter(ListDelimiter value);
    [CompilerGeneratedAttribute]
public bool get_IsTight();
    [CompilerGeneratedAttribute]
public void set_IsTight(bool value);
}
public enum CommonMark.Syntax.ListDelimiter : Enum {
    public byte value__;
    public static ListDelimiter Period;
    public static ListDelimiter Parenthesis;
}
public enum CommonMark.Syntax.ListType : Enum {
    public int value__;
    public static ListType Bullet;
    public static ListType Ordered;
}
public class CommonMark.Syntax.Reference : object {
    public static int MaximumReferenceLabelLength;
    internal static Reference SelfReference;
    internal static Reference InvalidReference;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPlaceholder>k__BackingField;
    public string Label { get; public set; }
    public string Url { get; public set; }
    public string Title { get; public set; }
    public bool IsPlaceholder { get; public set; }
    public Reference(string label, string url, string title);
    private static Reference();
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPlaceholder();
    [CompilerGeneratedAttribute]
public void set_IsPlaceholder(bool value);
}
public class CommonMark.Syntax.StringContent : object {
    private int _partCounter;
    private int _length;
    private int _partsLength;
    private StringPart[] _parts;
    internal PositionTracker PositionTracker;
    public int Length { get; }
    public int get_Length();
    private void RecalculateLength();
    public void Append(string source, int startIndex, int length);
    public string ToString(StringBuilder buffer);
    public virtual string ToString();
    internal void FillSubject(Subject subj);
    public void WriteTo(TextWriter writer);
    internal void WriteTo(HtmlTextWriter writer);
    public bool StartsWith(char character);
    public void Replace(string data, int startIndex, int length);
    public int IndexOf(char character);
    public string TakeFromStart(int length, bool trim);
    public void TrimEnd();
    public void RemoveTrailingBlankLines();
    internal ArraySegment`1<StringPart> RetrieveParts();
}
internal class CommonMark.Syntax.StringPart : ValueType {
    public string Source;
    public int StartIndex;
    public int Length;
    public StringPart(string source, int startIndex, int length);
    public virtual string ToString();
}
internal static class CommonMark.Utilities : object {
    [ConditionalAttribute("DEBUG")]
public static void Warning(string message, Object[] args);
    public static bool IsEscapableSymbol(char c);
    public static bool IsAsciiLetter(char c);
    public static bool IsAsciiLetterOrDigit(char c);
    public static bool IsWhitespace(char c);
    public static void CheckUnicodeCategory(char c, Boolean& space, Boolean& punctuation);
    public static bool IsFirstLineBlank(string source, int startIndex);
}
