[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class CommunityToolkit.Mvvm.ArgumentNullException : object {
    public static void ThrowIfNull(object argument, string paramName);
    [DoesNotReturnAttribute]
private static void Throw(string paramName);
}
internal static class CommunityToolkit.Mvvm.Collections.Internals.ObservableGroupHelper : object {
    [NullableAttribute("1")]
public static PropertyChangedEventArgs KeyChangedEventArgs;
    private static ObservableGroupHelper();
}
[DefaultMemberAttribute("Item")]
public interface CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup {
    [NullableAttribute("1")]
public object Key { get; }
    public int Count { get; }
    [NullableAttribute("2")]
public object Item { get; }
    [NullableContextAttribute("1")]
public abstract virtual object get_Key();
    public abstract virtual int get_Count();
    [NullableContextAttribute("2")]
public abstract virtual object get_Item(int index);
}
public interface CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup`1 {
    [NullableAttribute("1")]
public TKey Key { get; }
    [NullableContextAttribute("1")]
public abstract virtual TKey get_Key();
}
[DefaultMemberAttribute("Item")]
public interface CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup`2 {
    [NullableAttribute("1")]
public TElement Item { get; }
    [NullableContextAttribute("1")]
public abstract virtual TElement get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerDisplayAttribute("Key = {Key}, Count = {Count}")]
public class CommunityToolkit.Mvvm.Collections.ObservableGroup`2 : ObservableCollection`1<TElement> {
    private TKey key;
    public TKey Key { get; public set; }
    private object CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup.Key { get; }
    [NullableAttribute("2")]
private object CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup.Item { get; }
    public ObservableGroup`2(TKey key);
    public ObservableGroup`2(IGrouping`2<TKey, TElement> grouping);
    public ObservableGroup`2(TKey key, IEnumerable`1<TElement> collection);
    public sealed virtual TKey get_Key();
    public void set_Key(TKey value);
    internal bool TryGetList(List`1& list);
    private sealed virtual override object CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup.get_Key();
    [NullableContextAttribute("2")]
private sealed virtual override object CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class CommunityToolkit.Mvvm.Collections.ObservableGroupedCollection`2 : ObservableCollection`1<ObservableGroup`2<TKey, TElement>> {
    private IEnumerable`1<TElement> System.Linq.ILookup<TKey,TElement>.Item { get; }
    public ObservableGroupedCollection`2(IEnumerable`1<IGrouping`2<TKey, TElement>> collection);
    private sealed virtual override IEnumerable`1<TElement> System.Linq.ILookup<TKey,TElement>.get_Item(TKey key);
    internal bool TryGetList(List`1& list);
    private sealed virtual override bool System.Linq.ILookup<TKey,TElement>.Contains(TKey key);
    private sealed virtual override IEnumerator`1<IGrouping`2<TKey, TElement>> System.Collections.Generic.IEnumerable<System.Linq.IGrouping<TKey,TElement>>.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class CommunityToolkit.Mvvm.Collections.ObservableGroupedCollectionExtensions : object {
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> FirstGroupByKey(ObservableGroupedCollection`2<TKey, TElement> source, TKey key);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> FirstGroupByKeyOrDefault(ObservableGroupedCollection`2<TKey, TElement> source, TKey key);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> AddGroup(ObservableGroupedCollection`2<TKey, TElement> source, TKey key);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> AddGroup(ObservableGroupedCollection`2<TKey, TElement> source, IGrouping`2<TKey, TElement> grouping);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> AddGroup(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, IEnumerable`1<TElement> collection);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> InsertGroup(ObservableGroupedCollection`2<TKey, TElement> source, TKey key);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> InsertGroup(ObservableGroupedCollection`2<TKey, TElement> source, IGrouping`2<TKey, TElement> grouping);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> InsertGroup(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, IEnumerable`1<TElement> collection);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> InsertGroup(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> InsertGroup(ObservableGroupedCollection`2<TKey, TElement> source, IGrouping`2<TKey, TElement> grouping, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> InsertGroup(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, IComparer`1<TKey> comparer, IEnumerable`1<TElement> collection);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> AddItem(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, TElement item);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> InsertItem(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, TElement item);
    [ExtensionAttribute]
public static ObservableGroup`2<TKey, TElement> InsertItem(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, IComparer`1<TKey> keyComparer, TElement item, IComparer`1<TElement> itemComparer);
    [ExtensionAttribute]
public static void RemoveGroup(ObservableGroupedCollection`2<TKey, TValue> source, TKey key);
    [ExtensionAttribute]
public static void RemoveItem(ObservableGroupedCollection`2<TKey, TValue> source, TKey key, TValue item, bool removeGroupIfEmpty);
    [CompilerGeneratedAttribute]
[DoesNotReturnAttribute]
internal static void <FirstGroupByKey>g__ThrowArgumentExceptionForKeyNotFound|0_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ObservableGroup`2<TKey, TElement> <FirstGroupByKeyOrDefault>g__FirstGroupByKeyOrDefaultFallback|1_0(ObservableGroupedCollection`2<TKey, TElement> source, TKey key);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ObservableGroup`2<TKey, TElement> <InsertGroup>g__InsertGroupFallback|5_0(ObservableGroupedCollection`2<TKey, TElement> source, TKey key);
    [CompilerGeneratedAttribute]
internal static ObservableGroup`2<TKey, TElement> <InsertGroup>g__InsertGroupFallback|6_0(ObservableGroupedCollection`2<TKey, TElement> source, IGrouping`2<TKey, TElement> grouping);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ObservableGroup`2<TKey, TElement> <InsertGroup>g__InsertGroupFallback|7_0(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, IEnumerable`1<TElement> collection);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ObservableGroup`2<TKey, TElement> <InsertGroup>g__InsertGroupFallback|8_0(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, IComparer`1<TKey> comparer);
    [CompilerGeneratedAttribute]
internal static ObservableGroup`2<TKey, TElement> <InsertGroup>g__InsertGroupFallback|9_0(ObservableGroupedCollection`2<TKey, TElement> source, IGrouping`2<TKey, TElement> grouping, IComparer`1<TKey> comparer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ObservableGroup`2<TKey, TElement> <InsertGroup>g__InsertGroupFallback|10_0(ObservableGroupedCollection`2<TKey, TElement> source, TKey key, IComparer`1<TKey> comparer, IEnumerable`1<TElement> collection);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <InsertItem>g__InsertItemFallback|12_0(ObservableCollection`1<TElement> source, TElement item);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <InsertItem>g__InsertItemFallback|13_0(ObservableCollection`1<TElement> source, TElement item, IComparer`1<TElement> comparer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <RemoveGroup>g__RemoveGroupFallback|14_0(ObservableGroupedCollection`2<TKey, TValue> source, TKey key);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <RemoveItem>g__RemoveItemFallback|15_0(ObservableGroupedCollection`2<TKey, TValue> source, TKey key, TValue item, bool removeGroupIfEmpty);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerDisplayAttribute("Key = {Key}, Count = {Count}")]
public class CommunityToolkit.Mvvm.Collections.ReadOnlyObservableGroup`2 : ReadOnlyObservableCollection`1<TElement> {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    public TKey Key { get; }
    private object CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup.Key { get; }
    [NullableAttribute("2")]
private object CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup.Item { get; }
    public ReadOnlyObservableGroup`2(TKey key, ObservableCollection`1<TElement> collection);
    public ReadOnlyObservableGroup`2(ObservableGroup`2<TKey, TElement> group);
    [CompilerGeneratedAttribute]
public sealed virtual TKey get_Key();
    private sealed virtual override object CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup.get_Key();
    [NullableContextAttribute("2")]
private sealed virtual override object CommunityToolkit.Mvvm.Collections.IReadOnlyObservableGroup.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class CommunityToolkit.Mvvm.Collections.ReadOnlyObservableGroupedCollection`2 : ReadOnlyObservableCollection`1<ReadOnlyObservableGroup`2<TKey, TElement>> {
    private IEnumerable`1<TElement> System.Linq.ILookup<TKey,TElement>.Item { get; }
    public ReadOnlyObservableGroupedCollection`2(ObservableCollection`1<ObservableGroup`2<TKey, TElement>> collection);
    public ReadOnlyObservableGroupedCollection`2(ObservableCollection`1<ReadOnlyObservableGroup`2<TKey, TElement>> collection);
    private sealed virtual override IEnumerable`1<TElement> System.Linq.ILookup<TKey,TElement>.get_Item(TKey key);
    private sealed virtual override bool System.Linq.ILookup<TKey,TElement>.Contains(TKey key);
    private sealed virtual override IEnumerator`1<IGrouping`2<TKey, TElement>> System.Collections.Generic.IEnumerable<System.Linq.IGrouping<TKey,TElement>>.GetEnumerator();
    private void OnSourceCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private IEnumerable`1<TElement> FirstGroupByKeyOrDefault(TKey key);
    [CompilerGeneratedAttribute]
[DoesNotReturnAttribute]
internal static void <OnSourceCollectionChanged>g__ThrowNotSupportedExceptionForRangeOperation|6_0();
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<TElement> <FirstGroupByKeyOrDefault>g__FirstGroupByKeyOrDefaultFallback|7_0(ReadOnlyObservableGroupedCollection`2<TKey, TElement> source, TKey key);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This type is not intended to be used directly by user code")]
public static class CommunityToolkit.Mvvm.ComponentModel.__Internals.__ObservableValidatorHelper : object {
    [NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method is not intended to be called directly by user code")]
public static void ValidateProperty(ObservableValidator instance, object value, string propertyName);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This type is not intended to be used directly by user code")]
public static class CommunityToolkit.Mvvm.ComponentModel.__Internals.__TaskExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method is not intended to be called directly by user code")]
public static TaskAwaitableWithoutEndValidation GetAwaitableWithoutEndValidation(Task task);
}
[AttributeUsageAttribute("4")]
public class CommunityToolkit.Mvvm.ComponentModel.INotifyPropertyChangedAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IncludeAdditionalHelperMethods>k__BackingField;
    public bool IncludeAdditionalHelperMethods { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IncludeAdditionalHelperMethods();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeAdditionalHelperMethods(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
public class CommunityToolkit.Mvvm.ComponentModel.NotifyCanExecuteChangedForAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <CommandNames>k__BackingField;
    public String[] CommandNames { get; }
    public NotifyCanExecuteChangedForAttribute(string commandName);
    public NotifyCanExecuteChangedForAttribute(string commandName, String[] otherCommandNames);
    [CompilerGeneratedAttribute]
public String[] get_CommandNames();
}
[AttributeUsageAttribute("260")]
public class CommunityToolkit.Mvvm.ComponentModel.NotifyDataErrorInfoAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
public class CommunityToolkit.Mvvm.ComponentModel.NotifyPropertyChangedForAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <PropertyNames>k__BackingField;
    public String[] PropertyNames { get; }
    public NotifyPropertyChangedForAttribute(string propertyName);
    public NotifyPropertyChangedForAttribute(string propertyName, String[] otherPropertyNames);
    [CompilerGeneratedAttribute]
public String[] get_PropertyNames();
}
[AttributeUsageAttribute("260")]
public class CommunityToolkit.Mvvm.ComponentModel.NotifyPropertyChangedRecipientsAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class CommunityToolkit.Mvvm.ComponentModel.ObservableObject : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    [NullableContextAttribute("1")]
protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    [NullableContextAttribute("1")]
protected virtual void OnPropertyChanging(PropertyChangingEventArgs e);
    protected void OnPropertyChanged(string propertyName);
    protected void OnPropertyChanging(string propertyName);
    [NullableContextAttribute("1")]
protected bool SetProperty(T& field, T newValue, string propertyName);
    [NullableContextAttribute("1")]
protected bool SetProperty(T& field, T newValue, IEqualityComparer`1<T> comparer, string propertyName);
    [NullableContextAttribute("1")]
protected bool SetProperty(T oldValue, T newValue, Action`1<T> callback, string propertyName);
    [NullableContextAttribute("1")]
protected bool SetProperty(T oldValue, T newValue, IEqualityComparer`1<T> comparer, Action`1<T> callback, string propertyName);
    [NullableContextAttribute("1")]
protected bool SetProperty(T oldValue, T newValue, TModel model, Action`2<TModel, T> callback, string propertyName);
    [NullableContextAttribute("1")]
protected bool SetProperty(T oldValue, T newValue, IEqualityComparer`1<T> comparer, TModel model, Action`2<TModel, T> callback, string propertyName);
    protected bool SetPropertyAndNotifyOnCompletion(TaskNotifier& taskNotifier, Task newValue, string propertyName);
    protected bool SetPropertyAndNotifyOnCompletion(TaskNotifier& taskNotifier, Task newValue, Action`1<Task> callback, string propertyName);
    protected bool SetPropertyAndNotifyOnCompletion(TaskNotifier`1& taskNotifier, Task`1<T> newValue, string propertyName);
    protected bool SetPropertyAndNotifyOnCompletion(TaskNotifier`1& taskNotifier, Task`1<T> newValue, Action`1<Task`1<T>> callback, string propertyName);
    private bool SetPropertyAndNotifyOnCompletion(ITaskNotifier`1<TTask> taskNotifier, TTask newValue, Action`1<TTask> callback, string propertyName);
}
[AttributeUsageAttribute("4")]
public class CommunityToolkit.Mvvm.ComponentModel.ObservableObjectAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class CommunityToolkit.Mvvm.ComponentModel.ObservablePropertyAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class CommunityToolkit.Mvvm.ComponentModel.ObservableRecipient : ObservableObject {
    [CompilerGeneratedAttribute]
private IMessenger <Messenger>k__BackingField;
    private bool isActive;
    protected IMessenger Messenger { get; }
    public bool IsActive { get; public set; }
    protected ObservableRecipient(IMessenger messenger);
    [CompilerGeneratedAttribute]
protected IMessenger get_Messenger();
    public bool get_IsActive();
    [RequiresUnreferencedCodeAttribute("When this property is set to true, the OnActivated() method will be invoked, which will register all necessary message handlers for this recipient. This method requires the generated CommunityToolkit.Mvvm.Messaging.__Internals.__IMessengerExtensions type not to be removed to use the fast path. If this type is removed by the linker, or if the target recipient was created dynamically and was missed by the source generator, a slower fallback path using a compiled LINQ expression will be used. This will have more overhead in the first invocation of this method for any given recipient type. Alternatively, OnActivated() can be manually overwritten, and registration can be done individually for each required message for this recipient.")]
public void set_IsActive(bool value);
    [RequiresUnreferencedCodeAttribute("This method requires the generated CommunityToolkit.Mvvm.Messaging.__Internals.__IMessengerExtensions type not to be removed to use the fast path. If this type is removed by the linker, or if the target recipient was created dynamically and was missed by the source generator, a slower fallback path using a compiled LINQ expression will be used. This will have more overhead in the first invocation of this method for any given recipient type. Alternatively, OnActivated() can be manually overwritten, and registration can be done individually for each required message for this recipient.")]
protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    protected virtual void Broadcast(T oldValue, T newValue, string propertyName);
    protected bool SetProperty(T& field, T newValue, bool broadcast, string propertyName);
    protected bool SetProperty(T& field, T newValue, IEqualityComparer`1<T> comparer, bool broadcast, string propertyName);
    protected bool SetProperty(T oldValue, T newValue, Action`1<T> callback, bool broadcast, string propertyName);
    protected bool SetProperty(T oldValue, T newValue, IEqualityComparer`1<T> comparer, Action`1<T> callback, bool broadcast, string propertyName);
    protected bool SetProperty(T oldValue, T newValue, TModel model, Action`2<TModel, T> callback, bool broadcast, string propertyName);
    protected bool SetProperty(T oldValue, T newValue, IEqualityComparer`1<T> comparer, TModel model, Action`2<TModel, T> callback, bool broadcast, string propertyName);
}
[AttributeUsageAttribute("4")]
public class CommunityToolkit.Mvvm.ComponentModel.ObservableRecipientAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class CommunityToolkit.Mvvm.ComponentModel.ObservableValidator : ObservableObject {
    private static ConditionalWeakTable`2<Type, Action`1<object>> EntityValidatorMap;
    private static ConditionalWeakTable`2<Type, Dictionary`2<string, string>> DisplayNamesMap;
    private static PropertyChangedEventArgs HasErrorsChangedEventArgs;
    private ValidationContext validationContext;
    private Dictionary`2<string, List`1<ValidationResult>> errors;
    private int totalErrors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<DataErrorsChangedEventArgs> ErrorsChanged;
    public bool HasErrors { get; }
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected ObservableValidator(IDictionary`2<object, object> items);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected ObservableValidator(IServiceProvider serviceProvider, IDictionary`2<object, object> items);
    protected ObservableValidator(ValidationContext validationContext);
    private static ObservableValidator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    public sealed virtual bool get_HasErrors();
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool SetProperty(T& field, T newValue, bool validate, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool SetProperty(T& field, T newValue, IEqualityComparer`1<T> comparer, bool validate, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool SetProperty(T oldValue, T newValue, Action`1<T> callback, bool validate, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool SetProperty(T oldValue, T newValue, IEqualityComparer`1<T> comparer, Action`1<T> callback, bool validate, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool SetProperty(T oldValue, T newValue, TModel model, Action`2<TModel, T> callback, bool validate, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool SetProperty(T oldValue, T newValue, IEqualityComparer`1<T> comparer, TModel model, Action`2<TModel, T> callback, bool validate, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool TrySetProperty(T& field, T newValue, IReadOnlyCollection`1& errors, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool TrySetProperty(T& field, T newValue, IEqualityComparer`1<T> comparer, IReadOnlyCollection`1& errors, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool TrySetProperty(T oldValue, T newValue, Action`1<T> callback, IReadOnlyCollection`1& errors, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool TrySetProperty(T oldValue, T newValue, IEqualityComparer`1<T> comparer, Action`1<T> callback, IReadOnlyCollection`1& errors, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool TrySetProperty(T oldValue, T newValue, TModel model, Action`2<TModel, T> callback, IReadOnlyCollection`1& errors, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected bool TrySetProperty(T oldValue, T newValue, IEqualityComparer`1<T> comparer, TModel model, Action`2<TModel, T> callback, IReadOnlyCollection`1& errors, string propertyName);
    [NullableContextAttribute("2")]
protected void ClearErrors(string propertyName);
    public IEnumerable`1<ValidationResult> GetErrors(string propertyName);
    private sealed virtual override IEnumerable System.ComponentModel.INotifyDataErrorInfo.GetErrors(string propertyName);
    [RequiresUnreferencedCodeAttribute("This method requires the generated CommunityToolkit.Mvvm.ComponentModel.__Internals.__ObservableValidatorExtensions type not to be removed to use the fast path. If this type is removed by the linker, or if the target recipient was created dynamically and was missed by the source generator, a slower fallback path using a compiled LINQ expression will be used. This will have more overhead in the first invocation of this method for any given recipient type. Additionally, due to the usage of validation APIs, the type of the current instance cannot be statically discovered.")]
protected void ValidateAllProperties();
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
protected internal void ValidateProperty(object value, string propertyName);
    [RequiresUnreferencedCodeAttribute("The type of the current instance cannot be statically discovered.")]
private bool TryValidateProperty(object value, string propertyName, IReadOnlyCollection`1& errors);
    private void ClearAllErrors();
    private void ClearErrorsForProperty(string propertyName);
    private string GetDisplayNameForProperty(string propertyName);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ValidationResult> <GetErrors>g__GetAllErrors|28_0();
    [CompilerGeneratedAttribute]
internal static Action`1<object> <ValidateAllProperties>g__GetValidationAction|30_0(Type type);
    [CompilerGeneratedAttribute]
internal static Action`1<object> <ValidateAllProperties>g__GetValidationActionFallback|30_1(Type type);
    [CompilerGeneratedAttribute]
internal static Dictionary`2<string, string> <GetDisplayNameForProperty>g__GetDisplayNames|35_0(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.DependencyInjection.Ioc : object {
    [CompilerGeneratedAttribute]
private static Ioc <Default>k__BackingField;
    [NullableAttribute("2")]
private IServiceProvider modreq(System.Runtime.CompilerServices.IsVolatile) serviceProvider;
    public static Ioc Default { get; }
    private static Ioc();
    [CompilerGeneratedAttribute]
public static Ioc get_Default();
    public sealed virtual object GetService(Type serviceType);
    public T GetService();
    public T GetRequiredService();
    public void ConfigureServices(IServiceProvider serviceProvider);
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperationExceptionForMissingInitialization();
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperationExceptionForUnregisteredType();
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperationExceptionForRepeatedConfiguration();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Input.AsyncRelayCommand : object {
    internal static PropertyChangedEventArgs ExecutionTaskChangedEventArgs;
    internal static PropertyChangedEventArgs CanBeCanceledChangedEventArgs;
    internal static PropertyChangedEventArgs IsCancellationRequestedChangedEventArgs;
    internal static PropertyChangedEventArgs IsRunningChangedEventArgs;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<Task> execute;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<CancellationToken, Task> cancelableExecute;
    [NullableAttribute("2")]
private Func`1<bool> canExecute;
    private AsyncRelayCommandOptions options;
    [NullableAttribute("2")]
private CancellationTokenSource cancellationTokenSource;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    [NullableAttribute("2")]
private Task executionTask;
    [NullableAttribute("2")]
public Task ExecutionTask { get; private set; }
    public bool CanBeCanceled { get; }
    public bool IsCancellationRequested { get; }
    public bool IsRunning { get; }
    private bool CommunityToolkit.Mvvm.Input.Internals.ICancellationAwareCommand.IsCancellationSupported { get; }
    public AsyncRelayCommand(Func`1<Task> execute);
    public AsyncRelayCommand(Func`1<Task> execute, AsyncRelayCommandOptions options);
    public AsyncRelayCommand(Func`2<CancellationToken, Task> cancelableExecute);
    public AsyncRelayCommand(Func`2<CancellationToken, Task> cancelableExecute, AsyncRelayCommandOptions options);
    public AsyncRelayCommand(Func`1<Task> execute, Func`1<bool> canExecute);
    public AsyncRelayCommand(Func`1<Task> execute, Func`1<bool> canExecute, AsyncRelayCommandOptions options);
    public AsyncRelayCommand(Func`2<CancellationToken, Task> cancelableExecute, Func`1<bool> canExecute);
    public AsyncRelayCommand(Func`2<CancellationToken, Task> cancelableExecute, Func`1<bool> canExecute, AsyncRelayCommandOptions options);
    private static AsyncRelayCommand();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual Task get_ExecutionTask();
    [NullableContextAttribute("2")]
private void set_ExecutionTask(Task value);
    public sealed virtual bool get_CanBeCanceled();
    public sealed virtual bool get_IsCancellationRequested();
    public sealed virtual bool get_IsRunning();
    private sealed virtual override bool CommunityToolkit.Mvvm.Input.Internals.ICancellationAwareCommand.get_IsCancellationSupported();
    public sealed virtual void NotifyCanExecuteChanged();
    [NullableContextAttribute("2")]
public sealed virtual bool CanExecute(object parameter);
    [NullableContextAttribute("2")]
public sealed virtual void Execute(object parameter);
    public sealed virtual Task ExecuteAsync(object parameter);
    public sealed virtual void Cancel();
    [AsyncStateMachineAttribute("CommunityToolkit.Mvvm.Input.AsyncRelayCommand/<AwaitAndThrowIfFailed>d__40")]
internal static void AwaitAndThrowIfFailed(Task executionTask);
    [AsyncStateMachineAttribute("CommunityToolkit.Mvvm.Input.AsyncRelayCommand/<<set_ExecutionTask>g__MonitorTask|26_0>d")]
[CompilerGeneratedAttribute]
internal static void <set_ExecutionTask>g__MonitorTask|26_0(AsyncRelayCommand this, Task task);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Input.AsyncRelayCommand`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<T, Task> execute;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<T, CancellationToken, Task> cancelableExecute;
    private Predicate`1<T> canExecute;
    private AsyncRelayCommandOptions options;
    private CancellationTokenSource cancellationTokenSource;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    private Task executionTask;
    public Task ExecutionTask { get; private set; }
    public bool CanBeCanceled { get; }
    public bool IsCancellationRequested { get; }
    public bool IsRunning { get; }
    private bool CommunityToolkit.Mvvm.Input.Internals.ICancellationAwareCommand.IsCancellationSupported { get; }
    public AsyncRelayCommand`1(Func`2<T, Task> execute);
    public AsyncRelayCommand`1(Func`2<T, Task> execute, AsyncRelayCommandOptions options);
    public AsyncRelayCommand`1(Func`3<T, CancellationToken, Task> cancelableExecute);
    public AsyncRelayCommand`1(Func`3<T, CancellationToken, Task> cancelableExecute, AsyncRelayCommandOptions options);
    public AsyncRelayCommand`1(Func`2<T, Task> execute, Predicate`1<T> canExecute);
    public AsyncRelayCommand`1(Func`2<T, Task> execute, Predicate`1<T> canExecute, AsyncRelayCommandOptions options);
    public AsyncRelayCommand`1(Func`3<T, CancellationToken, Task> cancelableExecute, Predicate`1<T> canExecute);
    public AsyncRelayCommand`1(Func`3<T, CancellationToken, Task> cancelableExecute, Predicate`1<T> canExecute, AsyncRelayCommandOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public sealed virtual Task get_ExecutionTask();
    private void set_ExecutionTask(Task value);
    public sealed virtual bool get_CanBeCanceled();
    public sealed virtual bool get_IsCancellationRequested();
    public sealed virtual bool get_IsRunning();
    private sealed virtual override bool CommunityToolkit.Mvvm.Input.Internals.ICancellationAwareCommand.get_IsCancellationSupported();
    public sealed virtual void NotifyCanExecuteChanged();
    public sealed virtual bool CanExecute(T parameter);
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void Execute(T parameter);
    public sealed virtual void Execute(object parameter);
    [NullableContextAttribute("1")]
public sealed virtual Task ExecuteAsync(T parameter);
    [NullableContextAttribute("1")]
public sealed virtual Task ExecuteAsync(object parameter);
    public sealed virtual void Cancel();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("CommunityToolkit.Mvvm.Input.AsyncRelayCommand`1/<<set_ExecutionTask>g__MonitorTask|22_0>d")]
[CompilerGeneratedAttribute]
internal static void <set_ExecutionTask>g__MonitorTask|22_0(AsyncRelayCommand`1<T> this, Task task);
}
[FlagsAttribute]
public enum CommunityToolkit.Mvvm.Input.AsyncRelayCommandOptions : Enum {
    public int value__;
    public static AsyncRelayCommandOptions None;
    public static AsyncRelayCommandOptions AllowConcurrentExecutions;
    public static AsyncRelayCommandOptions FlowExceptionsToTaskScheduler;
}
public interface CommunityToolkit.Mvvm.Input.IAsyncRelayCommand {
    [NullableAttribute("2")]
public Task ExecutionTask { get; }
    public bool CanBeCanceled { get; }
    public bool IsCancellationRequested { get; }
    public bool IsRunning { get; }
    [NullableContextAttribute("2")]
public abstract virtual Task get_ExecutionTask();
    public abstract virtual bool get_CanBeCanceled();
    public abstract virtual bool get_IsCancellationRequested();
    public abstract virtual bool get_IsRunning();
    [NullableContextAttribute("1")]
public abstract virtual Task ExecuteAsync(object parameter);
    public abstract virtual void Cancel();
}
public interface CommunityToolkit.Mvvm.Input.IAsyncRelayCommand`1 {
    [NullableContextAttribute("1")]
public abstract virtual Task ExecuteAsync(T parameter);
}
[ExtensionAttribute]
public static class CommunityToolkit.Mvvm.Input.IAsyncRelayCommandExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ICommand CreateCancelCommand(IAsyncRelayCommand command);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class CommunityToolkit.Mvvm.Input.Internals.CancelCommand : object {
    [NullableAttribute("1")]
private IAsyncRelayCommand command;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    [NullableContextAttribute("1")]
public CancelCommand(IAsyncRelayCommand command);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void Execute(object parameter);
    [NullableContextAttribute("1")]
private void OnPropertyChanged(object sender, PropertyChangedEventArgs e);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class CommunityToolkit.Mvvm.Input.Internals.DisabledCommand : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static DisabledCommand <Instance>k__BackingField;
    [NullableAttribute("1")]
public static DisabledCommand Instance { get; }
    private static DisabledCommand();
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static DisabledCommand get_Instance();
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void Execute(object parameter);
}
internal interface CommunityToolkit.Mvvm.Input.Internals.ICancellationAwareCommand {
    public bool IsCancellationSupported { get; }
    public abstract virtual bool get_IsCancellationSupported();
}
public interface CommunityToolkit.Mvvm.Input.IRelayCommand {
    public abstract virtual void NotifyCanExecuteChanged();
}
[NullableContextAttribute("2")]
public interface CommunityToolkit.Mvvm.Input.IRelayCommand`1 {
    public abstract virtual bool CanExecute(T parameter);
    public abstract virtual void Execute(T parameter);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Input.RelayCommand : object {
    [NullableAttribute("1")]
private Action execute;
    private Func`1<bool> canExecute;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    [NullableContextAttribute("1")]
public RelayCommand(Action execute);
    [NullableContextAttribute("1")]
public RelayCommand(Action execute, Func`1<bool> canExecute);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public sealed virtual void NotifyCanExecuteChanged();
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void Execute(object parameter);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Input.RelayCommand`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<T> execute;
    private Predicate`1<T> canExecute;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    public RelayCommand`1(Action`1<T> execute);
    public RelayCommand`1(Action`1<T> execute, Predicate`1<T> canExecute);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public sealed virtual void NotifyCanExecuteChanged();
    public sealed virtual bool CanExecute(T parameter);
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void Execute(T parameter);
    public sealed virtual void Execute(object parameter);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class CommunityToolkit.Mvvm.Input.RelayCommandAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CanExecute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowConcurrentExecutions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlowExceptionsToTaskScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeCancelCommand>k__BackingField;
    public string CanExecute { get; public set; }
    public bool AllowConcurrentExecutions { get; public set; }
    public bool FlowExceptionsToTaskScheduler { get; public set; }
    public bool IncludeCancelCommand { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CanExecute();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanExecute(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowConcurrentExecutions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowConcurrentExecutions(bool value);
    [CompilerGeneratedAttribute]
public bool get_FlowExceptionsToTaskScheduler();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FlowExceptionsToTaskScheduler(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeCancelCommand();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeCancelCommand(bool value);
}
[NullableContextAttribute("1")]
public interface CommunityToolkit.Mvvm.Messaging.IMessenger {
    public abstract virtual bool IsRegistered(object recipient, TToken token);
    public abstract virtual void Register(TRecipient recipient, TToken token, MessageHandler`2<TRecipient, TMessage> handler);
    public abstract virtual void UnregisterAll(object recipient);
    public abstract virtual void UnregisterAll(object recipient, TToken token);
    public abstract virtual void Unregister(object recipient, TToken token);
    public abstract virtual TMessage Send(TMessage message, TToken token);
    public abstract virtual void Cleanup();
    public abstract virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class CommunityToolkit.Mvvm.Messaging.IMessengerExtensions : object {
    [ExtensionAttribute]
public static bool IsRegistered(IMessenger messenger, object recipient);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This method requires the generated CommunityToolkit.Mvvm.Messaging.__Internals.__IMessengerExtensions type not to be removed to use the fast path. If this type is removed by the linker, or if the target recipient was created dynamically and was missed by the source generator, a slower fallback path using a compiled LINQ expression will be used. This will have more overhead in the first invocation of this method for any given recipient type.")]
public static void RegisterAll(IMessenger messenger, object recipient);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This method requires the generated CommunityToolkit.Mvvm.Messaging.__Internals.__IMessengerExtensions type not to be removed to use the fast path. If this type is removed by the linker, or if the target recipient was created dynamically and was missed by the source generator, a slower fallback path using a compiled LINQ expression will be used. This will have more overhead in the first invocation of this method for any given recipient type.")]
public static void RegisterAll(IMessenger messenger, object recipient, TToken token);
    [ExtensionAttribute]
public static void Register(IMessenger messenger, IRecipient`1<TMessage> recipient);
    [ExtensionAttribute]
public static void Register(IMessenger messenger, IRecipient`1<TMessage> recipient, TToken token);
    [ExtensionAttribute]
public static void Register(IMessenger messenger, object recipient, MessageHandler`2<object, TMessage> handler);
    [ExtensionAttribute]
public static void Register(IMessenger messenger, TRecipient recipient, MessageHandler`2<TRecipient, TMessage> handler);
    [ExtensionAttribute]
public static void Register(IMessenger messenger, object recipient, TToken token, MessageHandler`2<object, TMessage> handler);
    [ExtensionAttribute]
public static void Unregister(IMessenger messenger, object recipient);
    [ExtensionAttribute]
public static TMessage Send(IMessenger messenger);
    [ExtensionAttribute]
public static TMessage Send(IMessenger messenger, TMessage message);
    [ExtensionAttribute]
public static TMessage Send(IMessenger messenger, TToken token);
    [CompilerGeneratedAttribute]
internal static Action`2<IMessenger, object> <RegisterAll>g__LoadRegistrationMethodsForType|4_0(Type recipientType);
    [CompilerGeneratedAttribute]
internal static Action`3<IMessenger, object, TToken> <RegisterAll>g__LoadRegistrationMethodsForType|5_0(Type recipientType);
    [CompilerGeneratedAttribute]
internal static Action`3<IMessenger, object, TToken> <RegisterAll>g__LoadRegistrationMethodsForTypeFallback|5_1(Type recipientType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class CommunityToolkit.Mvvm.Messaging.Internals.ArrayPoolBufferWriter`1 : ValueType {
    private static int DefaultInitialBufferSize;
    private T[] array;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Span`1<T> span;
    private int index;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> Span { get; }
    public static ArrayPoolBufferWriter`1<T> Create();
    public ReadOnlySpan`1<T> get_Span();
    public void Add(T item);
    public void Reset();
    private void ResizeBufferAndAdd(T item);
    public void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class CommunityToolkit.Mvvm.Messaging.Internals.MessageHandlerDispatcher : object {
    public abstract virtual void Invoke(object recipient, object message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class CommunityToolkit.Mvvm.Messaging.Internals.Type2 : ValueType {
    public Type TMessage;
    public Type TToken;
    public Type2(Type tMessage, Type tToken);
    public sealed virtual bool Equals(Type2 other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
internal class CommunityToolkit.Mvvm.Messaging.Internals.Unit : ValueType {
    public sealed virtual bool Equals(Unit other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
public interface CommunityToolkit.Mvvm.Messaging.IRecipient`1 {
    public abstract virtual void Receive(TMessage message);
}
public class CommunityToolkit.Mvvm.Messaging.MessageHandler`2 : MulticastDelegate {
    public MessageHandler`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(TRecipient recipient, TMessage message);
    public virtual IAsyncResult BeginInvoke(TRecipient recipient, TMessage message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Messaging.Messages.AsyncCollectionRequestMessage`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Task`1<T>, Func`2<CancellationToken, Task`1<T>>>> responses;
    private CancellationTokenSource cancellationTokenSource;
    public CancellationToken CancellationToken { get; }
    public CancellationToken get_CancellationToken();
    public void Reply(T response);
    public void Reply(Task`1<T> response);
    public void Reply(Func`2<CancellationToken, Task`1<T>> response);
    [AsyncStateMachineAttribute("CommunityToolkit.Mvvm.Messaging.Messages.AsyncCollectionRequestMessage`1/<GetResponsesAsync>d__7")]
public Task`1<IReadOnlyCollection`1<T>> GetResponsesAsync(CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("CommunityToolkit.Mvvm.Messaging.Messages.AsyncCollectionRequestMessage`1/<GetAsyncEnumerator>d__8")]
[EditorBrowsableAttribute("1")]
public sealed virtual IAsyncEnumerator`1<T> GetAsyncEnumerator(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Messaging.Messages.AsyncRequestMessage`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Task`1<T> response;
    [CompilerGeneratedAttribute]
private bool <HasReceivedResponse>k__BackingField;
    public Task`1<T> Response { get; }
    public bool HasReceivedResponse { get; private set; }
    public Task`1<T> get_Response();
    [CompilerGeneratedAttribute]
public bool get_HasReceivedResponse();
    [CompilerGeneratedAttribute]
private void set_HasReceivedResponse(bool value);
    public void Reply(T response);
    public void Reply(Task`1<T> response);
    [EditorBrowsableAttribute("1")]
public TaskAwaiter`1<T> GetAwaiter();
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperationExceptionForNoResponseReceived();
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperationExceptionForDuplicateReply();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Messaging.Messages.CollectionRequestMessage`1 : object {
    private List`1<T> responses;
    public IReadOnlyCollection`1<T> Responses { get; }
    public IReadOnlyCollection`1<T> get_Responses();
    public void Reply(T response);
    [EditorBrowsableAttribute("1")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Messaging.Messages.PropertyChangedMessage`1 : object {
    [CompilerGeneratedAttribute]
private object <Sender>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private T <OldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <NewValue>k__BackingField;
    public object Sender { get; }
    [NullableAttribute("2")]
public string PropertyName { get; }
    public T OldValue { get; }
    public T NewValue { get; }
    public PropertyChangedMessage`1(object sender, string propertyName, T oldValue, T newValue);
    [CompilerGeneratedAttribute]
public object get_Sender();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public T get_OldValue();
    [CompilerGeneratedAttribute]
public T get_NewValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Messaging.Messages.RequestMessage`1 : object {
    private T response;
    [CompilerGeneratedAttribute]
private bool <HasReceivedResponse>k__BackingField;
    public T Response { get; }
    public bool HasReceivedResponse { get; private set; }
    public T get_Response();
    [CompilerGeneratedAttribute]
public bool get_HasReceivedResponse();
    [CompilerGeneratedAttribute]
private void set_HasReceivedResponse(bool value);
    public void Reply(T response);
    public static T op_Implicit(RequestMessage`1<T> message);
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperationExceptionForNoResponseReceived();
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperationExceptionForDuplicateReply();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Messaging.Messages.ValueChangedMessage`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; }
    public ValueChangedMessage`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Messaging.StrongReferenceMessenger : object {
    private Dictionary2`2<Recipient, HashSet`1<IMapping>> recipientsMap;
    private Dictionary2`2<Type2, IMapping> typesMap;
    [CompilerGeneratedAttribute]
private static StrongReferenceMessenger <Default>k__BackingField;
    public static StrongReferenceMessenger Default { get; }
    private static StrongReferenceMessenger();
    [CompilerGeneratedAttribute]
public static StrongReferenceMessenger get_Default();
    public sealed virtual bool IsRegistered(object recipient, TToken token);
    public sealed virtual void Register(TRecipient recipient, TToken token, MessageHandler`2<TRecipient, TMessage> handler);
    internal void Register(IRecipient`1<TMessage> recipient, TToken token);
    private void Register(object recipient, TToken token, MessageHandlerDispatcher dispatcher);
    public sealed virtual void UnregisterAll(object recipient);
    public sealed virtual void UnregisterAll(object recipient, TToken token);
    public sealed virtual void Unregister(object recipient, TToken token);
    public sealed virtual TMessage Send(TMessage message, TToken token);
    private sealed virtual override void CommunityToolkit.Mvvm.Messaging.IMessenger.Cleanup();
    public sealed virtual void Reset();
    private bool TryGetMapping(Mapping& mapping);
    private bool TryGetMapping(Mapping`1& mapping);
    private Mapping GetOrAddMapping();
    private Mapping`1<TToken> GetOrAddMapping();
    private static void ThrowInvalidOperationExceptionForDuplicateRegistration();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class CommunityToolkit.Mvvm.Messaging.WeakReferenceMessenger : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary2`2<Type2, ConditionalWeakTable2`2<object, object>> recipientsMap;
    [CompilerGeneratedAttribute]
private static WeakReferenceMessenger <Default>k__BackingField;
    public static WeakReferenceMessenger Default { get; }
    private static WeakReferenceMessenger();
    [CompilerGeneratedAttribute]
public static WeakReferenceMessenger get_Default();
    public sealed virtual bool IsRegistered(object recipient, TToken token);
    public sealed virtual void Register(TRecipient recipient, TToken token, MessageHandler`2<TRecipient, TMessage> handler);
    internal void Register(IRecipient`1<TMessage> recipient, TToken token);
    private void Register(object recipient, TToken token, MessageHandlerDispatcher dispatcher);
    public sealed virtual void UnregisterAll(object recipient);
    public sealed virtual void UnregisterAll(object recipient, TToken token);
    public sealed virtual void Unregister(object recipient, TToken token);
    public sealed virtual TMessage Send(TMessage message, TToken token);
    internal static void SendAll(ReadOnlySpan`1<object> pairs, int i, TMessage message);
    public sealed virtual void Cleanup();
    public sealed virtual void Reset();
    private void CleanupWithNonBlockingLock();
    private void CleanupWithoutLock();
    private static void ThrowInvalidOperationExceptionForDuplicateRegistration();
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__Gen2GcCallbackProxy|1_0(object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Configuration : object {
    private static string DisableINotifyPropertyChangingSupport;
    public static bool IsINotifyPropertyChangingDisabled;
    private static Configuration();
    private static bool GetConfigurationValue(string propertyName);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Generic.Dictionary2`2 : object {
    private static int StartOfFreeList;
    private Int32[] buckets;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Entry[] entries;
    private ulong fastModMultiplier;
    private int count;
    private int freeList;
    private int freeCount;
    public int Count { get; }
    public TValue Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void Clear();
    public bool ContainsKey(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryRemove(TKey key);
    public TValue& GetOrAddValueRef(TKey key);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private TValue& FindValue(TKey key);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void Initialize(int capacity);
    private void Resize();
    private Int32& GetBucket(UInt32 hashCode);
    private static void ThrowArgumentExceptionForKeyNotFound(TKey key);
}
internal static class System.Collections.Generic.HashHelpers : object {
    private static int MaxPrimeArrayLength;
    private static int HashPrime;
    [NullableAttribute("1")]
private static Int32[] primes;
    private static HashHelpers();
    private static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ulong GetFastModMultiplier(UInt32 divisor);
    public static UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier);
}
internal interface System.Collections.Generic.IDictionary2 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual void Clear();
}
internal interface System.Collections.Generic.IDictionary2`1 {
    [NullableContextAttribute("1")]
public abstract virtual bool TryRemove(TKey key);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
internal interface System.Collections.Generic.IDictionary2`2 {
    public TValue Item { get; }
    public abstract virtual TValue get_Item(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Gen2GcCallback : CriticalFinalizerObject {
    private Action`1<object> callback;
    private GCHandle handle;
    private Gen2GcCallback(Action`1<object> callback, object target);
    public static void Register(Action`1<object> callback, object target);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Runtime.CompilerServices.ConditionalWeakTable2`2 : object {
    private static int InitialCapacity;
    private object lockObject;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Container modreq(System.Runtime.CompilerServices.IsVolatile) container;
    public bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    public bool Remove(TKey key);
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    private TValue GetValueLocked(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private void CreateEntry(TKey key, TValue value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.4.255.64262")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
