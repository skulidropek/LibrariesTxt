public enum Confluent.Kafka.Acks : Enum {
    public int value__;
    public static Acks None;
    public static Acks Leader;
    public static Acks All;
}
public class Confluent.Kafka.Admin.AccessControlEntry : object {
    [CompilerGeneratedAttribute]
private string <Principal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private AclOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private AclPermissionType <PermissionType>k__BackingField;
    public string Principal { get; public set; }
    public string Host { get; public set; }
    public AclOperation Operation { get; public set; }
    public AclPermissionType PermissionType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Principal();
    [CompilerGeneratedAttribute]
public void set_Principal(string value);
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public AclOperation get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(AclOperation value);
    [CompilerGeneratedAttribute]
public AclPermissionType get_PermissionType();
    [CompilerGeneratedAttribute]
public void set_PermissionType(AclPermissionType value);
    public AccessControlEntryFilter ToFilter();
    public AccessControlEntry Clone();
    public virtual bool Equals(object obj);
    public static bool op_Equality(AccessControlEntry a, AccessControlEntry b);
    public static bool op_Inequality(AccessControlEntry a, AccessControlEntry b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.AccessControlEntryFilter : object {
    [CompilerGeneratedAttribute]
private string <Principal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private AclOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private AclPermissionType <PermissionType>k__BackingField;
    public string Principal { get; public set; }
    public string Host { get; public set; }
    public AclOperation Operation { get; public set; }
    public AclPermissionType PermissionType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Principal();
    [CompilerGeneratedAttribute]
public void set_Principal(string value);
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public AclOperation get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(AclOperation value);
    [CompilerGeneratedAttribute]
public AclPermissionType get_PermissionType();
    [CompilerGeneratedAttribute]
public void set_PermissionType(AclPermissionType value);
    public AccessControlEntryFilter Clone();
    public virtual bool Equals(object obj);
    public static bool op_Equality(AccessControlEntryFilter a, AccessControlEntryFilter b);
    public static bool op_Inequality(AccessControlEntryFilter a, AccessControlEntryFilter b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.AclBinding : object {
    [CompilerGeneratedAttribute]
private ResourcePattern <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessControlEntry <Entry>k__BackingField;
    public ResourcePattern Pattern { get; public set; }
    public AccessControlEntry Entry { get; public set; }
    [CompilerGeneratedAttribute]
public ResourcePattern get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(ResourcePattern value);
    [CompilerGeneratedAttribute]
public AccessControlEntry get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(AccessControlEntry value);
    public AclBindingFilter ToFilter();
    public AclBinding Clone();
    public virtual bool Equals(object obj);
    public static bool op_Equality(AclBinding a, AclBinding b);
    public static bool op_Inequality(AclBinding a, AclBinding b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.AclBindingFilter : object {
    [CompilerGeneratedAttribute]
private ResourcePatternFilter <PatternFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessControlEntryFilter <EntryFilter>k__BackingField;
    public ResourcePatternFilter PatternFilter { get; public set; }
    public AccessControlEntryFilter EntryFilter { get; public set; }
    [CompilerGeneratedAttribute]
public ResourcePatternFilter get_PatternFilter();
    [CompilerGeneratedAttribute]
public void set_PatternFilter(ResourcePatternFilter value);
    [CompilerGeneratedAttribute]
public AccessControlEntryFilter get_EntryFilter();
    [CompilerGeneratedAttribute]
public void set_EntryFilter(AccessControlEntryFilter value);
    public AclBindingFilter Clone();
    public virtual bool Equals(object obj);
    public static bool op_Equality(AclBindingFilter a, AclBindingFilter b);
    public static bool op_Inequality(AclBindingFilter a, AclBindingFilter b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum Confluent.Kafka.Admin.AclOperation : Enum {
    public int value__;
    public static AclOperation Unknown;
    public static AclOperation Any;
    public static AclOperation All;
    public static AclOperation Read;
    public static AclOperation Write;
    public static AclOperation Create;
    public static AclOperation Delete;
    public static AclOperation Alter;
    public static AclOperation Describe;
    public static AclOperation ClusterAction;
    public static AclOperation DescribeConfigs;
    public static AclOperation AlterConfigs;
    public static AclOperation IdempotentWrite;
}
public enum Confluent.Kafka.Admin.AclPermissionType : Enum {
    public int value__;
    public static AclPermissionType Unknown;
    public static AclPermissionType Any;
    public static AclPermissionType Deny;
    public static AclPermissionType Allow;
}
public enum Confluent.Kafka.Admin.AlterConfigOpType : Enum {
    public int value__;
    public static AlterConfigOpType Set;
    public static AlterConfigOpType Delete;
    public static AlterConfigOpType Append;
    public static AlterConfigOpType Subtract;
}
public class Confluent.Kafka.Admin.AlterConfigsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<AlterConfigsReport> <Results>k__BackingField;
    public List`1<AlterConfigsReport> Results { get; }
    public AlterConfigsException(List`1<AlterConfigsReport> results);
    [CompilerGeneratedAttribute]
public List`1<AlterConfigsReport> get_Results();
}
public class Confluent.Kafka.Admin.AlterConfigsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateOnly>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public bool ValidateOnly { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_ValidateOnly();
    [CompilerGeneratedAttribute]
public void set_ValidateOnly(bool value);
}
public class Confluent.Kafka.Admin.AlterConfigsReport : object {
    public ConfigResource ConfigResource;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
}
public class Confluent.Kafka.Admin.AlterConsumerGroupOffsetsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<AlterConsumerGroupOffsetsReport> <Results>k__BackingField;
    public List`1<AlterConsumerGroupOffsetsReport> Results { get; }
    public AlterConsumerGroupOffsetsException(List`1<AlterConsumerGroupOffsetsReport> results);
    [CompilerGeneratedAttribute]
public List`1<AlterConsumerGroupOffsetsReport> get_Results();
}
public class Confluent.Kafka.Admin.AlterConsumerGroupOffsetsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.AlterConsumerGroupOffsetsReport : object {
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TopicPartitionOffsetError> <Partitions>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Group { get; public set; }
    public List`1<TopicPartitionOffsetError> Partitions { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public List`1<TopicPartitionOffsetError> get_Partitions();
    [CompilerGeneratedAttribute]
public void set_Partitions(List`1<TopicPartitionOffsetError> value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.AlterConsumerGroupOffsetsResult : object {
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TopicPartitionOffsetError> <Partitions>k__BackingField;
    public string Group { get; public set; }
    public List`1<TopicPartitionOffsetError> Partitions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public List`1<TopicPartitionOffsetError> get_Partitions();
    [CompilerGeneratedAttribute]
public void set_Partitions(List`1<TopicPartitionOffsetError> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.AlterUserScramCredentialsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<AlterUserScramCredentialsReport> <Results>k__BackingField;
    public List`1<AlterUserScramCredentialsReport> Results { get; }
    public AlterUserScramCredentialsException(List`1<AlterUserScramCredentialsReport> results);
    [CompilerGeneratedAttribute]
public List`1<AlterUserScramCredentialsReport> get_Results();
}
public class Confluent.Kafka.Admin.AlterUserScramCredentialsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.AlterUserScramCredentialsReport : object {
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string User { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
public void set_User(string value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.ConfigEntry : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private AlterConfigOpType <IncrementalOperation>k__BackingField;
    public string Name { get; public set; }
    public string Value { get; public set; }
    public AlterConfigOpType IncrementalOperation { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public AlterConfigOpType get_IncrementalOperation();
    [CompilerGeneratedAttribute]
public void set_IncrementalOperation(AlterConfigOpType value);
}
public class Confluent.Kafka.Admin.ConfigEntryResult : object {
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigSource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ConfigSynonym> <Synonyms>k__BackingField;
    public bool IsDefault { get; public set; }
    public bool IsReadOnly { get; public set; }
    public bool IsSensitive { get; public set; }
    public string Name { get; public set; }
    public string Value { get; public set; }
    public ConfigSource Source { get; public set; }
    public List`1<ConfigSynonym> Synonyms { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public void set_IsDefault(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSensitive();
    [CompilerGeneratedAttribute]
public void set_IsSensitive(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public ConfigSource get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(ConfigSource value);
    [CompilerGeneratedAttribute]
public List`1<ConfigSynonym> get_Synonyms();
    [CompilerGeneratedAttribute]
public void set_Synonyms(List`1<ConfigSynonym> value);
}
public class Confluent.Kafka.Admin.ConfigResource : object {
    [CompilerGeneratedAttribute]
private ResourceType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public ResourceType Type { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public ResourceType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ResourceType value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ConfigResource a, ConfigResource b);
    public static bool op_Inequality(ConfigResource a, ConfigResource b);
    public virtual string ToString();
}
public enum Confluent.Kafka.Admin.ConfigSource : Enum {
    public int value__;
    public static ConfigSource UnknownConfig;
    public static ConfigSource DynamicTopicConfig;
    public static ConfigSource DynamicBrokerConfig;
    public static ConfigSource DynamicDefaultBrokerConfig;
    public static ConfigSource StaticBrokerConfig;
    public static ConfigSource DefaultConfig;
}
public class Confluent.Kafka.Admin.ConfigSynonym : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigSource <Source>k__BackingField;
    public string Name { get; public set; }
    public string Value { get; public set; }
    public ConfigSource Source { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public ConfigSource get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(ConfigSource value);
}
public class Confluent.Kafka.Admin.ConsumerGroupDescription : object {
    [CompilerGeneratedAttribute]
private string <GroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSimpleConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionAssignor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsumerGroupState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Coordinator>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MemberDescription> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AclOperation> <AuthorizedOperations>k__BackingField;
    public string GroupId { get; public set; }
    public Error Error { get; public set; }
    public bool IsSimpleConsumerGroup { get; public set; }
    public string PartitionAssignor { get; public set; }
    public ConsumerGroupState State { get; public set; }
    public Node Coordinator { get; public set; }
    public List`1<MemberDescription> Members { get; public set; }
    public List`1<AclOperation> AuthorizedOperations { get; public set; }
    [CompilerGeneratedAttribute]
public string get_GroupId();
    [CompilerGeneratedAttribute]
public void set_GroupId(string value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    [CompilerGeneratedAttribute]
public bool get_IsSimpleConsumerGroup();
    [CompilerGeneratedAttribute]
public void set_IsSimpleConsumerGroup(bool value);
    [CompilerGeneratedAttribute]
public string get_PartitionAssignor();
    [CompilerGeneratedAttribute]
public void set_PartitionAssignor(string value);
    [CompilerGeneratedAttribute]
public ConsumerGroupState get_State();
    [CompilerGeneratedAttribute]
public void set_State(ConsumerGroupState value);
    [CompilerGeneratedAttribute]
public Node get_Coordinator();
    [CompilerGeneratedAttribute]
public void set_Coordinator(Node value);
    [CompilerGeneratedAttribute]
public List`1<MemberDescription> get_Members();
    [CompilerGeneratedAttribute]
public void set_Members(List`1<MemberDescription> value);
    [CompilerGeneratedAttribute]
public List`1<AclOperation> get_AuthorizedOperations();
    [CompilerGeneratedAttribute]
public void set_AuthorizedOperations(List`1<AclOperation> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.ConsumerGroupListing : object {
    [CompilerGeneratedAttribute]
private string <GroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsumerGroupState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSimpleConsumerGroup>k__BackingField;
    public string GroupId { get; public set; }
    public ConsumerGroupState State { get; public set; }
    public bool IsSimpleConsumerGroup { get; public set; }
    [CompilerGeneratedAttribute]
public string get_GroupId();
    [CompilerGeneratedAttribute]
public void set_GroupId(string value);
    [CompilerGeneratedAttribute]
public ConsumerGroupState get_State();
    [CompilerGeneratedAttribute]
public void set_State(ConsumerGroupState value);
    [CompilerGeneratedAttribute]
public bool get_IsSimpleConsumerGroup();
    [CompilerGeneratedAttribute]
public void set_IsSimpleConsumerGroup(bool value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.CreateAclReport : object {
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(CreateAclReport a, CreateAclReport b);
    public static bool op_Inequality(CreateAclReport a, CreateAclReport b);
    public virtual int GetHashCode();
}
public class Confluent.Kafka.Admin.CreateAclsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<CreateAclReport> <Results>k__BackingField;
    public List`1<CreateAclReport> Results { get; }
    public CreateAclsException(List`1<CreateAclReport> results);
    [CompilerGeneratedAttribute]
public List`1<CreateAclReport> get_Results();
    public virtual bool Equals(object obj);
    public static bool op_Equality(CreateAclsException a, CreateAclsException b);
    public static bool op_Inequality(CreateAclsException a, CreateAclsException b);
    public virtual int GetHashCode();
}
public class Confluent.Kafka.Admin.CreateAclsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.CreatePartitionsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<CreatePartitionsReport> <Results>k__BackingField;
    public List`1<CreatePartitionsReport> Results { get; }
    public CreatePartitionsException(List`1<CreatePartitionsReport> results);
    [CompilerGeneratedAttribute]
public List`1<CreatePartitionsReport> get_Results();
}
public class Confluent.Kafka.Admin.CreatePartitionsOptions : object {
    [CompilerGeneratedAttribute]
private bool <ValidateOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OperationTimeout>k__BackingField;
    public bool ValidateOnly { get; public set; }
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public Nullable`1<TimeSpan> OperationTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ValidateOnly();
    [CompilerGeneratedAttribute]
public void set_ValidateOnly(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.CreatePartitionsReport : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Topic { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
}
public class Confluent.Kafka.Admin.CreateTopicReport : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Topic { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
}
public class Confluent.Kafka.Admin.CreateTopicsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<CreateTopicReport> <Results>k__BackingField;
    public List`1<CreateTopicReport> Results { get; }
    public CreateTopicsException(List`1<CreateTopicReport> results);
    [CompilerGeneratedAttribute]
public List`1<CreateTopicReport> get_Results();
}
public class Confluent.Kafka.Admin.CreateTopicsOptions : object {
    [CompilerGeneratedAttribute]
private bool <ValidateOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OperationTimeout>k__BackingField;
    public bool ValidateOnly { get; public set; }
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public Nullable`1<TimeSpan> OperationTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ValidateOnly();
    [CompilerGeneratedAttribute]
public void set_ValidateOnly(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.DeleteAclsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<DeleteAclsReport> <Results>k__BackingField;
    public List`1<DeleteAclsReport> Results { get; }
    public DeleteAclsException(List`1<DeleteAclsReport> results);
    [CompilerGeneratedAttribute]
public List`1<DeleteAclsReport> get_Results();
    public virtual bool Equals(object obj);
    public static bool op_Equality(DeleteAclsException a, DeleteAclsException b);
    public static bool op_Inequality(DeleteAclsException a, DeleteAclsException b);
    public virtual int GetHashCode();
}
public class Confluent.Kafka.Admin.DeleteAclsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.DeleteAclsReport : object {
    [CompilerGeneratedAttribute]
private List`1<AclBinding> <AclBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public List`1<AclBinding> AclBindings { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<AclBinding> get_AclBindings();
    [CompilerGeneratedAttribute]
public void set_AclBindings(List`1<AclBinding> value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(DeleteAclsReport a, DeleteAclsReport b);
    public static bool op_Inequality(DeleteAclsReport a, DeleteAclsReport b);
    public virtual int GetHashCode();
}
public class Confluent.Kafka.Admin.DeleteAclsResult : object {
    [CompilerGeneratedAttribute]
private List`1<AclBinding> <AclBindings>k__BackingField;
    public List`1<AclBinding> AclBindings { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<AclBinding> get_AclBindings();
    [CompilerGeneratedAttribute]
public void set_AclBindings(List`1<AclBinding> value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(DeleteAclsResult a, DeleteAclsResult b);
    public static bool op_Inequality(DeleteAclsResult a, DeleteAclsResult b);
    public virtual int GetHashCode();
}
public class Confluent.Kafka.Admin.DeleteConsumerGroupOffsetsException : KafkaException {
    [CompilerGeneratedAttribute]
private DeleteConsumerGroupOffsetsReport <Result>k__BackingField;
    public DeleteConsumerGroupOffsetsReport Result { get; }
    public DeleteConsumerGroupOffsetsException(DeleteConsumerGroupOffsetsReport result);
    [CompilerGeneratedAttribute]
public DeleteConsumerGroupOffsetsReport get_Result();
}
public class Confluent.Kafka.Admin.DeleteConsumerGroupOffsetsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OperationTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public Nullable`1<TimeSpan> OperationTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.DeleteConsumerGroupOffsetsReport : object {
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TopicPartitionOffsetError> <Partitions>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Group { get; public set; }
    public List`1<TopicPartitionOffsetError> Partitions { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public List`1<TopicPartitionOffsetError> get_Partitions();
    [CompilerGeneratedAttribute]
public void set_Partitions(List`1<TopicPartitionOffsetError> value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
}
public class Confluent.Kafka.Admin.DeleteConsumerGroupOffsetsResult : object {
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TopicPartition> <Partitions>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Group { get; public set; }
    public List`1<TopicPartition> Partitions { get; public set; }
    internal Error Error { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public List`1<TopicPartition> get_Partitions();
    [CompilerGeneratedAttribute]
public void set_Partitions(List`1<TopicPartition> value);
    [CompilerGeneratedAttribute]
internal Error get_Error();
    [CompilerGeneratedAttribute]
internal void set_Error(Error value);
}
public class Confluent.Kafka.Admin.DeleteGroupReport : object {
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Group { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
}
public class Confluent.Kafka.Admin.DeleteGroupsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<DeleteGroupReport> <Results>k__BackingField;
    public List`1<DeleteGroupReport> Results { get; }
    public DeleteGroupsException(List`1<DeleteGroupReport> results);
    [CompilerGeneratedAttribute]
public List`1<DeleteGroupReport> get_Results();
}
public class Confluent.Kafka.Admin.DeleteGroupsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OperationTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public Nullable`1<TimeSpan> OperationTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.DeleteRecordsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<DeleteRecordsReport> <Results>k__BackingField;
    public List`1<DeleteRecordsReport> Results { get; }
    public DeleteRecordsException(List`1<DeleteRecordsReport> results);
    [CompilerGeneratedAttribute]
public List`1<DeleteRecordsReport> get_Results();
}
public class Confluent.Kafka.Admin.DeleteRecordsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OperationTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public Nullable`1<TimeSpan> OperationTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.DeleteRecordsReport : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Partition <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Topic { get; public set; }
    public Partition Partition { get; public set; }
    public Offset Offset { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
    [CompilerGeneratedAttribute]
public Partition get_Partition();
    [CompilerGeneratedAttribute]
public void set_Partition(Partition value);
    [CompilerGeneratedAttribute]
public Offset get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(Offset value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
}
public class Confluent.Kafka.Admin.DeleteRecordsResult : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Partition <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Topic { get; public set; }
    public Partition Partition { get; public set; }
    public Offset Offset { get; public set; }
    internal Error Error { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
    [CompilerGeneratedAttribute]
public Partition get_Partition();
    [CompilerGeneratedAttribute]
public void set_Partition(Partition value);
    [CompilerGeneratedAttribute]
public Offset get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(Offset value);
    [CompilerGeneratedAttribute]
internal Error get_Error();
    [CompilerGeneratedAttribute]
internal void set_Error(Error value);
}
public class Confluent.Kafka.Admin.DeleteTopicReport : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Topic { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
}
public class Confluent.Kafka.Admin.DeleteTopicsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<DeleteTopicReport> <Results>k__BackingField;
    public List`1<DeleteTopicReport> Results { get; }
    public DeleteTopicsException(List`1<DeleteTopicReport> results);
    [CompilerGeneratedAttribute]
public List`1<DeleteTopicReport> get_Results();
}
public class Confluent.Kafka.Admin.DeleteTopicsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OperationTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public Nullable`1<TimeSpan> OperationTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.DescribeAclsException : KafkaException {
    [CompilerGeneratedAttribute]
private DescribeAclsReport <Result>k__BackingField;
    public DescribeAclsReport Result { get; }
    public DescribeAclsException(DescribeAclsReport result);
    [CompilerGeneratedAttribute]
public DescribeAclsReport get_Result();
    public virtual bool Equals(object obj);
    public static bool op_Equality(DescribeAclsException a, DescribeAclsException b);
    public static bool op_Inequality(DescribeAclsException a, DescribeAclsException b);
    public virtual int GetHashCode();
}
public class Confluent.Kafka.Admin.DescribeAclsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.DescribeAclsReport : object {
    [CompilerGeneratedAttribute]
private List`1<AclBinding> <AclBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public List`1<AclBinding> AclBindings { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<AclBinding> get_AclBindings();
    [CompilerGeneratedAttribute]
public void set_AclBindings(List`1<AclBinding> value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(DescribeAclsReport a, DescribeAclsReport b);
    public static bool op_Inequality(DescribeAclsReport a, DescribeAclsReport b);
    public virtual int GetHashCode();
}
public class Confluent.Kafka.Admin.DescribeAclsResult : object {
    [CompilerGeneratedAttribute]
private List`1<AclBinding> <AclBindings>k__BackingField;
    public List`1<AclBinding> AclBindings { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<AclBinding> get_AclBindings();
    [CompilerGeneratedAttribute]
public void set_AclBindings(List`1<AclBinding> value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(DescribeAclsResult a, DescribeAclsResult b);
    public static bool op_Inequality(DescribeAclsResult a, DescribeAclsResult b);
    public virtual int GetHashCode();
}
public class Confluent.Kafka.Admin.DescribeClusterOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeAuthorizedOperations>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public bool IncludeAuthorizedOperations { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeAuthorizedOperations();
    [CompilerGeneratedAttribute]
public void set_IncludeAuthorizedOperations(bool value);
}
public class Confluent.Kafka.Admin.DescribeClusterResult : object {
    [CompilerGeneratedAttribute]
private string <ClusterId>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Controller>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Node> <Nodes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AclOperation> <AuthorizedOperations>k__BackingField;
    public string ClusterId { get; public set; }
    public Node Controller { get; public set; }
    public List`1<Node> Nodes { get; public set; }
    public List`1<AclOperation> AuthorizedOperations { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClusterId();
    [CompilerGeneratedAttribute]
public void set_ClusterId(string value);
    [CompilerGeneratedAttribute]
public Node get_Controller();
    [CompilerGeneratedAttribute]
public void set_Controller(Node value);
    [CompilerGeneratedAttribute]
public List`1<Node> get_Nodes();
    [CompilerGeneratedAttribute]
public void set_Nodes(List`1<Node> value);
    [CompilerGeneratedAttribute]
public List`1<AclOperation> get_AuthorizedOperations();
    [CompilerGeneratedAttribute]
public void set_AuthorizedOperations(List`1<AclOperation> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.DescribeConfigsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<DescribeConfigsReport> <Results>k__BackingField;
    public List`1<DescribeConfigsReport> Results { get; }
    public DescribeConfigsException(List`1<DescribeConfigsReport> results);
    [CompilerGeneratedAttribute]
public List`1<DescribeConfigsReport> get_Results();
}
public class Confluent.Kafka.Admin.DescribeConfigsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.DescribeConfigsReport : object {
    public ConfigResource ConfigResource;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ConfigEntryResult> <Entries>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public Dictionary`2<string, ConfigEntryResult> Entries { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ConfigEntryResult> get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(Dictionary`2<string, ConfigEntryResult> value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
}
public class Confluent.Kafka.Admin.DescribeConfigsResult : object {
    public ConfigResource ConfigResource;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ConfigEntryResult> <Entries>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public Dictionary`2<string, ConfigEntryResult> Entries { get; public set; }
    internal Error Error { get; internal set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ConfigEntryResult> get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(Dictionary`2<string, ConfigEntryResult> value);
    [CompilerGeneratedAttribute]
internal Error get_Error();
    [CompilerGeneratedAttribute]
internal void set_Error(Error value);
}
public class Confluent.Kafka.Admin.DescribeConsumerGroupsException : KafkaException {
    [CompilerGeneratedAttribute]
private DescribeConsumerGroupsReport <Results>k__BackingField;
    public DescribeConsumerGroupsReport Results { get; }
    public DescribeConsumerGroupsException(DescribeConsumerGroupsReport results);
    [CompilerGeneratedAttribute]
public DescribeConsumerGroupsReport get_Results();
}
public class Confluent.Kafka.Admin.DescribeConsumerGroupsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeAuthorizedOperations>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public bool IncludeAuthorizedOperations { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeAuthorizedOperations();
    [CompilerGeneratedAttribute]
public void set_IncludeAuthorizedOperations(bool value);
}
public class Confluent.Kafka.Admin.DescribeConsumerGroupsReport : object {
    [CompilerGeneratedAttribute]
private List`1<ConsumerGroupDescription> <ConsumerGroupDescriptions>k__BackingField;
    public List`1<ConsumerGroupDescription> ConsumerGroupDescriptions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ConsumerGroupDescription> get_ConsumerGroupDescriptions();
    [CompilerGeneratedAttribute]
public void set_ConsumerGroupDescriptions(List`1<ConsumerGroupDescription> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.DescribeConsumerGroupsResult : object {
    [CompilerGeneratedAttribute]
private List`1<ConsumerGroupDescription> <ConsumerGroupDescriptions>k__BackingField;
    public List`1<ConsumerGroupDescription> ConsumerGroupDescriptions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ConsumerGroupDescription> get_ConsumerGroupDescriptions();
    [CompilerGeneratedAttribute]
public void set_ConsumerGroupDescriptions(List`1<ConsumerGroupDescription> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.DescribeTopicsException : KafkaException {
    [CompilerGeneratedAttribute]
private DescribeTopicsReport <Results>k__BackingField;
    public DescribeTopicsReport Results { get; }
    public DescribeTopicsException(DescribeTopicsReport results);
    [CompilerGeneratedAttribute]
public DescribeTopicsReport get_Results();
}
public class Confluent.Kafka.Admin.DescribeTopicsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeAuthorizedOperations>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public bool IncludeAuthorizedOperations { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeAuthorizedOperations();
    [CompilerGeneratedAttribute]
public void set_IncludeAuthorizedOperations(bool value);
}
public class Confluent.Kafka.Admin.DescribeTopicsReport : object {
    [CompilerGeneratedAttribute]
private List`1<TopicDescription> <TopicDescriptions>k__BackingField;
    public List`1<TopicDescription> TopicDescriptions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TopicDescription> get_TopicDescriptions();
    [CompilerGeneratedAttribute]
public void set_TopicDescriptions(List`1<TopicDescription> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.DescribeTopicsResult : object {
    [CompilerGeneratedAttribute]
private List`1<TopicDescription> <TopicDescriptions>k__BackingField;
    public List`1<TopicDescription> TopicDescriptions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TopicDescription> get_TopicDescriptions();
    [CompilerGeneratedAttribute]
public void set_TopicDescriptions(List`1<TopicDescription> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.DescribeUserScramCredentialsException : KafkaException {
    [CompilerGeneratedAttribute]
private DescribeUserScramCredentialsReport <Results>k__BackingField;
    public DescribeUserScramCredentialsReport Results { get; }
    public DescribeUserScramCredentialsException(DescribeUserScramCredentialsReport results);
    [CompilerGeneratedAttribute]
public DescribeUserScramCredentialsReport get_Results();
}
public class Confluent.Kafka.Admin.DescribeUserScramCredentialsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
}
public class Confluent.Kafka.Admin.DescribeUserScramCredentialsReport : object {
    [CompilerGeneratedAttribute]
private List`1<UserScramCredentialsDescription> <UserScramCredentialsDescriptions>k__BackingField;
    public List`1<UserScramCredentialsDescription> UserScramCredentialsDescriptions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<UserScramCredentialsDescription> get_UserScramCredentialsDescriptions();
    [CompilerGeneratedAttribute]
public void set_UserScramCredentialsDescriptions(List`1<UserScramCredentialsDescription> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.DescribeUserScramCredentialsResult : object {
    [CompilerGeneratedAttribute]
private List`1<UserScramCredentialsDescription> <UserScramCredentialsDescriptions>k__BackingField;
    public List`1<UserScramCredentialsDescription> UserScramCredentialsDescriptions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<UserScramCredentialsDescription> get_UserScramCredentialsDescriptions();
    [CompilerGeneratedAttribute]
public void set_UserScramCredentialsDescriptions(List`1<UserScramCredentialsDescription> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.IncrementalAlterConfigsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<IncrementalAlterConfigsReport> <Results>k__BackingField;
    public List`1<IncrementalAlterConfigsReport> Results { get; }
    public IncrementalAlterConfigsException(List`1<IncrementalAlterConfigsReport> results);
    [CompilerGeneratedAttribute]
public List`1<IncrementalAlterConfigsReport> get_Results();
}
public class Confluent.Kafka.Admin.IncrementalAlterConfigsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateOnly>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public bool ValidateOnly { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_ValidateOnly();
    [CompilerGeneratedAttribute]
public void set_ValidateOnly(bool value);
}
public class Confluent.Kafka.Admin.IncrementalAlterConfigsReport : object {
    public ConfigResource ConfigResource;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
}
public class Confluent.Kafka.Admin.IncrementalAlterConfigsResult : object {
    public ConfigResource ConfigResource;
}
public class Confluent.Kafka.Admin.ListConsumerGroupOffsetsException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<ListConsumerGroupOffsetsReport> <Results>k__BackingField;
    public List`1<ListConsumerGroupOffsetsReport> Results { get; }
    public ListConsumerGroupOffsetsException(List`1<ListConsumerGroupOffsetsReport> results);
    [CompilerGeneratedAttribute]
public List`1<ListConsumerGroupOffsetsReport> get_Results();
}
public class Confluent.Kafka.Admin.ListConsumerGroupOffsetsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireStableOffsets>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public bool RequireStableOffsets { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_RequireStableOffsets();
    [CompilerGeneratedAttribute]
public void set_RequireStableOffsets(bool value);
}
public class Confluent.Kafka.Admin.ListConsumerGroupOffsetsReport : object {
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TopicPartitionOffsetError> <Partitions>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Group { get; public set; }
    public List`1<TopicPartitionOffsetError> Partitions { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public List`1<TopicPartitionOffsetError> get_Partitions();
    [CompilerGeneratedAttribute]
public void set_Partitions(List`1<TopicPartitionOffsetError> value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.ListConsumerGroupOffsetsResult : object {
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TopicPartitionOffsetError> <Partitions>k__BackingField;
    public string Group { get; public set; }
    public List`1<TopicPartitionOffsetError> Partitions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public List`1<TopicPartitionOffsetError> get_Partitions();
    [CompilerGeneratedAttribute]
public void set_Partitions(List`1<TopicPartitionOffsetError> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.ListConsumerGroupsException : KafkaException {
    [CompilerGeneratedAttribute]
private ListConsumerGroupsReport <Results>k__BackingField;
    public ListConsumerGroupsReport Results { get; }
    public ListConsumerGroupsException(ListConsumerGroupsReport report);
    [CompilerGeneratedAttribute]
public ListConsumerGroupsReport get_Results();
}
public class Confluent.Kafka.Admin.ListConsumerGroupsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ConsumerGroupState> <MatchStates>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public IEnumerable`1<ConsumerGroupState> MatchStates { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ConsumerGroupState> get_MatchStates();
    [CompilerGeneratedAttribute]
public void set_MatchStates(IEnumerable`1<ConsumerGroupState> value);
}
public class Confluent.Kafka.Admin.ListConsumerGroupsReport : object {
    [CompilerGeneratedAttribute]
private List`1<ConsumerGroupListing> <Valid>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Error> <Errors>k__BackingField;
    public List`1<ConsumerGroupListing> Valid { get; public set; }
    public List`1<Error> Errors { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ConsumerGroupListing> get_Valid();
    [CompilerGeneratedAttribute]
public void set_Valid(List`1<ConsumerGroupListing> value);
    [CompilerGeneratedAttribute]
public List`1<Error> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<Error> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.ListConsumerGroupsResult : object {
    [CompilerGeneratedAttribute]
private List`1<ConsumerGroupListing> <Valid>k__BackingField;
    public List`1<ConsumerGroupListing> Valid { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ConsumerGroupListing> get_Valid();
    [CompilerGeneratedAttribute]
public void set_Valid(List`1<ConsumerGroupListing> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.ListOffsetsException : KafkaException {
    [CompilerGeneratedAttribute]
private ListOffsetsReport <Result>k__BackingField;
    public ListOffsetsReport Result { get; }
    public ListOffsetsException(ListOffsetsReport result);
    [CompilerGeneratedAttribute]
public ListOffsetsReport get_Result();
}
public class Confluent.Kafka.Admin.ListOffsetsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IsolationLevel <IsolationLevel>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public IsolationLevel IsolationLevel { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public IsolationLevel get_IsolationLevel();
    [CompilerGeneratedAttribute]
public void set_IsolationLevel(IsolationLevel value);
}
public class Confluent.Kafka.Admin.ListOffsetsReport : object {
    [CompilerGeneratedAttribute]
private List`1<ListOffsetsResultInfo> <ResultInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public List`1<ListOffsetsResultInfo> ResultInfos { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ListOffsetsResultInfo> get_ResultInfos();
    [CompilerGeneratedAttribute]
public void set_ResultInfos(List`1<ListOffsetsResultInfo> value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.ListOffsetsResult : object {
    [CompilerGeneratedAttribute]
private List`1<ListOffsetsResultInfo> <ResultInfos>k__BackingField;
    public List`1<ListOffsetsResultInfo> ResultInfos { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ListOffsetsResultInfo> get_ResultInfos();
    [CompilerGeneratedAttribute]
public void set_ResultInfos(List`1<ListOffsetsResultInfo> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.ListOffsetsResultInfo : object {
    [CompilerGeneratedAttribute]
private TopicPartitionOffsetError <TopicPartitionOffsetError>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    public TopicPartitionOffsetError TopicPartitionOffsetError { get; public set; }
    public long Timestamp { get; public set; }
    [CompilerGeneratedAttribute]
public TopicPartitionOffsetError get_TopicPartitionOffsetError();
    [CompilerGeneratedAttribute]
public void set_TopicPartitionOffsetError(TopicPartitionOffsetError value);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(long value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.MemberAssignment : object {
    [CompilerGeneratedAttribute]
private List`1<TopicPartition> <TopicPartitions>k__BackingField;
    public List`1<TopicPartition> TopicPartitions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TopicPartition> get_TopicPartitions();
    [CompilerGeneratedAttribute]
public void set_TopicPartitions(List`1<TopicPartition> value);
}
public class Confluent.Kafka.Admin.MemberDescription : object {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GroupInstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberAssignment <Assignment>k__BackingField;
    public string ClientId { get; public set; }
    public string GroupInstanceId { get; public set; }
    public string ConsumerId { get; public set; }
    public string Host { get; public set; }
    public MemberAssignment Assignment { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_GroupInstanceId();
    [CompilerGeneratedAttribute]
public void set_GroupInstanceId(string value);
    [CompilerGeneratedAttribute]
public string get_ConsumerId();
    [CompilerGeneratedAttribute]
public void set_ConsumerId(string value);
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public MemberAssignment get_Assignment();
    [CompilerGeneratedAttribute]
public void set_Assignment(MemberAssignment value);
    public virtual string ToString();
}
public abstract class Confluent.Kafka.Admin.OffsetSpec : object {
    private static EarliestSpec EarliestSpecInstance;
    private static LatestSpec LatestSpecInstance;
    private static MaxTimestampSpec MaxTimestampSpecInstance;
    private static OffsetSpec();
    public static OffsetSpec Latest();
    public static OffsetSpec Earliest();
    public static OffsetSpec ForTimestamp(long timestamp);
    public static OffsetSpec MaxTimestamp();
    internal abstract virtual long Value();
}
public class Confluent.Kafka.Admin.PartitionsSpecification : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<List`1<int>> <ReplicaAssignments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IncreaseTo>k__BackingField;
    public string Topic { get; public set; }
    public List`1<List`1<int>> ReplicaAssignments { get; public set; }
    public int IncreaseTo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
    [CompilerGeneratedAttribute]
public List`1<List`1<int>> get_ReplicaAssignments();
    [CompilerGeneratedAttribute]
public void set_ReplicaAssignments(List`1<List`1<int>> value);
    [CompilerGeneratedAttribute]
public int get_IncreaseTo();
    [CompilerGeneratedAttribute]
public void set_IncreaseTo(int value);
}
public class Confluent.Kafka.Admin.ResourcePattern : object {
    [CompilerGeneratedAttribute]
private ResourceType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourcePatternType <ResourcePatternType>k__BackingField;
    public ResourceType Type { get; public set; }
    public string Name { get; public set; }
    public ResourcePatternType ResourcePatternType { get; public set; }
    [CompilerGeneratedAttribute]
public ResourceType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ResourceType value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ResourcePatternType get_ResourcePatternType();
    [CompilerGeneratedAttribute]
public void set_ResourcePatternType(ResourcePatternType value);
    public ResourcePatternFilter ToFilter();
    public ResourcePattern Clone();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ResourcePattern a, ResourcePattern b);
    public static bool op_Inequality(ResourcePattern a, ResourcePattern b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.ResourcePatternFilter : object {
    [CompilerGeneratedAttribute]
private ResourceType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourcePatternType <ResourcePatternType>k__BackingField;
    public ResourceType Type { get; public set; }
    public string Name { get; public set; }
    public ResourcePatternType ResourcePatternType { get; public set; }
    [CompilerGeneratedAttribute]
public ResourceType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ResourceType value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ResourcePatternType get_ResourcePatternType();
    [CompilerGeneratedAttribute]
public void set_ResourcePatternType(ResourcePatternType value);
    public ResourcePatternFilter Clone();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ResourcePatternFilter a, ResourcePatternFilter b);
    public static bool op_Inequality(ResourcePatternFilter a, ResourcePatternFilter b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum Confluent.Kafka.Admin.ResourcePatternType : Enum {
    public int value__;
    public static ResourcePatternType Unknown;
    public static ResourcePatternType Any;
    public static ResourcePatternType Match;
    public static ResourcePatternType Literal;
    public static ResourcePatternType Prefixed;
}
public enum Confluent.Kafka.Admin.ResourceType : Enum {
    public int value__;
    public static ResourceType Unknown;
    public static ResourceType Any;
    public static ResourceType Topic;
    public static ResourceType Group;
    public static ResourceType Broker;
}
public class Confluent.Kafka.Admin.ScramCredentialInfo : object {
    [CompilerGeneratedAttribute]
private ScramMechanism <Mechanism>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    public ScramMechanism Mechanism { get; public set; }
    public int Iterations { get; public set; }
    [CompilerGeneratedAttribute]
public ScramMechanism get_Mechanism();
    [CompilerGeneratedAttribute]
public void set_Mechanism(ScramMechanism value);
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public void set_Iterations(int value);
    public virtual string ToString();
}
public enum Confluent.Kafka.Admin.ScramMechanism : Enum {
    public int value__;
    public static ScramMechanism Unknown;
    public static ScramMechanism ScramSha256;
    public static ScramMechanism ScramSha512;
}
public class Confluent.Kafka.Admin.TopicDescription : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uuid <TopicId>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TopicPartitionInfo> <Partitions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AclOperation> <AuthorizedOperations>k__BackingField;
    public string Name { get; public set; }
    public Uuid TopicId { get; public set; }
    public Error Error { get; public set; }
    public bool IsInternal { get; public set; }
    public List`1<TopicPartitionInfo> Partitions { get; public set; }
    public List`1<AclOperation> AuthorizedOperations { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Uuid get_TopicId();
    [CompilerGeneratedAttribute]
public void set_TopicId(Uuid value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    [CompilerGeneratedAttribute]
public bool get_IsInternal();
    [CompilerGeneratedAttribute]
public void set_IsInternal(bool value);
    [CompilerGeneratedAttribute]
public List`1<TopicPartitionInfo> get_Partitions();
    [CompilerGeneratedAttribute]
public void set_Partitions(List`1<TopicPartitionInfo> value);
    [CompilerGeneratedAttribute]
public List`1<AclOperation> get_AuthorizedOperations();
    [CompilerGeneratedAttribute]
public void set_AuthorizedOperations(List`1<AclOperation> value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.TopicPartitionOffsetSpec : object {
    [CompilerGeneratedAttribute]
private TopicPartition <TopicPartition>k__BackingField;
    [CompilerGeneratedAttribute]
private OffsetSpec <OffsetSpec>k__BackingField;
    public TopicPartition TopicPartition { get; public set; }
    public OffsetSpec OffsetSpec { get; public set; }
    [CompilerGeneratedAttribute]
public TopicPartition get_TopicPartition();
    [CompilerGeneratedAttribute]
public void set_TopicPartition(TopicPartition value);
    [CompilerGeneratedAttribute]
public OffsetSpec get_OffsetSpec();
    [CompilerGeneratedAttribute]
public void set_OffsetSpec(OffsetSpec value);
}
public class Confluent.Kafka.Admin.TopicSpecification : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Configs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumPartitions>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, List`1<int>> <ReplicasAssignments>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ReplicationFactor>k__BackingField;
    public Dictionary`2<string, string> Configs { get; public set; }
    public string Name { get; public set; }
    public int NumPartitions { get; public set; }
    public Dictionary`2<int, List`1<int>> ReplicasAssignments { get; public set; }
    public short ReplicationFactor { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Configs();
    [CompilerGeneratedAttribute]
public void set_Configs(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_NumPartitions();
    [CompilerGeneratedAttribute]
public void set_NumPartitions(int value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, List`1<int>> get_ReplicasAssignments();
    [CompilerGeneratedAttribute]
public void set_ReplicasAssignments(Dictionary`2<int, List`1<int>> value);
    [CompilerGeneratedAttribute]
public short get_ReplicationFactor();
    [CompilerGeneratedAttribute]
public void set_ReplicationFactor(short value);
}
public class Confluent.Kafka.Admin.UserScramCredentialAlteration : object {
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    public string User { get; public set; }
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
public void set_User(string value);
}
public class Confluent.Kafka.Admin.UserScramCredentialDeletion : UserScramCredentialAlteration {
    [CompilerGeneratedAttribute]
private ScramMechanism <Mechanism>k__BackingField;
    public ScramMechanism Mechanism { get; public set; }
    [CompilerGeneratedAttribute]
public ScramMechanism get_Mechanism();
    [CompilerGeneratedAttribute]
public void set_Mechanism(ScramMechanism value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.UserScramCredentialsDescription : object {
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScramCredentialInfo> <ScramCredentialInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string User { get; public set; }
    public List`1<ScramCredentialInfo> ScramCredentialInfos { get; public set; }
    public Error Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
public void set_User(string value);
    [CompilerGeneratedAttribute]
public List`1<ScramCredentialInfo> get_ScramCredentialInfos();
    [CompilerGeneratedAttribute]
public void set_ScramCredentialInfos(List`1<ScramCredentialInfo> value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    public virtual string ToString();
}
public class Confluent.Kafka.Admin.UserScramCredentialUpsertion : UserScramCredentialAlteration {
    [CompilerGeneratedAttribute]
private ScramCredentialInfo <ScramCredentialInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Salt>k__BackingField;
    public ScramCredentialInfo ScramCredentialInfo { get; public set; }
    public Byte[] Password { get; public set; }
    public Byte[] Salt { get; public set; }
    [CompilerGeneratedAttribute]
public ScramCredentialInfo get_ScramCredentialInfo();
    [CompilerGeneratedAttribute]
public void set_ScramCredentialInfo(ScramCredentialInfo value);
    [CompilerGeneratedAttribute]
public Byte[] get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Salt();
    [CompilerGeneratedAttribute]
public void set_Salt(Byte[] value);
    public virtual string ToString();
}
internal class Confluent.Kafka.AdminClient : object {
    private int cancellationDelayMaxMs;
    private Task callbackTask;
    private CancellationTokenSource callbackCts;
    private IntPtr resultQueue;
    internal static Dictionary`2<EventType, Type> adminClientResultTypes;
    private IClient ownedClient;
    private Handle handle;
    private SafeKafkaHandle kafkaHandle { get; }
    public string Name { get; }
    public Handle Handle { get; }
    internal AdminClient(Handle handle);
    internal AdminClient(AdminClientBuilder builder);
    private static AdminClient();
    private List`1<DeleteRecordsReport> extractDeleteRecordsReports(IntPtr resultPtr);
    private List`1<CreateTopicReport> extractTopicResults(IntPtr topicResultsPtr, int topicResultsCount);
    private ConfigEntryResult extractConfigEntry(IntPtr configEntryPtr);
    private List`1<DescribeConfigsReport> extractResultConfigs(IntPtr configResourcesPtr, int configResourceCount);
    private static List`1<DeleteGroupReport> extractDeleteGroupsReport(IntPtr eventPtr);
    private List`1<CreateAclReport> extractCreateAclReports(IntPtr aclResultsPtr, int aclResultsCount);
    private List`1<AclBinding> extractAclBindings(IntPtr aclBindingsPtr, int aclBindingsCnt);
    private DescribeAclsReport extractDescribeAclsReport(IntPtr resultPtr);
    private List`1<DeleteAclsReport> extractDeleteAclsReports(IntPtr resultPtr);
    private DeleteConsumerGroupOffsetsReport extractDeleteConsumerGroupOffsetsReports(IntPtr resultPtr);
    private List`1<ListConsumerGroupOffsetsReport> extractListConsumerGroupOffsetsResults(IntPtr resultPtr);
    private List`1<AlterConsumerGroupOffsetsReport> extractAlterConsumerGroupOffsetsResults(IntPtr resultPtr);
    private ListConsumerGroupsReport extractListConsumerGroupsResults(IntPtr resultPtr);
    private DescribeConsumerGroupsReport extractDescribeConsumerGroupsResults(IntPtr resultPtr);
    private DescribeUserScramCredentialsReport extractDescribeUserScramCredentialsResult(IntPtr eventPtr);
    private List`1<AlterUserScramCredentialsReport> extractAlterUserScramCredentialsResults(IntPtr eventPtr);
    private List`1<TopicPartitionInfo> extractTopicPartitionInfo(IntPtr topicPartitionInfosPtr, int topicPartitionInfosCount);
    private DescribeTopicsReport extractDescribeTopicsResults(IntPtr resultPtr);
    private Uuid extractUuid(IntPtr uuidPtr);
    private Node extractNode(IntPtr nodePtr);
    private List`1<Node> extractNodeList(IntPtr nodesPtr, int nodesCount);
    private List`1<AclOperation> extractAuthorizedOperations(IntPtr authorizedOperationsPtr, int authorizedOperationCount);
    private DescribeClusterResult extractDescribeClusterResult(IntPtr resultPtr);
    private ListOffsetsReport extractListOffsetsReport(IntPtr resultPtr);
    private Task StartPollTask(CancellationToken ct);
    public sealed virtual Task`1<List`1<DescribeConfigsResult>> DescribeConfigsAsync(IEnumerable`1<ConfigResource> resources, DescribeConfigsOptions options);
    public sealed virtual Task AlterConfigsAsync(Dictionary`2<ConfigResource, List`1<ConfigEntry>> configs, AlterConfigsOptions options);
    public sealed virtual Task`1<List`1<IncrementalAlterConfigsResult>> IncrementalAlterConfigsAsync(Dictionary`2<ConfigResource, List`1<ConfigEntry>> configs, IncrementalAlterConfigsOptions options);
    public sealed virtual Task CreateTopicsAsync(IEnumerable`1<TopicSpecification> topics, CreateTopicsOptions options);
    public sealed virtual Task DeleteTopicsAsync(IEnumerable`1<string> topics, DeleteTopicsOptions options);
    public sealed virtual Task DeleteGroupsAsync(IList`1<string> groups, DeleteGroupsOptions options);
    public sealed virtual Task`1<DeleteConsumerGroupOffsetsResult> DeleteConsumerGroupOffsetsAsync(string group, IEnumerable`1<TopicPartition> partitions, DeleteConsumerGroupOffsetsOptions options);
    public sealed virtual Task CreatePartitionsAsync(IEnumerable`1<PartitionsSpecification> partitionsSpecifications, CreatePartitionsOptions options);
    public sealed virtual Task`1<List`1<DeleteRecordsResult>> DeleteRecordsAsync(IEnumerable`1<TopicPartitionOffset> topicPartitionOffsets, DeleteRecordsOptions options);
    private SafeKafkaHandle get_kafkaHandle();
    private void Init();
    public sealed virtual List`1<GroupInfo> ListGroups(TimeSpan timeout);
    public sealed virtual GroupInfo ListGroup(string group, TimeSpan timeout);
    public sealed virtual Metadata GetMetadata(TimeSpan timeout);
    public sealed virtual Metadata GetMetadata(string topic, TimeSpan timeout);
    public sealed virtual int AddBrokers(string brokers);
    public sealed virtual void SetSaslCredentials(string username, string password);
    public sealed virtual string get_Name();
    public sealed virtual Handle get_Handle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void DisposeResources();
    public sealed virtual Task CreateAclsAsync(IEnumerable`1<AclBinding> aclBindings, CreateAclsOptions options);
    public sealed virtual Task`1<DescribeAclsResult> DescribeAclsAsync(AclBindingFilter aclBindingFilter, DescribeAclsOptions options);
    public sealed virtual Task`1<List`1<DeleteAclsResult>> DeleteAclsAsync(IEnumerable`1<AclBindingFilter> aclBindingFilters, DeleteAclsOptions options);
    public sealed virtual Task`1<List`1<AlterConsumerGroupOffsetsResult>> AlterConsumerGroupOffsetsAsync(IEnumerable`1<ConsumerGroupTopicPartitionOffsets> groupPartitions, AlterConsumerGroupOffsetsOptions options);
    public sealed virtual Task`1<List`1<ListConsumerGroupOffsetsResult>> ListConsumerGroupOffsetsAsync(IEnumerable`1<ConsumerGroupTopicPartitions> groupPartitions, ListConsumerGroupOffsetsOptions options);
    public sealed virtual Task`1<ListConsumerGroupsResult> ListConsumerGroupsAsync(ListConsumerGroupsOptions options);
    public sealed virtual Task`1<DescribeConsumerGroupsResult> DescribeConsumerGroupsAsync(IEnumerable`1<string> groups, DescribeConsumerGroupsOptions options);
    public sealed virtual Task`1<DescribeUserScramCredentialsResult> DescribeUserScramCredentialsAsync(IEnumerable`1<string> users, DescribeUserScramCredentialsOptions options);
    public sealed virtual Task AlterUserScramCredentialsAsync(IEnumerable`1<UserScramCredentialAlteration> alterations, AlterUserScramCredentialsOptions options);
    public Task`1<DescribeTopicsResult> DescribeTopicsAsync(TopicCollection topicCollection, DescribeTopicsOptions options);
    public Task`1<DescribeClusterResult> DescribeClusterAsync(DescribeClusterOptions options);
    public Task`1<ListOffsetsResult> ListOffsetsAsync(IEnumerable`1<TopicPartitionOffsetSpec> topicPartitionOffsetSpecs, ListOffsetsOptions options);
    [CompilerGeneratedAttribute]
private ConfigEntryResult <extractConfigEntry>b__6_0(IntPtr synonymPtr);
    [CompilerGeneratedAttribute]
private ConfigEntryResult <extractResultConfigs>b__7_0(IntPtr configEntryPtr);
    [CompilerGeneratedAttribute]
private DeleteAclsReport <extractDeleteAclsReports>b__12_0(IntPtr resultResponsePtr);
    [CompilerGeneratedAttribute]
private ConsumerGroupDescription <extractDescribeConsumerGroupsResults>b__17_0(IntPtr groupPtr);
    [CompilerGeneratedAttribute]
private TopicPartitionInfo <extractTopicPartitionInfo>b__20_0(IntPtr topicPartitionInfoPtr);
    [CompilerGeneratedAttribute]
private TopicDescription <extractDescribeTopicsResults>b__21_0(IntPtr topicPtr);
    [CompilerGeneratedAttribute]
private Node <extractNodeList>b__24_0(IntPtr nodePtr);
}
public class Confluent.Kafka.AdminClientBuilder : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, string>> <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IAdminClient, Error> <ErrorHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IAdminClient, LogMessage> <LogHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IAdminClient, string> <StatisticsHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IProducer`2<Null, Null>, string> <OAuthBearerTokenRefreshHandler>k__BackingField;
    protected internal IEnumerable`1<KeyValuePair`2<string, string>> Config { get; protected internal set; }
    protected internal Action`2<IAdminClient, Error> ErrorHandler { get; protected internal set; }
    protected internal Action`2<IAdminClient, LogMessage> LogHandler { get; protected internal set; }
    protected internal Action`2<IAdminClient, string> StatisticsHandler { get; protected internal set; }
    public Action`2<IProducer`2<Null, Null>, string> OAuthBearerTokenRefreshHandler { get; public set; }
    public AdminClientBuilder(IEnumerable`1<KeyValuePair`2<string, string>> config);
    [CompilerGeneratedAttribute]
protected internal IEnumerable`1<KeyValuePair`2<string, string>> get_Config();
    [CompilerGeneratedAttribute]
protected internal void set_Config(IEnumerable`1<KeyValuePair`2<string, string>> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IAdminClient, Error> get_ErrorHandler();
    [CompilerGeneratedAttribute]
protected internal void set_ErrorHandler(Action`2<IAdminClient, Error> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IAdminClient, LogMessage> get_LogHandler();
    [CompilerGeneratedAttribute]
protected internal void set_LogHandler(Action`2<IAdminClient, LogMessage> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IAdminClient, string> get_StatisticsHandler();
    [CompilerGeneratedAttribute]
protected internal void set_StatisticsHandler(Action`2<IAdminClient, string> value);
    [CompilerGeneratedAttribute]
public Action`2<IProducer`2<Null, Null>, string> get_OAuthBearerTokenRefreshHandler();
    [CompilerGeneratedAttribute]
public void set_OAuthBearerTokenRefreshHandler(Action`2<IProducer`2<Null, Null>, string> value);
    public AdminClientBuilder SetStatisticsHandler(Action`2<IAdminClient, string> statisticsHandler);
    public AdminClientBuilder SetErrorHandler(Action`2<IAdminClient, Error> errorHandler);
    public AdminClientBuilder SetLogHandler(Action`2<IAdminClient, LogMessage> logHandler);
    public AdminClientBuilder SetOAuthBearerTokenRefreshHandler(Action`2<IProducer`2<Null, Null>, string> oAuthBearerTokenRefreshHandler);
    public virtual IAdminClient Build();
}
public class Confluent.Kafka.AdminClientConfig : ClientConfig {
    public AdminClientConfig(ClientConfig config);
    public AdminClientConfig(IDictionary`2<string, string> config);
    public AdminClientConfig ThrowIfContainsNonUserConfigurable();
}
public enum Confluent.Kafka.AutoOffsetReset : Enum {
    public int value__;
    public static AutoOffsetReset Latest;
    public static AutoOffsetReset Earliest;
    public static AutoOffsetReset Error;
}
public enum Confluent.Kafka.BrokerAddressFamily : Enum {
    public int value__;
    public static BrokerAddressFamily Any;
    public static BrokerAddressFamily V4;
    public static BrokerAddressFamily V6;
}
public class Confluent.Kafka.BrokerMetadata : object {
    [CompilerGeneratedAttribute]
private int <BrokerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    public int BrokerId { get; }
    public string Host { get; }
    public int Port { get; }
    public BrokerMetadata(int brokerId, string host, int port);
    [CompilerGeneratedAttribute]
public int get_BrokerId();
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public int get_Port();
    public virtual string ToString();
}
public class Confluent.Kafka.ClientConfig : Config {
    public Nullable`1<SaslMechanism> SaslMechanism { get; public set; }
    public Nullable`1<Acks> Acks { get; public set; }
    public string ClientId { get; public set; }
    public string BootstrapServers { get; public set; }
    public Nullable`1<int> MessageMaxBytes { get; public set; }
    public Nullable`1<int> MessageCopyMaxBytes { get; public set; }
    public Nullable`1<int> ReceiveMessageMaxBytes { get; public set; }
    public Nullable`1<int> MaxInFlight { get; public set; }
    public Nullable`1<int> TopicMetadataRefreshIntervalMs { get; public set; }
    public Nullable`1<int> MetadataMaxAgeMs { get; public set; }
    public Nullable`1<int> TopicMetadataRefreshFastIntervalMs { get; public set; }
    public Nullable`1<bool> TopicMetadataRefreshSparse { get; public set; }
    public Nullable`1<int> TopicMetadataPropagationMaxMs { get; public set; }
    public string TopicBlacklist { get; public set; }
    public string Debug { get; public set; }
    public Nullable`1<int> SocketTimeoutMs { get; public set; }
    public Nullable`1<int> SocketSendBufferBytes { get; public set; }
    public Nullable`1<int> SocketReceiveBufferBytes { get; public set; }
    public Nullable`1<bool> SocketKeepaliveEnable { get; public set; }
    public Nullable`1<bool> SocketNagleDisable { get; public set; }
    public Nullable`1<int> SocketMaxFails { get; public set; }
    public Nullable`1<int> BrokerAddressTtl { get; public set; }
    public Nullable`1<BrokerAddressFamily> BrokerAddressFamily { get; public set; }
    public Nullable`1<int> SocketConnectionSetupTimeoutMs { get; public set; }
    public Nullable`1<int> ConnectionsMaxIdleMs { get; public set; }
    public Nullable`1<int> ReconnectBackoffMs { get; public set; }
    public Nullable`1<int> ReconnectBackoffMaxMs { get; public set; }
    public Nullable`1<int> StatisticsIntervalMs { get; public set; }
    public Nullable`1<bool> LogQueue { get; public set; }
    public Nullable`1<bool> LogThreadName { get; public set; }
    public Nullable`1<bool> EnableRandomSeed { get; public set; }
    public Nullable`1<bool> LogConnectionClose { get; public set; }
    public Nullable`1<int> InternalTerminationSignal { get; public set; }
    public Nullable`1<bool> ApiVersionRequest { get; public set; }
    public Nullable`1<int> ApiVersionRequestTimeoutMs { get; public set; }
    public Nullable`1<int> ApiVersionFallbackMs { get; public set; }
    public string BrokerVersionFallback { get; public set; }
    public Nullable`1<bool> AllowAutoCreateTopics { get; public set; }
    public Nullable`1<SecurityProtocol> SecurityProtocol { get; public set; }
    public string SslCipherSuites { get; public set; }
    public string SslCurvesList { get; public set; }
    public string SslSigalgsList { get; public set; }
    public string SslKeyLocation { get; public set; }
    public string SslKeyPassword { get; public set; }
    public string SslKeyPem { get; public set; }
    public string SslCertificateLocation { get; public set; }
    public string SslCertificatePem { get; public set; }
    public string SslCaLocation { get; public set; }
    public string SslCaPem { get; public set; }
    public string SslCaCertificateStores { get; public set; }
    public string SslCrlLocation { get; public set; }
    public string SslKeystoreLocation { get; public set; }
    public string SslKeystorePassword { get; public set; }
    public string SslProviders { get; public set; }
    public string SslEngineLocation { get; public set; }
    public string SslEngineId { get; public set; }
    public Nullable`1<bool> EnableSslCertificateVerification { get; public set; }
    public Nullable`1<SslEndpointIdentificationAlgorithm> SslEndpointIdentificationAlgorithm { get; public set; }
    public string SaslKerberosServiceName { get; public set; }
    public string SaslKerberosPrincipal { get; public set; }
    public string SaslKerberosKinitCmd { get; public set; }
    public string SaslKerberosKeytab { get; public set; }
    public Nullable`1<int> SaslKerberosMinTimeBeforeRelogin { get; public set; }
    public string SaslUsername { get; public set; }
    public string SaslPassword { get; public set; }
    public string SaslOauthbearerConfig { get; public set; }
    public Nullable`1<bool> EnableSaslOauthbearerUnsecureJwt { get; public set; }
    public Nullable`1<SaslOauthbearerMethod> SaslOauthbearerMethod { get; public set; }
    public string SaslOauthbearerClientId { get; public set; }
    public string SaslOauthbearerClientSecret { get; public set; }
    public string SaslOauthbearerScope { get; public set; }
    public string SaslOauthbearerExtensions { get; public set; }
    public string SaslOauthbearerTokenEndpointUrl { get; public set; }
    public string PluginLibraryPaths { get; public set; }
    public string ClientRack { get; public set; }
    public Nullable`1<int> RetryBackoffMs { get; public set; }
    public Nullable`1<int> RetryBackoffMaxMs { get; public set; }
    public Nullable`1<ClientDnsLookup> ClientDnsLookup { get; public set; }
    public Nullable`1<bool> EnableMetricsPush { get; public set; }
    public ClientConfig(ClientConfig config);
    public ClientConfig(IDictionary`2<string, string> config);
    public Nullable`1<SaslMechanism> get_SaslMechanism();
    public void set_SaslMechanism(Nullable`1<SaslMechanism> value);
    public Nullable`1<Acks> get_Acks();
    public void set_Acks(Nullable`1<Acks> value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_BootstrapServers();
    public void set_BootstrapServers(string value);
    public Nullable`1<int> get_MessageMaxBytes();
    public void set_MessageMaxBytes(Nullable`1<int> value);
    public Nullable`1<int> get_MessageCopyMaxBytes();
    public void set_MessageCopyMaxBytes(Nullable`1<int> value);
    public Nullable`1<int> get_ReceiveMessageMaxBytes();
    public void set_ReceiveMessageMaxBytes(Nullable`1<int> value);
    public Nullable`1<int> get_MaxInFlight();
    public void set_MaxInFlight(Nullable`1<int> value);
    public Nullable`1<int> get_TopicMetadataRefreshIntervalMs();
    public void set_TopicMetadataRefreshIntervalMs(Nullable`1<int> value);
    public Nullable`1<int> get_MetadataMaxAgeMs();
    public void set_MetadataMaxAgeMs(Nullable`1<int> value);
    public Nullable`1<int> get_TopicMetadataRefreshFastIntervalMs();
    public void set_TopicMetadataRefreshFastIntervalMs(Nullable`1<int> value);
    public Nullable`1<bool> get_TopicMetadataRefreshSparse();
    public void set_TopicMetadataRefreshSparse(Nullable`1<bool> value);
    public Nullable`1<int> get_TopicMetadataPropagationMaxMs();
    public void set_TopicMetadataPropagationMaxMs(Nullable`1<int> value);
    public string get_TopicBlacklist();
    public void set_TopicBlacklist(string value);
    public string get_Debug();
    public void set_Debug(string value);
    public Nullable`1<int> get_SocketTimeoutMs();
    public void set_SocketTimeoutMs(Nullable`1<int> value);
    public Nullable`1<int> get_SocketSendBufferBytes();
    public void set_SocketSendBufferBytes(Nullable`1<int> value);
    public Nullable`1<int> get_SocketReceiveBufferBytes();
    public void set_SocketReceiveBufferBytes(Nullable`1<int> value);
    public Nullable`1<bool> get_SocketKeepaliveEnable();
    public void set_SocketKeepaliveEnable(Nullable`1<bool> value);
    public Nullable`1<bool> get_SocketNagleDisable();
    public void set_SocketNagleDisable(Nullable`1<bool> value);
    public Nullable`1<int> get_SocketMaxFails();
    public void set_SocketMaxFails(Nullable`1<int> value);
    public Nullable`1<int> get_BrokerAddressTtl();
    public void set_BrokerAddressTtl(Nullable`1<int> value);
    public Nullable`1<BrokerAddressFamily> get_BrokerAddressFamily();
    public void set_BrokerAddressFamily(Nullable`1<BrokerAddressFamily> value);
    public Nullable`1<int> get_SocketConnectionSetupTimeoutMs();
    public void set_SocketConnectionSetupTimeoutMs(Nullable`1<int> value);
    public Nullable`1<int> get_ConnectionsMaxIdleMs();
    public void set_ConnectionsMaxIdleMs(Nullable`1<int> value);
    public Nullable`1<int> get_ReconnectBackoffMs();
    public void set_ReconnectBackoffMs(Nullable`1<int> value);
    public Nullable`1<int> get_ReconnectBackoffMaxMs();
    public void set_ReconnectBackoffMaxMs(Nullable`1<int> value);
    public Nullable`1<int> get_StatisticsIntervalMs();
    public void set_StatisticsIntervalMs(Nullable`1<int> value);
    public Nullable`1<bool> get_LogQueue();
    public void set_LogQueue(Nullable`1<bool> value);
    public Nullable`1<bool> get_LogThreadName();
    public void set_LogThreadName(Nullable`1<bool> value);
    public Nullable`1<bool> get_EnableRandomSeed();
    public void set_EnableRandomSeed(Nullable`1<bool> value);
    public Nullable`1<bool> get_LogConnectionClose();
    public void set_LogConnectionClose(Nullable`1<bool> value);
    public Nullable`1<int> get_InternalTerminationSignal();
    public void set_InternalTerminationSignal(Nullable`1<int> value);
    public Nullable`1<bool> get_ApiVersionRequest();
    public void set_ApiVersionRequest(Nullable`1<bool> value);
    public Nullable`1<int> get_ApiVersionRequestTimeoutMs();
    public void set_ApiVersionRequestTimeoutMs(Nullable`1<int> value);
    public Nullable`1<int> get_ApiVersionFallbackMs();
    public void set_ApiVersionFallbackMs(Nullable`1<int> value);
    public string get_BrokerVersionFallback();
    public void set_BrokerVersionFallback(string value);
    public Nullable`1<bool> get_AllowAutoCreateTopics();
    public void set_AllowAutoCreateTopics(Nullable`1<bool> value);
    public Nullable`1<SecurityProtocol> get_SecurityProtocol();
    public void set_SecurityProtocol(Nullable`1<SecurityProtocol> value);
    public string get_SslCipherSuites();
    public void set_SslCipherSuites(string value);
    public string get_SslCurvesList();
    public void set_SslCurvesList(string value);
    public string get_SslSigalgsList();
    public void set_SslSigalgsList(string value);
    public string get_SslKeyLocation();
    public void set_SslKeyLocation(string value);
    public string get_SslKeyPassword();
    public void set_SslKeyPassword(string value);
    public string get_SslKeyPem();
    public void set_SslKeyPem(string value);
    public string get_SslCertificateLocation();
    public void set_SslCertificateLocation(string value);
    public string get_SslCertificatePem();
    public void set_SslCertificatePem(string value);
    public string get_SslCaLocation();
    public void set_SslCaLocation(string value);
    public string get_SslCaPem();
    public void set_SslCaPem(string value);
    public string get_SslCaCertificateStores();
    public void set_SslCaCertificateStores(string value);
    public string get_SslCrlLocation();
    public void set_SslCrlLocation(string value);
    public string get_SslKeystoreLocation();
    public void set_SslKeystoreLocation(string value);
    public string get_SslKeystorePassword();
    public void set_SslKeystorePassword(string value);
    public string get_SslProviders();
    public void set_SslProviders(string value);
    public string get_SslEngineLocation();
    public void set_SslEngineLocation(string value);
    public string get_SslEngineId();
    public void set_SslEngineId(string value);
    public Nullable`1<bool> get_EnableSslCertificateVerification();
    public void set_EnableSslCertificateVerification(Nullable`1<bool> value);
    public Nullable`1<SslEndpointIdentificationAlgorithm> get_SslEndpointIdentificationAlgorithm();
    public void set_SslEndpointIdentificationAlgorithm(Nullable`1<SslEndpointIdentificationAlgorithm> value);
    public string get_SaslKerberosServiceName();
    public void set_SaslKerberosServiceName(string value);
    public string get_SaslKerberosPrincipal();
    public void set_SaslKerberosPrincipal(string value);
    public string get_SaslKerberosKinitCmd();
    public void set_SaslKerberosKinitCmd(string value);
    public string get_SaslKerberosKeytab();
    public void set_SaslKerberosKeytab(string value);
    public Nullable`1<int> get_SaslKerberosMinTimeBeforeRelogin();
    public void set_SaslKerberosMinTimeBeforeRelogin(Nullable`1<int> value);
    public string get_SaslUsername();
    public void set_SaslUsername(string value);
    public string get_SaslPassword();
    public void set_SaslPassword(string value);
    public string get_SaslOauthbearerConfig();
    public void set_SaslOauthbearerConfig(string value);
    public Nullable`1<bool> get_EnableSaslOauthbearerUnsecureJwt();
    public void set_EnableSaslOauthbearerUnsecureJwt(Nullable`1<bool> value);
    public Nullable`1<SaslOauthbearerMethod> get_SaslOauthbearerMethod();
    public void set_SaslOauthbearerMethod(Nullable`1<SaslOauthbearerMethod> value);
    public string get_SaslOauthbearerClientId();
    public void set_SaslOauthbearerClientId(string value);
    public string get_SaslOauthbearerClientSecret();
    public void set_SaslOauthbearerClientSecret(string value);
    public string get_SaslOauthbearerScope();
    public void set_SaslOauthbearerScope(string value);
    public string get_SaslOauthbearerExtensions();
    public void set_SaslOauthbearerExtensions(string value);
    public string get_SaslOauthbearerTokenEndpointUrl();
    public void set_SaslOauthbearerTokenEndpointUrl(string value);
    public string get_PluginLibraryPaths();
    public void set_PluginLibraryPaths(string value);
    public string get_ClientRack();
    public void set_ClientRack(string value);
    public Nullable`1<int> get_RetryBackoffMs();
    public void set_RetryBackoffMs(Nullable`1<int> value);
    public Nullable`1<int> get_RetryBackoffMaxMs();
    public void set_RetryBackoffMaxMs(Nullable`1<int> value);
    public Nullable`1<ClientDnsLookup> get_ClientDnsLookup();
    public void set_ClientDnsLookup(Nullable`1<ClientDnsLookup> value);
    public Nullable`1<bool> get_EnableMetricsPush();
    public void set_EnableMetricsPush(Nullable`1<bool> value);
}
public enum Confluent.Kafka.ClientDnsLookup : Enum {
    public int value__;
    public static ClientDnsLookup UseAllDnsIps;
    public static ClientDnsLookup ResolveCanonicalBootstrapServersOnly;
}
[ExtensionAttribute]
public static class Confluent.Kafka.ClientExtensions : object {
    [ExtensionAttribute]
public static void OAuthBearerSetToken(IClient client, string tokenValue, long lifetimeMs, string principalName, IDictionary`2<string, string> extensions);
    [ExtensionAttribute]
public static void OAuthBearerSetTokenFailure(IClient client, string error);
}
public class Confluent.Kafka.CommittedOffsets : object {
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TopicPartitionOffsetError> <Offsets>k__BackingField;
    public Error Error { get; }
    public IList`1<TopicPartitionOffsetError> Offsets { get; }
    public CommittedOffsets(IList`1<TopicPartitionOffsetError> offsets, Error error);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public IList`1<TopicPartitionOffsetError> get_Offsets();
}
public enum Confluent.Kafka.CompressionType : Enum {
    public int value__;
    public static CompressionType None;
    public static CompressionType Gzip;
    public static CompressionType Snappy;
    public static CompressionType Lz4;
    public static CompressionType Zstd;
}
public class Confluent.Kafka.Config : object {
    private static Dictionary`2<string, string> EnumNameToConfigValueSubstitutes;
    protected IDictionary`2<string, string> properties;
    private static int DefaultCancellationDelayMaxMs;
    unknown int CancellationDelayMaxMs {public set; }
    public Config(Config config);
    public Config(IDictionary`2<string, string> config);
    private static Config();
    public void Set(string key, string val);
    public string Get(string key);
    protected Nullable`1<int> GetInt(string key);
    protected Nullable`1<bool> GetBool(string key);
    protected Nullable`1<double> GetDouble(string key);
    protected object GetEnum(Type type, string key);
    protected void SetObject(string name, object val);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void set_CancellationDelayMaxMs(int value);
    internal static IEnumerable`1<KeyValuePair`2<string, string>> ExtractCancellationDelayMaxMs(IEnumerable`1<KeyValuePair`2<string, string>> config, Int32& cancellationDelayMaxMs);
}
public static class Confluent.Kafka.ConfigPropertyNames : object {
    public static string CancellationDelayMaxMs;
}
public class Confluent.Kafka.ConsumeException : KafkaException {
    [CompilerGeneratedAttribute]
private ConsumeResult`2<Byte[], Byte[]> <ConsumerRecord>k__BackingField;
    public ConsumeResult`2<Byte[], Byte[]> ConsumerRecord { get; private set; }
    public ConsumeException(ConsumeResult`2<Byte[], Byte[]> consumerRecord, Error error, Exception innerException);
    public ConsumeException(ConsumeResult`2<Byte[], Byte[]> consumerRecord, Error error);
    [CompilerGeneratedAttribute]
public ConsumeResult`2<Byte[], Byte[]> get_ConsumerRecord();
    [CompilerGeneratedAttribute]
private void set_ConsumerRecord(ConsumeResult`2<Byte[], Byte[]> value);
}
internal class Confluent.Kafka.Consumer`2 : object {
    private IDeserializer`1<TKey> keyDeserializer;
    private IDeserializer`1<TValue> valueDeserializer;
    private Dictionary`2<Type, object> defaultDeserializers;
    private int cancellationDelayMaxMs;
    private bool disposeHasBeenCalled;
    private object disposeHasBeenCalledLockObj;
    private int assignCallCount;
    private object assignCallCountLockObj;
    private bool enableHeaderMarshaling;
    private bool enableTimestampMarshaling;
    private bool enableTopicNameMarshaling;
    private SafeKafkaHandle kafkaHandle;
    private Exception handlerException;
    private Action`1<Error> errorHandler;
    private ErrorDelegate errorCallbackDelegate;
    private Action`1<string> statisticsHandler;
    private StatsDelegate statisticsCallbackDelegate;
    private Action`1<string> oAuthBearerTokenRefreshHandler;
    private OAuthBearerTokenRefreshDelegate oAuthBearerTokenRefreshCallbackDelegate;
    private Action`1<LogMessage> logHandler;
    private object loggerLockObj;
    private LogDelegate logCallbackDelegate;
    private Func`2<List`1<TopicPartition>, IEnumerable`1<TopicPartitionOffset>> partitionsAssignedHandler;
    private Func`2<List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> partitionsRevokedHandler;
    private Func`2<List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> partitionsLostHandler;
    private bool revokedOrLostHandlerIsFunc;
    private RebalanceDelegate rebalanceDelegate;
    private Action`1<CommittedOffsets> offsetsCommittedHandler;
    private CommitDelegate commitDelegate;
    public List`1<TopicPartition> Assignment { get; }
    public List`1<string> Subscription { get; }
    public string MemberId { get; }
    public string Name { get; }
    public Handle Handle { get; }
    public IConsumerGroupMetadata ConsumerGroupMetadata { get; }
    internal Consumer`2(ConsumerBuilder`2<TKey, TValue> builder);
    private void ErrorCallback(IntPtr rk, ErrorCode err, string reason, IntPtr opaque);
    private int StatisticsCallback(IntPtr rk, IntPtr json, UIntPtr json_len, IntPtr opaque);
    private void OAuthBearerTokenRefreshCallback(IntPtr rk, IntPtr oauthbearer_config, IntPtr opaque);
    private void LogCallback(IntPtr rk, SyslogLevel level, string fac, string buf);
    private void RebalanceCallback(IntPtr rk, ErrorCode err, IntPtr partitionsPtr, IntPtr opaque);
    private void CommitCallback(IntPtr rk, ErrorCode err, IntPtr offsets, IntPtr opaque);
    private static Byte[] KeyAsByteArray(rd_kafka_message msg);
    private static Byte[] ValueAsByteArray(rd_kafka_message msg);
    public sealed virtual List`1<TopicPartition> get_Assignment();
    public sealed virtual List`1<string> get_Subscription();
    public sealed virtual void Subscribe(IEnumerable`1<string> topics);
    public sealed virtual void Subscribe(string topic);
    public sealed virtual void Unsubscribe();
    public sealed virtual void Assign(TopicPartition partition);
    public sealed virtual void Assign(TopicPartitionOffset partition);
    public sealed virtual void Assign(IEnumerable`1<TopicPartitionOffset> partitions);
    public sealed virtual void Assign(IEnumerable`1<TopicPartition> partitions);
    public sealed virtual void IncrementalAssign(IEnumerable`1<TopicPartitionOffset> partitions);
    public sealed virtual void IncrementalAssign(IEnumerable`1<TopicPartition> partitions);
    public sealed virtual void IncrementalUnassign(IEnumerable`1<TopicPartition> partitions);
    public sealed virtual void Unassign();
    public sealed virtual void StoreOffset(ConsumeResult`2<TKey, TValue> result);
    public sealed virtual void StoreOffset(TopicPartitionOffset offset);
    public sealed virtual List`1<TopicPartitionOffset> Commit();
    public sealed virtual void Commit(IEnumerable`1<TopicPartitionOffset> offsets);
    public sealed virtual void Commit(ConsumeResult`2<TKey, TValue> result);
    public sealed virtual void Seek(TopicPartitionOffset tpo);
    public sealed virtual void Pause(IEnumerable`1<TopicPartition> partitions);
    public sealed virtual void Resume(IEnumerable`1<TopicPartition> partitions);
    public sealed virtual List`1<TopicPartitionOffset> Committed(TimeSpan timeout);
    public sealed virtual List`1<TopicPartitionOffset> Committed(IEnumerable`1<TopicPartition> partitions, TimeSpan timeout);
    public sealed virtual Offset Position(TopicPartition partition);
    public sealed virtual List`1<TopicPartitionOffset> OffsetsForTimes(IEnumerable`1<TopicPartitionTimestamp> timestampsToSearch, TimeSpan timeout);
    public sealed virtual WatermarkOffsets GetWatermarkOffsets(TopicPartition topicPartition);
    public sealed virtual WatermarkOffsets QueryWatermarkOffsets(TopicPartition topicPartition, TimeSpan timeout);
    public sealed virtual string get_MemberId();
    public sealed virtual int AddBrokers(string brokers);
    public sealed virtual void SetSaslCredentials(string username, string password);
    public sealed virtual string get_Name();
    public sealed virtual Handle get_Handle();
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual ConsumeResult`2<TKey, TValue> Consume(int millisecondsTimeout);
    public sealed virtual ConsumeResult`2<TKey, TValue> Consume(CancellationToken cancellationToken);
    public sealed virtual ConsumeResult`2<TKey, TValue> Consume(TimeSpan timeout);
    public sealed virtual IConsumerGroupMetadata get_ConsumerGroupMetadata();
}
public class Confluent.Kafka.ConsumerBuilder`2 : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, string>> <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IConsumer`2<TKey, TValue>, Error> <ErrorHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IConsumer`2<TKey, TValue>, LogMessage> <LogHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IConsumer`2<TKey, TValue>, string> <StatisticsHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IConsumer`2<TKey, TValue>, string> <OAuthBearerTokenRefreshHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeserializer`1<TKey> <KeyDeserializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeserializer`1<TValue> <ValueDeserializer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartition>, IEnumerable`1<TopicPartitionOffset>> <PartitionsAssignedHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> <PartitionsRevokedHandler>k__BackingField;
    protected internal bool RevokedOrLostHandlerIsFunc;
    [CompilerGeneratedAttribute]
private Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> <PartitionsLostHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IConsumer`2<TKey, TValue>, CommittedOffsets> <OffsetsCommittedHandler>k__BackingField;
    protected internal IEnumerable`1<KeyValuePair`2<string, string>> Config { get; protected internal set; }
    protected internal Action`2<IConsumer`2<TKey, TValue>, Error> ErrorHandler { get; protected internal set; }
    protected internal Action`2<IConsumer`2<TKey, TValue>, LogMessage> LogHandler { get; protected internal set; }
    protected internal Action`2<IConsumer`2<TKey, TValue>, string> StatisticsHandler { get; protected internal set; }
    protected internal Action`2<IConsumer`2<TKey, TValue>, string> OAuthBearerTokenRefreshHandler { get; protected internal set; }
    protected internal IDeserializer`1<TKey> KeyDeserializer { get; protected internal set; }
    protected internal IDeserializer`1<TValue> ValueDeserializer { get; protected internal set; }
    protected internal Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartition>, IEnumerable`1<TopicPartitionOffset>> PartitionsAssignedHandler { get; protected internal set; }
    protected internal Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> PartitionsRevokedHandler { get; protected internal set; }
    protected internal Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> PartitionsLostHandler { get; protected internal set; }
    protected internal Action`2<IConsumer`2<TKey, TValue>, CommittedOffsets> OffsetsCommittedHandler { get; protected internal set; }
    public ConsumerBuilder`2(IEnumerable`1<KeyValuePair`2<string, string>> config);
    [CompilerGeneratedAttribute]
protected internal IEnumerable`1<KeyValuePair`2<string, string>> get_Config();
    [CompilerGeneratedAttribute]
protected internal void set_Config(IEnumerable`1<KeyValuePair`2<string, string>> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IConsumer`2<TKey, TValue>, Error> get_ErrorHandler();
    [CompilerGeneratedAttribute]
protected internal void set_ErrorHandler(Action`2<IConsumer`2<TKey, TValue>, Error> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IConsumer`2<TKey, TValue>, LogMessage> get_LogHandler();
    [CompilerGeneratedAttribute]
protected internal void set_LogHandler(Action`2<IConsumer`2<TKey, TValue>, LogMessage> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IConsumer`2<TKey, TValue>, string> get_StatisticsHandler();
    [CompilerGeneratedAttribute]
protected internal void set_StatisticsHandler(Action`2<IConsumer`2<TKey, TValue>, string> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IConsumer`2<TKey, TValue>, string> get_OAuthBearerTokenRefreshHandler();
    [CompilerGeneratedAttribute]
protected internal void set_OAuthBearerTokenRefreshHandler(Action`2<IConsumer`2<TKey, TValue>, string> value);
    [CompilerGeneratedAttribute]
protected internal IDeserializer`1<TKey> get_KeyDeserializer();
    [CompilerGeneratedAttribute]
protected internal void set_KeyDeserializer(IDeserializer`1<TKey> value);
    [CompilerGeneratedAttribute]
protected internal IDeserializer`1<TValue> get_ValueDeserializer();
    [CompilerGeneratedAttribute]
protected internal void set_ValueDeserializer(IDeserializer`1<TValue> value);
    [CompilerGeneratedAttribute]
protected internal Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartition>, IEnumerable`1<TopicPartitionOffset>> get_PartitionsAssignedHandler();
    [CompilerGeneratedAttribute]
protected internal void set_PartitionsAssignedHandler(Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartition>, IEnumerable`1<TopicPartitionOffset>> value);
    [CompilerGeneratedAttribute]
protected internal Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> get_PartitionsRevokedHandler();
    [CompilerGeneratedAttribute]
protected internal void set_PartitionsRevokedHandler(Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> value);
    [CompilerGeneratedAttribute]
protected internal Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> get_PartitionsLostHandler();
    [CompilerGeneratedAttribute]
protected internal void set_PartitionsLostHandler(Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IConsumer`2<TKey, TValue>, CommittedOffsets> get_OffsetsCommittedHandler();
    [CompilerGeneratedAttribute]
protected internal void set_OffsetsCommittedHandler(Action`2<IConsumer`2<TKey, TValue>, CommittedOffsets> value);
    internal Config<TKey, TValue> ConstructBaseConfig(Consumer`2<TKey, TValue> consumer);
    public ConsumerBuilder`2<TKey, TValue> SetStatisticsHandler(Action`2<IConsumer`2<TKey, TValue>, string> statisticsHandler);
    public ConsumerBuilder`2<TKey, TValue> SetErrorHandler(Action`2<IConsumer`2<TKey, TValue>, Error> errorHandler);
    public ConsumerBuilder`2<TKey, TValue> SetLogHandler(Action`2<IConsumer`2<TKey, TValue>, LogMessage> logHandler);
    public ConsumerBuilder`2<TKey, TValue> SetOAuthBearerTokenRefreshHandler(Action`2<IConsumer`2<TKey, TValue>, string> oAuthBearerTokenRefreshHandler);
    public ConsumerBuilder`2<TKey, TValue> SetKeyDeserializer(IDeserializer`1<TKey> deserializer);
    public ConsumerBuilder`2<TKey, TValue> SetValueDeserializer(IDeserializer`1<TValue> deserializer);
    public ConsumerBuilder`2<TKey, TValue> SetPartitionsAssignedHandler(Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartition>, IEnumerable`1<TopicPartitionOffset>> partitionsAssignedHandler);
    public ConsumerBuilder`2<TKey, TValue> SetPartitionsAssignedHandler(Action`2<IConsumer`2<TKey, TValue>, List`1<TopicPartition>> partitionAssignmentHandler);
    public ConsumerBuilder`2<TKey, TValue> SetPartitionsRevokedHandler(Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> partitionsRevokedHandler);
    public ConsumerBuilder`2<TKey, TValue> SetPartitionsRevokedHandler(Action`2<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>> partitionsRevokedHandler);
    public ConsumerBuilder`2<TKey, TValue> SetPartitionsLostHandler(Func`3<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>, IEnumerable`1<TopicPartitionOffset>> partitionsLostHandler);
    public ConsumerBuilder`2<TKey, TValue> SetPartitionsLostHandler(Action`2<IConsumer`2<TKey, TValue>, List`1<TopicPartitionOffset>> partitionsLostHandler);
    public ConsumerBuilder`2<TKey, TValue> SetOffsetsCommittedHandler(Action`2<IConsumer`2<TKey, TValue>, CommittedOffsets> offsetsCommittedHandler);
    public virtual IConsumer`2<TKey, TValue> Build();
}
public class Confluent.Kafka.ConsumerConfig : ClientConfig {
    unknown string ConsumeResultFields {public set; }
    public Nullable`1<AutoOffsetReset> AutoOffsetReset { get; public set; }
    public string GroupId { get; public set; }
    public string GroupInstanceId { get; public set; }
    public Nullable`1<PartitionAssignmentStrategy> PartitionAssignmentStrategy { get; public set; }
    public Nullable`1<int> SessionTimeoutMs { get; public set; }
    public Nullable`1<int> HeartbeatIntervalMs { get; public set; }
    public string GroupProtocolType { get; public set; }
    public Nullable`1<GroupProtocol> GroupProtocol { get; public set; }
    public string GroupRemoteAssignor { get; public set; }
    public Nullable`1<int> CoordinatorQueryIntervalMs { get; public set; }
    public Nullable`1<int> MaxPollIntervalMs { get; public set; }
    public Nullable`1<bool> EnableAutoCommit { get; public set; }
    public Nullable`1<int> AutoCommitIntervalMs { get; public set; }
    public Nullable`1<bool> EnableAutoOffsetStore { get; public set; }
    public Nullable`1<int> QueuedMinMessages { get; public set; }
    public Nullable`1<int> QueuedMaxMessagesKbytes { get; public set; }
    public Nullable`1<int> FetchWaitMaxMs { get; public set; }
    public Nullable`1<int> FetchQueueBackoffMs { get; public set; }
    public Nullable`1<int> MaxPartitionFetchBytes { get; public set; }
    public Nullable`1<int> FetchMaxBytes { get; public set; }
    public Nullable`1<int> FetchMinBytes { get; public set; }
    public Nullable`1<int> FetchErrorBackoffMs { get; public set; }
    public Nullable`1<IsolationLevel> IsolationLevel { get; public set; }
    public Nullable`1<bool> EnablePartitionEof { get; public set; }
    public Nullable`1<bool> CheckCrcs { get; public set; }
    public ConsumerConfig(ClientConfig config);
    public ConsumerConfig(IDictionary`2<string, string> config);
    public ConsumerConfig ThrowIfContainsNonUserConfigurable();
    public void set_ConsumeResultFields(string value);
    public Nullable`1<AutoOffsetReset> get_AutoOffsetReset();
    public void set_AutoOffsetReset(Nullable`1<AutoOffsetReset> value);
    public string get_GroupId();
    public void set_GroupId(string value);
    public string get_GroupInstanceId();
    public void set_GroupInstanceId(string value);
    public Nullable`1<PartitionAssignmentStrategy> get_PartitionAssignmentStrategy();
    public void set_PartitionAssignmentStrategy(Nullable`1<PartitionAssignmentStrategy> value);
    public Nullable`1<int> get_SessionTimeoutMs();
    public void set_SessionTimeoutMs(Nullable`1<int> value);
    public Nullable`1<int> get_HeartbeatIntervalMs();
    public void set_HeartbeatIntervalMs(Nullable`1<int> value);
    public string get_GroupProtocolType();
    public void set_GroupProtocolType(string value);
    public Nullable`1<GroupProtocol> get_GroupProtocol();
    public void set_GroupProtocol(Nullable`1<GroupProtocol> value);
    public string get_GroupRemoteAssignor();
    public void set_GroupRemoteAssignor(string value);
    public Nullable`1<int> get_CoordinatorQueryIntervalMs();
    public void set_CoordinatorQueryIntervalMs(Nullable`1<int> value);
    public Nullable`1<int> get_MaxPollIntervalMs();
    public void set_MaxPollIntervalMs(Nullable`1<int> value);
    public Nullable`1<bool> get_EnableAutoCommit();
    public void set_EnableAutoCommit(Nullable`1<bool> value);
    public Nullable`1<int> get_AutoCommitIntervalMs();
    public void set_AutoCommitIntervalMs(Nullable`1<int> value);
    public Nullable`1<bool> get_EnableAutoOffsetStore();
    public void set_EnableAutoOffsetStore(Nullable`1<bool> value);
    public Nullable`1<int> get_QueuedMinMessages();
    public void set_QueuedMinMessages(Nullable`1<int> value);
    public Nullable`1<int> get_QueuedMaxMessagesKbytes();
    public void set_QueuedMaxMessagesKbytes(Nullable`1<int> value);
    public Nullable`1<int> get_FetchWaitMaxMs();
    public void set_FetchWaitMaxMs(Nullable`1<int> value);
    public Nullable`1<int> get_FetchQueueBackoffMs();
    public void set_FetchQueueBackoffMs(Nullable`1<int> value);
    public Nullable`1<int> get_MaxPartitionFetchBytes();
    public void set_MaxPartitionFetchBytes(Nullable`1<int> value);
    public Nullable`1<int> get_FetchMaxBytes();
    public void set_FetchMaxBytes(Nullable`1<int> value);
    public Nullable`1<int> get_FetchMinBytes();
    public void set_FetchMinBytes(Nullable`1<int> value);
    public Nullable`1<int> get_FetchErrorBackoffMs();
    public void set_FetchErrorBackoffMs(Nullable`1<int> value);
    public Nullable`1<IsolationLevel> get_IsolationLevel();
    public void set_IsolationLevel(Nullable`1<IsolationLevel> value);
    public Nullable`1<bool> get_EnablePartitionEof();
    public void set_EnablePartitionEof(Nullable`1<bool> value);
    public Nullable`1<bool> get_CheckCrcs();
    public void set_CheckCrcs(Nullable`1<bool> value);
}
public class Confluent.Kafka.ConsumeResult`2 : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Partition <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LeaderEpoch>k__BackingField;
    [CompilerGeneratedAttribute]
private Message`2<TKey, TValue> <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPartitionEOF>k__BackingField;
    public string Topic { get; public set; }
    public Partition Partition { get; public set; }
    public Offset Offset { get; public set; }
    public Nullable`1<int> LeaderEpoch { get; public set; }
    public TopicPartition TopicPartition { get; }
    public TopicPartitionOffset TopicPartitionOffset { get; public set; }
    public Message`2<TKey, TValue> Message { get; public set; }
    [ObsoleteAttribute("Please access the message Key via .Message.Key.")]
public TKey Key { get; }
    [ObsoleteAttribute("Please access the message Value via .Message.Value.")]
public TValue Value { get; }
    [ObsoleteAttribute("Please access the message Timestamp via .Message.Timestamp.")]
public Timestamp Timestamp { get; }
    [ObsoleteAttribute("Please access the message Headers via .Message.Headers.")]
public Headers Headers { get; }
    public bool IsPartitionEOF { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
    [CompilerGeneratedAttribute]
public Partition get_Partition();
    [CompilerGeneratedAttribute]
public void set_Partition(Partition value);
    [CompilerGeneratedAttribute]
public Offset get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(Offset value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LeaderEpoch();
    [CompilerGeneratedAttribute]
public void set_LeaderEpoch(Nullable`1<int> value);
    public TopicPartition get_TopicPartition();
    public TopicPartitionOffset get_TopicPartitionOffset();
    public void set_TopicPartitionOffset(TopicPartitionOffset value);
    [CompilerGeneratedAttribute]
public Message`2<TKey, TValue> get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(Message`2<TKey, TValue> value);
    public TKey get_Key();
    public TValue get_Value();
    public Timestamp get_Timestamp();
    public Headers get_Headers();
    [CompilerGeneratedAttribute]
public bool get_IsPartitionEOF();
    [CompilerGeneratedAttribute]
public void set_IsPartitionEOF(bool value);
}
internal class Confluent.Kafka.ConsumerGroupMetadata : object {
    internal Byte[] serializedMetadata;
}
public enum Confluent.Kafka.ConsumerGroupState : Enum {
    public int value__;
    public static ConsumerGroupState Unknown;
    public static ConsumerGroupState PreparingRebalance;
    public static ConsumerGroupState CompletingRebalance;
    public static ConsumerGroupState Stable;
    public static ConsumerGroupState Dead;
    public static ConsumerGroupState Empty;
}
public class Confluent.Kafka.ConsumerGroupTopicPartitionOffsets : object {
    [CompilerGeneratedAttribute]
private List`1<TopicPartitionOffset> <TopicPartitionOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    public List`1<TopicPartitionOffset> TopicPartitionOffsets { get; }
    public string Group { get; }
    public ConsumerGroupTopicPartitionOffsets(string group, List`1<TopicPartitionOffset> topicPartitionOffsets);
    [CompilerGeneratedAttribute]
public List`1<TopicPartitionOffset> get_TopicPartitionOffsets();
    [CompilerGeneratedAttribute]
public string get_Group();
    public virtual string ToString();
}
public class Confluent.Kafka.ConsumerGroupTopicPartitions : object {
    [CompilerGeneratedAttribute]
private List`1<TopicPartition> <TopicPartitions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    public List`1<TopicPartition> TopicPartitions { get; }
    public string Group { get; }
    public ConsumerGroupTopicPartitions(string group, List`1<TopicPartition> topicPartitions);
    [CompilerGeneratedAttribute]
public List`1<TopicPartition> get_TopicPartitions();
    [CompilerGeneratedAttribute]
public string get_Group();
    public virtual string ToString();
}
public class Confluent.Kafka.DeliveryReport`2 : DeliveryResult`2<TKey, TValue> {
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public Error Error { get; public set; }
    public TopicPartitionOffsetError TopicPartitionOffsetError { get; public set; }
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    public TopicPartitionOffsetError get_TopicPartitionOffsetError();
    public void set_TopicPartitionOffsetError(TopicPartitionOffsetError value);
}
public class Confluent.Kafka.DeliveryResult`2 : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Partition <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private PersistenceStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Message`2<TKey, TValue> <Message>k__BackingField;
    public string Topic { get; public set; }
    public Partition Partition { get; public set; }
    public Offset Offset { get; public set; }
    public TopicPartition TopicPartition { get; }
    public TopicPartitionOffset TopicPartitionOffset { get; public set; }
    public PersistenceStatus Status { get; public set; }
    public Message`2<TKey, TValue> Message { get; public set; }
    public TKey Key { get; public set; }
    public TValue Value { get; public set; }
    public Timestamp Timestamp { get; public set; }
    public Headers Headers { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
    [CompilerGeneratedAttribute]
public Partition get_Partition();
    [CompilerGeneratedAttribute]
public void set_Partition(Partition value);
    [CompilerGeneratedAttribute]
public Offset get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(Offset value);
    public TopicPartition get_TopicPartition();
    public TopicPartitionOffset get_TopicPartitionOffset();
    public void set_TopicPartitionOffset(TopicPartitionOffset value);
    [CompilerGeneratedAttribute]
public PersistenceStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(PersistenceStatus value);
    [CompilerGeneratedAttribute]
public Message`2<TKey, TValue> get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(Message`2<TKey, TValue> value);
    public TKey get_Key();
    public void set_Key(TKey value);
    public TValue get_Value();
    public void set_Value(TValue value);
    public Timestamp get_Timestamp();
    public void set_Timestamp(Timestamp value);
    public Headers get_Headers();
    public void set_Headers(Headers value);
}
public class Confluent.Kafka.DependentAdminClientBuilder : object {
    [CompilerGeneratedAttribute]
private Handle <Handle>k__BackingField;
    public Handle Handle { get; public set; }
    public DependentAdminClientBuilder(Handle handle);
    [CompilerGeneratedAttribute]
public Handle get_Handle();
    [CompilerGeneratedAttribute]
public void set_Handle(Handle value);
    public virtual IAdminClient Build();
}
public class Confluent.Kafka.DependentProducerBuilder`2 : object {
    [CompilerGeneratedAttribute]
private Handle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializer`1<TKey> <KeySerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializer`1<TValue> <ValueSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IAsyncSerializer`1<TKey> <AsyncKeySerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IAsyncSerializer`1<TValue> <AsyncValueSerializer>k__BackingField;
    public Handle Handle { get; public set; }
    public ISerializer`1<TKey> KeySerializer { get; public set; }
    public ISerializer`1<TValue> ValueSerializer { get; public set; }
    public IAsyncSerializer`1<TKey> AsyncKeySerializer { get; public set; }
    public IAsyncSerializer`1<TValue> AsyncValueSerializer { get; public set; }
    public DependentProducerBuilder`2(Handle handle);
    [CompilerGeneratedAttribute]
public Handle get_Handle();
    [CompilerGeneratedAttribute]
public void set_Handle(Handle value);
    [CompilerGeneratedAttribute]
public ISerializer`1<TKey> get_KeySerializer();
    [CompilerGeneratedAttribute]
public void set_KeySerializer(ISerializer`1<TKey> value);
    [CompilerGeneratedAttribute]
public ISerializer`1<TValue> get_ValueSerializer();
    [CompilerGeneratedAttribute]
public void set_ValueSerializer(ISerializer`1<TValue> value);
    [CompilerGeneratedAttribute]
public IAsyncSerializer`1<TKey> get_AsyncKeySerializer();
    [CompilerGeneratedAttribute]
public void set_AsyncKeySerializer(IAsyncSerializer`1<TKey> value);
    [CompilerGeneratedAttribute]
public IAsyncSerializer`1<TValue> get_AsyncValueSerializer();
    [CompilerGeneratedAttribute]
public void set_AsyncValueSerializer(IAsyncSerializer`1<TValue> value);
    public DependentProducerBuilder`2<TKey, TValue> SetKeySerializer(ISerializer`1<TKey> serializer);
    public DependentProducerBuilder`2<TKey, TValue> SetValueSerializer(ISerializer`1<TValue> serializer);
    public DependentProducerBuilder`2<TKey, TValue> SetKeySerializer(IAsyncSerializer`1<TKey> serializer);
    public DependentProducerBuilder`2<TKey, TValue> SetValueSerializer(IAsyncSerializer`1<TValue> serializer);
    public virtual IProducer`2<TKey, TValue> Build();
}
public static class Confluent.Kafka.Deserializers : object {
    public static IDeserializer`1<string> Utf8;
    public static IDeserializer`1<Null> Null;
    public static IDeserializer`1<Ignore> Ignore;
    public static IDeserializer`1<long> Int64;
    public static IDeserializer`1<int> Int32;
    public static IDeserializer`1<float> Single;
    public static IDeserializer`1<double> Double;
    public static IDeserializer`1<Byte[]> ByteArray;
    private static Deserializers();
}
[ExtensionAttribute]
internal static class Confluent.Kafka.DictionaryExtensions : object {
    [ExtensionAttribute]
internal static String[] ToStringArray(IDictionary`2<string, string> dictionary);
}
public class Confluent.Kafka.Error : object {
    [CompilerGeneratedAttribute]
private ErrorCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFatal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetriable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TxnRequiresAbort>k__BackingField;
    private string reason;
    public ErrorCode Code { get; }
    public bool IsFatal { get; }
    internal bool IsRetriable { get; }
    internal bool TxnRequiresAbort { get; }
    public string Reason { get; }
    public bool IsError { get; }
    public bool IsLocalError { get; }
    public bool IsBrokerError { get; }
    public Error(Error error);
    internal Error(IntPtr error);
    internal Error(IntPtr error, bool destroy);
    public Error(ErrorCode code);
    public Error(ErrorCode code, string reason, bool isFatal);
    public Error(ErrorCode code, string reason);
    [CompilerGeneratedAttribute]
public ErrorCode get_Code();
    [CompilerGeneratedAttribute]
public bool get_IsFatal();
    [CompilerGeneratedAttribute]
internal bool get_IsRetriable();
    [CompilerGeneratedAttribute]
internal bool get_TxnRequiresAbort();
    public string get_Reason();
    public bool get_IsError();
    public bool get_IsLocalError();
    public bool get_IsBrokerError();
    public static ErrorCode op_Implicit(Error e);
    public static Error op_Implicit(ErrorCode c);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Error a, Error b);
    public static bool op_Inequality(Error a, Error b);
    public virtual string ToString();
}
public enum Confluent.Kafka.ErrorCode : Enum {
    public int value__;
    public static ErrorCode Local_BadMsg;
    public static ErrorCode Local_BadCompression;
    public static ErrorCode Local_Destroy;
    public static ErrorCode Local_Fail;
    public static ErrorCode Local_Transport;
    public static ErrorCode Local_CritSysResource;
    public static ErrorCode Local_Resolve;
    public static ErrorCode Local_MsgTimedOut;
    public static ErrorCode Local_PartitionEOF;
    public static ErrorCode Local_UnknownPartition;
    public static ErrorCode Local_FS;
    public static ErrorCode Local_UnknownTopic;
    public static ErrorCode Local_AllBrokersDown;
    public static ErrorCode Local_InvalidArg;
    public static ErrorCode Local_TimedOut;
    public static ErrorCode Local_QueueFull;
    public static ErrorCode Local_IsrInsuff;
    public static ErrorCode Local_NodeUpdate;
    public static ErrorCode Local_Ssl;
    public static ErrorCode Local_WaitCoord;
    public static ErrorCode Local_UnknownGroup;
    public static ErrorCode Local_InProgress;
    public static ErrorCode Local_PrevInProgress;
    public static ErrorCode Local_ExistingSubscription;
    public static ErrorCode Local_AssignPartitions;
    public static ErrorCode Local_RevokePartitions;
    public static ErrorCode Local_Conflict;
    public static ErrorCode Local_State;
    public static ErrorCode Local_UnknownProtocol;
    public static ErrorCode Local_NotImplemented;
    public static ErrorCode Local_Authentication;
    public static ErrorCode Local_NoOffset;
    public static ErrorCode Local_Outdated;
    public static ErrorCode Local_TimedOutQueue;
    public static ErrorCode Local_UnsupportedFeature;
    public static ErrorCode Local_WaitCache;
    public static ErrorCode Local_Intr;
    public static ErrorCode Local_KeySerialization;
    public static ErrorCode Local_ValueSerialization;
    public static ErrorCode Local_KeyDeserialization;
    public static ErrorCode Local_ValueDeserialization;
    public static ErrorCode Local_Partial;
    public static ErrorCode Local_ReadOnly;
    public static ErrorCode Local_NoEnt;
    public static ErrorCode Local_Underflow;
    public static ErrorCode Local_InvalidType;
    public static ErrorCode Local_Retry;
    public static ErrorCode Local_PurgeQueue;
    public static ErrorCode Local_PurgeInflight;
    public static ErrorCode Local_Fatal;
    public static ErrorCode Local_Inconsistent;
    public static ErrorCode Local_GaplessGuarantee;
    public static ErrorCode Local_MaxPollExceeded;
    public static ErrorCode Local_UnknownBroker;
    public static ErrorCode Local_NotConfigured;
    public static ErrorCode Local_Fenced;
    public static ErrorCode Local_Application;
    public static ErrorCode Local_AssignmentLost;
    public static ErrorCode Local_Noop;
    public static ErrorCode Local_AutoOffsetReset;
    public static ErrorCode Local_LogTruncation;
    public static ErrorCode Local_InvalidDifferentRecord;
    public static ErrorCode Unknown;
    public static ErrorCode NoError;
    public static ErrorCode OffsetOutOfRange;
    public static ErrorCode InvalidMsg;
    public static ErrorCode UnknownTopicOrPart;
    public static ErrorCode InvalidMsgSize;
    public static ErrorCode LeaderNotAvailable;
    public static ErrorCode NotLeaderForPartition;
    public static ErrorCode RequestTimedOut;
    public static ErrorCode BrokerNotAvailable;
    public static ErrorCode ReplicaNotAvailable;
    public static ErrorCode MsgSizeTooLarge;
    public static ErrorCode StaleCtrlEpoch;
    public static ErrorCode OffsetMetadataTooLarge;
    public static ErrorCode NetworkException;
    [ObsoleteAttribute("Superseded by GroupLoadInProgress")]
public static ErrorCode GroupLoadInProress;
    public static ErrorCode GroupLoadInProgress;
    public static ErrorCode GroupCoordinatorNotAvailable;
    public static ErrorCode NotCoordinatorForGroup;
    public static ErrorCode TopicException;
    public static ErrorCode RecordListTooLarge;
    public static ErrorCode NotEnoughReplicas;
    public static ErrorCode NotEnoughReplicasAfterAppend;
    public static ErrorCode InvalidRequiredAcks;
    public static ErrorCode IllegalGeneration;
    public static ErrorCode InconsistentGroupProtocol;
    public static ErrorCode InvalidGroupId;
    public static ErrorCode UnknownMemberId;
    public static ErrorCode InvalidSessionTimeout;
    public static ErrorCode RebalanceInProgress;
    public static ErrorCode InvalidCommitOffsetSize;
    public static ErrorCode TopicAuthorizationFailed;
    public static ErrorCode GroupAuthorizationFailed;
    public static ErrorCode ClusterAuthorizationFailed;
    public static ErrorCode InvalidTimestamp;
    public static ErrorCode UnsupportedSaslMechanism;
    public static ErrorCode IllegalSaslState;
    public static ErrorCode UnsupportedVersion;
    public static ErrorCode TopicAlreadyExists;
    public static ErrorCode InvalidPartitions;
    public static ErrorCode InvalidReplicationFactor;
    public static ErrorCode InvalidReplicaAssignment;
    public static ErrorCode InvalidConfig;
    public static ErrorCode NotController;
    public static ErrorCode InvalidRequest;
    public static ErrorCode UnsupportedForMessageFormat;
    public static ErrorCode PolicyViolation;
    public static ErrorCode OutOfOrderSequenceNumber;
    public static ErrorCode DuplicateSequenceNumber;
    public static ErrorCode InvalidProducerEpoch;
    public static ErrorCode InvalidTxnState;
    public static ErrorCode InvalidProducerIdMapping;
    public static ErrorCode InvalidTransactionTimeout;
    public static ErrorCode ConcurrentTransactions;
    public static ErrorCode TransactionCoordinatorFenced;
    public static ErrorCode TransactionalIdAuthorizationFailed;
    public static ErrorCode SecurityDisabled;
    public static ErrorCode OperationNotAttempted;
    public static ErrorCode KafkaStorageError;
    public static ErrorCode LogDirNotFound;
    public static ErrorCode SaslAuthenticationFailed;
    public static ErrorCode UnknownProducerId;
    public static ErrorCode ReassignmentInProgress;
    public static ErrorCode DelegationTokenAuthDisabled;
    public static ErrorCode DelegationTokenNotFound;
    public static ErrorCode DelegationTokenOwnerMismatch;
    public static ErrorCode DelegationTokenRequestNotAllowed;
    public static ErrorCode DelegationTokenAuthorizationFailed;
    public static ErrorCode DelegationTokenExpired;
    public static ErrorCode InvalidPrincipalType;
    public static ErrorCode NonEmptyGroup;
    public static ErrorCode GroupIdNotFound;
    public static ErrorCode FetchSessionIdNotFound;
    public static ErrorCode InvalidFetchSessionEpoch;
    public static ErrorCode ListenerNotFound;
    public static ErrorCode TopicDeletionDisabled;
    public static ErrorCode FencedLeaderEpoch;
    public static ErrorCode UnknownLeaderEpoch;
    public static ErrorCode UnsupportedCompressionType;
    public static ErrorCode StaleBrokerEpoch;
    public static ErrorCode OffsetNotAvailable;
    public static ErrorCode MemberIdRequired;
    public static ErrorCode PreferredLeaderNotAvailable;
    public static ErrorCode GroupMaxSizeReached;
    public static ErrorCode FencedInstanceId;
    public static ErrorCode EligibleLeadersNotAvailable;
    public static ErrorCode ElectionNotNeeded;
    public static ErrorCode NoReassignmentInProgress;
    public static ErrorCode GroupSubscribedToTopic;
    public static ErrorCode InvalidRecord;
    public static ErrorCode UnstableOffsetCommit;
    public static ErrorCode ThrottlingQuotaExceeded;
    public static ErrorCode ProducerFenced;
    public static ErrorCode ResourceNotFound;
    public static ErrorCode DuplicateResource;
    public static ErrorCode UnacceptableCredential;
    public static ErrorCode InconsistentVoterSet;
    public static ErrorCode InvalidUpdateVersion;
    public static ErrorCode FeatureUpdateFailed;
    public static ErrorCode PrincipalDeserializationFailure;
    public static ErrorCode UnknownTopicId;
    public static ErrorCode FencedMemberEpoch;
    public static ErrorCode UnreleasedInstanceId;
    public static ErrorCode UnsupportedAssignor;
    public static ErrorCode StaleMemberEpoch;
    public static ErrorCode UnknownSubscriptionId;
    public static ErrorCode TelemetryTooLarge;
}
[ExtensionAttribute]
public static class Confluent.Kafka.ErrorCodeExtensions : object {
    [ExtensionAttribute]
public static string GetReason(ErrorCode code);
}
public class Confluent.Kafka.GroupInfo : object {
    [CompilerGeneratedAttribute]
private BrokerMetadata <Broker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <State>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProtocolType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<GroupMemberInfo> <Members>k__BackingField;
    public BrokerMetadata Broker { get; }
    public string Group { get; }
    public Error Error { get; }
    public string State { get; }
    public string ProtocolType { get; }
    public string Protocol { get; }
    public List`1<GroupMemberInfo> Members { get; }
    public GroupInfo(BrokerMetadata broker, string group, Error error, string state, string protocolType, string protocol, List`1<GroupMemberInfo> members);
    [CompilerGeneratedAttribute]
public BrokerMetadata get_Broker();
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public string get_ProtocolType();
    [CompilerGeneratedAttribute]
public string get_Protocol();
    [CompilerGeneratedAttribute]
public List`1<GroupMemberInfo> get_Members();
}
public class Confluent.Kafka.GroupMemberInfo : object {
    [CompilerGeneratedAttribute]
private string <MemberId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientHost>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <MemberMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <MemberAssignment>k__BackingField;
    public string MemberId { get; }
    public string ClientId { get; }
    public string ClientHost { get; }
    public Byte[] MemberMetadata { get; }
    public Byte[] MemberAssignment { get; }
    public GroupMemberInfo(string memberId, string clientId, string clientHost, Byte[] memberMetadata, Byte[] memberAssignment);
    [CompilerGeneratedAttribute]
public string get_MemberId();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public string get_ClientHost();
    [CompilerGeneratedAttribute]
public Byte[] get_MemberMetadata();
    [CompilerGeneratedAttribute]
public Byte[] get_MemberAssignment();
}
public enum Confluent.Kafka.GroupProtocol : Enum {
    public int value__;
    public static GroupProtocol Classic;
    public static GroupProtocol Consumer;
}
public class Confluent.Kafka.Handle : object {
    [CompilerGeneratedAttribute]
private IClient <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeKafkaHandle <LibrdkafkaHandle>k__BackingField;
    public bool IsInvalid { get; }
    internal IClient Owner { get; internal set; }
    internal SafeKafkaHandle LibrdkafkaHandle { get; internal set; }
    public bool get_IsInvalid();
    [CompilerGeneratedAttribute]
internal IClient get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(IClient value);
    [CompilerGeneratedAttribute]
internal SafeKafkaHandle get_LibrdkafkaHandle();
    [CompilerGeneratedAttribute]
internal void set_LibrdkafkaHandle(SafeKafkaHandle value);
}
public class Confluent.Kafka.Header : object {
    private Byte[] val;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; private set; }
    public Header(string key, Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    public sealed virtual Byte[] GetValueBytes();
}
[DefaultMemberAttribute("Item")]
public class Confluent.Kafka.Headers : object {
    private List`1<IHeader> headers;
    public IReadOnlyList`1<IHeader> BackingList { get; }
    public IHeader Item { get; }
    public int Count { get; }
    public IReadOnlyList`1<IHeader> get_BackingList();
    public void Add(string key, Byte[] val);
    public void Add(Header header);
    public Byte[] GetLastBytes(string key);
    public bool TryGetLastBytes(string key, Byte[]& lastHeader);
    public void Remove(string key);
    public sealed virtual IEnumerator`1<IHeader> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IHeader get_Item(int index);
    public int get_Count();
}
public interface Confluent.Kafka.IAdminClient {
    public abstract virtual List`1<GroupInfo> ListGroups(TimeSpan timeout);
    public abstract virtual GroupInfo ListGroup(string group, TimeSpan timeout);
    public abstract virtual Metadata GetMetadata(string topic, TimeSpan timeout);
    public abstract virtual Metadata GetMetadata(TimeSpan timeout);
    public abstract virtual Task CreatePartitionsAsync(IEnumerable`1<PartitionsSpecification> partitionsSpecifications, CreatePartitionsOptions options);
    public abstract virtual Task DeleteGroupsAsync(IList`1<string> groups, DeleteGroupsOptions options);
    public abstract virtual Task DeleteTopicsAsync(IEnumerable`1<string> topics, DeleteTopicsOptions options);
    public abstract virtual Task CreateTopicsAsync(IEnumerable`1<TopicSpecification> topics, CreateTopicsOptions options);
    public abstract virtual Task AlterConfigsAsync(Dictionary`2<ConfigResource, List`1<ConfigEntry>> configs, AlterConfigsOptions options);
    public abstract virtual Task`1<List`1<IncrementalAlterConfigsResult>> IncrementalAlterConfigsAsync(Dictionary`2<ConfigResource, List`1<ConfigEntry>> configs, IncrementalAlterConfigsOptions options);
    public abstract virtual Task`1<List`1<DescribeConfigsResult>> DescribeConfigsAsync(IEnumerable`1<ConfigResource> resources, DescribeConfigsOptions options);
    public abstract virtual Task`1<List`1<DeleteRecordsResult>> DeleteRecordsAsync(IEnumerable`1<TopicPartitionOffset> topicPartitionOffsets, DeleteRecordsOptions options);
    public abstract virtual Task CreateAclsAsync(IEnumerable`1<AclBinding> aclBindings, CreateAclsOptions options);
    public abstract virtual Task`1<DescribeAclsResult> DescribeAclsAsync(AclBindingFilter aclBindingFilter, DescribeAclsOptions options);
    public abstract virtual Task`1<List`1<DeleteAclsResult>> DeleteAclsAsync(IEnumerable`1<AclBindingFilter> aclBindingFilters, DeleteAclsOptions options);
    public abstract virtual Task`1<DeleteConsumerGroupOffsetsResult> DeleteConsumerGroupOffsetsAsync(string group, IEnumerable`1<TopicPartition> partitions, DeleteConsumerGroupOffsetsOptions options);
    public abstract virtual Task`1<List`1<AlterConsumerGroupOffsetsResult>> AlterConsumerGroupOffsetsAsync(IEnumerable`1<ConsumerGroupTopicPartitionOffsets> groupPartitions, AlterConsumerGroupOffsetsOptions options);
    public abstract virtual Task`1<List`1<ListConsumerGroupOffsetsResult>> ListConsumerGroupOffsetsAsync(IEnumerable`1<ConsumerGroupTopicPartitions> groupPartitions, ListConsumerGroupOffsetsOptions options);
    public abstract virtual Task`1<ListConsumerGroupsResult> ListConsumerGroupsAsync(ListConsumerGroupsOptions options);
    public abstract virtual Task`1<DescribeConsumerGroupsResult> DescribeConsumerGroupsAsync(IEnumerable`1<string> groups, DescribeConsumerGroupsOptions options);
    public abstract virtual Task`1<DescribeUserScramCredentialsResult> DescribeUserScramCredentialsAsync(IEnumerable`1<string> users, DescribeUserScramCredentialsOptions options);
    public abstract virtual Task AlterUserScramCredentialsAsync(IEnumerable`1<UserScramCredentialAlteration> alterations, AlterUserScramCredentialsOptions options);
}
[ExtensionAttribute]
public static class Confluent.Kafka.IAdminClientExtensions : object {
    [ExtensionAttribute]
public static Task`1<DescribeTopicsResult> DescribeTopicsAsync(IAdminClient adminClient, TopicCollection topicCollection, DescribeTopicsOptions options);
    [ExtensionAttribute]
public static Task`1<DescribeClusterResult> DescribeClusterAsync(IAdminClient adminClient, DescribeClusterOptions options);
    [ExtensionAttribute]
public static Task`1<ListOffsetsResult> ListOffsetsAsync(IAdminClient adminClient, IEnumerable`1<TopicPartitionOffsetSpec> topicPartitionOffsets, ListOffsetsOptions options);
}
public interface Confluent.Kafka.IAsyncDeserializer`1 {
    public abstract virtual Task`1<T> DeserializeAsync(ReadOnlyMemory`1<byte> data, bool isNull, SerializationContext context);
}
public interface Confluent.Kafka.IAsyncSerializer`1 {
    public abstract virtual Task`1<Byte[]> SerializeAsync(T data, SerializationContext context);
}
public interface Confluent.Kafka.IClient {
    public Handle Handle { get; }
    public string Name { get; }
    public abstract virtual Handle get_Handle();
    public abstract virtual string get_Name();
    public abstract virtual int AddBrokers(string brokers);
    public abstract virtual void SetSaslCredentials(string username, string password);
}
public interface Confluent.Kafka.IConsumer`2 {
    public string MemberId { get; }
    public List`1<TopicPartition> Assignment { get; }
    public List`1<string> Subscription { get; }
    public IConsumerGroupMetadata ConsumerGroupMetadata { get; }
    public abstract virtual ConsumeResult`2<TKey, TValue> Consume(int millisecondsTimeout);
    public abstract virtual ConsumeResult`2<TKey, TValue> Consume(CancellationToken cancellationToken);
    public abstract virtual ConsumeResult`2<TKey, TValue> Consume(TimeSpan timeout);
    public abstract virtual string get_MemberId();
    public abstract virtual List`1<TopicPartition> get_Assignment();
    public abstract virtual List`1<string> get_Subscription();
    public abstract virtual void Subscribe(IEnumerable`1<string> topics);
    public abstract virtual void Subscribe(string topic);
    public abstract virtual void Unsubscribe();
    public abstract virtual void Assign(TopicPartition partition);
    public abstract virtual void Assign(TopicPartitionOffset partition);
    public abstract virtual void Assign(IEnumerable`1<TopicPartitionOffset> partitions);
    public abstract virtual void Assign(IEnumerable`1<TopicPartition> partitions);
    public abstract virtual void IncrementalAssign(IEnumerable`1<TopicPartitionOffset> partitions);
    public abstract virtual void IncrementalAssign(IEnumerable`1<TopicPartition> partitions);
    public abstract virtual void IncrementalUnassign(IEnumerable`1<TopicPartition> partitions);
    public abstract virtual void Unassign();
    public abstract virtual void StoreOffset(ConsumeResult`2<TKey, TValue> result);
    public abstract virtual void StoreOffset(TopicPartitionOffset offset);
    public abstract virtual List`1<TopicPartitionOffset> Commit();
    public abstract virtual void Commit(IEnumerable`1<TopicPartitionOffset> offsets);
    public abstract virtual void Commit(ConsumeResult`2<TKey, TValue> result);
    public abstract virtual void Seek(TopicPartitionOffset tpo);
    public abstract virtual void Pause(IEnumerable`1<TopicPartition> partitions);
    public abstract virtual void Resume(IEnumerable`1<TopicPartition> partitions);
    public abstract virtual List`1<TopicPartitionOffset> Committed(TimeSpan timeout);
    public abstract virtual List`1<TopicPartitionOffset> Committed(IEnumerable`1<TopicPartition> partitions, TimeSpan timeout);
    public abstract virtual Offset Position(TopicPartition partition);
    public abstract virtual List`1<TopicPartitionOffset> OffsetsForTimes(IEnumerable`1<TopicPartitionTimestamp> timestampsToSearch, TimeSpan timeout);
    public abstract virtual WatermarkOffsets GetWatermarkOffsets(TopicPartition topicPartition);
    public abstract virtual WatermarkOffsets QueryWatermarkOffsets(TopicPartition topicPartition, TimeSpan timeout);
    public abstract virtual void Close();
    public abstract virtual IConsumerGroupMetadata get_ConsumerGroupMetadata();
}
[ExtensionAttribute]
public static class Confluent.Kafka.IConsumerExtensions : object {
    [ExtensionAttribute]
public static TopicPartitionOffset PositionTopicPartitionOffset(IConsumer`2<TKey, TValue> consumer, TopicPartition partition);
}
public interface Confluent.Kafka.IConsumerGroupMetadata {
}
internal interface Confluent.Kafka.IDeliveryHandler {
    public abstract virtual void HandleDeliveryReport(DeliveryReport`2<Null, Null> deliveryReport);
}
public interface Confluent.Kafka.IDeserializer`1 {
    public abstract virtual T Deserialize(ReadOnlySpan`1<byte> data, bool isNull, SerializationContext context);
}
public class Confluent.Kafka.Ignore : object {
}
public interface Confluent.Kafka.IHeader {
    public string Key { get; }
    public abstract virtual string get_Key();
    public abstract virtual Byte[] GetValueBytes();
}
internal enum Confluent.Kafka.Impl.ConfRes : Enum {
    public int value__;
    public static ConfRes Unknown;
    public static ConfRes Invalid;
    public static ConfRes Ok;
}
internal static class Confluent.Kafka.Impl.Librdkafka : object {
    private static int RTLD_NOW;
    private static long minVersion;
    internal static int MaxErrorStringLength;
    private static object loadLockObj;
    private static bool isInitialized;
    private static Func`1<IntPtr> _version;
    private static Func`1<IntPtr> _version_str;
    private static Func`1<IntPtr> _get_debug_contexts;
    private static Func`2<ErrorCode, IntPtr> _err2str;
    private static Func`2<IntPtr, IntPtr> _topic_partition_list_new;
    private static Action`1<IntPtr> _topic_partition_list_destroy;
    private static Func`4<IntPtr, string, int, IntPtr> _topic_partition_list_add;
    private static Func`2<IntPtr, IntPtr> _headers_new;
    private static Action`1<IntPtr> _headers_destroy;
    private static Func`6<IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, ErrorCode> _header_add;
    private static headerGetAllDelegate _header_get_all;
    private static Func`1<ErrorCode> _last_error;
    private static Func`4<IntPtr, StringBuilder, UIntPtr, ErrorCode> _fatal_error;
    private static Func`2<IntPtr, IntPtr> _message_errstr;
    private static messageTimestampDelegate _message_timestamp;
    private static Func`2<IntPtr, PersistenceStatus> _message_status;
    private static messageHeadersDelegate _message_headers;
    private static messageLeaderEpoch _message_leader_epoch;
    private static Action`1<IntPtr> _message_destroy;
    private static Func`1<SafeConfigHandle> _conf_new;
    private static Action`1<IntPtr> _conf_destroy;
    private static Func`2<IntPtr, IntPtr> _conf_dup;
    private static Func`6<IntPtr, string, string, StringBuilder, UIntPtr, ConfRes> _conf_set;
    private static Action`2<IntPtr, DeliveryReportDelegate> _conf_set_dr_msg_cb;
    private static Action`2<IntPtr, RebalanceDelegate> _conf_set_rebalance_cb;
    private static Action`2<IntPtr, CommitDelegate> _conf_set_offset_commit_cb;
    private static Action`2<IntPtr, ErrorDelegate> _conf_set_error_cb;
    private static Action`2<IntPtr, LogDelegate> _conf_set_log_cb;
    private static Action`2<IntPtr, StatsDelegate> _conf_set_stats_cb;
    private static Action`2<IntPtr, OAuthBearerTokenRefreshDelegate> _conf_set_oauthbearer_token_refresh_cb;
    private static Func`9<IntPtr, string, long, string, String[], UIntPtr, StringBuilder, UIntPtr, ErrorCode> _oauthbearer_set_token;
    private static Func`3<IntPtr, string, ErrorCode> _oauthbearer_set_token_failure;
    private static Action`2<IntPtr, IntPtr> _conf_set_default_topic_conf;
    private static Func`2<SafeConfigHandle, SafeTopicConfigHandle> _conf_get_default_topic_conf;
    private static ConfGet _conf_get;
    private static ConfGet _topic_conf_get;
    private static ConfDump _conf_dump;
    private static ConfDump _topic_conf_dump;
    private static Action`2<IntPtr, UIntPtr> _conf_dump_free;
    private static Func`1<SafeTopicConfigHandle> _topic_conf_new;
    private static Func`2<SafeTopicConfigHandle, SafeTopicConfigHandle> _topic_conf_dup;
    private static Func`2<SafeKafkaHandle, SafeTopicConfigHandle> _default_topic_conf_dup;
    private static Action`1<IntPtr> _topic_conf_destroy;
    private static Func`6<IntPtr, string, string, StringBuilder, UIntPtr, ConfRes> _topic_conf_set;
    private static Action`2<IntPtr, IntPtr> _topic_conf_set_opaque;
    private static Action`2<IntPtr, PartitionerDelegate> _topic_conf_set_partitioner_cb;
    private static Func`3<IntPtr, int, bool> _topic_partition_available;
    private static Func`2<IntPtr, int> _topic_partition_get_leader_epoch;
    private static Action`2<IntPtr, int> _topic_partition_set_leader_epoch;
    private static Func`3<IntPtr, IntPtr, IntPtr> _init_transactions;
    private static Func`2<IntPtr, IntPtr> _begin_transaction;
    private static Func`3<IntPtr, IntPtr, IntPtr> _commit_transaction;
    private static Func`3<IntPtr, IntPtr, IntPtr> _abort_transaction;
    private static Func`5<IntPtr, IntPtr, IntPtr, IntPtr, IntPtr> _send_offsets_to_transaction;
    private static Func`2<IntPtr, IntPtr> _rd_kafka_consumer_group_metadata;
    private static Action`1<IntPtr> _rd_kafka_consumer_group_metadata_destroy;
    private static ConsumerGroupMetadataWriteDelegate _rd_kafka_consumer_group_metadata_write;
    private static ConsumerGroupMetadataReadDelegate _rd_kafka_consumer_group_metadata_read;
    private static Func`5<RdKafkaType, IntPtr, StringBuilder, UIntPtr, SafeKafkaHandle> _new;
    private static Action`1<IntPtr> _destroy;
    private static Action`2<IntPtr, IntPtr> _destroy_flags;
    private static Func`2<IntPtr, IntPtr> _name;
    private static Func`2<IntPtr, IntPtr> _memberid;
    private static Func`3<long, long, IntPtr> _Uuid_new;
    private static Func`2<IntPtr, IntPtr> _Uuid_base64str;
    private static Func`2<IntPtr, long> _Uuid_most_significant_bits;
    private static Func`2<IntPtr, long> _Uuid_least_significant_bits;
    private static Action`1<IntPtr> _Uuid_destroy;
    private static Func`4<IntPtr, IntPtr, IntPtr, SafeTopicHandle> _topic_new;
    private static Action`1<IntPtr> _topic_destroy;
    private static Func`2<IntPtr, IntPtr> _topic_name;
    private static Func`2<IntPtr, ErrorCode> _poll_set_consumer;
    private static Func`3<IntPtr, IntPtr, IntPtr> _poll;
    private static QueryOffsets _query_watermark_offsets;
    private static GetOffsets _get_watermark_offsets;
    private static OffsetsForTimes _offsets_for_times;
    private static Action`2<IntPtr, IntPtr> _mem_free;
    private static Func`3<IntPtr, IntPtr, ErrorCode> _subscribe;
    private static Func`2<IntPtr, ErrorCode> _unsubscribe;
    private static Subscription _subscription;
    private static Func`3<IntPtr, IntPtr, IntPtr> _consumer_poll;
    private static Func`2<IntPtr, ErrorCode> _consumer_close;
    private static Func`3<IntPtr, IntPtr, ErrorCode> _assign;
    private static Func`3<IntPtr, IntPtr, IntPtr> _incremental_assign;
    private static Func`3<IntPtr, IntPtr, IntPtr> _incremental_unassign;
    private static Func`2<IntPtr, IntPtr> _assignment_lost;
    private static Func`2<IntPtr, IntPtr> _rebalance_protocol;
    private static Assignment _assignment;
    private static Func`3<IntPtr, IntPtr, ErrorCode> _offsets_store;
    private static Func`4<IntPtr, IntPtr, bool, ErrorCode> _commit;
    private static Func`6<IntPtr, IntPtr, IntPtr, CommitDelegate, IntPtr, ErrorCode> _commit_queue;
    private static Func`3<IntPtr, IntPtr, ErrorCode> _pause_partitions;
    private static Func`3<IntPtr, IntPtr, ErrorCode> _resume_partitions;
    private static Func`5<IntPtr, int, long, IntPtr, ErrorCode> _seek;
    private static Func`4<IntPtr, IntPtr, IntPtr, IntPtr> _seek_partitions;
    private static Func`4<IntPtr, IntPtr, IntPtr, ErrorCode> _committed;
    private static Func`3<IntPtr, IntPtr, ErrorCode> _position;
    private static Produceva _produceva;
    private static Flush _flush;
    private static Metadata _metadata;
    private static Action`1<IntPtr> _metadata_destroy;
    private static ListGroups _list_groups;
    private static Action`1<IntPtr> _group_list_destroy;
    private static Func`3<IntPtr, string, IntPtr> _brokers_add;
    private static _sasl_set_credentials_delegate _sasl_set_credentials;
    private static Func`2<IntPtr, int> _outq_len;
    private static Func`3<IntPtr, AdminOp, IntPtr> _AdminOptions_new;
    private static Action`1<IntPtr> _AdminOptions_destroy;
    private static Func`5<IntPtr, IntPtr, StringBuilder, UIntPtr, ErrorCode> _AdminOptions_set_request_timeout;
    private static Func`5<IntPtr, IntPtr, StringBuilder, UIntPtr, ErrorCode> _AdminOptions_set_operation_timeout;
    private static Func`5<IntPtr, IntPtr, StringBuilder, UIntPtr, ErrorCode> _AdminOptions_set_validate_only;
    private static Func`5<IntPtr, IntPtr, StringBuilder, UIntPtr, ErrorCode> _AdminOptions_set_incremental;
    private static Func`5<IntPtr, int, StringBuilder, UIntPtr, ErrorCode> _AdminOptions_set_broker;
    private static Action`2<IntPtr, IntPtr> _AdminOptions_set_opaque;
    private static Func`3<IntPtr, IntPtr, IntPtr> _AdminOptions_set_require_stable_offsets;
    private static Func`3<IntPtr, IntPtr, IntPtr> _AdminOptions_set_include_authorized_operations;
    private static Func`4<IntPtr, ConsumerGroupState[], UIntPtr, IntPtr> _AdminOptions_set_match_consumer_group_states;
    private static Func`3<IntPtr, IntPtr, IntPtr> _AdminOptions_set_isolation_level;
    private static Func`6<string, IntPtr, IntPtr, StringBuilder, UIntPtr, IntPtr> _NewTopic_new;
    private static Action`1<IntPtr> _NewTopic_destroy;
    private static Func`7<IntPtr, int, Int32[], UIntPtr, StringBuilder, UIntPtr, ErrorCode> _NewTopic_set_replica_assignment;
    private static Func`4<IntPtr, string, string, ErrorCode> _NewTopic_set_config;
    private static Action`5<IntPtr, IntPtr[], UIntPtr, IntPtr, IntPtr> _CreateTopics;
    private static _CreateTopics_result_topics_delegate _CreateTopics_result_topics;
    private static Func`2<string, IntPtr> _DeleteTopic_new;
    private static Action`1<IntPtr> _DeleteTopic_destroy;
    private static Action`5<IntPtr, IntPtr[], UIntPtr, IntPtr, IntPtr> _DeleteTopics;
    private static _DeleteTopics_result_topics_delegate _DeleteTopics_result_topics;
    private static Func`2<string, IntPtr> _DeleteGroup_new;
    private static Action`1<IntPtr> _DeleteGroup_destroy;
    private static Action`5<IntPtr, IntPtr[], UIntPtr, IntPtr, IntPtr> _DeleteGroups;
    private static _DeleteGroups_result_groups_delegate _DeleteGroups_result_groups;
    private static Func`5<string, UIntPtr, StringBuilder, UIntPtr, IntPtr> _NewPartitions_new;
    private static Action`1<IntPtr> _NewPartitions_destroy;
    private static Func`7<IntPtr, int, Int32[], UIntPtr, StringBuilder, UIntPtr, ErrorCode> _NewPartitions_set_replica_assignment;
    private static Action`5<IntPtr, IntPtr[], UIntPtr, IntPtr, IntPtr> _CreatePartitions;
    private static _CreatePartitions_result_topics_delegate _CreatePartitions_result_topics;
    private static Func`2<ConfigSource, IntPtr> _ConfigSource_name;
    private static Func`2<IntPtr, IntPtr> _ConfigEntry_name;
    private static Func`2<IntPtr, IntPtr> _ConfigEntry_value;
    private static Func`2<IntPtr, ConfigSource> _ConfigEntry_source;
    private static Func`2<IntPtr, IntPtr> _ConfigEntry_is_read_only;
    private static Func`2<IntPtr, IntPtr> _ConfigEntry_is_default;
    private static Func`2<IntPtr, IntPtr> _ConfigEntry_is_sensitive;
    private static Func`2<IntPtr, IntPtr> _ConfigEntry_is_synonym;
    private static _ConfigEntry_synonyms_delegate _ConfigEntry_synonyms;
    private static Func`2<ResourceType, IntPtr> _ResourceType_name;
    private static Func`3<ResourceType, string, IntPtr> _ConfigResource_new;
    private static Action`1<IntPtr> _ConfigResource_destroy;
    private static Func`4<IntPtr, string, string, ErrorCode> _ConfigResource_add_config;
    private static Func`4<IntPtr, string, string, ErrorCode> _ConfigResource_set_config;
    private static Func`3<IntPtr, string, ErrorCode> _ConfigResource_delete_config;
    private static Func`5<IntPtr, string, AlterConfigOpType, string, IntPtr> _ConfigResource_add_incremental_config;
    private static _ConfigResource_configs_delegate _ConfigResource_configs;
    private static Func`2<IntPtr, ResourceType> _ConfigResource_type;
    private static Func`2<IntPtr, IntPtr> _ConfigResource_name;
    private static Func`2<IntPtr, ErrorCode> _ConfigResource_error;
    private static Func`2<IntPtr, IntPtr> _ConfigResource_error_string;
    private static Action`5<IntPtr, IntPtr[], UIntPtr, IntPtr, IntPtr> _AlterConfigs;
    private static _AlterConfigs_result_resources_delegate _AlterConfigs_result_resources;
    private static Action`5<IntPtr, IntPtr[], UIntPtr, IntPtr, IntPtr> _IncrementalAlterConfigs;
    private static _IncrementalAlterConfigs_result_resources_delegate _IncrementalAlterConfigs_result_resources;
    private static Action`5<IntPtr, IntPtr[], UIntPtr, IntPtr, IntPtr> _DescribeConfigs;
    private static _DescribeConfigs_result_resources_delegate _DescribeConfigs_result_resources;
    private static Func`2<IntPtr, IntPtr> _DeleteRecords_new;
    private static Action`1<IntPtr> _DeleteRecords_destroy;
    private static Action`5<IntPtr, IntPtr[], UIntPtr, IntPtr, IntPtr> _DeleteRecords;
    private static Func`2<IntPtr, IntPtr> _DeleteRecords_result_offsets;
    private static Func`3<string, IntPtr, IntPtr> _DeleteConsumerGroupOffsets_new;
    private static Action`1<IntPtr> _DeleteConsumerGroupOffsets_destroy;
    private static Action`5<IntPtr, IntPtr[], UIntPtr, IntPtr, IntPtr> _DeleteConsumerGroupOffsets;
    private static _DeleteConsumerGroupOffsets_result_groups_delegate _DeleteConsumerGroupOffsets_result_groups;
    private static _AclBinding_new_delegate _AclBinding_new;
    private static _AclBindingFilter_new_delegate _AclBindingFilter_new;
    private static _AclBinding_destroy_delegate _AclBinding_destroy;
    private static _AclBinding_restype_delegate _AclBinding_restype;
    private static _AclBinding_name_delegate _AclBinding_name;
    private static _AclBinding_resource_pattern_type_delegate _AclBinding_resource_pattern_type;
    private static _AclBinding_principal_delegate _AclBinding_principal;
    private static _AclBinding_host_delegate _AclBinding_host;
    private static _AclBinding_operation_delegate _AclBinding_operation;
    private static _AclBinding_permission_type_delegate _AclBinding_permission_type;
    private static _CreateAcls_delegate _CreateAcls;
    private static _CreateAcls_result_acls_delegate _CreateAcls_result_acls;
    private static _acl_result_error_delegate _acl_result_error;
    private static _DescribeAcls_delegate _DescribeAcls;
    private static _DescribeAcls_result_acls_delegate _DescribeAcls_result_acls;
    private static _DeleteAcls_delegate _DeleteAcls;
    private static _DeleteAcls_result_response_error_delegate _DeleteAcls_result_response_error;
    private static _DeleteAcls_result_responses_delegate _DeleteAcls_result_responses;
    private static _DeleteAcls_result_response_matching_acls_delegate _DeleteAcls_result_response_matching_acls;
    private static _AlterConsumerGroupOffsets_new_delegate _AlterConsumerGroupOffsets_new;
    private static _AlterConsumerGroupOffsets_destroy_delegate _AlterConsumerGroupOffsets_destroy;
    private static _AlterConsumerGroupOffsets_delegate _AlterConsumerGroupOffsets;
    private static _AlterConsumerGroupOffsets_result_groups_delegate _AlterConsumerGroupOffsets_result_groups;
    private static _ListConsumerGroupOffsets_new_delegate _ListConsumerGroupOffsets_new;
    private static _ListConsumerGroupOffsets_destroy_delegate _ListConsumerGroupOffsets_destroy;
    private static _ListConsumerGroupOffsets_delegate _ListConsumerGroupOffsets;
    private static _ListConsumerGroupOffsets_result_groups_delegate _ListConsumerGroupOffsets_result_groups;
    private static _ListConsumerGroups_delegate _ListConsumerGroups;
    private static _ConsumerGroupListing_group_id_delegate _ConsumerGroupListing_group_id;
    private static _ConsumerGroupListing_is_simple_consumer_group_delegate _ConsumerGroupListing_is_simple_consumer_group;
    private static _ConsumerGroupListing_state_delegate _ConsumerGroupListing_state;
    private static _ListConsumerGroups_result_valid_delegate _ListConsumerGroups_result_valid;
    private static _ListConsumerGroups_result_errors_delegate _ListConsumerGroups_result_errors;
    private static _DescribeConsumerGroups_delegate _DescribeConsumerGroups;
    private static _DescribeConsumerGroups_result_groups_delegate _DescribeConsumerGroups_result_groups;
    private static _ConsumerGroupDescription_group_id_delegate _ConsumerGroupDescription_group_id;
    private static _ConsumerGroupDescription_error_delegate _ConsumerGroupDescription_error;
    private static _ConsumerGroupDescription_is_simple_consumer_group_delegate _ConsumerGroupDescription_is_simple_consumer_group;
    private static _ConsumerGroupDescription_partition_assignor_delegate _ConsumerGroupDescription_partition_assignor;
    private static _ConsumerGroupDescription_state_delegate _ConsumerGroupDescription_state;
    private static _ConsumerGroupDescription_coordinator_delegate _ConsumerGroupDescription_coordinator;
    private static _ConsumerGroupDescription_member_count_delegate _ConsumerGroupDescription_member_count;
    private static _ConsumerGroupDescription_authorized_operations_delegate _ConsumerGroupDescription_authorized_operations;
    private static _ConsumerGroupDescription_member_delegate _ConsumerGroupDescription_member;
    private static _MemberDescription_client_id_delegate _MemberDescription_client_id;
    private static _MemberDescription_group_instance_id_delegate _MemberDescription_group_instance_id;
    private static _MemberDescription_consumer_id_delegate _MemberDescription_consumer_id;
    private static _MemberDescription_host_delegate _MemberDescription_host;
    private static _MemberDescription_assignment_delegate _MemberDescription_assignment;
    private static _MemberAssignment_partitions_delegate _MemberAssignment_partitions;
    private static _Node_id_delegate _Node_id;
    private static _Node_host_delegate _Node_host;
    private static _Node_port_delegate _Node_port;
    private static _Node_rack_delegate _Node_rack;
    private static _ListOffsets_delegate _ListOffsets;
    private static _ListOffsets_result_infos_delegate _ListOffsets_result_infos;
    private static _ListOffsetsResultInfo_timestamp_delegate _ListOffsetsResultInfo_timestamp;
    private static _ListOffsetsResultInfo_topic_partition_delegate _ListOffsetsResultInfo_topic_partition;
    private static Func`2<IntPtr, ErrorCode> _topic_result_error;
    private static Func`2<IntPtr, IntPtr> _topic_result_error_string;
    private static Func`2<IntPtr, IntPtr> _topic_result_name;
    private static Func`2<IntPtr, IntPtr> _group_result_name;
    private static Func`2<IntPtr, IntPtr> _group_result_error;
    private static Func`2<IntPtr, IntPtr> _group_result_partitions;
    private static _DescribeUserScramCredentials_delegate _DescribeUserScramCredentials;
    private static _DescribeUserScramCredentials_result_descriptions_delegate _DescribeUserScramCredentials_result_descriptions;
    private static _UserScramCredentialsDescription_user_delegate _UserScramCredentialsDescription_user;
    private static _UserScramCredentialsDescription_error_delegate _UserScramCredentialsDescription_error;
    private static _UserScramCredentialsDescription_scramcredentialinfo_count_delegate _UserScramCredentialsDescription_scramcredentialinfo_count;
    private static _UserScramCredentialsDescription_scramcredentialinfo_delegate _UserScramCredentialsDescription_scramcredentialinfo;
    private static _ScramCredentialInfo_mechanism_delegate _ScramCredentialInfo_mechanism;
    private static _ScramCredentialInfo_iterations_delegate _ScramCredentialInfo_iterations;
    private static _UserScramCredentialUpsertion_new_delegate _UserScramCredentialUpsertion_new;
    private static _UserScramCredentialDeletion_new_delegate _UserScramCredentialDeletion_new;
    private static _UserScramCredentialAlteration_destroy_delegate _UserScramCredentialAlteration_destroy;
    private static _AlterUserScramCredentials_delegate _AlterUserScramCredentials;
    private static _AlterUserScramCredentials_result_responses_delegate _AlterUserScramCredentials_result_responses;
    private static _AlterUserScramCredentials_result_response_user_delegate _AlterUserScramCredentials_result_response_user;
    private static _AlterUserScramCredentials_result_response_error_delegate _AlterUserScramCredentials_result_response_error;
    private static _DescribeTopics_delegate _DescribeTopics;
    private static _TopicCollection_of_topic_names_delegate _TopicCollection_of_topic_names;
    private static _TopicCollection_destroy_delegate _TopicCollection_destroy;
    private static _DescribeTopics_result_topics_delegate _DescribeTopics_result_topics;
    private static _TopicDescription_error_delegate _TopicDescription_error;
    private static _TopicDescription_name_delegate _TopicDescription_name;
    private static _TopicDescription_topic_id_delegate _TopicDescription_topic_id;
    private static _TopicDescription_partitions_delegate _TopicDescription_partitions;
    private static _TopicDescription_is_internal_delegate _TopicDescription_is_internal;
    private static _TopicDescription_authorized_operations_delegate _TopicDescription_authorized_operations;
    private static _TopicPartitionInfo_isr_delegate _TopicPartitionInfo_isr;
    private static _TopicPartitionInfo_leader_delegate _TopicPartitionInfo_leader;
    private static _TopicPartitionInfo_partition_delegate _TopicPartitionInfo_partition;
    private static _TopicPartitionInfo_replicas_delegate _TopicPartitionInfo_replicas;
    private static _DescribeCluster_delegate _DescribeCluster;
    private static _DescribeCluster_result_nodes_delegate _DescribeCluster_result_nodes;
    private static _DescribeCluster_result_authorized_operations_delegate _DescribeCluster_result_authorized_operations;
    private static _DescribeCluster_result_controller_delegate _DescribeCluster_result_controller;
    private static _DescribeCluster_result_cluster_id_delegate _DescribeCluster_result_cluster_id;
    private static Func`2<IntPtr, IntPtr> _queue_new;
    private static Action`1<IntPtr> _queue_destroy;
    private static Func`3<IntPtr, IntPtr, IntPtr> _queue_poll;
    private static Action`1<IntPtr> _event_destroy;
    private static Func`2<IntPtr, IntPtr> _event_opaque;
    private static Func`2<IntPtr, EventType> _event_type;
    private static Func`2<IntPtr, ErrorCode> _event_error;
    private static Func`2<IntPtr, IntPtr> _event_error_string;
    private static Func`2<IntPtr, IntPtr> _event_topic_partition_list;
    private static Func`2<IntPtr, ErrorCode> _error_code;
    private static Func`2<IntPtr, IntPtr> _error_string;
    private static Func`2<IntPtr, IntPtr> _error_is_fatal;
    private static Func`2<IntPtr, IntPtr> _error_is_retriable;
    private static Func`2<IntPtr, IntPtr> _error_txn_requires_abort;
    private static Action`1<IntPtr> _error_destroy;
    public static bool IsInitialized { get; }
    private static Librdkafka();
    private static bool SetDelegates(Type nativeMethodsClass);
    public static bool get_IsInitialized();
    public static bool Initialize(string userSpecifiedPath);
    private static bool TrySetDelegates(List`1<Type> nativeMethodCandidateTypes);
    private static void LoadNetStandardDelegates(string userSpecifiedPath);
    private static void LoadOSXDelegates(string userSpecifiedPath);
    private static void LoadLinuxDelegates(string userSpecifiedPath);
    internal static IntPtr version();
    internal static IntPtr version_str();
    internal static IntPtr get_debug_contexts();
    internal static IntPtr err2str(ErrorCode err);
    internal static IntPtr topic_partition_list_new(IntPtr size);
    internal static void topic_partition_list_destroy(IntPtr rkparlist);
    internal static IntPtr topic_partition_list_add(IntPtr rktparlist, string topic, int partition);
    internal static IntPtr headers_new(IntPtr size);
    internal static void headers_destroy(IntPtr hdrs);
    internal static ErrorCode headers_add(IntPtr hdrs, IntPtr keydata, IntPtr keylen, IntPtr valdata, IntPtr vallen);
    internal static ErrorCode header_get_all(IntPtr hdrs, IntPtr idx, IntPtr& namep, IntPtr& valuep, IntPtr& sizep);
    internal static ErrorCode last_error();
    internal static ErrorCode fatal_error(IntPtr rk, StringBuilder sb, UIntPtr len);
    internal static IntPtr message_errstr(IntPtr rkmessage);
    internal static long message_timestamp(IntPtr rkmessage, IntPtr& tstype);
    internal static PersistenceStatus message_status(IntPtr rkmessage);
    internal static ErrorCode message_headers(IntPtr rkmessage, IntPtr& hdrs);
    internal static int message_leader_epoch(IntPtr rkmessage);
    internal static void message_destroy(IntPtr rkmessage);
    internal static SafeConfigHandle conf_new();
    internal static void conf_destroy(IntPtr conf);
    internal static IntPtr conf_dup(IntPtr conf);
    internal static ConfRes conf_set(IntPtr conf, string name, string value, StringBuilder errstr, UIntPtr errstr_size);
    internal static void conf_set_dr_msg_cb(IntPtr conf, DeliveryReportDelegate dr_msg_cb);
    internal static void conf_set_rebalance_cb(IntPtr conf, RebalanceDelegate rebalance_cb);
    internal static void conf_set_offset_commit_cb(IntPtr conf, CommitDelegate commit_cb);
    internal static void conf_set_error_cb(IntPtr conf, ErrorDelegate error_cb);
    internal static void conf_set_log_cb(IntPtr conf, LogDelegate log_cb);
    internal static void conf_set_stats_cb(IntPtr conf, StatsDelegate stats_cb);
    internal static void conf_set_oauthbearer_token_refresh_cb(IntPtr conf, OAuthBearerTokenRefreshDelegate oauthbearer_token_refresh_cb);
    internal static ErrorCode oauthbearer_set_token(IntPtr rk, string token_value, long md_lifetime_ms, string md_principal_name, String[] extensions, UIntPtr extensions_size, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode oauthbearer_set_token_failure(IntPtr rk, string errstr);
    internal static void conf_set_default_topic_conf(IntPtr conf, IntPtr tconf);
    internal static SafeTopicConfigHandle conf_get_default_topic_conf(SafeConfigHandle conf);
    internal static ConfRes conf_get(IntPtr conf, string name, StringBuilder dest, UIntPtr& dest_size);
    internal static ConfRes topic_conf_get(IntPtr conf, string name, StringBuilder dest, UIntPtr& dest_size);
    internal static IntPtr conf_dump(IntPtr conf, UIntPtr& cntp);
    internal static IntPtr topic_conf_dump(IntPtr conf, UIntPtr& cntp);
    internal static void conf_dump_free(IntPtr arr, UIntPtr cnt);
    internal static SafeTopicConfigHandle topic_conf_new();
    internal static SafeTopicConfigHandle topic_conf_dup(SafeTopicConfigHandle conf);
    internal static SafeTopicConfigHandle default_topic_conf_dup(SafeKafkaHandle rk);
    internal static void topic_conf_destroy(IntPtr conf);
    internal static ConfRes topic_conf_set(IntPtr conf, string name, string value, StringBuilder errstr, UIntPtr errstr_size);
    internal static void topic_conf_set_opaque(IntPtr topic_conf, IntPtr opaque);
    internal static void topic_conf_set_partitioner_cb(IntPtr topic_conf, PartitionerDelegate partitioner_cb);
    internal static bool topic_partition_available(IntPtr rkt, int partition);
    internal static int topic_partition_get_leader_epoch(IntPtr rkt);
    internal static void topic_partition_set_leader_epoch(IntPtr rkt, int leader_epoch);
    internal static IntPtr init_transactions(IntPtr rk, IntPtr timeout);
    internal static IntPtr begin_transaction(IntPtr rk);
    internal static IntPtr commit_transaction(IntPtr rk, IntPtr timeout);
    internal static IntPtr abort_transaction(IntPtr rk, IntPtr timeout);
    internal static IntPtr send_offsets_to_transaction(IntPtr rk, IntPtr offsets, IntPtr consumer_group_metadata, IntPtr timeout_ms);
    internal static IntPtr consumer_group_metadata(IntPtr rk);
    internal static void consumer_group_metadata_destroy(IntPtr rk);
    internal static IntPtr consumer_group_metadata_write(IntPtr cgmd, IntPtr& data, IntPtr& dataSize);
    internal static IntPtr consumer_group_metadata_read(IntPtr& cgmd, Byte[] data, IntPtr dataSize);
    internal static SafeKafkaHandle kafka_new(RdKafkaType type, IntPtr conf, StringBuilder errstr, UIntPtr errstr_size);
    internal static void destroy(IntPtr rk);
    internal static void destroy_flags(IntPtr rk, IntPtr flags);
    internal static IntPtr name(IntPtr rk);
    internal static IntPtr memberid(IntPtr rk);
    internal static IntPtr Uuid_new(long most_significant_bits, long least_significant_bits);
    internal static IntPtr Uuid_base64str(IntPtr uuid);
    internal static long Uuid_most_significant_bits(IntPtr uuid);
    internal static long Uuid_least_significant_bits(IntPtr uuid);
    internal static void Uuid_destroy(IntPtr uuid);
    internal static SafeTopicHandle topic_new(IntPtr rk, IntPtr topic, IntPtr conf);
    internal static void topic_destroy(IntPtr rk);
    internal static IntPtr topic_name(IntPtr rkt);
    internal static ErrorCode poll_set_consumer(IntPtr rk);
    internal static IntPtr poll(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode query_watermark_offsets(IntPtr rk, string topic, int partition, Int64& low, Int64& high, IntPtr timeout_ms);
    internal static ErrorCode get_watermark_offsets(IntPtr rk, string topic, int partition, Int64& low, Int64& high);
    internal static ErrorCode offsets_for_times(IntPtr rk, IntPtr offsets, IntPtr timeout_ms);
    internal static void mem_free(IntPtr rk, IntPtr ptr);
    internal static ErrorCode subscribe(IntPtr rk, IntPtr topics);
    internal static ErrorCode unsubscribe(IntPtr rk);
    internal static ErrorCode subscription(IntPtr rk, IntPtr& topics);
    internal static IntPtr consumer_poll(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode consumer_close(IntPtr rk);
    internal static ErrorCode assign(IntPtr rk, IntPtr partitions);
    internal static IntPtr incremental_assign(IntPtr rk, IntPtr partitions);
    internal static IntPtr incremental_unassign(IntPtr rk, IntPtr partitions);
    internal static IntPtr assignment_lost(IntPtr rk);
    internal static IntPtr rebalance_protocol(IntPtr rk);
    internal static ErrorCode assignment(IntPtr rk, IntPtr& topics);
    internal static ErrorCode offsets_store(IntPtr rk, IntPtr offsets);
    internal static ErrorCode commit(IntPtr rk, IntPtr offsets, bool async);
    internal static ErrorCode commit_queue(IntPtr rk, IntPtr offsets, IntPtr rkqu, CommitDelegate cb, IntPtr opaque);
    internal static ErrorCode pause_partitions(IntPtr rk, IntPtr partitions);
    internal static ErrorCode resume_partitions(IntPtr rk, IntPtr partitions);
    internal static ErrorCode seek(IntPtr rkt, int partition, long offset, IntPtr timeout_ms);
    internal static IntPtr seek_partitions(IntPtr rkt, IntPtr partitions, IntPtr timeout_ms);
    internal static ErrorCode committed(IntPtr rk, IntPtr partitions, IntPtr timeout_ms);
    internal static ErrorCode position(IntPtr rk, IntPtr partitions);
    internal static ErrorCode produceva(IntPtr rk, string topic, int partition, IntPtr msgflags, IntPtr val, UIntPtr len, IntPtr key, UIntPtr keylen, long timestamp, IntPtr headers, IntPtr msg_opaque);
    private static ErrorCode GetErrorCodeAndDestroy(IntPtr ptr);
    internal static ErrorCode flush(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode metadata(IntPtr rk, bool all_topics, IntPtr only_rkt, IntPtr& metadatap, IntPtr timeout_ms);
    internal static void metadata_destroy(IntPtr metadata);
    internal static ErrorCode list_groups(IntPtr rk, string group, IntPtr& grplistp, IntPtr timeout_ms);
    internal static void group_list_destroy(IntPtr grplist);
    internal static IntPtr brokers_add(IntPtr rk, string brokerlist);
    internal static IntPtr sasl_set_credentials(IntPtr rk, string username, string password);
    internal static int outq_len(IntPtr rk);
    internal static IntPtr AdminOptions_new(IntPtr rk, AdminOp op);
    internal static void AdminOptions_destroy(IntPtr options);
    internal static ErrorCode AdminOptions_set_request_timeout(IntPtr options, IntPtr timeout_ms, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode AdminOptions_set_operation_timeout(IntPtr options, IntPtr timeout_ms, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode AdminOptions_set_validate_only(IntPtr options, IntPtr true_or_false, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode AdminOptions_set_incremental(IntPtr options, IntPtr true_or_false, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode AdminOptions_set_broker(IntPtr options, int broker_id, StringBuilder errstr, UIntPtr errstr_size);
    internal static void AdminOptions_set_opaque(IntPtr options, IntPtr opaque);
    internal static IntPtr AdminOptions_set_require_stable_offsets(IntPtr options, IntPtr true_or_false);
    internal static IntPtr AdminOptions_set_include_authorized_operations(IntPtr options, IntPtr true_or_false);
    internal static IntPtr AdminOptions_set_match_consumer_group_states(IntPtr options, ConsumerGroupState[] states, UIntPtr statesCnt);
    internal static IntPtr AdminOptions_set_isolation_level(IntPtr options, IntPtr IsolationLevel);
    internal static IntPtr NewTopic_new(string topic, IntPtr num_partitions, IntPtr replication_factor, StringBuilder errstr, UIntPtr errstr_size);
    internal static void NewTopic_destroy(IntPtr new_topic);
    internal static ErrorCode NewTopic_set_replica_assignment(IntPtr new_topic, int partition, Int32[] broker_ids, UIntPtr broker_id_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode NewTopic_set_config(IntPtr new_topic, string name, string value);
    internal static void CreateTopics(IntPtr rk, IntPtr[] new_topics, UIntPtr new_topic_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr CreateTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr DeleteTopic_new(string topic);
    internal static void DeleteTopic_destroy(IntPtr del_topic);
    internal static void DeleteTopics(IntPtr rk, IntPtr[] del_topics, UIntPtr del_topic_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr DeleteTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr DeleteGroup_new(string group);
    internal static void DeleteGroup_destroy(IntPtr del_group);
    internal static void DeleteGroups(IntPtr rk, IntPtr[] del_groups, UIntPtr del_groups_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr DeleteGroups_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr NewPartitions_new(string topic, UIntPtr new_total_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static void NewPartitions_destroy(IntPtr new_parts);
    internal static ErrorCode NewPartitions_set_replica_assignment(IntPtr new_parts, int new_partition_idx, Int32[] broker_ids, UIntPtr broker_id_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static void CreatePartitions(IntPtr rk, IntPtr[] new_parts, UIntPtr new_parts_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr CreatePartitions_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr ConfigSource_name(ConfigSource configsource);
    internal static IntPtr ConfigEntry_name(IntPtr entry);
    internal static IntPtr ConfigEntry_value(IntPtr entry);
    internal static ConfigSource ConfigEntry_source(IntPtr entry);
    internal static IntPtr ConfigEntry_is_read_only(IntPtr entry);
    internal static IntPtr ConfigEntry_is_default(IntPtr entry);
    internal static IntPtr ConfigEntry_is_sensitive(IntPtr entry);
    internal static IntPtr ConfigEntry_is_synonym(IntPtr entry);
    internal static IntPtr ConfigEntry_synonyms(IntPtr entry, UIntPtr& cntp);
    internal static IntPtr ResourceType_name(ResourceType restype);
    internal static IntPtr ConfigResource_new(ResourceType restype, string resname);
    internal static void ConfigResource_destroy(IntPtr config);
    internal static ErrorCode ConfigResource_add_config(IntPtr config, string name, string value);
    internal static ErrorCode ConfigResource_set_config(IntPtr config, string name, string value);
    internal static ErrorCode ConfigResource_delete_config(IntPtr config, string name);
    internal static IntPtr ConfigResource_add_incremental_config(IntPtr config, string name, AlterConfigOpType optype, string value);
    internal static IntPtr ConfigResource_configs(IntPtr config, UIntPtr& cntp);
    internal static ResourceType ConfigResource_type(IntPtr config);
    internal static IntPtr ConfigResource_name(IntPtr config);
    internal static ErrorCode ConfigResource_error(IntPtr config);
    internal static IntPtr ConfigResource_error_string(IntPtr config);
    internal static void AlterConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr AlterConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static void IncrementalAlterConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr IncrementalAlterConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static void DescribeConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr DescribeConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static IntPtr DeleteRecords_new(IntPtr topicPartitionOffsets);
    internal static void DeleteRecords_destroy(IntPtr del_records);
    internal static void DeleteRecords(IntPtr rk, IntPtr[] del_records, UIntPtr del_records_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr DeleteRecords_result_offsets(IntPtr result);
    internal static IntPtr DeleteConsumerGroupOffsets_new(string group, IntPtr topicPartitionOffsets);
    internal static void DeleteConsumerGroupOffsets_destroy(IntPtr del_grp_offsets);
    internal static void DeleteConsumerGroupOffsets(IntPtr rk, IntPtr[] del_grp_offsets, UIntPtr del_grp_offsets_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr DeleteConsumerGroupOffsets_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr AclBinding_new(ResourceType restype, string name, ResourcePatternType resource_pattern_type, string principal, string host, AclOperation operation, AclPermissionType permission_type, StringBuilder errstr, UIntPtr errstr_size);
    internal static IntPtr AclBindingFilter_new(ResourceType restype, string name, ResourcePatternType resource_pattern_type, string principal, string host, AclOperation operation, AclPermissionType permission_type, StringBuilder errstr, UIntPtr errstr_size);
    internal static void AclBinding_destroy(IntPtr acl_binding);
    internal static ResourceType AclBinding_restype(IntPtr acl_binding);
    internal static IntPtr AclBinding_name(IntPtr acl_binding);
    internal static ResourcePatternType AclBinding_resource_pattern_type(IntPtr acl_binding);
    internal static IntPtr AclBinding_principal(IntPtr acl_binding);
    internal static IntPtr AclBinding_host(IntPtr acl_binding);
    internal static AclOperation AclBinding_operation(IntPtr acl_binding);
    internal static AclPermissionType AclBinding_permission_type(IntPtr acl_binding);
    internal static void CreateAcls(IntPtr handle, IntPtr[] aclBindingsPtrs, UIntPtr aclBindingsPtrsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr CreateAcls_result_acls(IntPtr result, UIntPtr& cntp);
    internal static IntPtr acl_result_error(IntPtr aclres);
    internal static void DescribeAcls(IntPtr handle, IntPtr aclBindingFilterPtr, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr DescribeAcls_result_acls(IntPtr result, UIntPtr& cntp);
    internal static void DeleteAcls(IntPtr handle, IntPtr[] aclBindingFilterPtrs, UIntPtr aclBindingFilterPtrsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr DeleteAcls_result_response_error(IntPtr resultResponse);
    internal static IntPtr DeleteAcls_result_responses(IntPtr result, UIntPtr& cntp);
    internal static IntPtr DeleteAcls_result_response_matching_acls(IntPtr resultResponse, UIntPtr& matchingAclsCntp);
    internal static IntPtr AlterConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void AlterConsumerGroupOffsets_destroy(IntPtr groupPartitions);
    internal static void AlterConsumerGroupOffsets(IntPtr handle, IntPtr[] alterGroupsPartitions, UIntPtr alterGroupsPartitionsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr AlterConsumerGroupOffsets_result_groups(IntPtr resultResponse, UIntPtr& groupsTopicPartitionsCount);
    internal static IntPtr ListConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void ListConsumerGroupOffsets_destroy(IntPtr groupPartitions);
    internal static void ListConsumerGroupOffsets(IntPtr handle, IntPtr[] listGroupsPartitions, UIntPtr listGroupsPartitionsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr ListConsumerGroupOffsets_result_groups(IntPtr resultResponse, UIntPtr& groupsTopicPartitionsCount);
    internal static void ListConsumerGroups(IntPtr handle, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr ConsumerGroupListing_group_id(IntPtr grplist);
    internal static IntPtr ConsumerGroupListing_is_simple_consumer_group(IntPtr grplist);
    internal static ConsumerGroupState ConsumerGroupListing_state(IntPtr grplist);
    internal static IntPtr ListConsumerGroups_result_valid(IntPtr result, UIntPtr& cntp);
    internal static IntPtr ListConsumerGroups_result_errors(IntPtr result, UIntPtr& cntp);
    internal static void DescribeConsumerGroups(IntPtr handle, String[] groups, UIntPtr groupsCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr DescribeConsumerGroups_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr ConsumerGroupDescription_group_id(IntPtr grpdesc);
    internal static IntPtr ConsumerGroupDescription_error(IntPtr grpdesc);
    internal static int ConsumerGroupDescription_is_simple_consumer_group(IntPtr grpdesc);
    internal static IntPtr ConsumerGroupDescription_partition_assignor(IntPtr grpdesc);
    internal static ConsumerGroupState ConsumerGroupDescription_state(IntPtr grpdesc);
    internal static IntPtr ConsumerGroupDescription_coordinator(IntPtr grpdesc);
    internal static IntPtr ConsumerGroupDescription_member_count(IntPtr grpdesc);
    internal static IntPtr ConsumerGroupDescription_authorized_operations(IntPtr grpdesc, UIntPtr& cntp);
    internal static IntPtr ConsumerGroupDescription_member(IntPtr grpdesc, IntPtr idx);
    internal static IntPtr MemberDescription_client_id(IntPtr member);
    internal static IntPtr MemberDescription_group_instance_id(IntPtr member);
    internal static IntPtr MemberDescription_consumer_id(IntPtr member);
    internal static IntPtr MemberDescription_host(IntPtr member);
    internal static IntPtr MemberDescription_assignment(IntPtr member);
    internal static IntPtr MemberAssignment_topic_partitions(IntPtr assignment);
    internal static IntPtr Node_id(IntPtr node);
    internal static IntPtr Node_host(IntPtr node);
    internal static IntPtr Node_port(IntPtr node);
    internal static IntPtr Node_rack(IntPtr node);
    internal static void ListOffsets(IntPtr handle, IntPtr topic_partition_list, IntPtr options, IntPtr resultQueuePtr);
    internal static IntPtr ListOffsets_result_infos(IntPtr resultPtr, UIntPtr& cntp);
    internal static long ListOffsetsResultInfo_timestamp(IntPtr element);
    internal static IntPtr ListOffsetsResultInfo_topic_partition(IntPtr element);
    internal static ErrorCode topic_result_error(IntPtr topicres);
    internal static IntPtr topic_result_error_string(IntPtr topicres);
    internal static IntPtr topic_result_name(IntPtr topicres);
    internal static IntPtr group_result_name(IntPtr groupres);
    internal static IntPtr group_result_error(IntPtr groupres);
    internal static IntPtr group_result_partitions(IntPtr groupres);
    internal static void DescribeUserScramCredentials(IntPtr handle, String[] users, UIntPtr usersCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr DescribeUserScramCredentials_result_descriptions(IntPtr event_result, UIntPtr& cntp);
    internal static IntPtr UserScramCredentialsDescription_user(IntPtr description);
    internal static IntPtr UserScramCredentialsDescription_error(IntPtr description);
    internal static int UserScramCredentialsDescription_scramcredentialinfo_count(IntPtr description);
    internal static IntPtr UserScramCredentialsDescription_scramcredentialinfo(IntPtr description, int i);
    internal static ScramMechanism ScramCredentialInfo_mechanism(IntPtr scramcredentialinfo);
    internal static int ScramCredentialInfo_iterations(IntPtr scramcredentialinfo);
    internal static IntPtr UserScramCredentialUpsertion_new(string user, ScramMechanism mechanism, int iterations, Byte[] password, IntPtr passwordSize, Byte[] salt, IntPtr saltSize);
    internal static IntPtr UserScramCredentialDeletion_new(string user, ScramMechanism mechanism);
    internal static void UserScramCredentialAlteration_destroy(IntPtr alteration);
    internal static ErrorCode AlterUserScramCredentials(IntPtr handle, IntPtr[] alterations, UIntPtr alterationsCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr AlterUserScramCredentials_result_responses(IntPtr event_result, UIntPtr& cntp);
    internal static IntPtr AlterUserScramCredentials_result_response_user(IntPtr element);
    internal static IntPtr AlterUserScramCredentials_result_response_error(IntPtr element);
    internal static void DescribeTopics(IntPtr handle, IntPtr topicCollectionPtr, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr TopicCollection_of_topic_names(String[] topics, UIntPtr topicsCnt);
    internal static void TopicCollection_destroy(IntPtr topic_collection);
    internal static IntPtr DescribeTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr TopicDescription_error(IntPtr topicdesc);
    internal static IntPtr TopicDescription_name(IntPtr topicdesc);
    internal static IntPtr TopicDescription_topic_id(IntPtr topicdesc);
    internal static IntPtr TopicDescription_partitions(IntPtr topicdesc, UIntPtr& cntp);
    internal static IntPtr TopicDescription_is_internal(IntPtr topicdesc);
    internal static IntPtr TopicDescription_authorized_operations(IntPtr topicdesc, UIntPtr& cntp);
    internal static IntPtr TopicPartitionInfo_isr(IntPtr topic_partition_info, UIntPtr& cntp);
    internal static IntPtr TopicPartitionInfo_leader(IntPtr topic_partition_info);
    internal static int TopicPartitionInfo_partition(IntPtr topic_partition_info);
    internal static IntPtr TopicPartitionInfo_replicas(IntPtr topic_partition_info, UIntPtr& cntp);
    internal static void DescribeCluster(IntPtr handle, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr DescribeCluster_result_nodes(IntPtr result, UIntPtr& cntp);
    internal static IntPtr DescribeCluster_result_authorized_operations(IntPtr result, UIntPtr& cntp);
    internal static IntPtr DescribeCluster_result_controller(IntPtr result);
    internal static IntPtr DescribeCluster_result_cluster_id(IntPtr result);
    internal static IntPtr queue_new(IntPtr rk);
    internal static void queue_destroy(IntPtr rkqu);
    internal static IntPtr queue_poll(IntPtr rkqu, int timeout_ms);
    internal static void event_destroy(IntPtr rkev);
    internal static IntPtr event_opaque(IntPtr rkev);
    internal static EventType event_type(IntPtr rkev);
    internal static ErrorCode event_error(IntPtr rkev);
    internal static string event_error_string(IntPtr rkev);
    internal static IntPtr event_topic_partition_list(IntPtr rkev);
    internal static ErrorCode error_code(IntPtr error);
    internal static string error_string(IntPtr error);
    internal static bool error_is_fatal(IntPtr error);
    internal static bool error_is_retriable(IntPtr error);
    internal static bool error_txn_requires_abort(IntPtr error);
    internal static void error_destroy(IntPtr error);
}
internal enum Confluent.Kafka.Impl.MsgFlags : Enum {
    public int value__;
    public static MsgFlags MSG_F_FREE;
    public static MsgFlags MSG_F_COPY;
    public static MsgFlags MSG_F_BLOCK;
}
internal class Confluent.Kafka.Impl.NativeMethods.NativeMethods : object {
    public static string DllName;
    internal static IntPtr rd_kafka_version();
    internal static IntPtr rd_kafka_version_str();
    internal static IntPtr rd_kafka_get_debug_contexts();
    internal static IntPtr rd_kafka_err2str(ErrorCode err);
    internal static ErrorCode rd_kafka_last_error();
    internal static ErrorCode rd_kafka_fatal_error(IntPtr rk, StringBuilder errstr, UIntPtr errstr_size);
    internal static IntPtr rd_kafka_message_errstr(IntPtr rkmessage);
    internal static IntPtr rd_kafka_topic_partition_list_new(IntPtr size);
    internal static void rd_kafka_topic_partition_list_destroy(IntPtr rkparlist);
    internal static IntPtr rd_kafka_topic_partition_list_add(IntPtr rktparlist, string topic, int partition);
    internal static IntPtr rd_kafka_headers_new(IntPtr size);
    internal static void rd_kafka_headers_destroy(IntPtr hdrs);
    internal static ErrorCode rd_kafka_header_add(IntPtr hdrs, IntPtr name, IntPtr name_size, IntPtr value, IntPtr value_size);
    internal static ErrorCode rd_kafka_header_get_all(IntPtr hdrs, IntPtr idx, IntPtr& namep, IntPtr& valuep, IntPtr& sizep);
    internal static long rd_kafka_message_timestamp(IntPtr rkmessage, IntPtr& tstype);
    internal static ErrorCode rd_kafka_message_headers(IntPtr rkmessage, IntPtr& hdrs);
    internal static PersistenceStatus rd_kafka_message_status(IntPtr rkmessage);
    internal static int rd_kafka_message_leader_epoch(IntPtr rkmessage);
    internal static void rd_kafka_message_destroy(IntPtr rkmessage);
    internal static SafeConfigHandle rd_kafka_conf_new();
    internal static void rd_kafka_conf_destroy(IntPtr conf);
    internal static IntPtr rd_kafka_conf_dup(IntPtr conf);
    internal static SafeTopicConfigHandle rd_kafka_default_topic_conf_dup(SafeKafkaHandle rk);
    internal static ConfRes rd_kafka_conf_set(IntPtr conf, string name, string value, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_conf_set_dr_msg_cb(IntPtr conf, DeliveryReportDelegate dr_msg_cb);
    internal static void rd_kafka_conf_set_rebalance_cb(IntPtr conf, RebalanceDelegate rebalance_cb);
    internal static void rd_kafka_conf_set_offset_commit_cb(IntPtr conf, CommitDelegate commit_cb);
    internal static void rd_kafka_conf_set_error_cb(IntPtr conf, ErrorDelegate error_cb);
    internal static void rd_kafka_conf_set_log_cb(IntPtr conf, LogDelegate log_cb);
    internal static void rd_kafka_conf_set_oauthbearer_token_refresh_cb(IntPtr conf, OAuthBearerTokenRefreshDelegate oauthbearer_token_refresh_cb);
    internal static ErrorCode rd_kafka_oauthbearer_set_token(IntPtr rk, string token_value, long md_lifetime_ms, string md_principal_name, String[] extensions, UIntPtr extension_size, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_oauthbearer_set_token_failure(IntPtr rk, string errstr);
    internal static void rd_kafka_conf_set_stats_cb(IntPtr conf, StatsDelegate stats_cb);
    internal static void rd_kafka_conf_set_default_topic_conf(IntPtr conf, IntPtr tconf);
    internal static SafeTopicConfigHandle rd_kafka_conf_get_default_topic_conf(SafeConfigHandle conf);
    internal static ConfRes rd_kafka_conf_get(IntPtr conf, string name, StringBuilder dest, UIntPtr& dest_size);
    internal static ConfRes rd_kafka_topic_conf_get(IntPtr conf, string name, StringBuilder dest, UIntPtr& dest_size);
    internal static IntPtr rd_kafka_conf_dump(IntPtr conf, UIntPtr& cntp);
    internal static IntPtr rd_kafka_topic_conf_dump(IntPtr conf, UIntPtr& cntp);
    internal static void rd_kafka_conf_dump_free(IntPtr arr, UIntPtr cnt);
    internal static SafeTopicConfigHandle rd_kafka_topic_conf_new();
    internal static SafeTopicConfigHandle rd_kafka_topic_conf_dup(SafeTopicConfigHandle conf);
    internal static void rd_kafka_topic_conf_destroy(IntPtr conf);
    internal static ConfRes rd_kafka_topic_conf_set(IntPtr conf, string name, string value, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_topic_conf_set_opaque(IntPtr topic_conf, IntPtr opaque);
    internal static void rd_kafka_topic_conf_set_partitioner_cb(IntPtr topic_conf, PartitionerDelegate partitioner_cb);
    internal static bool rd_kafka_topic_partition_available(IntPtr rkt, int partition);
    internal static int rd_kafka_topic_partition_get_leader_epoch(IntPtr rkt);
    internal static void rd_kafka_topic_partition_set_leader_epoch(IntPtr rkt, int leader_epoch);
    internal static IntPtr rd_kafka_init_transactions(IntPtr rk, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_begin_transaction(IntPtr rk);
    internal static IntPtr rd_kafka_commit_transaction(IntPtr rk, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_abort_transaction(IntPtr rk, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_send_offsets_to_transaction(IntPtr rk, IntPtr offsets, IntPtr consumer_group_metadata, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_consumer_group_metadata(IntPtr rk);
    internal static void rd_kafka_consumer_group_metadata_destroy(IntPtr rk);
    internal static IntPtr rd_kafka_consumer_group_metadata_write(IntPtr cgmd, IntPtr& valuep, IntPtr& sizep);
    internal static IntPtr rd_kafka_consumer_group_metadata_read(IntPtr& cgmdp, Byte[] buffer, IntPtr size);
    internal static SafeKafkaHandle rd_kafka_new(RdKafkaType type, IntPtr conf, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_destroy(IntPtr rk);
    internal static void rd_kafka_destroy_flags(IntPtr rk, IntPtr flags);
    internal static IntPtr rd_kafka_name(IntPtr rk);
    internal static IntPtr rd_kafka_memberid(IntPtr rk);
    internal static IntPtr rd_kafka_Uuid_new(long most_significant_bits, long least_significant_bits);
    internal static IntPtr rd_kafka_Uuid_base64str(IntPtr uuid);
    internal static long rd_kafka_Uuid_most_significant_bits(IntPtr uuid);
    internal static long rd_kafka_Uuid_least_significant_bits(IntPtr uuid);
    internal static void rd_kafka_Uuid_destroy(IntPtr uuid);
    internal static SafeTopicHandle rd_kafka_topic_new(IntPtr rk, IntPtr topic, IntPtr conf);
    internal static void rd_kafka_topic_destroy(IntPtr rk);
    internal static IntPtr rd_kafka_topic_name(IntPtr rkt);
    internal static ErrorCode rd_kafka_poll_set_consumer(IntPtr rk);
    internal static IntPtr rd_kafka_poll(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_query_watermark_offsets(IntPtr rk, string topic, int partition, Int64& low, Int64& high, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_get_watermark_offsets(IntPtr rk, string topic, int partition, Int64& low, Int64& high);
    internal static ErrorCode rd_kafka_offsets_for_times(IntPtr rk, IntPtr offsets, IntPtr timeout_ms);
    internal static void rd_kafka_mem_free(IntPtr rk, IntPtr ptr);
    internal static ErrorCode rd_kafka_subscribe(IntPtr rk, IntPtr topics);
    internal static ErrorCode rd_kafka_unsubscribe(IntPtr rk);
    internal static ErrorCode rd_kafka_subscription(IntPtr rk, IntPtr& topics);
    internal static IntPtr rd_kafka_consumer_poll(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_consumer_close(IntPtr rk);
    internal static ErrorCode rd_kafka_assign(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_incremental_assign(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_incremental_unassign(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_assignment_lost(IntPtr rk);
    internal static IntPtr rd_kafka_rebalance_protocol(IntPtr rk);
    internal static ErrorCode rd_kafka_assignment(IntPtr rk, IntPtr& topics);
    internal static ErrorCode rd_kafka_offsets_store(IntPtr rk, IntPtr offsets);
    internal static ErrorCode rd_kafka_commit(IntPtr rk, IntPtr offsets, bool async);
    internal static ErrorCode rd_kafka_commit_queue(IntPtr rk, IntPtr offsets, IntPtr rkqu, CommitDelegate cb, IntPtr opaque);
    internal static ErrorCode rd_kafka_pause_partitions(IntPtr rk, IntPtr partitions);
    internal static ErrorCode rd_kafka_resume_partitions(IntPtr rk, IntPtr partitions);
    internal static ErrorCode rd_kafka_seek(IntPtr rkt, int partition, long offset, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_seek_partitions(IntPtr rkt, IntPtr partitions, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_committed(IntPtr rk, IntPtr partitions, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_position(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_produceva(IntPtr rk, rd_kafka_vu* vus, IntPtr size);
    internal static ErrorCode rd_kafka_flush(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_metadata(IntPtr rk, bool all_topics, IntPtr only_rkt, IntPtr& metadatap, IntPtr timeout_ms);
    internal static void rd_kafka_metadata_destroy(IntPtr metadata);
    internal static ErrorCode rd_kafka_list_groups(IntPtr rk, string group, IntPtr& grplistp, IntPtr timeout_ms);
    internal static void rd_kafka_group_list_destroy(IntPtr grplist);
    internal static IntPtr rd_kafka_brokers_add(IntPtr rk, string brokerlist);
    internal static IntPtr rd_kafka_sasl_set_credentials(IntPtr rk, string username, string password);
    internal static int rd_kafka_outq_len(IntPtr rk);
    internal static IntPtr rd_kafka_AdminOptions_new(IntPtr rk, AdminOp op);
    internal static void rd_kafka_AdminOptions_destroy(IntPtr options);
    internal static ErrorCode rd_kafka_AdminOptions_set_request_timeout(IntPtr options, IntPtr timeout_ms, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_operation_timeout(IntPtr options, IntPtr timeout_ms, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_validate_only(IntPtr options, IntPtr true_or_false, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_incremental(IntPtr options, IntPtr true_or_false, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_broker(IntPtr options, int broker_id, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_AdminOptions_set_opaque(IntPtr options, IntPtr opaque);
    internal static IntPtr rd_kafka_AdminOptions_set_require_stable_offsets(IntPtr options, IntPtr true_or_false);
    internal static IntPtr rd_kafka_AdminOptions_set_include_authorized_operations(IntPtr options, IntPtr true_or_false);
    internal static IntPtr rd_kafka_AdminOptions_set_isolation_level(IntPtr options, IntPtr isolation_level);
    internal static IntPtr rd_kafka_AdminOptions_set_match_consumer_group_states(IntPtr options, ConsumerGroupState[] states, UIntPtr statesCnt);
    internal static IntPtr rd_kafka_NewTopic_new(string topic, IntPtr num_partitions, IntPtr replication_factor, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_NewTopic_destroy(IntPtr new_topic);
    internal static ErrorCode rd_kafka_NewTopic_set_replica_assignment(IntPtr new_topic, int partition, Int32[] broker_ids, UIntPtr broker_id_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_NewTopic_set_config(IntPtr new_topic, string name, string value);
    internal static void rd_kafka_CreateTopics(IntPtr rk, IntPtr[] new_topics, UIntPtr new_topic_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_CreateTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteTopic_new(string topic);
    internal static void rd_kafka_DeleteTopic_destroy(IntPtr del_topic);
    internal static void rd_kafka_DeleteTopics(IntPtr rk, IntPtr[] del_topics, UIntPtr del_topic_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteGroup_new(string group);
    internal static void rd_kafka_DeleteGroup_destroy(IntPtr del_group);
    internal static void rd_kafka_DeleteGroups(IntPtr rk, IntPtr[] del_groups, UIntPtr del_group_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteGroups_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteRecords_new(IntPtr offsets);
    internal static void rd_kafka_DeleteRecords_destroy(IntPtr del_topic);
    internal static void rd_kafka_DeleteRecords(IntPtr rk, IntPtr[] del_records, UIntPtr del_records_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteRecords_result_offsets(IntPtr result);
    internal static IntPtr rd_kafka_NewPartitions_new(string topic, UIntPtr new_total_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_NewPartitions_destroy(IntPtr new_parts);
    internal static ErrorCode rd_kafka_NewPartitions_set_replica_assignment(IntPtr new_parts, int new_partition_idx, Int32[] broker_ids, UIntPtr broker_id_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_CreatePartitions(IntPtr rk, IntPtr[] new_parts, UIntPtr new_parts_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_CreatePartitions_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ConfigSource_name(ConfigSource configsource);
    internal static IntPtr rd_kafka_ConfigEntry_name(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_value(IntPtr entry);
    internal static ConfigSource rd_kafka_ConfigEntry_source(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_read_only(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_default(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_sensitive(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_synonym(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_synonyms(IntPtr entry, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ResourceType_name(ResourceType restype);
    internal static IntPtr rd_kafka_ConfigResource_new(ResourceType restype, string resname);
    internal static void rd_kafka_ConfigResource_destroy(IntPtr config);
    internal static ErrorCode rd_kafka_ConfigResource_add_config(IntPtr config, string name, string value);
    internal static ErrorCode rd_kafka_ConfigResource_set_config(IntPtr config, string name, string value);
    internal static ErrorCode rd_kafka_ConfigResource_delete_config(IntPtr config, string name);
    internal static IntPtr rd_kafka_ConfigResource_add_incremental_config(IntPtr config, string name, AlterConfigOpType optype, string value);
    internal static IntPtr rd_kafka_ConfigResource_configs(IntPtr config, UIntPtr& cntp);
    internal static ResourceType rd_kafka_ConfigResource_type(IntPtr config);
    internal static IntPtr rd_kafka_ConfigResource_name(IntPtr config);
    internal static ErrorCode rd_kafka_ConfigResource_error(IntPtr config);
    internal static IntPtr rd_kafka_ConfigResource_error_string(IntPtr config);
    internal static void rd_kafka_AlterConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_AlterConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_IncrementalAlterConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_IncrementalAlterConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_DescribeConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DescribeConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_AclBinding_new(ResourceType restype, string name, ResourcePatternType resource_pattern_type, string principal, string host, AclOperation operation, AclPermissionType permission_type, StringBuilder errstr, UIntPtr errstr_size);
    internal static IntPtr rd_kafka_AclBindingFilter_new(ResourceType restype, string name, ResourcePatternType resource_pattern_type, string principal, string host, AclOperation operation, AclPermissionType permission_type, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_AclBinding_destroy(IntPtr acl_binding);
    internal static ResourceType rd_kafka_AclBinding_restype(IntPtr acl_binding);
    internal static IntPtr rd_kafka_AclBinding_name(IntPtr acl_binding);
    internal static ResourcePatternType rd_kafka_AclBinding_resource_pattern_type(IntPtr acl_binding);
    internal static IntPtr rd_kafka_AclBinding_principal(IntPtr acl_binding);
    internal static IntPtr rd_kafka_AclBinding_host(IntPtr acl_binding);
    internal static AclOperation rd_kafka_AclBinding_operation(IntPtr acl_binding);
    internal static AclPermissionType rd_kafka_AclBinding_permission_type(IntPtr acl_binding);
    internal static void rd_kafka_CreateAcls(IntPtr rk, IntPtr[] new_acls, UIntPtr new_acls_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_CreateAcls_result_acls(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_acl_result_error(IntPtr aclres);
    internal static void rd_kafka_DescribeAcls(IntPtr rk, IntPtr acl_filter, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DescribeAcls_result_acls(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_DeleteAcls(IntPtr rk, IntPtr[] del_acls, UIntPtr del_acls_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteAcls_result_responses(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteAcls_result_response_error(IntPtr result_response);
    internal static IntPtr rd_kafka_DeleteAcls_result_response_matching_acls(IntPtr result_response, UIntPtr& matching_acls_cntp);
    internal static IntPtr rd_kafka_DeleteConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void rd_kafka_DeleteConsumerGroupOffsets_destroy(IntPtr del_grp_offsets);
    internal static void rd_kafka_DeleteConsumerGroupOffsets(IntPtr rk, IntPtr[] del_grp_offsets, UIntPtr del_grp_offsets_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteConsumerGroupOffsets_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ListConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void rd_kafka_ListConsumerGroupOffsets_destroy(IntPtr groupPartitions);
    internal static IntPtr rd_kafka_ListConsumerGroupOffsets_result_groups(IntPtr resultResponse, UIntPtr& groupsTopicPartitionsCount);
    internal static void rd_kafka_ListConsumerGroupOffsets(IntPtr handle, IntPtr[] listGroupsPartitions, UIntPtr listGroupsPartitionsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_AlterConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void rd_kafka_AlterConsumerGroupOffsets_destroy(IntPtr groupPartitions);
    internal static IntPtr rd_kafka_AlterConsumerGroupOffsets_result_groups(IntPtr resultResponse, UIntPtr& groupsTopicPartitionsCount);
    internal static void rd_kafka_AlterConsumerGroupOffsets(IntPtr handle, IntPtr[] alterGroupsPartitions, UIntPtr alterGroupsPartitionsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static void rd_kafka_ListConsumerGroups(IntPtr handle, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_ConsumerGroupListing_group_id(IntPtr grplist);
    internal static IntPtr rd_kafka_ConsumerGroupListing_is_simple_consumer_group(IntPtr grplist);
    internal static ConsumerGroupState rd_kafka_ConsumerGroupListing_state(IntPtr grplist);
    internal static IntPtr rd_kafka_ListConsumerGroups_result_valid(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ListConsumerGroups_result_errors(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_DescribeConsumerGroups(IntPtr handle, String[] groups, UIntPtr groupsCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_DescribeConsumerGroups_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_group_id(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_error(IntPtr grpdesc);
    internal static int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_partition_assignor(IntPtr grpdesc);
    internal static ConsumerGroupState rd_kafka_ConsumerGroupDescription_state(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_coordinator(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_authorized_operations(IntPtr grpdesc, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_member_count(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_member(IntPtr grpdesc, IntPtr idx);
    internal static IntPtr rd_kafka_MemberDescription_client_id(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_group_instance_id(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_consumer_id(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_host(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_assignment(IntPtr member);
    internal static IntPtr rd_kafka_MemberAssignment_partitions(IntPtr assignment);
    internal static IntPtr rd_kafka_Node_id(IntPtr node);
    internal static IntPtr rd_kafka_Node_host(IntPtr node);
    internal static IntPtr rd_kafka_Node_port(IntPtr node);
    internal static IntPtr rd_kafka_Node_rack(IntPtr node);
    internal static ErrorCode rd_kafka_topic_result_error(IntPtr topicres);
    internal static IntPtr rd_kafka_topic_result_error_string(IntPtr topicres);
    internal static IntPtr rd_kafka_topic_result_name(IntPtr topicres);
    internal static IntPtr rd_kafka_group_result_name(IntPtr groupres);
    internal static IntPtr rd_kafka_group_result_error(IntPtr groupres);
    internal static IntPtr rd_kafka_group_result_partitions(IntPtr groupres);
    internal static void rd_kafka_DescribeUserScramCredentials(IntPtr handle, String[] users, UIntPtr usersCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static ErrorCode rd_kafka_AlterUserScramCredentials(IntPtr handle, IntPtr[] alterations, UIntPtr alterationsCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_UserScramCredentialDeletion_new(string user, ScramMechanism mechanism);
    internal static IntPtr rd_kafka_UserScramCredentialUpsertion_new(string user, ScramMechanism mechanism, int iterations, Byte[] password, IntPtr passwordSize, Byte[] salt, IntPtr saltSize);
    internal static void rd_kafka_UserScramCredentialAlteration_destroy(IntPtr alteration);
    internal static IntPtr rd_kafka_DescribeUserScramCredentials_result_descriptions(IntPtr event_result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_UserScramCredentialsDescription_user(IntPtr description);
    internal static IntPtr rd_kafka_UserScramCredentialsDescription_error(IntPtr description);
    internal static int rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(IntPtr description);
    internal static IntPtr rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(IntPtr description, int i);
    internal static ScramMechanism rd_kafka_ScramCredentialInfo_mechanism(IntPtr scramcredentialinfo);
    internal static int rd_kafka_ScramCredentialInfo_iterations(IntPtr scramcredentialinfo);
    internal static IntPtr rd_kafka_AlterUserScramCredentials_result_responses(IntPtr event_result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_AlterUserScramCredentials_result_response_user(IntPtr element);
    internal static IntPtr rd_kafka_AlterUserScramCredentials_result_response_error(IntPtr element);
    internal static void rd_kafka_ListOffsets(IntPtr handle, IntPtr topic_partition_list, IntPtr options, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_ListOffsets_result_infos(IntPtr resultPtr, UIntPtr& cntp);
    internal static long rd_kafka_ListOffsetsResultInfo_timestamp(IntPtr element);
    internal static IntPtr rd_kafka_ListOffsetsResultInfo_topic_partition(IntPtr element);
    internal static void rd_kafka_DescribeTopics(IntPtr handle, IntPtr topicCollection, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_DescribeTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicCollection_of_topic_names(String[] topics, UIntPtr topicsCnt);
    internal static void rd_kafka_TopicCollection_destroy(IntPtr topic_collection);
    internal static IntPtr rd_kafka_TopicDescription_error(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_name(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_topic_id(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_partitions(IntPtr topicdesc, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicDescription_is_internal(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_authorized_operations(IntPtr topicdesc, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicPartitionInfo_isr(IntPtr topic_partition_info, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicPartitionInfo_leader(IntPtr topic_partition_info);
    internal static int rd_kafka_TopicPartitionInfo_partition(IntPtr topic_partition_info);
    internal static IntPtr rd_kafka_TopicPartitionInfo_replicas(IntPtr topic_partition_info, UIntPtr& cntp);
    internal static void rd_kafka_DescribeCluster(IntPtr handle, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_DescribeCluster_result_nodes(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DescribeCluster_result_authorized_operations(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DescribeCluster_result_controller(IntPtr result);
    internal static IntPtr rd_kafka_DescribeCluster_result_cluster_id(IntPtr result);
    internal static IntPtr rd_kafka_queue_new(IntPtr rk);
    internal static void rd_kafka_queue_destroy(IntPtr rkqu);
    internal static IntPtr rd_kafka_queue_poll(IntPtr rkqu, IntPtr timeout_ms);
    internal static void rd_kafka_event_destroy(IntPtr rkev);
    internal static EventType rd_kafka_event_type(IntPtr rkev);
    internal static IntPtr rd_kafka_event_opaque(IntPtr rkev);
    internal static ErrorCode rd_kafka_event_error(IntPtr rkev);
    internal static IntPtr rd_kafka_event_error_string(IntPtr rkev);
    internal static IntPtr rd_kafka_event_topic_partition_list(IntPtr rkev);
    internal static ErrorCode rd_kafka_error_code(IntPtr error);
    internal static IntPtr rd_kafka_error_string(IntPtr error);
    internal static IntPtr rd_kafka_error_is_fatal(IntPtr error);
    internal static IntPtr rd_kafka_error_is_retriable(IntPtr error);
    internal static IntPtr rd_kafka_error_txn_requires_abort(IntPtr error);
    internal static void rd_kafka_error_destroy(IntPtr error);
}
internal class Confluent.Kafka.Impl.NativeMethods.NativeMethods_Alpine : object {
    public static string DllName;
    internal static IntPtr rd_kafka_version();
    internal static IntPtr rd_kafka_version_str();
    internal static IntPtr rd_kafka_get_debug_contexts();
    internal static IntPtr rd_kafka_err2str(ErrorCode err);
    internal static ErrorCode rd_kafka_last_error();
    internal static ErrorCode rd_kafka_fatal_error(IntPtr rk, StringBuilder errstr, UIntPtr errstr_size);
    internal static IntPtr rd_kafka_message_errstr(IntPtr rkmessage);
    internal static IntPtr rd_kafka_topic_partition_list_new(IntPtr size);
    internal static void rd_kafka_topic_partition_list_destroy(IntPtr rkparlist);
    internal static IntPtr rd_kafka_topic_partition_list_add(IntPtr rktparlist, string topic, int partition);
    internal static IntPtr rd_kafka_headers_new(IntPtr size);
    internal static void rd_kafka_headers_destroy(IntPtr hdrs);
    internal static ErrorCode rd_kafka_header_add(IntPtr hdrs, IntPtr name, IntPtr name_size, IntPtr value, IntPtr value_size);
    internal static ErrorCode rd_kafka_header_get_all(IntPtr hdrs, IntPtr idx, IntPtr& namep, IntPtr& valuep, IntPtr& sizep);
    internal static long rd_kafka_message_timestamp(IntPtr rkmessage, IntPtr& tstype);
    internal static ErrorCode rd_kafka_message_headers(IntPtr rkmessage, IntPtr& hdrs);
    internal static PersistenceStatus rd_kafka_message_status(IntPtr rkmessage);
    internal static int rd_kafka_message_leader_epoch(IntPtr rkmessage);
    internal static void rd_kafka_message_destroy(IntPtr rkmessage);
    internal static SafeConfigHandle rd_kafka_conf_new();
    internal static void rd_kafka_conf_destroy(IntPtr conf);
    internal static IntPtr rd_kafka_conf_dup(IntPtr conf);
    internal static SafeTopicConfigHandle rd_kafka_default_topic_conf_dup(SafeKafkaHandle rk);
    internal static ConfRes rd_kafka_conf_set(IntPtr conf, string name, string value, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_conf_set_dr_msg_cb(IntPtr conf, DeliveryReportDelegate dr_msg_cb);
    internal static void rd_kafka_conf_set_rebalance_cb(IntPtr conf, RebalanceDelegate rebalance_cb);
    internal static void rd_kafka_conf_set_offset_commit_cb(IntPtr conf, CommitDelegate commit_cb);
    internal static void rd_kafka_conf_set_error_cb(IntPtr conf, ErrorDelegate error_cb);
    internal static void rd_kafka_conf_set_log_cb(IntPtr conf, LogDelegate log_cb);
    internal static void rd_kafka_conf_set_oauthbearer_token_refresh_cb(IntPtr conf, OAuthBearerTokenRefreshDelegate oauthbearer_token_refresh_cb);
    internal static ErrorCode rd_kafka_oauthbearer_set_token(IntPtr rk, string token_value, long md_lifetime_ms, string md_principal_name, String[] extensions, UIntPtr extension_size, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_oauthbearer_set_token_failure(IntPtr rk, string errstr);
    internal static void rd_kafka_conf_set_stats_cb(IntPtr conf, StatsDelegate stats_cb);
    internal static void rd_kafka_conf_set_default_topic_conf(IntPtr conf, IntPtr tconf);
    internal static SafeTopicConfigHandle rd_kafka_conf_get_default_topic_conf(SafeConfigHandle conf);
    internal static ConfRes rd_kafka_conf_get(IntPtr conf, string name, StringBuilder dest, UIntPtr& dest_size);
    internal static ConfRes rd_kafka_topic_conf_get(IntPtr conf, string name, StringBuilder dest, UIntPtr& dest_size);
    internal static IntPtr rd_kafka_conf_dump(IntPtr conf, UIntPtr& cntp);
    internal static IntPtr rd_kafka_topic_conf_dump(IntPtr conf, UIntPtr& cntp);
    internal static void rd_kafka_conf_dump_free(IntPtr arr, UIntPtr cnt);
    internal static SafeTopicConfigHandle rd_kafka_topic_conf_new();
    internal static SafeTopicConfigHandle rd_kafka_topic_conf_dup(SafeTopicConfigHandle conf);
    internal static void rd_kafka_topic_conf_destroy(IntPtr conf);
    internal static ConfRes rd_kafka_topic_conf_set(IntPtr conf, string name, string value, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_topic_conf_set_opaque(IntPtr topic_conf, IntPtr opaque);
    internal static void rd_kafka_topic_conf_set_partitioner_cb(IntPtr topic_conf, PartitionerDelegate partitioner_cb);
    internal static bool rd_kafka_topic_partition_available(IntPtr rkt, int partition);
    internal static int rd_kafka_topic_partition_get_leader_epoch(IntPtr rkt);
    internal static void rd_kafka_topic_partition_set_leader_epoch(IntPtr rkt, int leader_epoch);
    internal static IntPtr rd_kafka_init_transactions(IntPtr rk, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_begin_transaction(IntPtr rk);
    internal static IntPtr rd_kafka_commit_transaction(IntPtr rk, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_abort_transaction(IntPtr rk, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_send_offsets_to_transaction(IntPtr rk, IntPtr offsets, IntPtr consumer_group_metadata, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_consumer_group_metadata(IntPtr rk);
    internal static void rd_kafka_consumer_group_metadata_destroy(IntPtr rk);
    internal static IntPtr rd_kafka_consumer_group_metadata_write(IntPtr cgmd, IntPtr& valuep, IntPtr& sizep);
    internal static IntPtr rd_kafka_consumer_group_metadata_read(IntPtr& cgmdp, Byte[] buffer, IntPtr size);
    internal static SafeKafkaHandle rd_kafka_new(RdKafkaType type, IntPtr conf, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_destroy(IntPtr rk);
    internal static void rd_kafka_destroy_flags(IntPtr rk, IntPtr flags);
    internal static IntPtr rd_kafka_name(IntPtr rk);
    internal static IntPtr rd_kafka_memberid(IntPtr rk);
    internal static IntPtr rd_kafka_Uuid_new(long most_significant_bits, long least_significant_bits);
    internal static IntPtr rd_kafka_Uuid_base64str(IntPtr uuid);
    internal static long rd_kafka_Uuid_most_significant_bits(IntPtr uuid);
    internal static long rd_kafka_Uuid_least_significant_bits(IntPtr uuid);
    internal static void rd_kafka_Uuid_destroy(IntPtr uuid);
    internal static SafeTopicHandle rd_kafka_topic_new(IntPtr rk, IntPtr topic, IntPtr conf);
    internal static void rd_kafka_topic_destroy(IntPtr rk);
    internal static IntPtr rd_kafka_topic_name(IntPtr rkt);
    internal static ErrorCode rd_kafka_poll_set_consumer(IntPtr rk);
    internal static IntPtr rd_kafka_poll(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_query_watermark_offsets(IntPtr rk, string topic, int partition, Int64& low, Int64& high, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_get_watermark_offsets(IntPtr rk, string topic, int partition, Int64& low, Int64& high);
    internal static ErrorCode rd_kafka_offsets_for_times(IntPtr rk, IntPtr offsets, IntPtr timeout_ms);
    internal static void rd_kafka_mem_free(IntPtr rk, IntPtr ptr);
    internal static ErrorCode rd_kafka_subscribe(IntPtr rk, IntPtr topics);
    internal static ErrorCode rd_kafka_unsubscribe(IntPtr rk);
    internal static ErrorCode rd_kafka_subscription(IntPtr rk, IntPtr& topics);
    internal static IntPtr rd_kafka_consumer_poll(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_consumer_close(IntPtr rk);
    internal static ErrorCode rd_kafka_assign(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_incremental_assign(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_incremental_unassign(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_assignment_lost(IntPtr rk);
    internal static IntPtr rd_kafka_rebalance_protocol(IntPtr rk);
    internal static ErrorCode rd_kafka_assignment(IntPtr rk, IntPtr& topics);
    internal static ErrorCode rd_kafka_offsets_store(IntPtr rk, IntPtr offsets);
    internal static ErrorCode rd_kafka_commit(IntPtr rk, IntPtr offsets, bool async);
    internal static ErrorCode rd_kafka_commit_queue(IntPtr rk, IntPtr offsets, IntPtr rkqu, CommitDelegate cb, IntPtr opaque);
    internal static ErrorCode rd_kafka_pause_partitions(IntPtr rk, IntPtr partitions);
    internal static ErrorCode rd_kafka_resume_partitions(IntPtr rk, IntPtr partitions);
    internal static ErrorCode rd_kafka_seek(IntPtr rkt, int partition, long offset, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_seek_partitions(IntPtr rkt, IntPtr partitions, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_committed(IntPtr rk, IntPtr partitions, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_position(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_produceva(IntPtr rk, rd_kafka_vu* vus, IntPtr size);
    internal static ErrorCode rd_kafka_flush(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_metadata(IntPtr rk, bool all_topics, IntPtr only_rkt, IntPtr& metadatap, IntPtr timeout_ms);
    internal static void rd_kafka_metadata_destroy(IntPtr metadata);
    internal static ErrorCode rd_kafka_list_groups(IntPtr rk, string group, IntPtr& grplistp, IntPtr timeout_ms);
    internal static void rd_kafka_group_list_destroy(IntPtr grplist);
    internal static IntPtr rd_kafka_brokers_add(IntPtr rk, string brokerlist);
    internal static IntPtr rd_kafka_sasl_set_credentials(IntPtr rk, string username, string password);
    internal static int rd_kafka_outq_len(IntPtr rk);
    internal static IntPtr rd_kafka_AdminOptions_new(IntPtr rk, AdminOp op);
    internal static void rd_kafka_AdminOptions_destroy(IntPtr options);
    internal static ErrorCode rd_kafka_AdminOptions_set_request_timeout(IntPtr options, IntPtr timeout_ms, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_operation_timeout(IntPtr options, IntPtr timeout_ms, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_validate_only(IntPtr options, IntPtr true_or_false, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_incremental(IntPtr options, IntPtr true_or_false, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_broker(IntPtr options, int broker_id, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_AdminOptions_set_opaque(IntPtr options, IntPtr opaque);
    internal static IntPtr rd_kafka_AdminOptions_set_require_stable_offsets(IntPtr options, IntPtr true_or_false);
    internal static IntPtr rd_kafka_AdminOptions_set_include_authorized_operations(IntPtr options, IntPtr true_or_false);
    internal static IntPtr rd_kafka_AdminOptions_set_isolation_level(IntPtr options, IntPtr isolation_level);
    internal static IntPtr rd_kafka_AdminOptions_set_match_consumer_group_states(IntPtr options, ConsumerGroupState[] states, UIntPtr statesCnt);
    internal static IntPtr rd_kafka_NewTopic_new(string topic, IntPtr num_partitions, IntPtr replication_factor, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_NewTopic_destroy(IntPtr new_topic);
    internal static ErrorCode rd_kafka_NewTopic_set_replica_assignment(IntPtr new_topic, int partition, Int32[] broker_ids, UIntPtr broker_id_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_NewTopic_set_config(IntPtr new_topic, string name, string value);
    internal static void rd_kafka_CreateTopics(IntPtr rk, IntPtr[] new_topics, UIntPtr new_topic_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_CreateTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteTopic_new(string topic);
    internal static void rd_kafka_DeleteTopic_destroy(IntPtr del_topic);
    internal static void rd_kafka_DeleteTopics(IntPtr rk, IntPtr[] del_topics, UIntPtr del_topic_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteGroup_new(string group);
    internal static void rd_kafka_DeleteGroup_destroy(IntPtr del_group);
    internal static void rd_kafka_DeleteGroups(IntPtr rk, IntPtr[] del_groups, UIntPtr del_group_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteGroups_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteRecords_new(IntPtr offsets);
    internal static void rd_kafka_DeleteRecords_destroy(IntPtr del_topic);
    internal static void rd_kafka_DeleteRecords(IntPtr rk, IntPtr[] del_records, UIntPtr del_records_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteRecords_result_offsets(IntPtr result);
    internal static IntPtr rd_kafka_NewPartitions_new(string topic, UIntPtr new_total_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_NewPartitions_destroy(IntPtr new_parts);
    internal static ErrorCode rd_kafka_NewPartitions_set_replica_assignment(IntPtr new_parts, int new_partition_idx, Int32[] broker_ids, UIntPtr broker_id_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_CreatePartitions(IntPtr rk, IntPtr[] new_parts, UIntPtr new_parts_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_CreatePartitions_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ConfigSource_name(ConfigSource configsource);
    internal static IntPtr rd_kafka_ConfigEntry_name(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_value(IntPtr entry);
    internal static ConfigSource rd_kafka_ConfigEntry_source(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_read_only(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_default(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_sensitive(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_synonym(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_synonyms(IntPtr entry, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ResourceType_name(ResourceType restype);
    internal static IntPtr rd_kafka_ConfigResource_new(ResourceType restype, string resname);
    internal static void rd_kafka_ConfigResource_destroy(IntPtr config);
    internal static ErrorCode rd_kafka_ConfigResource_add_config(IntPtr config, string name, string value);
    internal static ErrorCode rd_kafka_ConfigResource_set_config(IntPtr config, string name, string value);
    internal static ErrorCode rd_kafka_ConfigResource_delete_config(IntPtr config, string name);
    internal static IntPtr rd_kafka_ConfigResource_add_incremental_config(IntPtr config, string name, AlterConfigOpType optype, string value);
    internal static IntPtr rd_kafka_ConfigResource_configs(IntPtr config, UIntPtr& cntp);
    internal static ResourceType rd_kafka_ConfigResource_type(IntPtr config);
    internal static IntPtr rd_kafka_ConfigResource_name(IntPtr config);
    internal static ErrorCode rd_kafka_ConfigResource_error(IntPtr config);
    internal static IntPtr rd_kafka_ConfigResource_error_string(IntPtr config);
    internal static void rd_kafka_AlterConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_AlterConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_IncrementalAlterConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_IncrementalAlterConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_DescribeConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DescribeConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_AclBinding_new(ResourceType restype, string name, ResourcePatternType resource_pattern_type, string principal, string host, AclOperation operation, AclPermissionType permission_type, StringBuilder errstr, UIntPtr errstr_size);
    internal static IntPtr rd_kafka_AclBindingFilter_new(ResourceType restype, string name, ResourcePatternType resource_pattern_type, string principal, string host, AclOperation operation, AclPermissionType permission_type, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_AclBinding_destroy(IntPtr acl_binding);
    internal static ResourceType rd_kafka_AclBinding_restype(IntPtr acl_binding);
    internal static IntPtr rd_kafka_AclBinding_name(IntPtr acl_binding);
    internal static ResourcePatternType rd_kafka_AclBinding_resource_pattern_type(IntPtr acl_binding);
    internal static IntPtr rd_kafka_AclBinding_principal(IntPtr acl_binding);
    internal static IntPtr rd_kafka_AclBinding_host(IntPtr acl_binding);
    internal static AclOperation rd_kafka_AclBinding_operation(IntPtr acl_binding);
    internal static AclPermissionType rd_kafka_AclBinding_permission_type(IntPtr acl_binding);
    internal static void rd_kafka_CreateAcls(IntPtr rk, IntPtr[] new_acls, UIntPtr new_acls_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_CreateAcls_result_acls(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_acl_result_error(IntPtr aclres);
    internal static void rd_kafka_DescribeAcls(IntPtr rk, IntPtr acl_filter, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DescribeAcls_result_acls(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_DeleteAcls(IntPtr rk, IntPtr[] del_acls, UIntPtr del_acls_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteAcls_result_responses(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteAcls_result_response_error(IntPtr result_response);
    internal static IntPtr rd_kafka_DeleteAcls_result_response_matching_acls(IntPtr result_response, UIntPtr& matching_acls_cntp);
    internal static IntPtr rd_kafka_DeleteConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void rd_kafka_DeleteConsumerGroupOffsets_destroy(IntPtr del_grp_offsets);
    internal static void rd_kafka_DeleteConsumerGroupOffsets(IntPtr rk, IntPtr[] del_grp_offsets, UIntPtr del_grp_offsets_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteConsumerGroupOffsets_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ListConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void rd_kafka_ListConsumerGroupOffsets_destroy(IntPtr groupPartitions);
    internal static IntPtr rd_kafka_ListConsumerGroupOffsets_result_groups(IntPtr resultResponse, UIntPtr& groupsTopicPartitionsCount);
    internal static void rd_kafka_ListConsumerGroupOffsets(IntPtr handle, IntPtr[] listGroupsPartitions, UIntPtr listGroupsPartitionsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_AlterConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void rd_kafka_AlterConsumerGroupOffsets_destroy(IntPtr groupPartitions);
    internal static IntPtr rd_kafka_AlterConsumerGroupOffsets_result_groups(IntPtr resultResponse, UIntPtr& groupsTopicPartitionsCount);
    internal static void rd_kafka_AlterConsumerGroupOffsets(IntPtr handle, IntPtr[] alterGroupsPartitions, UIntPtr alterGroupsPartitionsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static void rd_kafka_ListConsumerGroups(IntPtr handle, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_ConsumerGroupListing_group_id(IntPtr grplist);
    internal static IntPtr rd_kafka_ConsumerGroupListing_is_simple_consumer_group(IntPtr grplist);
    internal static ConsumerGroupState rd_kafka_ConsumerGroupListing_state(IntPtr grplist);
    internal static IntPtr rd_kafka_ListConsumerGroups_result_valid(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ListConsumerGroups_result_errors(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_DescribeConsumerGroups(IntPtr handle, String[] groups, UIntPtr groupsCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_DescribeConsumerGroups_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_group_id(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_error(IntPtr grpdesc);
    internal static int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_partition_assignor(IntPtr grpdesc);
    internal static ConsumerGroupState rd_kafka_ConsumerGroupDescription_state(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_coordinator(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_authorized_operations(IntPtr grpdesc, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_member_count(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_member(IntPtr grpdesc, IntPtr idx);
    internal static IntPtr rd_kafka_MemberDescription_client_id(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_group_instance_id(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_consumer_id(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_host(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_assignment(IntPtr member);
    internal static IntPtr rd_kafka_MemberAssignment_partitions(IntPtr assignment);
    internal static IntPtr rd_kafka_Node_id(IntPtr node);
    internal static IntPtr rd_kafka_Node_host(IntPtr node);
    internal static IntPtr rd_kafka_Node_port(IntPtr node);
    internal static IntPtr rd_kafka_Node_rack(IntPtr node);
    internal static ErrorCode rd_kafka_topic_result_error(IntPtr topicres);
    internal static IntPtr rd_kafka_topic_result_error_string(IntPtr topicres);
    internal static IntPtr rd_kafka_topic_result_name(IntPtr topicres);
    internal static IntPtr rd_kafka_group_result_name(IntPtr groupres);
    internal static IntPtr rd_kafka_group_result_error(IntPtr groupres);
    internal static IntPtr rd_kafka_group_result_partitions(IntPtr groupres);
    internal static void rd_kafka_DescribeUserScramCredentials(IntPtr handle, String[] users, UIntPtr usersCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static ErrorCode rd_kafka_AlterUserScramCredentials(IntPtr handle, IntPtr[] alterations, UIntPtr alterationsCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_UserScramCredentialDeletion_new(string user, ScramMechanism mechanism);
    internal static IntPtr rd_kafka_UserScramCredentialUpsertion_new(string user, ScramMechanism mechanism, int iterations, Byte[] password, IntPtr passwordSize, Byte[] salt, IntPtr saltSize);
    internal static void rd_kafka_UserScramCredentialAlteration_destroy(IntPtr alteration);
    internal static IntPtr rd_kafka_DescribeUserScramCredentials_result_descriptions(IntPtr event_result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_UserScramCredentialsDescription_user(IntPtr description);
    internal static IntPtr rd_kafka_UserScramCredentialsDescription_error(IntPtr description);
    internal static int rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(IntPtr description);
    internal static IntPtr rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(IntPtr description, int i);
    internal static ScramMechanism rd_kafka_ScramCredentialInfo_mechanism(IntPtr scramcredentialinfo);
    internal static int rd_kafka_ScramCredentialInfo_iterations(IntPtr scramcredentialinfo);
    internal static IntPtr rd_kafka_AlterUserScramCredentials_result_responses(IntPtr event_result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_AlterUserScramCredentials_result_response_user(IntPtr element);
    internal static IntPtr rd_kafka_AlterUserScramCredentials_result_response_error(IntPtr element);
    internal static void rd_kafka_ListOffsets(IntPtr handle, IntPtr topic_partition_list, IntPtr options, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_ListOffsets_result_infos(IntPtr resultPtr, UIntPtr& cntp);
    internal static long rd_kafka_ListOffsetsResultInfo_timestamp(IntPtr element);
    internal static IntPtr rd_kafka_ListOffsetsResultInfo_topic_partition(IntPtr element);
    internal static void rd_kafka_DescribeTopics(IntPtr handle, IntPtr topicCollection, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_DescribeTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicCollection_of_topic_names(String[] topics, UIntPtr topicsCnt);
    internal static void rd_kafka_TopicCollection_destroy(IntPtr topic_collection);
    internal static IntPtr rd_kafka_TopicDescription_error(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_name(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_topic_id(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_partitions(IntPtr topicdesc, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicDescription_is_internal(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_authorized_operations(IntPtr topicdesc, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicPartitionInfo_isr(IntPtr topic_partition_info, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicPartitionInfo_leader(IntPtr topic_partition_info);
    internal static int rd_kafka_TopicPartitionInfo_partition(IntPtr topic_partition_info);
    internal static IntPtr rd_kafka_TopicPartitionInfo_replicas(IntPtr topic_partition_info, UIntPtr& cntp);
    internal static void rd_kafka_DescribeCluster(IntPtr handle, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_DescribeCluster_result_nodes(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DescribeCluster_result_authorized_operations(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DescribeCluster_result_controller(IntPtr result);
    internal static IntPtr rd_kafka_DescribeCluster_result_cluster_id(IntPtr result);
    internal static IntPtr rd_kafka_queue_new(IntPtr rk);
    internal static void rd_kafka_queue_destroy(IntPtr rkqu);
    internal static IntPtr rd_kafka_queue_poll(IntPtr rkqu, IntPtr timeout_ms);
    internal static void rd_kafka_event_destroy(IntPtr rkev);
    internal static EventType rd_kafka_event_type(IntPtr rkev);
    internal static IntPtr rd_kafka_event_opaque(IntPtr rkev);
    internal static ErrorCode rd_kafka_event_error(IntPtr rkev);
    internal static IntPtr rd_kafka_event_error_string(IntPtr rkev);
    internal static IntPtr rd_kafka_event_topic_partition_list(IntPtr rkev);
    internal static ErrorCode rd_kafka_error_code(IntPtr error);
    internal static IntPtr rd_kafka_error_string(IntPtr error);
    internal static IntPtr rd_kafka_error_is_fatal(IntPtr error);
    internal static IntPtr rd_kafka_error_is_retriable(IntPtr error);
    internal static IntPtr rd_kafka_error_txn_requires_abort(IntPtr error);
    internal static void rd_kafka_error_destroy(IntPtr error);
}
internal class Confluent.Kafka.Impl.NativeMethods.NativeMethods_Centos8 : object {
    public static string DllName;
    internal static IntPtr rd_kafka_version();
    internal static IntPtr rd_kafka_version_str();
    internal static IntPtr rd_kafka_get_debug_contexts();
    internal static IntPtr rd_kafka_err2str(ErrorCode err);
    internal static ErrorCode rd_kafka_last_error();
    internal static ErrorCode rd_kafka_fatal_error(IntPtr rk, StringBuilder errstr, UIntPtr errstr_size);
    internal static IntPtr rd_kafka_message_errstr(IntPtr rkmessage);
    internal static IntPtr rd_kafka_topic_partition_list_new(IntPtr size);
    internal static void rd_kafka_topic_partition_list_destroy(IntPtr rkparlist);
    internal static IntPtr rd_kafka_topic_partition_list_add(IntPtr rktparlist, string topic, int partition);
    internal static IntPtr rd_kafka_headers_new(IntPtr size);
    internal static void rd_kafka_headers_destroy(IntPtr hdrs);
    internal static ErrorCode rd_kafka_header_add(IntPtr hdrs, IntPtr name, IntPtr name_size, IntPtr value, IntPtr value_size);
    internal static ErrorCode rd_kafka_header_get_all(IntPtr hdrs, IntPtr idx, IntPtr& namep, IntPtr& valuep, IntPtr& sizep);
    internal static long rd_kafka_message_timestamp(IntPtr rkmessage, IntPtr& tstype);
    internal static ErrorCode rd_kafka_message_headers(IntPtr rkmessage, IntPtr& hdrs);
    internal static PersistenceStatus rd_kafka_message_status(IntPtr rkmessage);
    internal static int rd_kafka_message_leader_epoch(IntPtr rkmessage);
    internal static void rd_kafka_message_destroy(IntPtr rkmessage);
    internal static SafeConfigHandle rd_kafka_conf_new();
    internal static void rd_kafka_conf_destroy(IntPtr conf);
    internal static IntPtr rd_kafka_conf_dup(IntPtr conf);
    internal static SafeTopicConfigHandle rd_kafka_default_topic_conf_dup(SafeKafkaHandle rk);
    internal static ConfRes rd_kafka_conf_set(IntPtr conf, string name, string value, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_conf_set_dr_msg_cb(IntPtr conf, DeliveryReportDelegate dr_msg_cb);
    internal static void rd_kafka_conf_set_rebalance_cb(IntPtr conf, RebalanceDelegate rebalance_cb);
    internal static void rd_kafka_conf_set_offset_commit_cb(IntPtr conf, CommitDelegate commit_cb);
    internal static void rd_kafka_conf_set_error_cb(IntPtr conf, ErrorDelegate error_cb);
    internal static void rd_kafka_conf_set_log_cb(IntPtr conf, LogDelegate log_cb);
    internal static void rd_kafka_conf_set_oauthbearer_token_refresh_cb(IntPtr conf, OAuthBearerTokenRefreshDelegate oauthbearer_token_refresh_cb);
    internal static ErrorCode rd_kafka_oauthbearer_set_token(IntPtr rk, string token_value, long md_lifetime_ms, string md_principal_name, String[] extensions, UIntPtr extension_size, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_oauthbearer_set_token_failure(IntPtr rk, string errstr);
    internal static void rd_kafka_conf_set_stats_cb(IntPtr conf, StatsDelegate stats_cb);
    internal static void rd_kafka_conf_set_default_topic_conf(IntPtr conf, IntPtr tconf);
    internal static SafeTopicConfigHandle rd_kafka_conf_get_default_topic_conf(SafeConfigHandle conf);
    internal static ConfRes rd_kafka_conf_get(IntPtr conf, string name, StringBuilder dest, UIntPtr& dest_size);
    internal static ConfRes rd_kafka_topic_conf_get(IntPtr conf, string name, StringBuilder dest, UIntPtr& dest_size);
    internal static IntPtr rd_kafka_conf_dump(IntPtr conf, UIntPtr& cntp);
    internal static IntPtr rd_kafka_topic_conf_dump(IntPtr conf, UIntPtr& cntp);
    internal static void rd_kafka_conf_dump_free(IntPtr arr, UIntPtr cnt);
    internal static SafeTopicConfigHandle rd_kafka_topic_conf_new();
    internal static SafeTopicConfigHandle rd_kafka_topic_conf_dup(SafeTopicConfigHandle conf);
    internal static void rd_kafka_topic_conf_destroy(IntPtr conf);
    internal static ConfRes rd_kafka_topic_conf_set(IntPtr conf, string name, string value, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_topic_conf_set_opaque(IntPtr topic_conf, IntPtr opaque);
    internal static void rd_kafka_topic_conf_set_partitioner_cb(IntPtr topic_conf, PartitionerDelegate partitioner_cb);
    internal static bool rd_kafka_topic_partition_available(IntPtr rkt, int partition);
    internal static int rd_kafka_topic_partition_get_leader_epoch(IntPtr rkt);
    internal static void rd_kafka_topic_partition_set_leader_epoch(IntPtr rkt, int leader_epoch);
    internal static IntPtr rd_kafka_init_transactions(IntPtr rk, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_begin_transaction(IntPtr rk);
    internal static IntPtr rd_kafka_commit_transaction(IntPtr rk, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_abort_transaction(IntPtr rk, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_send_offsets_to_transaction(IntPtr rk, IntPtr offsets, IntPtr consumer_group_metadata, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_consumer_group_metadata(IntPtr rk);
    internal static void rd_kafka_consumer_group_metadata_destroy(IntPtr rk);
    internal static IntPtr rd_kafka_consumer_group_metadata_write(IntPtr cgmd, IntPtr& valuep, IntPtr& sizep);
    internal static IntPtr rd_kafka_consumer_group_metadata_read(IntPtr& cgmdp, Byte[] buffer, IntPtr size);
    internal static SafeKafkaHandle rd_kafka_new(RdKafkaType type, IntPtr conf, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_destroy(IntPtr rk);
    internal static void rd_kafka_destroy_flags(IntPtr rk, IntPtr flags);
    internal static IntPtr rd_kafka_name(IntPtr rk);
    internal static IntPtr rd_kafka_memberid(IntPtr rk);
    internal static IntPtr rd_kafka_Uuid_new(long most_significant_bits, long least_significant_bits);
    internal static IntPtr rd_kafka_Uuid_base64str(IntPtr uuid);
    internal static long rd_kafka_Uuid_most_significant_bits(IntPtr uuid);
    internal static long rd_kafka_Uuid_least_significant_bits(IntPtr uuid);
    internal static void rd_kafka_Uuid_destroy(IntPtr uuid);
    internal static SafeTopicHandle rd_kafka_topic_new(IntPtr rk, IntPtr topic, IntPtr conf);
    internal static void rd_kafka_topic_destroy(IntPtr rk);
    internal static IntPtr rd_kafka_topic_name(IntPtr rkt);
    internal static ErrorCode rd_kafka_poll_set_consumer(IntPtr rk);
    internal static IntPtr rd_kafka_poll(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_query_watermark_offsets(IntPtr rk, string topic, int partition, Int64& low, Int64& high, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_get_watermark_offsets(IntPtr rk, string topic, int partition, Int64& low, Int64& high);
    internal static ErrorCode rd_kafka_offsets_for_times(IntPtr rk, IntPtr offsets, IntPtr timeout_ms);
    internal static void rd_kafka_mem_free(IntPtr rk, IntPtr ptr);
    internal static ErrorCode rd_kafka_subscribe(IntPtr rk, IntPtr topics);
    internal static ErrorCode rd_kafka_unsubscribe(IntPtr rk);
    internal static ErrorCode rd_kafka_subscription(IntPtr rk, IntPtr& topics);
    internal static IntPtr rd_kafka_consumer_poll(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_consumer_close(IntPtr rk);
    internal static ErrorCode rd_kafka_assign(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_incremental_assign(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_incremental_unassign(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_assignment_lost(IntPtr rk);
    internal static IntPtr rd_kafka_rebalance_protocol(IntPtr rk);
    internal static ErrorCode rd_kafka_assignment(IntPtr rk, IntPtr& topics);
    internal static ErrorCode rd_kafka_offsets_store(IntPtr rk, IntPtr offsets);
    internal static ErrorCode rd_kafka_commit(IntPtr rk, IntPtr offsets, bool async);
    internal static ErrorCode rd_kafka_commit_queue(IntPtr rk, IntPtr offsets, IntPtr rkqu, CommitDelegate cb, IntPtr opaque);
    internal static ErrorCode rd_kafka_pause_partitions(IntPtr rk, IntPtr partitions);
    internal static ErrorCode rd_kafka_resume_partitions(IntPtr rk, IntPtr partitions);
    internal static ErrorCode rd_kafka_seek(IntPtr rkt, int partition, long offset, IntPtr timeout_ms);
    internal static IntPtr rd_kafka_seek_partitions(IntPtr rkt, IntPtr partitions, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_committed(IntPtr rk, IntPtr partitions, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_position(IntPtr rk, IntPtr partitions);
    internal static IntPtr rd_kafka_produceva(IntPtr rk, rd_kafka_vu* vus, IntPtr size);
    internal static ErrorCode rd_kafka_flush(IntPtr rk, IntPtr timeout_ms);
    internal static ErrorCode rd_kafka_metadata(IntPtr rk, bool all_topics, IntPtr only_rkt, IntPtr& metadatap, IntPtr timeout_ms);
    internal static void rd_kafka_metadata_destroy(IntPtr metadata);
    internal static ErrorCode rd_kafka_list_groups(IntPtr rk, string group, IntPtr& grplistp, IntPtr timeout_ms);
    internal static void rd_kafka_group_list_destroy(IntPtr grplist);
    internal static IntPtr rd_kafka_brokers_add(IntPtr rk, string brokerlist);
    internal static IntPtr rd_kafka_sasl_set_credentials(IntPtr rk, string username, string password);
    internal static int rd_kafka_outq_len(IntPtr rk);
    internal static IntPtr rd_kafka_AdminOptions_new(IntPtr rk, AdminOp op);
    internal static void rd_kafka_AdminOptions_destroy(IntPtr options);
    internal static ErrorCode rd_kafka_AdminOptions_set_request_timeout(IntPtr options, IntPtr timeout_ms, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_operation_timeout(IntPtr options, IntPtr timeout_ms, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_validate_only(IntPtr options, IntPtr true_or_false, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_incremental(IntPtr options, IntPtr true_or_false, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_AdminOptions_set_broker(IntPtr options, int broker_id, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_AdminOptions_set_opaque(IntPtr options, IntPtr opaque);
    internal static IntPtr rd_kafka_AdminOptions_set_require_stable_offsets(IntPtr options, IntPtr true_or_false);
    internal static IntPtr rd_kafka_AdminOptions_set_include_authorized_operations(IntPtr options, IntPtr true_or_false);
    internal static IntPtr rd_kafka_AdminOptions_set_isolation_level(IntPtr options, IntPtr isolation_level);
    internal static IntPtr rd_kafka_AdminOptions_set_match_consumer_group_states(IntPtr options, ConsumerGroupState[] states, UIntPtr statesCnt);
    internal static IntPtr rd_kafka_NewTopic_new(string topic, IntPtr num_partitions, IntPtr replication_factor, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_NewTopic_destroy(IntPtr new_topic);
    internal static ErrorCode rd_kafka_NewTopic_set_replica_assignment(IntPtr new_topic, int partition, Int32[] broker_ids, UIntPtr broker_id_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static ErrorCode rd_kafka_NewTopic_set_config(IntPtr new_topic, string name, string value);
    internal static void rd_kafka_CreateTopics(IntPtr rk, IntPtr[] new_topics, UIntPtr new_topic_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_CreateTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteTopic_new(string topic);
    internal static void rd_kafka_DeleteTopic_destroy(IntPtr del_topic);
    internal static void rd_kafka_DeleteTopics(IntPtr rk, IntPtr[] del_topics, UIntPtr del_topic_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteGroup_new(string group);
    internal static void rd_kafka_DeleteGroup_destroy(IntPtr del_group);
    internal static void rd_kafka_DeleteGroups(IntPtr rk, IntPtr[] del_groups, UIntPtr del_group_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteGroups_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteRecords_new(IntPtr offsets);
    internal static void rd_kafka_DeleteRecords_destroy(IntPtr del_topic);
    internal static void rd_kafka_DeleteRecords(IntPtr rk, IntPtr[] del_records, UIntPtr del_records_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteRecords_result_offsets(IntPtr result);
    internal static IntPtr rd_kafka_NewPartitions_new(string topic, UIntPtr new_total_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_NewPartitions_destroy(IntPtr new_parts);
    internal static ErrorCode rd_kafka_NewPartitions_set_replica_assignment(IntPtr new_parts, int new_partition_idx, Int32[] broker_ids, UIntPtr broker_id_cnt, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_CreatePartitions(IntPtr rk, IntPtr[] new_parts, UIntPtr new_parts_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_CreatePartitions_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ConfigSource_name(ConfigSource configsource);
    internal static IntPtr rd_kafka_ConfigEntry_name(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_value(IntPtr entry);
    internal static ConfigSource rd_kafka_ConfigEntry_source(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_read_only(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_default(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_sensitive(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_is_synonym(IntPtr entry);
    internal static IntPtr rd_kafka_ConfigEntry_synonyms(IntPtr entry, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ResourceType_name(ResourceType restype);
    internal static IntPtr rd_kafka_ConfigResource_new(ResourceType restype, string resname);
    internal static void rd_kafka_ConfigResource_destroy(IntPtr config);
    internal static ErrorCode rd_kafka_ConfigResource_add_config(IntPtr config, string name, string value);
    internal static ErrorCode rd_kafka_ConfigResource_set_config(IntPtr config, string name, string value);
    internal static ErrorCode rd_kafka_ConfigResource_delete_config(IntPtr config, string name);
    internal static IntPtr rd_kafka_ConfigResource_add_incremental_config(IntPtr config, string name, AlterConfigOpType optype, string value);
    internal static IntPtr rd_kafka_ConfigResource_configs(IntPtr config, UIntPtr& cntp);
    internal static ResourceType rd_kafka_ConfigResource_type(IntPtr config);
    internal static IntPtr rd_kafka_ConfigResource_name(IntPtr config);
    internal static ErrorCode rd_kafka_ConfigResource_error(IntPtr config);
    internal static IntPtr rd_kafka_ConfigResource_error_string(IntPtr config);
    internal static void rd_kafka_AlterConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_AlterConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_IncrementalAlterConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_IncrementalAlterConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_DescribeConfigs(IntPtr rk, IntPtr[] configs, UIntPtr config_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DescribeConfigs_result_resources(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_AclBinding_new(ResourceType restype, string name, ResourcePatternType resource_pattern_type, string principal, string host, AclOperation operation, AclPermissionType permission_type, StringBuilder errstr, UIntPtr errstr_size);
    internal static IntPtr rd_kafka_AclBindingFilter_new(ResourceType restype, string name, ResourcePatternType resource_pattern_type, string principal, string host, AclOperation operation, AclPermissionType permission_type, StringBuilder errstr, UIntPtr errstr_size);
    internal static void rd_kafka_AclBinding_destroy(IntPtr acl_binding);
    internal static ResourceType rd_kafka_AclBinding_restype(IntPtr acl_binding);
    internal static IntPtr rd_kafka_AclBinding_name(IntPtr acl_binding);
    internal static ResourcePatternType rd_kafka_AclBinding_resource_pattern_type(IntPtr acl_binding);
    internal static IntPtr rd_kafka_AclBinding_principal(IntPtr acl_binding);
    internal static IntPtr rd_kafka_AclBinding_host(IntPtr acl_binding);
    internal static AclOperation rd_kafka_AclBinding_operation(IntPtr acl_binding);
    internal static AclPermissionType rd_kafka_AclBinding_permission_type(IntPtr acl_binding);
    internal static void rd_kafka_CreateAcls(IntPtr rk, IntPtr[] new_acls, UIntPtr new_acls_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_CreateAcls_result_acls(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_acl_result_error(IntPtr aclres);
    internal static void rd_kafka_DescribeAcls(IntPtr rk, IntPtr acl_filter, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DescribeAcls_result_acls(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_DeleteAcls(IntPtr rk, IntPtr[] del_acls, UIntPtr del_acls_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteAcls_result_responses(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DeleteAcls_result_response_error(IntPtr result_response);
    internal static IntPtr rd_kafka_DeleteAcls_result_response_matching_acls(IntPtr result_response, UIntPtr& matching_acls_cntp);
    internal static IntPtr rd_kafka_DeleteConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void rd_kafka_DeleteConsumerGroupOffsets_destroy(IntPtr del_grp_offsets);
    internal static void rd_kafka_DeleteConsumerGroupOffsets(IntPtr rk, IntPtr[] del_grp_offsets, UIntPtr del_grp_offsets_cnt, IntPtr options, IntPtr rkqu);
    internal static IntPtr rd_kafka_DeleteConsumerGroupOffsets_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ListConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void rd_kafka_ListConsumerGroupOffsets_destroy(IntPtr groupPartitions);
    internal static IntPtr rd_kafka_ListConsumerGroupOffsets_result_groups(IntPtr resultResponse, UIntPtr& groupsTopicPartitionsCount);
    internal static void rd_kafka_ListConsumerGroupOffsets(IntPtr handle, IntPtr[] listGroupsPartitions, UIntPtr listGroupsPartitionsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_AlterConsumerGroupOffsets_new(string group, IntPtr partitions);
    internal static void rd_kafka_AlterConsumerGroupOffsets_destroy(IntPtr groupPartitions);
    internal static IntPtr rd_kafka_AlterConsumerGroupOffsets_result_groups(IntPtr resultResponse, UIntPtr& groupsTopicPartitionsCount);
    internal static void rd_kafka_AlterConsumerGroupOffsets(IntPtr handle, IntPtr[] alterGroupsPartitions, UIntPtr alterGroupsPartitionsSize, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static void rd_kafka_ListConsumerGroups(IntPtr handle, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_ConsumerGroupListing_group_id(IntPtr grplist);
    internal static IntPtr rd_kafka_ConsumerGroupListing_is_simple_consumer_group(IntPtr grplist);
    internal static ConsumerGroupState rd_kafka_ConsumerGroupListing_state(IntPtr grplist);
    internal static IntPtr rd_kafka_ListConsumerGroups_result_valid(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ListConsumerGroups_result_errors(IntPtr result, UIntPtr& cntp);
    internal static void rd_kafka_DescribeConsumerGroups(IntPtr handle, String[] groups, UIntPtr groupsCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_DescribeConsumerGroups_result_groups(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_group_id(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_error(IntPtr grpdesc);
    internal static int rd_kafka_ConsumerGroupDescription_is_simple_consumer_group(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_partition_assignor(IntPtr grpdesc);
    internal static ConsumerGroupState rd_kafka_ConsumerGroupDescription_state(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_coordinator(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_authorized_operations(IntPtr grpdesc, UIntPtr& cntp);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_member_count(IntPtr grpdesc);
    internal static IntPtr rd_kafka_ConsumerGroupDescription_member(IntPtr grpdesc, IntPtr idx);
    internal static IntPtr rd_kafka_MemberDescription_client_id(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_group_instance_id(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_consumer_id(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_host(IntPtr member);
    internal static IntPtr rd_kafka_MemberDescription_assignment(IntPtr member);
    internal static IntPtr rd_kafka_MemberAssignment_partitions(IntPtr assignment);
    internal static IntPtr rd_kafka_Node_id(IntPtr node);
    internal static IntPtr rd_kafka_Node_host(IntPtr node);
    internal static IntPtr rd_kafka_Node_port(IntPtr node);
    internal static IntPtr rd_kafka_Node_rack(IntPtr node);
    internal static ErrorCode rd_kafka_topic_result_error(IntPtr topicres);
    internal static IntPtr rd_kafka_topic_result_error_string(IntPtr topicres);
    internal static IntPtr rd_kafka_topic_result_name(IntPtr topicres);
    internal static IntPtr rd_kafka_group_result_name(IntPtr groupres);
    internal static IntPtr rd_kafka_group_result_error(IntPtr groupres);
    internal static IntPtr rd_kafka_group_result_partitions(IntPtr groupres);
    internal static void rd_kafka_DescribeUserScramCredentials(IntPtr handle, String[] users, UIntPtr usersCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static ErrorCode rd_kafka_AlterUserScramCredentials(IntPtr handle, IntPtr[] alterations, UIntPtr alterationsCnt, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_UserScramCredentialDeletion_new(string user, ScramMechanism mechanism);
    internal static IntPtr rd_kafka_UserScramCredentialUpsertion_new(string user, ScramMechanism mechanism, int iterations, Byte[] password, IntPtr passwordSize, Byte[] salt, IntPtr saltSize);
    internal static void rd_kafka_UserScramCredentialAlteration_destroy(IntPtr alteration);
    internal static IntPtr rd_kafka_DescribeUserScramCredentials_result_descriptions(IntPtr event_result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_UserScramCredentialsDescription_user(IntPtr description);
    internal static IntPtr rd_kafka_UserScramCredentialsDescription_error(IntPtr description);
    internal static int rd_kafka_UserScramCredentialsDescription_scramcredentialinfo_count(IntPtr description);
    internal static IntPtr rd_kafka_UserScramCredentialsDescription_scramcredentialinfo(IntPtr description, int i);
    internal static ScramMechanism rd_kafka_ScramCredentialInfo_mechanism(IntPtr scramcredentialinfo);
    internal static int rd_kafka_ScramCredentialInfo_iterations(IntPtr scramcredentialinfo);
    internal static IntPtr rd_kafka_AlterUserScramCredentials_result_responses(IntPtr event_result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_AlterUserScramCredentials_result_response_user(IntPtr element);
    internal static IntPtr rd_kafka_AlterUserScramCredentials_result_response_error(IntPtr element);
    internal static void rd_kafka_ListOffsets(IntPtr handle, IntPtr topic_partition_list, IntPtr options, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_ListOffsets_result_infos(IntPtr resultPtr, UIntPtr& cntp);
    internal static long rd_kafka_ListOffsetsResultInfo_timestamp(IntPtr element);
    internal static IntPtr rd_kafka_ListOffsetsResultInfo_topic_partition(IntPtr element);
    internal static void rd_kafka_DescribeTopics(IntPtr handle, IntPtr topicCollection, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_DescribeTopics_result_topics(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicCollection_of_topic_names(String[] topics, UIntPtr topicsCnt);
    internal static void rd_kafka_TopicCollection_destroy(IntPtr topic_collection);
    internal static IntPtr rd_kafka_TopicDescription_error(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_name(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_topic_id(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_partitions(IntPtr topicdesc, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicDescription_is_internal(IntPtr topicdesc);
    internal static IntPtr rd_kafka_TopicDescription_authorized_operations(IntPtr topicdesc, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicPartitionInfo_isr(IntPtr topic_partition_info, UIntPtr& cntp);
    internal static IntPtr rd_kafka_TopicPartitionInfo_leader(IntPtr topic_partition_info);
    internal static int rd_kafka_TopicPartitionInfo_partition(IntPtr topic_partition_info);
    internal static IntPtr rd_kafka_TopicPartitionInfo_replicas(IntPtr topic_partition_info, UIntPtr& cntp);
    internal static void rd_kafka_DescribeCluster(IntPtr handle, IntPtr optionsPtr, IntPtr resultQueuePtr);
    internal static IntPtr rd_kafka_DescribeCluster_result_nodes(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DescribeCluster_result_authorized_operations(IntPtr result, UIntPtr& cntp);
    internal static IntPtr rd_kafka_DescribeCluster_result_controller(IntPtr result);
    internal static IntPtr rd_kafka_DescribeCluster_result_cluster_id(IntPtr result);
    internal static IntPtr rd_kafka_queue_new(IntPtr rk);
    internal static void rd_kafka_queue_destroy(IntPtr rkqu);
    internal static IntPtr rd_kafka_queue_poll(IntPtr rkqu, IntPtr timeout_ms);
    internal static void rd_kafka_event_destroy(IntPtr rkev);
    internal static EventType rd_kafka_event_type(IntPtr rkev);
    internal static IntPtr rd_kafka_event_opaque(IntPtr rkev);
    internal static ErrorCode rd_kafka_event_error(IntPtr rkev);
    internal static IntPtr rd_kafka_event_error_string(IntPtr rkev);
    internal static IntPtr rd_kafka_event_topic_partition_list(IntPtr rkev);
    internal static ErrorCode rd_kafka_error_code(IntPtr error);
    internal static IntPtr rd_kafka_error_string(IntPtr error);
    internal static IntPtr rd_kafka_error_is_fatal(IntPtr error);
    internal static IntPtr rd_kafka_error_is_retriable(IntPtr error);
    internal static IntPtr rd_kafka_error_txn_requires_abort(IntPtr error);
    internal static void rd_kafka_error_destroy(IntPtr error);
}
internal class Confluent.Kafka.Impl.PlatformApis : object {
    private static Lazy`1<DistroInfo> _distroInfo;
    private static PlatformApis();
    public static string GetOSName();
    public static string GetOSVersion();
    private static string GetDistroId();
    private static string GetDistroVersionId();
    private static DistroInfo LoadDistroInfo();
    private static DistroInfo NormalizeDistroInfo(DistroInfo distroInfo);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class Confluent.Kafka.Impl.ptr_and_size : ValueType {
    public IntPtr ptr;
    public UIntPtr size;
}
internal class Confluent.Kafka.Impl.rd_kafka_group_info : ValueType {
    internal rd_kafka_metadata_broker broker;
    internal string group;
    internal ErrorCode err;
    internal string state;
    internal string protocol_type;
    internal string protocol;
    internal IntPtr members;
    internal int member_cnt;
}
internal class Confluent.Kafka.Impl.rd_kafka_group_list : ValueType {
    internal IntPtr groups;
    internal int group_cnt;
}
internal class Confluent.Kafka.Impl.rd_kafka_group_member_info : ValueType {
    internal string member_id;
    internal string client_id;
    internal string client_host;
    internal IntPtr member_metadata;
    internal IntPtr member_metadata_size;
    internal IntPtr member_assignment;
    internal IntPtr member_assignment_size;
}
internal class Confluent.Kafka.Impl.rd_kafka_message : ValueType {
    internal ErrorCode err;
    internal IntPtr rkt;
    internal int partition;
    internal IntPtr val;
    internal UIntPtr len;
    internal IntPtr key;
    internal UIntPtr key_len;
    internal long offset;
    internal IntPtr _private;
}
internal class Confluent.Kafka.Impl.rd_kafka_metadata : ValueType {
    internal int broker_cnt;
    internal IntPtr brokers;
    internal int topic_cnt;
    internal IntPtr topics;
    internal int orig_broker_id;
    internal string orig_broker_name;
}
internal class Confluent.Kafka.Impl.rd_kafka_metadata_broker : ValueType {
    internal int id;
    internal string host;
    internal int port;
}
internal class Confluent.Kafka.Impl.rd_kafka_metadata_partition : ValueType {
    internal int id;
    internal ErrorCode err;
    internal int leader;
    internal int replica_cnt;
    internal IntPtr replicas;
    internal int isr_cnt;
    internal IntPtr isrs;
}
internal class Confluent.Kafka.Impl.rd_kafka_metadata_topic : ValueType {
    internal string topic;
    internal int partition_cnt;
    internal IntPtr partitions;
    internal ErrorCode err;
}
internal class Confluent.Kafka.Impl.rd_kafka_topic_partition : ValueType {
    internal string topic;
    internal int partition;
    internal long offset;
    internal IntPtr metadata;
    internal UIntPtr metadata_size;
    internal IntPtr opaque;
    internal ErrorCode err;
    internal IntPtr _private;
}
internal class Confluent.Kafka.Impl.rd_kafka_topic_partition_list : ValueType {
    internal int cnt;
    internal int size;
    internal IntPtr elems;
}
internal enum Confluent.Kafka.Impl.rd_kafka_vtype : Enum {
    public int value__;
    public static rd_kafka_vtype End;
    public static rd_kafka_vtype Topic;
    public static rd_kafka_vtype Rkt;
    public static rd_kafka_vtype Partition;
    public static rd_kafka_vtype Value;
    public static rd_kafka_vtype Key;
    public static rd_kafka_vtype Opaque;
    public static rd_kafka_vtype MsgFlags;
    public static rd_kafka_vtype Timestamp;
    public static rd_kafka_vtype Header;
    public static rd_kafka_vtype Headers;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class Confluent.Kafka.Impl.rd_kafka_vu : ValueType {
    public rd_kafka_vtype vt;
    public vu_data data;
}
internal enum Confluent.Kafka.Impl.RdKafkaType : Enum {
    public int value__;
    public static RdKafkaType Producer;
    public static RdKafkaType Consumer;
}
internal class Confluent.Kafka.Impl.SafeConfigHandle : SafeHandleZeroIsInvalid {
    internal static SafeConfigHandle Create();
    internal SafeTopicConfigHandle GetDefaultTopicConfig();
    internal IntPtr Dup();
    internal Dictionary`2<string, string> Dump();
    internal void Set(string name, string value);
    internal string Get(string name);
    protected virtual bool ReleaseHandle();
}
internal abstract class Confluent.Kafka.Impl.SafeHandleZeroIsInvalid : SafeHandle {
    private string handleName;
    public bool IsInvalid { get; }
    internal SafeHandleZeroIsInvalid(string handleName);
    internal SafeHandleZeroIsInvalid(string handleName, bool ownsHandle);
    public virtual bool get_IsInvalid();
}
internal class Confluent.Kafka.Impl.SafeKafkaHandle : SafeHandleZeroIsInvalid {
    private static int RD_KAFKA_PARTITION_UA;
    public IClient modreq(System.Runtime.CompilerServices.IsVolatile) owner;
    public RdKafkaType type;
    private object topicHandlesLock;
    private Dictionary`2<string, SafeTopicHandle> topicHandles;
    private string name;
    internal string Name { get; }
    private int OutQueueLength { get; }
    internal bool AssignmentLost { get; }
    internal string RebalanceProtocol { get; }
    internal string MemberId { get; }
    internal SafeTopicHandle newTopic(string topic, IntPtr topicConfigPtr);
    internal void SetOwner(IClient owner);
    public static SafeKafkaHandle Create(RdKafkaType type, IntPtr config, IClient owner);
    public void ThrowIfHandleClosed();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
    internal Error CreatePossiblyFatalMessageError(IntPtr msgPtr);
    internal Error CreatePossiblyFatalError(ErrorCode err, string reason);
    internal Error CreateFatalError();
    internal string get_Name();
    private int get_OutQueueLength();
    internal int Flush(int millisecondsTimeout);
    internal int AddBrokers(string brokers);
    internal void SetSaslCredentials(string username, string password);
    internal int Poll(IntPtr millisecondsTimeout);
    internal SafeTopicHandle NewTopic(string topic, IntPtr config);
    private IntPtr marshalHeaders(IReadOnlyList`1<IHeader> headers);
    internal ErrorCode Produce(string topic, Byte[] val, int valOffset, int valLength, Byte[] key, int keyOffset, int keyLength, int partition, long timestamp, IReadOnlyList`1<IHeader> headers, IntPtr opaque);
    private static Int32[] MarshalCopy(IntPtr source, int length);
    internal Metadata GetMetadata(bool allTopics, SafeTopicHandle topic, int millisecondsTimeout);
    internal ErrorCode PollSetConsumer();
    internal void InitTransactions(int millisecondsTimeout);
    internal void BeginTransaction();
    internal void CommitTransaction(int millisecondsTimeout);
    internal void AbortTransaction(int millisecondsTimeout);
    internal void SendOffsetsToTransaction(IEnumerable`1<TopicPartitionOffset> offsets, IConsumerGroupMetadata groupMetadata, int millisecondsTimeout);
    internal IntPtr GetConsumerGroupMetadata();
    internal void DestroyConsumerGroupMetadata(IntPtr consumerGroupMetadata);
    internal Byte[] SerializeConsumerGroupMetadata(IntPtr consumerGroupMetadata);
    internal IntPtr DeserializeConsumerGroupMetadata(Byte[] buffer);
    internal WatermarkOffsets QueryWatermarkOffsets(string topic, int partition, int millisecondsTimeout);
    internal WatermarkOffsets GetWatermarkOffsets(string topic, int partition);
    internal List`1<TopicPartitionOffset> OffsetsForTimes(IEnumerable`1<TopicPartitionTimestamp> timestampsToSearch, int millisecondsTimeout);
    internal void Subscribe(IEnumerable`1<string> topics);
    internal void Unsubscribe();
    internal IntPtr ConsumerPoll(IntPtr millisecondsTimeout);
    internal void ConsumerClose();
    internal List`1<TopicPartition> GetAssignment();
    internal List`1<string> GetSubscription();
    private void AssignImpl(IEnumerable`1<TopicPartitionOffset> partitions, Func`3<IntPtr, IntPtr, ErrorCode> assignMethodErr, Func`3<IntPtr, IntPtr, IntPtr> assignMethodError);
    internal void Assign(IEnumerable`1<TopicPartitionOffset> partitions);
    internal void IncrementalAssign(IEnumerable`1<TopicPartitionOffset> partitions);
    internal void IncrementalUnassign(IEnumerable`1<TopicPartitionOffset> partitions);
    internal bool get_AssignmentLost();
    internal string get_RebalanceProtocol();
    internal void StoreOffsets(IEnumerable`1<TopicPartitionOffset> offsets);
    private static void DummyOffsetCommitCb(IntPtr rk, ErrorCode err, IntPtr offsets, IntPtr opaque);
    internal List`1<TopicPartitionOffset> Commit(IEnumerable`1<TopicPartitionOffset> offsets);
    internal void Seek(string topic, Partition partition, Offset offset, int millisecondsTimeout, Nullable`1<int> leaderEpoch);
    internal List`1<TopicPartitionError> Pause(IEnumerable`1<TopicPartition> partitions);
    internal List`1<TopicPartitionError> Resume(IEnumerable`1<TopicPartition> partitions);
    internal List`1<TopicPartitionOffset> Committed(IEnumerable`1<TopicPartition> partitions, IntPtr timeout_ms);
    internal List`1<TopicPartitionOffset> Position(IEnumerable`1<TopicPartition> partitions);
    internal string get_MemberId();
    internal static List`1<TopicPartitionError> GetTopicPartitionErrorList(IntPtr listPtr);
    internal static List`1<TopicPartitionOffsetError> GetTopicPartitionOffsetErrorList(IntPtr listPtr);
    internal static List`1<TopicPartition> GetTopicPartitionList(IntPtr listPtr);
    internal static IntPtr GetCTopicPartitionList(IEnumerable`1<TopicPartitionOffset> offsets);
    internal static IntPtr GetCTopicPartitionList(IEnumerable`1<TopicPartition> partitions);
    private static Byte[] CopyBytes(IntPtr ptr, IntPtr len);
    internal GroupInfo ListGroup(string group, int millisecondsTimeout);
    internal List`1<GroupInfo> ListGroups(int millisecondsTimeout);
    private List`1<GroupInfo> ListGroupsImpl(string group, int millisecondsTimeout);
    internal IntPtr CreateQueue();
    internal void DestroyQueue(IntPtr queue);
    internal IntPtr QueuePoll(IntPtr queue, int millisecondsTimeout);
    private void setOption_ValidatOnly(IntPtr optionsPtr, bool validateOnly);
    private void setOption_RequestTimeout(IntPtr optionsPtr, Nullable`1<TimeSpan> timeout);
    private void setOption_OperationTimeout(IntPtr optionsPtr, Nullable`1<TimeSpan> timeout);
    private void setOption_RequireStableOffsets(IntPtr optionsPtr, bool requireStable);
    private void setOption_IncludeAuthorizedOperations(IntPtr optionsPtr, bool includeAuthorizedOperations);
    private void setOption_MatchConsumerGroupStates(IntPtr optionsPtr, ConsumerGroupState[] states);
    private void setOption_IsolationLevel(IntPtr optionsPtr, IsolationLevel IsolationLevel);
    private void setOption_completionSource(IntPtr optionsPtr, IntPtr completionSourcePtr);
    internal void AlterConfigs(IDictionary`2<ConfigResource, List`1<ConfigEntry>> configs, AlterConfigsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void IncrementalAlterConfigs(IDictionary`2<ConfigResource, List`1<ConfigEntry>> configs, IncrementalAlterConfigsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DescribeConfigs(IEnumerable`1<ConfigResource> resources, DescribeConfigsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void CreatePartitions(IEnumerable`1<PartitionsSpecification> newPartitions, CreatePartitionsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DeleteRecords(IEnumerable`1<TopicPartitionOffset> topicPartitionOffsets, DeleteRecordsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DeleteGroups(IList`1<string> deleteGroups, DeleteGroupsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DeleteConsumerGroupOffsets(string group, IEnumerable`1<TopicPartition> partitions, DeleteConsumerGroupOffsetsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DeleteTopics(IEnumerable`1<string> deleteTopics, DeleteTopicsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void CreateTopics(IEnumerable`1<TopicSpecification> newTopics, CreateTopicsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    private static void Validate(AclBinding aclBinding);
    private static void Validate(AclBindingFilter aclBindingFilter);
    internal void CreateAcls(IEnumerable`1<AclBinding> aclBindings, CreateAclsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DescribeAcls(AclBindingFilter aclBindingFilter, DescribeAclsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DeleteAcls(IEnumerable`1<AclBindingFilter> aclBindingFilters, DeleteAclsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void AlterConsumerGroupOffsets(IEnumerable`1<ConsumerGroupTopicPartitionOffsets> groupsPartitions, AlterConsumerGroupOffsetsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void ListConsumerGroupOffsets(IEnumerable`1<ConsumerGroupTopicPartitions> groupsPartitions, ListConsumerGroupOffsetsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void ListConsumerGroups(ListConsumerGroupsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DescribeConsumerGroups(IEnumerable`1<string> groups, DescribeConsumerGroupsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DescribeUserScramCredentials(IEnumerable`1<string> users, DescribeUserScramCredentialsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void AlterUserScramCredentials(IEnumerable`1<UserScramCredentialAlteration> alterations, AlterUserScramCredentialsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void ListOffsets(IEnumerable`1<TopicPartitionOffsetSpec> topicPartitionOffsets, ListOffsetsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DescribeTopics(TopicCollection topicCollection, DescribeTopicsOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void DescribeCluster(DescribeClusterOptions options, IntPtr resultQueuePtr, IntPtr completionSourcePtr);
    internal void OAuthBearerSetToken(string tokenValue, long lifetimeMs, string principalName, IDictionary`2<string, string> extensions);
    internal void OAuthBearerSetTokenFailure(string errstr);
    internal SafeTopicConfigHandle DuplicateDefaultTopicConfig();
}
internal class Confluent.Kafka.Impl.SafeTopicConfigHandle : SafeHandleZeroIsInvalid {
    internal static SafeTopicConfigHandle Create();
    internal SafeTopicConfigHandle Duplicate();
    internal Dictionary`2<string, string> Dump();
    internal void Set(string name, string value);
    internal string Get(string name);
    protected virtual bool ReleaseHandle();
}
internal class Confluent.Kafka.Impl.SafeTopicHandle : SafeHandleZeroIsInvalid {
    private static int RD_KAFKA_PARTITION_UA;
    internal SafeKafkaHandle kafkaHandle;
    protected virtual bool ReleaseHandle();
    internal string GetName();
    internal bool PartitionAvailable(int partition);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class Confluent.Kafka.Impl.vu_data : ValueType {
    public IntPtr topic;
    public int partition;
    public ptr_and_size key;
    public ptr_and_size val;
    public IntPtr opaque;
    public IntPtr msgflags;
    public long timestamp;
    public IntPtr headers;
}
internal static class Confluent.Kafka.Internal.Util : object {
}
public interface Confluent.Kafka.IProducer`2 {
    public abstract virtual Task`1<DeliveryResult`2<TKey, TValue>> ProduceAsync(string topic, Message`2<TKey, TValue> message, CancellationToken cancellationToken);
    public abstract virtual Task`1<DeliveryResult`2<TKey, TValue>> ProduceAsync(TopicPartition topicPartition, Message`2<TKey, TValue> message, CancellationToken cancellationToken);
    public abstract virtual void Produce(string topic, Message`2<TKey, TValue> message, Action`1<DeliveryReport`2<TKey, TValue>> deliveryHandler);
    public abstract virtual void Produce(TopicPartition topicPartition, Message`2<TKey, TValue> message, Action`1<DeliveryReport`2<TKey, TValue>> deliveryHandler);
    public abstract virtual int Poll(TimeSpan timeout);
    public abstract virtual int Flush(TimeSpan timeout);
    public abstract virtual void Flush(CancellationToken cancellationToken);
    public abstract virtual void InitTransactions(TimeSpan timeout);
    public abstract virtual void BeginTransaction();
    public abstract virtual void CommitTransaction(TimeSpan timeout);
    public abstract virtual void CommitTransaction();
    public abstract virtual void AbortTransaction(TimeSpan timeout);
    public abstract virtual void AbortTransaction();
    public abstract virtual void SendOffsetsToTransaction(IEnumerable`1<TopicPartitionOffset> offsets, IConsumerGroupMetadata groupMetadata, TimeSpan timeout);
}
public interface Confluent.Kafka.ISerializer`1 {
    public abstract virtual Byte[] Serialize(T data, SerializationContext context);
}
public enum Confluent.Kafka.IsolationLevel : Enum {
    public int value__;
    public static IsolationLevel ReadUncommitted;
    public static IsolationLevel ReadCommitted;
}
public class Confluent.Kafka.KafkaException : Exception {
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public Error Error { get; }
    public KafkaException(Error error);
    public KafkaException(Error error, Exception innerException);
    public KafkaException(ErrorCode code);
    [CompilerGeneratedAttribute]
public Error get_Error();
}
public class Confluent.Kafka.KafkaRetriableException : KafkaException {
    public KafkaRetriableException(Error error);
}
public class Confluent.Kafka.KafkaTxnRequiresAbortException : KafkaException {
    public KafkaTxnRequiresAbortException(Error error);
}
public static class Confluent.Kafka.Library : object {
    private static int kafkaHandleCreateCount;
    private static int kafkaHandleDestroyCount;
    public static int Version { get; }
    public static string VersionString { get; }
    public static String[] DebugContexts { get; }
    public static bool IsLoaded { get; }
    public static int HandleCount { get; }
    internal static List`1<KeyValuePair`2<string, string>> NameAndVersionConfig { get; }
    public static int get_Version();
    public static string get_VersionString();
    public static String[] get_DebugContexts();
    public static bool get_IsLoaded();
    public static bool Load();
    public static bool Load(string path);
    internal static void IncrementKafkaHandleCreateCount();
    internal static void IncrementKafkaHandleDestroyCount();
    public static int get_HandleCount();
    internal static List`1<KeyValuePair`2<string, string>> get_NameAndVersionConfig();
}
public static class Confluent.Kafka.Loggers : object {
    public static void ConsoleLogger(LogMessage logInfo);
}
public enum Confluent.Kafka.LogLevelType : Enum {
    public int value__;
    public static LogLevelType SysLogLevel;
    public static LogLevelType MicrosoftExtensionsLogging;
    public static LogLevelType SystemDiagnostics;
}
public class Confluent.Kafka.LogMessage : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SyslogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Facility>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    private static Int32[] SystemDiagnosticsLevelLookup;
    private static Int32[] MicrosoftExtensionsLoggingLevelLookup;
    public string Name { get; }
    public SyslogLevel Level { get; }
    public string Facility { get; }
    public string Message { get; }
    public LogMessage(string name, SyslogLevel level, string facility, string message);
    private static LogMessage();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public SyslogLevel get_Level();
    [CompilerGeneratedAttribute]
public string get_Facility();
    [CompilerGeneratedAttribute]
public string get_Message();
    public int LevelAs(LogLevelType type);
}
public class Confluent.Kafka.Message`2 : MessageMetadata {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public TKey Key { get; public set; }
    public TValue Value { get; public set; }
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(TKey value);
    [CompilerGeneratedAttribute]
public TValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(TValue value);
}
public enum Confluent.Kafka.MessageComponentType : Enum {
    public int value__;
    public static MessageComponentType Key;
    public static MessageComponentType Value;
}
public class Confluent.Kafka.MessageMetadata : object {
    [CompilerGeneratedAttribute]
private Timestamp <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Headers <Headers>k__BackingField;
    public Timestamp Timestamp { get; public set; }
    public Headers Headers { get; public set; }
    [CompilerGeneratedAttribute]
public Timestamp get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(Timestamp value);
    [CompilerGeneratedAttribute]
public Headers get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(Headers value);
}
public class Confluent.Kafka.MessageNullException : NullReferenceException {
}
public class Confluent.Kafka.Metadata : object {
    [CompilerGeneratedAttribute]
private List`1<BrokerMetadata> <Brokers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TopicMetadata> <Topics>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OriginatingBrokerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginatingBrokerName>k__BackingField;
    public List`1<BrokerMetadata> Brokers { get; }
    public List`1<TopicMetadata> Topics { get; }
    public int OriginatingBrokerId { get; }
    public string OriginatingBrokerName { get; }
    public Metadata(List`1<BrokerMetadata> brokers, List`1<TopicMetadata> topics, int originatingBrokerId, string originatingBrokerName);
    [CompilerGeneratedAttribute]
public List`1<BrokerMetadata> get_Brokers();
    [CompilerGeneratedAttribute]
public List`1<TopicMetadata> get_Topics();
    [CompilerGeneratedAttribute]
public int get_OriginatingBrokerId();
    [CompilerGeneratedAttribute]
public string get_OriginatingBrokerName();
    public virtual string ToString();
}
public class Confluent.Kafka.Node : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Rack>k__BackingField;
    public int Id { get; public set; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public string Rack { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public string get_Rack();
    [CompilerGeneratedAttribute]
public void set_Rack(string value);
    public virtual string ToString();
}
public class Confluent.Kafka.Null : object {
}
public class Confluent.Kafka.Offset : ValueType {
    private static long RD_KAFKA_OFFSET_BEGINNING;
    private static long RD_KAFKA_OFFSET_END;
    private static long RD_KAFKA_OFFSET_STORED;
    private static long RD_KAFKA_OFFSET_INVALID;
    public static Offset Beginning;
    public static Offset End;
    public static Offset Stored;
    public static Offset Unset;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public long Value { get; }
    public bool IsSpecial { get; }
    public Offset(long offset);
    private static Offset();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Value();
    public bool get_IsSpecial();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Offset other);
    public static bool op_Equality(Offset a, Offset b);
    public static bool op_Inequality(Offset a, Offset b);
    public static bool op_GreaterThan(Offset a, Offset b);
    public static bool op_LessThan(Offset a, Offset b);
    public static bool op_GreaterThanOrEqual(Offset a, Offset b);
    public static bool op_LessThanOrEqual(Offset a, Offset b);
    public static Offset op_Addition(Offset a, int b);
    public static Offset op_Addition(Offset a, long b);
    public virtual int GetHashCode();
    public static Offset op_Implicit(long v);
    public static long op_Implicit(Offset o);
    public virtual string ToString();
}
public class Confluent.Kafka.Partition : ValueType {
    private static int RD_KAFKA_PARTITION_UA;
    public static Partition Any;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public bool IsSpecial { get; }
    public Partition(int partition);
    private static Partition();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Value();
    public bool get_IsSpecial();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Partition other);
    public static bool op_Equality(Partition a, Partition b);
    public static bool op_Inequality(Partition a, Partition b);
    public static bool op_GreaterThan(Partition a, Partition b);
    public static bool op_LessThan(Partition a, Partition b);
    public static bool op_GreaterThanOrEqual(Partition a, Partition b);
    public static bool op_LessThanOrEqual(Partition a, Partition b);
    public virtual int GetHashCode();
    public static Partition op_Implicit(int v);
    public static int op_Implicit(Partition o);
    public virtual string ToString();
}
public enum Confluent.Kafka.PartitionAssignmentStrategy : Enum {
    public int value__;
    public static PartitionAssignmentStrategy Range;
    public static PartitionAssignmentStrategy RoundRobin;
    public static PartitionAssignmentStrategy CooperativeSticky;
}
public enum Confluent.Kafka.Partitioner : Enum {
    public int value__;
    public static Partitioner Random;
    public static Partitioner Consistent;
    public static Partitioner ConsistentRandom;
    public static Partitioner Murmur2;
    public static Partitioner Murmur2Random;
}
public class Confluent.Kafka.PartitionerDelegate : MulticastDelegate {
    public PartitionerDelegate(object object, IntPtr method);
    public virtual Partition Invoke(string topic, int partitionCount, ReadOnlySpan`1<byte> keyData, bool keyIsNull);
    public virtual IAsyncResult BeginInvoke(string topic, int partitionCount, ReadOnlySpan`1<byte> keyData, bool keyIsNull, AsyncCallback callback, object object);
    public virtual Partition EndInvoke(IAsyncResult result);
}
public class Confluent.Kafka.PartitionMetadata : object {
    [CompilerGeneratedAttribute]
private int <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Leader>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Replicas>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <InSyncReplicas>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public int PartitionId { get; }
    public int Leader { get; }
    public Int32[] Replicas { get; }
    public Int32[] InSyncReplicas { get; }
    public Error Error { get; }
    public PartitionMetadata(int partitionId, int leader, Int32[] replicas, Int32[] inSyncReplicas, Error error);
    [CompilerGeneratedAttribute]
public int get_PartitionId();
    [CompilerGeneratedAttribute]
public int get_Leader();
    [CompilerGeneratedAttribute]
public Int32[] get_Replicas();
    [CompilerGeneratedAttribute]
public Int32[] get_InSyncReplicas();
    [CompilerGeneratedAttribute]
public Error get_Error();
    public virtual string ToString();
}
public enum Confluent.Kafka.PersistenceStatus : Enum {
    public int value__;
    public static PersistenceStatus NotPersisted;
    public static PersistenceStatus PossiblyPersisted;
    public static PersistenceStatus Persisted;
}
public class Confluent.Kafka.ProduceException`2 : KafkaException {
    [CompilerGeneratedAttribute]
private DeliveryResult`2<TKey, TValue> <DeliveryResult>k__BackingField;
    public DeliveryResult`2<TKey, TValue> DeliveryResult { get; }
    public ProduceException`2(Error error, DeliveryResult`2<TKey, TValue> deliveryResult, Exception innerException);
    public ProduceException`2(Error error, DeliveryResult`2<TKey, TValue> deliveryResult);
    [CompilerGeneratedAttribute]
public DeliveryResult`2<TKey, TValue> get_DeliveryResult();
}
internal class Confluent.Kafka.Producer`2 : object {
    private ISerializer`1<TKey> keySerializer;
    private ISerializer`1<TValue> valueSerializer;
    private IAsyncSerializer`1<TKey> asyncKeySerializer;
    private IAsyncSerializer`1<TValue> asyncValueSerializer;
    private static Dictionary`2<Type, object> defaultSerializers;
    private int cancellationDelayMaxMs;
    private bool disposeHasBeenCalled;
    private object disposeHasBeenCalledLockObj;
    private bool manualPoll;
    private bool enableDeliveryReports;
    private bool enableDeliveryReportKey;
    private bool enableDeliveryReportValue;
    private bool enableDeliveryReportTimestamp;
    private bool enableDeliveryReportHeaders;
    private bool enableDeliveryReportPersistedStatus;
    private SafeKafkaHandle ownedKafkaHandle;
    private Handle borrowedHandle;
    private List`1<GCHandle> partitionerHandles;
    private Task callbackTask;
    private CancellationTokenSource callbackCts;
    private int eventsServedCount;
    private object pollSyncObj;
    private Exception handlerException;
    private Action`1<Error> errorHandler;
    private ErrorDelegate errorCallbackDelegate;
    private Action`1<string> statisticsHandler;
    private StatsDelegate statisticsCallbackDelegate;
    private Action`1<string> oAuthBearerTokenRefreshHandler;
    private OAuthBearerTokenRefreshDelegate oAuthBearerTokenRefreshCallbackDelegate;
    private Action`1<LogMessage> logHandler;
    private object loggerLockObj;
    private LogDelegate logCallbackDelegate;
    private DeliveryReportDelegate DeliveryReportCallback;
    private SafeKafkaHandle KafkaHandle { get; }
    public string Name { get; }
    public Handle Handle { get; }
    internal Producer`2(DependentProducerBuilder`2<TKey, TValue> builder);
    internal Producer`2(ProducerBuilder`2<TKey, TValue> builder);
    private static Producer`2();
    private SafeKafkaHandle get_KafkaHandle();
    private Task StartPollTask(CancellationToken ct);
    private void ErrorCallback(IntPtr rk, ErrorCode err, string reason, IntPtr opaque);
    private int StatisticsCallback(IntPtr rk, IntPtr json, UIntPtr json_len, IntPtr opaque);
    private void OAuthBearerTokenRefreshCallback(IntPtr rk, IntPtr oauthbearer_config, IntPtr opaque);
    private void LogCallback(IntPtr rk, SyslogLevel level, string fac, string buf);
    private void DeliveryReportCallbackImpl(IntPtr rk, IntPtr rkmessage, IntPtr opaque);
    private void ProduceImpl(string topic, Byte[] val, int valOffset, int valLength, Byte[] key, int keyOffset, int keyLength, Timestamp timestamp, Partition partition, IReadOnlyList`1<IHeader> headers, IDeliveryHandler deliveryHandler);
    public sealed virtual int Poll(TimeSpan timeout);
    public sealed virtual int Flush(TimeSpan timeout);
    public sealed virtual void Flush(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual string get_Name();
    public sealed virtual int AddBrokers(string brokers);
    public sealed virtual void SetSaslCredentials(string username, string password);
    public sealed virtual Handle get_Handle();
    private void InitializeSerializers(ISerializer`1<TKey> keySerializer, ISerializer`1<TValue> valueSerializer, IAsyncSerializer`1<TKey> asyncKeySerializer, IAsyncSerializer`1<TValue> asyncValueSerializer);
    [AsyncStateMachineAttribute("Confluent.Kafka.Producer`2/<ProduceAsync>d__57")]
public sealed virtual Task`1<DeliveryResult`2<TKey, TValue>> ProduceAsync(TopicPartition topicPartition, Message`2<TKey, TValue> message, CancellationToken cancellationToken);
    public sealed virtual Task`1<DeliveryResult`2<TKey, TValue>> ProduceAsync(string topic, Message`2<TKey, TValue> message, CancellationToken cancellationToken);
    public sealed virtual void Produce(string topic, Message`2<TKey, TValue> message, Action`1<DeliveryReport`2<TKey, TValue>> deliveryHandler);
    public sealed virtual void Produce(TopicPartition topicPartition, Message`2<TKey, TValue> message, Action`1<DeliveryReport`2<TKey, TValue>> deliveryHandler);
    public sealed virtual void InitTransactions(TimeSpan timeout);
    public sealed virtual void BeginTransaction();
    public sealed virtual void CommitTransaction(TimeSpan timeout);
    public sealed virtual void CommitTransaction();
    public sealed virtual void AbortTransaction(TimeSpan timeout);
    public sealed virtual void AbortTransaction();
    public sealed virtual void SendOffsetsToTransaction(IEnumerable`1<TopicPartitionOffset> offsets, IConsumerGroupMetadata groupMetadata, TimeSpan timeout);
    [CompilerGeneratedAttribute]
private void <.ctor>b__56_6(SafeTopicConfigHandle topicConfigHandle, PartitionerDelegate partitioner);
}
public class Confluent.Kafka.ProducerBuilder`2 : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, string>> <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IProducer`2<TKey, TValue>, Error> <ErrorHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IProducer`2<TKey, TValue>, LogMessage> <LogHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IProducer`2<TKey, TValue>, string> <StatisticsHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IProducer`2<TKey, TValue>, string> <OAuthBearerTokenRefreshHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, PartitionerDelegate> <Partitioners>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionerDelegate <DefaultPartitioner>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializer`1<TKey> <KeySerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializer`1<TValue> <ValueSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IAsyncSerializer`1<TKey> <AsyncKeySerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IAsyncSerializer`1<TValue> <AsyncValueSerializer>k__BackingField;
    protected internal IEnumerable`1<KeyValuePair`2<string, string>> Config { get; protected internal set; }
    protected internal Action`2<IProducer`2<TKey, TValue>, Error> ErrorHandler { get; protected internal set; }
    protected internal Action`2<IProducer`2<TKey, TValue>, LogMessage> LogHandler { get; protected internal set; }
    protected internal Action`2<IProducer`2<TKey, TValue>, string> StatisticsHandler { get; protected internal set; }
    protected internal Action`2<IProducer`2<TKey, TValue>, string> OAuthBearerTokenRefreshHandler { get; protected internal set; }
    protected internal Dictionary`2<string, PartitionerDelegate> Partitioners { get; protected internal set; }
    protected internal PartitionerDelegate DefaultPartitioner { get; protected internal set; }
    protected internal ISerializer`1<TKey> KeySerializer { get; protected internal set; }
    protected internal ISerializer`1<TValue> ValueSerializer { get; protected internal set; }
    protected internal IAsyncSerializer`1<TKey> AsyncKeySerializer { get; protected internal set; }
    protected internal IAsyncSerializer`1<TValue> AsyncValueSerializer { get; protected internal set; }
    public ProducerBuilder`2(IEnumerable`1<KeyValuePair`2<string, string>> config);
    [CompilerGeneratedAttribute]
protected internal IEnumerable`1<KeyValuePair`2<string, string>> get_Config();
    [CompilerGeneratedAttribute]
protected internal void set_Config(IEnumerable`1<KeyValuePair`2<string, string>> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IProducer`2<TKey, TValue>, Error> get_ErrorHandler();
    [CompilerGeneratedAttribute]
protected internal void set_ErrorHandler(Action`2<IProducer`2<TKey, TValue>, Error> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IProducer`2<TKey, TValue>, LogMessage> get_LogHandler();
    [CompilerGeneratedAttribute]
protected internal void set_LogHandler(Action`2<IProducer`2<TKey, TValue>, LogMessage> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IProducer`2<TKey, TValue>, string> get_StatisticsHandler();
    [CompilerGeneratedAttribute]
protected internal void set_StatisticsHandler(Action`2<IProducer`2<TKey, TValue>, string> value);
    [CompilerGeneratedAttribute]
protected internal Action`2<IProducer`2<TKey, TValue>, string> get_OAuthBearerTokenRefreshHandler();
    [CompilerGeneratedAttribute]
protected internal void set_OAuthBearerTokenRefreshHandler(Action`2<IProducer`2<TKey, TValue>, string> value);
    [CompilerGeneratedAttribute]
protected internal Dictionary`2<string, PartitionerDelegate> get_Partitioners();
    [CompilerGeneratedAttribute]
protected internal void set_Partitioners(Dictionary`2<string, PartitionerDelegate> value);
    [CompilerGeneratedAttribute]
protected internal PartitionerDelegate get_DefaultPartitioner();
    [CompilerGeneratedAttribute]
protected internal void set_DefaultPartitioner(PartitionerDelegate value);
    [CompilerGeneratedAttribute]
protected internal ISerializer`1<TKey> get_KeySerializer();
    [CompilerGeneratedAttribute]
protected internal void set_KeySerializer(ISerializer`1<TKey> value);
    [CompilerGeneratedAttribute]
protected internal ISerializer`1<TValue> get_ValueSerializer();
    [CompilerGeneratedAttribute]
protected internal void set_ValueSerializer(ISerializer`1<TValue> value);
    [CompilerGeneratedAttribute]
protected internal IAsyncSerializer`1<TKey> get_AsyncKeySerializer();
    [CompilerGeneratedAttribute]
protected internal void set_AsyncKeySerializer(IAsyncSerializer`1<TKey> value);
    [CompilerGeneratedAttribute]
protected internal IAsyncSerializer`1<TValue> get_AsyncValueSerializer();
    [CompilerGeneratedAttribute]
protected internal void set_AsyncValueSerializer(IAsyncSerializer`1<TValue> value);
    internal Config<TKey, TValue> ConstructBaseConfig(Producer`2<TKey, TValue> producer);
    public ProducerBuilder`2<TKey, TValue> SetStatisticsHandler(Action`2<IProducer`2<TKey, TValue>, string> statisticsHandler);
    public ProducerBuilder`2<TKey, TValue> SetPartitioner(string topic, PartitionerDelegate partitioner);
    public ProducerBuilder`2<TKey, TValue> SetDefaultPartitioner(PartitionerDelegate partitioner);
    public ProducerBuilder`2<TKey, TValue> SetErrorHandler(Action`2<IProducer`2<TKey, TValue>, Error> errorHandler);
    public ProducerBuilder`2<TKey, TValue> SetLogHandler(Action`2<IProducer`2<TKey, TValue>, LogMessage> logHandler);
    public ProducerBuilder`2<TKey, TValue> SetOAuthBearerTokenRefreshHandler(Action`2<IProducer`2<TKey, TValue>, string> oAuthBearerTokenRefreshHandler);
    public ProducerBuilder`2<TKey, TValue> SetKeySerializer(ISerializer`1<TKey> serializer);
    public ProducerBuilder`2<TKey, TValue> SetValueSerializer(ISerializer`1<TValue> serializer);
    public ProducerBuilder`2<TKey, TValue> SetKeySerializer(IAsyncSerializer`1<TKey> serializer);
    public ProducerBuilder`2<TKey, TValue> SetValueSerializer(IAsyncSerializer`1<TValue> serializer);
    public virtual IProducer`2<TKey, TValue> Build();
}
public class Confluent.Kafka.ProducerConfig : ClientConfig {
    public Nullable`1<bool> EnableBackgroundPoll { get; public set; }
    public Nullable`1<bool> EnableDeliveryReports { get; public set; }
    public string DeliveryReportFields { get; public set; }
    public Nullable`1<int> RequestTimeoutMs { get; public set; }
    public Nullable`1<int> MessageTimeoutMs { get; public set; }
    public Nullable`1<Partitioner> Partitioner { get; public set; }
    public Nullable`1<int> CompressionLevel { get; public set; }
    public string TransactionalId { get; public set; }
    public Nullable`1<int> TransactionTimeoutMs { get; public set; }
    public Nullable`1<bool> EnableIdempotence { get; public set; }
    public Nullable`1<bool> EnableGaplessGuarantee { get; public set; }
    public Nullable`1<int> QueueBufferingMaxMessages { get; public set; }
    public Nullable`1<int> QueueBufferingMaxKbytes { get; public set; }
    public Nullable`1<double> LingerMs { get; public set; }
    public Nullable`1<int> MessageSendMaxRetries { get; public set; }
    public Nullable`1<int> QueueBufferingBackpressureThreshold { get; public set; }
    public Nullable`1<CompressionType> CompressionType { get; public set; }
    public Nullable`1<int> BatchNumMessages { get; public set; }
    public Nullable`1<int> BatchSize { get; public set; }
    public Nullable`1<int> StickyPartitioningLingerMs { get; public set; }
    public ProducerConfig(ClientConfig config);
    public ProducerConfig(IDictionary`2<string, string> config);
    public ProducerConfig ThrowIfContainsNonUserConfigurable();
    public Nullable`1<bool> get_EnableBackgroundPoll();
    public void set_EnableBackgroundPoll(Nullable`1<bool> value);
    public Nullable`1<bool> get_EnableDeliveryReports();
    public void set_EnableDeliveryReports(Nullable`1<bool> value);
    public string get_DeliveryReportFields();
    public void set_DeliveryReportFields(string value);
    public Nullable`1<int> get_RequestTimeoutMs();
    public void set_RequestTimeoutMs(Nullable`1<int> value);
    public Nullable`1<int> get_MessageTimeoutMs();
    public void set_MessageTimeoutMs(Nullable`1<int> value);
    public Nullable`1<Partitioner> get_Partitioner();
    public void set_Partitioner(Nullable`1<Partitioner> value);
    public Nullable`1<int> get_CompressionLevel();
    public void set_CompressionLevel(Nullable`1<int> value);
    public string get_TransactionalId();
    public void set_TransactionalId(string value);
    public Nullable`1<int> get_TransactionTimeoutMs();
    public void set_TransactionTimeoutMs(Nullable`1<int> value);
    public Nullable`1<bool> get_EnableIdempotence();
    public void set_EnableIdempotence(Nullable`1<bool> value);
    public Nullable`1<bool> get_EnableGaplessGuarantee();
    public void set_EnableGaplessGuarantee(Nullable`1<bool> value);
    public Nullable`1<int> get_QueueBufferingMaxMessages();
    public void set_QueueBufferingMaxMessages(Nullable`1<int> value);
    public Nullable`1<int> get_QueueBufferingMaxKbytes();
    public void set_QueueBufferingMaxKbytes(Nullable`1<int> value);
    public Nullable`1<double> get_LingerMs();
    public void set_LingerMs(Nullable`1<double> value);
    public Nullable`1<int> get_MessageSendMaxRetries();
    public void set_MessageSendMaxRetries(Nullable`1<int> value);
    public Nullable`1<int> get_QueueBufferingBackpressureThreshold();
    public void set_QueueBufferingBackpressureThreshold(Nullable`1<int> value);
    public Nullable`1<CompressionType> get_CompressionType();
    public void set_CompressionType(Nullable`1<CompressionType> value);
    public Nullable`1<int> get_BatchNumMessages();
    public void set_BatchNumMessages(Nullable`1<int> value);
    public Nullable`1<int> get_BatchSize();
    public void set_BatchSize(Nullable`1<int> value);
    public Nullable`1<int> get_StickyPartitioningLingerMs();
    public void set_StickyPartitioningLingerMs(Nullable`1<int> value);
}
public enum Confluent.Kafka.SaslMechanism : Enum {
    public int value__;
    public static SaslMechanism Gssapi;
    public static SaslMechanism Plain;
    public static SaslMechanism ScramSha256;
    public static SaslMechanism ScramSha512;
    public static SaslMechanism OAuthBearer;
}
public enum Confluent.Kafka.SaslOauthbearerMethod : Enum {
    public int value__;
    public static SaslOauthbearerMethod Default;
    public static SaslOauthbearerMethod Oidc;
}
public enum Confluent.Kafka.SecurityProtocol : Enum {
    public int value__;
    public static SecurityProtocol Plaintext;
    public static SecurityProtocol Ssl;
    public static SecurityProtocol SaslPlaintext;
    public static SecurityProtocol SaslSsl;
}
public class Confluent.Kafka.SerializationContext : ValueType {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageComponentType <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private Headers <Headers>k__BackingField;
    public static SerializationContext Empty { get; }
    public string Topic { get; private set; }
    public MessageComponentType Component { get; private set; }
    public Headers Headers { get; private set; }
    public SerializationContext(MessageComponentType component, string topic, Headers headers);
    public static SerializationContext get_Empty();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
private void set_Topic(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MessageComponentType get_Component();
    [CompilerGeneratedAttribute]
private void set_Component(MessageComponentType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Headers get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(Headers value);
}
public static class Confluent.Kafka.Serializers : object {
    public static ISerializer`1<string> Utf8;
    public static ISerializer`1<Null> Null;
    public static ISerializer`1<long> Int64;
    public static ISerializer`1<int> Int32;
    public static ISerializer`1<float> Single;
    public static ISerializer`1<double> Double;
    public static ISerializer`1<Byte[]> ByteArray;
    private static Serializers();
}
public enum Confluent.Kafka.SslEndpointIdentificationAlgorithm : Enum {
    public int value__;
    public static SslEndpointIdentificationAlgorithm None;
    public static SslEndpointIdentificationAlgorithm Https;
}
[ExtensionAttribute]
internal static class Confluent.Kafka.StringExtensions : object {
    [ExtensionAttribute]
internal static Encoding ToEncoding(string encodingName);
    [ExtensionAttribute]
internal static string Quote(bool b);
    [ExtensionAttribute]
internal static string Quote(string str);
}
public class Confluent.Kafka.SyncOverAsync.SyncOverAsyncDeserializer`1 : object {
    [CompilerGeneratedAttribute]
private IAsyncDeserializer`1<T> <asyncDeserializer>k__BackingField;
    private IAsyncDeserializer`1<T> asyncDeserializer { get; }
    public SyncOverAsyncDeserializer`1(IAsyncDeserializer`1<T> asyncDeserializer);
    [CompilerGeneratedAttribute]
private IAsyncDeserializer`1<T> get_asyncDeserializer();
    public sealed virtual T Deserialize(ReadOnlySpan`1<byte> data, bool isNull, SerializationContext context);
}
[ExtensionAttribute]
public static class Confluent.Kafka.SyncOverAsync.SyncOverAsyncDeserializerExtensionMethods : object {
    [ExtensionAttribute]
public static IDeserializer`1<T> AsSyncOverAsync(IAsyncDeserializer`1<T> asyncDeserializer);
}
public class Confluent.Kafka.SyncOverAsync.SyncOverAsyncSerializer`1 : object {
    [CompilerGeneratedAttribute]
private IAsyncSerializer`1<T> <asyncSerializer>k__BackingField;
    private IAsyncSerializer`1<T> asyncSerializer { get; }
    public SyncOverAsyncSerializer`1(IAsyncSerializer`1<T> asyncSerializer);
    [CompilerGeneratedAttribute]
private IAsyncSerializer`1<T> get_asyncSerializer();
    public sealed virtual Byte[] Serialize(T data, SerializationContext context);
}
[ExtensionAttribute]
public static class Confluent.Kafka.SyncOverAsync.SyncOverAsyncSerializerExtensionMethods : object {
    [ExtensionAttribute]
public static ISerializer`1<T> AsSyncOverAsync(IAsyncSerializer`1<T> asyncSerializer);
}
public enum Confluent.Kafka.SyslogLevel : Enum {
    public int value__;
    public static SyslogLevel Emergency;
    public static SyslogLevel Alert;
    public static SyslogLevel Critical;
    public static SyslogLevel Error;
    public static SyslogLevel Warning;
    public static SyslogLevel Notice;
    public static SyslogLevel Info;
    public static SyslogLevel Debug;
}
[ExtensionAttribute]
internal static class Confluent.Kafka.TimeSpanExtensions : object {
    [ExtensionAttribute]
internal static int TotalMillisecondsAsInt(TimeSpan timespan);
}
public class Confluent.Kafka.Timestamp : ValueType {
    private static long RD_KAFKA_NO_TIMESTAMP;
    public static DateTime UnixTimeEpoch;
    private static long UnixTimeEpochMilliseconds;
    [CompilerGeneratedAttribute]
private TimestampType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UnixTimestampMs>k__BackingField;
    public static Timestamp Default { get; }
    public TimestampType Type { get; }
    public long UnixTimestampMs { get; }
    public DateTime UtcDateTime { get; }
    public Timestamp(long unixTimestampMs, TimestampType type);
    public Timestamp(DateTime dateTime, TimestampType type);
    public Timestamp(DateTime dateTime);
    public Timestamp(DateTimeOffset dateTimeOffset);
    private static Timestamp();
    public static Timestamp get_Default();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TimestampType get_Type();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_UnixTimestampMs();
    public DateTime get_UtcDateTime();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Timestamp other);
    public virtual int GetHashCode();
    public static bool op_Equality(Timestamp a, Timestamp b);
    public static bool op_Inequality(Timestamp a, Timestamp b);
    public static long DateTimeToUnixTimestampMs(DateTime dateTime);
    public static DateTime UnixTimestampMsToDateTime(long unixMillisecondsTimestamp);
}
public enum Confluent.Kafka.TimestampType : Enum {
    public int value__;
    public static TimestampType NotAvailable;
    public static TimestampType CreateTime;
    public static TimestampType LogAppendTime;
}
public class Confluent.Kafka.TopicCollection : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Topics>k__BackingField;
    internal IEnumerable`1<string> Topics { get; internal set; }
    [CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_Topics();
    [CompilerGeneratedAttribute]
internal void set_Topics(IEnumerable`1<string> value);
    public static TopicCollection OfTopicNames(IEnumerable`1<string> topics);
    public virtual string ToString();
}
public class Confluent.Kafka.TopicMetadata : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PartitionMetadata> <Partitions>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Topic { get; }
    public List`1<PartitionMetadata> Partitions { get; }
    public Error Error { get; }
    public TopicMetadata(string topic, List`1<PartitionMetadata> partitions, Error error);
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public List`1<PartitionMetadata> get_Partitions();
    [CompilerGeneratedAttribute]
public Error get_Error();
    public virtual string ToString();
}
public class Confluent.Kafka.TopicPartition : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Partition <Partition>k__BackingField;
    public string Topic { get; }
    public Partition Partition { get; }
    public TopicPartition(string topic, Partition partition);
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public Partition get_Partition();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TopicPartition a, TopicPartition b);
    public static bool op_Inequality(TopicPartition a, TopicPartition b);
    public virtual string ToString();
    public sealed virtual int CompareTo(object obj);
}
public class Confluent.Kafka.TopicPartitionError : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Partition <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Topic { get; }
    public Partition Partition { get; }
    public Error Error { get; }
    public TopicPartition TopicPartition { get; }
    public TopicPartitionError(TopicPartition tp, Error error);
    public TopicPartitionError(string topic, Partition partition, Error error);
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public Partition get_Partition();
    [CompilerGeneratedAttribute]
public Error get_Error();
    public TopicPartition get_TopicPartition();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TopicPartitionError a, TopicPartitionError b);
    public static bool op_Inequality(TopicPartitionError a, TopicPartitionError b);
    public virtual string ToString();
}
public class Confluent.Kafka.TopicPartitionException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<TopicPartitionError> <Results>k__BackingField;
    public List`1<TopicPartitionError> Results { get; }
    public TopicPartitionException(List`1<TopicPartitionError> results);
    [CompilerGeneratedAttribute]
public List`1<TopicPartitionError> get_Results();
}
public class Confluent.Kafka.TopicPartitionInfo : object {
    [CompilerGeneratedAttribute]
private int <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Leader>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Node> <Replicas>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Node> <ISR>k__BackingField;
    public int Partition { get; public set; }
    public Node Leader { get; public set; }
    public List`1<Node> Replicas { get; public set; }
    public List`1<Node> ISR { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Partition();
    [CompilerGeneratedAttribute]
public void set_Partition(int value);
    [CompilerGeneratedAttribute]
public Node get_Leader();
    [CompilerGeneratedAttribute]
public void set_Leader(Node value);
    [CompilerGeneratedAttribute]
public List`1<Node> get_Replicas();
    [CompilerGeneratedAttribute]
public void set_Replicas(List`1<Node> value);
    [CompilerGeneratedAttribute]
public List`1<Node> get_ISR();
    [CompilerGeneratedAttribute]
public void set_ISR(List`1<Node> value);
    public virtual string ToString();
}
public class Confluent.Kafka.TopicPartitionOffset : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Partition <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LeaderEpoch>k__BackingField;
    public string Topic { get; }
    public Partition Partition { get; }
    public Offset Offset { get; }
    public Nullable`1<int> LeaderEpoch { get; }
    public TopicPartition TopicPartition { get; }
    public TopicPartitionOffset(TopicPartition tp, Offset offset);
    public TopicPartitionOffset(TopicPartition tp, Offset offset, Nullable`1<int> leaderEpoch);
    public TopicPartitionOffset(string topic, Partition partition, Offset offset);
    public TopicPartitionOffset(string topic, Partition partition, Offset offset, Nullable`1<int> leaderEpoch);
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public Partition get_Partition();
    [CompilerGeneratedAttribute]
public Offset get_Offset();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LeaderEpoch();
    public TopicPartition get_TopicPartition();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TopicPartitionOffset a, TopicPartitionOffset b);
    public static bool op_Inequality(TopicPartitionOffset a, TopicPartitionOffset b);
    public virtual string ToString();
}
public class Confluent.Kafka.TopicPartitionOffsetError : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Partition <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LeaderEpoch>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Topic { get; }
    public Partition Partition { get; }
    public Offset Offset { get; }
    public Nullable`1<int> LeaderEpoch { get; }
    public Error Error { get; }
    public TopicPartition TopicPartition { get; }
    public TopicPartitionOffset TopicPartitionOffset { get; }
    public TopicPartitionOffsetError(TopicPartition tp, Offset offset, Error error, Nullable`1<int> leaderEpoch);
    public TopicPartitionOffsetError(TopicPartitionOffset tpo, Error error);
    public TopicPartitionOffsetError(string topic, Partition partition, Offset offset, Error error, Nullable`1<int> leaderEpoch);
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public Partition get_Partition();
    [CompilerGeneratedAttribute]
public Offset get_Offset();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LeaderEpoch();
    [CompilerGeneratedAttribute]
public Error get_Error();
    public TopicPartition get_TopicPartition();
    public TopicPartitionOffset get_TopicPartitionOffset();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TopicPartitionOffsetError a, TopicPartitionOffsetError b);
    public static bool op_Inequality(TopicPartitionOffsetError a, TopicPartitionOffsetError b);
    public static TopicPartitionOffset op_Explicit(TopicPartitionOffsetError tpoe);
    public virtual string ToString();
}
public class Confluent.Kafka.TopicPartitionOffsetException : KafkaException {
    [CompilerGeneratedAttribute]
private List`1<TopicPartitionOffsetError> <Results>k__BackingField;
    public List`1<TopicPartitionOffsetError> Results { get; }
    public TopicPartitionOffsetException(List`1<TopicPartitionOffsetError> results);
    [CompilerGeneratedAttribute]
public List`1<TopicPartitionOffsetError> get_Results();
}
public class Confluent.Kafka.TopicPartitionTimestamp : object {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Partition <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private Timestamp <Timestamp>k__BackingField;
    public string Topic { get; }
    public Partition Partition { get; }
    public Timestamp Timestamp { get; }
    public TopicPartition TopicPartition { get; }
    public TopicPartitionTimestamp(TopicPartition tp, Timestamp timestamp);
    public TopicPartitionTimestamp(string topic, Partition partition, Timestamp timestamp);
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public Partition get_Partition();
    [CompilerGeneratedAttribute]
public Timestamp get_Timestamp();
    public TopicPartition get_TopicPartition();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TopicPartitionTimestamp a, TopicPartitionTimestamp b);
    public static bool op_Inequality(TopicPartitionTimestamp a, TopicPartitionTimestamp b);
    public virtual string ToString();
}
public class Confluent.Kafka.Uuid : object {
    [CompilerGeneratedAttribute]
private Offset <MostSignificantBits>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <LeastSignificantBits>k__BackingField;
    private string Base64str;
    public Offset MostSignificantBits { get; }
    public Offset LeastSignificantBits { get; }
    public Uuid(long mostSignificantBits, long leastSignificantBits);
    [CompilerGeneratedAttribute]
public Offset get_MostSignificantBits();
    [CompilerGeneratedAttribute]
public Offset get_LeastSignificantBits();
    public virtual string ToString();
}
public class Confluent.Kafka.WatermarkOffsets : object {
    [CompilerGeneratedAttribute]
private Offset <Low>k__BackingField;
    [CompilerGeneratedAttribute]
private Offset <High>k__BackingField;
    public Offset Low { get; }
    public Offset High { get; }
    public WatermarkOffsets(Offset low, Offset high);
    [CompilerGeneratedAttribute]
public Offset get_Low();
    [CompilerGeneratedAttribute]
public Offset get_High();
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
