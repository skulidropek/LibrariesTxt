[GeneratedCodeAttribute("ANTLR", "4.13.1")]
[CLSCompliantAttribute("False")]
public interface INCalcListener {
    public abstract virtual void EnterNcalcExpression(NcalcExpressionContext context);
    public abstract virtual void ExitNcalcExpression(NcalcExpressionContext context);
    public abstract virtual void EnterLogicalExpression(LogicalExpressionContext context);
    public abstract virtual void ExitLogicalExpression(LogicalExpressionContext context);
    public abstract virtual void EnterConditionalExpression(ConditionalExpressionContext context);
    public abstract virtual void ExitConditionalExpression(ConditionalExpressionContext context);
    public abstract virtual void EnterBooleanAndExpression(BooleanAndExpressionContext context);
    public abstract virtual void ExitBooleanAndExpression(BooleanAndExpressionContext context);
    public abstract virtual void EnterBitwiseOrExpression(BitwiseOrExpressionContext context);
    public abstract virtual void ExitBitwiseOrExpression(BitwiseOrExpressionContext context);
    public abstract virtual void EnterBitwiseXOrExpression(BitwiseXOrExpressionContext context);
    public abstract virtual void ExitBitwiseXOrExpression(BitwiseXOrExpressionContext context);
    public abstract virtual void EnterBitwiseAndExpression(BitwiseAndExpressionContext context);
    public abstract virtual void ExitBitwiseAndExpression(BitwiseAndExpressionContext context);
    public abstract virtual void EnterEqualityExpression(EqualityExpressionContext context);
    public abstract virtual void ExitEqualityExpression(EqualityExpressionContext context);
    public abstract virtual void EnterRelationalExpression(RelationalExpressionContext context);
    public abstract virtual void ExitRelationalExpression(RelationalExpressionContext context);
    public abstract virtual void EnterShiftExpression(ShiftExpressionContext context);
    public abstract virtual void ExitShiftExpression(ShiftExpressionContext context);
    public abstract virtual void EnterAdditiveExpression(AdditiveExpressionContext context);
    public abstract virtual void ExitAdditiveExpression(AdditiveExpressionContext context);
    public abstract virtual void EnterMultiplicativeExpression(MultiplicativeExpressionContext context);
    public abstract virtual void ExitMultiplicativeExpression(MultiplicativeExpressionContext context);
    public abstract virtual void EnterUnaryExpression(UnaryExpressionContext context);
    public abstract virtual void ExitUnaryExpression(UnaryExpressionContext context);
    public abstract virtual void EnterExponentialExpression(ExponentialExpressionContext context);
    public abstract virtual void ExitExponentialExpression(ExponentialExpressionContext context);
    public abstract virtual void EnterPrimaryExpression(PrimaryExpressionContext context);
    public abstract virtual void ExitPrimaryExpression(PrimaryExpressionContext context);
    public abstract virtual void EnterValueExpression(ValueExpressionContext context);
    public abstract virtual void ExitValueExpression(ValueExpressionContext context);
    public abstract virtual void EnterIdentifier(IdentifierContext context);
    public abstract virtual void ExitIdentifier(IdentifierContext context);
    public abstract virtual void EnterExpressionList(ExpressionListContext context);
    public abstract virtual void ExitExpressionList(ExpressionListContext context);
    public abstract virtual void EnterArguments(ArgumentsContext context);
    public abstract virtual void ExitArguments(ArgumentsContext context);
}
public class NCalc.Domain.BinaryExpression : LogicalExpression {
    [CompilerGeneratedAttribute]
private LogicalExpression <LeftExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private LogicalExpression <RightExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryExpressionType <Type>k__BackingField;
    public LogicalExpression LeftExpression { get; public set; }
    public LogicalExpression RightExpression { get; public set; }
    public BinaryExpressionType Type { get; public set; }
    public BinaryExpression(BinaryExpressionType type, LogicalExpression leftExpression, LogicalExpression rightExpression);
    [CompilerGeneratedAttribute]
public LogicalExpression get_LeftExpression();
    [CompilerGeneratedAttribute]
public void set_LeftExpression(LogicalExpression value);
    [CompilerGeneratedAttribute]
public LogicalExpression get_RightExpression();
    [CompilerGeneratedAttribute]
public void set_RightExpression(LogicalExpression value);
    [CompilerGeneratedAttribute]
public BinaryExpressionType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(BinaryExpressionType value);
    public virtual void Accept(LogicalExpressionVisitor visitor);
}
public enum NCalc.Domain.BinaryExpressionType : Enum {
    public int value__;
    public static BinaryExpressionType And;
    public static BinaryExpressionType Or;
    public static BinaryExpressionType NotEqual;
    public static BinaryExpressionType LesserOrEqual;
    public static BinaryExpressionType GreaterOrEqual;
    public static BinaryExpressionType Lesser;
    public static BinaryExpressionType Greater;
    public static BinaryExpressionType Equal;
    public static BinaryExpressionType Minus;
    public static BinaryExpressionType Plus;
    public static BinaryExpressionType Modulo;
    public static BinaryExpressionType Div;
    public static BinaryExpressionType Times;
    public static BinaryExpressionType BitwiseOr;
    public static BinaryExpressionType BitwiseAnd;
    public static BinaryExpressionType BitwiseXOr;
    public static BinaryExpressionType LeftShift;
    public static BinaryExpressionType RightShift;
    public static BinaryExpressionType Unknown;
    public static BinaryExpressionType Exponentiation;
}
public class NCalc.Domain.EvaluationVisitor : LogicalExpressionVisitor {
    private EvaluateOptions _options;
    private CultureInfo _cultureInfo;
    private StringComparer _comparer;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    private static Type[] CommonTypes;
    [CompilerGeneratedAttribute]
private EvaluateFunctionHandler EvaluateFunction;
    [CompilerGeneratedAttribute]
private EvaluateParameterHandler EvaluateParameter;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Parameters>k__BackingField;
    private bool IgnoreCase { get; }
    private bool Ordinal { get; }
    private bool IgnoreCaseString { get; }
    private bool Checked { get; }
    public object Result { get; protected set; }
    public Dictionary`2<string, object> Parameters { get; public set; }
    public EvaluationVisitor(EvaluateOptions options);
    public EvaluationVisitor(EvaluateOptions options, CultureInfo cultureInfo);
    private static EvaluationVisitor();
    private bool get_IgnoreCase();
    private bool get_Ordinal();
    private bool get_IgnoreCaseString();
    private bool get_Checked();
    [CompilerGeneratedAttribute]
public object get_Result();
    [CompilerGeneratedAttribute]
protected void set_Result(object value);
    private object Evaluate(LogicalExpression expression);
    public virtual void Visit(LogicalExpression expression);
    private static Type GetMostPreciseType(Type a, Type b);
    public int CompareUsingMostPreciseType(object a, object b);
    public virtual void Visit(TernaryExpression expression);
    private static bool IsReal(object value);
    public virtual void Visit(BinaryExpression expression);
    public virtual void Visit(UnaryExpression expression);
    public virtual void Visit(ValueExpression expression);
    public virtual void Visit(Function function);
    private void CheckCase(string function, string called);
    [CompilerGeneratedAttribute]
public void add_EvaluateFunction(EvaluateFunctionHandler value);
    [CompilerGeneratedAttribute]
public void remove_EvaluateFunction(EvaluateFunctionHandler value);
    private void OnEvaluateFunction(string name, FunctionArgs args);
    public virtual void Visit(Identifier parameter);
    [CompilerGeneratedAttribute]
public void add_EvaluateParameter(EvaluateParameterHandler value);
    [CompilerGeneratedAttribute]
public void remove_EvaluateParameter(EvaluateParameterHandler value);
    private void OnEvaluateParameter(string name, ParameterArgs args);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(Dictionary`2<string, object> value);
}
public class NCalc.Domain.Function : LogicalExpression {
    [CompilerGeneratedAttribute]
private Identifier <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private LogicalExpression[] <Expressions>k__BackingField;
    public Identifier Identifier { get; public set; }
    public LogicalExpression[] Expressions { get; public set; }
    public Function(Identifier identifier, LogicalExpression[] expressions);
    [CompilerGeneratedAttribute]
public Identifier get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(Identifier value);
    [CompilerGeneratedAttribute]
public LogicalExpression[] get_Expressions();
    [CompilerGeneratedAttribute]
public void set_Expressions(LogicalExpression[] value);
    public virtual void Accept(LogicalExpressionVisitor visitor);
}
public class NCalc.Domain.Identifier : LogicalExpression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public Identifier(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual void Accept(LogicalExpressionVisitor visitor);
}
public abstract class NCalc.Domain.LogicalExpression : object {
    public BinaryExpression And(LogicalExpression operand);
    public BinaryExpression And(object operand);
    public BinaryExpression DividedBy(LogicalExpression operand);
    public BinaryExpression DividedBy(object operand);
    public BinaryExpression EqualsTo(LogicalExpression operand);
    public BinaryExpression EqualsTo(object operand);
    public BinaryExpression GreaterThan(LogicalExpression operand);
    public BinaryExpression GreaterThan(object operand);
    public BinaryExpression GreaterOrEqualThan(LogicalExpression operand);
    public BinaryExpression GreaterOrEqualThan(object operand);
    public BinaryExpression LesserThan(LogicalExpression operand);
    public BinaryExpression LesserThan(object operand);
    public BinaryExpression LesserOrEqualThan(LogicalExpression operand);
    public BinaryExpression LesserOrEqualThan(object operand);
    public BinaryExpression Minus(LogicalExpression operand);
    public BinaryExpression Minus(object operand);
    public BinaryExpression Modulo(LogicalExpression operand);
    public BinaryExpression Modulo(object operand);
    public BinaryExpression NotEqual(LogicalExpression operand);
    public BinaryExpression NotEqual(object operand);
    public BinaryExpression Or(LogicalExpression operand);
    public BinaryExpression Or(object operand);
    public BinaryExpression Plus(LogicalExpression operand);
    public BinaryExpression Plus(object operand);
    public BinaryExpression Mult(LogicalExpression operand);
    public BinaryExpression Mult(object operand);
    public BinaryExpression BitwiseOr(LogicalExpression operand);
    public BinaryExpression BitwiseOr(object operand);
    public BinaryExpression BitwiseAnd(LogicalExpression operand);
    public BinaryExpression BitwiseAnd(object operand);
    public BinaryExpression BitwiseXOr(LogicalExpression operand);
    public BinaryExpression BitwiseXOr(object operand);
    public BinaryExpression LeftShift(LogicalExpression operand);
    public BinaryExpression LeftShift(object operand);
    public BinaryExpression RightShift(LogicalExpression operand);
    public BinaryExpression RightShift(object operand);
    public virtual string ToString();
    public virtual void Accept(LogicalExpressionVisitor visitor);
}
public abstract class NCalc.Domain.LogicalExpressionVisitor : object {
    public abstract virtual void Visit(LogicalExpression expression);
    public abstract virtual void Visit(TernaryExpression expression);
    public abstract virtual void Visit(BinaryExpression expression);
    public abstract virtual void Visit(UnaryExpression expression);
    public abstract virtual void Visit(ValueExpression expression);
    public abstract virtual void Visit(Function function);
    public abstract virtual void Visit(Identifier function);
}
public class NCalc.Domain.SerializationVisitor : LogicalExpressionVisitor {
    private NumberFormatInfo _numberFormatInfo;
    [CompilerGeneratedAttribute]
private StringBuilder <Result>k__BackingField;
    public StringBuilder Result { get; protected set; }
    [CompilerGeneratedAttribute]
public StringBuilder get_Result();
    [CompilerGeneratedAttribute]
protected void set_Result(StringBuilder value);
    public virtual void Visit(LogicalExpression expression);
    public virtual void Visit(TernaryExpression expression);
    public virtual void Visit(BinaryExpression expression);
    public virtual void Visit(UnaryExpression expression);
    public virtual void Visit(ValueExpression expression);
    public virtual void Visit(Function function);
    public virtual void Visit(Identifier parameter);
    protected void EncapsulateNoValue(LogicalExpression expression);
}
public class NCalc.Domain.TernaryExpression : LogicalExpression {
    [CompilerGeneratedAttribute]
private LogicalExpression <LeftExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private LogicalExpression <MiddleExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private LogicalExpression <RightExpression>k__BackingField;
    public LogicalExpression LeftExpression { get; public set; }
    public LogicalExpression MiddleExpression { get; public set; }
    public LogicalExpression RightExpression { get; public set; }
    public TernaryExpression(LogicalExpression leftExpression, LogicalExpression middleExpression, LogicalExpression rightExpression);
    [CompilerGeneratedAttribute]
public LogicalExpression get_LeftExpression();
    [CompilerGeneratedAttribute]
public void set_LeftExpression(LogicalExpression value);
    [CompilerGeneratedAttribute]
public LogicalExpression get_MiddleExpression();
    [CompilerGeneratedAttribute]
public void set_MiddleExpression(LogicalExpression value);
    [CompilerGeneratedAttribute]
public LogicalExpression get_RightExpression();
    [CompilerGeneratedAttribute]
public void set_RightExpression(LogicalExpression value);
    public virtual void Accept(LogicalExpressionVisitor visitor);
}
public class NCalc.Domain.UnaryExpression : LogicalExpression {
    [CompilerGeneratedAttribute]
private LogicalExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private UnaryExpressionType <Type>k__BackingField;
    public LogicalExpression Expression { get; public set; }
    public UnaryExpressionType Type { get; public set; }
    public UnaryExpression(UnaryExpressionType type, LogicalExpression expression);
    [CompilerGeneratedAttribute]
public LogicalExpression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(LogicalExpression value);
    [CompilerGeneratedAttribute]
public UnaryExpressionType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(UnaryExpressionType value);
    public virtual void Accept(LogicalExpressionVisitor visitor);
}
public enum NCalc.Domain.UnaryExpressionType : Enum {
    public int value__;
    public static UnaryExpressionType Not;
    public static UnaryExpressionType Negate;
    public static UnaryExpressionType BitwiseNot;
    public static UnaryExpressionType Positive;
}
public class NCalc.Domain.ValueExpression : LogicalExpression {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueType <Type>k__BackingField;
    public object Value { get; public set; }
    public ValueType Type { get; public set; }
    public ValueExpression(object value, ValueType type);
    public ValueExpression(object value);
    public ValueExpression(string value);
    public ValueExpression(int value);
    public ValueExpression(float value);
    public ValueExpression(DateTime value);
    public ValueExpression(bool value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public ValueType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ValueType value);
    public virtual void Accept(LogicalExpressionVisitor visitor);
}
public enum NCalc.Domain.ValueType : Enum {
    public int value__;
    public static ValueType Integer;
    public static ValueType String;
    public static ValueType DateTime;
    public static ValueType Float;
    public static ValueType Boolean;
}
internal class NCalc.ErrorListener`1 : object {
    public List`1<SyntaxError`1<T>> Errors;
    public sealed virtual void SyntaxError(TextWriter output, IRecognizer recognizer, T offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class NCalc.EvaluateFunctionHandler : MulticastDelegate {
    public EvaluateFunctionHandler(object object, IntPtr method);
    public virtual void Invoke(string name, FunctionArgs args);
    public virtual IAsyncResult BeginInvoke(string name, FunctionArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum NCalc.EvaluateOptions : Enum {
    public int value__;
    public static EvaluateOptions None;
    public static EvaluateOptions IgnoreCase;
    public static EvaluateOptions NoCache;
    public static EvaluateOptions IterateParameters;
    public static EvaluateOptions RoundAwayFromZero;
    public static EvaluateOptions MatchStringsWithIgnoreCase;
    public static EvaluateOptions MatchStringsOrdinal;
    public static EvaluateOptions OverflowProtection;
    public static EvaluateOptions BooleanCalculation;
    public static EvaluateOptions UseDoubleForAbsFunction;
    public static EvaluateOptions AllowNullParameter;
}
public class NCalc.EvaluateParameterHandler : MulticastDelegate {
    public EvaluateParameterHandler(object object, IntPtr method);
    public virtual void Invoke(string name, ParameterArgs args);
    public virtual IAsyncResult BeginInvoke(string name, ParameterArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NCalc.EvaluationException : Exception {
    public EvaluationException(string message);
    public EvaluationException(string message, Exception innerException);
}
public class NCalc.Expression : object {
    [CompilerGeneratedAttribute]
private EvaluateOptions <Options>k__BackingField;
    protected string OriginalExpression;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    private static bool _cacheEnabled;
    private static ConcurrentDictionary`2<string, WeakReference`1<LogicalExpression>> _compiledExpressions;
    private static int _totalCachedCompilations;
    [CompilerGeneratedAttribute]
private static int <CacheCleanInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ErrorException>k__BackingField;
    [CompilerGeneratedAttribute]
private LogicalExpression <ParsedExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluateFunctionHandler EvaluateFunction;
    [CompilerGeneratedAttribute]
private EvaluateParameterHandler EvaluateParameter;
    private Dictionary`2<string, object> _parameters;
    public EvaluateOptions Options { get; public set; }
    protected CultureInfo CultureInfo { get; protected set; }
    internal static int CurrentCachedCompilations { get; }
    internal static int TotalCachedCompilations { get; }
    public static int CacheCleanInterval { get; public set; }
    public static bool CacheEnabled { get; public set; }
    public string Error { get; private set; }
    public Exception ErrorException { get; private set; }
    public LogicalExpression ParsedExpression { get; private set; }
    public Dictionary`2<string, object> Parameters { get; public set; }
    public Expression(string expression);
    public Expression(string expression, CultureInfo cultureInfo);
    public Expression(string expression, EvaluateOptions options);
    public Expression(string expression, EvaluateOptions options, CultureInfo cultureInfo);
    public Expression(LogicalExpression expression, EvaluateOptions options);
    public Expression(LogicalExpression expression, EvaluateOptions options, CultureInfo cultureInfo);
    private static Expression();
    [CompilerGeneratedAttribute]
public EvaluateOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(EvaluateOptions value);
    [CompilerGeneratedAttribute]
protected CultureInfo get_CultureInfo();
    [CompilerGeneratedAttribute]
protected void set_CultureInfo(CultureInfo value);
    internal static int get_CurrentCachedCompilations();
    internal static int get_TotalCachedCompilations();
    [CompilerGeneratedAttribute]
public static int get_CacheCleanInterval();
    [CompilerGeneratedAttribute]
public static void set_CacheCleanInterval(int value);
    public static bool get_CacheEnabled();
    public static void set_CacheEnabled(bool value);
    private static void CleanCache();
    public static LogicalExpression Compile(string expression, bool nocache);
    public bool HasErrors();
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(string value);
    [CompilerGeneratedAttribute]
public Exception get_ErrorException();
    [CompilerGeneratedAttribute]
private void set_ErrorException(Exception value);
    [CompilerGeneratedAttribute]
public LogicalExpression get_ParsedExpression();
    [CompilerGeneratedAttribute]
private void set_ParsedExpression(LogicalExpression value);
    private ExpressionWithParameter ToLinqExpressionInternal();
    protected virtual Expression ToLinqExpression();
    protected virtual ExpressionWithParameter ToLinqExpression();
    public virtual Func`1<TResult> ToLambda();
    public virtual Func`2<TContext, TResult> ToLambda();
    public object Evaluate();
    [CompilerGeneratedAttribute]
public void add_EvaluateFunction(EvaluateFunctionHandler value);
    [CompilerGeneratedAttribute]
public void remove_EvaluateFunction(EvaluateFunctionHandler value);
    [CompilerGeneratedAttribute]
public void add_EvaluateParameter(EvaluateParameterHandler value);
    [CompilerGeneratedAttribute]
public void remove_EvaluateParameter(EvaluateParameterHandler value);
    public Dictionary`2<string, object> get_Parameters();
    public void set_Parameters(Dictionary`2<string, object> value);
}
public class NCalc.ExtendedMethodInfo : object {
    [CompilerGeneratedAttribute]
private MethodInfo <BaseMethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression[] <PreparedArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Score>k__BackingField;
    public MethodInfo BaseMethodInfo { get; public set; }
    public Expression[] PreparedArguments { get; public set; }
    public int Score { get; public set; }
    [CompilerGeneratedAttribute]
public MethodInfo get_BaseMethodInfo();
    [CompilerGeneratedAttribute]
public void set_BaseMethodInfo(MethodInfo value);
    [CompilerGeneratedAttribute]
public Expression[] get_PreparedArguments();
    [CompilerGeneratedAttribute]
public void set_PreparedArguments(Expression[] value);
    [CompilerGeneratedAttribute]
public int get_Score();
    [CompilerGeneratedAttribute]
public void set_Score(int value);
}
public class NCalc.FunctionArgs : EventArgs {
    private object _result;
    [CompilerGeneratedAttribute]
private bool <HasResult>k__BackingField;
    private Expression[] _parameters;
    public object Result { get; public set; }
    public bool HasResult { get; public set; }
    public Expression[] Parameters { get; public set; }
    public object get_Result();
    public void set_Result(object value);
    [CompilerGeneratedAttribute]
public bool get_HasResult();
    [CompilerGeneratedAttribute]
public void set_HasResult(bool value);
    public Expression[] get_Parameters();
    public void set_Parameters(Expression[] value);
    public Object[] EvaluateParameters();
}
internal class NCalc.LambdaExpressionVistor : LogicalExpressionVisitor {
    private IDictionary`2<string, object> _parameters;
    private Expression _result;
    private Expression _context;
    private EvaluateOptions _options;
    private Dictionary`2<Type, HashSet`1<Type>> _implicitPrimitiveConversionTable;
    private static Dictionary`2<string, MathCallFunction> _mathCallFunctions;
    private bool Ordinal { get; }
    private bool IgnoreCaseString { get; }
    private bool Checked { get; }
    public Expression Result { get; }
    public LambdaExpressionVistor(IDictionary`2<string, object> parameters, EvaluateOptions options);
    public LambdaExpressionVistor(ParameterExpression context, EvaluateOptions options);
    private static LambdaExpressionVistor();
    private static MathCallFunction GetMathCallFunctionHelper(string method, int argCount);
    private bool get_Ordinal();
    private bool get_IgnoreCaseString();
    private bool get_Checked();
    public Expression get_Result();
    public virtual void Visit(LogicalExpression expression);
    public virtual void Visit(TernaryExpression expression);
    public virtual void Visit(BinaryExpression expression);
    public virtual void Visit(UnaryExpression expression);
    public virtual void Visit(ValueExpression expression);
    public virtual void Visit(Function function);
    public virtual void Visit(Identifier function);
    private ExtendedMethodInfo FindMethod(string methodName, Expression[] methodArgs);
    private Tuple`2<int, Expression[]> PrepareMethodArgumentsIfValid(ParameterInfo[] parameters, Expression[] arguments);
    private bool TryCastImplicitly(Type from, Type to, Expression& argument);
    private Expression WithCommonNumericType(Expression left, Expression right, Func`3<Expression, Expression, Expression> action, BinaryExpressionType expressiontype);
    private static Expression UnwrapNullable(Expression expression);
    [CompilerGeneratedAttribute]
internal static void <Visit>g__CheckArgumentsLengthForFunction|23_0(string funcStr, int argsNum, int argsNeed);
}
public static class NCalc.Numbers : object {
    private static object ConvertIfString(object s, CultureInfo cultureInfo);
    private static object ConvertIfBoolean(object input);
    public static object Add(object a, object b, EvaluateOptions options);
    public static object Add(object a, object b, EvaluateOptions options, CultureInfo cultureInfo);
    public static object AddChecked(object a, object b, EvaluateOptions options);
    public static object AddChecked(object a, object b, EvaluateOptions options, CultureInfo cultureInfo);
    [ObsoleteAttribute("This method will be removed in the next major update. Use Subtract method instead")]
public static object Soustract(object a, object b, EvaluateOptions options);
    [ObsoleteAttribute("This method will be removed in the next major update. Use Subtract method instead")]
public static object Soustract(object a, object b, EvaluateOptions options, CultureInfo cultureInfo);
    public static object Subtract(object a, object b, EvaluateOptions options);
    public static object Subtract(object a, object b, EvaluateOptions options, CultureInfo cultureInfo);
    [ObsoleteAttribute("This method will be removed in the next major update. Use SubtractChecked method instead")]
public static object SoustractChecked(object a, object b, EvaluateOptions options);
    [ObsoleteAttribute("This method will be removed in the next major update. Use SubtractChecked method instead")]
public static object SoustractChecked(object a, object b, EvaluateOptions options, CultureInfo cultureInfo);
    public static object SubtractChecked(object a, object b, EvaluateOptions options);
    public static object SubtractChecked(object a, object b, EvaluateOptions options, CultureInfo cultureInfo);
    public static object Multiply(object a, object b, EvaluateOptions options);
    public static object Multiply(object a, object b, EvaluateOptions options, CultureInfo cultureInfo);
    public static object MultiplyChecked(object a, object b, EvaluateOptions options);
    public static object MultiplyChecked(object a, object b, EvaluateOptions options, CultureInfo cultureInfo);
    public static object Divide(object a, object b, EvaluateOptions options);
    public static object Divide(object a, object b, EvaluateOptions options, CultureInfo cultureInfo);
    public static object Modulo(object a, object b);
    public static object Modulo(object a, object b, CultureInfo cultureInfo);
    public static object Max(object a, object b);
    public static object Max(object a, object b, CultureInfo cultureInfo);
    public static object Min(object a, object b);
    public static object Min(object a, object b, CultureInfo cultureInfo);
    private static TypeCode ConvertToHighestPrecision(Object& a, Object& b, CultureInfo cultureInfo);
    private static Nullable`1<int> TypeCodeBitSize(TypeCode typeCode, Boolean& floatingPoint);
    private static object ConvertTo(object value, TypeCode toType, CultureInfo cultureInfo);
}
public class NCalc.ParameterArgs : EventArgs {
    private object _result;
    [CompilerGeneratedAttribute]
private bool <HasResult>k__BackingField;
    public object Result { get; public set; }
    public bool HasResult { get; public set; }
    public object get_Result();
    public void set_Result(object value);
    [CompilerGeneratedAttribute]
public bool get_HasResult();
    [CompilerGeneratedAttribute]
public void set_HasResult(bool value);
}
internal class NCalc.SyntaxError`1 : object {
    public T OffendingSymbol;
    public int Line;
    public int CharPositionInLine;
    public string Message;
    public RecognitionException Exception;
    public SyntaxError`1(T offendingSymbol, int line, int charPositionInLine, string message, RecognitionException exception);
    public virtual string ToString();
}
[GeneratedCodeAttribute("ANTLR", "4.13.1")]
[DebuggerNonUserCodeAttribute]
[CLSCompliantAttribute("False")]
public class NCalcBaseListener : object {
    public virtual void EnterNcalcExpression(NcalcExpressionContext context);
    public virtual void ExitNcalcExpression(NcalcExpressionContext context);
    public virtual void EnterLogicalExpression(LogicalExpressionContext context);
    public virtual void ExitLogicalExpression(LogicalExpressionContext context);
    public virtual void EnterConditionalExpression(ConditionalExpressionContext context);
    public virtual void ExitConditionalExpression(ConditionalExpressionContext context);
    public virtual void EnterBooleanAndExpression(BooleanAndExpressionContext context);
    public virtual void ExitBooleanAndExpression(BooleanAndExpressionContext context);
    public virtual void EnterBitwiseOrExpression(BitwiseOrExpressionContext context);
    public virtual void ExitBitwiseOrExpression(BitwiseOrExpressionContext context);
    public virtual void EnterBitwiseXOrExpression(BitwiseXOrExpressionContext context);
    public virtual void ExitBitwiseXOrExpression(BitwiseXOrExpressionContext context);
    public virtual void EnterBitwiseAndExpression(BitwiseAndExpressionContext context);
    public virtual void ExitBitwiseAndExpression(BitwiseAndExpressionContext context);
    public virtual void EnterEqualityExpression(EqualityExpressionContext context);
    public virtual void ExitEqualityExpression(EqualityExpressionContext context);
    public virtual void EnterRelationalExpression(RelationalExpressionContext context);
    public virtual void ExitRelationalExpression(RelationalExpressionContext context);
    public virtual void EnterShiftExpression(ShiftExpressionContext context);
    public virtual void ExitShiftExpression(ShiftExpressionContext context);
    public virtual void EnterAdditiveExpression(AdditiveExpressionContext context);
    public virtual void ExitAdditiveExpression(AdditiveExpressionContext context);
    public virtual void EnterMultiplicativeExpression(MultiplicativeExpressionContext context);
    public virtual void ExitMultiplicativeExpression(MultiplicativeExpressionContext context);
    public virtual void EnterUnaryExpression(UnaryExpressionContext context);
    public virtual void ExitUnaryExpression(UnaryExpressionContext context);
    public virtual void EnterExponentialExpression(ExponentialExpressionContext context);
    public virtual void ExitExponentialExpression(ExponentialExpressionContext context);
    public virtual void EnterPrimaryExpression(PrimaryExpressionContext context);
    public virtual void ExitPrimaryExpression(PrimaryExpressionContext context);
    public virtual void EnterValueExpression(ValueExpressionContext context);
    public virtual void ExitValueExpression(ValueExpressionContext context);
    public virtual void EnterIdentifier(IdentifierContext context);
    public virtual void ExitIdentifier(IdentifierContext context);
    public virtual void EnterExpressionList(ExpressionListContext context);
    public virtual void ExitExpressionList(ExpressionListContext context);
    public virtual void EnterArguments(ArgumentsContext context);
    public virtual void ExitArguments(ArgumentsContext context);
    public virtual void EnterEveryRule(ParserRuleContext context);
    public virtual void ExitEveryRule(ParserRuleContext context);
    public virtual void VisitTerminal(ITerminalNode node);
    public virtual void VisitErrorNode(IErrorNode node);
}
[GeneratedCodeAttribute("ANTLR", "4.13.1")]
[CLSCompliantAttribute("False")]
public class NCalcLexer : Lexer {
    protected static DFA[] decisionToDFA;
    protected static PredictionContextCache sharedContextCache;
    public static int T__0;
    public static int T__1;
    public static int T__2;
    public static int T__3;
    public static int T__4;
    public static int T__5;
    public static int T__6;
    public static int T__7;
    public static int T__8;
    public static int T__9;
    public static int T__10;
    public static int T__11;
    public static int T__12;
    public static int T__13;
    public static int T__14;
    public static int T__15;
    public static int T__16;
    public static int T__17;
    public static int T__18;
    public static int T__19;
    public static int T__20;
    public static int T__21;
    public static int T__22;
    public static int T__23;
    public static int T__24;
    public static int T__25;
    public static int T__26;
    public static int T__27;
    public static int TRUE;
    public static int FALSE;
    public static int AND;
    public static int OR;
    public static int NOT;
    public static int ID;
    public static int INTEGER;
    public static int FLOAT;
    public static int STRING;
    public static int DATETIME;
    public static int NAME;
    public static int EXPONENT;
    public static int WS;
    public static String[] channelNames;
    public static String[] modeNames;
    public static String[] ruleNames;
    private static char BS;
    private static NumberFormatInfo numberFormatInfo;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    private static Int32[] _serializedATN;
    public static ATN _ATN;
    public List`1<string> Errors { get; private set; }
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public String[] ChannelNames { get; }
    public String[] ModeNames { get; }
    public Int32[] SerializedAtn { get; }
    public NCalcLexer(ICharStream input);
    public NCalcLexer(ICharStream input, TextWriter output, TextWriter errorOutput);
    private static NCalcLexer();
    private string extractString(string text);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(List`1<string> value);
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ChannelNames();
    public virtual String[] get_ModeNames();
    public virtual Int32[] get_SerializedAtn();
}
[GeneratedCodeAttribute("ANTLR", "4.13.1")]
[CLSCompliantAttribute("False")]
public class NCalcParser : Parser {
    protected static DFA[] decisionToDFA;
    protected static PredictionContextCache sharedContextCache;
    public static int T__0;
    public static int T__1;
    public static int T__2;
    public static int T__3;
    public static int T__4;
    public static int T__5;
    public static int T__6;
    public static int T__7;
    public static int T__8;
    public static int T__9;
    public static int T__10;
    public static int T__11;
    public static int T__12;
    public static int T__13;
    public static int T__14;
    public static int T__15;
    public static int T__16;
    public static int T__17;
    public static int T__18;
    public static int T__19;
    public static int T__20;
    public static int T__21;
    public static int T__22;
    public static int T__23;
    public static int T__24;
    public static int T__25;
    public static int T__26;
    public static int T__27;
    public static int TRUE;
    public static int FALSE;
    public static int AND;
    public static int OR;
    public static int NOT;
    public static int ID;
    public static int INTEGER;
    public static int FLOAT;
    public static int STRING;
    public static int DATETIME;
    public static int NAME;
    public static int EXPONENT;
    public static int WS;
    public static int RULE_ncalcExpression;
    public static int RULE_logicalExpression;
    public static int RULE_conditionalExpression;
    public static int RULE_booleanAndExpression;
    public static int RULE_bitwiseOrExpression;
    public static int RULE_bitwiseXOrExpression;
    public static int RULE_bitwiseAndExpression;
    public static int RULE_equalityExpression;
    public static int RULE_relationalExpression;
    public static int RULE_shiftExpression;
    public static int RULE_additiveExpression;
    public static int RULE_multiplicativeExpression;
    public static int RULE_unaryExpression;
    public static int RULE_exponentialExpression;
    public static int RULE_primaryExpression;
    public static int RULE_valueExpression;
    public static int RULE_identifier;
    public static int RULE_expressionList;
    public static int RULE_arguments;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    private static char BS;
    private static NumberFormatInfo numberFormatInfo;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    private static Int32[] _serializedATN;
    public static ATN _ATN;
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public Int32[] SerializedAtn { get; }
    public List`1<string> Errors { get; private set; }
    private static NCalcParser();
    public NCalcParser(ITokenStream input);
    public NCalcParser(ITokenStream input, TextWriter output, TextWriter errorOutput);
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual Int32[] get_SerializedAtn();
    private string extractString(string text);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(List`1<string> value);
    [RuleVersionAttribute("0")]
public NcalcExpressionContext ncalcExpression();
    [RuleVersionAttribute("0")]
public LogicalExpressionContext logicalExpression();
    [RuleVersionAttribute("0")]
public ConditionalExpressionContext conditionalExpression();
    [RuleVersionAttribute("0")]
public BooleanAndExpressionContext booleanAndExpression();
    [RuleVersionAttribute("0")]
public BitwiseOrExpressionContext bitwiseOrExpression();
    [RuleVersionAttribute("0")]
public BitwiseXOrExpressionContext bitwiseXOrExpression();
    [RuleVersionAttribute("0")]
public BitwiseAndExpressionContext bitwiseAndExpression();
    [RuleVersionAttribute("0")]
public EqualityExpressionContext equalityExpression();
    [RuleVersionAttribute("0")]
public RelationalExpressionContext relationalExpression();
    [RuleVersionAttribute("0")]
public ShiftExpressionContext shiftExpression();
    [RuleVersionAttribute("0")]
public AdditiveExpressionContext additiveExpression();
    [RuleVersionAttribute("0")]
public MultiplicativeExpressionContext multiplicativeExpression();
    [RuleVersionAttribute("0")]
public UnaryExpressionContext unaryExpression();
    [RuleVersionAttribute("0")]
public ExponentialExpressionContext exponentialExpression();
    [RuleVersionAttribute("0")]
public PrimaryExpressionContext primaryExpression();
    [RuleVersionAttribute("0")]
public ValueExpressionContext valueExpression();
    [RuleVersionAttribute("0")]
public IdentifierContext identifier();
    [RuleVersionAttribute("0")]
public ExpressionListContext expressionList();
    [RuleVersionAttribute("0")]
public ArgumentsContext arguments();
}
[ExtensionAttribute]
public static class System.TypeExtensions : object {
    private static Dictionary`2<Type, TypeCode> TypeCodeMap;
    private static TypeExtensions();
    [ExtensionAttribute]
public static TypeCode GetTypeCode(object obj);
    [ExtensionAttribute]
public static TypeCode ToTypeCode(Type type);
}
