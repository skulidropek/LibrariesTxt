[DebuggerNonUserCodeAttribute]
internal static class Check : object {
    public static void Assert(bool condition);
    public static void Assert(bool condition, string message);
    public static void Assert(bool condition, ExceptionBuilder fnExceptionBuilder);
    public static void Assert(bool condition, string message, Exception innerException);
    public static T NotNull(T value);
    public static string NotEmpty(string value);
    public static Guid NotEmpty(Guid value);
    public static T NotEmpty(T value);
    public static void IsEqual(T a, T b);
    public static void NotEqual(T a, T b);
    public static T[] ArraySize(T[] value, int min, int max);
    public static T InRange(T value, T min, T max);
    public static T IsAssignable(object value);
    public static object IsAssignable(Type toType, object fromValue);
    public static void IsAssignable(Type toType, Type fromType);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("CSharpTest.Net.Generators", "2.0")]
public class CSharpTest.Net.AssertionFailedException : BaseAssertionException {
    protected AssertionFailedException(SerializationInfo info, StreamingContext context);
    protected AssertionFailedException(Exception innerException, int hResult, string message);
    public AssertionFailedException(Exception innerException);
    public AssertionFailedException(string message);
    public AssertionFailedException(string message, Exception innerException);
    public static void Assert(bool condition, string format, Object[] args);
    internal static Exception Create(int hResult, string message);
    public static void Assert(bool condition);
    public static void Assert(bool condition, string message);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("CSharpTest.Net.Generators", "1.11.225.410")]
public abstract class CSharpTest.Net.BaseAssertionException : ApplicationException {
    protected BaseAssertionException(SerializationInfo info, StreamingContext context);
    protected BaseAssertionException(string text);
    protected BaseAssertionException(string text, Exception innerException);
    [DebuggerNonUserCodeAttribute]
private static string AssertionText(string message);
}
public abstract class CSharpTest.Net.Bases.Disposable : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private EventHandler DisposedEvent;
    [CompilerGeneratedAttribute]
private void add_DisposedEvent(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove_DisposedEvent(EventHandler value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void OnDispose(bool disposing);
    public void add_Disposed(EventHandler value);
    public void remove_Disposed(EventHandler value);
    protected virtual void Assert();
    protected abstract virtual void Dispose(bool disposing);
}
[DebuggerNonUserCodeAttribute]
public abstract class CSharpTest.Net.Bases.Equatable`1 : object {
    public static EqualityComparer<T> Comparer;
    protected int HashCode { get; }
    private static Equatable`1();
    protected abstract virtual int get_HashCode();
    public abstract virtual bool Equals(T other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public static bool Equals(T x, T y);
    public static int GetHashCode(T obj);
    public static bool op_Equality(Equatable`1<T> x, Equatable`1<T> y);
    public static bool op_Inequality(Equatable`1<T> x, Equatable`1<T> y);
}
[DefaultMemberAttribute("Item")]
public class CSharpTest.Net.Collections.BPlusTree`2 : object {
    private BPlusTreeOptions`2<TKey, TValue> _options;
    private NodeCacheBase<TKey, TValue> _storage;
    private ILockStrategy _selfLock;
    private IComparer`1<TKey> _keyComparer;
    private IComparer`1<Element<TKey, TValue>> _itemComparer;
    private bool _disposed;
    private bool _hasCount;
    private int _count;
    private KeyCollection<TKey, TValue> _keysCollection;
    private ValueCollection<TKey, TValue> _valuesCollection;
    private static bool IsDebugBuild;
    private bool _validated;
    private TextWriter _debugOut;
    private static KeyValueUpdate`2<TKey, TValue> IgnoreUpdate;
    private static LockType<TKey, TValue> NoLock;
    public ILockStrategy CallLevelLock { get; }
    public int Count { get; }
    private int LockTimeout { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public bool IsReadOnly { get; }
    public BPlusTree`2(IComparer`1<TKey> comparer);
    public BPlusTree`2(OptionsV2<TKey, TValue> optionsV2);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public BPlusTree`2(Options<TKey, TValue> optionsV1);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public BPlusTree`2(BPlusTreeOptions`2<TKey, TValue> ioptions);
    private static BPlusTree`2();
    public sealed virtual void Dispose();
    private void NotDisposed();
    public sealed virtual void Commit();
    private void CommitChanges(bool requiresLock);
    private void OnChanged();
    public sealed virtual void Rollback();
    public ILockStrategy get_CallLevelLock();
    public sealed virtual int get_Count();
    private int get_LockTimeout();
    public void EnableCount();
    public void UnloadCache();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private RootLock<TKey, TValue> LockRoot(LockType<TKey, TValue> ltype, string methodName);
    private RootLock<TKey, TValue> LockRoot(LockType<TKey, TValue> ltype, string methodName, bool exclusive);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryUpdate(TKey key, TValue value);
    public sealed virtual bool TryUpdate(TKey key, TValue value, TValue comparisonValue);
    public sealed virtual bool TryUpdate(TKey key, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    public void AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> unorderedItems);
    public int AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> unorderedItems, bool allowUpdates);
    public int AddRangeSorted(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public int AddRangeSorted(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, bool allowUpdates);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual TValue GetOrAdd(TKey key, TValue value);
    public sealed virtual TValue GetOrAdd(TKey key, Converter`2<TKey, TValue> fnCreate);
    public sealed virtual bool TryAdd(TKey key, Converter`2<TKey, TValue> fnCreate);
    public sealed virtual bool TryAdd(TKey key, TValue value);
    [ObsoleteAttribute("Just use this[key] = value instead.")]
public void AddOrUpdate(TKey key, TValue value);
    public sealed virtual TValue AddOrUpdate(TKey key, TValue addValue, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public sealed virtual TValue AddOrUpdate(TKey key, Converter`2<TKey, TValue> fnCreate, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public sealed virtual bool AddOrUpdate(TKey key, T& createOrUpdateValue);
    private InsertResult<TKey, TValue> AddEntry(TKey key, T& info);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryRemove(TKey key, TValue& value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryRemove(TKey key, KeyValuePredicate`2<TKey, TValue> fnCondition);
    public sealed virtual bool TryRemove(TKey key, T& removeValue);
    private RemoveResult<TKey, TValue> RemoveEntry(TKey key, T& removeValue);
    public KeyValuePair`2<TKey, TValue> First();
    public bool TryGetFirst(KeyValuePair`2& item);
    public KeyValuePair`2<TKey, TValue> Last();
    public bool TryGetLast(KeyValuePair`2& item);
    public IEnumerable`1<KeyValuePair`2<TKey, TValue>> EnumerateFrom(TKey start);
    public IEnumerable`1<KeyValuePair`2<TKey, TValue>> EnumerateRange(TKey start, TKey end);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    [ObsoleteAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual void Clear();
    public sealed virtual bool get_IsReadOnly();
    [DebuggerNonUserCodeAttribute]
private static void Assert(bool condition);
    [DebuggerNonUserCodeAttribute]
private static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public void DebugSetOutput(TextWriter output);
    [ConditionalAttribute("DEBUG")]
public void DebugSetValidateOnCheckpoint(bool validate);
    [ConditionalAttribute("DEBUG")]
private void DebugComplete(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public void Print(TextWriter output, DebugFormat<TKey, TValue> format);
    [ConditionalAttribute("DEBUG")]
private void Print(NodePin<TKey, TValue> node, TextWriter output, int depth, DebugFormat<TKey, TValue> format);
    [ConditionalAttribute("DEBUG")]
public void Validate();
    [IteratorStateMachineAttribute("CSharpTest.Net.Collections.BPlusTree`2/<EnumerateFile>d__94")]
public static IEnumerable`1<KeyValuePair`2<TKey, TValue>> EnumerateFile(BPlusTreeOptions`2<TKey, TValue> options);
    public static int RecoverFile(Options<TKey, TValue> options);
    [IteratorStateMachineAttribute("CSharpTest.Net.Collections.BPlusTree`2/<RecoveryScan>d__96")]
public static IEnumerable`1<KeyValuePair`2<TKey, TValue>> RecoveryScan(Options<TKey, TValue> options, FileShare sharing);
    private static bool IngoreDataInvalid(Exception input);
    private int AddRange(NodePin<TKey, TValue> thisLock, KeyRange& range, AddRangeInfo<TKey, TValue> value, NodePin<TKey, TValue> parent, int parentIx);
    public int BulkInsert(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public int BulkInsert(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, BulkInsertOptions bulkOptions);
    private Node<TKey, TValue> BulkWrite(ICollection`1<IStorageHandle> handles, Int32& counter, IEnumerable`1<KeyValuePair`2<TKey, TValue>> itemsEnum);
    private void InsertWorkingNode(ICollection`1<IStorageHandle> handles, List`1<Node<TKey, TValue>> working, int index, Element<TKey, TValue> child);
    [IteratorStateMachineAttribute("CSharpTest.Net.Collections.BPlusTree`2/<EnumerateNodeContents>d__108")]
private IEnumerable`1<KeyValuePair`2<TKey, TValue>> EnumerateNodeContents(NodePin<TKey, TValue> root);
    private void DeleteTree(NodePin<TKey, TValue> pin);
    private RemoveResult<TKey, TValue> Delete(NodePin<TKey, TValue> thisLock, TKey key, T& condition, NodePin<TKey, TValue> parent, int parentIx);
    private void CopyElements(Node<TKey, TValue> src, int srcIndex, Node<TKey, TValue> dest, int destIndex, int count, TKey firstSrcKey);
    private void Join(NodePin<TKey, TValue> small, NodePin<TKey, TValue> big, bool moveToBigger, NodePin<TKey, TValue> parent, int parentSmallIndex);
    private InsertResult<TKey, TValue> Insert(NodePin<TKey, TValue> thisLock, TKey key, T& value, NodePin<TKey, TValue> parent, int parentIx);
    private NodePin<TKey, TValue> Split(NodeTransaction<TKey, TValue> trans, NodePin& thisLock, NodePin<TKey, TValue> parentLock, int parentIx, TKey& splitKey, bool leftHeavy);
    private bool Seek(NodePin<TKey, TValue> thisLock, TKey key, NodePin& pin, Int32& offset);
    private bool Search(NodePin<TKey, TValue> thisLock, TKey key, TValue& value);
    private bool SeekToEdge(NodePin<TKey, TValue> thisLock, bool first, NodePin& pin, Int32& offset);
    private bool TryGetEdge(NodePin<TKey, TValue> thisLock, bool first, KeyValuePair`2& item);
    private bool Update(NodePin<TKey, TValue> thisLock, TKey key, T& value);
    private int CountValues(NodePin<TKey, TValue> thisLock);
}
public abstract class CSharpTest.Net.Collections.BPlusTreeOptions`2 : object {
    private ISerializer`1<TKey> _keySerializer;
    private ISerializer`1<TValue> _valueSerializer;
    private IComparer`1<TKey> _keyComparer;
    private StorageType _storageType;
    private CreatePolicy _createFile;
    private bool _readOnly;
    private ILockFactory _lockingFactory;
    private ILockStrategy _callLevelLock;
    private int _lockTimeout;
    private int _minimumChildNodes;
    private int _maximumChildNodes;
    private int _fillChildNodes;
    private int _minimumValueNodes;
    private int _maximumValueNodes;
    private int _fillValueNodes;
    private int _fileBlockSize;
    private ExistingLogAction _existingLogAction;
    private string _fileName;
    private INodeStorage _storageSystem;
    private CachePolicy _cachePolicy;
    private int _keepAliveMinHistory;
    private int _keepAliveMaxHistory;
    private int _keepAliveTimeout;
    internal bool UseStorageCache;
    internal ITransactionLog`2<TKey, TValue> LogFile;
    private FactoryMethod`1<IObjectKeepAlive> _cacheKeepAliveFactory;
    [CompilerGeneratedAttribute]
private long <TransactionLogLimit>k__BackingField;
    public ISerializer`1<TKey> KeySerializer { get; }
    public ISerializer`1<TValue> ValueSerializer { get; }
    public IComparer`1<TKey> KeyComparer { get; public set; }
    public FileVersion FileVersion { get; }
    public StorageType StorageType { get; public set; }
    public bool ReadOnly { get; public set; }
    public INodeStorage StorageSystem { get; public set; }
    public string FileName { get; public set; }
    public CreatePolicy CreateFile { get; public set; }
    public int FileBlockSize { get; public set; }
    public int LockTimeout { get; public set; }
    public ILockFactory LockingFactory { get; public set; }
    public ILockStrategy CallLevelLock { get; public set; }
    unknown int BTreeOrder {public set; }
    public int MinimumChildNodes { get; public set; }
    public int MaximumChildNodes { get; public set; }
    public int MinimumValueNodes { get; public set; }
    public int MaximumValueNodes { get; public set; }
    public CachePolicy CachePolicy { get; public set; }
    public FactoryMethod`1<IObjectKeepAlive> CacheKeepAliveFactory { get; public set; }
    public int CacheKeepAliveMinimumHistory { get; public set; }
    public int CacheKeepAliveMaximumHistory { get; public set; }
    public int CacheKeepAliveTimeout { get; public set; }
    internal ExistingLogAction ExistingLogAction { get; internal set; }
    internal long TransactionLogLimit { get; internal set; }
    internal int FillChildNodes { get; }
    internal int FillValueNodes { get; }
    protected BPlusTreeOptions`2(ISerializer`1<TKey> keySerializer, ISerializer`1<TValue> valueSerializer, IComparer`1<TKey> comparer);
    public ISerializer`1<TKey> get_KeySerializer();
    public ISerializer`1<TValue> get_ValueSerializer();
    public IComparer`1<TKey> get_KeyComparer();
    public void set_KeyComparer(IComparer`1<TKey> value);
    public abstract virtual FileVersion get_FileVersion();
    public void CalcBTreeOrder(int avgKeySizeBytes, int avgValueSizeBytes);
    protected abstract virtual void CalculateOrder(int avgKeySizeBytes, int avgValueSizeBytes);
    public StorageType get_StorageType();
    public void set_StorageType(StorageType value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public INodeStorage get_StorageSystem();
    public void set_StorageSystem(INodeStorage value);
    public string get_FileName();
    public void set_FileName(string value);
    public CreatePolicy get_CreateFile();
    public void set_CreateFile(CreatePolicy value);
    public int get_FileBlockSize();
    public void set_FileBlockSize(int value);
    public int get_LockTimeout();
    public void set_LockTimeout(int value);
    public ILockFactory get_LockingFactory();
    public void set_LockingFactory(ILockFactory value);
    public virtual ILockStrategy get_CallLevelLock();
    public virtual void set_CallLevelLock(ILockStrategy value);
    public void set_BTreeOrder(int value);
    public int get_MinimumChildNodes();
    public void set_MinimumChildNodes(int value);
    public int get_MaximumChildNodes();
    public void set_MaximumChildNodes(int value);
    public int get_MinimumValueNodes();
    public void set_MinimumValueNodes(int value);
    public int get_MaximumValueNodes();
    public void set_MaximumValueNodes(int value);
    public CachePolicy get_CachePolicy();
    public void set_CachePolicy(CachePolicy value);
    public FactoryMethod`1<IObjectKeepAlive> get_CacheKeepAliveFactory();
    public void set_CacheKeepAliveFactory(FactoryMethod`1<IObjectKeepAlive> value);
    public int get_CacheKeepAliveMinimumHistory();
    public void set_CacheKeepAliveMinimumHistory(int value);
    public int get_CacheKeepAliveMaximumHistory();
    public void set_CacheKeepAliveMaximumHistory(int value);
    public int get_CacheKeepAliveTimeout();
    public void set_CacheKeepAliveTimeout(int value);
    public BPlusTreeOptions`2<TKey, TValue> Clone();
    private sealed virtual override object System.ICloneable.Clone();
    protected void SetStorageCache(bool cached);
    protected void SetLogFile(ITransactionLog`2<TKey, TValue> logFile);
    internal ExistingLogAction get_ExistingLogAction();
    internal void set_ExistingLogAction(ExistingLogAction value);
    [CompilerGeneratedAttribute]
internal long get_TransactionLogLimit();
    [CompilerGeneratedAttribute]
internal void set_TransactionLogLimit(long value);
    internal abstract virtual INodeStorage CreateStorage();
    internal int get_FillChildNodes();
    internal int get_FillValueNodes();
    internal IObjectKeepAlive CreateCacheKeepAlive();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {_count}")]
public class CSharpTest.Net.Collections.BTreeDictionary`2 : object {
    public static int DefaultOrder;
    private Node<TKey, TValue> _root;
    private int _order;
    private IComparer`1<TKey> _comparer;
    private KvComparer<TKey, TValue> _kvcomparer;
    private int _count;
    private bool _isReadOnly;
    private Node<TKey, TValue> _first;
    private Node<TKey, TValue> _last;
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IComparer`1<TKey> Comparer { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public BTreeDictionary`2(IComparer`1<TKey> comparer);
    public BTreeDictionary`2(int order, IComparer`1<TKey> comparer);
    public BTreeDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> copyFrom);
    public BTreeDictionary`2(IComparer`1<TKey> comparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> copyFrom);
    public BTreeDictionary`2(int order, IComparer`1<TKey> comparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> copyFrom);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public IComparer`1<TKey> get_Comparer();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual void Clear();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public void AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    [ObsoleteAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual TValue GetOrAdd(TKey key, TValue value);
    public sealed virtual bool TryAdd(TKey key, TValue value);
    public sealed virtual bool TryUpdate(TKey key, TValue value);
    public sealed virtual bool TryUpdate(TKey key, TValue value, TValue comparisonValue);
    public sealed virtual bool TryRemove(TKey key, TValue& value);
    public KeyValuePair`2[] ToArray();
    public KeyValuePair`2<TKey, TValue> First();
    public bool TryGetFirst(KeyValuePair`2& item);
    public KeyValuePair`2<TKey, TValue> Last();
    public bool TryGetLast(KeyValuePair`2& item);
    public IEnumerable`1<KeyValuePair`2<TKey, TValue>> EnumerateFrom(TKey start);
    public IEnumerable`1<KeyValuePair`2<TKey, TValue>> EnumerateRange(TKey start, TKey end);
    private sealed virtual override object System.ICloneable.Clone();
    public BTreeDictionary`2<TKey, TValue> Clone();
    public BTreeDictionary`2<TKey, TValue> MakeReadOnly();
    private void Modify();
    private bool Seek(Node<TKey, TValue> from, TKey item, SeekResult& found);
    private bool Add(Node<TKey, TValue> parent, int myIx, Node<TKey, TValue> me, KeyValuePair`2<TKey, TValue> item, bool adding);
    private bool Remove(Node<TKey, TValue> parent, int myIx, Node<TKey, TValue> me, KeyValuePair`2& item);
    [ConditionalAttribute("DEBUG")]
public void DebugAssert();
}
[DebuggerDisplayAttribute("Count = {_count}")]
public class CSharpTest.Net.Collections.BTreeList`1 : object {
    public static int DefaultOrder;
    private Node<T> _root;
    private int _order;
    private IComparer`1<T> _comparer;
    private KvComparer<T> _kvcomparer;
    private int _count;
    private bool _isReadOnly;
    private Node<T> _first;
    private Node<T> _last;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IComparer`1<T> Comparer { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    public BTreeList`1(IComparer`1<T> comparer);
    public BTreeList`1(int order, IComparer`1<T> comparer);
    public BTreeList`1(IEnumerable`1<T> copyFrom);
    public BTreeList`1(IComparer`1<T> comparer, IEnumerable`1<T> copyFrom);
    public BTreeList`1(int order, IComparer`1<T> comparer, IEnumerable`1<T> copyFrom);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public IComparer`1<T> get_Comparer();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual void Clear();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    public sealed virtual void Add(T value);
    public void AddRange(IEnumerable`1<T> items);
    public sealed virtual bool Contains(T item);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    public sealed virtual bool Remove(T value);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    [ObsoleteAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool TryAddItem(T value);
    public T[] ToArray();
    public IEnumerable`1<T> EnumerateFrom(T start);
    public IEnumerable`1<T> EnumerateRange(T start, T end);
    private sealed virtual override object System.ICloneable.Clone();
    public BTreeList`1<T> Clone();
    public BTreeList`1<T> MakeReadOnly();
    private void Modify();
    private bool Seek(Node<T> from, T item, SeekResult& found);
    private bool Add(Node<T> parent, int myIx, Node<T> me, T item, bool adding);
    private bool Remove(Node<T> parent, int myIx, Node<T> me, T item);
}
public class CSharpTest.Net.Collections.BulkInsertOptions : object {
    private bool _inputIsSorted;
    private bool _commitOnCompletion;
    private bool _replaceContents;
    private DuplicateHandling _duplicateHandling;
    public bool InputIsSorted { get; public set; }
    public DuplicateHandling DuplicateHandling { get; public set; }
    public bool CommitOnCompletion { get; public set; }
    public bool ReplaceContents { get; public set; }
    public bool get_InputIsSorted();
    public void set_InputIsSorted(bool value);
    public DuplicateHandling get_DuplicateHandling();
    public void set_DuplicateHandling(DuplicateHandling value);
    public bool get_CommitOnCompletion();
    public void set_CommitOnCompletion(bool value);
    public bool get_ReplaceContents();
    public void set_ReplaceContents(bool value);
}
public enum CSharpTest.Net.Collections.CachePolicy : Enum {
    public int value__;
    public static CachePolicy None;
    public static CachePolicy All;
    public static CachePolicy Recent;
}
public enum CSharpTest.Net.Collections.CreatePolicy : Enum {
    public int value__;
    public static CreatePolicy Never;
    public static CreatePolicy Always;
    public static CreatePolicy IfNeeded;
}
public class CSharpTest.Net.Collections.DisposingList : DisposingList`1<IDisposable> {
    public DisposingList(IEnumerable`1<IDisposable> collection);
    public DisposingList(int capacity);
}
public class CSharpTest.Net.Collections.DisposingList`1 : List`1<T> {
    public DisposingList`1(IEnumerable`1<T> collection);
    public DisposingList`1(int capacity);
    public sealed virtual void Dispose();
}
public enum CSharpTest.Net.Collections.DuplicateHandling : Enum {
    public int value__;
    public static DuplicateHandling None;
    public static DuplicateHandling FirstValueWins;
    public static DuplicateHandling LastValueWins;
    public static DuplicateHandling RaisesException;
}
public enum CSharpTest.Net.Collections.ExistingLogAction : Enum {
    public int value__;
    public static ExistingLogAction Default;
    public static ExistingLogAction Ignore;
    public static ExistingLogAction Replay;
    public static ExistingLogAction ReplayAndCommit;
    public static ExistingLogAction Truncate;
}
public enum CSharpTest.Net.Collections.FileVersion : Enum {
    public int value__;
    public static FileVersion Version1;
    public static FileVersion Version2;
}
internal class CSharpTest.Net.Collections.HashUtilities : object {
    private static Int32[] PrimeNumbers;
    private static HashUtilities();
    internal static int SelectPrimeNumber(int hashSize);
}
public interface CSharpTest.Net.Collections.IConcurrentDictionary`2 {
    public abstract virtual TValue GetOrAdd(TKey key, Converter`2<TKey, TValue> fnCreate);
    public abstract virtual TValue AddOrUpdate(TKey key, TValue addValue, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public abstract virtual TValue AddOrUpdate(TKey key, Converter`2<TKey, TValue> fnCreate, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public abstract virtual bool AddOrUpdate(TKey key, T& createOrUpdateValue);
    public abstract virtual bool TryAdd(TKey key, Converter`2<TKey, TValue> fnCreate);
    public abstract virtual bool TryUpdate(TKey key, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public abstract virtual bool TryRemove(TKey key, KeyValuePredicate`2<TKey, TValue> fnCondition);
    public abstract virtual bool TryRemove(TKey key, T& removeValue);
}
public interface CSharpTest.Net.Collections.ICreateOrUpdateValue`2 {
}
public interface CSharpTest.Net.Collections.ICreateValue`2 {
    public abstract virtual bool CreateValue(TKey key, TValue& value);
}
public interface CSharpTest.Net.Collections.IDictionaryEx`2 {
    public abstract virtual TValue GetOrAdd(TKey key, TValue value);
    public abstract virtual bool TryAdd(TKey key, TValue value);
    public abstract virtual bool TryUpdate(TKey key, TValue value);
    public abstract virtual bool TryUpdate(TKey key, TValue value, TValue comparisonValue);
    public abstract virtual bool TryRemove(TKey key, TValue& value);
}
public interface CSharpTest.Net.Collections.INodeStorage {
    public abstract virtual IStorageHandle OpenRoot(Boolean& isNew);
    public abstract virtual void Reset();
    public abstract virtual bool TryGetNode(IStorageHandle handle, TNode& node, ISerializer`1<TNode> serializer);
    public abstract virtual IStorageHandle Create();
    public abstract virtual void Destroy(IStorageHandle handle);
    public abstract virtual void Update(IStorageHandle handle, ISerializer`1<TNode> serializer, TNode node);
}
public interface CSharpTest.Net.Collections.INodeStoreWithCount {
    public int Count { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual void set_Count(int value);
}
public interface CSharpTest.Net.Collections.IRemoveValue`2 {
    public abstract virtual bool RemoveValue(TKey key, TValue value);
}
public interface CSharpTest.Net.Collections.IStorageHandle {
}
public interface CSharpTest.Net.Collections.ITransactionLog`2 {
    public string FileName { get; }
    public long Size { get; }
    public abstract virtual void ReplayLog(IDictionary`2<TKey, TValue> target);
    public abstract virtual void ReplayLog(IDictionary`2<TKey, TValue> target, Int64& position);
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TValue>> MergeLog(IComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> existing);
    public abstract virtual void TruncateLog();
    public abstract virtual TransactionToken BeginTransaction();
    public abstract virtual void AddValue(TransactionToken& token, TKey key, TValue value);
    public abstract virtual void UpdateValue(TransactionToken& token, TKey key, TValue value);
    public abstract virtual void RemoveValue(TransactionToken& token, TKey key);
    public abstract virtual void CommitTransaction(TransactionToken& token);
    public abstract virtual void RollbackTransaction(TransactionToken& token);
    public abstract virtual string get_FileName();
    public abstract virtual long get_Size();
}
public interface CSharpTest.Net.Collections.IUpdateValue`2 {
    public abstract virtual bool UpdateValue(TKey key, TValue& value);
}
public class CSharpTest.Net.Collections.KeyValueComparer`2 : object {
    private IComparer`1<TKey> _keyComparer;
    private static KeyValueComparer`2<TKey, TValue> _defaultInstance;
    public static KeyValueComparer`2<TKey, TValue> Default { get; }
    public IComparer`1<TKey> Comparer { get; }
    public KeyValueComparer`2(IComparer`1<TKey> keyComparer);
    public static KeyValueComparer`2<TKey, TValue> get_Default();
    public IComparer`1<TKey> get_Comparer();
    public sealed virtual int Compare(KeyValuePair`2<TKey, TValue> x, KeyValuePair`2<TKey, TValue> y);
}
public class CSharpTest.Net.Collections.KeyValuePredicate`2 : MulticastDelegate {
    public KeyValuePredicate`2(object object, IntPtr method);
    public virtual bool Invoke(TKey key, TValue original);
    public virtual IAsyncResult BeginInvoke(TKey key, TValue original, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class CSharpTest.Net.Collections.KeyValueUpdate`2 : MulticastDelegate {
    public KeyValueUpdate`2(object object, IntPtr method);
    public virtual TValue Invoke(TKey key, TValue original);
    public virtual IAsyncResult BeginInvoke(TKey key, TValue original, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class CSharpTest.Net.Collections.LurchTable`2 : object {
    [CompilerGeneratedAttribute]
private Action`1<KeyValuePair`2<TKey, TValue>> ItemRemoved;
    [CompilerGeneratedAttribute]
private ItemUpdatedMethod<TKey, TValue> ItemUpdated;
    [CompilerGeneratedAttribute]
private Action`1<KeyValuePair`2<TKey, TValue>> ItemAdded;
    private static int OverAlloc;
    private static int FreeSlots;
    private IEqualityComparer`1<TKey> _comparer;
    private int _hsize;
    private int _lsize;
    private int _limit;
    private int _allocSize;
    private int _shift;
    private int _shiftMask;
    private LurchTableOrder _ordering;
    private Object[] _locks;
    private Int32[] _buckets;
    private FreeList[] _free;
    private Entry[][] _entries;
    private int _used;
    private int _count;
    private int _allocNext;
    private int _freeVersion;
    private KeyCollection<TKey, TValue> _keyCollection;
    private ValueCollection<TKey, TValue> _valueCollection;
    public int Count { get; }
    public LurchTableOrder Ordering { get; }
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Limit { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    [ObsoleteAttribute]
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    [ObsoleteAttribute]
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public LurchTable`2(int capacity);
    public LurchTable`2(int capacity, LurchTableOrder ordering);
    public LurchTable`2(int capacity, LurchTableOrder ordering, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(LurchTableOrder ordering, int limit);
    public LurchTable`2(LurchTableOrder ordering, int limit, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(LurchTableOrder ordering, int limit, int hashSize, int allocSize, int lockSize, IEqualityComparer`1<TKey> comparer);
    [CompilerGeneratedAttribute]
public void add_ItemRemoved(Action`1<KeyValuePair`2<TKey, TValue>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemRemoved(Action`1<KeyValuePair`2<TKey, TValue>> value);
    [CompilerGeneratedAttribute]
public void add_ItemUpdated(ItemUpdatedMethod<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public void remove_ItemUpdated(ItemUpdatedMethod<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public void add_ItemAdded(Action`1<KeyValuePair`2<TKey, TValue>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemAdded(Action`1<KeyValuePair`2<TKey, TValue>> value);
    public sealed virtual void Dispose();
    public sealed virtual int get_Count();
    public LurchTableOrder get_Ordering();
    public IEqualityComparer`1<TKey> get_Comparer();
    public int get_Limit();
    public void Initialize();
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual TValue GetOrAdd(TKey key, TValue value);
    public sealed virtual bool TryAdd(TKey key, TValue value);
    public sealed virtual bool TryUpdate(TKey key, TValue value);
    public sealed virtual bool TryUpdate(TKey key, TValue value, TValue comparisonValue);
    public sealed virtual bool TryRemove(TKey key, TValue& value);
    public sealed virtual TValue GetOrAdd(TKey key, Converter`2<TKey, TValue> fnCreate);
    public sealed virtual TValue AddOrUpdate(TKey key, TValue addValue, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public sealed virtual TValue AddOrUpdate(TKey key, Converter`2<TKey, TValue> fnCreate, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public sealed virtual bool AddOrUpdate(TKey key, T& createOrUpdateValue);
    public sealed virtual bool TryAdd(TKey key, Converter`2<TKey, TValue> fnCreate);
    public sealed virtual bool TryUpdate(TKey key, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public sealed virtual bool TryRemove(TKey key, KeyValuePredicate`2<TKey, TValue> fnCondition);
    public sealed virtual bool TryRemove(TKey key, T& removeValue);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private bool MoveNext(EnumState& state);
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public bool Peek(KeyValuePair`2& value);
    public KeyValuePair`2<TKey, TValue> Dequeue();
    public bool TryDequeue(KeyValuePair`2& value);
    public bool TryDequeue(Predicate`1<KeyValuePair`2<TKey, TValue>> predicate, KeyValuePair`2& value);
    private bool InternalGetValue(int hash, TKey key, TValue& value);
    private InsertResult<TKey, TValue> Insert(TKey key, T& value);
    private InsertResult<TKey, TValue> InternalInsert(int hash, TKey key, Int32& added, T& value);
    private bool Delete(TKey key, T& value);
    private void InternalLink(int index);
    private void InternalUnlink(int index);
    [ObsoleteAttribute("Release build inlining, so we need to ignore for testing.")]
private int AllocSlot();
    private void FreeSlot(Int32& index, int ver);
}
public enum CSharpTest.Net.Collections.LurchTableOrder : Enum {
    public int value__;
    public static LurchTableOrder None;
    public static LurchTableOrder Insertion;
    public static LurchTableOrder Modified;
    public static LurchTableOrder Access;
}
public static class CSharpTest.Net.Collections.MergeSort : object {
    public static void Sort(T[] list);
    internal static void Sort(T[] list, T[]& working, int offset, int count, IComparer`1<T> compare);
    public static void Sort(T[] list, IComparer`1<T> compare);
    public static void Sort(T[] list, int offset, int count, IComparer`1<T> compare);
    public static void Sort(T[] list, Comparison`1<T> compare);
    public static void Sort(T[] list, int offset, int count, Comparison`1<T> compare);
    private static void Sort(T[] src, T[] dest, int offset, int count, IComparer`1<T> compare);
}
public class CSharpTest.Net.Collections.OrderedEnumeration`1 : object {
    private static int DefaultLimit;
    private static int LimitMax;
    private IEnumerable`1<T> _unordered;
    private IComparer`1<T> _comparer;
    private ISerializer`1<T> _serializer;
    private int _memoryLimit;
    private DuplicateHandling _duplicateHandling;
    private bool _enumerated;
    public IComparer`1<T> Comparer { get; public set; }
    public ISerializer`1<T> Serializer { get; public set; }
    public int InMemoryLimit { get; public set; }
    public DuplicateHandling DuplicateHandling { get; public set; }
    public OrderedEnumeration`1(IEnumerable`1<T> unordered);
    public OrderedEnumeration`1(IComparer`1<T> comparer, IEnumerable`1<T> unordered);
    public OrderedEnumeration`1(IComparer`1<T> comparer, IEnumerable`1<T> unordered, ISerializer`1<T> serializer);
    public OrderedEnumeration`1(IComparer`1<T> comparer, IEnumerable`1<T> unordered, ISerializer`1<T> serializer, int memoryLimit);
    public IComparer`1<T> get_Comparer();
    public void set_Comparer(IComparer`1<T> value);
    public ISerializer`1<T> get_Serializer();
    public void set_Serializer(ISerializer`1<T> value);
    public int get_InMemoryLimit();
    public void set_InMemoryLimit(int value);
    public DuplicateHandling get_DuplicateHandling();
    public void set_DuplicateHandling(DuplicateHandling value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("CSharpTest.Net.Collections.OrderedEnumeration`1/<PagedAndOrdered>d__26")]
private IEnumerable`1<T> PagedAndOrdered();
    [IteratorStateMachineAttribute("CSharpTest.Net.Collections.OrderedEnumeration`1/<Read>d__27")]
private IEnumerable`1<T> Read(TempFile file, Stream io);
    [IteratorStateMachineAttribute("CSharpTest.Net.Collections.OrderedEnumeration`1/<Merge>d__28")]
public static IEnumerable`1<T> Merge(IComparer`1<T> comparer, IEnumerable`1<T> x, IEnumerable`1<T> y);
    public static IEnumerable`1<T> Merge(IEnumerable`1[] enums);
    public static IEnumerable`1<T> Merge(IComparer`1<T> comparer, IEnumerable`1[] enums);
    public static IEnumerable`1<T> Merge(IComparer`1<T> comparer, DuplicateHandling duplicateHandling, IEnumerable`1[] enums);
    private static IEnumerable`1<T> Merge(IComparer`1<T> comparer, int start, int count, IEnumerable`1[] enums);
    public static IEnumerable`1<T> WithDuplicateHandling(IEnumerable`1<T> items, IComparer`1<T> comparer, DuplicateHandling duplicateHandling);
}
public class CSharpTest.Net.Collections.OrderedKeyValuePairs`2 : OrderedEnumeration`1<KeyValuePair`2<TKey, TValue>> {
    public OrderedKeyValuePairs`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> unordered);
    public OrderedKeyValuePairs`2(IComparer`1<TKey> comparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> unordered);
    public OrderedKeyValuePairs`2(IComparer`1<TKey> comparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> unordered, ISerializer`1<KeyValuePair`2<TKey, TValue>> serializer);
    public OrderedKeyValuePairs`2(IComparer`1<TKey> comparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> unordered, ISerializer`1<KeyValuePair`2<TKey, TValue>> serializer, int memoryLimit);
    public OrderedKeyValuePairs`2(IComparer`1<TKey> comparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> unordered, ISerializer`1<TKey> keySerializer, ISerializer`1<TValue> valueSerializer);
    public OrderedKeyValuePairs`2(IComparer`1<TKey> comparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> unordered, ISerializer`1<TKey> keySerializer, ISerializer`1<TValue> valueSerializer, int memoryLimit);
    public static IEnumerable`1<KeyValuePair`2<TKey, TValue>> Merge(IComparer`1<TKey> comparer, IEnumerable`1[] enums);
    public static IEnumerable`1<KeyValuePair`2<TKey, TValue>> Merge(IComparer`1<TKey> comparer, DuplicateHandling duplicateHandling, IEnumerable`1[] enums);
}
public class CSharpTest.Net.Collections.OrdinalList : object {
    private static Byte[] BitCount;
    private Byte[] _bits;
    public int Count { get; }
    public int Ceiling { get; public set; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private static OrdinalList();
    public OrdinalList(Byte[] fromBits);
    public OrdinalList(IEnumerable`1<int> contents);
    public sealed virtual void Clear();
    public sealed virtual int get_Count();
    public int get_Ceiling();
    public void set_Ceiling(int value);
    private void AllocFor(int max);
    public void AddRange(IEnumerable`1<int> contents);
    public sealed virtual void Add(int item);
    public sealed virtual bool Remove(int item);
    public sealed virtual bool Contains(int item);
    public sealed virtual void CopyTo(Int32[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public Int32[] ToArray();
    public Byte[] ToByteArray();
    public OrdinalList Invert(int ceiling);
    public OrdinalList IntersectWith(OrdinalList other);
    public OrdinalList UnionWith(OrdinalList other);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public IEnumerable`1<int> EnumerateFrom(int startAt);
    [IteratorStateMachineAttribute("CSharpTest.Net.Collections.OrdinalList/<EnumerateRange>d__31")]
public IEnumerable`1<int> EnumerateRange(int startAt, int endAt);
    public sealed virtual IEnumerator`1<int> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override object System.ICloneable.Clone();
    public OrdinalList Clone();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{ToArray()}")]
public class CSharpTest.Net.Collections.SetList`1 : object {
    private static SetList`1<T> __empty;
    private List`1<T> _list;
    private IComparer`1<T> _comparer;
    public static SetList`1<T> EmptySet { get; }
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SetList`1(IComparer`1<T> comparer);
    public SetList`1(int capacity);
    public SetList`1(int capacity, IComparer`1<T> comparer);
    public SetList`1(IEnumerable`1<T> items);
    public SetList`1(ICollection`1<T> items);
    public SetList`1(IEnumerable`1<T> items, IComparer`1<T> comparer);
    public SetList`1(ICollection`1<T> items, IComparer`1<T> comparer);
    private SetList`1(int capacity, IEnumerable`1<T> items, IComparer`1<T> comparer);
    private SetList`1(List`1<T> items, IComparer`1<T> comparer);
    public static SetList`1<T> get_EmptySet();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual int IndexOf(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    public sealed virtual void Clear();
    public sealed virtual void Add(T item);
    public void Add(T item, Int32& index);
    public void AddRange(IEnumerable`1<T> other);
    public bool Replace(T item);
    public bool ReplaceAll(IEnumerable`1<T> items);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveAll(IEnumerable`1<T> other);
    public SetList`1<T> IntersectWith(SetList`1<T> other);
    public SetList`1<T> UnionWith(SetList`1<T> other);
    public SetList`1<T> ComplementOf(SetList`1<T> other);
    public SetList`1<T> SubtractSet(SetList`1<T> other);
    public SetList`1<T> ExclusiveOrWith(SetList`1<T> other);
    public bool IsEqualTo(SetList`1<T> other);
    public bool IsSubsetOf(SetList`1<T> other);
    public bool IsSupersetOf(SetList`1<T> other);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual SetList`1<T> Clone();
    private sealed virtual override object System.ICloneable.Clone();
}
public enum CSharpTest.Net.Collections.StoragePerformance : Enum {
    public int value__;
    public static StoragePerformance Fastest;
    public static StoragePerformance LogFileInCache;
    public static StoragePerformance CommitToCache;
    public static StoragePerformance LogFileNoCache;
    public static StoragePerformance CommitToDisk;
    public static StoragePerformance Default;
}
public enum CSharpTest.Net.Collections.StorageType : Enum {
    public int value__;
    public static StorageType Memory;
    public static StorageType Disk;
    public static StorageType Custom;
}
public class CSharpTest.Net.Collections.TransactionLog`2 : object {
    private static int StateOpen;
    private static int StateCommitted;
    private static int StateRolledback;
    private object _logSync;
    private TransactionLogOptions`2<TKey, TValue> _options;
    private long _transactionId;
    private long _fLength;
    private Stream _logfile;
    public string FileName { get; }
    public long Size { get; }
    public TransactionLog`2(TransactionLogOptions`2<TKey, TValue> options);
    public sealed virtual string get_FileName();
    private sealed virtual override void System.IDisposable.Dispose();
    public void Close();
    public sealed virtual long get_Size();
    public sealed virtual void ReplayLog(IDictionary`2<TKey, TValue> target);
    public sealed virtual void ReplayLog(IDictionary`2<TKey, TValue> target, Int64& position);
    [IteratorStateMachineAttribute("CSharpTest.Net.Collections.TransactionLog`2/<MergeLog>d__22")]
public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TValue>> MergeLog(IComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> existing);
    [IteratorStateMachineAttribute("CSharpTest.Net.Collections.TransactionLog`2/<EnumerateLog>d__23")]
private IEnumerable`1<LogEntry<TKey, TValue>> EnumerateLog(Int64[] position);
    public sealed virtual void TruncateLog();
    private void TruncateLog(long position);
    public sealed virtual TransactionToken BeginTransaction();
    public sealed virtual void AddValue(TransactionToken& token, TKey key, TValue value);
    public sealed virtual void UpdateValue(TransactionToken& token, TKey key, TValue value);
    public sealed virtual void RemoveValue(TransactionToken& token, TKey key);
    private void Write(TransactionToken& token, OperationCode<TKey, TValue> operation, TKey key, TValue value);
    public sealed virtual void CommitTransaction(TransactionToken& token);
    private void WriteBytes(Byte[] bytes, int offset, int length);
    public sealed virtual void RollbackTransaction(TransactionToken& token);
}
public class CSharpTest.Net.Collections.TransactionLogOptions`2 : object {
    private string _fileName;
    private ISerializer`1<TKey> _keySerializer;
    private ISerializer`1<TValue> _valueSerializer;
    private FileOptions _foptions;
    private int _fbuffer;
    private bool _readOnly;
    public ISerializer`1<TKey> KeySerializer { get; }
    public ISerializer`1<TValue> ValueSerializer { get; }
    public string FileName { get; }
    public FileOptions FileOptions { get; public set; }
    public int FileBuffer { get; public set; }
    public bool ReadOnly { get; public set; }
    public TransactionLogOptions`2(string fileName, ISerializer`1<TKey> keySerializer, ISerializer`1<TValue> valueSerializer);
    public ISerializer`1<TKey> get_KeySerializer();
    public ISerializer`1<TValue> get_ValueSerializer();
    public string get_FileName();
    public FileOptions get_FileOptions();
    public void set_FileOptions(FileOptions value);
    public int get_FileBuffer();
    public void set_FileBuffer(int value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public TransactionLogOptions`2<TKey, TValue> Clone();
}
public class CSharpTest.Net.Collections.TransactionToken : ValueType {
    public int State;
    public long Handle;
    public object Object;
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("CSharpTest.Net.Generators", "2.0")]
public class CSharpTest.Net.DeadlockException : BaseAssertionException {
    protected DeadlockException(SerializationInfo info, StreamingContext context);
    protected DeadlockException(Exception innerException, int hResult, string message);
    public DeadlockException(Exception innerException);
    internal static Exception Create(int hResult, string message);
    public static void Assert(bool condition);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("CSharpTest.Net.Generators", "2.0")]
public class CSharpTest.Net.DebugAssertionFailedException : ApplicationException {
    protected DebugAssertionFailedException(SerializationInfo info, StreamingContext context);
    protected DebugAssertionFailedException(Exception innerException, int hResult, string message);
    public DebugAssertionFailedException(string message);
    public DebugAssertionFailedException(string message, Exception innerException);
    internal static Exception Create(int hResult, string message);
    public static void Assert(bool condition, string message);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("CSharpTest.Net.Generators", "2.0")]
public class CSharpTest.Net.DuplicateKeyException : ApplicationException {
    protected DuplicateKeyException(SerializationInfo info, StreamingContext context);
    protected DuplicateKeyException(Exception innerException, int hResult, string message);
    public DuplicateKeyException(Exception innerException);
    internal static Exception Create(int hResult, string message);
    public static void Assert(bool condition);
}
public class CSharpTest.Net.Interfaces.DelegateFactory`1 : object {
    private FactoryMethod`1<T> _method;
    public DelegateFactory`1(FactoryMethod`1<T> method);
    public sealed virtual T Create();
}
public class CSharpTest.Net.Interfaces.FactoryMethod`1 : MulticastDelegate {
    public FactoryMethod`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public interface CSharpTest.Net.Interfaces.ICloneable`1 {
    public abstract virtual T Clone();
}
public interface CSharpTest.Net.Interfaces.IFactory`1 {
    public abstract virtual T Create();
}
public class CSharpTest.Net.Interfaces.InstanceFactory`1 : object {
    private T _instance;
    public InstanceFactory`1(T instance);
    public sealed virtual T Create();
}
public interface CSharpTest.Net.Interfaces.ITransactable {
    public abstract virtual void Commit();
    public abstract virtual void Rollback();
}
public class CSharpTest.Net.Interfaces.NewFactory`1 : object {
    public sealed virtual T Create();
}
public static class CSharpTest.Net.Interfaces.Singleton`1 : object {
    public static T Instance { get; }
    public static IFactory`1<T> Factory { get; }
    public static T get_Instance();
    public static IFactory`1<T> get_Factory();
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("CSharpTest.Net.Generators", "2.0")]
public class CSharpTest.Net.InvalidConfigurationValueException : ArgumentException {
    protected InvalidConfigurationValueException(SerializationInfo info, StreamingContext context);
    protected InvalidConfigurationValueException(Exception innerException, int hResult, string message);
    public InvalidConfigurationValueException(string property);
    public InvalidConfigurationValueException(string property, Exception innerException);
    public InvalidConfigurationValueException(string property, string message);
    public InvalidConfigurationValueException(string property, string message, Exception innerException);
    internal static Exception Create(int hResult, string message);
    public static void Assert(bool condition, string property);
    public static void Assert(bool condition, string property, string message);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("CSharpTest.Net.Generators", "2.0")]
public class CSharpTest.Net.InvalidNodeHandleException : BaseAssertionException {
    protected InvalidNodeHandleException(SerializationInfo info, StreamingContext context);
    protected InvalidNodeHandleException(Exception innerException, int hResult, string message);
    public InvalidNodeHandleException(Exception innerException);
    internal static Exception Create(int hResult, string message);
    public static void Assert(bool condition);
}
public abstract class CSharpTest.Net.IO.AggregateStream : Stream {
    private Stream _stream;
    protected Stream Stream { get; protected set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected AggregateStream(Stream io);
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual Stream get_Stream();
    protected virtual void set_Stream(Stream value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class CSharpTest.Net.IO.BinaryComparer : object {
    public static bool Equals(Byte[] ar1, Byte[] ar2);
    public static int Compare(Byte[] ar1, Byte[] ar2);
    public static int GetHashCode(Byte[] bytes);
    private sealed virtual override int System.Collections.Generic.IComparer<System.Byte[]>.Compare(Byte[] x, Byte[] y);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Byte[]>.Equals(Byte[] x, Byte[] y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Byte[]>.GetHashCode(Byte[] bytes);
}
[DebuggerDisplayAttribute("{Value:X8}")]
public class CSharpTest.Net.IO.Crc32 : ValueType {
    private static Int32[] Table;
    private int _crc32;
    public int Value { get; }
    private static Crc32();
    public Crc32(int crc);
    public Crc32(string text);
    public Crc32(Byte[] bytes);
    public virtual string ToString();
    public int get_Value();
    public void Add(byte b);
    public static Crc32 op_Addition(Crc32 chksum, byte b);
    public void Add(Byte[] bytes);
    public void Add(Byte[] bytes, int start, int length);
    public static Crc32 op_Addition(Crc32 chksum, Byte[] bytes);
    public void Add(string text);
    public static Crc32 op_Addition(Crc32 chksum, string text);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Crc32 other);
    public sealed virtual bool Equals(int crc32);
    public static bool op_Equality(Crc32 x, Crc32 y);
    public static bool op_Inequality(Crc32 x, Crc32 y);
    public static bool op_Equality(Crc32 x, int y);
    public static bool op_Inequality(Crc32 x, int y);
}
public class CSharpTest.Net.IO.FileStreamFactory : object {
    private static int DefaultBuffer;
    private string _filename;
    private FileMode _mode;
    private FileAccess _access;
    private FileShare _share;
    private int _bufferSize;
    private FileOptions _options;
    public string FileName { get; }
    public FileStreamFactory(string filename, FileMode mode);
    public FileStreamFactory(string filename, FileMode mode, FileAccess access);
    public FileStreamFactory(string filename, FileMode mode, FileAccess access, FileShare share);
    public FileStreamFactory(string filename, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStreamFactory(string filename, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public string get_FileName();
    public sealed virtual Stream Create();
}
public class CSharpTest.Net.IO.FragmentedFile : object {
    private static FileOptions NoBuffering;
    public static FileOptions OptionsDefault;
    public static FileOptions OptionsWriteThrough;
    public static FileOptions OptionsNoBuffering;
    private StreamCache _streamCache;
    private bool _useAlignedIo;
    private long _maskVersion;
    private long _maskOffset;
    private int _blockSize;
    private int _reallocSize;
    private object _syncFreeBlock;
    private FileBlock _header;
    private bool _disposed;
    private long _nextFree;
    public long FirstIdentity { get; }
    public FragmentedFile(string filename, int blockSize);
    public FragmentedFile(string filename, int blockSize, int growthRate, int cacheLimit, FileOptions options);
    public FragmentedFile(string filename, int blockSize, int growthRate, int cacheLimit, FileAccess access, FileShare share, FileOptions options);
    public FragmentedFile(IFactory`1<Stream> streamFactory, int blockSize, int growthRate, int cacheLimit);
    protected FragmentedFile(IFactory`1<Stream> streamFactory, int blockSize, int growthRate, int cacheLimit, FileOptions options);
    public sealed virtual void Dispose();
    public static FragmentedFile CreateNew(string filename, int blockSize);
    public static FragmentedFile CreateNew(string filename, int blockSize, int growthRate, int cacheLimit, FileOptions options);
    public static FragmentedFile CreateNew(IFactory`1<Stream> streamFactory, int blockSize, int growthRate, int cacheLimit);
    private static void WriteEmtpy(IFactory`1<Stream> streamFactory, int blockSize);
    public void Clear();
    public long Create();
    public Stream Create(Int64& identity);
    public Stream Open(long identity, FileAccess access);
    public void Delete(long identity);
    private Stream OpenBlock(FileAccess access, long identity);
    public long get_FirstIdentity();
    private long LastAllocated(Stream s);
    private static void SetBlockSize(int value, Int32& blockSize, Int64& maskVersion, Int64& maskOffset);
    private long RecoverFreeBlocks();
    [IteratorStateMachineAttribute("CSharpTest.Net.IO.FragmentedFile/<ForeachBlock>d__35")]
public IEnumerable`1<KeyValuePair`2<long, Stream>> ForeachBlock(bool allocatedOnly, bool verifyReads, Converter`2<Exception, bool> ignoreException);
    private bool FreeBlock(long blockId, BlockFlags expected);
    private void ResizeFile(long startBlock, long endBlock);
    private long AllocBlock(FileBlock block, BlockFlags type);
    private void ReadBlock(long ordinal, FileBlock block, int length, BlockFlags type);
    private void ReadBlock(long ordinal, FileBlock block, int length, BlockFlags type, bool exactId);
    private void WriteBlock(long ordinal, FileBlock block, int length);
}
public static class CSharpTest.Net.IO.IOStream : object {
    public static Byte[] ReadAllBytes(Stream io);
    public static string ReadAllText(Stream io, Encoding encoding);
    public static void Read(Stream io, Byte[] bytes);
    public static Byte[] Read(Stream io, int nBytes);
    public static void Read(Stream io, Byte[] bytes, int length);
    public static int ReadChunk(Stream io, Byte[] bytes, int length);
    public static int ReadChunk(Stream io, Byte[] bytes, int offset, int length);
    public static long CopyStream(Stream input, Stream output);
    public static long CopyStream(Stream input, Stream output, long stopAfter);
}
public class CSharpTest.Net.IO.StreamCache : Disposable {
    private IFactory`1<Stream> _streamFactory;
    private Stream[] _streams;
    private Mutex[] _handles;
    public StreamCache(IFactory`1<Stream> streamFactory);
    public StreamCache(IFactory`1<Stream> streamFactory, int maxItem);
    protected virtual void Dispose(bool disposing);
    private void InvalidHandle(Mutex ownerHandle);
    public Stream Open();
    private sealed virtual override Stream CSharpTest.Net.Interfaces.IFactory<System.IO.Stream>.Create();
    public Stream Open(FileAccess access);
}
[DebuggerDisplayAttribute("{TempPath}")]
public class CSharpTest.Net.IO.TempFile : object {
    private string _filename;
    public string TempPath { get; protected set; }
    [DebuggerNonUserCodeAttribute]
public bool Exists { get; }
    public long Length { get; public set; }
    public FileInfo Info { get; }
    public TempFile(string filename);
    public static TempFile Attach(string existingPath);
    [DebuggerNonUserCodeAttribute]
public static TempFile FromExtension(string extensionWithDot);
    [DebuggerNonUserCodeAttribute]
public static string CreateTempPath(string extensionWithDot);
    public static TempFile FromCopy(string srcFileName);
    public static void Delete(string path);
    protected virtual override void Finalize();
    [DebuggerNonUserCodeAttribute]
public string get_TempPath();
    protected void set_TempPath(string value);
    public sealed virtual void Dispose();
    [DebuggerNonUserCodeAttribute]
protected virtual void Dispose(bool disposing);
    public string Detatch();
    public bool get_Exists();
    public long get_Length();
    public void set_Length(long value);
    public FileInfo get_Info();
    public Byte[] ReadAllBytes();
    public void WriteAllBytes(Byte[] data);
    public string ReadAllText();
    public void WriteAllText(string content);
    public void Delete();
    public Stream Create();
    public Stream Open();
    public Stream Read();
    public Stream Read(FileShare shared);
    public void CopyTo(string target);
    public void CopyTo(string target, bool replace);
}
public class CSharpTest.Net.IO.TransactedCompoundFile : object {
    private static int BlockHeaderSize;
    private static int OffsetOfHeaderSize;
    private static int OffsetOfLength;
    private static int OffsetOfCrc32;
    private static int OffsetOfBlockCount;
    private static int OffsetOfBlockId;
    private Options _options;
    private int BlockSize;
    private int BlocksPerSection;
    private long SectionSize;
    private object _sync;
    private FileSection[] _sections;
    private IFactory`1<Stream> _readers;
    private Stream _stream;
    private FPut _fcommit;
    private FPut _fput;
    private FGet _fget;
    private int _firstFreeBlock;
    private int _prevFreeBlock;
    private int _prevFreeHandle;
    private OrdinalList _freeHandles;
    private OrdinalList _freeBlocks;
    private OrdinalList _reservedBlocks;
    public static UInt32 FirstIdentity { get; }
    public TransactedCompoundFile(string filename);
    public TransactedCompoundFile(Options options);
    public static UInt32 get_FirstIdentity();
    private void fput(long position, Byte[] bytes, int offset, int length);
    public sealed virtual void Dispose();
    private static bool FlushFileBuffers(IntPtr hFile);
    private void FlushStream(Stream stream);
    private void Flush(bool forced);
    public sealed virtual void Commit();
    public void Commit(Action`1<T> stageCommit, T value);
    public sealed virtual void Rollback();
    private void LoadSections(Stream stream);
    private bool LoadSections(Stream stream, LoadFrom from);
    private int AddSection();
    private UInt32 TakeBlocks(int blocksNeeded);
    private void FreeBlocks(BlockRef block);
    private int ReadBytes(long position, Byte[] bytes, int offset, int length);
    public UInt32 Create();
    public void Write(UInt32 handle, Byte[] bytes, int offset, int length);
    public Stream Read(UInt32 handle);
    public void Delete(UInt32 handle);
    public void Clear();
    private static UInt32 GetUInt32(Byte[] bytes, int start);
    private static void PutUInt32(Byte[] bytes, int start, UInt32 value);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("CSharpTest.Net.Generators", "2.0")]
public class CSharpTest.Net.LockTimeoutException : TimeoutException {
    protected LockTimeoutException(SerializationInfo info, StreamingContext context);
    protected LockTimeoutException(Exception innerException, int hResult, string message);
    public LockTimeoutException(Exception innerException);
    internal static Exception Create(int hResult, string message);
    public static void Assert(bool condition);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("CSharpTest.Net.Generators", "2.0")]
public class CSharpTest.Net.LurchTableCorruptionException : ApplicationException {
    protected LurchTableCorruptionException(SerializationInfo info, StreamingContext context);
    protected LurchTableCorruptionException(Exception innerException, int hResult, string message);
    public LurchTableCorruptionException(Exception innerException);
    internal static Exception Create(int hResult, string message);
    public static void Assert(bool condition);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CSharpTest.Net.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string IOStreamCompressionFailed { get; }
    internal static string IOStreamFailedToRead { get; }
    internal static string ProcessRunnerAlreadyRunning { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_IOStreamCompressionFailed();
    internal static string get_IOStreamFailedToRead();
    internal static string get_ProcessRunnerAlreadyRunning();
    public static string FailedToConstructSingleton(Type type);
    public static string InvalidFileExtension(string ext);
    public static string StringConverterTryParse(Type type);
}
public class CSharpTest.Net.Serialization.BytesSerializer : object {
    public static ISerializer`1<Byte[]> RawBytes;
    private static BytesSerializer();
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Byte[]>.WriteTo(Byte[] value, Stream stream);
    private sealed virtual override Byte[] CSharpTest.Net.Serialization.ISerializer<System.Byte[]>.ReadFrom(Stream stream);
}
public interface CSharpTest.Net.Serialization.ISerializer`1 {
    public abstract virtual void WriteTo(T value, Stream stream);
    public abstract virtual T ReadFrom(Stream stream);
}
public class CSharpTest.Net.Serialization.KeyValueSerializer`2 : object {
    private ISerializer`1<TKey> _keySerializer;
    private ISerializer`1<TValue> _valueSerializer;
    public KeyValueSerializer`2(ISerializer`1<TKey> keySerializer, ISerializer`1<TValue> valueSerializer);
    public sealed virtual void WriteTo(KeyValuePair`2<TKey, TValue> value, Stream stream);
    public sealed virtual KeyValuePair`2<TKey, TValue> ReadFrom(Stream stream);
}
public class CSharpTest.Net.Serialization.LimitedSerializer : object {
    private int _maxLength;
    public static ISerializer`1<Byte[]> Bytes1024;
    public static ISerializer`1<Byte[]> Bytes2048;
    public static ISerializer`1<Byte[]> Bytes4092;
    public static ISerializer`1<Byte[]> Bytes8196;
    public static ISerializer`1<string> String256;
    public static ISerializer`1<string> String512;
    public static ISerializer`1<string> String1024;
    internal static LimitedSerializer Unlimited;
    public LimitedSerializer(int maxLength);
    private static LimitedSerializer();
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.String>.WriteTo(string value, Stream stream);
    private sealed virtual override string CSharpTest.Net.Serialization.ISerializer<System.String>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Byte[]>.WriteTo(Byte[] value, Stream stream);
    private sealed virtual override Byte[] CSharpTest.Net.Serialization.ISerializer<System.Byte[]>.ReadFrom(Stream stream);
}
public class CSharpTest.Net.Serialization.PrimitiveSerializer : object {
    public static PrimitiveSerializer Instance;
    public static ISerializer`1<string> String;
    public static ISerializer`1<bool> Boolean;
    public static ISerializer`1<byte> Byte;
    public static ISerializer`1<sbyte> SByte;
    public static ISerializer`1<Byte[]> Bytes;
    public static ISerializer`1<char> Char;
    public static ISerializer`1<DateTime> DateTime;
    public static ISerializer`1<TimeSpan> TimeSpan;
    public static ISerializer`1<short> Int16;
    public static ISerializer`1<ushort> UInt16;
    public static ISerializer`1<int> Int32;
    public static ISerializer`1<UInt32> UInt32;
    public static ISerializer`1<long> Int64;
    public static ISerializer`1<ulong> UInt64;
    public static ISerializer`1<double> Double;
    public static ISerializer`1<float> Float;
    public static ISerializer`1<Guid> Guid;
    public static ISerializer`1<IntPtr> IntPtr;
    public static ISerializer`1<UIntPtr> UIntPtr;
    private static PrimitiveSerializer();
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.String>.WriteTo(string value, Stream stream);
    private sealed virtual override string CSharpTest.Net.Serialization.ISerializer<System.String>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Boolean>.WriteTo(bool value, Stream stream);
    private sealed virtual override bool CSharpTest.Net.Serialization.ISerializer<System.Boolean>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Byte>.WriteTo(byte value, Stream stream);
    private sealed virtual override byte CSharpTest.Net.Serialization.ISerializer<System.Byte>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.SByte>.WriteTo(sbyte value, Stream stream);
    private sealed virtual override sbyte CSharpTest.Net.Serialization.ISerializer<System.SByte>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Byte[]>.WriteTo(Byte[] value, Stream stream);
    private sealed virtual override Byte[] CSharpTest.Net.Serialization.ISerializer<System.Byte[]>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Char>.WriteTo(char value, Stream stream);
    private sealed virtual override char CSharpTest.Net.Serialization.ISerializer<System.Char>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.DateTime>.WriteTo(DateTime value, Stream stream);
    private sealed virtual override DateTime CSharpTest.Net.Serialization.ISerializer<System.DateTime>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.TimeSpan>.WriteTo(TimeSpan value, Stream stream);
    private sealed virtual override TimeSpan CSharpTest.Net.Serialization.ISerializer<System.TimeSpan>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Int16>.WriteTo(short value, Stream stream);
    private sealed virtual override short CSharpTest.Net.Serialization.ISerializer<System.Int16>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.UInt16>.WriteTo(ushort value, Stream stream);
    private sealed virtual override ushort CSharpTest.Net.Serialization.ISerializer<System.UInt16>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Int32>.WriteTo(int value, Stream stream);
    private sealed virtual override int CSharpTest.Net.Serialization.ISerializer<System.Int32>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.UInt32>.WriteTo(UInt32 value, Stream stream);
    private sealed virtual override UInt32 CSharpTest.Net.Serialization.ISerializer<System.UInt32>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Int64>.WriteTo(long value, Stream stream);
    private sealed virtual override long CSharpTest.Net.Serialization.ISerializer<System.Int64>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.UInt64>.WriteTo(ulong value, Stream stream);
    private sealed virtual override ulong CSharpTest.Net.Serialization.ISerializer<System.UInt64>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Double>.WriteTo(double value, Stream stream);
    private sealed virtual override double CSharpTest.Net.Serialization.ISerializer<System.Double>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Single>.WriteTo(float value, Stream stream);
    private sealed virtual override float CSharpTest.Net.Serialization.ISerializer<System.Single>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Guid>.WriteTo(Guid value, Stream stream);
    private sealed virtual override Guid CSharpTest.Net.Serialization.ISerializer<System.Guid>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.IntPtr>.WriteTo(IntPtr value, Stream stream);
    private sealed virtual override IntPtr CSharpTest.Net.Serialization.ISerializer<System.IntPtr>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.UIntPtr>.WriteTo(UIntPtr value, Stream stream);
    private sealed virtual override UIntPtr CSharpTest.Net.Serialization.ISerializer<System.UIntPtr>.ReadFrom(Stream stream);
}
public class CSharpTest.Net.Serialization.VariantNumberSerializer : object {
    public static VariantNumberSerializer Instance;
    public static ISerializer`1<int> Int32;
    public static ISerializer`1<UInt32> UInt32;
    public static ISerializer`1<long> Int64;
    public static ISerializer`1<ulong> UInt64;
    private static VariantNumberSerializer();
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Int32>.WriteTo(int value, Stream stream);
    private sealed virtual override int CSharpTest.Net.Serialization.ISerializer<System.Int32>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.UInt32>.WriteTo(UInt32 value, Stream stream);
    private sealed virtual override UInt32 CSharpTest.Net.Serialization.ISerializer<System.UInt32>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.Int64>.WriteTo(long value, Stream stream);
    private sealed virtual override long CSharpTest.Net.Serialization.ISerializer<System.Int64>.ReadFrom(Stream stream);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<System.UInt64>.WriteTo(ulong value, Stream stream);
    private sealed virtual override ulong CSharpTest.Net.Serialization.ISerializer<System.UInt64>.ReadFrom(Stream stream);
}
internal class CSharpTest.Net.Storage.BTreeFileStore : object {
    private static ISerializer`1<IStorageHandle> StorageHandleSerializer;
    private Byte[] _fileId;
    private FragmentedFile _file;
    private FileId _rootId;
    public BTreeFileStore(string filePath, int blockSize, int growthRate, int concurrentWriters, FileOptions options, bool readOnly);
    private BTreeFileStore(FragmentedFile filestore);
    private static BTreeFileStore();
    public sealed virtual void Dispose();
    public static BTreeFileStore CreateNew(string filepath, int blockSize, int growthRate, int concurrentWriters, FileOptions options);
    private static void CreateRoot(FragmentedFile file);
    public sealed virtual void Reset();
    public sealed virtual IStorageHandle OpenRoot(Boolean& isNew);
    public sealed virtual bool TryGetNode(IStorageHandle handleIn, TNode& node, ISerializer`1<TNode> serializer);
    public sealed virtual IStorageHandle Create();
    public sealed virtual void Destroy(IStorageHandle handleIn);
    public sealed virtual void Update(IStorageHandle handleIn, ISerializer`1<T> serializer, T node);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<CSharpTest.Net.Collections.IStorageHandle>.WriteTo(IStorageHandle handleIn, Stream stream);
    private sealed virtual override IStorageHandle CSharpTest.Net.Serialization.ISerializer<CSharpTest.Net.Collections.IStorageHandle>.ReadFrom(Stream stream);
}
internal class CSharpTest.Net.Storage.BTreeFileStoreV2 : object {
    private TransactedCompoundFile _file;
    private FileId _rootId;
    private Options _options;
    public BTreeFileStoreV2(Options options);
    public sealed virtual void Dispose();
    public sealed virtual void Commit();
    public sealed virtual void Rollback();
    private static void CreateRoot(TransactedCompoundFile file);
    public sealed virtual void Reset();
    public sealed virtual IStorageHandle OpenRoot(Boolean& isNew);
    public sealed virtual bool TryGetNode(IStorageHandle handleIn, TNode& node, ISerializer`1<TNode> serializer);
    public sealed virtual IStorageHandle Create();
    public sealed virtual void Destroy(IStorageHandle handleIn);
    public sealed virtual void Update(IStorageHandle handleIn, ISerializer`1<T> serializer, T node);
    private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<CSharpTest.Net.Collections.IStorageHandle>.WriteTo(IStorageHandle handleIn, Stream stream);
    private sealed virtual override IStorageHandle CSharpTest.Net.Serialization.ISerializer<CSharpTest.Net.Collections.IStorageHandle>.ReadFrom(Stream stream);
}
internal class CSharpTest.Net.Storage.BTreeMemoryStore : object {
    private ISerializer`1<string> _stringSerializer;
    private MyStorageHandle _root;
    public sealed virtual void Dispose();
    public sealed virtual IStorageHandle OpenRoot(Boolean& isNew);
    public sealed virtual void Reset();
    public sealed virtual bool TryGetNode(IStorageHandle handleIn, TNode& node, ISerializer`1<TNode> serializer);
    [ObsoleteAttribute("Not supported", "True")]
private sealed virtual override void CSharpTest.Net.Serialization.ISerializer<CSharpTest.Net.Collections.IStorageHandle>.WriteTo(IStorageHandle value, Stream stream);
    [ObsoleteAttribute("Not supported", "True")]
private sealed virtual override IStorageHandle CSharpTest.Net.Serialization.ISerializer<CSharpTest.Net.Collections.IStorageHandle>.ReadFrom(Stream stream);
    public sealed virtual IStorageHandle Create();
    public sealed virtual void Destroy(IStorageHandle handleIn);
    public sealed virtual void Update(IStorageHandle handleIn, ISerializer`1<T> serializer, T node);
}
public class CSharpTest.Net.Synchronization.ExclusiveLocking : object {
    private int _writeVersion;
    public int WriteVersion { get; }
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool TryRead(int timeout);
    public sealed virtual void ReleaseRead();
    public sealed virtual int get_WriteVersion();
    public sealed virtual bool TryWrite(int timeout);
    public sealed virtual void ReleaseWrite();
    public sealed virtual ReadLock Read();
    public sealed virtual ReadLock Read(int timeout);
    public sealed virtual WriteLock Write();
    public sealed virtual WriteLock Write(int timeout);
}
public class CSharpTest.Net.Synchronization.IgnoreLockFactory : object {
    public sealed virtual ILockStrategy Create();
}
public class CSharpTest.Net.Synchronization.IgnoreLocking : object {
    public static IgnoreLocking Instance;
    public int WriteVersion { get; }
    private static IgnoreLocking();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual int get_WriteVersion();
    public sealed virtual bool TryRead(int timeout);
    public sealed virtual void ReleaseRead();
    public sealed virtual bool TryWrite(int timeout);
    public sealed virtual void ReleaseWrite();
    public sealed virtual ReadLock Read();
    public sealed virtual ReadLock Read(int timeout);
    public sealed virtual WriteLock Write();
    public sealed virtual WriteLock Write(int timeout);
}
public interface CSharpTest.Net.Synchronization.ILockFactory {
}
public interface CSharpTest.Net.Synchronization.ILockStrategy {
    public int WriteVersion { get; }
    public abstract virtual ReadLock Read();
    public abstract virtual ReadLock Read(int timeout);
    public abstract virtual bool TryRead(int timeout);
    public abstract virtual void ReleaseRead();
    public abstract virtual int get_WriteVersion();
    public abstract virtual WriteLock Write();
    public abstract virtual WriteLock Write(int timeout);
    public abstract virtual bool TryWrite(int timeout);
    public abstract virtual void ReleaseWrite();
}
public class CSharpTest.Net.Synchronization.LockFactory`1 : object {
    public sealed virtual ILockStrategy Create();
}
public class CSharpTest.Net.Synchronization.ReaderWriterLocking : object {
    private ReaderWriterLock _lock;
    public int WriteVersion { get; }
    public ReaderWriterLocking(ReaderWriterLock lck);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual int get_WriteVersion();
    [DebuggerNonUserCodeAttribute]
public sealed virtual bool TryRead(int timeout);
    public sealed virtual void ReleaseRead();
    [DebuggerNonUserCodeAttribute]
public sealed virtual bool TryWrite(int timeout);
    public sealed virtual void ReleaseWrite();
    public sealed virtual ReadLock Read();
    public sealed virtual ReadLock Read(int timeout);
    public sealed virtual WriteLock Write();
    public sealed virtual WriteLock Write(int timeout);
}
public class CSharpTest.Net.Synchronization.ReadLock : ValueType {
    private bool _hasLock;
    private ILockStrategy _lock;
    public bool HasReadLock { get; }
    public ReadLock(ILockStrategy lck, bool locked);
    public ReadLock(ILockStrategy lck, int timeout);
    public static ReadLock Acquire(ILockStrategy lck, int timeout);
    [ObsoleteAttribute("Do not call directly, use a using(...) statement only.", "True")]
public sealed virtual void Dispose();
    public bool get_HasReadLock();
}
public class CSharpTest.Net.Synchronization.SafeLock : ValueType {
    public static int DefaultTimeout;
    private object _sync;
    public SafeLock(object monitor);
    public SafeLock(object monitor, int timeoutMilliseconds);
    [ObsoleteAttribute("Do not call directly, use a using(...) statement only.", "True")]
public sealed virtual void Dispose();
}
public class CSharpTest.Net.Synchronization.SafeLock`1 : ValueType {
    private object _sync;
    public SafeLock`1(object monitor);
    public SafeLock`1(object monitor, int timeoutMilliseconds);
    [ObsoleteAttribute("Do not call directly, use a using(...) statement only.", "True")]
public sealed virtual void Dispose();
}
public class CSharpTest.Net.Synchronization.SimpleReadWriteLocking : object {
    private static int SpinLoops;
    private static int SpinWaitTime;
    private AutoResetEvent _event;
    private object _sync;
    private int _readersCount;
    private int _targetReaders;
    private int _writeVersion;
    private int _exclusiveThreadId;
    private int _writeRecursiveCount;
    public int WriteVersion { get; }
    private static SimpleReadWriteLocking();
    public SimpleReadWriteLocking(object syncRoot);
    public virtual void Dispose();
    public sealed virtual int get_WriteVersion();
    public sealed virtual bool TryRead(int millisecondsTimeout);
    public sealed virtual void ReleaseRead();
    public virtual bool TryWrite(int millisecondsTimeout);
    protected bool WaitForExclusive(int targetReaders, int millisecondsTimeout);
    public sealed virtual void ReleaseWrite();
    public sealed virtual ReadLock Read();
    public sealed virtual ReadLock Read(int millisecondsTimeout);
    public sealed virtual WriteLock Write();
    public sealed virtual WriteLock Write(int millisecondsTimeout);
}
public class CSharpTest.Net.Synchronization.WriteLock : ValueType {
    private bool _hasLock;
    private ILockStrategy _lock;
    public bool HasWriteLock { get; }
    public WriteLock(ILockStrategy lck, bool locked);
    public WriteLock(ILockStrategy lck, int timeout);
    public static WriteLock Acquire(ILockStrategy lck, int timeout);
    public bool get_HasWriteLock();
    [ObsoleteAttribute("Do not call directly, use a using(...) statement only.", "True")]
public sealed virtual void Dispose();
}
public class CSharpTest.Net.Synchronization.WriterOnlyLocking : object {
    private int _writeVersion;
    public int WriteVersion { get; }
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool TryRead(int timeout);
    public sealed virtual void ReleaseRead();
    public sealed virtual int get_WriteVersion();
    public sealed virtual bool TryWrite(int timeout);
    public sealed virtual void ReleaseWrite();
    public sealed virtual ReadLock Read();
    public sealed virtual ReadLock Read(int timeout);
    public sealed virtual WriteLock Write();
    public sealed virtual WriteLock Write(int timeout);
}
public interface CSharpTest.Net.Utils.IObjectKeepAlive {
    public abstract virtual void Clear();
    public abstract virtual void Tick();
    public abstract virtual void Add(object item);
}
[DebuggerDisplayAttribute("{_head.Start}-{_tail.Last}")]
public class CSharpTest.Net.Utils.ObjectKeepAlive : object {
    private static int BucketSize;
    private int _minItems;
    private int _maxItems;
    private bool _externalTicks;
    private long _maxAge;
    private long _position;
    private Entry _head;
    private Entry _tail;
    public ObjectKeepAlive(int minItems, int maxItems, TimeSpan maxAge);
    public ObjectKeepAlive(int minItems, int maxItems, TimeSpan maxAge, bool externalTicks);
    public sealed virtual void Clear();
    public sealed virtual void Tick();
    public sealed virtual void Add(object item);
    private void Tick(long dtNow);
}
public class CSharpTest.Net.Utils.WeakReference`1 : WeakReference {
    public bool IsAlive { get; }
    public T Target { get; public set; }
    public WeakReference`1(T instance);
    protected WeakReference`1(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsAlive();
    public T get_Target();
    public void set_Target(T value);
    public bool TryGetTarget(T& value);
}
