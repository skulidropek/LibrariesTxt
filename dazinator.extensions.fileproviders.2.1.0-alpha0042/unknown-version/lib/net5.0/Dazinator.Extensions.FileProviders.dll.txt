internal class Dazinator.Extensions.FileProviders.CompositeChangeToken : object {
    private IList`1<IChangeToken> _changeTokens;
    public bool HasChanged { get; }
    public bool ActiveChangeCallbacks { get; }
    public CompositeChangeToken(IList`1<IChangeToken> changeTokens);
    public sealed virtual IDisposable RegisterChangeCallback(Action`1<object> callback, object state);
    public sealed virtual bool get_HasChanged();
    public sealed virtual bool get_ActiveChangeCallbacks();
}
public class Dazinator.Extensions.FileProviders.CompositeDirectoryContents : object {
    private IEnumerable`1<IDirectoryContents> _directoryContents;
    private bool _initialised;
    private bool _exists;
    private HashSet`1<string> _names;
    private List`1<IFileInfo> _files;
    public bool Exists { get; }
    public CompositeDirectoryContents(IEnumerable`1<IDirectoryContents> directoryContents);
    public sealed virtual bool get_Exists();
    public sealed virtual IEnumerator`1<IFileInfo> GetEnumerator();
    private void EnsureInitialised();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Dazinator.Extensions.FileProviders.CompositeDisposable : object {
    private IList`1<IDisposable> _disposables;
    public CompositeDisposable(IList`1<IDisposable> disposables);
    public sealed virtual void Dispose();
}
public class Dazinator.Extensions.FileProviders.DirectoryFileInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <Exists>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private long <Length>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <PhysicalPath>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DateTimeOffset <LastModified>k__BackingField;
    public bool Exists { get; }
    public long Length { get; }
    public string PhysicalPath { get; }
    public string Name { get; }
    public DateTimeOffset LastModified { get; }
    public bool IsDirectory { get; }
    public DirectoryFileInfo(string name);
    public sealed virtual Stream CreateReadStream();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Exists();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Length();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PhysicalPath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_LastModified();
    public sealed virtual bool get_IsDirectory();
}
public class Dazinator.Extensions.FileProviders.EmbeddedFileInfo : object {
    private Assembly _assembly;
    private string _resourcePath;
    private Lazy`1<long> _lazyLength;
    private Lazy`1<DateTimeOffset> _lazyLastModified;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <Exists>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <PhysicalPath>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsDirectory>k__BackingField;
    public bool Exists { get; }
    public long Length { get; }
    public string PhysicalPath { get; }
    public string Name { get; }
    public DateTimeOffset LastModified { get; }
    public bool IsDirectory { get; }
    public EmbeddedFileInfo(Assembly assembly, string resourcePath, string fileName);
    public sealed virtual Stream CreateReadStream();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Exists();
    public sealed virtual long get_Length();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PhysicalPath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDirectory();
}
internal class Dazinator.Extensions.FileProviders.EmptyDisposable : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static EmptyDisposable <Instance>k__BackingField;
    public static EmptyDisposable Instance { get; }
    private static EmptyDisposable();
    [CompilerGeneratedAttribute]
public static EmptyDisposable get_Instance();
    public sealed virtual void Dispose();
}
public class Dazinator.Extensions.FileProviders.EnumerableDirectoryContents : object {
    private bool _exists;
    private IFileInfo[] _files;
    public bool Exists { get; }
    public EnumerableDirectoryContents(bool exists, IFileInfo[] files);
    public sealed virtual bool get_Exists();
    [IteratorStateMachineAttribute("Dazinator.Extensions.FileProviders.EnumerableDirectoryContents/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<IFileInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class Dazinator.Extensions.FileProviders.GlobPatternFileProviderExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<string, IFileInfo>> Search(IFileProvider fileProvider, string globPattern);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<string, IFileInfo>> Search(IFileProvider fileProvider, String[] includePatterns);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<string, IFileInfo>> Search(IFileProvider fileProvider, String[] includePatterns, String[] excludePatterns);
}
public class Dazinator.Extensions.FileProviders.GlobPatternFilter.GlobMatchingEnumerableDirectoryContents : object {
    private GlobMatchingEnumerableFileInfos _globAllowedFiles;
    public bool Exists { get; }
    public GlobMatchingEnumerableDirectoryContents(GlobMatchingEnumerableFileInfos globAllowedFiles);
    public sealed virtual bool get_Exists();
    [IteratorStateMachineAttribute("Dazinator.Extensions.FileProviders.GlobPatternFilter.GlobMatchingEnumerableDirectoryContents/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<IFileInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Dazinator.Extensions.FileProviders.GlobPatternFilter.GlobMatchingEnumerableFileInfos : object {
    private PathString _rootDir;
    private bool _recurseDirectories;
    private IFileProvider _fileProvider;
    private GlobPatternIncludeExcludeEvaluator _evaluator;
    public GlobMatchingEnumerableFileInfos(PathString rootDir, bool recurseDirectories, IFileProvider fileProvider, String[] includePatterns);
    public GlobMatchingEnumerableFileInfos(PathString rootDir, bool recurseDirectories, IFileProvider fileProvider, String[] includePatterns, String[] excludePatterns);
    public GlobMatchingEnumerableFileInfos(PathString rootDir, bool recurseDirectories, IFileProvider fileProvider, GlobPatternIncludeExcludeEvaluator evaluator);
    [IteratorStateMachineAttribute("Dazinator.Extensions.FileProviders.GlobPatternFilter.GlobMatchingEnumerableFileInfos/<GetEnumerator>d__7")]
public sealed virtual IEnumerator`1<Tuple`2<string, IFileInfo>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Dazinator.Extensions.FileProviders.GlobPatternFilter.GlobPatternFilterFileProvider : object {
    private IFileProvider _inner;
    private GlobPatternIncludeExcludeEvaluator _evaluator;
    public GlobPatternFilterFileProvider(IFileProvider inner, String[] includes, String[] excludes);
    public sealed virtual IDirectoryContents GetDirectoryContents(string subpath);
    public sealed virtual IFileInfo GetFileInfo(string subpath);
    public sealed virtual IChangeToken Watch(string filter);
}
public class Dazinator.Extensions.FileProviders.GlobPatternFilter.GlobPatternIncludeExcludeEvaluator : object {
    private String[] _includePatterns;
    private String[] _excludePatterns;
    private Lazy`1<List`1<Glob>> _includeGlobs;
    private Lazy`1<List`1<Glob>> _excludeGlobs;
    public GlobPatternIncludeExcludeEvaluator(String[] includePatterns, String[] excludePatterns);
    public bool IsAllowed(string subject);
    [CompilerGeneratedAttribute]
private List`1<Glob> <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private List`1<Glob> <.ctor>b__4_1();
}
[ExtensionAttribute]
public static class Dazinator.Extensions.FileProviders.IFileProviderExtensions : object {
    [ExtensionAttribute]
public static IFileInfo EnsureFile(IFileProvider fileProvider, string path);
    [ExtensionAttribute]
public static string ReadAllContent(IFileInfo fileInfo);
}
public abstract class Dazinator.Extensions.FileProviders.InMemory.Directory.BaseDirectoryItem : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<DirectoryItemUpdatedEventArgs> Updated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<DirectoryItemDeletedEventArgs> Deleted;
    private bool _listenToParent;
    private IFolderDirectoryItem _parentFolder;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IFileInfo <FileInfo>k__BackingField;
    public IFolderDirectoryItem ParentFolder { get; public set; }
    public string Name { get; }
    public bool IsFolder { get; }
    public string Path { get; }
    public IFileInfo FileInfo { get; protected set; }
    protected BaseDirectoryItem(IFileInfo fileInfo, IFolderDirectoryItem parentFolder, bool listenToParent);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Updated(EventHandler`1<DirectoryItemUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Updated(EventHandler`1<DirectoryItemUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Deleted(EventHandler`1<DirectoryItemDeletedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Deleted(EventHandler`1<DirectoryItemDeletedEventArgs> value);
    private void EnsureParentEvents(IFolderDirectoryItem parent, bool listen);
    protected abstract virtual void OnParentUpdated(object sender, DirectoryItemUpdatedEventArgs e);
    public sealed virtual void OnRemoved();
    public sealed virtual IFolderDirectoryItem get_ParentFolder();
    public sealed virtual void set_ParentFolder(IFolderDirectoryItem value);
    public virtual string get_Name();
    public abstract virtual bool get_IsFolder();
    public virtual string get_Path();
    [CompilerGeneratedAttribute]
public virtual IFileInfo get_FileInfo();
    [CompilerGeneratedAttribute]
protected virtual void set_FileInfo(IFileInfo value);
    public virtual void Delete();
    public abstract virtual void Accept(BaseDirectoryVisitor Visitor);
    protected void OnRaiseItemUpdated(IDirectoryItem oldItem);
    protected virtual void OnRaiseItemDeleted();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public abstract virtual void Update(IFileInfo newFileInfo);
    public abstract virtual void ApplyUpdate(IFileInfo newFileInfo);
    public virtual void Rename(string newName);
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.BaseDirectoryVisitor : object {
    public virtual void Visit(FileDirectoryItem item);
    public virtual void Visit(FolderDirectoryItem item);
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.DirectoryItemAddedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IDirectoryItem <NewItem>k__BackingField;
    public IDirectoryItem NewItem { get; private set; }
    public DirectoryItemAddedEventArgs(IDirectoryItem newItem);
    [CompilerGeneratedAttribute]
public IDirectoryItem get_NewItem();
    [CompilerGeneratedAttribute]
private void set_NewItem(IDirectoryItem value);
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.DirectoryItemDeletedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IDirectoryItem <DeletedItem>k__BackingField;
    public IDirectoryItem DeletedItem { get; private set; }
    public DirectoryItemDeletedEventArgs(IDirectoryItem deletedItem);
    [CompilerGeneratedAttribute]
public IDirectoryItem get_DeletedItem();
    [CompilerGeneratedAttribute]
private void set_DeletedItem(IDirectoryItem value);
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.DirectoryItemUpdatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IDirectoryItem <OldItem>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IDirectoryItem <NewItem>k__BackingField;
    public IDirectoryItem OldItem { get; private set; }
    public IDirectoryItem NewItem { get; private set; }
    public DirectoryItemUpdatedEventArgs(IDirectoryItem oldItem, IDirectoryItem newItem);
    [CompilerGeneratedAttribute]
public IDirectoryItem get_OldItem();
    [CompilerGeneratedAttribute]
private void set_OldItem(IDirectoryItem value);
    [CompilerGeneratedAttribute]
public IDirectoryItem get_NewItem();
    [CompilerGeneratedAttribute]
private void set_NewItem(IDirectoryItem value);
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.DirectoryWatcher : BaseDirectoryVisitor {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemUpdatedEventArgs>> ItemUpdated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemAddedEventArgs>> ItemAdded;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemDeletedEventArgs>> ItemDeleted;
    private ConcurrentDictionary`2<string, IDirectoryItem> _watchingFolders;
    private List`1<Glob> _Filters;
    private VisitMode _visitMode;
    private bool _UnregisterWasSuccessful;
    private IDirectory _directory;
    public DirectoryWatcher(IDirectory directory);
    [CompilerGeneratedAttribute]
public void add_ItemUpdated(EventHandler`1<DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemUpdatedEventArgs>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemUpdated(EventHandler`1<DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemUpdatedEventArgs>> value);
    [CompilerGeneratedAttribute]
public void add_ItemAdded(EventHandler`1<DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemAddedEventArgs>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemAdded(EventHandler`1<DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemAddedEventArgs>> value);
    [CompilerGeneratedAttribute]
public void add_ItemDeleted(EventHandler`1<DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemDeletedEventArgs>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemDeleted(EventHandler`1<DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemDeletedEventArgs>> value);
    public virtual void Visit(FileDirectoryItem item);
    public virtual void Visit(FolderDirectoryItem item);
    private void Register(IFolderDirectoryItem folder);
    private void Register(IFileDirectoryItem file);
    private bool Unregister(IFileDirectoryItem file);
    private bool Unregister(IFolderDirectoryItem folder);
    private bool UnregisterAll();
    private void Folder_ItemAdded(object sender, DirectoryItemAddedEventArgs e);
    private void Item_Deleted(object sender, DirectoryItemDeletedEventArgs e);
    private void Item_Updated(object sender, DirectoryItemUpdatedEventArgs e);
    protected virtual void OnRaiseItemAdded(DirectoryItemAddedEventArgs args);
    [IteratorStateMachineAttribute("Dazinator.Extensions.FileProviders.InMemory.Directory.DirectoryWatcher/<GetMatchingFilters>d__26")]
private IEnumerable`1<string> GetMatchingFilters(string path);
    protected virtual void OnRaiseItemUpdated(DirectoryItemUpdatedEventArgs args);
    protected virtual void OnRaiseItemDeleted(DirectoryItemDeletedEventArgs args);
    public void AddFilter(string pattern);
    public sealed virtual void Dispose();
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.DirectoryWatcherFilterMatchedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TDirectoryItemEventArgs <DirectoryItemEventArgs>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private String[] <MatchedFilters>k__BackingField;
    public TDirectoryItemEventArgs DirectoryItemEventArgs { get; public set; }
    public String[] MatchedFilters { get; public set; }
    public DirectoryWatcherFilterMatchedEventArgs`1(TDirectoryItemEventArgs args, String[] matchedFilters);
    [CompilerGeneratedAttribute]
public TDirectoryItemEventArgs get_DirectoryItemEventArgs();
    [CompilerGeneratedAttribute]
public void set_DirectoryItemEventArgs(TDirectoryItemEventArgs value);
    [CompilerGeneratedAttribute]
public String[] get_MatchedFilters();
    [CompilerGeneratedAttribute]
public void set_MatchedFilters(String[] value);
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.FileDirectoryItem : BaseDirectoryItem {
    public bool IsFolder { get; }
    public FileDirectoryItem(IFileInfo fileInfo, IFolderDirectoryItem parentFolder);
    protected FileDirectoryItem(IFileInfo fileInfo, IFolderDirectoryItem parentFolder, bool listenToParent);
    protected virtual void OnParentUpdated(object sender, DirectoryItemUpdatedEventArgs e);
    public virtual bool get_IsFolder();
    public virtual void Update(IFileInfo newFileInfo);
    public virtual void ApplyUpdate(IFileInfo newFileInfo);
    public virtual void Accept(BaseDirectoryVisitor Visitor);
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.FolderDirectoryItem : BaseDirectoryItem {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<DirectoryItemAddedEventArgs> ItemAdded;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ConcurrentDictionary`2<string, IDirectoryItem> <Items>k__BackingField;
    public ConcurrentDictionary`2<string, IDirectoryItem> Items { get; public set; }
    public bool IsFolder { get; }
    public FolderDirectoryItem(string name, IFolderDirectoryItem parentFolder);
    public FolderDirectoryItem(IFileInfo directoryFileInfo, IFolderDirectoryItem parentFolder);
    protected FolderDirectoryItem(IFileInfo fileInfo, IFolderDirectoryItem parentFolder, bool listenToParent);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ItemAdded(EventHandler`1<DirectoryItemAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ItemAdded(EventHandler`1<DirectoryItemAddedEventArgs> value);
    protected virtual void OnParentUpdated(object sender, DirectoryItemUpdatedEventArgs e);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, IDirectoryItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(ConcurrentDictionary`2<string, IDirectoryItem> value);
    public virtual bool get_IsFolder();
    public sealed virtual IFolderDirectoryItem GetOrAddFolder(string name);
    public sealed virtual IFileDirectoryItem AddFile(IFileInfo file);
    public sealed virtual IFileDirectoryItem AddOrUpdateFile(IFileInfo file);
    public sealed virtual IFileDirectoryItem UpdateFile(IFileInfo file);
    public sealed virtual void ReplaceItem(IDirectoryItem existingItem, IFileInfo newItem);
    public virtual void Update(IFileInfo newFileInfo);
    public virtual void ApplyUpdate(IFileInfo newFileInfo);
    public virtual void Delete();
    public sealed virtual void Delete(bool recursive);
    private IFileDirectoryItem GetFileItem(string name);
    public sealed virtual IDirectoryItem NavigateToNext(string name);
    private IDirectoryItem GetOrAddItem(string name, Func`2<string, IDirectoryItem> createItemCallback);
    private IDirectoryItem AddOrUpdateItem(string name, IDirectoryItem newItem);
    private bool AddItem(string name, IDirectoryItem newItem);
    public sealed virtual bool RemoveItem(string name);
    protected virtual void OnRaiseItemAdded(IDirectoryItem newItem);
    public virtual void Accept(BaseDirectoryVisitor Visitor);
    public sealed virtual IEnumerator`1<IDirectoryItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private IDirectoryItem <GetOrAddFolder>b__13_0(string folderName);
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.GlobPatternEnumerableDirectoryItems : object {
    private IFolderDirectoryItem _rootFolder;
    private string _pattern;
    public GlobPatternEnumerableDirectoryItems(IFolderDirectoryItem rootFolder, string pattern);
    [IteratorStateMachineAttribute("Dazinator.Extensions.FileProviders.InMemory.Directory.GlobPatternEnumerableDirectoryItems/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<IDirectoryItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface Dazinator.Extensions.FileProviders.InMemory.Directory.IDirectory {
    public IFolderDirectoryItem Root { get; }
    public abstract virtual IFolderDirectoryItem get_Root();
    public abstract virtual IDirectoryItem GetItem(string path);
    public abstract virtual IFileDirectoryItem GetFile(string path);
    public abstract virtual IFileDirectoryItem AddFile(string directory, IFileInfo file);
    public abstract virtual IFileDirectoryItem AddOrUpdateFile(string directory, IFileInfo file);
    public abstract virtual IFolderDirectoryItem GetFolder(string path);
    public abstract virtual IFolderDirectoryItem GetOrAddFolder(string directory);
    public abstract virtual IEnumerable`1<IDirectoryItem> Search(string globPattern);
}
public interface Dazinator.Extensions.FileProviders.InMemory.Directory.IDirectoryItem {
    public IFolderDirectoryItem ParentFolder { get; public set; }
    public string Name { get; }
    public bool IsFolder { get; }
    public IFileInfo FileInfo { get; }
    public string Path { get; }
    public abstract virtual IFolderDirectoryItem get_ParentFolder();
    public abstract virtual void set_ParentFolder(IFolderDirectoryItem value);
    public abstract virtual string get_Name();
    public abstract virtual bool get_IsFolder();
    public abstract virtual IFileInfo get_FileInfo();
    public abstract virtual string get_Path();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(EventHandler`1<DirectoryItemUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(EventHandler`1<DirectoryItemUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Deleted(EventHandler`1<DirectoryItemDeletedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Deleted(EventHandler`1<DirectoryItemDeletedEventArgs> value);
    public abstract virtual void OnRemoved();
    public abstract virtual void Delete();
    public abstract virtual void ApplyUpdate(IFileInfo newFileInfo);
}
public interface Dazinator.Extensions.FileProviders.InMemory.Directory.IFileDirectoryItem {
    public abstract virtual void Update(IFileInfo newFileInfo);
}
public interface Dazinator.Extensions.FileProviders.InMemory.Directory.IFolderDirectoryItem {
    public abstract virtual IDirectoryItem NavigateToNext(string name);
    public abstract virtual IFolderDirectoryItem GetOrAddFolder(string name);
    public abstract virtual void Rename(string newName);
    public abstract virtual void ReplaceItem(IDirectoryItem existingItem, IFileInfo newItem);
    public abstract virtual IFileDirectoryItem AddFile(IFileInfo file);
    public abstract virtual IFileDirectoryItem UpdateFile(IFileInfo file);
    public abstract virtual void Update(IFileInfo file);
    public abstract virtual void Delete(bool recursive);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemAdded(EventHandler`1<DirectoryItemAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemAdded(EventHandler`1<DirectoryItemAddedEventArgs> value);
    public abstract virtual bool RemoveItem(string name);
    public abstract virtual IFileDirectoryItem AddOrUpdateFile(IFileInfo file);
}
public class Dazinator.Extensions.FileProviders.InMemory.Directory.InMemoryDirectory : object {
    private IFolderDirectoryItem _rootFolder;
    public IFolderDirectoryItem Root { get; }
    public InMemoryDirectory(string rootDirName);
    public InMemoryDirectory(IFolderDirectoryItem rootFolder);
    public sealed virtual IFolderDirectoryItem GetFolder(string path);
    public sealed virtual IFolderDirectoryItem GetOrAddFolder(string directory);
    public sealed virtual IFolderDirectoryItem get_Root();
    public sealed virtual IFileDirectoryItem GetFile(string path);
    public sealed virtual IDirectoryItem GetItem(string path);
    public sealed virtual IEnumerable`1<IDirectoryItem> Search(string globPattern);
    public sealed virtual IFileDirectoryItem AddFile(string folderPath, IFileInfo file);
    public void UpdateFile(string folderPath, IFileInfo fileInfo);
    public sealed virtual void Accept(BaseDirectoryVisitor Visitor);
    public sealed virtual IFileDirectoryItem AddOrUpdateFile(string directory, IFileInfo file);
}
public interface Dazinator.Extensions.FileProviders.InMemory.Directory.IVisitable`1 {
    public abstract virtual void Accept(T Visitor);
}
public enum Dazinator.Extensions.FileProviders.InMemory.Directory.VisitMode : Enum {
    public int value__;
    public static VisitMode Register;
    public static VisitMode Unregister;
}
public class Dazinator.Extensions.FileProviders.InMemory.EnumerableFolderDirectoryContents : object {
    private IFolderDirectoryItem _folder;
    public bool Exists { get; }
    public EnumerableFolderDirectoryContents(IFolderDirectoryItem folder);
    public sealed virtual bool get_Exists();
    [IteratorStateMachineAttribute("Dazinator.Extensions.FileProviders.InMemory.EnumerableFolderDirectoryContents/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<IFileInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Dazinator.Extensions.FileProviders.InMemory.InMemoryFileProvider : object {
    private ConcurrentDictionary`2<string, ChangeTokenInfo> _matchInfoCache;
    private Lazy`1<DirectoryWatcher> _dirWatcher;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IDirectory <Directory>k__BackingField;
    public DirectoryWatcher DirectoryWatcher { get; }
    public IDirectory Directory { get; public set; }
    public InMemoryFileProvider(IDirectory directory);
    private void Watcher_ItemUpdated(object sender, DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemUpdatedEventArgs> e);
    private void Watcher_ItemDeleted(object sender, DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemDeletedEventArgs> e);
    private void Watcher_ItemAdded(object sender, DirectoryWatcherFilterMatchedEventArgs`1<DirectoryItemAddedEventArgs> e);
    private void SignalTokens(String[] keys);
    public DirectoryWatcher get_DirectoryWatcher();
    [CompilerGeneratedAttribute]
public IDirectory get_Directory();
    [CompilerGeneratedAttribute]
public void set_Directory(IDirectory value);
    public sealed virtual IFileInfo GetFileInfo(string subpath);
    public sealed virtual IDirectoryContents GetDirectoryContents(string subpath);
    public sealed virtual IChangeToken Watch(string filter);
    private IChangeToken GetOrAddChangeToken(string key, Action`1<ChangeTokenInfo> onNewTokenAdded);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private DirectoryWatcher <.ctor>b__3_0();
}
public class Dazinator.Extensions.FileProviders.InMemoryChangeToken : object {
    private ConcurrentBag`1<Tuple`3<Action`1<object>, object, IDisposable>> _callbacks;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <ActiveChangeCallbacks>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <HasChanged>k__BackingField;
    public bool ActiveChangeCallbacks { get; public set; }
    public bool HasChanged { get; public set; }
    public ConcurrentBag`1<Tuple`3<Action`1<object>, object, IDisposable>> Callbacks { get; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ActiveChangeCallbacks();
    [CompilerGeneratedAttribute]
public void set_ActiveChangeCallbacks(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasChanged();
    [CompilerGeneratedAttribute]
public void set_HasChanged(bool value);
    public ConcurrentBag`1<Tuple`3<Action`1<object>, object, IDisposable>> get_Callbacks();
    public sealed virtual IDisposable RegisterChangeCallback(Action`1<object> callback, object state);
    public void RaiseCallback(object newItem);
}
public class Dazinator.Extensions.FileProviders.Mapping.FileMap : object {
    private DirectoryFileInfo _cachedDirectoryInfo;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Dictionary`2<PathString, FileMap> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Dictionary`2<PathString, SourceFileInfo> <FileNameMappings>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private List`1<PatternInfo> <PatternMappings>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PathString <Path>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FileMap <Parent>k__BackingField;
    private Dictionary`2<PathString, FileMap> Children { get; private set; }
    private Dictionary`2<PathString, SourceFileInfo> FileNameMappings { get; private set; }
    private List`1<PatternInfo> PatternMappings { get; private set; }
    public PathString Path { get; private set; }
    public FileMap Parent { get; public set; }
    public FileMap(PathString path);
    private IDirectoryContents GetExplicitDirectoryContents();
    [CompilerGeneratedAttribute]
private Dictionary`2<PathString, FileMap> get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(Dictionary`2<PathString, FileMap> value);
    [CompilerGeneratedAttribute]
private Dictionary`2<PathString, SourceFileInfo> get_FileNameMappings();
    [CompilerGeneratedAttribute]
private void set_FileNameMappings(Dictionary`2<PathString, SourceFileInfo> value);
    [CompilerGeneratedAttribute]
private List`1<PatternInfo> get_PatternMappings();
    [CompilerGeneratedAttribute]
private void set_PatternMappings(List`1<PatternInfo> value);
    [CompilerGeneratedAttribute]
public PathString get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(PathString value);
    [CompilerGeneratedAttribute]
public FileMap get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(FileMap value);
    public FileMap NavigateTo(PathString requestPath, bool createIfNotExists);
    public FileMap MapPath(PathString requestPath, Action`1<FileMap> configureMappings);
    public bool TryGetChild(PathString path, FileMap& child);
    public FileMap GetChild(PathString path);
    public FileMap GetOrAddChild(PathString path);
    public FileMap AddChild(PathString pathString);
    public FileMap AddFileNameMapping(PathString fileName, IFileProvider sourceFileProvider, string sourcePath);
    public FileMap AddPatternMapping(string pattern, IFileProvider sourceFileProvider, Nullable`1<int> segmentDepthOfPathToPassToSourceFileProvider);
    private bool TryGetFileFromFileMappings(PathString fileName, IFileInfo& sourceFile);
    private static IFileInfo GetMappedFileFromSourceFile(PathString fileName, SourceFileInfo sourceFileMapping);
    private bool TryGetFileFromPatternMappings(PathString fileName, String[] requestPathSegments, IFileInfo& sourceFile);
    public bool TryGetMappedFile(PathString remainingPath, String[] requestPathSegments, IFileInfo& sourceFile);
    public bool GetMappedDirectoryContents(PathString remainingPath, String[] requestPathSegments, IDirectoryContents& directoryContents);
}
public class Dazinator.Extensions.FileProviders.Mapping.MappingFileProvider : object {
    private FileMap _map;
    public MappingFileProvider(FileMap map);
    public sealed virtual IFileInfo GetFileInfo(string subpath);
    public sealed virtual IDirectoryContents GetDirectoryContents(string subpath);
    public bool TryNavigateTo(PathString requestPath, FileMap& map, PathString& remaining, String[]& requestPathSegments);
    public sealed virtual IChangeToken Watch(string filter);
}
[ExtensionAttribute]
public static class Dazinator.Extensions.FileProviders.Mapping.StaticWebAssets.FileMapExtensions : object {
    [ExtensionAttribute]
public static FileMap AddFromStaticWebAssetsManifest(FileMap map, StaticWebAssetManifest manifest, Func`2<string, IFileProvider> contentRootFileProviderFactory, Func`2<FileMap, bool> isPathMappingAllowed);
    private static void PopulateFromManifest(FileMap map, StaticWebAssetManifest manifest, Func`2<string, IFileProvider> contentRootFileProviderFactory, Func`2<FileMap, bool> isPathMappingAllowed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Dazinator.Extensions.FileProviders.Mapping.StaticWebAssets.StaticWebAssetManifest : object {
    internal static StringComparer PathComparer;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private String[] <ContentRoots>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StaticWebAssetNode <Root>k__BackingField;
    public String[] ContentRoots { get; public set; }
    public StaticWebAssetNode Root { get; public set; }
    private static StaticWebAssetManifest();
    [CompilerGeneratedAttribute]
public String[] get_ContentRoots();
    [CompilerGeneratedAttribute]
public void set_ContentRoots(String[] value);
    [CompilerGeneratedAttribute]
public StaticWebAssetNode get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(StaticWebAssetNode value);
    public static StaticWebAssetManifest Parse(Stream manifest);
}
public class Dazinator.Extensions.FileProviders.MemoryStreamFileInfo : object {
    private MemoryStream _stream;
    private Lazy`1<long> _lazyLength;
    private object _lock;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <Exists>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <PhysicalPath>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsDirectory>k__BackingField;
    public bool Exists { get; }
    public long Length { get; }
    public string PhysicalPath { get; }
    public string Name { get; }
    public DateTimeOffset LastModified { get; }
    public bool IsDirectory { get; }
    public MemoryStreamFileInfo(MemoryStream contents, string name);
    public sealed virtual Stream CreateReadStream();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Exists();
    public sealed virtual long get_Length();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PhysicalPath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDirectory();
    [CompilerGeneratedAttribute]
private long <.ctor>b__3_0();
}
public static class Dazinator.Extensions.FileProviders.PathUtils : object {
    private static Char[] _directorySeperator;
    private static PathUtils();
    public static String[] SplitPathIntoSegments(string path);
}
public class Dazinator.Extensions.FileProviders.PrependBasePath.PrependBasePathFileProvider : object {
    private PathString _basePath;
    private IFileProvider _underlyingFileProvider;
    private IFileInfo _baseDirectoryFileInfo;
    private static Char[] _splitChar;
    public PrependBasePathFileProvider(string basePath, IFileProvider underlyingFileProvider);
    private static PrependBasePathFileProvider();
    protected virtual bool TryMapSubPath(string originalSubPath, PathString& newSubPath);
    public sealed virtual IDirectoryContents GetDirectoryContents(string subpath);
    public sealed virtual IFileInfo GetFileInfo(string subpath);
    public sealed virtual IChangeToken Watch(string filter);
}
public class Dazinator.Extensions.FileProviders.StringFileInfo : object {
    private string _contents;
    private Lazy`1<long> _lazyLength;
    private static Encoding DefaultEncoding;
    private Encoding _Encoding;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DateTimeOffset <LastModified>k__BackingField;
    public bool Exists { get; }
    public long Length { get; }
    public string PhysicalPath { get; }
    public string Name { get; }
    public DateTimeOffset LastModified { get; }
    public bool IsDirectory { get; }
    public StringFileInfo(string contents, string name, Encoding encoding);
    private static StringFileInfo();
    public sealed virtual Stream CreateReadStream();
    public sealed virtual bool get_Exists();
    public sealed virtual long get_Length();
    public sealed virtual string get_PhysicalPath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_LastModified();
    public sealed virtual bool get_IsDirectory();
    [CompilerGeneratedAttribute]
private long <.ctor>b__4_0();
}
public static class Dazinator.Extensions.FileProviders.Utils.FileSystemStringComparison : object {
    private static StringComparison _fsComparison;
    public static StringComparison SingletonInstance { get; }
    private static FileSystemStringComparison();
    public static StringComparison get_SingletonInstance();
}
public class Dazinator.Extensions.FileProviders.WrappedFileInfo : object {
    private IFileInfo _originalFileInfo;
    private Func`2<Stream, Stream> _wrapStream;
    private Nullable`1<bool> _Exists;
    private Nullable`1<long> _Length;
    private string _PhysicalPath;
    private string _Name;
    private Nullable`1<DateTimeOffset> _LastModified;
    private Nullable`1<bool> _IsDirectory;
    public bool Exists { get; public set; }
    public long Length { get; public set; }
    public string PhysicalPath { get; public set; }
    public string Name { get; public set; }
    public DateTimeOffset LastModified { get; public set; }
    public bool IsDirectory { get; public set; }
    public WrappedFileInfo(IFileInfo originalFileInfo, Func`2<Stream, Stream> wrapStream);
    public sealed virtual Stream CreateReadStream();
    public sealed virtual bool get_Exists();
    public void set_Exists(bool value);
    public sealed virtual long get_Length();
    public void set_Length(long value);
    public sealed virtual string get_PhysicalPath();
    public void set_PhysicalPath(string value);
    public sealed virtual string get_Name();
    public void set_Name(string value);
    public sealed virtual DateTimeOffset get_LastModified();
    public void set_LastModified(DateTimeOffset value);
    public sealed virtual bool get_IsDirectory();
    public void set_IsDirectory(bool value);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.PathStringExtensions : object {
    [ExtensionAttribute]
public static void SplitToDirectoryPathAndFileName(PathString path, PathSeperationStrategy strategy, PathString& directory, PathString& fileName);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
