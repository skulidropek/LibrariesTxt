[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Medallion.Threading.DeadlockException : InvalidOperationException {
    public DeadlockException(string message);
    public DeadlockException(string message, Exception innerException);
    private DeadlockException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Medallion.Threading.DistributedLockProviderExtensions : object {
    [ExtensionAttribute]
public static IDistributedSynchronizationHandle TryAcquireLock(IDistributedLockProvider provider, string name, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IDistributedSynchronizationHandle AcquireLock(IDistributedLockProvider provider, string name, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedSynchronizationHandle> TryAcquireLockAsync(IDistributedLockProvider provider, string name, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedSynchronizationHandle> AcquireLockAsync(IDistributedLockProvider provider, string name, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Medallion.Threading.DistributedReaderWriterLockProviderExtensions : object {
    [ExtensionAttribute]
public static IDistributedSynchronizationHandle TryAcquireReadLock(IDistributedReaderWriterLockProvider provider, string name, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IDistributedSynchronizationHandle AcquireReadLock(IDistributedReaderWriterLockProvider provider, string name, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedSynchronizationHandle> TryAcquireReadLockAsync(IDistributedReaderWriterLockProvider provider, string name, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedSynchronizationHandle> AcquireReadLockAsync(IDistributedReaderWriterLockProvider provider, string name, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IDistributedSynchronizationHandle TryAcquireWriteLock(IDistributedReaderWriterLockProvider provider, string name, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IDistributedSynchronizationHandle AcquireWriteLock(IDistributedReaderWriterLockProvider provider, string name, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedSynchronizationHandle> TryAcquireWriteLockAsync(IDistributedReaderWriterLockProvider provider, string name, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedSynchronizationHandle> AcquireWriteLockAsync(IDistributedReaderWriterLockProvider provider, string name, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Medallion.Threading.DistributedSemaphoreProviderExtensions : object {
    [ExtensionAttribute]
public static IDistributedSynchronizationHandle TryAcquireSemaphore(IDistributedSemaphoreProvider provider, string name, int maxCount, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IDistributedSynchronizationHandle AcquireSemaphore(IDistributedSemaphoreProvider provider, string name, int maxCount, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedSynchronizationHandle> TryAcquireSemaphoreAsync(IDistributedSemaphoreProvider provider, string name, int maxCount, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedSynchronizationHandle> AcquireSemaphoreAsync(IDistributedSemaphoreProvider provider, string name, int maxCount, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Medallion.Threading.DistributedUpgradeableReaderWriterLockProviderExtensions : object {
    [ExtensionAttribute]
public static IDistributedLockUpgradeableHandle TryAcquireUpgradeableReadLock(IDistributedUpgradeableReaderWriterLockProvider provider, string name, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IDistributedLockUpgradeableHandle AcquireUpgradeableReadLock(IDistributedUpgradeableReaderWriterLockProvider provider, string name, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedLockUpgradeableHandle> TryAcquireUpgradeableReadLockAsync(IDistributedUpgradeableReaderWriterLockProvider provider, string name, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<IDistributedLockUpgradeableHandle> AcquireUpgradeableReadLockAsync(IDistributedUpgradeableReaderWriterLockProvider provider, string name, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Medallion.Threading.IDistributedLock {
    public string Name { get; }
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual IDistributedSynchronizationHandle TryAcquire(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual IDistributedSynchronizationHandle Acquire(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedSynchronizationHandle> TryAcquireAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedSynchronizationHandle> AcquireAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Medallion.Threading.IDistributedLockProvider {
    public abstract virtual IDistributedLock CreateLock(string name);
}
public interface Medallion.Threading.IDistributedLockUpgradeableHandle {
    public abstract virtual bool TryUpgradeToWriteLock(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual void UpgradeToWriteLock(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<bool> TryUpgradeToWriteLockAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask UpgradeToWriteLockAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Medallion.Threading.IDistributedReaderWriterLock {
    public string Name { get; }
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual IDistributedSynchronizationHandle TryAcquireReadLock(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual IDistributedSynchronizationHandle AcquireReadLock(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedSynchronizationHandle> TryAcquireReadLockAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedSynchronizationHandle> AcquireReadLockAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual IDistributedSynchronizationHandle TryAcquireWriteLock(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual IDistributedSynchronizationHandle AcquireWriteLock(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedSynchronizationHandle> TryAcquireWriteLockAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedSynchronizationHandle> AcquireWriteLockAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Medallion.Threading.IDistributedReaderWriterLockProvider {
    public abstract virtual IDistributedReaderWriterLock CreateReaderWriterLock(string name);
}
[NullableContextAttribute("1")]
public interface Medallion.Threading.IDistributedSemaphore {
    public string Name { get; }
    public int MaxCount { get; }
    public abstract virtual string get_Name();
    public abstract virtual int get_MaxCount();
    [NullableContextAttribute("2")]
public abstract virtual IDistributedSynchronizationHandle TryAcquire(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual IDistributedSynchronizationHandle Acquire(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedSynchronizationHandle> TryAcquireAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedSynchronizationHandle> AcquireAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Medallion.Threading.IDistributedSemaphoreProvider {
    public abstract virtual IDistributedSemaphore CreateSemaphore(string name, int maxCount);
}
public interface Medallion.Threading.IDistributedSynchronizationHandle {
    public CancellationToken HandleLostToken { get; }
    public abstract virtual CancellationToken get_HandleLostToken();
}
public interface Medallion.Threading.IDistributedUpgradeableReaderWriterLock {
    [NullableContextAttribute("2")]
public abstract virtual IDistributedLockUpgradeableHandle TryAcquireUpgradeableReadLock(TimeSpan timeout, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual IDistributedLockUpgradeableHandle AcquireUpgradeableReadLock(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedLockUpgradeableHandle> TryAcquireUpgradeableReadLockAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IDistributedLockUpgradeableHandle> AcquireUpgradeableReadLockAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
}
public interface Medallion.Threading.IDistributedUpgradeableReaderWriterLockProvider {
    [NullableContextAttribute("1")]
public abstract virtual IDistributedUpgradeableReaderWriterLock CreateUpgradeableReaderWriterLock(string name);
}
[IsReadOnlyAttribute]
internal class Medallion.Threading.Internal.AsyncLock : ValueType {
    [NullableAttribute("1")]
private SemaphoreSlim _semaphore;
    [NullableContextAttribute("1")]
private AsyncLock(SemaphoreSlim semaphore);
    public static AsyncLock Create();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.AsyncLock/<AcquireAsync>d__3")]
public ValueTask`1<IDisposable> AcquireAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.AsyncLock/<TryAcquireAsync>d__4")]
public ValueTask`1<IDisposable> TryAcquireAsync(TimeoutValue timeout, CancellationToken cancellationToken);
}
internal static class Medallion.Threading.Internal.BusyWaitHelper : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Medallion.Threading.Internal.BusyWaitHelper/<WaitAsync>d__0`2")]
public static ValueTask`1<TResult> WaitAsync(TState state, Func`3<TState, CancellationToken, ValueTask`1<TResult>> tryGetValue, TimeoutValue timeout, TimeoutValue minSleepTime, TimeoutValue maxSleepTime, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static IDisposable CreateMergedCancellationTokenSourceSource(TimeoutValue timeout, CancellationToken cancellationToken, CancellationToken& mergedCancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <WaitAsync>g__IsTimedOut|0_0(<>c__DisplayClass0_0`2& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Medallion.Threading.Internal.Data.ConnectionMonitor : object {
    private WeakReference`1<DatabaseConnection> _weakConnection;
    [NullableAttribute("2")]
private StateChangeEventHandler _stateChangedHandler;
    private AsyncLock _connectionLock;
    private bool _isExternallyOwnedConnection;
    private TimeoutValue _keepaliveCadence;
    private State _state;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<MonitoringHandle, CancellationTokenSource> _monitoringHandleRegistrations;
    [NullableAttribute("2")]
private CancellationTokenSource _monitorStateChangedTokenSource;
    private Task _monitoringWorkerTask;
    private object Lock { get; }
    private bool HasRegisteredMonitoringHandlesNoLock { get; }
    public ConnectionMonitor(DatabaseConnection connection);
    private object get_Lock();
    private bool get_HasRegisteredMonitoringHandlesNoLock();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.ConnectionMonitor/<AcquireConnectionLockAsync>d__14")]
public ValueTask`1<IDisposable> AcquireConnectionLockAsync(CancellationToken cancellationToken);
    public void SetKeepaliveCadence(TimeoutValue keepaliveCadence);
    public IDatabaseConnectionMonitoringHandle GetMonitoringHandle();
    private void ReleaseMonitoringHandle(MonitoringHandle handle);
    private void OnConnectionStateChanged(object sender, StateChangeEventArgs args);
    public void Start();
    private void StartNoLock();
    public ValueTask StopAsync();
    public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.ConnectionMonitor/<StopOrDisposeAsync>d__23")]
private ValueTask StopOrDisposeAsync(bool isDispose);
    private void CloseOrCancelMonitoringHandleRegistrationsNoLock(bool isCancel);
    private bool StartMonitorWorkerIfNeededNoLock();
    private void FireStateChangedNoLock();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.ConnectionMonitor/<MonitorWorkerLoop>d__27")]
private Task MonitorWorkerLoop();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.ConnectionMonitor/<TryKeepaliveOrMonitorAsync>d__28")]
private Task`1<bool> TryKeepaliveOrMonitorAsync();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.ConnectionMonitor/<DoMonitoringAsync>d__29")]
private Task`1<bool> DoMonitoringAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.ConnectionMonitor/<DoKeepaliveAsync>d__30")]
private Task`1<bool> DoKeepaliveAsync(TimeoutValue keepaliveCadence, CancellationToken stateChangedToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Medallion.Threading.Internal.Data.DatabaseCommand : object {
    private IDbCommand _command;
    private DatabaseConnection _connection;
    public IDataParameterCollection Parameters { get; }
    internal DatabaseCommand(IDbCommand command, DatabaseConnection connection);
    public IDataParameterCollection get_Parameters();
    public void SetCommandText(string sql);
    public void SetTimeout(TimeoutValue operationTimeout);
    public void SetCommandType(CommandType type);
    [NullableContextAttribute("2")]
public IDbDataParameter AddParameter(string name, object value, Nullable`1<DbType> type, Nullable`1<ParameterDirection> direction);
    [NullableContextAttribute("0")]
public ValueTask`1<int> ExecuteNonQueryAsync(CancellationToken cancellationToken, bool disallowAsyncCancellation);
    [NullableContextAttribute("0")]
internal ValueTask`1<int> ExecuteNonQueryAsync(CancellationToken cancellationToken, bool disallowAsyncCancellation, bool isConnectionMonitoringQuery);
    public ValueTask`1<object> ExecuteScalarAsync(CancellationToken cancellationToken, bool disallowAsyncCancellation);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.DatabaseCommand/<ExecuteAsync>d__12`1")]
private ValueTask`1<TResult> ExecuteAsync(Func`3<DbCommand, CancellationToken, Task`1<TResult>> executeAsync, Func`2<IDbCommand, TResult> executeSync, CancellationToken cancellationToken, bool disallowAsyncCancellation, bool isConnectionMonitoringQuery);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.DatabaseCommand/<InternalExecuteAndPropagateCancellationAsync>d__13`2")]
private ValueTask`1<TResult> InternalExecuteAndPropagateCancellationAsync(TState state, Func`3<TState, CancellationToken, ValueTask`1<TResult>> executeAsync, CancellationToken cancellationToken, bool isConnectionMonitoringQuery);
    private ValueTask PrepareIfNeededAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private ValueTask`1<IDisposable> AcquireConnectionLockIfNeeded(bool isConnectionMonitoringQuery);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Medallion.Threading.Internal.Data.DatabaseConnection : object {
    [NullableAttribute("2")]
private IDbTransaction _transaction;
    [CompilerGeneratedAttribute]
private ConnectionMonitor <ConnectionMonitor>k__BackingField;
    [CompilerGeneratedAttribute]
private IDbConnection <InnerConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExernallyOwned>k__BackingField;
    internal ConnectionMonitor ConnectionMonitor { get; }
    internal IDbConnection InnerConnection { get; }
    public bool HasTransaction { get; }
    public bool IsExernallyOwned { get; }
    public bool ShouldPrepareCommands { get; }
    internal bool CanExecuteQueries { get; }
    protected DatabaseConnection(IDbConnection connection, bool isExternallyOwned);
    protected DatabaseConnection(IDbTransaction transaction, bool isExternallyOwned);
    [CompilerGeneratedAttribute]
internal ConnectionMonitor get_ConnectionMonitor();
    [CompilerGeneratedAttribute]
internal IDbConnection get_InnerConnection();
    public bool get_HasTransaction();
    [CompilerGeneratedAttribute]
public bool get_IsExernallyOwned();
    public abstract virtual bool get_ShouldPrepareCommands();
    internal bool get_CanExecuteQueries();
    internal void SetKeepaliveCadence(TimeoutValue cadence);
    internal IDatabaseConnectionMonitoringHandle GetConnectionMonitoringHandle();
    public DatabaseCommand CreateCommand();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.DatabaseConnection/<BeginTransactionAsync>d__21")]
public ValueTask BeginTransactionAsync();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.DatabaseConnection/<OpenAsync>d__22")]
public ValueTask OpenAsync(CancellationToken cancellationToken);
    public ValueTask CloseAsync();
    public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.DatabaseConnection/<DisposeOrCloseAsync>d__25")]
private ValueTask DisposeOrCloseAsync(bool isDispose);
    public ValueTask DisposeTransactionAsync();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.DatabaseConnection/<DisposeTransactionAsync>d__27")]
private ValueTask DisposeTransactionAsync(bool isClosingOrDisposingConnection);
    public abstract virtual bool IsCommandCancellationException(Exception exception);
    public abstract virtual Task SleepAsync(TimeSpan sleepTime, CancellationToken cancellationToken, Func`3<DatabaseCommand, CancellationToken, ValueTask`1<int>> executor);
    [CompilerGeneratedAttribute]
private void <DisposeOrCloseAsync>g__SyncDisposeConnection|25_0(<>c__DisplayClass25_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Medallion.Threading.Internal.Data.DedicatedConnectionOrTransactionDbDistributedLock : object {
    private string _name;
    private Func`1<DatabaseConnection> _connectionFactory;
    private bool _transactionScopedIfPossible;
    private TimeoutValue _keepaliveCadence;
    public DedicatedConnectionOrTransactionDbDistributedLock(string name, Func`1<DatabaseConnection> externalConnectionFactory);
    public DedicatedConnectionOrTransactionDbDistributedLock(string name, Func`1<DatabaseConnection> connectionFactory, bool useTransaction, TimeoutValue keepaliveCadence);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.DedicatedConnectionOrTransactionDbDistributedLock/<TryAcquireAsync>d__6`1")]
public sealed virtual ValueTask`1<IDistributedSynchronizationHandle> TryAcquireAsync(TimeoutValue timeout, IDbSynchronizationStrategy`1<TLockCookie> strategy, CancellationToken cancellationToken, IDistributedSynchronizationHandle contextHandle);
    private DatabaseConnection GetContextHandleConnection(IDistributedSynchronizationHandle contextHandle);
}
internal interface Medallion.Threading.Internal.Data.IDatabaseConnectionMonitoringHandle {
    public CancellationToken ConnectionLostToken { get; }
    public abstract virtual CancellationToken get_ConnectionLostToken();
}
[NullableContextAttribute("1")]
internal interface Medallion.Threading.Internal.Data.IDbDistributedLock {
    public abstract virtual ValueTask`1<IDistributedSynchronizationHandle> TryAcquireAsync(TimeoutValue timeout, IDbSynchronizationStrategy`1<TLockCookie> strategy, CancellationToken cancellationToken, IDistributedSynchronizationHandle contextHandle);
}
[NullableContextAttribute("1")]
internal interface Medallion.Threading.Internal.Data.IDbSynchronizationStrategy`1 {
    public bool IsUpgradeable { get; }
    public abstract virtual bool get_IsUpgradeable();
    public abstract virtual ValueTask`1<TLockCookie> TryAcquireAsync(DatabaseConnection connection, string resourceName, TimeoutValue timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask ReleaseAsync(DatabaseConnection connection, string resourceName, TLockCookie lockCookie);
}
internal class Medallion.Threading.Internal.Data.MultiplexedConnectionLock : object {
    private AsyncLock _mutex;
    [NullableAttribute("1")]
private Dictionary`2<string, TimeoutValue> _heldLocksToKeepaliveCadences;
    [NullableAttribute("1")]
private DatabaseConnection _connection;
    private bool _connectionOpened;
    private bool IsConnectionBrokenNoLock { get; }
    [NullableContextAttribute("1")]
public MultiplexedConnectionLock(DatabaseConnection connection);
    private bool get_IsConnectionBrokenNoLock();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.MultiplexedConnectionLock/<TryAcquireAsync>d__7`1")]
public ValueTask`1<Result> TryAcquireAsync(string name, TimeoutValue timeout, IDbSynchronizationStrategy`1<TLockCookie> strategy, TimeoutValue keepaliveCadence, CancellationToken cancellationToken, bool opportunistic);
    public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.MultiplexedConnectionLock/<GetIsInUseAsync>d__9")]
public ValueTask`1<bool> GetIsInUseAsync();
    private Result GetAlreadyBrokenResultNoLock();
    private Result GetFailureResultNoLock(bool isAlreadyHeld, bool opportunistic, TimeoutValue timeout);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.MultiplexedConnectionLock/<ReleaseAsync>d__12`1")]
private ValueTask ReleaseAsync(IDbSynchronizationStrategy`1<TLockCookie> strategy, string name, TLockCookie lockCookie);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.MultiplexedConnectionLock/<CloseConnectionIfNeededNoLockAsync>d__13")]
private ValueTask CloseConnectionIfNeededNoLockAsync();
    private void SetKeepaliveCadenceNoLock();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Medallion.Threading.Internal.Data.MultiplexedConnectionLockPool : object {
    private AsyncLock _lock;
    private Dictionary`2<string, Queue`1<MultiplexedConnectionLock>> _poolsByConnectionString;
    private UInt32 _storeCountSinceLastPrune;
    private UInt32 _pooledLockCount;
    [CompilerGeneratedAttribute]
private Func`2<string, DatabaseConnection> <ConnectionFactory>k__BackingField;
    internal Func`2<string, DatabaseConnection> ConnectionFactory { get; }
    public MultiplexedConnectionLockPool(Func`2<string, DatabaseConnection> connectionFactory);
    [CompilerGeneratedAttribute]
internal Func`2<string, DatabaseConnection> get_ConnectionFactory();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.MultiplexedConnectionLockPool/<TryAcquireAsync>d__8`1")]
public ValueTask`1<IDistributedSynchronizationHandle> TryAcquireAsync(string connectionString, string name, TimeoutValue timeout, IDbSynchronizationStrategy`1<TLockCookie> strategy, TimeoutValue keepaliveCadence, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.MultiplexedConnectionLockPool/<GetExistingLockOrDefaultAsync>d__9")]
private ValueTask`1<MultiplexedConnectionLock> GetExistingLockOrDefaultAsync(string connectionString);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.MultiplexedConnectionLockPool/<StoreOrDisposeLockAsync>d__10")]
private ValueTask StoreOrDisposeLockAsync(string connectionString, MultiplexedConnectionLock lock, bool shouldDispose);
    private bool IsDueForPruningNoLock();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.Data.MultiplexedConnectionLockPool/<PrunePoolsNoLockAsync>d__12")]
private ValueTask PrunePoolsNoLockAsync();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<Result> <TryAcquireAsync>g__TryAcquireAsync|8_0(MultiplexedConnectionLock lock, bool opportunistic, <>c__DisplayClass8_0`1& );
}
internal enum Medallion.Threading.Internal.Data.MultiplexedConnectionLockRetry : Enum {
    public int value__;
    public static MultiplexedConnectionLockRetry NoRetry;
    public static MultiplexedConnectionLockRetry RetryOnThisLock;
    public static MultiplexedConnectionLockRetry Retry;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Medallion.Threading.Internal.Data.OptimisticConnectionMultiplexingDbDistributedLock : object {
    private string _name;
    private string _connectionString;
    private MultiplexedConnectionLockPool _multiplexedConnectionLockPool;
    private TimeoutValue _keepaliveCadence;
    private IDbDistributedLock _fallbackLock;
    public OptimisticConnectionMultiplexingDbDistributedLock(string name, string connectionString, MultiplexedConnectionLockPool multiplexedConnectionLockPool, TimeoutValue keepaliveCadence);
    public sealed virtual ValueTask`1<IDistributedSynchronizationHandle> TryAcquireAsync(TimeoutValue timeout, IDbSynchronizationStrategy`1<TLockCookie> strategy, CancellationToken cancellationToken, IDistributedSynchronizationHandle contextHandle);
    [CompilerGeneratedAttribute]
private DatabaseConnection <.ctor>b__5_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Medallion.Threading.Internal.DistributedLockHelpers : object {
    public static string ToSafeName(string name, int maxNameLength, Func`2<string, string> convertToValidName);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.DistributedLockHelpers/<Wrap>d__1`1")]
[ExtensionAttribute]
public static ValueTask`1<THandle> Wrap(ValueTask`1<IDistributedSynchronizationHandle> handleTask, Func`2<IDistributedSynchronizationHandle, THandle> factory);
    public static ValueTask`1<THandle> AcquireAsync(IInternalDistributedLock`1<THandle> lock, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public static THandle Acquire(IInternalDistributedLock`1<THandle> lock, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public static THandle TryAcquire(IInternalDistributedLock`1<THandle> lock, TimeSpan timeout, CancellationToken cancellationToken);
    public static ValueTask`1<THandle> AcquireAsync(IInternalDistributedReaderWriterLock`1<THandle> lock, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken, bool isWrite);
    public static THandle Acquire(IInternalDistributedReaderWriterLock`1<THandle> lock, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken, bool isWrite);
    public static THandle TryAcquire(IInternalDistributedReaderWriterLock`1<THandle> lock, TimeSpan timeout, CancellationToken cancellationToken, bool isWrite);
    public static ValueTask`1<TUpgradeableHandle> AcquireUpgradeableReadLockAsync(IInternalDistributedUpgradeableReaderWriterLock`2<THandle, TUpgradeableHandle> lock, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public static TUpgradeableHandle AcquireUpgradeableReadLock(IInternalDistributedUpgradeableReaderWriterLock`2<THandle, TUpgradeableHandle> lock, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public static TUpgradeableHandle TryAcquireUpgradeableReadLock(IInternalDistributedUpgradeableReaderWriterLock`2<THandle, TUpgradeableHandle> lock, TimeSpan timeout, CancellationToken cancellationToken);
    public static ValueTask`1<THandle> AcquireAsync(IInternalDistributedSemaphore`1<THandle> lock, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public static THandle Acquire(IInternalDistributedSemaphore`1<THandle> lock, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public static THandle TryAcquire(IInternalDistributedSemaphore`1<THandle> lock, TimeSpan timeout, CancellationToken cancellationToken);
    public static ValueTask UpgradeToWriteLockAsync(IInternalDistributedLockUpgradeableHandle handle, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public static void UpgradeToWriteLock(IDistributedLockUpgradeableHandle handle, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public static bool TryUpgradeToWriteLock(IDistributedLockUpgradeableHandle handle, TimeSpan timeout, CancellationToken cancellationToken);
    private static Exception LockTimeout(string object);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.DistributedLockHelpers/<ThrowTimeoutIfNull>d__18`1")]
[ExtensionAttribute]
public static ValueTask`1<T> ThrowTimeoutIfNull(ValueTask`1<T> task, string object);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Medallion.Threading.Internal.DistributedLockHelpers/<ThrowTimeoutIfFalse>d__19")]
[ExtensionAttribute]
private static ValueTask ThrowTimeoutIfFalse(ValueTask`1<bool> task);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Medallion.Threading.Internal.Helpers : object {
    [ExtensionAttribute]
public static T As(T this);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Medallion.Threading.Internal.Helpers/<Convert>d__1`2")]
[ExtensionAttribute]
public static ValueTask`1<TBase> Convert(ValueTask`1<TDerived> task, ValueTaskConversion<TBase> _);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Medallion.Threading.Internal.Helpers/<ConvertToVoid>d__4`1")]
[ExtensionAttribute]
internal static ValueTask ConvertToVoid(ValueTask`1<TResult> task);
    [ExtensionAttribute]
public static ValueTask`1<T> AsValueTask(Task`1<T> task);
    [ExtensionAttribute]
public static ValueTask AsValueTask(Task task);
    [ExtensionAttribute]
public static ValueTask`1<T> AsValueTask(T value);
    public static Task`1<TResult> SafeCreateTask(Func`2<TState, Task`1<TResult>> taskFactory, TState state);
    public static Task SafeCreateTask(Func`2<TState, Task> taskFactory, TState state);
    private static TTask InternalSafeCreateTask(Func`2<TState, TTask> taskFactory, TState state);
    [ExtensionAttribute]
public static ObjectDisposedException ObjectDisposed(T _);
    [ExtensionAttribute]
public static NonThrowingAwaitable`1<TTask> TryAwait(TTask task);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryGetValue(Nullable`1<T> nullable, T& value);
}
[NullableContextAttribute("1")]
internal interface Medallion.Threading.Internal.IInternalDistributedLock`1 {
    [NullableContextAttribute("2")]
public abstract virtual THandle TryAcquire(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual THandle Acquire(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> TryAcquireAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> AcquireAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> InternalTryAcquireAsync(TimeoutValue timeout, CancellationToken cancellationToken);
}
internal interface Medallion.Threading.Internal.IInternalDistributedLockUpgradeableHandle {
    public abstract virtual ValueTask`1<bool> InternalTryUpgradeToWriteLockAsync(TimeoutValue timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Medallion.Threading.Internal.IInternalDistributedReaderWriterLock`1 {
    [NullableContextAttribute("2")]
public abstract virtual THandle TryAcquireReadLock(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual THandle AcquireReadLock(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> TryAcquireReadLockAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> AcquireReadLockAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual THandle TryAcquireWriteLock(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual THandle AcquireWriteLock(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> TryAcquireWriteLockAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> AcquireWriteLockAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> InternalTryAcquireAsync(TimeoutValue timeout, CancellationToken cancellationToken, bool isWrite);
}
[NullableContextAttribute("1")]
internal interface Medallion.Threading.Internal.IInternalDistributedSemaphore`1 {
    [NullableContextAttribute("2")]
public abstract virtual THandle TryAcquire(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual THandle Acquire(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> TryAcquireAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> AcquireAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<THandle> InternalTryAcquireAsync(TimeoutValue timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Medallion.Threading.Internal.IInternalDistributedUpgradeableReaderWriterLock`2 {
    [NullableContextAttribute("2")]
public abstract virtual TUpgradeableHandle TryAcquireUpgradeableReadLock(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual TUpgradeableHandle AcquireUpgradeableReadLock(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<TUpgradeableHandle> TryAcquireUpgradeableReadLockAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<TUpgradeableHandle> AcquireUpgradeableReadLockAsync(Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<TUpgradeableHandle> InternalTryAcquireUpgradeableReadLockAsync(TimeoutValue timeout, CancellationToken cancellationToken);
}
internal static class Medallion.Threading.Internal.Invariant : object {
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void Require(bool condition, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Medallion.Threading.Internal.LeaseMonitor : object {
    private CancellationTokenSource _disposalSource;
    private CancellationTokenSource _handleLostSource;
    private ILeaseHandle _leaseHandle;
    private Task _monitoringTask;
    [NullableAttribute("2")]
private Task _cancellationTask;
    public CancellationToken HandleLostToken { get; }
    public LeaseMonitor(ILeaseHandle leaseHandle);
    public CancellationToken get_HandleLostToken();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.LeaseMonitor/<DisposeAsync>d__9")]
public sealed virtual ValueTask DisposeAsync();
    private static Task CreateMonitoringLoopTask(WeakReference`1<LeaseMonitor> weakMonitor, TimeoutValue monitoringCadence, CancellationToken disposalToken);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.LeaseMonitor/<RunMonitoringLoopIterationAsync>d__11")]
private static Task`1<bool> RunMonitoringLoopIterationAsync(WeakReference`1<LeaseMonitor> weakMonitor, Stopwatch leaseLifetime);
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.LeaseMonitor/<CheckLeaseAsync>d__12")]
private Task`1<LeaseState> CheckLeaseAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Medallion.Threading.Internal.ManagedFinalizerQueue : object {
    internal static TimeSpan FinalizerCadence;
    public static ManagedFinalizerQueue Instance;
    private ConcurrentDictionary`2<IAsyncDisposable, WeakReference> _items;
    private long _count;
    private Task _finalizerTask;
    private int _finalizerTaskIsInitializing;
    private static ManagedFinalizerQueue();
    public IDisposable Register(object resource, IAsyncDisposable finalizer);
    private void StartFinalizerTask();
    [AsyncStateMachineAttribute("Medallion.Threading.Internal.ManagedFinalizerQueue/<FinalizerLoop>d__9")]
private Task FinalizerLoop();
    private Task FinalizeAsync(bool waitForItemFinalization);
    internal Task FinalizeAsync();
    private Task TryRemove(IAsyncDisposable key, bool disposeKey);
}
internal class Medallion.Threading.Internal.RefBox : object {
    public static RefBox`1<T> Create(T value);
    public static bool TryConsume(RefBox`1& boxRef, T& value);
}
internal class Medallion.Threading.Internal.RefBox`1 : object {
    private T _value;
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Value { get; }
    internal RefBox`1(T value);
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Medallion.Threading.Internal.SyncViaAsync : object {
    [ThreadStaticAttribute]
private static bool _isSynchronous;
    public static bool IsSynchronous { get; }
    public static bool get_IsSynchronous();
    public static void Run(Func`2<TState, ValueTask> action, TState state);
    public static TResult Run(Func`2<TState, ValueTask`1<TResult>> action, TState state);
    public static ValueTask Delay(TimeoutValue timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void DisposeSyncViaAsync(TDisposable disposable);
    [ExtensionAttribute]
public static ValueTask`1<TResult> AwaitSyncOverAsync(Task`1<TResult> task);
    [ExtensionAttribute]
public static ValueTask AwaitSyncOverAsync(Task task);
}
[IsReadOnlyAttribute]
internal class Medallion.Threading.Internal.TimeoutValue : ValueType {
    [CompilerGeneratedAttribute]
private int <InMilliseconds>k__BackingField;
    public int InMilliseconds { get; }
    public int InSeconds { get; }
    public bool IsInfinite { get; }
    public bool IsZero { get; }
    public TimeSpan TimeSpan { get; }
    [NullableContextAttribute("1")]
public TimeoutValue(Nullable`1<TimeSpan> timeout, string paramName);
    [CompilerGeneratedAttribute]
public int get_InMilliseconds();
    public int get_InSeconds();
    public bool get_IsInfinite();
    public bool get_IsZero();
    public TimeSpan get_TimeSpan();
    public sealed virtual bool Equals(TimeoutValue that);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(TimeoutValue that);
    public static bool op_Equality(TimeoutValue a, TimeoutValue b);
    public static bool op_Inequality(TimeoutValue a, TimeoutValue b);
    public static TimeoutValue op_Implicit(Nullable`1<TimeSpan> timeout);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal static class Medallion.Threading.Internal.To`1 : object {
    public static ValueTaskConversion<TTo> ValueTask { get; }
    public static ValueTaskConversion<TTo> get_ValueTask();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
