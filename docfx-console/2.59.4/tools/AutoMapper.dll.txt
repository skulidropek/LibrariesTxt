public class AutoMapper.AutoMapperConfigurationException : Exception {
    [CompilerGeneratedAttribute]
private TypeMapConfigErrors[] <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypePair> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyMap <PropertyMap>k__BackingField;
    public TypeMapConfigErrors[] Errors { get; }
    public Nullable`1<TypePair> Types { get; }
    public PropertyMap PropertyMap { get; public set; }
    public string Message { get; }
    public string StackTrace { get; }
    public AutoMapperConfigurationException(string message);
    protected AutoMapperConfigurationException(string message, Exception inner);
    public AutoMapperConfigurationException(TypeMapConfigErrors[] errors);
    public AutoMapperConfigurationException(TypePair types);
    [CompilerGeneratedAttribute]
public TypeMapConfigErrors[] get_Errors();
    [CompilerGeneratedAttribute]
public Nullable`1<TypePair> get_Types();
    [CompilerGeneratedAttribute]
public PropertyMap get_PropertyMap();
    [CompilerGeneratedAttribute]
public void set_PropertyMap(PropertyMap value);
    public virtual string get_Message();
    public virtual string get_StackTrace();
}
public class AutoMapper.AutoMapperMappingException : Exception {
    private string _message;
    [CompilerGeneratedAttribute]
private Nullable`1<TypePair> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeMap <TypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyMap <PropertyMap>k__BackingField;
    public Nullable`1<TypePair> Types { get; public set; }
    public TypeMap TypeMap { get; public set; }
    public PropertyMap PropertyMap { get; public set; }
    public string Message { get; }
    public string StackTrace { get; }
    public AutoMapperMappingException(string message);
    public AutoMapperMappingException(string message, Exception innerException);
    public AutoMapperMappingException(string message, Exception innerException, TypePair types);
    public AutoMapperMappingException(string message, Exception innerException, TypePair types, TypeMap typeMap);
    public AutoMapperMappingException(string message, Exception innerException, TypePair types, TypeMap typeMap, PropertyMap propertyMap);
    [CompilerGeneratedAttribute]
public Nullable`1<TypePair> get_Types();
    [CompilerGeneratedAttribute]
public void set_Types(Nullable`1<TypePair> value);
    [CompilerGeneratedAttribute]
public TypeMap get_TypeMap();
    [CompilerGeneratedAttribute]
public void set_TypeMap(TypeMap value);
    [CompilerGeneratedAttribute]
public PropertyMap get_PropertyMap();
    [CompilerGeneratedAttribute]
public void set_PropertyMap(PropertyMap value);
    public virtual string get_Message();
    public virtual string get_StackTrace();
}
public class AutoMapper.Configuration.Conventions.AllMemberInfo : object {
    private IList`1<Func`2<MemberInfo, bool>> _predicates;
    public sealed virtual IEnumerable`1<MemberInfo> GetMemberInfos(TypeDetails typeInfo);
    public sealed virtual IGetTypeInfoMembers AddCondition(Func`2<MemberInfo, bool> predicate);
    [CompilerGeneratedAttribute]
private bool <GetMemberInfos>b__1_0(MemberInfo m);
}
public class AutoMapper.Configuration.Conventions.CaseInsensitiveName : object {
    public sealed virtual MemberInfo GetMatchingMemberInfo(IGetTypeInfoMembers getTypeInfoMembers, TypeDetails typeInfo, Type destType, Type destMemberType, string nameToSearch);
}
public class AutoMapper.Configuration.Conventions.CaseSensitiveName : object {
    [CompilerGeneratedAttribute]
private bool <MethodCaseSensitive>k__BackingField;
    public bool MethodCaseSensitive { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_MethodCaseSensitive();
    [CompilerGeneratedAttribute]
public void set_MethodCaseSensitive(bool value);
    public sealed virtual MemberInfo GetMatchingMemberInfo(IGetTypeInfoMembers getTypeInfoMembers, TypeDetails typeInfo, Type destType, Type destMemberType, string nameToSearch);
}
public class AutoMapper.Configuration.Conventions.DefaultMember : object {
    [CompilerGeneratedAttribute]
private IParentSourceToDestinationNameMapper <NameMapper>k__BackingField;
    public IParentSourceToDestinationNameMapper NameMapper { get; public set; }
    [CompilerGeneratedAttribute]
public IParentSourceToDestinationNameMapper get_NameMapper();
    [CompilerGeneratedAttribute]
public void set_NameMapper(IParentSourceToDestinationNameMapper value);
    public sealed virtual bool MapDestinationPropertyToSource(ProfileMap options, TypeDetails sourceType, Type destType, Type destMemberType, string nameToSearch, LinkedList`1<MemberInfo> resolvers, IMemberConfiguration parent);
}
public class AutoMapper.Configuration.Conventions.DefaultName : CaseSensitiveName {
}
public interface AutoMapper.Configuration.Conventions.IChildMemberConfiguration {
    public abstract virtual bool MapDestinationPropertyToSource(ProfileMap options, TypeDetails sourceType, Type destType, Type destMemberType, string nameToSearch, LinkedList`1<MemberInfo> resolvers, IMemberConfiguration parent);
}
public interface AutoMapper.Configuration.Conventions.IGetTypeInfoMembers {
    public abstract virtual IEnumerable`1<MemberInfo> GetMemberInfos(TypeDetails typeInfo);
    public abstract virtual IGetTypeInfoMembers AddCondition(Func`2<MemberInfo, bool> predicate);
}
public interface AutoMapper.Configuration.Conventions.IMemberConfiguration {
    public IList`1<IChildMemberConfiguration> MemberMappers { get; }
    public IParentSourceToDestinationNameMapper NameMapper { get; public set; }
    public abstract virtual IList`1<IChildMemberConfiguration> get_MemberMappers();
    public abstract virtual IMemberConfiguration AddMember(Action`1<TMemberMapper> setupAction);
    public abstract virtual IMemberConfiguration AddName(Action`1<TNameMapper> setupAction);
    public abstract virtual IParentSourceToDestinationNameMapper get_NameMapper();
    public abstract virtual void set_NameMapper(IParentSourceToDestinationNameMapper value);
    public abstract virtual bool MapDestinationPropertyToSource(ProfileMap options, TypeDetails sourceType, Type destType, Type destMemberType, string nameToSearch, LinkedList`1<MemberInfo> resolvers);
}
public interface AutoMapper.Configuration.Conventions.IParentSourceToDestinationNameMapper {
    public ICollection`1<ISourceToDestinationNameMapper> NamedMappers { get; }
    public IGetTypeInfoMembers GetMembers { get; }
    public abstract virtual ICollection`1<ISourceToDestinationNameMapper> get_NamedMappers();
    public abstract virtual IGetTypeInfoMembers get_GetMembers();
    public abstract virtual MemberInfo GetMatchingMemberInfo(TypeDetails typeInfo, Type destType, Type destMemberType, string nameToSearch);
}
public interface AutoMapper.Configuration.Conventions.ISourceToDestinationNameMapper {
    public abstract virtual MemberInfo GetMatchingMemberInfo(IGetTypeInfoMembers getTypeInfoMembers, TypeDetails typeInfo, Type destType, Type destMemberType, string nameToSearch);
}
[AttributeUsageAttribute("384")]
public class AutoMapper.Configuration.Conventions.MapToAttribute : SourceToDestinationMapperAttribute {
    [CompilerGeneratedAttribute]
private string <MatchingName>k__BackingField;
    public string MatchingName { get; }
    public MapToAttribute(string matchingName);
    [CompilerGeneratedAttribute]
public string get_MatchingName();
    public virtual bool IsMatch(TypeDetails typeInfo, MemberInfo memberInfo, Type destType, Type destMemberType, string nameToSearch);
}
public class AutoMapper.Configuration.Conventions.MemberConfiguration : object {
    [CompilerGeneratedAttribute]
private IParentSourceToDestinationNameMapper <NameMapper>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IChildMemberConfiguration> <MemberMappers>k__BackingField;
    public IParentSourceToDestinationNameMapper NameMapper { get; public set; }
    public IList`1<IChildMemberConfiguration> MemberMappers { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IParentSourceToDestinationNameMapper get_NameMapper();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NameMapper(IParentSourceToDestinationNameMapper value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IChildMemberConfiguration> get_MemberMappers();
    public sealed virtual IMemberConfiguration AddMember(Action`1<TMemberMapper> setupAction);
    public sealed virtual IMemberConfiguration AddName(Action`1<TNameMapper> setupAction);
    private TMemberMapper GetOrAdd(Func`2<IMemberConfiguration, IList> getList, Action`1<TMemberMapper> setupAction);
    public sealed virtual bool MapDestinationPropertyToSource(ProfileMap options, TypeDetails sourceType, Type destType, Type destMemberType, string nameToSearch, LinkedList`1<MemberInfo> resolvers);
}
public class AutoMapper.Configuration.Conventions.MemberNameReplacer : object {
    [CompilerGeneratedAttribute]
private string <OriginalValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewValue>k__BackingField;
    public string OriginalValue { get; private set; }
    public string NewValue { get; private set; }
    public MemberNameReplacer(string originalValue, string newValue);
    [CompilerGeneratedAttribute]
public string get_OriginalValue();
    [CompilerGeneratedAttribute]
private void set_OriginalValue(string value);
    [CompilerGeneratedAttribute]
public string get_NewValue();
    [CompilerGeneratedAttribute]
private void set_NewValue(string value);
}
public class AutoMapper.Configuration.Conventions.NameSplitMember : object {
    [CompilerGeneratedAttribute]
private INamingConvention <SourceMemberNamingConvention>k__BackingField;
    [CompilerGeneratedAttribute]
private INamingConvention <DestinationMemberNamingConvention>k__BackingField;
    public INamingConvention SourceMemberNamingConvention { get; public set; }
    public INamingConvention DestinationMemberNamingConvention { get; public set; }
    [CompilerGeneratedAttribute]
public INamingConvention get_SourceMemberNamingConvention();
    [CompilerGeneratedAttribute]
public void set_SourceMemberNamingConvention(INamingConvention value);
    [CompilerGeneratedAttribute]
public INamingConvention get_DestinationMemberNamingConvention();
    [CompilerGeneratedAttribute]
public void set_DestinationMemberNamingConvention(INamingConvention value);
    public sealed virtual bool MapDestinationPropertyToSource(ProfileMap options, TypeDetails sourceType, Type destType, Type destMemberType, string nameToSearch, LinkedList`1<MemberInfo> resolvers, IMemberConfiguration parent);
    private NameSnippet CreateNameSnippet(IEnumerable`1<string> matches, int i);
    [CompilerGeneratedAttribute]
private string <MapDestinationPropertyToSource>b__9_0(Match m);
    [CompilerGeneratedAttribute]
private string <CreateNameSnippet>b__10_0(string s);
    [CompilerGeneratedAttribute]
private string <CreateNameSnippet>b__10_1(string s);
}
public class AutoMapper.Configuration.Conventions.ParentSourceToDestinationNameMapper : object {
    [CompilerGeneratedAttribute]
private IGetTypeInfoMembers <GetMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ISourceToDestinationNameMapper> <NamedMappers>k__BackingField;
    public IGetTypeInfoMembers GetMembers { get; }
    public ICollection`1<ISourceToDestinationNameMapper> NamedMappers { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IGetTypeInfoMembers get_GetMembers();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<ISourceToDestinationNameMapper> get_NamedMappers();
    public sealed virtual MemberInfo GetMatchingMemberInfo(TypeDetails typeInfo, Type destType, Type destMemberType, string nameToSearch);
}
public class AutoMapper.Configuration.Conventions.PrePostfixName : object {
    [CompilerGeneratedAttribute]
private ICollection`1<string> <Prefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <Postfixes>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <DestinationPrefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <DestinationPostfixes>k__BackingField;
    public ICollection`1<string> Prefixes { get; }
    public ICollection`1<string> Postfixes { get; }
    public ICollection`1<string> DestinationPrefixes { get; }
    public ICollection`1<string> DestinationPostfixes { get; }
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_Prefixes();
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_Postfixes();
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_DestinationPrefixes();
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_DestinationPostfixes();
    public PrePostfixName AddStrings(Func`2<PrePostfixName, ICollection`1<string>> getStringsFunc, String[] names);
    public sealed virtual MemberInfo GetMatchingMemberInfo(IGetTypeInfoMembers getTypeInfoMembers, TypeDetails typeInfo, Type destType, Type destMemberType, string nameToSearch);
    [IteratorStateMachineAttribute("AutoMapper.Configuration.Conventions.PrePostfixName/<PossibleNames>d__14")]
private IEnumerable`1<string> PossibleNames(string memberName, IEnumerable`1<string> prefixes, IEnumerable`1<string> postfixes);
    private IEnumerable`1<string> PostFixes(IEnumerable`1<string> postfixes, string name);
}
public class AutoMapper.Configuration.Conventions.ReplaceName : object {
    [CompilerGeneratedAttribute]
private ICollection`1<MemberNameReplacer> <MemberNameReplacers>k__BackingField;
    private ICollection`1<MemberNameReplacer> MemberNameReplacers { get; }
    [CompilerGeneratedAttribute]
private ICollection`1<MemberNameReplacer> get_MemberNameReplacers();
    public ReplaceName AddReplace(string original, string newValue);
    public sealed virtual MemberInfo GetMatchingMemberInfo(IGetTypeInfoMembers getTypeInfoMembers, TypeDetails typeInfo, Type destType, Type destMemberType, string nameToSearch);
    private IEnumerable`1<string> PossibleNames(string nameToSearch);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType6`2<MemberInfo, IEnumerable`1<string>> <GetMatchingMemberInfo>b__5_0(MemberInfo mi);
}
public abstract class AutoMapper.Configuration.Conventions.SourceToDestinationMapperAttribute : Attribute {
    public abstract virtual bool IsMatch(TypeDetails typeInfo, MemberInfo memberInfo, Type destType, Type destMemberType, string nameToSearch);
}
public class AutoMapper.Configuration.Conventions.SourceToDestinationNameMapperAttributesMember : object {
    private static SourceMember[] Empty;
    private Dictionary`2<TypeDetails, SourceMember[]> allSourceMembers;
    private static SourceToDestinationNameMapperAttributesMember();
    public sealed virtual MemberInfo GetMatchingMemberInfo(IGetTypeInfoMembers getTypeInfoMembers, TypeDetails typeInfo, Type destType, Type destMemberType, string nameToSearch);
}
public interface AutoMapper.Configuration.IConfiguration {
    public Func`2<Type, object> ServiceCtor { get; }
    public IEnumerable`1<IProfileConfiguration> Profiles { get; }
    public abstract virtual Func`2<Type, object> get_ServiceCtor();
    public abstract virtual IEnumerable`1<IProfileConfiguration> get_Profiles();
}
public interface AutoMapper.Configuration.IProfileConfiguration {
    public IEnumerable`1<IMemberConfiguration> MemberConfigurations { get; }
    public IEnumerable`1<IConditionalObjectMapper> TypeConfigurations { get; }
    public Nullable`1<bool> ConstructorMappingEnabled { get; }
    public Nullable`1<bool> AllowNullDestinationValues { get; }
    public Nullable`1<bool> AllowNullCollections { get; }
    public Nullable`1<bool> EnableNullPropagationForQueryMapping { get; }
    public Nullable`1<bool> CreateMissingTypeMaps { get; }
    public IEnumerable`1<Action`2<TypeMap, IMappingExpression>> AllTypeMapActions { get; }
    public IEnumerable`1<Action`2<PropertyMap, IMemberConfigurationExpression>> AllPropertyMapActions { get; }
    public IEnumerable`1<MethodInfo> SourceExtensionMethods { get; }
    public Func`2<PropertyInfo, bool> ShouldMapProperty { get; }
    public Func`2<FieldInfo, bool> ShouldMapField { get; }
    public string ProfileName { get; }
    public IEnumerable`1<string> GlobalIgnores { get; }
    public INamingConvention SourceMemberNamingConvention { get; }
    public INamingConvention DestinationMemberNamingConvention { get; }
    public IEnumerable`1<ITypeMapConfiguration> TypeMapConfigs { get; }
    public IEnumerable`1<ITypeMapConfiguration> OpenTypeMapConfigs { get; }
    public abstract virtual IEnumerable`1<IMemberConfiguration> get_MemberConfigurations();
    public abstract virtual IEnumerable`1<IConditionalObjectMapper> get_TypeConfigurations();
    public abstract virtual Nullable`1<bool> get_ConstructorMappingEnabled();
    public abstract virtual Nullable`1<bool> get_AllowNullDestinationValues();
    public abstract virtual Nullable`1<bool> get_AllowNullCollections();
    public abstract virtual Nullable`1<bool> get_EnableNullPropagationForQueryMapping();
    public abstract virtual Nullable`1<bool> get_CreateMissingTypeMaps();
    public abstract virtual IEnumerable`1<Action`2<TypeMap, IMappingExpression>> get_AllTypeMapActions();
    public abstract virtual IEnumerable`1<Action`2<PropertyMap, IMemberConfigurationExpression>> get_AllPropertyMapActions();
    public abstract virtual IEnumerable`1<MethodInfo> get_SourceExtensionMethods();
    public abstract virtual Func`2<PropertyInfo, bool> get_ShouldMapProperty();
    public abstract virtual Func`2<FieldInfo, bool> get_ShouldMapField();
    public abstract virtual string get_ProfileName();
    public abstract virtual IEnumerable`1<string> get_GlobalIgnores();
    public abstract virtual INamingConvention get_SourceMemberNamingConvention();
    public abstract virtual INamingConvention get_DestinationMemberNamingConvention();
    public abstract virtual IEnumerable`1<ITypeMapConfiguration> get_TypeMapConfigs();
    public abstract virtual IEnumerable`1<ITypeMapConfiguration> get_OpenTypeMapConfigs();
}
public interface AutoMapper.Configuration.IPropertyMapConfiguration {
    public MemberInfo DestinationMember { get; }
    public abstract virtual void Configure(TypeMap typeMap);
    public abstract virtual MemberInfo get_DestinationMember();
}
public interface AutoMapper.Configuration.ITypeMapConfiguration {
    public MemberList MemberList { get; }
    public Type SourceType { get; }
    public Type DestinationType { get; }
    public bool IsOpenGeneric { get; }
    public TypePair Types { get; }
    public ITypeMapConfiguration ReverseTypeMap { get; }
    public abstract virtual void Configure(TypeMap typeMap);
    public abstract virtual MemberList get_MemberList();
    public abstract virtual Type get_SourceType();
    public abstract virtual Type get_DestinationType();
    public abstract virtual bool get_IsOpenGeneric();
    public abstract virtual TypePair get_Types();
    public abstract virtual ITypeMapConfiguration get_ReverseTypeMap();
}
public class AutoMapper.Configuration.MapperConfigurationExpression : Profile {
    private IList`1<Profile> _profiles;
    [CompilerGeneratedAttribute]
private Func`2<Type, object> <ServiceCtor>k__BackingField;
    public IEnumerable`1<IProfileConfiguration> Profiles { get; }
    public Func`2<Type, object> ServiceCtor { get; private set; }
    public sealed virtual IEnumerable`1<IProfileConfiguration> get_Profiles();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Type, object> get_ServiceCtor();
    [CompilerGeneratedAttribute]
private void set_ServiceCtor(Func`2<Type, object> value);
    public sealed virtual void CreateProfile(string profileName, Action`1<IProfileExpression> config);
    public sealed virtual void AddProfile(Profile profile);
    public sealed virtual void AddProfile();
    public sealed virtual void AddProfile(Type profileType);
    public sealed virtual void AddProfiles(IEnumerable`1<Assembly> assembliesToScan);
    public sealed virtual void AddProfiles(Assembly[] assembliesToScan);
    public sealed virtual void AddProfiles(IEnumerable`1<string> assemblyNamesToScan);
    public sealed virtual void AddProfiles(String[] assemblyNamesToScan);
    public sealed virtual void AddProfiles(IEnumerable`1<Type> typesFromAssembliesContainingProfiles);
    public sealed virtual void AddProfiles(Type[] typesFromAssembliesContainingProfiles);
    private void AddProfilesCore(IEnumerable`1<Assembly> assembliesToScan);
    public sealed virtual void ConstructServicesUsing(Func`2<Type, object> constructor);
}
public class AutoMapper.Configuration.MappingExpression : MappingExpression`2<object, object> {
    public MappingExpression(TypePair types, MemberList memberList);
    public sealed virtual IMappingExpression ReverseMap();
    public sealed virtual IMappingExpression Substitute(Func`2<object, object> substituteFunc);
    public sealed virtual IMappingExpression ConstructUsingServiceLocator();
    public sealed virtual void ForAllMembers(Action`1<IMemberConfigurationExpression> memberOptions);
    private sealed virtual override void AutoMapper.IMappingExpression.ConvertUsing();
    public sealed virtual void ConvertUsing(Type typeConverterType);
    public sealed virtual void ForAllOtherMembers(Action`1<IMemberConfigurationExpression> memberOptions);
    public sealed virtual IMappingExpression ForMember(string name, Action`1<IMemberConfigurationExpression> memberOptions);
    public sealed virtual IMappingExpression ForSourceMember(string sourceMemberName, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public sealed virtual IMappingExpression Include(Type otherSourceType, Type otherDestinationType);
    public sealed virtual IMappingExpression IgnoreAllPropertiesWithAnInaccessibleSetter();
    public sealed virtual IMappingExpression IgnoreAllSourcePropertiesWithAnInaccessibleSetter();
    public sealed virtual IMappingExpression IncludeBase(Type sourceBase, Type destinationBase);
    public sealed virtual IMappingExpression BeforeMap(Action`2<object, object> beforeFunction);
    public sealed virtual IMappingExpression BeforeMap();
    public sealed virtual IMappingExpression AfterMap(Action`2<object, object> afterFunction);
    public sealed virtual IMappingExpression AfterMap();
    public sealed virtual IMappingExpression ConstructUsing(Func`2<object, object> ctor);
    public sealed virtual IMappingExpression ConstructUsing(Func`3<object, ResolutionContext, object> ctor);
    public sealed virtual IMappingExpression ConstructProjectionUsing(LambdaExpression ctor);
    public sealed virtual IMappingExpression MaxDepth(int depth);
    public sealed virtual IMappingExpression ForCtorParam(string ctorParamName, Action`1<ICtorParamConfigurationExpression`1<object>> paramOptions);
    public sealed virtual IMappingExpression PreserveReferences();
    protected virtual IPropertyMapConfiguration CreateMemberConfigurationExpression(MemberInfo member, Type sourceType);
    protected virtual MappingExpression`2<object, object> CreateReverseMapExpression();
}
public class AutoMapper.Configuration.MappingExpression`2 : object {
    private List`1<IPropertyMapConfiguration> _memberConfigurations;
    private List`1<SourceMappingExpression> _sourceMemberConfigurations;
    private List`1<CtorParamConfigurationExpression`1<TSource>> _ctorParamConfigurations;
    private MappingExpression`2<TDestination, TSource> _reverseMap;
    private Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> _allMemberOptions;
    private Func`2<MemberInfo, bool> _memberFilter;
    [CompilerGeneratedAttribute]
private MemberList <MemberList>k__BackingField;
    [CompilerGeneratedAttribute]
private TypePair <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOpenGeneric>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Action`1<TypeMap>> <TypeMapActions>k__BackingField;
    public MemberList MemberList { get; }
    public TypePair Types { get; }
    public Type SourceType { get; }
    public Type DestinationType { get; }
    public bool IsOpenGeneric { get; }
    public ITypeMapConfiguration ReverseTypeMap { get; }
    protected List`1<Action`1<TypeMap>> TypeMapActions { get; }
    public MappingExpression`2(MemberList memberList);
    public MappingExpression`2(MemberList memberList, Type sourceType, Type destinationType);
    [CompilerGeneratedAttribute]
public sealed virtual MemberList get_MemberList();
    [CompilerGeneratedAttribute]
public sealed virtual TypePair get_Types();
    public sealed virtual Type get_SourceType();
    public sealed virtual Type get_DestinationType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOpenGeneric();
    public sealed virtual ITypeMapConfiguration get_ReverseTypeMap();
    [CompilerGeneratedAttribute]
protected List`1<Action`1<TypeMap>> get_TypeMapActions();
    public sealed virtual IMappingExpression`2<TSource, TDestination> PreserveReferences();
    protected virtual IPropertyMapConfiguration CreateMemberConfigurationExpression(MemberInfo member, Type sourceType);
    protected virtual MappingExpression`2<TDestination, TSource> CreateReverseMapExpression();
    public sealed virtual IMappingExpression`2<TSource, TDestination> ForMember(Expression`1<Func`2<TDestination, TMember>> destinationMember, Action`1<IMemberConfigurationExpression`3<TSource, TDestination, TMember>> memberOptions);
    public sealed virtual IMappingExpression`2<TSource, TDestination> ForMember(string name, Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public sealed virtual void ForAllOtherMembers(Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public sealed virtual void ForAllMembers(Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public sealed virtual IMappingExpression`2<TSource, TDestination> IgnoreAllPropertiesWithAnInaccessibleSetter();
    public sealed virtual IMappingExpression`2<TSource, TDestination> IgnoreAllSourcePropertiesWithAnInaccessibleSetter();
    public sealed virtual IMappingExpression`2<TSource, TDestination> Include();
    public sealed virtual IMappingExpression`2<TSource, TDestination> Include(Type otherSourceType, Type otherDestinationType);
    public sealed virtual IMappingExpression`2<TSource, TDestination> IncludeBase();
    public IMappingExpression`2<TSource, TDestination> IncludeBase(Type sourceBase, Type destinationBase);
    public sealed virtual void ProjectUsing(Expression`1<Func`2<TSource, TDestination>> projectionExpression);
    public sealed virtual IMappingExpression`2<TSource, TDestination> MaxDepth(int depth);
    public sealed virtual IMappingExpression`2<TSource, TDestination> ConstructUsingServiceLocator();
    public sealed virtual IMappingExpression`2<TDestination, TSource> ReverseMap();
    public sealed virtual IMappingExpression`2<TSource, TDestination> ForSourceMember(Expression`1<Func`2<TSource, object>> sourceMember, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public sealed virtual IMappingExpression`2<TSource, TDestination> ForSourceMember(string sourceMemberName, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public sealed virtual IMappingExpression`2<TSource, TDestination> Substitute(Func`2<TSource, TSubstitute> substituteFunc);
    public sealed virtual void ConvertUsing(Func`2<TSource, TDestination> mappingFunction);
    public sealed virtual void ConvertUsing(Func`3<TSource, TDestination, TDestination> mappingFunction);
    public sealed virtual void ConvertUsing(Func`4<TSource, TDestination, ResolutionContext, TDestination> mappingFunction);
    public sealed virtual void ConvertUsing(ITypeConverter`2<TSource, TDestination> converter);
    public sealed virtual void ConvertUsing();
    public sealed virtual IMappingExpression`2<TSource, TDestination> BeforeMap(Action`2<TSource, TDestination> beforeFunction);
    public sealed virtual IMappingExpression`2<TSource, TDestination> BeforeMap(Action`3<TSource, TDestination, ResolutionContext> beforeFunction);
    public sealed virtual IMappingExpression`2<TSource, TDestination> BeforeMap();
    public sealed virtual IMappingExpression`2<TSource, TDestination> AfterMap(Action`2<TSource, TDestination> afterFunction);
    public sealed virtual IMappingExpression`2<TSource, TDestination> AfterMap(Action`3<TSource, TDestination, ResolutionContext> afterFunction);
    public sealed virtual IMappingExpression`2<TSource, TDestination> AfterMap();
    public sealed virtual IMappingExpression`2<TSource, TDestination> ConstructUsing(Func`2<TSource, TDestination> ctor);
    public sealed virtual IMappingExpression`2<TSource, TDestination> ConstructUsing(Func`3<TSource, ResolutionContext, TDestination> ctor);
    public sealed virtual IMappingExpression`2<TSource, TDestination> ConstructProjectionUsing(Expression`1<Func`2<TSource, TDestination>> ctor);
    private IMappingExpression`2<TSource, TDestination> ForDestinationMember(MemberInfo destinationProperty, Action`1<IMemberConfigurationExpression`3<TSource, TDestination, TMember>> memberOptions);
    public sealed virtual void As();
    public sealed virtual void As(Type typeOverride);
    public sealed virtual IMappingExpression`2<TSource, TDestination> ForCtorParam(string ctorParamName, Action`1<ICtorParamConfigurationExpression`1<TSource>> paramOptions);
    public sealed virtual IMappingExpression`2<TSource, TDestination> DisableCtorValidation();
    public sealed virtual void Configure(TypeMap typeMap);
    [CompilerGeneratedAttribute]
private bool <ForAllOtherMembers>b__31_0(MemberInfo m);
}
public class AutoMapper.Configuration.MemberConfigurationExpression`3 : object {
    private MemberInfo _destinationMember;
    private Type _sourceType;
    [CompilerGeneratedAttribute]
private List`1<Action`1<PropertyMap>> <PropertyMapActions>k__BackingField;
    protected List`1<Action`1<PropertyMap>> PropertyMapActions { get; }
    public MemberInfo DestinationMember { get; }
    public MemberConfigurationExpression`3(MemberInfo destinationMember, Type sourceType);
    [CompilerGeneratedAttribute]
protected List`1<Action`1<PropertyMap>> get_PropertyMapActions();
    public sealed virtual MemberInfo get_DestinationMember();
    public sealed virtual void NullSubstitute(object nullSubstitute);
    public sealed virtual void ResolveUsing();
    public sealed virtual void ResolveUsing(Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public sealed virtual void ResolveUsing(string sourceMemberName);
    public sealed virtual void ResolveUsing(IValueResolver`3<TSource, TDestination, TMember> valueResolver);
    public sealed virtual void ResolveUsing(IMemberValueResolver`4<TSource, TDestination, TSourceMember, TMember> valueResolver, Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public sealed virtual void ResolveUsing(Func`2<TSource, TResult> resolver);
    public sealed virtual void ResolveUsing(Func`3<TSource, TDestination, TResult> resolver);
    public sealed virtual void ResolveUsing(Func`4<TSource, TDestination, TMember, TResult> resolver);
    public sealed virtual void ResolveUsing(Func`5<TSource, TDestination, TMember, ResolutionContext, TResult> resolver);
    public sealed virtual void MapFrom(Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public sealed virtual void MapFrom(string sourceMember);
    public sealed virtual void UseValue(TValue value);
    public sealed virtual void Condition(Func`6<TSource, TDestination, TMember, TMember, ResolutionContext, bool> condition);
    public sealed virtual void Condition(Func`5<TSource, TDestination, TMember, TMember, bool> condition);
    public sealed virtual void Condition(Func`4<TSource, TDestination, TMember, bool> condition);
    public sealed virtual void Condition(Func`3<TSource, TDestination, bool> condition);
    public sealed virtual void Condition(Func`2<TSource, bool> condition);
    public sealed virtual void PreCondition(Func`2<TSource, bool> condition);
    public sealed virtual void PreCondition(Func`2<ResolutionContext, bool> condition);
    public sealed virtual void ExplicitExpansion();
    public sealed virtual void Ignore();
    public sealed virtual void AllowNull();
    public sealed virtual void UseDestinationValue();
    public sealed virtual void DoNotUseDestinationValue();
    public sealed virtual void SetMappingOrder(int mappingOrder);
    public sealed virtual void Configure(TypeMap typeMap);
}
[ExtensionAttribute]
internal static class AutoMapper.Configuration.PrimitiveExtensions : object {
    [ExtensionAttribute]
public static TValue GetOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static MethodInfo GetInheritedMethod(Type type, string name);
    [ExtensionAttribute]
public static MemberInfo GetFieldOrProperty(Type type, string name);
    private static MemberInfo GetMember(Type type, string name);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static Type GetTypeOfNullable(Type type);
    [ExtensionAttribute]
public static bool IsCollectionType(Type type);
    [ExtensionAttribute]
public static bool IsEnumerableType(Type type);
    [ExtensionAttribute]
public static bool IsQueryableType(Type type);
    [ExtensionAttribute]
public static bool IsListType(Type type);
    [ExtensionAttribute]
public static bool IsListOrDictionaryType(Type type);
    [ExtensionAttribute]
public static bool IsDictionaryType(Type type);
    [ExtensionAttribute]
public static bool ImplementsGenericInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static bool IsGenericType(Type type, Type genericType);
    [ExtensionAttribute]
public static Type GetIEnumerableType(Type type);
    [ExtensionAttribute]
public static Type GetDictionaryType(Type type);
    [ExtensionAttribute]
public static Type GetGenericInterface(Type type, Type genericInterface);
    [ExtensionAttribute]
public static Type GetGenericElementType(Type type);
}
public class AutoMapper.Configuration.ResolutionExpression : ResolutionExpression`1<object> {
    public ResolutionExpression(ValueResolverConfiguration config);
}
public class AutoMapper.Configuration.ResolutionExpression`1 : object {
    private ValueResolverConfiguration _config;
    private List`1<Action`1<PropertyMap>> _propertyMapActions;
    public ResolutionExpression`1(ValueResolverConfiguration config);
    public sealed virtual void FromMember(Expression`1<Func`2<TSource, object>> sourceMember);
    public sealed virtual void FromMember(string sourcePropertyName);
    public void Configure(PropertyMap propertyMap);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(PropertyMap pm);
}
public class AutoMapper.Configuration.SourceMappingExpression : object {
    private MemberInfo _sourceMember;
    private List`1<Action`1<SourceMemberConfig>> _sourceMemberActions;
    public SourceMappingExpression(MemberInfo sourceMember);
    public sealed virtual void Ignore();
    public void Configure(TypeMap typeMap);
}
public class AutoMapper.Configuration.SourceMemberConfig : object {
    private bool _ignored;
    [CompilerGeneratedAttribute]
private MemberInfo <SourceMember>k__BackingField;
    public MemberInfo SourceMember { get; private set; }
    public SourceMemberConfig(MemberInfo sourceMember);
    [CompilerGeneratedAttribute]
public MemberInfo get_SourceMember();
    [CompilerGeneratedAttribute]
private void set_SourceMember(MemberInfo value);
    public void Ignore();
    public bool IsIgnored();
}
public class AutoMapper.ConfigurationValidator : object {
    private IConfigurationProvider _config;
    public ConfigurationValidator(IConfigurationProvider config);
    public void AssertConfigurationIsValid(IEnumerable`1<TypeMap> typeMaps);
    private void DryRunTypeMap(ICollection`1<TypeMap> typeMapsChecked, TypePair types, TypeMap typeMap, ResolutionContext context);
    private void CheckElementMaps(ICollection`1<TypeMap> typeMapsChecked, TypePair types, ResolutionContext context);
    private void CheckPropertyMaps(ICollection`1<TypeMap> typeMapsChecked, TypeMap typeMap, ResolutionContext context);
}
public class AutoMapper.ConstructorMap : object {
    private IList`1<ConstructorParameterMap> _ctorParams;
    [CompilerGeneratedAttribute]
private ConstructorInfo <Ctor>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeMap <TypeMap>k__BackingField;
    private static IExpressionResultConverter[] ExpressionResultConverters;
    public ConstructorInfo Ctor { get; }
    public TypeMap TypeMap { get; }
    internal IEnumerable`1<ConstructorParameterMap> CtorParams { get; }
    public bool CanResolve { get; }
    public ConstructorMap(ConstructorInfo ctor, TypeMap typeMap);
    private static ConstructorMap();
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Ctor();
    [CompilerGeneratedAttribute]
public TypeMap get_TypeMap();
    internal IEnumerable`1<ConstructorParameterMap> get_CtorParams();
    public bool get_CanResolve();
    public Expression NewExpression(Expression instanceParameter);
    public Expression BuildExpression(TypeMapPlanBuilder builder);
    public void AddParameter(ParameterInfo parameter, MemberInfo[] resolvers, bool canResolve);
}
public class AutoMapper.ConstructorParameterMap : object {
    [CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo[] <SourceMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanResolve>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <CustomExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<object, ResolutionContext, object> <CustomValueResolver>k__BackingField;
    public ParameterInfo Parameter { get; }
    public MemberInfo[] SourceMembers { get; }
    public bool CanResolve { get; public set; }
    public bool DefaultValue { get; private set; }
    public LambdaExpression CustomExpression { get; public set; }
    public Func`3<object, ResolutionContext, object> CustomValueResolver { get; public set; }
    public Type DestinationType { get; }
    public ConstructorParameterMap(ParameterInfo parameter, MemberInfo[] sourceMembers, bool canResolve);
    [CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    [CompilerGeneratedAttribute]
public MemberInfo[] get_SourceMembers();
    [CompilerGeneratedAttribute]
public bool get_CanResolve();
    [CompilerGeneratedAttribute]
public void set_CanResolve(bool value);
    [CompilerGeneratedAttribute]
public bool get_DefaultValue();
    [CompilerGeneratedAttribute]
private void set_DefaultValue(bool value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_CustomExpression();
    [CompilerGeneratedAttribute]
public void set_CustomExpression(LambdaExpression value);
    [CompilerGeneratedAttribute]
public Func`3<object, ResolutionContext, object> get_CustomValueResolver();
    [CompilerGeneratedAttribute]
public void set_CustomValueResolver(Func`3<object, ResolutionContext, object> value);
    public Type get_DestinationType();
    public Expression CreateExpression(TypeMapPlanBuilder builder);
    private Expression ResolveSource(ParameterExpression sourceParameter, ParameterExpression contextParameter);
}
public class AutoMapper.CtorParamConfigurationExpression`1 : object {
    private string _ctorParamName;
    private List`1<Action`1<ConstructorParameterMap>> _ctorParamActions;
    public CtorParamConfigurationExpression`1(string ctorParamName);
    public sealed virtual void MapFrom(Expression`1<Func`2<TSource, TMember>> sourceMember);
    public sealed virtual void ResolveUsing(Func`2<TSource, object> resolver);
    public sealed virtual void ResolveUsing(Func`3<TSource, ResolutionContext, object> resolver);
    public void Configure(TypeMap typeMap);
    [CompilerGeneratedAttribute]
private bool <Configure>b__6_0(ConstructorParameterMap p);
}
public class AutoMapper.Execution.DelegateFactory : object {
    private LockingConcurrentDictionary`2<Type, LateBoundCtor> _ctorCache;
    public Expression`1<LateBoundMethod`2<object, TValue>> CreateGet(MethodInfo method);
    public LateBoundCtor CreateCtor(Type type);
    private static LateBoundCtor GenerateConstructor(Type type);
    public static Expression GenerateConstructorExpression(Type type);
    private static Expression[] CreateParameterExpressions(MethodInfo method, Expression instanceParameter, Expression argumentsParameter);
}
public interface AutoMapper.Execution.IProxyGenerator {
    public abstract virtual Type GetProxyType(Type interfaceType);
}
public class AutoMapper.Execution.LateBoundCtor : MulticastDelegate {
    public LateBoundCtor(object object, IntPtr method);
    public virtual object Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class AutoMapper.Execution.LateBoundFieldGet`2 : MulticastDelegate {
    public LateBoundFieldGet`2(object object, IntPtr method);
    public virtual TValue Invoke(TSource target);
    public virtual IAsyncResult BeginInvoke(TSource target, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
public class AutoMapper.Execution.LateBoundFieldSet`2 : MulticastDelegate {
    public LateBoundFieldSet`2(object object, IntPtr method);
    public virtual void Invoke(TSource target, TValue value);
    public virtual IAsyncResult BeginInvoke(TSource target, TValue value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class AutoMapper.Execution.LateBoundMethod`2 : MulticastDelegate {
    public LateBoundMethod`2(object object, IntPtr method);
    public virtual TValue Invoke(TSource target, Object[] arguments);
    public virtual IAsyncResult BeginInvoke(TSource target, Object[] arguments, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
public class AutoMapper.Execution.LateBoundParamsCtor : MulticastDelegate {
    public LateBoundParamsCtor(object object, IntPtr method);
    public virtual object Invoke(Object[] parameters);
    public virtual IAsyncResult BeginInvoke(Object[] parameters, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class AutoMapper.Execution.LateBoundPropertyGet`2 : MulticastDelegate {
    public LateBoundPropertyGet`2(object object, IntPtr method);
    public virtual TValue Invoke(TSource target);
    public virtual IAsyncResult BeginInvoke(TSource target, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
public class AutoMapper.Execution.LateBoundPropertySet`2 : MulticastDelegate {
    public LateBoundPropertySet`2(object object, IntPtr method);
    public virtual void Invoke(TSource target, TValue value);
    public virtual IAsyncResult BeginInvoke(TSource target, TValue value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class AutoMapper.Execution.LateBoundValueTypeFieldSet : MulticastDelegate {
    public LateBoundValueTypeFieldSet(object object, IntPtr method);
    public virtual void Invoke(Object& target, object value);
    public virtual IAsyncResult BeginInvoke(Object& target, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(Object& target, IAsyncResult result);
}
public class AutoMapper.Execution.LateBoundValueTypePropertySet : MulticastDelegate {
    public LateBoundValueTypePropertySet(object object, IntPtr method);
    public virtual void Invoke(Object& target, object value);
    public virtual IAsyncResult BeginInvoke(Object& target, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(Object& target, IAsyncResult result);
}
public class AutoMapper.Execution.PropertyEmitter : object {
    private static MethodInfo proxyBase_NotifyPropertyChanged;
    private FieldBuilder fieldBuilder;
    private MethodBuilder getterBuilder;
    private PropertyBuilder propertyBuilder;
    private MethodBuilder setterBuilder;
    public Type PropertyType { get; }
    public PropertyEmitter(TypeBuilder owner, string name, Type propertyType, FieldBuilder propertyChangedField);
    private static PropertyEmitter();
    public Type get_PropertyType();
    public MethodBuilder GetGetter(Type requiredType);
    public MethodBuilder GetSetter(Type requiredType);
}
public abstract class AutoMapper.Execution.ProxyBase : object {
    protected void NotifyPropertyChanged(PropertyChangedEventHandler handler, string method);
}
public class AutoMapper.Execution.ProxyGenerator : object {
    private static Byte[] privateKey;
    private static Byte[] privateKeyToken;
    private static MethodInfo delegate_Combine;
    private static MethodInfo delegate_Remove;
    private static EventInfo iNotifyPropertyChanged_PropertyChanged;
    private static ConstructorInfo proxyBase_ctor;
    private static ModuleBuilder proxyModule;
    private static LockingConcurrentDictionary`2<Type, Type> proxyTypes;
    private static ProxyGenerator();
    private static ModuleBuilder CreateProxyModule();
    private static Type EmitProxy(Type interfaceType);
    public sealed virtual Type GetProxyType(Type interfaceType);
    private static Byte[] StringToByteArray(string hex);
}
public class AutoMapper.Execution.TypeMapPlanBuilder : object {
    private static Expression`1<Func`2<IRuntimeMapper, ResolutionContext>> CreateContext;
    private static Expression`1<Func`1<AutoMapperMappingException>> CtorExpression;
    private static Expression`1<Action`1<ResolutionContext>> IncTypeDepthInfo;
    private static Expression`1<Action`1<ResolutionContext>> DecTypeDepthInfo;
    private static Expression`1<Func`2<ResolutionContext, int>> GetTypeDepthInfo;
    private IConfigurationProvider _configurationProvider;
    private TypeMap _typeMap;
    private TypeMapRegistry _typeMapRegistry;
    private ParameterExpression _source;
    private ParameterExpression _initialDestination;
    private ParameterExpression _context;
    private ParameterExpression _destination;
    public ParameterExpression Source { get; }
    public ParameterExpression Context { get; }
    public TypeMapPlanBuilder(IConfigurationProvider configurationProvider, TypeMapRegistry typeMapRegistry, TypeMap typeMap);
    private static TypeMapPlanBuilder();
    public ParameterExpression get_Source();
    public ParameterExpression get_Context();
    public LambdaExpression CreateMapperLambda();
    private LambdaExpression TypeConverterMapper();
    public static ConditionalExpression CheckContext(TypeMap typeMap, Expression context);
    private Expression CreateDestinationFunc(Boolean& constructorMapping);
    private Expression CreateAssignmentFunc(Expression destinationFunc, bool constructorMapping);
    private Expression CreateMapperFunc(Expression assignmentFunc);
    private Expression CreateNewDestinationFunc(Boolean& constructorMapping);
    private Expression TryPropertyMap(PropertyMap propertyMap);
    private Expression CreatePropertyMapFunc(PropertyMap propertyMap);
    private Expression SetMap(PropertyMap propertyMap, Expression valueResolverExpression, Expression destinationValueExpression);
    private Expression BuildValueResolverFunc(PropertyMap propertyMap, Expression destValueExpr);
    public Expression MapExpression(TypePair typePair, Expression sourceParameter, PropertyMap propertyMap, Expression destinationParameter);
    public static Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, TypePair typePair, Expression sourceParameter, Expression contextParameter, PropertyMap propertyMap, Expression destinationParameter);
    private static Expression ContextMap(TypePair typePair, Expression sourceParameter, Expression contextParameter, Expression destinationParameter);
    [CompilerGeneratedAttribute]
private Expression <CreateAssignmentFunc>b__21_0(LambdaExpression afterMapAction);
}
[ExtensionAttribute]
internal static class AutoMapper.ExpressionExtensions : object {
    public static Expression ForEach(Expression collection, ParameterExpression loopVar, Expression loopContent);
    public static Expression ForEachArrayItem(Expression array, Func`2<Expression, Expression> body);
    public static Expression For(Expression count, Func`2<Expression, Expression> body);
    public static Expression ToObject(Expression expression);
    public static Expression ToType(Expression expression, Type type);
    public static Expression ConsoleWriteLine(string value, Expression[] values);
    [ExtensionAttribute]
public static Expression ReplaceParameters(LambdaExpression exp, Expression[] replace);
    [ExtensionAttribute]
public static Expression ConvertReplaceParameters(LambdaExpression exp, Expression[] replace);
    [ExtensionAttribute]
public static Expression Replace(Expression exp, Expression old, Expression replace);
    [ExtensionAttribute]
public static LambdaExpression Concat(LambdaExpression expr, LambdaExpression concat);
    [ExtensionAttribute]
public static Expression IfNotNull(Expression expression, Type destinationType);
    [ExtensionAttribute]
public static Expression RemoveIfNotNull(Expression expression, Expression[] expressions);
    [ExtensionAttribute]
public static Expression IfNullElse(Expression expression, Expression[] ifElse);
}
public interface AutoMapper.IConfigurationProvider {
    public Func`2<Type, object> ServiceCtor { get; }
    public ProfileMap Configuration { get; }
    public bool EnableNullPropagationForQueryMapping { get; }
    public IExpressionBuilder ExpressionBuilder { get; }
    public abstract virtual TypeMap[] GetAllTypeMaps();
    public abstract virtual TypeMap FindTypeMapFor(Type sourceType, Type destinationType);
    public abstract virtual TypeMap FindTypeMapFor(TypePair typePair);
    public abstract virtual TypeMap FindTypeMapFor();
    public abstract virtual TypeMap ResolveTypeMap(Type sourceType, Type destinationType);
    public abstract virtual TypeMap ResolveTypeMap(TypePair typePair);
    public abstract virtual void AssertConfigurationIsValid();
    public abstract virtual void AssertConfigurationIsValid(TypeMap typeMap);
    public abstract virtual void AssertConfigurationIsValid(string profileName);
    public abstract virtual void AssertConfigurationIsValid();
    public abstract virtual IEnumerable`1<IObjectMapper> GetMappers();
    public abstract virtual Func`2<Type, object> get_ServiceCtor();
    public abstract virtual ProfileMap get_Configuration();
    public abstract virtual bool get_EnableNullPropagationForQueryMapping();
    public abstract virtual IExpressionBuilder get_ExpressionBuilder();
    public abstract virtual IMapper CreateMapper();
    public abstract virtual IMapper CreateMapper(Func`2<Type, object> serviceCtor);
    public abstract virtual Func`4<TSource, TDestination, ResolutionContext, TDestination> GetMapperFunc(TypePair types);
    public abstract virtual void CompileMappings();
    public abstract virtual Delegate GetMapperFunc(MapRequest request);
    public abstract virtual Func`4<object, object, ResolutionContext, object> GetUntypedMapperFunc(MapRequest mapRequest);
}
public interface AutoMapper.ICtorParamConfigurationExpression`1 {
    public abstract virtual void MapFrom(Expression`1<Func`2<TSource, TMember>> sourceMember);
    public abstract virtual void ResolveUsing(Func`2<TSource, object> resolver);
    public abstract virtual void ResolveUsing(Func`3<TSource, ResolutionContext, object> resolver);
}
[AttributeUsageAttribute("384")]
public class AutoMapper.IgnoreMapAttribute : Attribute {
}
public interface AutoMapper.IMapper {
    public IConfigurationProvider ConfigurationProvider { get; }
    public Func`2<Type, object> ServiceCtor { get; }
    public abstract virtual TDestination Map(object source);
    public abstract virtual TDestination Map(object source, Action`1<IMappingOperationOptions> opts);
    public abstract virtual TDestination Map(TSource source);
    public abstract virtual TDestination Map(TSource source, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    public abstract virtual TDestination Map(TSource source, TDestination destination);
    public abstract virtual TDestination Map(TSource source, TDestination destination, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    public abstract virtual object Map(object source, Type sourceType, Type destinationType);
    public abstract virtual object Map(object source, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions> opts);
    public abstract virtual object Map(object source, object destination, Type sourceType, Type destinationType);
    public abstract virtual object Map(object source, object destination, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions> opts);
    public abstract virtual IConfigurationProvider get_ConfigurationProvider();
    public abstract virtual Func`2<Type, object> get_ServiceCtor();
}
public interface AutoMapper.IMapperConfigurationExpression {
    public Nullable`1<bool> CreateMissingTypeMaps { get; public set; }
    public abstract virtual Nullable`1<bool> get_CreateMissingTypeMaps();
    public abstract virtual void set_CreateMissingTypeMaps(Nullable`1<bool> value);
    public abstract virtual void AddProfile(Profile profile);
    public abstract virtual void AddProfile();
    public abstract virtual void AddProfile(Type profileType);
    public abstract virtual void AddProfiles(IEnumerable`1<Assembly> assembliesToScan);
    public abstract virtual void AddProfiles(Assembly[] assembliesToScan);
    public abstract virtual void AddProfiles(IEnumerable`1<string> assemblyNamesToScan);
    public abstract virtual void AddProfiles(String[] assemblyNamesToScan);
    public abstract virtual void AddProfiles(IEnumerable`1<Type> typesFromAssembliesContainingProfiles);
    public abstract virtual void AddProfiles(Type[] typesFromAssembliesContainingProfiles);
    public abstract virtual void ConstructServicesUsing(Func`2<Type, object> constructor);
    public abstract virtual void CreateProfile(string profileName, Action`1<IProfileExpression> config);
}
public interface AutoMapper.IMappingAction`2 {
    public abstract virtual void Process(TSource source, TDestination destination);
}
public interface AutoMapper.IMappingExpression {
    public abstract virtual IMappingExpression PreserveReferences();
    public abstract virtual IMappingExpression ForCtorParam(string ctorParamName, Action`1<ICtorParamConfigurationExpression`1<object>> paramOptions);
    public abstract virtual IMappingExpression ReverseMap();
    public abstract virtual IMappingExpression Substitute(Func`2<object, object> substituteFunc);
    public abstract virtual IMappingExpression ConstructUsingServiceLocator();
    public abstract virtual IMappingExpression MaxDepth(int depth);
    public abstract virtual IMappingExpression ConstructProjectionUsing(LambdaExpression ctor);
    public abstract virtual IMappingExpression ConstructUsing(Func`3<object, ResolutionContext, object> ctor);
    public abstract virtual IMappingExpression ConstructUsing(Func`2<object, object> ctor);
    public abstract virtual void ProjectUsing(Expression`1<Func`2<object, object>> projectionExpression);
    public abstract virtual void ForAllMembers(Action`1<IMemberConfigurationExpression> memberOptions);
    public abstract virtual void ForAllOtherMembers(Action`1<IMemberConfigurationExpression> memberOptions);
    public abstract virtual IMappingExpression ForSourceMember(string sourceMemberName, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public abstract virtual void ConvertUsing();
    public abstract virtual void ConvertUsing(Type typeConverterType);
    public abstract virtual void As(Type typeOverride);
    public abstract virtual IMappingExpression ForMember(string name, Action`1<IMemberConfigurationExpression> memberOptions);
    public abstract virtual IMappingExpression Include(Type derivedSourceType, Type derivedDestinationType);
    public abstract virtual IMappingExpression IgnoreAllPropertiesWithAnInaccessibleSetter();
    public abstract virtual IMappingExpression IgnoreAllSourcePropertiesWithAnInaccessibleSetter();
    public abstract virtual IMappingExpression IncludeBase(Type sourceBase, Type destinationBase);
    public abstract virtual IMappingExpression BeforeMap(Action`2<object, object> beforeFunction);
    public abstract virtual IMappingExpression BeforeMap();
    public abstract virtual IMappingExpression AfterMap(Action`2<object, object> afterFunction);
    public abstract virtual IMappingExpression AfterMap();
}
public interface AutoMapper.IMappingExpression`2 {
    public abstract virtual IMappingExpression`2<TSource, TDestination> PreserveReferences();
    public abstract virtual void ForAllOtherMembers(Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public abstract virtual IMappingExpression`2<TSource, TDestination> ForMember(Expression`1<Func`2<TDestination, TMember>> destinationMember, Action`1<IMemberConfigurationExpression`3<TSource, TDestination, TMember>> memberOptions);
    public abstract virtual IMappingExpression`2<TSource, TDestination> ForMember(string name, Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public abstract virtual void ForAllMembers(Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public abstract virtual IMappingExpression`2<TSource, TDestination> IgnoreAllPropertiesWithAnInaccessibleSetter();
    public abstract virtual IMappingExpression`2<TSource, TDestination> IgnoreAllSourcePropertiesWithAnInaccessibleSetter();
    public abstract virtual IMappingExpression`2<TSource, TDestination> Include();
    public abstract virtual IMappingExpression`2<TSource, TDestination> IncludeBase();
    public abstract virtual IMappingExpression`2<TSource, TDestination> Include(Type derivedSourceType, Type derivedDestinationType);
    public abstract virtual void ProjectUsing(Expression`1<Func`2<TSource, TDestination>> projectionExpression);
    public abstract virtual void ConvertUsing(Func`2<TSource, TDestination> mappingFunction);
    public abstract virtual void ConvertUsing(Func`3<TSource, TDestination, TDestination> mappingFunction);
    public abstract virtual void ConvertUsing(Func`4<TSource, TDestination, ResolutionContext, TDestination> mappingFunction);
    public abstract virtual void ConvertUsing(ITypeConverter`2<TSource, TDestination> converter);
    public abstract virtual void ConvertUsing();
    public abstract virtual IMappingExpression`2<TSource, TDestination> BeforeMap(Action`2<TSource, TDestination> beforeFunction);
    public abstract virtual IMappingExpression`2<TSource, TDestination> BeforeMap(Action`3<TSource, TDestination, ResolutionContext> beforeFunction);
    public abstract virtual IMappingExpression`2<TSource, TDestination> BeforeMap();
    public abstract virtual IMappingExpression`2<TSource, TDestination> AfterMap(Action`2<TSource, TDestination> afterFunction);
    public abstract virtual IMappingExpression`2<TSource, TDestination> AfterMap(Action`3<TSource, TDestination, ResolutionContext> afterFunction);
    public abstract virtual IMappingExpression`2<TSource, TDestination> AfterMap();
    public abstract virtual IMappingExpression`2<TSource, TDestination> ConstructUsing(Func`2<TSource, TDestination> ctor);
    public abstract virtual IMappingExpression`2<TSource, TDestination> ConstructProjectionUsing(Expression`1<Func`2<TSource, TDestination>> ctor);
    public abstract virtual IMappingExpression`2<TSource, TDestination> ConstructUsing(Func`3<TSource, ResolutionContext, TDestination> ctor);
    public abstract virtual void As();
    public abstract virtual IMappingExpression`2<TSource, TDestination> MaxDepth(int depth);
    public abstract virtual IMappingExpression`2<TSource, TDestination> ConstructUsingServiceLocator();
    public abstract virtual IMappingExpression`2<TDestination, TSource> ReverseMap();
    public abstract virtual IMappingExpression`2<TSource, TDestination> ForSourceMember(Expression`1<Func`2<TSource, object>> sourceMember, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public abstract virtual IMappingExpression`2<TSource, TDestination> ForSourceMember(string sourceMemberName, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public abstract virtual IMappingExpression`2<TSource, TDestination> Substitute(Func`2<TSource, TSubstitute> substituteFunc);
    public abstract virtual IMappingExpression`2<TSource, TDestination> ForCtorParam(string ctorParamName, Action`1<ICtorParamConfigurationExpression`1<TSource>> paramOptions);
    public abstract virtual IMappingExpression`2<TSource, TDestination> DisableCtorValidation();
}
public interface AutoMapper.IMappingOperationOptions {
    public Func`2<Type, object> ServiceCtor { get; }
    public IDictionary`2<string, object> Items { get; }
    public abstract virtual T CreateInstance();
    public abstract virtual Func`2<Type, object> get_ServiceCtor();
    public abstract virtual void ConstructServicesUsing(Func`2<Type, object> constructor);
    public abstract virtual IDictionary`2<string, object> get_Items();
    public abstract virtual void BeforeMap(Action`2<object, object> beforeFunction);
    public abstract virtual void AfterMap(Action`2<object, object> afterFunction);
}
public interface AutoMapper.IMappingOperationOptions`2 {
    public abstract virtual void BeforeMap(Action`2<TSource, TDestination> beforeFunction);
    public abstract virtual void AfterMap(Action`2<TSource, TDestination> afterFunction);
}
public interface AutoMapper.IMemberConfigurationExpression {
    public abstract virtual void ResolveUsing(Type valueResolverType);
    public abstract virtual void ResolveUsing(Type valueResolverType, string memberName);
    public abstract virtual void ResolveUsing(IMemberValueResolver`4<TSource, TDestination, TSourceMember, TDestMember> valueResolver, string memberName);
}
public interface AutoMapper.IMemberConfigurationExpression`3 {
    public MemberInfo DestinationMember { get; }
    public abstract virtual void NullSubstitute(object nullSubstitute);
    public abstract virtual void ResolveUsing();
    public abstract virtual void ResolveUsing(Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public abstract virtual void ResolveUsing(string sourceMemberName);
    public abstract virtual void ResolveUsing(IValueResolver`3<TSource, TDestination, TMember> valueResolver);
    public abstract virtual void ResolveUsing(IMemberValueResolver`4<TSource, TDestination, TSourceMember, TMember> valueResolver, Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public abstract virtual void ResolveUsing(Func`2<TSource, TResult> resolver);
    public abstract virtual void ResolveUsing(Func`3<TSource, TDestination, TResult> resolver);
    public abstract virtual void ResolveUsing(Func`4<TSource, TDestination, TMember, TResult> resolver);
    public abstract virtual void ResolveUsing(Func`5<TSource, TDestination, TMember, ResolutionContext, TResult> resolver);
    public abstract virtual void MapFrom(Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public abstract virtual void MapFrom(string property);
    public abstract virtual void Ignore();
    public abstract virtual void AllowNull();
    public abstract virtual void SetMappingOrder(int mappingOrder);
    public abstract virtual void UseDestinationValue();
    public abstract virtual void DoNotUseDestinationValue();
    public abstract virtual void UseValue(TValue value);
    public abstract virtual void Condition(Func`6<TSource, TDestination, TMember, TMember, ResolutionContext, bool> condition);
    public abstract virtual void Condition(Func`5<TSource, TDestination, TMember, TMember, bool> condition);
    public abstract virtual void Condition(Func`4<TSource, TDestination, TMember, bool> condition);
    public abstract virtual void Condition(Func`3<TSource, TDestination, bool> condition);
    public abstract virtual void Condition(Func`2<TSource, bool> condition);
    public abstract virtual void PreCondition(Func`2<TSource, bool> condition);
    public abstract virtual void PreCondition(Func`2<ResolutionContext, bool> condition);
    public abstract virtual void ExplicitExpansion();
    public abstract virtual MemberInfo get_DestinationMember();
}
public interface AutoMapper.IMemberValueResolver`4 {
    public abstract virtual TDestMember Resolve(TSource source, TDestination destination, TSourceMember sourceMember, TDestMember destMember, ResolutionContext context);
}
public interface AutoMapper.INamingConvention {
    public Regex SplittingExpression { get; }
    public string SeparatorCharacter { get; }
    public abstract virtual Regex get_SplittingExpression();
    public abstract virtual string get_SeparatorCharacter();
    public abstract virtual string ReplaceValue(Match match);
}
public interface AutoMapper.IObjectMapper {
    public abstract virtual bool IsMatch(TypePair context);
    public abstract virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public interface AutoMapper.IProfileExpression {
    public Nullable`1<bool> AllowNullDestinationValues { get; public set; }
    public Nullable`1<bool> AllowNullCollections { get; public set; }
    public Nullable`1<bool> EnableNullPropagationForQueryMapping { get; public set; }
    public INamingConvention SourceMemberNamingConvention { get; public set; }
    public INamingConvention DestinationMemberNamingConvention { get; public set; }
    public Func`2<PropertyInfo, bool> ShouldMapProperty { get; public set; }
    public Func`2<FieldInfo, bool> ShouldMapField { get; public set; }
    public string ProfileName { get; }
    public abstract virtual void DisableConstructorMapping();
    public abstract virtual IMappingExpression`2<TSource, TDestination> CreateMap();
    public abstract virtual IMappingExpression`2<TSource, TDestination> CreateMap(MemberList memberList);
    public abstract virtual IMappingExpression CreateMap(Type sourceType, Type destinationType);
    public abstract virtual IMappingExpression CreateMap(Type sourceType, Type destinationType, MemberList memberList);
    public abstract virtual void ClearPrefixes();
    public abstract virtual void RecognizePrefixes(String[] prefixes);
    public abstract virtual void RecognizePostfixes(String[] postfixes);
    public abstract virtual void RecognizeAlias(string original, string alias);
    public abstract virtual void ReplaceMemberName(string original, string newValue);
    public abstract virtual void RecognizeDestinationPrefixes(String[] prefixes);
    public abstract virtual void RecognizeDestinationPostfixes(String[] postfixes);
    public abstract virtual void AddGlobalIgnore(string propertyNameStartingWith);
    public abstract virtual Nullable`1<bool> get_AllowNullDestinationValues();
    public abstract virtual void set_AllowNullDestinationValues(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_AllowNullCollections();
    public abstract virtual void set_AllowNullCollections(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_EnableNullPropagationForQueryMapping();
    public abstract virtual void set_EnableNullPropagationForQueryMapping(Nullable`1<bool> value);
    public abstract virtual INamingConvention get_SourceMemberNamingConvention();
    public abstract virtual void set_SourceMemberNamingConvention(INamingConvention value);
    public abstract virtual INamingConvention get_DestinationMemberNamingConvention();
    public abstract virtual void set_DestinationMemberNamingConvention(INamingConvention value);
    public abstract virtual void ForAllMaps(Action`2<TypeMap, IMappingExpression> configuration);
    public abstract virtual void ForAllPropertyMaps(Func`2<PropertyMap, bool> condition, Action`2<PropertyMap, IMemberConfigurationExpression> memberOptions);
    public abstract virtual Func`2<PropertyInfo, bool> get_ShouldMapProperty();
    public abstract virtual void set_ShouldMapProperty(Func`2<PropertyInfo, bool> value);
    public abstract virtual Func`2<FieldInfo, bool> get_ShouldMapField();
    public abstract virtual void set_ShouldMapField(Func`2<FieldInfo, bool> value);
    public abstract virtual string get_ProfileName();
    public abstract virtual IMemberConfiguration AddMemberConfiguration();
    public abstract virtual IConditionalObjectMapper AddConditionalObjectMapper();
    public abstract virtual void IncludeSourceExtensionMethods(Type type);
}
public interface AutoMapper.IResolutionExpression {
    public abstract virtual void FromMember(string sourcePropertyName);
}
public interface AutoMapper.IResolutionExpression`1 {
    public abstract virtual void FromMember(Expression`1<Func`2<TSource, object>> sourceMember);
}
public interface AutoMapper.IResolverConfigurationExpression`1 {
    public abstract virtual void FromMember(Expression`1<Func`2<TSource, object>> sourceMember);
    public abstract virtual void FromMember(string sourcePropertyName);
}
public interface AutoMapper.IRuntimeMapper {
    public ResolutionContext DefaultContext { get; }
    public abstract virtual ResolutionContext get_DefaultContext();
    public abstract virtual object Map(object source, object destination, Type sourceType, Type destinationType, ResolutionContext parent);
    public abstract virtual TDestination Map(TSource source, TDestination destination, ResolutionContext parent);
    public abstract virtual TDestination CreateObject();
}
public interface AutoMapper.ISourceMemberConfigurationExpression {
    public abstract virtual void Ignore();
}
public interface AutoMapper.ITypeConverter`2 {
    public abstract virtual TDestination Convert(TSource source, TDestination destination, ResolutionContext context);
}
public interface AutoMapper.IValueResolver`3 {
    public abstract virtual TDestMember Resolve(TSource source, TDestination destination, TDestMember destMember, ResolutionContext context);
}
internal class AutoMapper.LockingConcurrentDictionary`2 : ValueType {
    private ConcurrentDictionary`2<TKey, Lazy`1<TValue>> _dictionary;
    private Func`2<TKey, Lazy`1<TValue>> _valueFactory;
    public LockingConcurrentDictionary`2(Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAdd(TKey key);
}
public class AutoMapper.LowerUnderscoreNamingConvention : object {
    [CompilerGeneratedAttribute]
private Regex <SplittingExpression>k__BackingField;
    public Regex SplittingExpression { get; }
    public string SeparatorCharacter { get; }
    [CompilerGeneratedAttribute]
public sealed virtual Regex get_SplittingExpression();
    public sealed virtual string get_SeparatorCharacter();
    public sealed virtual string ReplaceValue(Match match);
}
public class AutoMapper.Mapper : object {
    private static string InvalidOperationMessage;
    private static IConfigurationProvider _configuration;
    private static IMapper _instance;
    private IConfigurationProvider _configurationProvider;
    private Func`2<Type, object> _serviceCtor;
    private ResolutionContext _defaultContext;
    public static IConfigurationProvider Configuration { get; private set; }
    public static IMapper Instance { get; private set; }
    public ResolutionContext DefaultContext { get; }
    private Func`2<Type, object> AutoMapper.IMapper.ServiceCtor { get; }
    private IConfigurationProvider AutoMapper.IMapper.ConfigurationProvider { get; }
    public Mapper(IConfigurationProvider configurationProvider);
    public Mapper(IConfigurationProvider configurationProvider, Func`2<Type, object> serviceCtor);
    public static IConfigurationProvider get_Configuration();
    private static void set_Configuration(IConfigurationProvider value);
    public static IMapper get_Instance();
    private static void set_Instance(IMapper value);
    public static void Initialize(Action`1<IMapperConfigurationExpression> config);
    public static void Initialize(MapperConfigurationExpression config);
    public static TDestination Map(object source);
    public static TDestination Map(object source, Action`1<IMappingOperationOptions> opts);
    public static TDestination Map(TSource source);
    public static TDestination Map(TSource source, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    public static TDestination Map(TSource source, TDestination destination);
    public static TDestination Map(TSource source, TDestination destination, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    public static object Map(object source, Type sourceType, Type destinationType);
    public static object Map(object source, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions> opts);
    public static object Map(object source, object destination, Type sourceType, Type destinationType);
    public static object Map(object source, object destination, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions> opts);
    public static void AssertConfigurationIsValid();
    public sealed virtual ResolutionContext get_DefaultContext();
    private sealed virtual override Func`2<Type, object> AutoMapper.IMapper.get_ServiceCtor();
    private sealed virtual override IConfigurationProvider AutoMapper.IMapper.get_ConfigurationProvider();
    private sealed virtual override TDestination AutoMapper.IMapper.Map(object source);
    private sealed virtual override TDestination AutoMapper.IMapper.Map(object source, Action`1<IMappingOperationOptions> opts);
    private sealed virtual override TDestination AutoMapper.IMapper.Map(TSource source);
    private sealed virtual override TDestination AutoMapper.IMapper.Map(TSource source, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    private sealed virtual override TDestination AutoMapper.IMapper.Map(TSource source, TDestination destination);
    private sealed virtual override TDestination AutoMapper.IMapper.Map(TSource source, TDestination destination, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    private sealed virtual override object AutoMapper.IMapper.Map(object source, Type sourceType, Type destinationType);
    private sealed virtual override object AutoMapper.IMapper.Map(object source, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions> opts);
    private sealed virtual override object AutoMapper.IMapper.Map(object source, object destination, Type sourceType, Type destinationType);
    private sealed virtual override object AutoMapper.IMapper.Map(object source, object destination, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions> opts);
    private sealed virtual override object AutoMapper.IRuntimeMapper.Map(object source, object destination, Type sourceType, Type destinationType, ResolutionContext context);
    private sealed virtual override TDestination AutoMapper.IRuntimeMapper.Map(TSource source, TDestination destination, ResolutionContext context);
    private sealed virtual override TDestination AutoMapper.IRuntimeMapper.CreateObject();
}
public class AutoMapper.MapperConfiguration : object {
    private IEnumerable`1<IObjectMapper> _mappers;
    private TypeMapRegistry _typeMapRegistry;
    private Dictionary`2<TypePair, TypeMap> _typeMapPlanCache;
    private LockingConcurrentDictionary`2<MapRequest, MapperFuncs> _mapPlanCache;
    private ConfigurationValidator _validator;
    [CompilerGeneratedAttribute]
private IExpressionBuilder <ExpressionBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Type, object> <ServiceCtor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableNullPropagationForQueryMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private ProfileMap <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProfileMap> <Profiles>k__BackingField;
    public IExpressionBuilder ExpressionBuilder { get; }
    public Func`2<Type, object> ServiceCtor { get; }
    public bool EnableNullPropagationForQueryMapping { get; }
    public ProfileMap Configuration { get; }
    public IEnumerable`1<ProfileMap> Profiles { get; }
    public MapperConfiguration(MapperConfigurationExpression configurationExpression);
    public MapperConfiguration(MapperConfigurationExpression configurationExpression, IEnumerable`1<IObjectMapper> mappers);
    public MapperConfiguration(Action`1<IMapperConfigurationExpression> configure);
    public MapperConfiguration(Action`1<IMapperConfigurationExpression> configure, IEnumerable`1<IObjectMapper> mappers);
    [CompilerGeneratedAttribute]
public sealed virtual IExpressionBuilder get_ExpressionBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Type, object> get_ServiceCtor();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableNullPropagationForQueryMapping();
    [CompilerGeneratedAttribute]
public sealed virtual ProfileMap get_Configuration();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ProfileMap> get_Profiles();
    public sealed virtual Func`4<TSource, TDestination, ResolutionContext, TDestination> GetMapperFunc(TypePair types);
    public sealed virtual void CompileMappings();
    public sealed virtual Delegate GetMapperFunc(MapRequest mapRequest);
    public sealed virtual Func`4<object, object, ResolutionContext, object> GetUntypedMapperFunc(MapRequest mapRequest);
    private MapperFuncs CreateMapperFuncs(MapRequest mapRequest);
    public sealed virtual TypeMap[] GetAllTypeMaps();
    public sealed virtual TypeMap FindTypeMapFor(Type sourceType, Type destinationType);
    public sealed virtual TypeMap FindTypeMapFor();
    public sealed virtual TypeMap FindTypeMapFor(TypePair typePair);
    public sealed virtual TypeMap ResolveTypeMap(Type sourceType, Type destinationType);
    public sealed virtual TypeMap ResolveTypeMap(TypePair typePair);
    private TypeMap GetTypeMap(TypePair initialTypes);
    public sealed virtual void AssertConfigurationIsValid(TypeMap typeMap);
    public sealed virtual void AssertConfigurationIsValid(string profileName);
    public sealed virtual void AssertConfigurationIsValid();
    public sealed virtual void AssertConfigurationIsValid();
    public sealed virtual IMapper CreateMapper();
    public sealed virtual IMapper CreateMapper(Func`2<Type, object> serviceCtor);
    public sealed virtual IEnumerable`1<IObjectMapper> GetMappers();
    private static MapperConfigurationExpression Build(Action`1<IMapperConfigurationExpression> configure);
    private void Seal();
    [IteratorStateMachineAttribute("AutoMapper.MapperConfiguration/<GetDerivedTypeMaps>d__45")]
private IEnumerable`1<TypeMap> GetDerivedTypeMaps(TypeMap typeMap);
    private bool CoveredByObjectMap(TypePair typePair);
    private TypeMap FindConventionTypeMapFor(TypePair typePair);
    private TypeMap FindClosedGenericTypeMapFor(TypePair typePair, TypePair requestedTypes);
    [CompilerGeneratedAttribute]
private bool <Seal>b__44_1(Tuple`2<TypePair, TypeMap> derivedMap);
}
[ExtensionAttribute]
internal static class AutoMapper.Mappers.ArrayExtensions : object {
    [ExtensionAttribute]
public static Int32[] GetLengths(Array array);
}
public class AutoMapper.Mappers.ArrayMapper : object {
    private static MethodInfo MapMethodInfo;
    private static ArrayMapper();
    public static TDestination[] Map(IEnumerable`1<TSource> source, ResolutionContext context, Func`3<TSource, ResolutionContext, TDestination> newItemFunc);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.AssignableMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.CollectionMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
[ExtensionAttribute]
public static class AutoMapper.Mappers.CollectionMapperExtensions : object {
    [ExtensionAttribute]
internal static Expression MapCollectionExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression, Func`2<Expression, Expression> conditionalExpression, Type ifInterfaceType, MapItem mapItem);
    internal static Delegate Constructor(Type type);
    [ExtensionAttribute]
internal static Expression NewExpr(Type baseType, Type ifInterfaceType);
    [ExtensionAttribute]
internal static Expression MapItemExpr(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Type sourceType, Type destType, Expression contextParam, ParameterExpression& itemParam);
    [ExtensionAttribute]
internal static Expression MapKeyPairValueExpr(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Type sourceType, Type destType, Expression contextParam, ParameterExpression& itemParam);
    internal static BinaryExpression IfNotNull(Expression destExpression);
}
public class AutoMapper.Mappers.ConditionalObjectMapper : object {
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<TypePair, bool>> <Conventions>k__BackingField;
    public ICollection`1<Func`2<TypePair, bool>> Conventions { get; }
    public sealed virtual bool IsMatch(TypePair typePair);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Func`2<TypePair, bool>> get_Conventions();
}
[ExtensionAttribute]
public static class AutoMapper.Mappers.ConventionGeneratorExtensions : object {
    [ExtensionAttribute]
public static IConditionalObjectMapper Where(IConditionalObjectMapper self, Func`3<Type, Type, bool> condition);
}
public class AutoMapper.Mappers.ConvertMapper : object {
    private Dictionary`2<TypePair, Lazy`1<LambdaExpression>> _converters;
    private static Dictionary`2<TypePair, Lazy`1<LambdaExpression>> GetConverters();
    private static LambdaExpression ConvertExpression(Type sourceType, Type destinationType);
    private static Type UnderlyingType(Type type, Boolean& nullable);
    public sealed virtual bool IsMatch(TypePair types);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.DictionaryMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public enum AutoMapper.Mappers.ElementTypeFlags : Enum {
    public int value__;
    public static ElementTypeFlags None;
    public static ElementTypeFlags BreakKeyValuePair;
}
public class AutoMapper.Mappers.EnumerableMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
    private static Expression IfEditableList(Expression dest);
}
public class AutoMapper.Mappers.EnumerableToDictionaryMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.EnumToEnumMapper : object {
    private static MethodInfo MapMethodInfo;
    private static EnumToEnumMapper();
    public static TDestination Map(TSource source);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.EnumToUnderlyingTypeMapper : object {
    private static MethodInfo MapMethodInfo;
    private static EnumToUnderlyingTypeMapper();
    public static TDestination Map(TSource source);
    internal static bool EnumToNullableTypeMapping(TypePair context);
    private static TDestination ConvertEnumToNullableType(TSource source);
    public sealed virtual bool IsMatch(TypePair context);
    private static bool EnumToUnderlyingTypeMapping(TypePair context, Boolean& toEnum);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.ExplicitConversionOperatorMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    private static MethodInfo GetExplicitConversionOperator(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.ExpressionMapper : object {
    private static MethodInfo MapMethodInfo;
    private static ExpressionMapper();
    public static TDestination Map(TSource expression, ResolutionContext context);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.FlagsEnumMapper : object {
    private static MethodInfo MapMethodInfo;
    private static FlagsEnumMapper();
    public static TDestination Map(TSource source, Func`1<TDestination> ifNull);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.FromDynamicMapper : object {
    private static MethodInfo MapMethodInfo;
    private static FromDynamicMapper();
    public static TDestination Map(TSource source, TDestination destination, ResolutionContext context, Func`1<TDestination> ifNull);
    private static object GetDynamically(MemberInfo member, object target);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.FromStringDictionaryMapper : object {
    private static MethodInfo MapMethodInfo;
    private static FromStringDictionaryMapper();
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
    private static TDestination Map(IDictionary`2<string, object> source, TDestination destination, ResolutionContext context);
}
public class AutoMapper.Mappers.HashSetMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
    private static bool IsSetType(Type type);
}
public interface AutoMapper.Mappers.IConditionalObjectMapper {
    public ICollection`1<Func`2<TypePair, bool>> Conventions { get; }
    public abstract virtual ICollection`1<Func`2<TypePair, bool>> get_Conventions();
    public abstract virtual bool IsMatch(TypePair context);
}
public class AutoMapper.Mappers.ImplicitConversionOperatorMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    private static MethodInfo GetImplicitConversionOperator(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public static class AutoMapper.Mappers.MapperRegistry : object {
    private static IObjectMapper[] _initialMappers;
    private static List`1<IObjectMapper> _mappers;
    public static IList`1<IObjectMapper> Mappers { get; }
    private static MapperRegistry();
    public static IList`1<IObjectMapper> get_Mappers();
    public static void Reset();
}
public class AutoMapper.Mappers.MultidimensionalArrayFiller : object {
    private Int32[] indices;
    private Array destination;
    public MultidimensionalArrayFiller(Array destination);
    public void NewValue(object value);
}
public class AutoMapper.Mappers.MultidimensionalArrayMapper : object {
    private static MultidimensionalArrayFiller filler;
    private static MethodInfo MapMethodInfo;
    private static MultidimensionalArrayMapper();
    public static Array Map(TSource source, ResolutionContext context, bool allowNullCollections, bool allowNullDestinationValues);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.NameValueCollectionMapper : object {
    private static MethodInfo MapMethodInfo;
    private static NameValueCollectionMapper();
    public static NameValueCollection Map(NameValueCollection source);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.NullableSourceMapper : object {
    private static MethodInfo MapMethodInfo;
    private static NullableSourceMapper();
    public static TDestination Map(Nullable`1<TSource> source, TDestination destination, ResolutionContext context);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public static class AutoMapper.Mappers.ObjectCreator : object {
    public static DelegateFactory DelegateFactory;
    private static ObjectCreator();
    public static Array CreateArray(Type elementType, int length);
    public static Array CreateArray(Type elementType, Array sourceArray);
    public static IList CreateList(Type elementType);
    public static object CreateDictionary(Type dictionaryType, Type keyType, Type valueType);
    private static object CreateDictionary(Type dictionaryType);
    public static object CreateDefaultValue(Type type);
    public static object CreateNonNullValue(Type type);
    public static object CreateObject(Type type);
}
public class AutoMapper.Mappers.ReadOnlyCollectionMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.StringMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.StringToEnumMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.ToDynamicMapper : object {
    private static MethodInfo MapMethodInfo;
    private static ToDynamicMapper();
    public static TDestination Map(TSource source, TDestination destination, ResolutionContext context, Func`1<TDestination> ifNull);
    private static void SetDynamically(MemberInfo member, object target, object value);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.Mappers.ToStringDictionaryMapper : object {
    private static MethodInfo MembersDictionaryMethodInfo;
    private static ToStringDictionaryMapper();
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
    public static Dictionary`2<string, object> MembersDictionary(object source, ResolutionContext context);
}
public class AutoMapper.Mappers.TypeConverterMapper : object {
    private static MethodInfo MapMethodInfo;
    private static TypeConverterMapper();
    private static TDestination Map(TSource source, Func`1<TDestination> ifNull);
    private static TDestination GetConverter(TSource source);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
    private static TypeConverter GetTypeConverter(Type type);
}
[ExtensionAttribute]
internal static class AutoMapper.Mappers.TypeHelper : object {
    public static Type GetElementType(Type enumerableType);
    public static Type[] GetElementTypes(Type enumerableType, ElementTypeFlags flags);
    public static Type GetElementType(Type enumerableType, IEnumerable enumerable);
    public static Type[] GetElementTypes(Type enumerableType, IEnumerable enumerable, ElementTypeFlags flags);
    public static Type GetEnumerationType(Type enumType);
    [ExtensionAttribute]
internal static IEnumerable`1<MethodInfo> GetStaticMethods(Type type);
}
public class AutoMapper.MappingOperationOptions`2 : object {
    private Dictionary`2<string, object> _items;
    private static Action`2<TSource, TDestination> Empty;
    [CompilerGeneratedAttribute]
private Func`2<Type, object> <ServiceCtor>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<TSource, TDestination> <BeforeMapAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<TSource, TDestination> <AfterMapAction>k__BackingField;
    public Func`2<Type, object> ServiceCtor { get; private set; }
    public IDictionary`2<string, object> Items { get; }
    public Action`2<TSource, TDestination> BeforeMapAction { get; protected set; }
    public Action`2<TSource, TDestination> AfterMapAction { get; protected set; }
    public MappingOperationOptions`2(Func`2<Type, object> serviceCtor);
    private static MappingOperationOptions`2();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Type, object> get_ServiceCtor();
    [CompilerGeneratedAttribute]
private void set_ServiceCtor(Func`2<Type, object> value);
    public sealed virtual IDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public Action`2<TSource, TDestination> get_BeforeMapAction();
    [CompilerGeneratedAttribute]
protected void set_BeforeMapAction(Action`2<TSource, TDestination> value);
    [CompilerGeneratedAttribute]
public Action`2<TSource, TDestination> get_AfterMapAction();
    [CompilerGeneratedAttribute]
protected void set_AfterMapAction(Action`2<TSource, TDestination> value);
    public sealed virtual void BeforeMap(Action`2<TSource, TDestination> beforeFunction);
    public sealed virtual void AfterMap(Action`2<TSource, TDestination> afterFunction);
    public sealed virtual T CreateInstance();
    public sealed virtual void ConstructServicesUsing(Func`2<Type, object> constructor);
    private sealed virtual override void AutoMapper.IMappingOperationOptions.BeforeMap(Action`2<object, object> beforeFunction);
    private sealed virtual override void AutoMapper.IMappingOperationOptions.AfterMap(Action`2<object, object> afterFunction);
}
[DebuggerDisplayAttribute("{RequestedTypes.SourceType.Name}, {RequestedTypes.DestinationType.Name} : {RuntimeTypes.SourceType.Name}, {RuntimeTypes.DestinationType.Name}")]
public class AutoMapper.MapRequest : ValueType {
    private int _hashcode;
    [CompilerGeneratedAttribute]
private TypePair <RequestedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private TypePair <RuntimeTypes>k__BackingField;
    public TypePair RequestedTypes { get; }
    public TypePair RuntimeTypes { get; }
    public MapRequest(TypePair requestedTypes, TypePair runtimeTypes);
    [CompilerGeneratedAttribute]
public TypePair get_RequestedTypes();
    [CompilerGeneratedAttribute]
public TypePair get_RuntimeTypes();
    public sealed virtual bool Equals(MapRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MapRequest left, MapRequest right);
    public static bool op_Inequality(MapRequest left, MapRequest right);
}
public enum AutoMapper.MemberList : Enum {
    public int value__;
    public static MemberList Destination;
    public static MemberList Source;
    public static MemberList None;
}
public abstract class AutoMapper.ObjectMapper`2 : object {
    private static MethodInfo MapMethod;
    private static ObjectMapper`2();
    public abstract virtual bool IsMatch(TypePair context);
    public abstract virtual TDestination Map(TSource source, TDestination destination, ResolutionContext context);
    public sealed virtual Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression);
}
public class AutoMapper.PascalCaseNamingConvention : object {
    [CompilerGeneratedAttribute]
private Regex <SplittingExpression>k__BackingField;
    public Regex SplittingExpression { get; }
    public string SeparatorCharacter { get; }
    [CompilerGeneratedAttribute]
public sealed virtual Regex get_SplittingExpression();
    public sealed virtual string get_SeparatorCharacter();
    public sealed virtual string ReplaceValue(Match match);
}
public abstract class AutoMapper.Profile : object {
    private List`1<Action`2<PropertyMap, IMemberConfigurationExpression>> _allPropertyMapActions;
    private List`1<Action`2<TypeMap, IMappingExpression>> _allTypeMapActions;
    private List`1<string> _globalIgnore;
    private IList`1<IMemberConfiguration> _memberConfigurations;
    private List`1<ITypeMapConfiguration> _openTypeMapConfigs;
    private List`1<MethodInfo> _sourceExtensionMethods;
    private IList`1<ConditionalObjectMapper> _typeConfigurations;
    private List`1<ITypeMapConfiguration> _typeMapConfigs;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ConstructorMappingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CreateMissingTypeMaps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProfileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowNullDestinationValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowNullCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableNullPropagationForQueryMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<PropertyInfo, bool> <ShouldMapProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<FieldInfo, bool> <ShouldMapField>k__BackingField;
    [CompilerGeneratedAttribute]
private INamingConvention <SourceMemberNamingConvention>k__BackingField;
    [CompilerGeneratedAttribute]
private INamingConvention <DestinationMemberNamingConvention>k__BackingField;
    public IMemberConfiguration DefaultMemberConfig { get; }
    public Nullable`1<bool> ConstructorMappingEnabled { get; private set; }
    public Nullable`1<bool> CreateMissingTypeMaps { get; public set; }
    private IEnumerable`1<Action`2<PropertyMap, IMemberConfigurationExpression>> AutoMapper.Configuration.IProfileConfiguration.AllPropertyMapActions { get; }
    private IEnumerable`1<Action`2<TypeMap, IMappingExpression>> AutoMapper.Configuration.IProfileConfiguration.AllTypeMapActions { get; }
    private IEnumerable`1<string> AutoMapper.Configuration.IProfileConfiguration.GlobalIgnores { get; }
    private IEnumerable`1<IMemberConfiguration> AutoMapper.Configuration.IProfileConfiguration.MemberConfigurations { get; }
    private IEnumerable`1<MethodInfo> AutoMapper.Configuration.IProfileConfiguration.SourceExtensionMethods { get; }
    private IEnumerable`1<IConditionalObjectMapper> AutoMapper.Configuration.IProfileConfiguration.TypeConfigurations { get; }
    private IEnumerable`1<ITypeMapConfiguration> AutoMapper.Configuration.IProfileConfiguration.TypeMapConfigs { get; }
    private IEnumerable`1<ITypeMapConfiguration> AutoMapper.Configuration.IProfileConfiguration.OpenTypeMapConfigs { get; }
    public string ProfileName { get; }
    public Nullable`1<bool> AllowNullDestinationValues { get; public set; }
    public Nullable`1<bool> AllowNullCollections { get; public set; }
    public Nullable`1<bool> EnableNullPropagationForQueryMapping { get; public set; }
    public Func`2<PropertyInfo, bool> ShouldMapProperty { get; public set; }
    public Func`2<FieldInfo, bool> ShouldMapField { get; public set; }
    public INamingConvention SourceMemberNamingConvention { get; public set; }
    public INamingConvention DestinationMemberNamingConvention { get; public set; }
    protected Profile(string profileName);
    protected Profile(string profileName, Action`1<IProfileExpression> configurationAction);
    public IMemberConfiguration get_DefaultMemberConfig();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_ConstructorMappingEnabled();
    [CompilerGeneratedAttribute]
private void set_ConstructorMappingEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_CreateMissingTypeMaps();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CreateMissingTypeMaps(Nullable`1<bool> value);
    private sealed virtual override IEnumerable`1<Action`2<PropertyMap, IMemberConfigurationExpression>> AutoMapper.Configuration.IProfileConfiguration.get_AllPropertyMapActions();
    private sealed virtual override IEnumerable`1<Action`2<TypeMap, IMappingExpression>> AutoMapper.Configuration.IProfileConfiguration.get_AllTypeMapActions();
    private sealed virtual override IEnumerable`1<string> AutoMapper.Configuration.IProfileConfiguration.get_GlobalIgnores();
    private sealed virtual override IEnumerable`1<IMemberConfiguration> AutoMapper.Configuration.IProfileConfiguration.get_MemberConfigurations();
    private sealed virtual override IEnumerable`1<MethodInfo> AutoMapper.Configuration.IProfileConfiguration.get_SourceExtensionMethods();
    private sealed virtual override IEnumerable`1<IConditionalObjectMapper> AutoMapper.Configuration.IProfileConfiguration.get_TypeConfigurations();
    private sealed virtual override IEnumerable`1<ITypeMapConfiguration> AutoMapper.Configuration.IProfileConfiguration.get_TypeMapConfigs();
    private sealed virtual override IEnumerable`1<ITypeMapConfiguration> AutoMapper.Configuration.IProfileConfiguration.get_OpenTypeMapConfigs();
    [CompilerGeneratedAttribute]
public virtual string get_ProfileName();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_AllowNullDestinationValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AllowNullDestinationValues(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_AllowNullCollections();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AllowNullCollections(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_EnableNullPropagationForQueryMapping();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EnableNullPropagationForQueryMapping(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<PropertyInfo, bool> get_ShouldMapProperty();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldMapProperty(Func`2<PropertyInfo, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<FieldInfo, bool> get_ShouldMapField();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldMapField(Func`2<FieldInfo, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual INamingConvention get_SourceMemberNamingConvention();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SourceMemberNamingConvention(INamingConvention value);
    [CompilerGeneratedAttribute]
public sealed virtual INamingConvention get_DestinationMemberNamingConvention();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DestinationMemberNamingConvention(INamingConvention value);
    public sealed virtual void DisableConstructorMapping();
    public sealed virtual void ForAllMaps(Action`2<TypeMap, IMappingExpression> configuration);
    public sealed virtual void ForAllPropertyMaps(Func`2<PropertyMap, bool> condition, Action`2<PropertyMap, IMemberConfigurationExpression> configuration);
    public sealed virtual IMappingExpression`2<TSource, TDestination> CreateMap();
    public sealed virtual IMappingExpression`2<TSource, TDestination> CreateMap(MemberList memberList);
    public sealed virtual IMappingExpression CreateMap(Type sourceType, Type destinationType);
    public sealed virtual IMappingExpression CreateMap(Type sourceType, Type destinationType, MemberList memberList);
    public sealed virtual void ClearPrefixes();
    public sealed virtual void RecognizeAlias(string original, string alias);
    public sealed virtual void ReplaceMemberName(string original, string newValue);
    public sealed virtual void RecognizePrefixes(String[] prefixes);
    public sealed virtual void RecognizePostfixes(String[] postfixes);
    public sealed virtual void RecognizeDestinationPrefixes(String[] prefixes);
    public sealed virtual void RecognizeDestinationPostfixes(String[] postfixes);
    public sealed virtual void AddGlobalIgnore(string propertyNameStartingWith);
    public sealed virtual IMemberConfiguration AddMemberConfiguration();
    public sealed virtual IConditionalObjectMapper AddConditionalObjectMapper();
    public sealed virtual void IncludeSourceExtensionMethods(Type type);
    [ObsoleteAttribute("Create a constructor and configure inside of your profile's constructor instead. Will be removed in 6.0")]
protected virtual void Configure();
    internal void Initialize();
    private IMappingExpression`2<TSource, TDestination> CreateMappingExpression(MemberList memberList);
}
[DebuggerDisplayAttribute("{Name}")]
public class AutoMapper.ProfileMap : object {
    private TypeMapFactory _typeMapFactory;
    private IEnumerable`1<ITypeMapConfiguration> _typeMapConfigs;
    private IEnumerable`1<ITypeMapConfiguration> _openTypeMapConfigs;
    private LockingConcurrentDictionary`2<Type, TypeDetails> _typeDetails;
    [CompilerGeneratedAttribute]
private bool <AllowNullCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNullDestinationValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConstructorMappingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateMissingTypeMaps>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableNullPropagationForQueryMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<FieldInfo, bool> <ShouldMapField>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<PropertyInfo, bool> <ShouldMapProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Action`2<PropertyMap, IMemberConfigurationExpression>> <AllPropertyMapActions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Action`2<TypeMap, IMappingExpression>> <AllTypeMapActions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <GlobalIgnores>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IMemberConfiguration> <MemberConfigurations>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodInfo> <SourceExtensionMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IConditionalObjectMapper> <TypeConfigurations>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Prefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Postfixes>k__BackingField;
    public bool AllowNullCollections { get; }
    public bool AllowNullDestinationValues { get; }
    public bool ConstructorMappingEnabled { get; }
    public bool CreateMissingTypeMaps { get; }
    public bool EnableNullPropagationForQueryMapping { get; }
    public string Name { get; }
    public Func`2<FieldInfo, bool> ShouldMapField { get; }
    public Func`2<PropertyInfo, bool> ShouldMapProperty { get; }
    public IEnumerable`1<Action`2<PropertyMap, IMemberConfigurationExpression>> AllPropertyMapActions { get; }
    public IEnumerable`1<Action`2<TypeMap, IMappingExpression>> AllTypeMapActions { get; }
    public IEnumerable`1<string> GlobalIgnores { get; }
    public IEnumerable`1<IMemberConfiguration> MemberConfigurations { get; }
    public IEnumerable`1<MethodInfo> SourceExtensionMethods { get; }
    public IEnumerable`1<IConditionalObjectMapper> TypeConfigurations { get; }
    public IEnumerable`1<string> Prefixes { get; }
    public IEnumerable`1<string> Postfixes { get; }
    public ProfileMap(IProfileConfiguration profile);
    public ProfileMap(IProfileConfiguration profile, IConfiguration configuration);
    [CompilerGeneratedAttribute]
public bool get_AllowNullCollections();
    [CompilerGeneratedAttribute]
public bool get_AllowNullDestinationValues();
    [CompilerGeneratedAttribute]
public bool get_ConstructorMappingEnabled();
    [CompilerGeneratedAttribute]
public bool get_CreateMissingTypeMaps();
    [CompilerGeneratedAttribute]
public bool get_EnableNullPropagationForQueryMapping();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Func`2<FieldInfo, bool> get_ShouldMapField();
    [CompilerGeneratedAttribute]
public Func`2<PropertyInfo, bool> get_ShouldMapProperty();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Action`2<PropertyMap, IMemberConfigurationExpression>> get_AllPropertyMapActions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Action`2<TypeMap, IMappingExpression>> get_AllTypeMapActions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_GlobalIgnores();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IMemberConfiguration> get_MemberConfigurations();
    [CompilerGeneratedAttribute]
public IEnumerable`1<MethodInfo> get_SourceExtensionMethods();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IConditionalObjectMapper> get_TypeConfigurations();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Prefixes();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Postfixes();
    public TypeDetails CreateTypeDetails(Type type);
    private TypeDetails TypeDetailsFactory(Type type);
    public void Register(TypeMapRegistry typeMapRegistry);
    public void Configure(TypeMapRegistry typeMapRegistry);
    private void BuildTypeMap(TypeMapRegistry typeMapRegistry, ITypeMapConfiguration config);
    private void Configure(TypeMapRegistry typeMapRegistry, ITypeMapConfiguration typeMapConfiguration);
    private void Configure(TypeMapRegistry typeMapRegistry, TypeMap typeMap);
    public TypeMap ConfigureConventionTypeMap(TypeMapRegistry typeMapRegistry, TypePair types);
    public TypeMap ConfigureClosedGenericTypeMap(TypeMapRegistry typeMapRegistry, TypePair closedTypes, TypePair requestedTypes);
    private static void ApplyBaseMaps(TypeMapRegistry typeMapRegistry, TypeMap derivedMap, TypeMap currentMap);
    private void ApplyDerivedMaps(TypeMapRegistry typeMapRegistry, TypeMap baseMap, TypeMap typeMap);
}
[DebuggerDisplayAttribute("{DestinationProperty.Name}")]
public class AutoMapper.PropertyMap : object {
    private List`1<MemberInfo> _memberChain;
    [CompilerGeneratedAttribute]
private TypeMap <TypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <DestinationProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNull>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MappingOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <CustomResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <PreCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <CustomExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <CustomSourceMember>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDestinationValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitExpansion>k__BackingField;
    [CompilerGeneratedAttribute]
private object <NullSubstitute>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueResolverConfiguration <ValueResolverConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomSourceMemberName>k__BackingField;
    public TypeMap TypeMap { get; }
    public MemberInfo DestinationProperty { get; }
    public Type DestinationPropertyType { get; }
    public IEnumerable`1<MemberInfo> SourceMembers { get; }
    public bool Ignored { get; public set; }
    public bool AllowNull { get; public set; }
    public Nullable`1<int> MappingOrder { get; public set; }
    public LambdaExpression CustomResolver { get; public set; }
    public LambdaExpression Condition { get; public set; }
    public LambdaExpression PreCondition { get; public set; }
    public LambdaExpression CustomExpression { get; private set; }
    public MemberInfo CustomSourceMember { get; public set; }
    public bool UseDestinationValue { get; public set; }
    public bool ExplicitExpansion { get; public set; }
    public object NullSubstitute { get; public set; }
    public ValueResolverConfiguration ValueResolverConfig { get; public set; }
    public MemberInfo SourceMember { get; }
    public Type SourceType { get; }
    public string CustomSourceMemberName { get; public set; }
    public PropertyMap(MemberInfo destinationProperty, TypeMap typeMap);
    public PropertyMap(PropertyMap inheritedMappedProperty, TypeMap typeMap);
    [CompilerGeneratedAttribute]
public TypeMap get_TypeMap();
    [CompilerGeneratedAttribute]
public MemberInfo get_DestinationProperty();
    public Type get_DestinationPropertyType();
    public IEnumerable`1<MemberInfo> get_SourceMembers();
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowNull();
    [CompilerGeneratedAttribute]
public void set_AllowNull(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MappingOrder();
    [CompilerGeneratedAttribute]
public void set_MappingOrder(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_CustomResolver();
    [CompilerGeneratedAttribute]
public void set_CustomResolver(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_PreCondition();
    [CompilerGeneratedAttribute]
public void set_PreCondition(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_CustomExpression();
    [CompilerGeneratedAttribute]
private void set_CustomExpression(LambdaExpression value);
    [CompilerGeneratedAttribute]
public MemberInfo get_CustomSourceMember();
    [CompilerGeneratedAttribute]
public void set_CustomSourceMember(MemberInfo value);
    [CompilerGeneratedAttribute]
public bool get_UseDestinationValue();
    [CompilerGeneratedAttribute]
public void set_UseDestinationValue(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitExpansion();
    [CompilerGeneratedAttribute]
public void set_ExplicitExpansion(bool value);
    [CompilerGeneratedAttribute]
public object get_NullSubstitute();
    [CompilerGeneratedAttribute]
public void set_NullSubstitute(object value);
    [CompilerGeneratedAttribute]
public ValueResolverConfiguration get_ValueResolverConfig();
    [CompilerGeneratedAttribute]
public void set_ValueResolverConfig(ValueResolverConfiguration value);
    public MemberInfo get_SourceMember();
    public Type get_SourceType();
    [CompilerGeneratedAttribute]
public string get_CustomSourceMemberName();
    [CompilerGeneratedAttribute]
public void set_CustomSourceMemberName(string value);
    public void ChainMembers(IEnumerable`1<MemberInfo> members);
    public void ApplyInheritedPropertyMap(PropertyMap inheritedMappedProperty);
    public bool IsMapped();
    public bool CanResolveValue();
    public void SetCustomValueResolverExpression(Expression`1<Func`2<TSource, TMember>> sourceMember);
}
public class AutoMapper.QueryableExtensions.ExpressionBuilder : object {
    private static IExpressionResultConverter[] ExpressionResultConverters;
    private static IExpressionBinder[] Binders;
    private LockingConcurrentDictionary`2<ExpressionRequest, LambdaExpression> _expressionCache;
    private IConfigurationProvider _configurationProvider;
    public ExpressionBuilder(IConfigurationProvider configurationProvider);
    private static ExpressionBuilder();
    public sealed virtual Expression CreateMapExpression(Type sourceType, Type destinationType, IDictionary`2<string, object> parameters, MemberInfo[] membersToExpand);
    public sealed virtual Expression`1<Func`2<TSource, TDestination>> CreateMapExpression(IDictionary`2<string, object> parameters, MemberInfo[] membersToExpand);
    public LambdaExpression CreateMapExpression(ExpressionRequest request);
    public sealed virtual LambdaExpression CreateMapExpression(ExpressionRequest request, IDictionary`2<ExpressionRequest, int> typePairCount);
    public sealed virtual Expression CreateMapExpression(ExpressionRequest request, Expression instanceParameter, IDictionary`2<ExpressionRequest, int> typePairCount);
    private static int GetDepth(ExpressionRequest request, IDictionary`2<ExpressionRequest, int> typePairCount);
    private LambdaExpression DestinationConstructorExpression(TypeMap typeMap, Expression instanceParameter);
    private List`1<MemberBinding> CreateMemberBindings(ExpressionRequest request, TypeMap typeMap, Expression instanceParameter, IDictionary`2<ExpressionRequest, int> typePairCount);
    private static ExpressionResolutionResult ResolveExpression(PropertyMap propertyMap, Type currentType, Expression instanceParameter);
}
public class AutoMapper.QueryableExtensions.ExpressionRequest : object {
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DestinationType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo[] <MembersToExpand>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ExpressionRequest> <PreviousRequests>k__BackingField;
    public Type SourceType { get; }
    public Type DestinationType { get; }
    public MemberInfo[] MembersToExpand { get; }
    internal ICollection`1<ExpressionRequest> PreviousRequests { get; private set; }
    internal bool AlreadyExists { get; }
    public ExpressionRequest(Type sourceType, Type destinationType, MemberInfo[] membersToExpand, ExpressionRequest parentRequest);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public Type get_DestinationType();
    [CompilerGeneratedAttribute]
public MemberInfo[] get_MembersToExpand();
    [CompilerGeneratedAttribute]
internal ICollection`1<ExpressionRequest> get_PreviousRequests();
    [CompilerGeneratedAttribute]
private void set_PreviousRequests(ICollection`1<ExpressionRequest> value);
    internal IEnumerable`1<ExpressionRequest> GetPreviousRequestsAndSelf();
    internal bool get_AlreadyExists();
    public sealed virtual bool Equals(ExpressionRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ExpressionRequest left, ExpressionRequest right);
    public static bool op_Inequality(ExpressionRequest left, ExpressionRequest right);
}
public class AutoMapper.QueryableExtensions.ExpressionResolutionResult : object {
    [CompilerGeneratedAttribute]
private Expression <ResolutionExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Expression ResolutionExpression { get; private set; }
    public Type Type { get; private set; }
    public ExpressionResolutionResult(Expression resolutionExpression, Type type);
    [CompilerGeneratedAttribute]
public Expression get_ResolutionExpression();
    [CompilerGeneratedAttribute]
private void set_ResolutionExpression(Expression value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
}
[ExtensionAttribute]
public static class AutoMapper.QueryableExtensions.Extensions : object {
    [ExtensionAttribute]
public static IQueryable`1<TDestination> Map(IQueryable`1<TSource> sourceQuery, IQueryable`1<TDestination> destQuery);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> Map(IQueryable`1<TSource> sourceQuery, IQueryable`1<TDestination> destQuery, IConfigurationProvider config);
    [ExtensionAttribute]
[ObsoleteAttribute("Uses static API internally (Mapper.Configuration) - will be dropped in v5")]
public static IQueryDataSourceInjection`1<TSource> UseAsDataSource(IQueryable`1<TSource> dataSource);
    [ExtensionAttribute]
public static IQueryDataSourceInjection`1<TSource> UseAsDataSource(IQueryable`1<TSource> dataSource, IConfigurationProvider config);
    [ExtensionAttribute]
public static IQueryDataSourceInjection`1<TSource> UseAsDataSource(IQueryable`1<TSource> dataSource, IMapper mapper);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> ProjectTo(IQueryable source, object parameters, Expression`1[] membersToExpand);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> ProjectTo(IQueryable source, IConfigurationProvider configuration, object parameters, Expression`1[] membersToExpand);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> ProjectTo(IQueryable source, IConfigurationProvider configuration, Expression`1[] membersToExpand);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> ProjectTo(IQueryable source, Expression`1[] membersToExpand);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> ProjectTo(IQueryable source, IDictionary`2<string, object> parameters, String[] membersToExpand);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> ProjectTo(IQueryable source, IConfigurationProvider configuration, IDictionary`2<string, object> parameters, String[] membersToExpand);
}
public interface AutoMapper.QueryableExtensions.IExpressionBinder {
    public abstract virtual bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionResolutionResult result);
    public abstract virtual MemberAssignment Build(IConfigurationProvider configuration, PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary`2<ExpressionRequest, int> typePairCount);
}
public interface AutoMapper.QueryableExtensions.IExpressionBuilder {
    public abstract virtual Expression CreateMapExpression(Type sourceType, Type destinationType, IDictionary`2<string, object> parameters, MemberInfo[] membersToExpand);
    public abstract virtual Expression`1<Func`2<TSource, TDestination>> CreateMapExpression(IDictionary`2<string, object> parameters, MemberInfo[] membersToExpand);
    public abstract virtual LambdaExpression CreateMapExpression(ExpressionRequest request, IDictionary`2<ExpressionRequest, int> typePairCount);
    public abstract virtual Expression CreateMapExpression(ExpressionRequest request, Expression instanceParameter, IDictionary`2<ExpressionRequest, int> typePairCount);
}
public interface AutoMapper.QueryableExtensions.IExpressionResultConverter {
    public abstract virtual ExpressionResolutionResult GetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, PropertyMap propertyMap);
    public abstract virtual ExpressionResolutionResult GetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, ConstructorParameterMap propertyMap);
    public abstract virtual bool CanGetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, PropertyMap propertyMap);
    public abstract virtual bool CanGetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, ConstructorParameterMap propertyMap);
}
public class AutoMapper.QueryableExtensions.Impl.AssignableExpressionBinder : object {
    public sealed virtual bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionResolutionResult result);
    public sealed virtual MemberAssignment Build(IConfigurationProvider configuration, PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary`2<ExpressionRequest, int> typePairCount);
    private static MemberAssignment BindAssignableExpression(PropertyMap propertyMap, ExpressionResolutionResult result);
}
public class AutoMapper.QueryableExtensions.Impl.CustomProjectionExpressionBinder : object {
    public sealed virtual bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionResolutionResult result);
    public sealed virtual MemberAssignment Build(IConfigurationProvider configuration, PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary`2<ExpressionRequest, int> typePairCount);
    private static MemberAssignment BindCustomProjectionExpression(PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionResolutionResult result);
}
internal class AutoMapper.QueryableExtensions.Impl.ElementOperatorSearcher : ExpressionVisitor {
    [CompilerGeneratedAttribute]
private bool <ContainsElementOperator>k__BackingField;
    public bool ContainsElementOperator { get; private set; }
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    [CompilerGeneratedAttribute]
public bool get_ContainsElementOperator();
    [CompilerGeneratedAttribute]
private void set_ContainsElementOperator(bool value);
}
public class AutoMapper.QueryableExtensions.Impl.EnumerableExpressionBinder : object {
    public sealed virtual bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionResolutionResult result);
    public sealed virtual MemberAssignment Build(IConfigurationProvider configuration, PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary`2<ExpressionRequest, int> typePairCount);
    private static MemberAssignment BindEnumerableExpression(IConfigurationProvider configuration, PropertyMap propertyMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary`2<ExpressionRequest, int> typePairCount);
}
public interface AutoMapper.QueryableExtensions.Impl.IQueryDataSourceInjection`1 {
    public abstract virtual ISourceInjectedQueryable`1<TDestination> For();
    public abstract virtual ISourceInjectedQueryable`1<TDestination> For(object parameters, Expression`1[] membersToExpand);
    public abstract virtual ISourceInjectedQueryable`1<TDestination> For(Expression`1[] membersToExpand);
    public abstract virtual ISourceInjectedQueryable`1<TDestination> For(IDictionary`2<string, object> parameters, String[] membersToExpand);
    public abstract virtual IQueryDataSourceInjection`1<TSource> UsingInspector(SourceInjectedQueryInspector inspector);
    public abstract virtual IQueryDataSourceInjection`1<TSource> BeforeProjection(ExpressionVisitor[] visitors);
    public abstract virtual IQueryDataSourceInjection`1<TSource> AfterProjection(ExpressionVisitor[] visitors);
    public abstract virtual IQueryDataSourceInjection`1<TSource> OnError(Action`1<Exception> exceptionHandler);
}
public interface AutoMapper.QueryableExtensions.Impl.ISourceInjectedQueryable`1 {
    public abstract virtual IQueryable`1<T> OnEnumerated(Action`1<IEnumerable`1<object>> enumerationHandler);
    public abstract virtual IQueryable`1<T> AsQueryable();
}
public class AutoMapper.QueryableExtensions.Impl.MappedTypeExpressionBinder : object {
    public sealed virtual bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionResolutionResult result);
    public sealed virtual MemberAssignment Build(IConfigurationProvider configuration, PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary`2<ExpressionRequest, int> typePairCount);
    private static MemberAssignment BindMappedTypeExpression(IConfigurationProvider configuration, PropertyMap propertyMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary`2<ExpressionRequest, int> typePairCount);
}
public class AutoMapper.QueryableExtensions.Impl.MemberAccessQueryMapperVisitor : ExpressionVisitor {
    private ExpressionVisitor _rootVisitor;
    private IConfigurationProvider _config;
    public MemberAccessQueryMapperVisitor(ExpressionVisitor rootVisitor, IConfigurationProvider config);
    protected virtual Expression VisitMember(MemberExpression node);
}
public class AutoMapper.QueryableExtensions.Impl.MemberGetterExpressionResultConverter : object {
    public sealed virtual ExpressionResolutionResult GetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, PropertyMap propertyMap);
    public sealed virtual ExpressionResolutionResult GetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, ConstructorParameterMap propertyMap);
    private static ExpressionResolutionResult ExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, IEnumerable`1<MemberInfo> sourceMembers);
    private static ExpressionResolutionResult ExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, MemberInfo getter);
    public sealed virtual bool CanGetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, PropertyMap propertyMap);
    public sealed virtual bool CanGetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, ConstructorParameterMap propertyMap);
}
public class AutoMapper.QueryableExtensions.Impl.MemberResolverExpressionResultConverter : object {
    public sealed virtual ExpressionResolutionResult GetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, PropertyMap propertyMap);
    private static ExpressionResolutionResult ExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, LambdaExpression lambdaExpression);
    public sealed virtual ExpressionResolutionResult GetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, ConstructorParameterMap propertyMap);
    public sealed virtual bool CanGetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, PropertyMap propertyMap);
    public sealed virtual bool CanGetExpressionResolutionResult(ExpressionResolutionResult expressionResolutionResult, ConstructorParameterMap propertyMap);
}
internal class AutoMapper.QueryableExtensions.Impl.MethodNodeReplacer`1 : ExpressionVisitor {
    private MethodCallExpression _foundExpression;
    private static MethodInfo QueryableWhereMethod;
    [CompilerGeneratedAttribute]
private MethodInfo <ReplacedMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <ElementOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FoundElementOperator>k__BackingField;
    public MethodInfo ReplacedMethod { get; private set; }
    public MethodInfo ElementOperator { get; private set; }
    public bool FoundElementOperator { get; private set; }
    public MethodNodeReplacer`1(MethodCallExpression foundExpression);
    private static MethodNodeReplacer`1();
    private static MethodInfo FindQueryableWhereMethod();
    [CompilerGeneratedAttribute]
public MethodInfo get_ReplacedMethod();
    [CompilerGeneratedAttribute]
private void set_ReplacedMethod(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_ElementOperator();
    [CompilerGeneratedAttribute]
private void set_ElementOperator(MethodInfo value);
    [CompilerGeneratedAttribute]
public bool get_FoundElementOperator();
    [CompilerGeneratedAttribute]
private void set_FoundElementOperator(bool value);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
}
public class AutoMapper.QueryableExtensions.Impl.NullableExpressionBinder : object {
    public sealed virtual bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionResolutionResult result);
    public sealed virtual MemberAssignment Build(IConfigurationProvider configuration, PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary`2<ExpressionRequest, int> typePairCount);
    private static MemberAssignment BindNullableExpression(PropertyMap propertyMap, ExpressionResolutionResult result);
}
internal class AutoMapper.QueryableExtensions.Impl.ParameterConversionVisitor : ExpressionVisitor {
    private Expression newParameter;
    private ParameterExpression oldParameter;
    public ParameterConversionVisitor(Expression newParameter, ParameterExpression oldParameter);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
}
public class AutoMapper.QueryableExtensions.Impl.ParameterReplacementVisitor : ExpressionVisitor {
    private Expression _memberExpression;
    public ParameterReplacementVisitor(Expression memberExpression);
    protected virtual Expression VisitParameter(ParameterExpression node);
}
public class AutoMapper.QueryableExtensions.Impl.QueryDataSourceInjection`1 : object {
    private IQueryable`1<TSource> _dataSource;
    private IMapper _mapper;
    private List`1<ExpressionVisitor> _beforeMappingVisitors;
    private List`1<ExpressionVisitor> _afterMappingVisitors;
    private ExpressionVisitor _sourceExpressionTracer;
    private ExpressionVisitor _destinationExpressionTracer;
    private Action`1<Exception> _exceptionHandler;
    private IEnumerable`1<IEnumerable`1<MemberInfo>> _membersToExpand;
    private IDictionary`2<string, object> _parameters;
    private SourceInjectedQueryInspector _inspector;
    public QueryDataSourceInjection`1(IQueryable`1<TSource> dataSource, IMapper mapper);
    public sealed virtual ISourceInjectedQueryable`1<TDestination> For();
    public sealed virtual ISourceInjectedQueryable`1<TDestination> For(object parameters, Expression`1[] membersToExpand);
    public sealed virtual ISourceInjectedQueryable`1<TDestination> For(Expression`1[] membersToExpand);
    public sealed virtual ISourceInjectedQueryable`1<TDestination> For(IDictionary`2<string, object> parameters, String[] membersToExpand);
    public sealed virtual IQueryDataSourceInjection`1<TSource> UsingInspector(SourceInjectedQueryInspector inspector);
    public sealed virtual IQueryDataSourceInjection`1<TSource> BeforeProjection(ExpressionVisitor[] visitors);
    public sealed virtual IQueryDataSourceInjection`1<TSource> AfterProjection(ExpressionVisitor[] visitors);
    public sealed virtual IQueryDataSourceInjection`1<TSource> OnError(Action`1<Exception> exceptionHandler);
    private ISourceInjectedQueryable`1<TDestination> CreateQueryable();
    private static IDictionary`2<string, object> GetParameters(object parameters);
    private IEnumerable`1<IEnumerable`1<MemberInfo>> GetMemberPaths(Type type, String[] membersToExpand);
    private IEnumerable`1<IEnumerable`1<MemberInfo>> GetMemberPaths(Expression`1[] membersToExpand);
}
[ExtensionAttribute]
public static class AutoMapper.QueryableExtensions.Impl.QueryMapperHelper : object {
    [ExtensionAttribute]
public static PropertyMap GetPropertyMap(IConfigurationProvider config, MemberInfo sourceMemberInfo, Type destinationMemberType);
    [ExtensionAttribute]
public static TypeMap CheckIfMapExists(IConfigurationProvider config, Type sourceType, Type destinationType);
    public static Exception MissingMapException(Type sourceType, Type destinationType);
}
public class AutoMapper.QueryableExtensions.Impl.QueryMapperVisitor : ExpressionVisitor {
    private IQueryable _destQuery;
    private ParameterExpression _instanceParameter;
    private Type _sourceType;
    private Type _destinationType;
    private Stack`1<object> _tree;
    private Stack`1<object> _newTree;
    private MemberAccessQueryMapperVisitor _memberVisitor;
    internal QueryMapperVisitor(Type sourceType, Type destinationType, IQueryable destQuery, IConfigurationProvider config);
    public static IQueryable`1<TDestination> Map(IQueryable`1<TSource> sourceQuery, IQueryable`1<TDestination> destQuery, IConfigurationProvider config);
    public virtual Expression Visit(Expression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private Expression VisitOrderBy(MethodCallExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    private MethodInfo ChangeMethodArgTypeFormSourceToDest(MethodInfo mi);
    private Type ChangeLambdaArgTypeFormSourceToDest(Type lambdaType, Type returnType);
    [CompilerGeneratedAttribute]
private ParameterExpression <VisitLambda>b__13_0(ParameterExpression p);
    [CompilerGeneratedAttribute]
private Type <ChangeMethodArgTypeFormSourceToDest>b__17_0(Type t);
    [CompilerGeneratedAttribute]
private Type <ChangeLambdaArgTypeFormSourceToDest>b__18_0(Type t);
}
internal class AutoMapper.QueryableExtensions.Impl.ReplaceableMethodNodeFinder`1 : ExpressionVisitor {
    [CompilerGeneratedAttribute]
private MethodCallExpression <MethodNode>k__BackingField;
    private bool _ignoredMethodFound;
    private static String[] IgnoredMethods;
    public MethodCallExpression MethodNode { get; private set; }
    private static ReplaceableMethodNodeFinder`1();
    [CompilerGeneratedAttribute]
public MethodCallExpression get_MethodNode();
    [CompilerGeneratedAttribute]
private void set_MethodNode(MethodCallExpression value);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
}
public class AutoMapper.QueryableExtensions.Impl.SourceInjectedQueryInspector : object {
    [CompilerGeneratedAttribute]
private Action`2<Expression, object> <SourceResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<object> <DestResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Type, Expression> <StartQueryExecuteInterceptor>k__BackingField;
    public Action`2<Expression, object> SourceResult { get; public set; }
    public Action`1<object> DestResult { get; public set; }
    public Action`2<Type, Expression> StartQueryExecuteInterceptor { get; public set; }
    [CompilerGeneratedAttribute]
public Action`2<Expression, object> get_SourceResult();
    [CompilerGeneratedAttribute]
public void set_SourceResult(Action`2<Expression, object> value);
    [CompilerGeneratedAttribute]
public Action`1<object> get_DestResult();
    [CompilerGeneratedAttribute]
public void set_DestResult(Action`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<Type, Expression> get_StartQueryExecuteInterceptor();
    [CompilerGeneratedAttribute]
public void set_StartQueryExecuteInterceptor(Action`2<Type, Expression> value);
}
public class AutoMapper.QueryableExtensions.Impl.SourceInjectedQueryProvider`2 : object {
    private IMapper _mapper;
    private IQueryable`1<TSource> _dataSource;
    private IQueryable`1<TDestination> _destQuery;
    private IEnumerable`1<ExpressionVisitor> _beforeVisitors;
    private IEnumerable`1<ExpressionVisitor> _afterVisitors;
    private IDictionary`2<string, object> _parameters;
    private IEnumerable`1<IEnumerable`1<MemberInfo>> _membersToExpand;
    private Action`1<Exception> _exceptionHandler;
    [CompilerGeneratedAttribute]
private SourceInjectedQueryInspector <Inspector>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IEnumerable`1<object>> <EnumerationHandler>k__BackingField;
    private static MethodInfo QueryableSelectMethod;
    public SourceInjectedQueryInspector Inspector { get; public set; }
    internal Action`1<IEnumerable`1<object>> EnumerationHandler { get; internal set; }
    public SourceInjectedQueryProvider`2(IMapper mapper, IQueryable`1<TSource> dataSource, IQueryable`1<TDestination> destQuery, IEnumerable`1<ExpressionVisitor> beforeVisitors, IEnumerable`1<ExpressionVisitor> afterVisitors, Action`1<Exception> exceptionHandler, IDictionary`2<string, object> parameters, IEnumerable`1<IEnumerable`1<MemberInfo>> membersToExpand);
    private static SourceInjectedQueryProvider`2();
    [CompilerGeneratedAttribute]
public SourceInjectedQueryInspector get_Inspector();
    [CompilerGeneratedAttribute]
public void set_Inspector(SourceInjectedQueryInspector value);
    [CompilerGeneratedAttribute]
internal Action`1<IEnumerable`1<object>> get_EnumerationHandler();
    [CompilerGeneratedAttribute]
internal void set_EnumerationHandler(Action`1<IEnumerable`1<object>> value);
    public sealed virtual IQueryable CreateQuery(Expression expression);
    public sealed virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public sealed virtual object Execute(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    private object InvokeSourceQuery(Type sourceResultType, Expression sourceExpression);
    private static bool IsProjection(Type resultType);
    private static bool IsProjection(Type resultType, Expression sourceExpression);
    private static bool IsProjection(Type resultType);
    private static Type CreateSourceResultType(Type destResultType);
    private Expression ConvertDestinationExpressionToSourceExpression(Expression expression);
    private static MethodInfo FindQueryableSelectMethod();
}
public class AutoMapper.QueryableExtensions.Impl.SourceSourceInjectedQuery`2 : object {
    private Action`1<Exception> _exceptionHandler;
    [CompilerGeneratedAttribute]
private Action`1<IEnumerable`1<object>> <EnumerationHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryProvider <Provider>k__BackingField;
    internal Action`1<IEnumerable`1<object>> EnumerationHandler { get; internal set; }
    internal IDictionary`2<string, object> Parameters { get; internal set; }
    public Type ElementType { get; }
    public Expression Expression { get; }
    public IQueryProvider Provider { get; }
    public SourceSourceInjectedQuery`2(IQueryable`1<TSource> dataSource, IQueryable`1<TDestination> destQuery, IMapper mapper, IEnumerable`1<ExpressionVisitor> beforeVisitors, IEnumerable`1<ExpressionVisitor> afterVisitors, Action`1<Exception> exceptionHandler, IDictionary`2<string, object> parameters, IEnumerable`1<IEnumerable`1<MemberInfo>> membersToExpand, SourceInjectedQueryInspector inspector);
    internal SourceSourceInjectedQuery`2(IQueryProvider provider, Expression expression, Action`1<IEnumerable`1<object>> enumerationHandler, Action`1<Exception> exceptionHandler);
    public sealed virtual IQueryable`1<TDestination> OnEnumerated(Action`1<IEnumerable`1<object>> enumerationHandler);
    public sealed virtual IQueryable`1<TDestination> AsQueryable();
    [CompilerGeneratedAttribute]
internal Action`1<IEnumerable`1<object>> get_EnumerationHandler();
    [CompilerGeneratedAttribute]
internal void set_EnumerationHandler(Action`1<IEnumerable`1<object>> value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
internal void set_Parameters(IDictionary`2<string, object> value);
    public sealed virtual IEnumerator`1<TDestination> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual IQueryProvider get_Provider();
}
public class AutoMapper.QueryableExtensions.Impl.StringExpressionBinder : object {
    public sealed virtual bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionResolutionResult result);
    public sealed virtual MemberAssignment Build(IConfigurationProvider configuration, PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary`2<ExpressionRequest, int> typePairCount);
    private static MemberAssignment BindStringExpression(PropertyMap propertyMap, ExpressionResolutionResult result);
}
public interface AutoMapper.QueryableExtensions.IProjectionExpression {
    public abstract virtual IQueryable`1<TResult> To(object parameters);
    public abstract virtual IQueryable`1<TResult> To(IDictionary`2<string, object> parameters);
    public abstract virtual IQueryable`1<TResult> To(object parameters, String[] membersToExpand);
    public abstract virtual IQueryable`1<TResult> To(IDictionary`2<string, object> parameters, String[] membersToExpand);
    public abstract virtual IQueryable`1<TResult> To(object parameters, Expression`1[] membersToExpand);
    public abstract virtual IQueryable`1<TResult> To(IDictionary`2<string, object> parameters, Expression`1[] membersToExpand);
}
public class AutoMapper.QueryableExtensions.ProjectionExpression : object {
    private static MethodInfo QueryableSelectMethod;
    private IQueryable _source;
    private IExpressionBuilder _builder;
    public ProjectionExpression(IQueryable source, IExpressionBuilder builder);
    private static ProjectionExpression();
    private static MethodInfo FindQueryableSelectMethod();
    public sealed virtual IQueryable`1<TResult> To(object parameters);
    public sealed virtual IQueryable`1<TResult> To(object parameters, String[] membersToExpand);
    private static IDictionary`2<string, object> GetParameters(object parameters);
    public sealed virtual IQueryable`1<TResult> To(IDictionary`2<string, object> parameters);
    public sealed virtual IQueryable`1<TResult> To(IDictionary`2<string, object> parameters, String[] membersToExpand);
    public sealed virtual IQueryable`1<TResult> To(object parameters, Expression`1[] membersToExpand);
    private IEnumerable`1<IEnumerable`1<MemberInfo>> GetMemberPaths(Type type, String[] membersToExpand);
    private IEnumerable`1<IEnumerable`1<MemberInfo>> GetMemberPaths(Expression`1[] membersToExpand);
    public sealed virtual IQueryable`1<TResult> To(IDictionary`2<string, object> parameters, Expression`1[] membersToExpand);
    internal IQueryable`1<TResult> To(IDictionary`2<string, object> parameters, IEnumerable`1<IEnumerable`1<MemberInfo>> memberPathsToExpand);
}
[ExtensionAttribute]
internal static class AutoMapper.ReflectionHelper : object {
    [ExtensionAttribute]
public static object GetDefaultValue(ParameterInfo parameter);
    [ExtensionAttribute]
public static object MapMember(ResolutionContext context, MemberInfo member, object value, object destination);
    [ExtensionAttribute]
public static object MapMember(ResolutionContext context, MemberInfo member, object value);
    [ExtensionAttribute]
public static bool IsDynamic(object obj);
    [ExtensionAttribute]
public static bool IsDynamic(Type type);
    [ExtensionAttribute]
public static void SetMemberValue(MemberInfo propertyOrField, object target, object value);
    private static ArgumentOutOfRangeException Expected(MemberInfo propertyOrField);
    [ExtensionAttribute]
public static object GetMemberValue(MemberInfo propertyOrField, object target);
    [IteratorStateMachineAttribute("AutoMapper.ReflectionHelper/<GetMemberPath>d__8")]
public static IEnumerable`1<MemberInfo> GetMemberPath(Type type, string fullMemberName);
    private static Type GetCurrentType(MemberInfo member, Type type);
    [ExtensionAttribute]
public static MemberInfo GetFieldOrProperty(LambdaExpression expression);
    public static MemberInfo FindProperty(LambdaExpression lambdaExpression);
    [ExtensionAttribute]
public static Type GetMemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static Type ReplaceItemType(Type targetType, Type oldType, Type newType);
}
public class AutoMapper.ResolutionContext : object {
    private Dictionary`2<object, object> _instanceCache;
    private Dictionary`2<TypePair, int> _typeDepth;
    [CompilerGeneratedAttribute]
private IMappingOperationOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IRuntimeMapper <Mapper>k__BackingField;
    public IMappingOperationOptions Options { get; }
    public Dictionary`2<object, object> InstanceCache { get; }
    private Dictionary`2<TypePair, int> TypeDepth { get; }
    public IRuntimeMapper Mapper { get; }
    public IConfigurationProvider ConfigurationProvider { get; }
    public IDictionary`2<string, object> Items { get; }
    internal bool IsDefault { get; }
    public ResolutionContext(IMappingOperationOptions options, IRuntimeMapper mapper);
    [CompilerGeneratedAttribute]
public IMappingOperationOptions get_Options();
    public Dictionary`2<object, object> get_InstanceCache();
    private void CheckDefault();
    private Dictionary`2<TypePair, int> get_TypeDepth();
    internal void IncrementTypeDepth(TypePair types);
    internal void DecrementTypeDepth(TypePair types);
    internal int GetTypeDepth(TypePair types);
    [CompilerGeneratedAttribute]
public IRuntimeMapper get_Mapper();
    public IConfigurationProvider get_ConfigurationProvider();
    public IDictionary`2<string, object> get_Items();
    internal bool get_IsDefault();
    internal TDestination Map(TSource source, TDestination destination);
    internal object Map(object source, object destination, Type sourceType, Type destinationType);
}
[DebuggerDisplayAttribute("{Type}")]
public class AutoMapper.TypeDetails : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ConstructorInfo> <Constructors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberInfo> <PublicReadAccessors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberInfo> <PublicWriteAccessors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodInfo> <PublicNoArgMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodInfo> <PublicNoArgExtensionMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberInfo> <AllMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DestinationMemberName> <DestinationMemberNames>k__BackingField;
    public Type Type { get; }
    public IEnumerable`1<ConstructorInfo> Constructors { get; }
    public IEnumerable`1<MemberInfo> PublicReadAccessors { get; }
    public IEnumerable`1<MemberInfo> PublicWriteAccessors { get; }
    public IEnumerable`1<MethodInfo> PublicNoArgMethods { get; }
    public IEnumerable`1<MethodInfo> PublicNoArgExtensionMethods { get; }
    public IEnumerable`1<MemberInfo> AllMembers { get; }
    public IEnumerable`1<DestinationMemberName> DestinationMemberNames { get; public set; }
    public TypeDetails(Type type, ProfileMap config);
    [IteratorStateMachineAttribute("AutoMapper.TypeDetails/<PossibleNames>d__1")]
private IEnumerable`1<string> PossibleNames(string memberName, IEnumerable`1<string> prefixes, IEnumerable`1<string> postfixes);
    private IEnumerable`1<string> PostFixes(IEnumerable`1<string> postfixes, string name);
    private Func`2<MemberInfo, bool> MembersToMap(Func`2<PropertyInfo, bool> shouldMapProperty, Func`2<FieldInfo, bool> shouldMapField);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ConstructorInfo> get_Constructors();
    [CompilerGeneratedAttribute]
public IEnumerable`1<MemberInfo> get_PublicReadAccessors();
    [CompilerGeneratedAttribute]
public IEnumerable`1<MemberInfo> get_PublicWriteAccessors();
    [CompilerGeneratedAttribute]
public IEnumerable`1<MethodInfo> get_PublicNoArgMethods();
    [CompilerGeneratedAttribute]
public IEnumerable`1<MethodInfo> get_PublicNoArgExtensionMethods();
    [CompilerGeneratedAttribute]
public IEnumerable`1<MemberInfo> get_AllMembers();
    [CompilerGeneratedAttribute]
public IEnumerable`1<DestinationMemberName> get_DestinationMemberNames();
    [CompilerGeneratedAttribute]
public void set_DestinationMemberNames(IEnumerable`1<DestinationMemberName> value);
    private IEnumerable`1<MethodInfo> BuildPublicNoArgExtensionMethods(IEnumerable`1<MethodInfo> sourceExtensionMethodSearch);
    private static MemberInfo[] BuildPublicReadAccessors(IEnumerable`1<MemberInfo> allMembers);
    private static MemberInfo[] BuildPublicAccessors(IEnumerable`1<MemberInfo> allMembers);
    private IEnumerable`1<MemberInfo> GetAllPublicReadableMembers(Func`2<MemberInfo, bool> membersToMap);
    private IEnumerable`1<MemberInfo> GetAllPublicWritableMembers(Func`2<MemberInfo, bool> membersToMap);
    private static bool PropertyReadable(PropertyInfo propertyInfo);
    private bool FieldReadable(FieldInfo fieldInfo);
    private static bool PropertyWritable(PropertyInfo propertyInfo);
    private bool FieldWritable(FieldInfo fieldInfo);
    private IEnumerable`1<MemberInfo> GetAllPublicMembers(Func`2<PropertyInfo, bool> propertyAvailableFor, Func`2<FieldInfo, bool> fieldAvailableFor, Func`2<MemberInfo, bool> memberAvailableFor);
    private MethodInfo[] BuildPublicNoArgMethods();
    [CompilerGeneratedAttribute]
private bool <BuildPublicNoArgExtensionMethods>b__30_0(MethodInfo method);
}
[ExtensionAttribute]
internal static class AutoMapper.TypeExtensions : object {
    [ExtensionAttribute]
public static bool Has(Type type);
    [ExtensionAttribute]
public static Type GetGenericTypeDefinitionIfGeneric(Type type);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static Type[] GetGenericParameters(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<ConstructorInfo> GetDeclaredConstructors(Type type);
    [ExtensionAttribute]
public static Type CreateType(TypeBuilder type);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetDeclaredMembers(Type type);
    [IteratorStateMachineAttribute("AutoMapper.TypeExtensions/<GetAllMembers>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetAllMembers(Type type);
    [ExtensionAttribute]
public static MemberInfo[] GetMember(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetDeclaredMethods(Type type);
    [ExtensionAttribute]
public static MethodInfo GetDeclaredMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetDeclaredMethod(Type type, string name, Type[] parameters);
    [ExtensionAttribute]
public static ConstructorInfo GetDeclaredConstructor(Type type, Type[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetAllMethods(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetDeclaredProperties(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetDeclaredProperty(Type type, string name);
    [ExtensionAttribute]
public static Object[] GetCustomAttributes(Type type, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsStatic(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static bool IsStatic(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool IsStatic(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool IsPublic(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> PropertiesWithAnInaccessibleSetter(Type type);
    [ExtensionAttribute]
public static bool HasAnInaccessibleSetter(PropertyInfo property);
    [ExtensionAttribute]
public static bool IsPublic(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool IsNotPublic(ConstructorInfo constructorInfo);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, Type other);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsInstanceOfType(Type type, object o);
    [ExtensionAttribute]
public static ConstructorInfo[] GetConstructors(Type type);
    [ExtensionAttribute]
public static PropertyInfo[] GetProperties(Type type);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo propertyInfo, bool ignored);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo propertyInfo, bool ignored);
    [ExtensionAttribute]
public static FieldInfo GetField(Type type, string name);
}
[DebuggerDisplayAttribute("{SourceType.Name} -> {DestinationType.Name}")]
public class AutoMapper.TypeMap : object {
    private List`1<LambdaExpression> _afterMapActions;
    private List`1<LambdaExpression> _beforeMapActions;
    private HashSet`1<TypePair> _includedDerivedTypes;
    private HashSet`1<TypePair> _includedBaseTypes;
    private List`1<PropertyMap> _propertyMaps;
    private List`1<SourceMemberConfig> _sourceMemberConfigs;
    private IList`1<PropertyMap> _inheritedMaps;
    private PropertyMap[] _orderedPropertyMaps;
    private bool _sealed;
    private IList`1<TypeMap> _inheritedTypeMaps;
    [CompilerGeneratedAttribute]
private LambdaExpression <MapExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private TypePair <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorMap <ConstructorMap>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDetails <SourceTypeDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDetails <DestinationTypeDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private ProfileMap <Profile>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <CustomMapper>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <CustomProjection>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <DestinationCtor>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DestinationTypeOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConstructDestinationUsingServiceLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberList <ConfiguredMemberList>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <ConstructExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeConverterType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableConstructorValidation>k__BackingField;
    public LambdaExpression MapExpression { get; private set; }
    public TypePair Types { get; }
    public ConstructorMap ConstructorMap { get; public set; }
    public TypeDetails SourceTypeDetails { get; }
    public TypeDetails DestinationTypeDetails { get; }
    public Type SourceType { get; }
    public Type DestinationType { get; }
    public ProfileMap Profile { get; }
    public LambdaExpression CustomMapper { get; public set; }
    public LambdaExpression CustomProjection { get; public set; }
    public LambdaExpression DestinationCtor { get; public set; }
    public Type DestinationTypeOverride { get; public set; }
    public Type DestinationTypeToUse { get; }
    public bool ConstructDestinationUsingServiceLocator { get; public set; }
    public MemberList ConfiguredMemberList { get; }
    public IEnumerable`1<TypePair> IncludedDerivedTypes { get; }
    public IEnumerable`1<TypePair> IncludedBaseTypes { get; }
    public IEnumerable`1<LambdaExpression> BeforeMapActions { get; }
    public IEnumerable`1<LambdaExpression> AfterMapActions { get; }
    public bool PreserveReferences { get; public set; }
    public LambdaExpression Condition { get; public set; }
    public int MaxDepth { get; public set; }
    public LambdaExpression Substitution { get; public set; }
    public LambdaExpression ConstructExpression { get; public set; }
    public Type TypeConverterType { get; public set; }
    public bool DisableConstructorValidation { get; public set; }
    public TypeMap(TypeDetails sourceType, TypeDetails destinationType, MemberList memberList, ProfileMap profile);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MapExpression();
    [CompilerGeneratedAttribute]
private void set_MapExpression(LambdaExpression value);
    [CompilerGeneratedAttribute]
public TypePair get_Types();
    [CompilerGeneratedAttribute]
public ConstructorMap get_ConstructorMap();
    [CompilerGeneratedAttribute]
public void set_ConstructorMap(ConstructorMap value);
    [CompilerGeneratedAttribute]
public TypeDetails get_SourceTypeDetails();
    [CompilerGeneratedAttribute]
public TypeDetails get_DestinationTypeDetails();
    public Type get_SourceType();
    public Type get_DestinationType();
    [CompilerGeneratedAttribute]
public ProfileMap get_Profile();
    [CompilerGeneratedAttribute]
public LambdaExpression get_CustomMapper();
    [CompilerGeneratedAttribute]
public void set_CustomMapper(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_CustomProjection();
    [CompilerGeneratedAttribute]
public void set_CustomProjection(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_DestinationCtor();
    [CompilerGeneratedAttribute]
public void set_DestinationCtor(LambdaExpression value);
    [CompilerGeneratedAttribute]
public Type get_DestinationTypeOverride();
    [CompilerGeneratedAttribute]
public void set_DestinationTypeOverride(Type value);
    public Type get_DestinationTypeToUse();
    [CompilerGeneratedAttribute]
public bool get_ConstructDestinationUsingServiceLocator();
    [CompilerGeneratedAttribute]
public void set_ConstructDestinationUsingServiceLocator(bool value);
    [CompilerGeneratedAttribute]
public MemberList get_ConfiguredMemberList();
    public IEnumerable`1<TypePair> get_IncludedDerivedTypes();
    public IEnumerable`1<TypePair> get_IncludedBaseTypes();
    public IEnumerable`1<LambdaExpression> get_BeforeMapActions();
    public IEnumerable`1<LambdaExpression> get_AfterMapActions();
    [CompilerGeneratedAttribute]
public bool get_PreserveReferences();
    [CompilerGeneratedAttribute]
public void set_PreserveReferences(bool value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(LambdaExpression value);
    [CompilerGeneratedAttribute]
public int get_MaxDepth();
    [CompilerGeneratedAttribute]
public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_Substitution();
    [CompilerGeneratedAttribute]
public void set_Substitution(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_ConstructExpression();
    [CompilerGeneratedAttribute]
public void set_ConstructExpression(LambdaExpression value);
    [CompilerGeneratedAttribute]
public Type get_TypeConverterType();
    [CompilerGeneratedAttribute]
public void set_TypeConverterType(Type value);
    [CompilerGeneratedAttribute]
public bool get_DisableConstructorValidation();
    [CompilerGeneratedAttribute]
public void set_DisableConstructorValidation(bool value);
    public PropertyMap[] GetPropertyMaps();
    public bool ConstructorParameterMatches(string destinationPropertyName);
    public void AddPropertyMap(MemberInfo destProperty, IEnumerable`1<MemberInfo> resolvers);
    public String[] GetUnmappedPropertyNames();
    public bool PassesCtorValidation();
    public PropertyMap FindOrCreatePropertyMapFor(MemberInfo destinationProperty);
    public void IncludeDerivedTypes(Type derivedSourceType, Type derivedDestinationType);
    public void IncludeBaseTypes(Type baseSourceType, Type baseDestinationType);
    public Type GetDerivedTypeFor(Type derivedSourceType);
    public bool TypeHasBeenIncluded(TypePair derivedTypes);
    public bool HasDerivedTypesToInclude();
    public void AddBeforeMapAction(LambdaExpression beforeMap);
    public void AddAfterMapAction(LambdaExpression afterMap);
    public void Seal(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider);
    public PropertyMap GetExistingPropertyMapFor(MemberInfo destinationProperty);
    public void InheritTypes(TypeMap inheritedTypeMap);
    public SourceMemberConfig FindOrCreateSourceMemberConfigFor(MemberInfo sourceMember);
    public void ApplyInheritedMap(TypeMap inheritedTypeMap);
    public bool ShouldCheckForValid();
    private void ApplyInheritedTypeMap(TypeMap inheritedTypeMap);
    [CompilerGeneratedAttribute]
private string <GetUnmappedPropertyNames>b__99_0(PropertyMap pm);
    [CompilerGeneratedAttribute]
private bool <GetUnmappedPropertyNames>b__99_9(string memberName);
    [CompilerGeneratedAttribute]
private bool <InheritTypes>b__111_0(TypePair includedDerivedType);
}
public class AutoMapper.TypeMapFactory : object {
    public TypeMap CreateTypeMap(Type sourceType, Type destinationType, ProfileMap options, MemberList memberList);
    private bool MapDestinationPropertyToSource(ProfileMap options, TypeDetails sourceTypeInfo, Type destType, Type destMemberType, string destMemberInfo, LinkedList`1<MemberInfo> members);
    private bool MapDestinationCtorToSource(TypeMap typeMap, ConstructorInfo destCtor, TypeDetails sourceTypeInfo, ProfileMap options);
}
public class AutoMapper.TypeMapRegistry : object {
    private IDictionary`2<TypePair, TypeMap> _typeMaps;
    public IEnumerable`1<TypeMap> TypeMaps { get; }
    public IEnumerable`1<TypeMap> get_TypeMaps();
    public void RegisterTypeMap(TypeMap typeMap);
    public TypeMap GetTypeMap(TypePair typePair);
}
[DebuggerDisplayAttribute("{SourceType.Name}, {DestinationType.Name}")]
public class AutoMapper.TypePair : ValueType {
    private int _hashcode;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DestinationType>k__BackingField;
    public Type SourceType { get; }
    public Type DestinationType { get; }
    public TypePair(Type sourceType, Type destinationType);
    public static bool op_Equality(TypePair left, TypePair right);
    public static bool op_Inequality(TypePair left, TypePair right);
    public static TypePair Create(TSource source, Type sourceType, Type destinationType);
    public static TypePair Create(TSource source, TDestination destination, Type sourceType, Type destinationType);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public Type get_DestinationType();
    public sealed virtual bool Equals(TypePair other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Nullable`1<TypePair> GetOpenGenericTypePair();
    public IEnumerable`1<TypePair> GetRelatedTypePairs();
    [IteratorStateMachineAttribute("AutoMapper.TypePair/<GetAllTypes>d__17")]
private IEnumerable`1<Type> GetAllTypes(Type type);
    [IteratorStateMachineAttribute("AutoMapper.TypePair/<GetTypeInheritance>d__18")]
private static IEnumerable`1<Type> GetTypeInheritance(Type type);
}
public class AutoMapper.ValueResolverConfiguration : object {
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SourceMember>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceMemberName>k__BackingField;
    public object Instance { get; }
    public Type Type { get; }
    public LambdaExpression SourceMember { get; public set; }
    public string SourceMemberName { get; public set; }
    public ValueResolverConfiguration(Type type);
    public ValueResolverConfiguration(object instance);
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public LambdaExpression get_SourceMember();
    [CompilerGeneratedAttribute]
public void set_SourceMember(LambdaExpression value);
    [CompilerGeneratedAttribute]
public string get_SourceMemberName();
    [CompilerGeneratedAttribute]
public void set_SourceMemberName(string value);
}
