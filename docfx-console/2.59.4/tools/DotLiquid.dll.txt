public class DotLiquid.ActivatorTagFactory : object {
    private Type _tagType;
    private string _tagName;
    public string TagName { get; }
    public ActivatorTagFactory(Type tagType, string tagName);
    public sealed virtual string get_TagName();
    public sealed virtual Tag Create();
}
public class DotLiquid.Block : Tag {
    private static Regex IsTag;
    private static Regex IsVariable;
    private static Regex ContentOfVariable;
    internal static Regex FullToken;
    protected string BlockDelimiter { get; }
    private string BlockName { get; }
    private static Block();
    protected virtual void Parse(List`1<string> tokens);
    public virtual void EndTag();
    public virtual void UnknownTag(string tag, string markup, List`1<string> tokens);
    protected virtual string get_BlockDelimiter();
    private string get_BlockName();
    public Variable CreateVariable(string token);
    public virtual void Render(Context context, TextWriter result);
    protected virtual void AssertMissingDelimitation();
    protected void RenderAll(List`1<object> list, Context context, TextWriter result);
}
public class DotLiquid.Condition : object {
    public static Dictionary`2<string, ConditionOperatorDelegate> Operators;
    private string _childRelation;
    private Condition _childCondition;
    [CompilerGeneratedAttribute]
private string <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<object> <Attachment>k__BackingField;
    public string Left { get; public set; }
    public string Operator { get; public set; }
    public string Right { get; public set; }
    public List`1<object> Attachment { get; private set; }
    public bool IsElse { get; }
    public Condition(string left, string operator, string right);
    private static Condition();
    [CompilerGeneratedAttribute]
public string get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(string value);
    [CompilerGeneratedAttribute]
public string get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(string value);
    [CompilerGeneratedAttribute]
public string get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(string value);
    [CompilerGeneratedAttribute]
public List`1<object> get_Attachment();
    [CompilerGeneratedAttribute]
private void set_Attachment(List`1<object> value);
    public virtual bool get_IsElse();
    public virtual bool Evaluate(Context context);
    public void Or(Condition condition);
    public void And(Condition condition);
    public List`1<object> Attach(List`1<object> attachment);
    public virtual string ToString();
    private static bool EqualVariables(object left, object right);
    private static bool InterpretCondition(string left, string right, string op, Context context);
}
public class DotLiquid.ConditionOperatorDelegate : MulticastDelegate {
    public ConditionOperatorDelegate(object object, IntPtr method);
    public virtual bool Invoke(object left, object right);
    public virtual IAsyncResult BeginInvoke(object left, object right, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class DotLiquid.Context : object {
    private static Regex SingleQuotedRegex;
    private static Regex DoubleQuotedRegex;
    private static Regex IntegerRegex;
    private static Regex RangeRegex;
    private static Regex FloatRegex;
    private static Regex SquareBracketedRegex;
    private static Regex VariableParserRegex;
    private bool _rethrowErrors;
    private Strainer _strainer;
    [CompilerGeneratedAttribute]
private List`1<Hash> <Environments>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Hash> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private Hash <Registers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Exception> <Errors>k__BackingField;
    public List`1<Hash> Environments { get; private set; }
    public List`1<Hash> Scopes { get; private set; }
    public Hash Registers { get; private set; }
    public List`1<Exception> Errors { get; private set; }
    public Strainer Strainer { get; }
    public object Item { get; public set; }
    public Context(List`1<Hash> environments, Hash outerScope, Hash registers, bool rethrowErrors);
    private static Context();
    [CompilerGeneratedAttribute]
public List`1<Hash> get_Environments();
    [CompilerGeneratedAttribute]
private void set_Environments(List`1<Hash> value);
    [CompilerGeneratedAttribute]
public List`1<Hash> get_Scopes();
    [CompilerGeneratedAttribute]
private void set_Scopes(List`1<Hash> value);
    [CompilerGeneratedAttribute]
public Hash get_Registers();
    [CompilerGeneratedAttribute]
private void set_Registers(Hash value);
    [CompilerGeneratedAttribute]
public List`1<Exception> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(List`1<Exception> value);
    public Strainer get_Strainer();
    public void AddFilter(string filterName, Func`2<TIn, TOut> func);
    public void AddFilter(string filterName, Func`3<TIn, TIn2, TOut> func);
    public void AddFilters(IEnumerable`1<Type> filters);
    public void AddFilters(Type[] filters);
    public string HandleError(Exception ex);
    public object Invoke(string method, List`1<object> args);
    public void Push(Hash newScope);
    public void Merge(Hash newScopes);
    public Hash Pop();
    public void Stack(Hash newScope, Action callback);
    public void Stack(Action callback);
    public void ClearInstanceAssigns();
    public object get_Item(string key, bool notifyNotFound);
    public void set_Item(string key, bool notifyNotFound, object value);
    public bool HasKey(string key);
    private object Resolve(string key, bool notifyNotFound);
    private object FindVariable(string key);
    private object Variable(string markup, bool notifyNotFound);
    private static bool IsHashOrArrayLikeObject(object obj, object part);
    private object LookupAndEvaluate(object obj, object key);
    private static object Liquidize(object obj);
    private void SquashInstanceAssignsWithEnvironments();
}
[ExtensionAttribute]
internal static class DotLiquid.DictionaryExtensions : object {
    [ExtensionAttribute]
public static V TryAdd(IDictionary`2<K, V> dic, K key, Func`1<V> factory);
}
public class DotLiquid.Document : Block {
    protected string BlockDelimiter { get; }
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    protected virtual string get_BlockDelimiter();
    protected virtual void AssertMissingDelimitation();
    public virtual void Render(Context context, TextWriter result);
}
public abstract class DotLiquid.Drop : DropBase {
    internal virtual object GetObject();
    internal virtual TypeResolution CreateTypeResolution(Type type);
}
[DefaultMemberAttribute("Item")]
public abstract class DotLiquid.DropBase : object {
    private TypeResolution _resolution;
    [CompilerGeneratedAttribute]
private Context <Context>k__BackingField;
    internal TypeResolution TypeResolution { get; }
    public Context Context { get; public set; }
    public object Item { get; }
    internal TypeResolution get_TypeResolution();
    [CompilerGeneratedAttribute]
public Context get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Context(Context value);
    public sealed virtual object get_Item(object method);
    public virtual bool ContainsKey(object name);
    public virtual object ToLiquid();
    internal abstract virtual object GetObject();
    internal abstract virtual TypeResolution CreateTypeResolution(Type type);
    public virtual object BeforeMethod(string method);
    public object InvokeDrop(object name);
}
public class DotLiquid.DropProxy : DropBase {
    private String[] _allowedMembers;
    private object _proxiedObject;
    private Func`2<object, object> _value;
    public DropProxy(object obj, String[] allowedMembers);
    public DropProxy(object obj, String[] allowedMembers, Func`2<object, object> value);
    public virtual object ConvertToValueType();
    internal virtual object GetObject();
    internal virtual TypeResolution CreateTypeResolution(Type type);
    [CompilerGeneratedAttribute]
private bool <CreateTypeResolution>b__7_0(MemberInfo mi);
}
public class DotLiquid.ElseCondition : Condition {
    public bool IsElse { get; }
    public virtual bool get_IsElse();
    public virtual bool Evaluate(Context context);
}
public class DotLiquid.Exceptions.ArgumentException : LiquidException {
    public ArgumentException(string message, String[] args);
}
public class DotLiquid.Exceptions.BreakInterrupt : InterruptException {
}
public class DotLiquid.Exceptions.ContextException : LiquidException {
    public ContextException(string message, String[] args);
}
public class DotLiquid.Exceptions.ContinueInterrupt : InterruptException {
}
public class DotLiquid.Exceptions.FileSystemException : LiquidException {
    public FileSystemException(string message, String[] args);
}
public class DotLiquid.Exceptions.FilterNotFoundException : LiquidException {
    public FilterNotFoundException(string message, FilterNotFoundException innerException);
    public FilterNotFoundException(string message, String[] args);
    public FilterNotFoundException(string message);
}
public class DotLiquid.Exceptions.InterruptException : LiquidException {
    public InterruptException(string message);
}
public abstract class DotLiquid.Exceptions.LiquidException : ApplicationException {
    protected LiquidException(string message, Exception innerException);
    protected LiquidException(string message);
}
public class DotLiquid.Exceptions.StackLevelException : LiquidException {
    public StackLevelException(string message);
}
public class DotLiquid.Exceptions.SyntaxException : LiquidException {
    public SyntaxException(string message, String[] args);
}
public class DotLiquid.Exceptions.VariableNotFoundException : LiquidException {
    public VariableNotFoundException(string message, String[] args);
    public VariableNotFoundException(string message);
}
public class DotLiquid.FileSystems.BlankFileSystem : object {
    public sealed virtual string ReadTemplateFile(Context context, string templateName);
}
public class DotLiquid.FileSystems.EmbeddedFileSystem : object {
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    protected Assembly Assembly { get; private set; }
    public string Root { get; private set; }
    public EmbeddedFileSystem(Assembly assembly, string root);
    [CompilerGeneratedAttribute]
protected Assembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(Assembly value);
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
private void set_Root(string value);
    public sealed virtual string ReadTemplateFile(Context context, string templateName);
    public string FullPath(string templatePath);
}
public interface DotLiquid.FileSystems.IFileSystem {
    public abstract virtual string ReadTemplateFile(Context context, string templateName);
}
public interface DotLiquid.FileSystems.ITemplateFileSystem {
    public abstract virtual Template GetTemplate(Context context, string templateName);
}
public class DotLiquid.FileSystems.LocalFileSystem : object {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    public string Root { get; public set; }
    public LocalFileSystem(string root);
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(string value);
    public sealed virtual string ReadTemplateFile(Context context, string templateName);
    public string FullPath(string templatePath);
}
[DefaultMemberAttribute("Item")]
public class DotLiquid.Hash : object {
    private static ConcurrentDictionary`2<Type, Action`2<object, Hash>> mapperCache;
    private Func`3<Hash, string, object> _lambda;
    private Dictionary`2<string, object> _nestedDictionary;
    private object _defaultValue;
    private object System.Collections.IDictionary.Item { get; private set; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    public ICollection`1<object> Values { get; }
    public Hash(object defaultValue);
    public Hash(Func`3<Hash, string, object> lambda);
    private static Hash();
    public static Hash FromAnonymousObject(object anonymousObject);
    private static void FromAnonymousObject40(object anonymousObject, Hash hash);
    private static Action`2<object, Hash> GetObjToDictionaryMapper(Type type);
    private static Action`2<object, Hash> GenerateMapper(Type type);
    public static Hash FromDictionary(IDictionary`2<string, object> dictionary);
    public void Merge(IDictionary`2<string, object> otherValues);
    private object GetValue(string key);
    public T Get(string key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    public sealed virtual void Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual ICollection`1<string> get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
}
public interface DotLiquid.IContextAware {
    unknown Context Context {public set; }
    public abstract virtual void set_Context(Context value);
}
[DefaultMemberAttribute("Item")]
public interface DotLiquid.IIndexable {
    public object Item { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual bool ContainsKey(object key);
}
public interface DotLiquid.ILiquidizable {
    public abstract virtual object ToLiquid();
}
internal interface DotLiquid.IRenderable {
    public abstract virtual void Render(Context context, TextWriter result);
}
public interface DotLiquid.ITagFactory {
    public string TagName { get; }
    public abstract virtual string get_TagName();
    public abstract virtual Tag Create();
}
public interface DotLiquid.IValueTypeConvertible {
    public abstract virtual object ConvertToValueType();
}
public static class DotLiquid.Liquid : object {
    internal static ResourceManager ResourceManager;
    public static string FilterSeparator;
    public static string ArgumentSeparator;
    public static string FilterArgumentSeparator;
    public static string VariableAttributeSeparator;
    public static string TagStart;
    public static string TagEnd;
    public static string VariableSignature;
    public static string VariableSegment;
    public static string VariableStart;
    public static string VariableEnd;
    public static string VariableIncompleteEnd;
    public static string QuotedString;
    public static string QuotedFragment;
    public static string QuotedAssignFragment;
    public static string StrictQuotedFragment;
    public static string FirstFilterArgument;
    public static string OtherFilterArgument;
    public static string SpacelessFilter;
    public static string Expression;
    public static string TagAttributes;
    public static string AnyStartingTag;
    public static string PartialTemplateParser;
    public static string TemplateParser;
    public static string VariableParser;
    public static string LiteralShorthand;
    public static string CommentShorthand;
    public static bool UseRubyDateFormat;
    private static Liquid();
}
[AttributeUsageAttribute("4")]
public class DotLiquid.LiquidTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <AllowedMembers>k__BackingField;
    public String[] AllowedMembers { get; private set; }
    public LiquidTypeAttribute(String[] allowedMembers);
    [CompilerGeneratedAttribute]
public String[] get_AllowedMembers();
    [CompilerGeneratedAttribute]
private void set_AllowedMembers(String[] value);
}
public class DotLiquid.NamingConventions.CSharpNamingConvention : object {
    public StringComparer StringComparer { get; }
    public sealed virtual StringComparer get_StringComparer();
    public sealed virtual string GetMemberName(string name);
    public sealed virtual bool OperatorEquals(string testedOperator, string referenceOperator);
    private static string UpperFirstLetter(string word);
    private static string LowerFirstLetter(string word);
}
public interface DotLiquid.NamingConventions.INamingConvention {
    public StringComparer StringComparer { get; }
    public abstract virtual StringComparer get_StringComparer();
    public abstract virtual string GetMemberName(string name);
    public abstract virtual bool OperatorEquals(string testedOperator, string referenceOperator);
}
public class DotLiquid.NamingConventions.RubyNamingConvention : object {
    private static Regex _regex1;
    private static Regex _regex2;
    public StringComparer StringComparer { get; }
    private static RubyNamingConvention();
    public sealed virtual StringComparer get_StringComparer();
    public sealed virtual string GetMemberName(string name);
    public sealed virtual bool OperatorEquals(string testedOperator, string referenceOperator);
}
public class DotLiquid.Proc : MulticastDelegate {
    public Proc(object object, IntPtr method);
    public virtual object Invoke(Context context);
    public virtual IAsyncResult BeginInvoke(Context context, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class DotLiquid.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AssignTagSyntaxException { get; }
    internal static string BlankFileSystemDoesNotAllowIncludesException { get; }
    internal static string BlockTagAlreadyDefinedException { get; }
    internal static string BlockTagNoElseException { get; }
    internal static string BlockTagNoEndException { get; }
    internal static string BlockTagNotClosedException { get; }
    internal static string BlockTagNotTerminatedException { get; }
    internal static string BlockTagSyntaxException { get; }
    internal static string BlockUnknownTagException { get; }
    internal static string BlockVariableNotTerminatedException { get; }
    internal static string CaptureTagSyntaxException { get; }
    internal static string CaseTagElseSyntaxException { get; }
    internal static string CaseTagSyntaxException { get; }
    internal static string CaseTagWhenSyntaxException { get; }
    internal static string ConditionUnknownOperatorException { get; }
    internal static string ContextLiquidError { get; }
    internal static string ContextLiquidSyntaxError { get; }
    internal static string ContextObjectInvalidException { get; }
    internal static string ContextStackException { get; }
    internal static string CycleTagSyntaxException { get; }
    internal static string DropWrongNamingConventionMessage { get; }
    internal static string ExtendsTagCanBeUsedOneException { get; }
    internal static string ExtendsTagMustBeFirstTagException { get; }
    internal static string ExtendsTagSyntaxException { get; }
    internal static string ExtendsTagUnallowedTagsException { get; }
    internal static string ForTagSyntaxException { get; }
    internal static string IfTagSyntaxException { get; }
    internal static string IncludeTagSyntaxException { get; }
    internal static string LocalFileSystemIllegalTemplateNameException { get; }
    internal static string LocalFileSystemIllegalTemplatePathException { get; }
    internal static string LocalFileSystemTemplateNotFoundException { get; }
    internal static string StrainerFilterHasNoValueException { get; }
    internal static string TableRowTagSyntaxException { get; }
    internal static string VariableFilterNotFoundException { get; }
    internal static string VariableNotFoundException { get; }
    internal static string WeakTableKeyNotFoundException { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AssignTagSyntaxException();
    internal static string get_BlankFileSystemDoesNotAllowIncludesException();
    internal static string get_BlockTagAlreadyDefinedException();
    internal static string get_BlockTagNoElseException();
    internal static string get_BlockTagNoEndException();
    internal static string get_BlockTagNotClosedException();
    internal static string get_BlockTagNotTerminatedException();
    internal static string get_BlockTagSyntaxException();
    internal static string get_BlockUnknownTagException();
    internal static string get_BlockVariableNotTerminatedException();
    internal static string get_CaptureTagSyntaxException();
    internal static string get_CaseTagElseSyntaxException();
    internal static string get_CaseTagSyntaxException();
    internal static string get_CaseTagWhenSyntaxException();
    internal static string get_ConditionUnknownOperatorException();
    internal static string get_ContextLiquidError();
    internal static string get_ContextLiquidSyntaxError();
    internal static string get_ContextObjectInvalidException();
    internal static string get_ContextStackException();
    internal static string get_CycleTagSyntaxException();
    internal static string get_DropWrongNamingConventionMessage();
    internal static string get_ExtendsTagCanBeUsedOneException();
    internal static string get_ExtendsTagMustBeFirstTagException();
    internal static string get_ExtendsTagSyntaxException();
    internal static string get_ExtendsTagUnallowedTagsException();
    internal static string get_ForTagSyntaxException();
    internal static string get_IfTagSyntaxException();
    internal static string get_IncludeTagSyntaxException();
    internal static string get_LocalFileSystemIllegalTemplateNameException();
    internal static string get_LocalFileSystemIllegalTemplatePathException();
    internal static string get_LocalFileSystemTemplateNotFoundException();
    internal static string get_StrainerFilterHasNoValueException();
    internal static string get_TableRowTagSyntaxException();
    internal static string get_VariableFilterNotFoundException();
    internal static string get_VariableNotFoundException();
    internal static string get_WeakTableKeyNotFoundException();
}
public class DotLiquid.RenderParameters : object {
    [CompilerGeneratedAttribute]
private Context <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Hash <LocalVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private Hash <Registers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RethrowErrors>k__BackingField;
    public Context Context { get; public set; }
    public Hash LocalVariables { get; public set; }
    public IEnumerable`1<Type> Filters { get; public set; }
    public Hash Registers { get; public set; }
    public bool RethrowErrors { get; public set; }
    [CompilerGeneratedAttribute]
public Context get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(Context value);
    [CompilerGeneratedAttribute]
public Hash get_LocalVariables();
    [CompilerGeneratedAttribute]
public void set_LocalVariables(Hash value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_Filters();
    [CompilerGeneratedAttribute]
public void set_Filters(IEnumerable`1<Type> value);
    [CompilerGeneratedAttribute]
public Hash get_Registers();
    [CompilerGeneratedAttribute]
public void set_Registers(Hash value);
    [CompilerGeneratedAttribute]
public bool get_RethrowErrors();
    [CompilerGeneratedAttribute]
public void set_RethrowErrors(bool value);
    internal void Evaluate(Template template, Context& context, Hash& registers, IEnumerable`1& filters);
    public static RenderParameters FromContext(Context context);
}
public static class DotLiquid.StandardFilters : object {
    public static int Size(object input);
    public static string Slice(string input, int start, int len);
    public static string Downcase(string input);
    public static string Upcase(string input);
    public static string UrlEncode(string input);
    public static string Capitalize(string input);
    public static string Escape(string input);
    public static string H(string input);
    public static string Truncate(string input, int length, string truncateString);
    public static string TruncateWords(string input, int words, string truncateString);
    public static String[] Split(string input, string pattern);
    public static string StripHtml(string input);
    public static string Currency(object input, string cultureInfo);
    public static string StripNewlines(string input);
    public static string Join(IEnumerable input, string glue);
    public static IEnumerable Sort(object input, string property);
    public static IEnumerable Map(IEnumerable input, string property);
    public static string Replace(string input, string string, string replacement);
    public static string ReplaceFirst(string input, string string, string replacement);
    public static string Remove(string input, string string);
    public static string RemoveFirst(string input, string string);
    public static string Append(string input, string string);
    public static string Prepend(string input, string string);
    public static string NewlineToBr(string input);
    public static string Date(object input, string format);
    public static object First(IEnumerable array);
    public static object Last(IEnumerable array);
    public static object Plus(object input, object operand);
    public static object Minus(object input, object operand);
    public static object Times(object input, object operand);
    public static object Round(object input, object places);
    public static object DividedBy(object input, object operand);
    public static object Modulo(object input, object operand);
    public static string Default(string input, string defaultValue);
    private static bool IsReal(object o);
    private static object DoMathsOperation(object input, object operand, Func`3<Expression, Expression, BinaryExpression> operation);
}
public class DotLiquid.Strainer : object {
    private static Dictionary`2<string, Type> Filters;
    private static Dictionary`2<string, Tuple`2<object, MethodInfo>> FilterFuncs;
    private Context _context;
    private Dictionary`2<string, IList`1<Tuple`2<object, MethodInfo>>> _methods;
    public IEnumerable`1<MethodInfo> Methods { get; }
    public Strainer(Context context);
    private static Strainer();
    public static void GlobalFilter(Type filter);
    public static void GlobalFilter(string rawName, object target, MethodInfo methodInfo);
    public static Strainer Create(Context context);
    public IEnumerable`1<MethodInfo> get_Methods();
    public void Extend(Type type);
    public void AddFunction(string rawName, Func`2<TIn, TOut> func);
    public void AddFunction(string rawName, Func`3<TIn, TIn2, TOut> func);
    public void AddMethodInfo(string rawName, object target, MethodInfo method);
    public bool RespondTo(string method);
    public object Invoke(string method, List`1<object> args);
}
[ExtensionAttribute]
internal static class DotLiquid.StringExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string s);
}
public class DotLiquid.Tag : object {
    [CompilerGeneratedAttribute]
private List`1<object> <NodeList>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Markup>k__BackingField;
    public List`1<object> NodeList { get; protected set; }
    protected string TagName { get; private set; }
    protected string Markup { get; private set; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public List`1<object> get_NodeList();
    [CompilerGeneratedAttribute]
protected void set_NodeList(List`1<object> value);
    [CompilerGeneratedAttribute]
protected string get_TagName();
    [CompilerGeneratedAttribute]
private void set_TagName(string value);
    [CompilerGeneratedAttribute]
protected string get_Markup();
    [CompilerGeneratedAttribute]
private void set_Markup(string value);
    internal virtual void AssertTagRulesViolation(List`1<object> rootNodeList);
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    protected virtual void Parse(List`1<string> tokens);
    public string get_Name();
    public virtual void Render(Context context, TextWriter result);
    internal string Render(Context context);
}
public class DotLiquid.Tags.Assign : Tag {
    private static Regex Syntax;
    private string _to;
    private Variable _from;
    private static Assign();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Block : Block {
    private static Regex Syntax;
    [CompilerGeneratedAttribute]
private string <BlockName>k__BackingField;
    internal string BlockName { get; internal set; }
    private static Block();
    [CompilerGeneratedAttribute]
internal string get_BlockName();
    [CompilerGeneratedAttribute]
internal void set_BlockName(string value);
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    internal virtual void AssertTagRulesViolation(List`1<object> rootNodeList);
    public virtual void Render(Context context, TextWriter result);
    internal List`1<object> GetNodeList(BlockRenderState blockState);
    public void AddParent(Dictionary`2<Block, Block> parents, List`1<object> nodeList);
    public void CallSuper(Context context, TextWriter result);
}
public class DotLiquid.Tags.BlockDrop : Drop {
    private Block _block;
    private TextWriter _result;
    public BlockDrop(Block block, TextWriter result);
    public void Super();
}
internal class DotLiquid.Tags.BlockRenderState : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<Block, Block> <Parents>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Block, List`1<object>> <NodeLists>k__BackingField;
    public Dictionary`2<Block, Block> Parents { get; private set; }
    public Dictionary`2<Block, List`1<object>> NodeLists { get; private set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<Block, Block> get_Parents();
    [CompilerGeneratedAttribute]
private void set_Parents(Dictionary`2<Block, Block> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<Block, List`1<object>> get_NodeLists();
    [CompilerGeneratedAttribute]
private void set_NodeLists(Dictionary`2<Block, List`1<object>> value);
    public List`1<object> GetNodeList(Block block);
    public static BlockRenderState Find(Context context);
}
public class DotLiquid.Tags.Break : Tag {
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Capture : Block {
    private static Regex Syntax;
    private string _to;
    private static Capture();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Case : Block {
    private static Regex Syntax;
    private static Regex WhenSyntax;
    private List`1<Condition> _blocks;
    private string _left;
    private static Case();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void UnknownTag(string tag, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    private void RecordWhenCondition(string markup);
    private void RecordElseCondition(string markup);
}
public class DotLiquid.Tags.Comment : Block {
    private static Regex ShortHandRegex;
    private static Comment();
    public static string FromShortHand(string string);
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Continue : Tag {
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Cycle : Tag {
    private static Regex SimpleSyntax;
    private static Regex NamedSyntax;
    private static Regex QuotedFragmentRegex;
    private String[] _variables;
    private string _name;
    private static Cycle();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    private static String[] VariablesFromString(string markup);
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Extends : Block {
    private static Regex Syntax;
    private string _templateName;
    private static Extends();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    internal virtual void AssertTagRulesViolation(List`1<object> rootNodeList);
    protected virtual void AssertMissingDelimitation();
    public virtual void Render(Context context, TextWriter result);
    public bool IsExtending(Template template);
    private List`1<Block> FindBlocks(object node, List`1<Block> blocks);
}
public class DotLiquid.Tags.For : Block {
    private static Regex Syntax;
    private string _variableName;
    private string _collectionName;
    private string _name;
    private bool _reversed;
    private Dictionary`2<string, string> _attributes;
    private static For();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    private static List`1<object> SliceCollectionUsingEach(IEnumerable collection, int from, Nullable`1<int> to);
    private void BuildContext(Context context, string parent, string key, object value);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(string key, string value);
}
public class DotLiquid.Tags.Html.TableRow : Block {
    private static Regex Syntax;
    private string _variableName;
    private string _collectionName;
    private Dictionary`2<string, string> _attributes;
    private static TableRow();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(string key, string value);
}
public class DotLiquid.Tags.If : Block {
    private string SyntaxHelp;
    private string TooMuchConditionsHelp;
    private static Regex Syntax;
    private static string ExpressionsAndOperators;
    private static Regex ExpressionsAndOperatorsRegex;
    [CompilerGeneratedAttribute]
private List`1<Condition> <Blocks>k__BackingField;
    protected List`1<Condition> Blocks { get; private set; }
    private static If();
    [CompilerGeneratedAttribute]
protected List`1<Condition> get_Blocks();
    [CompilerGeneratedAttribute]
private void set_Blocks(List`1<Condition> value);
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void UnknownTag(string tag, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    private void PushBlock(string tag, string markup);
}
public class DotLiquid.Tags.IfChanged : Block {
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Include : Block {
    private static Regex Syntax;
    private string _templateName;
    private string _variableName;
    private Dictionary`2<string, string> _attributes;
    private static Include();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    protected virtual void Parse(List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(string key, string value);
}
public class DotLiquid.Tags.Literal : Block {
    private static Regex LiteralRegex;
    private static Literal();
    public static string FromShortHand(string string);
    protected virtual void Parse(List`1<string> tokens);
}
public class DotLiquid.Tags.Raw : Block {
    protected virtual void Parse(List`1<string> tokens);
}
public class DotLiquid.Tags.Unless : If {
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Template : object {
    public static INamingConvention NamingConvention;
    [CompilerGeneratedAttribute]
private static IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <DefaultIsThreadSafe>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, Tuple`2<ITagFactory, Type>> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <RegexTimeOut>k__BackingField;
    private static Dictionary`2<Type, Func`2<object, object>> SafeTypeTransformers;
    private static Dictionary`2<Type, Func`2<object, object>> ValueTypeTransformers;
    private Hash _registers;
    private Hash _assigns;
    private Hash _instanceAssigns;
    private List`1<Exception> _errors;
    private Nullable`1<bool> _isThreadSafe;
    [CompilerGeneratedAttribute]
private Document <Root>k__BackingField;
    public static IFileSystem FileSystem { get; public set; }
    public static bool DefaultIsThreadSafe { get; public set; }
    private static Dictionary`2<string, Tuple`2<ITagFactory, Type>> Tags { get; private set; }
    public static TimeSpan RegexTimeOut { get; public set; }
    public Document Root { get; public set; }
    public Hash Registers { get; }
    public Hash Assigns { get; }
    public Hash InstanceAssigns { get; }
    public List`1<Exception> Errors { get; }
    public bool IsThreadSafe { get; }
    private static Template();
    [CompilerGeneratedAttribute]
public static IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
public static void set_FileSystem(IFileSystem value);
    [CompilerGeneratedAttribute]
public static bool get_DefaultIsThreadSafe();
    [CompilerGeneratedAttribute]
public static void set_DefaultIsThreadSafe(bool value);
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, Tuple`2<ITagFactory, Type>> get_Tags();
    [CompilerGeneratedAttribute]
private static void set_Tags(Dictionary`2<string, Tuple`2<ITagFactory, Type>> value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_RegexTimeOut();
    [CompilerGeneratedAttribute]
public static void set_RegexTimeOut(TimeSpan value);
    public static void RegisterTag(string name);
    public static void RegisterTagFactory(ITagFactory tagFactory);
    public static Type GetTagType(string name);
    internal static Tag CreateTag(string name);
    public static void RegisterFilter(Type filter);
    public static void RegisterSafeType(Type type, String[] allowedMembers);
    public static void RegisterSafeType(Type type, String[] allowedMembers, Func`2<object, object> func);
    public static void RegisterSafeType(Type type, Func`2<object, object> func);
    public static void RegisterValueTypeTransformer(Type type, Func`2<object, object> func);
    public static Func`2<object, object> GetValueTypeTransformer(Type type);
    public static Func`2<object, object> GetSafeTypeTransformer(Type type);
    public static Template Parse(string source);
    [CompilerGeneratedAttribute]
public Document get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(Document value);
    public Hash get_Registers();
    public Hash get_Assigns();
    public Hash get_InstanceAssigns();
    public List`1<Exception> get_Errors();
    public bool get_IsThreadSafe();
    internal Template ParseInternal(string source);
    public void MakeThreadSafe();
    public string Render();
    public string Render(Hash localVariables);
    public string Render(RenderParameters parameters);
    public void Render(TextWriter result, RenderParameters parameters);
    public void Render(Stream stream, RenderParameters parameters);
    private void RenderInternal(TextWriter result, RenderParameters parameters);
    internal static List`1<string> Tokenize(string source);
}
internal class DotLiquid.TypeResolution : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MethodInfo> <CachedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, PropertyInfo> <CachedProperties>k__BackingField;
    public Dictionary`2<string, MethodInfo> CachedMethods { get; private set; }
    public Dictionary`2<string, PropertyInfo> CachedProperties { get; private set; }
    public TypeResolution(Type type, Func`2<MemberInfo, bool> filterMemberCallback);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MethodInfo> get_CachedMethods();
    [CompilerGeneratedAttribute]
private void set_CachedMethods(Dictionary`2<string, MethodInfo> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, PropertyInfo> get_CachedProperties();
    [CompilerGeneratedAttribute]
private void set_CachedProperties(Dictionary`2<string, PropertyInfo> value);
    private Dictionary`2<string, T> GetMemberDictionary(IEnumerable`1<T> members, Func`2<T, bool> filterMemberCallback);
    private static IEnumerable`1<PropertyInfo> GetPropertiesWithoutDuplicateNames(Type type, Func`2<PropertyInfo, bool> predicate);
    private static IEnumerable`1<MethodInfo> GetMethodsWithoutDuplicateNames(Type type, Func`2<MethodInfo, bool> predicate);
    private static IEnumerable`1<MemberInfo> GetMembersWithoutDuplicateNames(ICollection`1<MemberInfo> members);
}
internal static class DotLiquid.TypeResolutionCache : object {
    [ThreadStaticAttribute]
private static WeakTable`2<Type, TypeResolution> _cache;
    public static WeakTable`2<Type, TypeResolution> Instance { get; }
    public static WeakTable`2<Type, TypeResolution> get_Instance();
}
[ExtensionAttribute]
public static class DotLiquid.Util.EnumerableExtensionMethods : object {
    [IteratorStateMachineAttribute("DotLiquid.Util.EnumerableExtensionMethods/<Flatten>d__0")]
[ExtensionAttribute]
public static IEnumerable Flatten(IEnumerable array);
    [ExtensionAttribute]
public static void EachWithIndex(IEnumerable`1<object> array, Action`2<object, int> callback);
}
public static class DotLiquid.Util.ExpressionUtility : object {
    public static Delegate CreateExpression(Func`3<Expression, Expression, BinaryExpression> body, Type leftType, Type rightType, Type resultType, bool castArgsToResultOnFailure);
}
[ExtensionAttribute]
public static class DotLiquid.Util.ListExtensionMethods : object {
    [ExtensionAttribute]
public static T TryGetAtIndex(List`1<T> list, int index);
    [ExtensionAttribute]
public static T TryGetAtIndexReverse(List`1<T> list, int rindex);
    [ExtensionAttribute]
public static T Shift(List`1<T> list);
    [ExtensionAttribute]
public static T Pop(List`1<T> list);
}
[ExtensionAttribute]
public static class DotLiquid.Util.ObjectExtensionMethods : object {
    [ExtensionAttribute]
public static bool RespondTo(object value, string member, bool ensureNoParameters);
    [ExtensionAttribute]
public static object Send(object value, string member, Object[] parameters);
}
public static class DotLiquid.Util.R : object {
    public static string Q(string regex);
    public static Regex B(string format, String[] args);
    public static Regex C(string pattern, RegexOptions options);
    public static List`1<string> Scan(string input, Regex regex);
    [ObsoleteAttribute("Use Scan(string, Regex) instead.")]
public static List`1<string> Scan(string input, string pattern);
    public static void Scan(string input, string pattern, Action`2<string, string> callback);
}
internal static class DotLiquid.Util.Range : object {
    internal static long Succ(long val);
    internal static int Succ(int val);
    internal static short Succ(short val);
    internal static sbyte Succ(sbyte val);
    internal static ulong Succ(ulong val);
    internal static UInt32 Succ(UInt32 val);
    internal static ushort Succ(ushort val);
    internal static byte Succ(byte val);
    internal static char Succ(char val);
    internal static DateTime Succ(DateTime val);
    internal static string Succ(string val);
    internal static string Succ(string val, int length);
    [IteratorStateMachineAttribute("DotLiquid.Util.Range/<Inclusive>d__12`1")]
public static IEnumerable`1<T> Inclusive(T start, T finish, Func`2<T, T> succ, Comparison`1<T> comp);
    internal static int Comp(T a, T b);
    public static IEnumerable`1<T> Inclusive(T start, T finish, Func`2<T, T> succ);
    public static IEnumerable`1<DateTime> Inclusive(DateTime start, DateTime finish);
    public static IEnumerable`1<string> Inclusive(string start, string finish);
    public static IEnumerable`1<int> Inclusive(int start, int finish);
}
[ExtensionAttribute]
public static class DotLiquid.Util.StrFTime : object {
    private static Dictionary`2<string, DateTimeDelegate> Formats;
    private static StrFTime();
    [ExtensionAttribute]
public static string ToStrFTime(DateTime dateTime, string pattern);
}
internal class DotLiquid.Util.Symbol : object {
    [CompilerGeneratedAttribute]
private Func`2<object, bool> <EvaluationFunction>k__BackingField;
    public Func`2<object, bool> EvaluationFunction { get; public set; }
    public Symbol(Func`2<object, bool> evaluationFunction);
    [CompilerGeneratedAttribute]
public Func`2<object, bool> get_EvaluationFunction();
    [CompilerGeneratedAttribute]
public void set_EvaluationFunction(Func`2<object, bool> value);
}
internal static class DotLiquid.Util.TypeUtility : object {
    private static TypeAttributes AnonymousTypeAttributes;
    public static bool IsAnonymousType(Type t);
}
[DefaultMemberAttribute("Item")]
internal class DotLiquid.Util.WeakTable`2 : object {
    private Bucket[] _buckets;
    public TValue Item { get; public set; }
    public WeakTable`2(int size);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Remove(TKey key);
}
public class DotLiquid.Variable : object {
    private static Regex FilterParserRegex;
    private static Regex FilterArgRegex;
    private static Regex QuotedAssignFragmentRegex;
    private static Regex FilterSeparatorRegex;
    private static Regex FilterNameRegex;
    [CompilerGeneratedAttribute]
private List`1<Filter> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private string _markup;
    public List`1<Filter> Filters { get; public set; }
    public string Name { get; public set; }
    public Variable(string markup);
    private static Variable();
    [CompilerGeneratedAttribute]
public List`1<Filter> get_Filters();
    [CompilerGeneratedAttribute]
public void set_Filters(List`1<Filter> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual void Render(Context context, TextWriter result);
    private object RenderInternal(Context context);
    internal object Render(Context context);
}
