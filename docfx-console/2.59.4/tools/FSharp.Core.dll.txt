[CompilationMappingAttribute("7")]
internal static class FSharp.BuildProperties : object {
    internal static string fsProductVersion { get; }
    internal static string fsLanguageVersion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_fsProductVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_fsLanguageVersion();
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.Array2DModule : object {
    [CompilationSourceNameAttribute("length1")]
public static int Length1(T[0...,0...] array);
    [CompilationSourceNameAttribute("length2")]
public static int Length2(T[0...,0...] array);
    [CompilationSourceNameAttribute("base1")]
public static int Base1(T[0...,0...] array);
    [CompilationSourceNameAttribute("base2")]
public static int Base2(T[0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("get")]
public static T Get(T[0...,0...] array, int index1, int index2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("set")]
public static void Set(T[0...,0...] array, int index1, int index2, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zeroCreate")]
public static T[0...,0...] ZeroCreate(int length1, int length2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zeroCreateBased")]
public static T[0...,0...] ZeroCreateBased(int base1, int base2, int length1, int length2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("createBased")]
public static T[0...,0...] CreateBased(int base1, int base2, int length1, int length2, T initial);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("initBased")]
public static T[0...,0...] InitializeBased(int base1, int base2, int length1, int length2, FSharpFunc`2<int, FSharpFunc`2<int, T>> initializer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("create")]
public static T[0...,0...] Create(int length1, int length2, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("init")]
public static T[0...,0...] Initialize(int length1, int length2, FSharpFunc`2<int, FSharpFunc`2<int, T>> initializer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<T, Unit> action, T[0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iteri")]
public static void IterateIndexed(FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<T, Unit>>> action, T[0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static TResult[0...,0...] Map(FSharpFunc`2<T, TResult> mapping, T[0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapi")]
public static TResult[0...,0...] MapIndexed(FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<T, TResult>>> mapping, T[0...,0...] array);
    [CompilationSourceNameAttribute("copy")]
public static T[0...,0...] Copy(T[0...,0...] array);
    [CompilationSourceNameAttribute("rebase")]
public static T[0...,0...] Rebase(T[0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("blit")]
public static void CopyTo(T[0...,0...] source, int sourceIndex1, int sourceIndex2, T[0...,0...] target, int targetIndex1, int targetIndex2, int length1, int length2);
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.Array3DModule : object {
    [CompilationSourceNameAttribute("length1")]
public static int Length1(T[0...,0...,0...] array);
    [CompilationSourceNameAttribute("length2")]
public static int Length2(T[0...,0...,0...] array);
    [CompilationSourceNameAttribute("length3")]
public static int Length3(T[0...,0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("get")]
public static T Get(T[0...,0...,0...] array, int index1, int index2, int index3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("set")]
public static void Set(T[0...,0...,0...] array, int index1, int index2, int index3, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zeroCreate")]
public static T[0...,0...,0...] ZeroCreate(int length1, int length2, int length3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("create")]
public static T[0...,0...,0...] Create(int length1, int length2, int length3, T initial);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("init")]
public static T[0...,0...,0...] Initialize(int length1, int length2, int length3, FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<int, T>>> initializer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<T, Unit> action, T[0...,0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static TResult[0...,0...,0...] Map(FSharpFunc`2<T, TResult> mapping, T[0...,0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iteri")]
public static void IterateIndexed(FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<T, Unit>>>> action, T[0...,0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapi")]
public static TResult[0...,0...,0...] MapIndexed(FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<T, TResult>>>> mapping, T[0...,0...,0...] array);
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.Array4DModule : object {
    [CompilationSourceNameAttribute("length1")]
public static int Length1(T[0...,0...,0...,0...] array);
    [CompilationSourceNameAttribute("length2")]
public static int Length2(T[0...,0...,0...,0...] array);
    [CompilationSourceNameAttribute("length3")]
public static int Length3(T[0...,0...,0...,0...] array);
    [CompilationSourceNameAttribute("length4")]
public static int Length4(T[0...,0...,0...,0...] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zeroCreate")]
public static T[0...,0...,0...,0...] ZeroCreate(int length1, int length2, int length3, int length4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("create")]
public static T[0...,0...,0...,0...] Create(int length1, int length2, int length3, int length4, T initial);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("init")]
public static T[0...,0...,0...,0...] Initialize(int length1, int length2, int length3, int length4, FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<int, T>>>> initializer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("get")]
public static T Get(T[0...,0...,0...,0...] array, int index1, int index2, int index3, int index4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("set")]
public static void Set(T[0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, T value);
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.ArrayModule : object {
    [CompilationSourceNameAttribute("length")]
public static int Length(T[] array);
    [CompilationSourceNameAttribute("last")]
public static T Last(T[] array);
    [CompilationSourceNameAttribute("tryLast")]
public static FSharpOption`1<T> TryLast(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("init")]
public static T[] Initialize(int count, FSharpFunc`2<int, T> initializer);
    [CompilationSourceNameAttribute("zeroCreate")]
public static T[] ZeroCreate(int count);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("create")]
public static T[] Create(int count, T value);
    [CompilationSourceNameAttribute("tryHead")]
public static FSharpOption`1<T> TryHead(T[] array);
    [CompilationSourceNameAttribute("isEmpty")]
public static bool IsEmpty(T[] array);
    [CompilationSourceNameAttribute("tail")]
public static T[] Tail(T[] array);
    [GeneralizableValueAttribute]
[CompilationSourceNameAttribute("empty")]
public static T[] Empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("blit")]
public static void CopyTo(T[] source, int sourceIndex, T[] target, int targetIndex, int count);
    internal static T[] concatArrays(T[][] arrs);
    [CompilationSourceNameAttribute("concat")]
public static T[] Concat(IEnumerable`1<T[]> arrays);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("replicate")]
public static T[] Replicate(int count, T initial);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("collect")]
public static TResult[] Collect(FSharpFunc`2<T, TResult[]> mapping, T[] array);
    [CompilerGeneratedAttribute]
internal static Tuple`2<T[], T[]> splitAt$cont@128(int index, T[] array, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("splitAt")]
public static Tuple`2<T[], T[]> SplitAt(int index, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("take")]
public static T[] Take(int count, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("takeWhile")]
public static T[] TakeWhile(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2[] countByValueType(FSharpFunc`2<T, TKey> projection, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2[] countByRefType(FSharpFunc`2<T, TKey> projection, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("countBy")]
public static Tuple`2[] CountBy(FSharpFunc`2<T, TKey> projection, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("append")]
public static T[] Append(T[] array1, T[] array2);
    [CompilationSourceNameAttribute("head")]
public static T Head(T[] array);
    [CompilationSourceNameAttribute("copy")]
public static T[] Copy(T[] array);
    [CompilationSourceNameAttribute("toList")]
public static FSharpList`1<T> ToList(T[] array);
    [CompilationSourceNameAttribute("ofList")]
public static T[] OfList(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("indexed")]
public static Tuple`2[] Indexed(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<T, Unit> action, T[] array);
    [CompilationSourceNameAttribute("distinct")]
public static T[] Distinct(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static TResult[] Map(FSharpFunc`2<T, TResult> mapping, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter2")]
public static void Iterate2(FSharpFunc`2<T1, FSharpFunc`2<T2, Unit>> action, T1[] array1, T2[] array2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("distinctBy")]
public static T[] DistinctBy(FSharpFunc`2<T, TKey> projection, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map2")]
public static TResult[] Map2(FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> mapping, T1[] array1, T2[] array2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map3")]
public static TResult[] Map3(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> mapping, T1[] array1, T2[] array2, T3[] array3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapi2")]
public static TResult[] MapIndexed2(FSharpFunc`2<int, FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>>> mapping, T1[] array1, T2[] array2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iteri")]
public static void IterateIndexed(FSharpFunc`2<int, FSharpFunc`2<T, Unit>> action, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iteri2")]
public static void IterateIndexed2(FSharpFunc`2<int, FSharpFunc`2<T1, FSharpFunc`2<T2, Unit>>> action, T1[] array1, T2[] array2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapi")]
public static TResult[] MapIndexed(FSharpFunc`2<int, FSharpFunc`2<T, TResult>> mapping, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapFold")]
public static Tuple`2<TResult[], TState> MapFold(FSharpFunc`2<TState, FSharpFunc`2<T, Tuple`2<TResult, TState>>> mapping, TState state, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapFoldBack")]
public static Tuple`2<TResult[], TState> MapFoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, Tuple`2<TResult, TState>>> mapping, T[] array, TState state);
    internal static bool loop@366-33(FSharpFunc`2<T, bool> predicate, T[] array, int len, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists")]
public static bool Exists(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("contains")]
public static bool Contains(T value, T[] array);
    internal static bool loop@386-34(T1[] array1, T2[] array2, FSharpFunc`3<T1, T2, bool> f, int len1, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists2")]
public static bool Exists2(FSharpFunc`2<T1, FSharpFunc`2<T2, bool>> predicate, T1[] array1, T2[] array2);
    internal static bool loop@393-35(FSharpFunc`2<T, bool> predicate, T[] array, int len, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall")]
public static bool ForAll(FSharpFunc`2<T, bool> predicate, T[] array);
    internal static bool loop@403-36(T1[] array1, T2[] array2, FSharpFunc`3<T1, T2, bool> f, int len1, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall2")]
public static bool ForAll2(FSharpFunc`2<T1, FSharpFunc`2<T2, bool>> predicate, T1[] array1, T2[] array2);
    [CompilerGeneratedAttribute]
internal static Tuple`2[] groupByImpl$cont@409(FSharpFunc`2<T, TKey> keyf, T[] array, IEqualityComparer`1<TKey> comparer, int length, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2[] groupByValueType(FSharpFunc`2<T, TKey> keyf, T[] array);
    [CompilerGeneratedAttribute]
internal static Tuple`2[] groupByImpl$cont@409-1(FSharpFunc`2<T, TKey> keyf, T[] array, IEqualityComparer`1<StructBox`1<TKey>> comparer, int length, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2[] groupByRefType(FSharpFunc`2<T, TKey> keyf, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("groupBy")]
public static Tuple`2[] GroupBy(FSharpFunc`2<T, TKey> projection, T[] array);
    internal static TResult loop@448-37(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, T[] array, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("pick")]
public static TResult Pick(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, T[] array);
    internal static FSharpOption`1<TResult> loop@460-38(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, T[] array, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryPick")]
public static FSharpOption`1<TResult> TryPick(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("choose")]
public static TResult[] Choose(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static T[] Filter(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("where")]
public static T[] Where(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("except")]
public static T[] Except(IEnumerable`1<T> itemsToExclude, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("partition")]
public static Tuple`2<T[], T[]> Partition(FSharpFunc`2<T, bool> predicate, T[] array);
    internal static T loop@720-39(FSharpFunc`2<T, bool> predicate, T[] array, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("find")]
public static T Find(FSharpFunc`2<T, bool> predicate, T[] array);
    internal static FSharpOption`1<T> loop@728-40(FSharpFunc`2<T, bool> predicate, T[] array, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFind")]
public static FSharpOption`1<T> TryFind(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("skip")]
public static T[] Skip(int count, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("skipWhile")]
public static T[] SkipWhile(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findBack")]
public static T FindBack(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindBack")]
public static FSharpOption`1<T> TryFindBack(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findIndexBack")]
public static int FindIndexBack(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindIndexBack")]
public static FSharpOption`1<int> TryFindIndexBack(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("windowed")]
public static T[][] Windowed(int windowSize, T[] array);
    [CompilerGeneratedAttribute]
internal static T[][] chunkBySize$cont@796(int chunkSize, T[] array, int len, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("chunkBySize")]
public static T[][] ChunkBySize(int chunkSize, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("splitInto")]
public static T[][] SplitInto(int count, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zip")]
public static Tuple`2[] Zip(T1[] array1, T2[] array2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zip3")]
public static Tuple`3[] Zip3(T1[] array1, T2[] array2, T3[] array3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("allPairs")]
public static Tuple`2[] AllPairs(T1[] array1, T2[] array2);
    internal static void loop@848-41(FSharpFunc`2<TState, FSharpOption`1<Tuple`2<T, TState>>> generator, List`1<T> res, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("unfold")]
public static T[] Unfold(FSharpFunc`2<TState, FSharpOption`1<Tuple`2<T, TState>>> generator, TState state);
    [CompilationSourceNameAttribute("unzip")]
public static Tuple`2<T1[], T2[]> Unzip(Tuple`2[] array);
    [CompilationSourceNameAttribute("unzip3")]
public static Tuple`3<T1[], T2[], T3[]> Unzip3(Tuple`3[] array);
    [CompilationSourceNameAttribute("rev")]
public static T[] Reverse(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold")]
public static TState Fold(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> folder, TState state, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack")]
public static TState FoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> folder, T[] array, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack2")]
public static TState FoldBack2(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<TState, TState>>> folder, T1[] array1, T2[] array2, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold2")]
public static TState Fold2(FSharpFunc`2<TState, FSharpFunc`2<T1, FSharpFunc`2<T2, TState>>> folder, TState state, T1[] array1, T2[] array2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b foldSubRight(FSharpFunc`2<a, FSharpFunc`2<b, b>> f, a[] array, int start, int fin, b acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a[] scanSubLeft(FSharpFunc`2<a, FSharpFunc`2<b, a>> f, a initState, b[] array, int start, int fin);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("scan")]
public static TState[] Scan(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> folder, TState state, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("scanBack")]
public static TState[] ScanBack(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> folder, T[] array, TState state);
    [CompilationSourceNameAttribute("singleton")]
public static T[] Singleton(T value);
    [CompilerGeneratedAttribute]
internal static Tuple`2<T, T> initializer@41(T[] array, int i);
    [CompilationSourceNameAttribute("pairwise")]
public static Tuple`2[] Pairwise(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("reduce")]
public static T Reduce(FSharpFunc`2<T, FSharpFunc`2<T, T>> reduction, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("reduceBack")]
public static T ReduceBack(FSharpFunc`2<T, FSharpFunc`2<T, T>> reduction, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortInPlaceWith")]
public static void SortInPlaceWith(FSharpFunc`2<T, FSharpFunc`2<T, int>> comparer, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortInPlaceBy")]
public static void SortInPlaceBy(FSharpFunc`2<T, TKey> projection, T[] array);
    [CompilationSourceNameAttribute("sortInPlace")]
public static void SortInPlace(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortWith")]
public static T[] SortWith(FSharpFunc`2<T, FSharpFunc`2<T, int>> comparer, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortBy")]
public static T[] SortBy(FSharpFunc`2<T, TKey> projection, T[] array);
    [CompilationSourceNameAttribute("sort")]
public static T[] Sort(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortByDescending")]
public static T[] SortByDescending(FSharpFunc`2<T, TKey> projection, T[] array);
    [CompilationSourceNameAttribute("sortDescending")]
public static T[] SortDescending(T[] array);
    [CompilationSourceNameAttribute("toSeq")]
public static IEnumerable`1<T> ToSeq(T[] array);
    [CompilationSourceNameAttribute("ofSeq")]
public static T[] OfSeq(IEnumerable`1<T> source);
    internal static int go@1063-1(FSharpFunc`2<T, bool> predicate, T[] array, int len, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findIndex")]
public static int FindIndex(FSharpFunc`2<T, bool> predicate, T[] array);
    internal static FSharpOption`1<int> go@1075-2(FSharpFunc`2<T, bool> predicate, T[] array, int len, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindIndex")]
public static FSharpOption`1<int> TryFindIndex(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("permute")]
public static T[] Permute(FSharpFunc`2<int, int> indexMap, T[] array);
    [CompilationSourceNameAttribute("sum")]
public static T Sum(T[] array);
    [CompilationSourceNameAttribute("sum")]
public static T Sum$W(FSharpFunc`2<Unit, T> get_Zero, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Addition, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sumBy")]
public static TResult SumBy(FSharpFunc`2<T, TResult> projection, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sumBy")]
public static TResult SumBy$W(FSharpFunc`2<Unit, TResult> get_Zero, FSharpFunc`2<TResult, FSharpFunc`2<TResult, TResult>> op_Addition, FSharpFunc`2<T, TResult> projection, T[] array);
    [CompilationSourceNameAttribute("min")]
public static T Min(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("minBy")]
public static T MinBy(FSharpFunc`2<T, TResult> projection, T[] array);
    [CompilationSourceNameAttribute("max")]
public static T Max(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("maxBy")]
public static T MaxBy(FSharpFunc`2<T, TResult> projection, T[] array);
    [CompilationSourceNameAttribute("average")]
public static T Average(T[] array);
    [CompilationSourceNameAttribute("average")]
public static T Average$W(FSharpFunc`2<T, FSharpFunc`2<int, T>> divideByInt, FSharpFunc`2<Unit, T> get_Zero, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Addition, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("averageBy")]
public static TResult AverageBy(FSharpFunc`2<T, TResult> projection, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("averageBy")]
public static TResult AverageBy$W(FSharpFunc`2<TResult, FSharpFunc`2<int, TResult>> divideByInt, FSharpFunc`2<Unit, TResult> get_Zero, FSharpFunc`2<TResult, FSharpFunc`2<TResult, TResult>> op_Addition, FSharpFunc`2<T, TResult> projection, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("compareWith")]
public static int CompareWith(FSharpFunc`2<T, FSharpFunc`2<T, int>> comparer, T[] array1, T[] array2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sub")]
public static T[] GetSubArray(T[] array, int startIndex, int count);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("item")]
public static T Item(int index, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryItem")]
public static FSharpOption`1<T> TryItem(int index, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("get")]
public static T Get(T[] array, int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("set")]
public static void Set(T[] array, int index, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fill")]
public static void Fill(T[] target, int targetIndex, int count, T value);
    [CompilationSourceNameAttribute("exactlyOne")]
public static T ExactlyOne(T[] array);
    [CompilationSourceNameAttribute("tryExactlyOne")]
public static FSharpOption`1<T> TryExactlyOne(T[] array);
    internal static T[][] transposeArrays(T[][] array);
    [CompilationSourceNameAttribute("transpose")]
public static T[][] Transpose(IEnumerable`1<T[]> arrays);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("truncate")]
public static T[] Truncate(int count, T[] array);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Collections.CachedSeq`1 : object {
    internal IEnumerable`1<T> res;
    internal FSharpFunc`2<Unit, Unit> cleanup;
    public CachedSeq`1(FSharpFunc`2<Unit, Unit> cleanup, IEnumerable`1<T> res);
    internal void Clear();
    private virtual override void System.IDisposable.Dispose();
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.ComparisonIdentity : object {
    public static IComparer`1<T> Structural();
    public static IComparer`1<T> NonStructural();
    public static IComparer`1<T> NonStructural$W(FSharpFunc`2<T, FSharpFunc`2<T, bool>> op_GreaterThan, FSharpFunc`2<T, FSharpFunc`2<T, bool>> op_LessThan);
    public static IComparer`1<T> FromFunction(FSharpFunc`2<T, FSharpFunc`2<T, int>> comparer);
}
[DefaultMemberAttribute("Item")]
[DefaultAugmentationAttribute("False")]
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpList`1")]
[DebuggerTypeProxyAttribute("Microsoft.FSharp.Collections.ListDebugView`1")]
[DebuggerDisplayAttribute("{DebugDisplay,nq}")]
[CompilationMappingAttribute("1")]
public class Microsoft.FSharp.Collections.FSharpList`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T head;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<T> tail;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpList`1<T> _unique_Empty;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpList`1<T> Empty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCons { get; }
    [CompilationMappingAttribute("4", "1", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T HeadOrDefault { get; }
    [CompilationMappingAttribute("4", "1", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<T> TailOrNull { get; }
    [DebuggerBrowsableAttribute("0")]
public int Length { get; }
    [DebuggerBrowsableAttribute("0")]
internal string DebugDisplay { get; }
    public T Head { get; }
    public FSharpList`1<T> Tail { get; }
    public T Item { get; }
    private static FSharpList`1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1(T head, FSharpList`1<T> tail);
    [CompilationMappingAttribute("8", "0")]
public static FSharpList`1<T> get_Empty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEmpty();
    [CompilationMappingAttribute("8", "1")]
public static FSharpList`1<T> Cons(T head, FSharpList`1<T> tail);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCons();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T get_HeadOrDefault();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<T> get_TailOrNull();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpList`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpList`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
    public int get_Length();
    internal string get_DebugDisplay();
    public T get_Head();
    public FSharpList`1<T> get_Tail();
    public T get_Item(int index);
    public virtual string ToString();
    public FSharpList`1<T> GetSlice(FSharpOption`1<int> startIndex, FSharpOption`1<int> endIndex);
    [ExperimentalAttribute("Experimental library feature, requires '--langversion:preview'")]
public int GetReverseIndex(int rank, int offset);
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override int System.Collections.Generic.IReadOnlyCollection<'T>.get_Count();
    private virtual override T System.Collections.Generic.IReadOnlyList<'T>.get_Item(int index);
}
[DefaultMemberAttribute("Item")]
[CompiledNameAttribute("FSharpMap`2")]
[SealedAttribute]
[DebuggerTypeProxyAttribute("Microsoft.FSharp.Collections.MapDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Collections.FSharpMap`2 : object {
    internal IComparer`1<TKey> comparer@488;
    internal MapTree`2<TKey, TValue> tree@492;
    internal KeyValuePair`2[] serializedData;
    internal static FSharpMap`2<TKey, TValue> empty;
    internal static FSharpMap`2<TKey, TValue> Empty { get; }
    [DebuggerBrowsableAttribute("0")]
internal IComparer`1<TKey> Comparer { get; }
    internal MapTree`2<TKey, TValue> Tree { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    public TValue Item { get; }
    public int Count { get; }
    internal FSharpMap`2(IComparer`1<TKey> comparer, MapTree`2<TKey, TValue> tree);
    private static FSharpMap`2();
    public FSharpMap`2(IEnumerable`1<Tuple`2<TKey, TValue>> elements);
    [OnSerializingAttribute]
internal void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
internal void OnDeserialized(StreamingContext context);
    internal static FSharpMap`2<TKey, TValue> get_Empty();
    internal static FSharpMap`2<TKey, TValue> Create(IEnumerable`1<Tuple`2<TKey, TValue>> ie);
    internal IComparer`1<TKey> get_Comparer();
    internal MapTree`2<TKey, TValue> get_Tree();
    public FSharpMap`2<TKey, TValue> Add(TKey key, TValue value);
    public FSharpMap`2<TKey, TValue> Change(TKey key, FSharpFunc`2<FSharpOption`1<TValue>, FSharpOption`1<TValue>> f);
    public bool get_IsEmpty();
    public TValue get_Item(TKey key);
    internal FSharpOption`1<a> TryPick(FSharpFunc`2<TKey, FSharpFunc`2<TValue, FSharpOption`1<a>>> f);
    internal bool Exists(FSharpFunc`2<TKey, FSharpFunc`2<TValue, bool>> predicate);
    internal FSharpMap`2<TKey, TValue> Filter(FSharpFunc`2<TKey, FSharpFunc`2<TValue, bool>> predicate);
    internal bool ForAll(FSharpFunc`2<TKey, FSharpFunc`2<TValue, bool>> predicate);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal a Fold(FSharpFunc`2<TKey, FSharpFunc`2<TValue, FSharpFunc`2<a, a>>> f, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal z FoldSection(TKey lo, TKey hi, FSharpFunc`2<TKey, FSharpFunc`2<TValue, FSharpFunc`2<z, z>>> f, z acc);
    internal void Iterate(FSharpFunc`2<TKey, FSharpFunc`2<TValue, Unit>> f);
    internal FSharpMap`2<TKey, b> MapRange(FSharpFunc`2<TValue, b> f);
    internal FSharpMap`2<TKey, b> Map(FSharpFunc`2<TKey, FSharpFunc`2<TValue, b>> f);
    internal Tuple`2<FSharpMap`2<TKey, TValue>, FSharpMap`2<TKey, TValue>> Partition(FSharpFunc`2<TKey, FSharpFunc`2<TValue, bool>> predicate);
    public int get_Count();
    public bool ContainsKey(TKey key);
    public FSharpMap`2<TKey, TValue> Remove(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public FSharpOption`1<TValue> TryFind(TKey key);
    internal FSharpList`1<Tuple`2<TKey, TValue>> ToList();
    internal Tuple`2[] ToArray();
    internal static FSharpMap`2<TKey, TValue> ofList(FSharpList`1<Tuple`2<TKey, TValue>> l);
    internal int ComputeHashCode();
    public virtual bool Equals(object that);
    public virtual int GetHashCode();
    public virtual string ToString();
    private virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override TValue System.Collections.Generic.IDictionary<'Key, 'Value>.get_Item(TKey x);
    private virtual override void System.Collections.Generic.IDictionary<'Key, 'Value>.set_Item(TKey x, TValue v);
    private virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<'Key, 'Value>.get_Keys();
    private virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<'Key, 'Value>.get_Values();
    private virtual override void System.Collections.Generic.IDictionary<'Key, 'Value>.Add(TKey k, TValue v);
    private virtual override bool System.Collections.Generic.IDictionary<'Key, 'Value>.ContainsKey(TKey k);
    private virtual override bool System.Collections.Generic.IDictionary<'Key, 'Value>.TryGetValue(TKey k, TValue& r);
    private virtual override bool System.Collections.Generic.IDictionary<'Key, 'Value>.Remove(TKey k);
    private virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.Add(KeyValuePair`2<TKey, TValue> x);
    private virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.Clear();
    private virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.Remove(KeyValuePair`2<TKey, TValue> x);
    private virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.Contains(KeyValuePair`2<TKey, TValue> x);
    private virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.CopyTo(KeyValuePair`2[] arr, int i);
    private virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.get_IsReadOnly();
    private virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.get_Count();
    private virtual override int System.IComparable.CompareTo(object obj);
    private virtual override int System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.get_Count();
    private virtual override TValue System.Collections.Generic.IReadOnlyDictionary<'Key, 'Value>.get_Item(TKey key);
    private virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<'Key, 'Value>.get_Keys();
    private virtual override bool System.Collections.Generic.IReadOnlyDictionary<'Key, 'Value>.TryGetValue(TKey key, TValue& value);
    private virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<'Key, 'Value>.get_Values();
    private virtual override bool System.Collections.Generic.IReadOnlyDictionary<'Key, 'Value>.ContainsKey(TKey key);
}
[SealedAttribute]
[CompiledNameAttribute("FSharpSet`1")]
[DebuggerTypeProxyAttribute("Microsoft.FSharp.Collections.SetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Collections.FSharpSet`1 : object {
    internal IComparer`1<T> comparer@519;
    internal SetTree`1<T> tree@523;
    internal T[] serializedData;
    internal static FSharpSet`1<T> empty;
    [DebuggerBrowsableAttribute("0")]
internal IComparer`1<T> Comparer { get; }
    internal SetTree`1<T> Tree { get; }
    [DebuggerBrowsableAttribute("0")]
internal static FSharpSet`1<T> Empty { get; }
    public int Count { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    [DebuggerBrowsableAttribute("0")]
internal T Choose { get; }
    [DebuggerBrowsableAttribute("0")]
public T MinimumElement { get; }
    [DebuggerBrowsableAttribute("0")]
public T MaximumElement { get; }
    internal FSharpSet`1(IComparer`1<T> comparer, SetTree`1<T> tree);
    private static FSharpSet`1();
    public FSharpSet`1(IEnumerable`1<T> elements);
    [OnSerializingAttribute]
internal void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
internal void OnDeserialized(StreamingContext context);
    internal IComparer`1<T> get_Comparer();
    internal SetTree`1<T> get_Tree();
    internal static FSharpSet`1<T> get_Empty();
    public FSharpSet`1<T> Add(T value);
    public FSharpSet`1<T> Remove(T value);
    public int get_Count();
    public bool Contains(T value);
    internal void Iterate(FSharpFunc`2<T, Unit> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal a Fold(FSharpFunc`2<T, FSharpFunc`2<a, a>> f, a z);
    public bool get_IsEmpty();
    internal Tuple`2<FSharpSet`1<T>, FSharpSet`1<T>> Partition(FSharpFunc`2<T, bool> f);
    internal FSharpSet`1<T> Filter(FSharpFunc`2<T, bool> f);
    internal FSharpSet`1<TResult> Map(FSharpFunc`2<T, TResult> f);
    internal bool Exists(FSharpFunc`2<T, bool> f);
    internal bool ForAll(FSharpFunc`2<T, bool> f);
    public static FSharpSet`1<T> op_Subtraction(FSharpSet`1<T> set1, FSharpSet`1<T> set2);
    public static FSharpSet`1<T> op_Addition(FSharpSet`1<T> set1, FSharpSet`1<T> set2);
    internal static FSharpSet`1<T> Intersection(FSharpSet`1<T> a, FSharpSet`1<T> b);
    internal static FSharpSet`1<T> Union(IEnumerable`1<FSharpSet`1<T>> sets);
    internal static FSharpSet`1<T> Intersection(IEnumerable`1<FSharpSet`1<T>> sets);
    internal static bool Equality(FSharpSet`1<T> a, FSharpSet`1<T> b);
    internal static int Compare(FSharpSet`1<T> a, FSharpSet`1<T> b);
    internal T get_Choose();
    public T get_MinimumElement();
    public T get_MaximumElement();
    public bool IsSubsetOf(FSharpSet`1<T> otherSet);
    public bool IsSupersetOf(FSharpSet`1<T> otherSet);
    public bool IsProperSubsetOf(FSharpSet`1<T> otherSet);
    public bool IsProperSupersetOf(FSharpSet`1<T> otherSet);
    internal FSharpList`1<T> ToList();
    internal T[] ToArray();
    internal int ComputeHashCode();
    public virtual int GetHashCode();
    public virtual bool Equals(object that);
    internal static FSharpSet`1<T> Singleton(T x);
    internal static FSharpSet`1<T> Create(IEnumerable`1<T> elements);
    internal static FSharpSet`1<T> FromArray(T[] arr);
    public virtual string ToString();
    private virtual override int System.IComparable.CompareTo(object that);
    private virtual override void System.Collections.Generic.ICollection<'T>.Add(T x);
    private virtual override void System.Collections.Generic.ICollection<'T>.Clear();
    private virtual override bool System.Collections.Generic.ICollection<'T>.Remove(T x);
    private virtual override bool System.Collections.Generic.ICollection<'T>.Contains(T x);
    private virtual override void System.Collections.Generic.ICollection<'T>.CopyTo(T[] arr, int i);
    private virtual override bool System.Collections.Generic.ICollection<'T>.get_IsReadOnly();
    private virtual override int System.Collections.Generic.ICollection<'T>.get_Count();
    private virtual override int System.Collections.Generic.IReadOnlyCollection<'T>.get_Count();
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Collections.Generator : object {
    internal static void disposeG(Generator`1<T> g);
    internal static Step`1<a> appG(Generator`1<a> g);
    internal static IEnumerator`1<T> EnumerateFromGenerator(Generator`1<T> g);
    internal static Generator`1<T> GenerateFromEnumerator(IEnumerator`1<T> e);
}
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.HashIdentity : object {
    public static IEqualityComparer`1<T> Structural();
    public static IEqualityComparer`1<T> LimitedStructural(int limit);
    public static IEqualityComparer`1<T> Reference();
    public static IEqualityComparer`1<T> NonStructural();
    public static IEqualityComparer`1<T> NonStructural$W(FSharpFunc`2<T, FSharpFunc`2<T, bool>> op_Equality);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEqualityComparer`1<T> FromFunctions(FSharpFunc`2<T, int> hasher, FSharpFunc`2<T, FSharpFunc`2<T, bool>> equality);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Collections.IEnumerator : object {
    internal static a noReset();
    internal static a notStarted();
    internal static a alreadyFinished();
    internal static void check(bool started);
    internal static void dispose(IDisposable r);
    internal static IEnumerator`1<T> cast(IEnumerator e);
    internal static IEnumerator`1<T> Empty();
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<a> action@4737(FSharpRef`1<FSharpOption`1<a>> r, Unit unitVar0);
    internal static FSharpOption`1<a> readAndClear(FSharpRef`1<FSharpOption`1<a>> r);
    internal static void finish@80(FSharpFunc`2<a, Unit> closef, FSharpRef`1<FSharpOption`1<a>> state, FSharpRef`1<FSharpOption`1<TResult>> curr, Unit unitVar0);
    internal static void start@77(FSharpRef`1<bool> started, Unit unitVar0);
    internal static TResult getCurr@74(FSharpRef`1<bool> started, FSharpRef`1<FSharpOption`1<TResult>> curr, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerator`1<TResult> generateWhileSome(FSharpFunc`2<Unit, a> openf, FSharpFunc`2<a, FSharpOption`1<TResult>> compute, FSharpFunc`2<a, Unit> closef);
    internal static IEnumerator`1<T> Singleton(T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerator`1<T> EnumerateThenFinally(FSharpFunc`2<Unit, Unit> f, IEnumerator`1<T> e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkNonNull(string argName, a arg);
    internal static IEnumerable`1<TResult> mkSeq(FSharpFunc`2<Unit, IEnumerator`1<TResult>> f);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Collections.Internal : object {
}
[DebuggerDisplayAttribute("{keyValue.Value}")]
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Collections.KeyValuePairDebugFriendly`2 : object {
    internal KeyValuePair`2<TKey, TValue> keyValue;
    [DebuggerBrowsableAttribute("3")]
internal KeyValuePair`2<TKey, TValue> KeyValue { get; }
    public KeyValuePairDebugFriendly`2(KeyValuePair`2<TKey, TValue> keyValue);
    internal KeyValuePair`2<TKey, TValue> get_KeyValue();
}
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Collections.ListDebugView`1 : object {
    internal FSharpList`1<T> l;
    internal int ListDebugViewMaxLength;
    internal int ListDebugViewMaxFullLength;
    [DebuggerBrowsableAttribute("3")]
internal T[] Items { get; }
    [DebuggerBrowsableAttribute("2")]
internal T[] _FullList { get; }
    public ListDebugView`1(FSharpList`1<T> l);
    internal T[] get_Items();
    internal T[] get__FullList();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal int count(FSharpList`1<b> l, int n, int max);
    [CompilerGeneratedAttribute]
internal T[] items(int length);
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.ListModule : object {
    [CompilationSourceNameAttribute("length")]
public static int Length(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("last")]
public static T Last(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("tryLast")]
public static FSharpOption`1<T> TryLast(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("rev")]
public static FSharpList`1<T> Reverse(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("concat")]
public static FSharpList`1<T> Concat(IEnumerable`1<FSharpList`1<T>> lists);
    [CompilerGeneratedAttribute]
internal static void loop@51-23(FSharpFunc`2<T, TKey> projection, Dictionary`2<TKey, int> dict, FSharpList`1<T> srcList);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TKey, int>> countByValueType(FSharpFunc`2<T, TKey> projection, FSharpList`1<T> list);
    [CompilerGeneratedAttribute]
internal static void loop@51-24(FSharpFunc`2<T, TKey> projection, Dictionary`2<StructBox`1<TKey>, int> dict, FSharpList`1<T> srcList);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TKey, int>> countByRefType(FSharpFunc`2<T, TKey> projection, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("countBy")]
public static FSharpList`1<Tuple`2<TKey, int>> CountBy(FSharpFunc`2<T, TKey> projection, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static FSharpList`1<TResult> Map(FSharpFunc`2<T, TResult> mapping, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapi")]
public static FSharpList`1<TResult> MapIndexed(FSharpFunc`2<int, FSharpFunc`2<T, TResult>> mapping, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("indexed")]
public static FSharpList`1<Tuple`2<int, T>> Indexed(FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapFold")]
public static Tuple`2<FSharpList`1<TResult>, TState> MapFold(FSharpFunc`2<TState, FSharpFunc`2<T, Tuple`2<TResult, TState>>> mapping, TState state, FSharpList`1<T> list);
    internal static Tuple`2<FSharpList`1<TResult>, TState> loop@94-25(FSharpFunc`3<T, TState, Tuple`2<TResult, TState>> f, Tuple`2<FSharpList`1<TResult>, TState> res, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapFoldBack")]
public static Tuple`2<FSharpList`1<TResult>, TState> MapFoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, Tuple`2<TResult, TState>>> mapping, FSharpList`1<T> list, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<T, Unit> action, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("distinct")]
public static FSharpList`1<T> Distinct(FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("distinctBy")]
public static FSharpList`1<T> DistinctBy(FSharpFunc`2<T, TKey> projection, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("ofArray")]
public static FSharpList`1<T> OfArray(T[] array);
    [CompilationSourceNameAttribute("toArray")]
public static T[] ToArray(FSharpList`1<T> list);
    [GeneralizableValueAttribute]
[CompilationSourceNameAttribute("empty")]
public static FSharpList`1<T> Empty();
    [CompilationSourceNameAttribute("head")]
public static T Head(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("tryHead")]
public static FSharpOption`1<T> TryHead(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("tail")]
public static FSharpList`1<T> Tail(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("isEmpty")]
public static bool IsEmpty(FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("append")]
public static FSharpList`1<T> Append(FSharpList`1<T> list1, FSharpList`1<T> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("item")]
public static T Item(int index, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryItem")]
public static FSharpOption`1<T> TryItem(int index, FSharpList`1<T> list);
    [ObsoleteAttribute("please use List.item")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("nth")]
public static T Get(FSharpList`1<T> list, int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("choose")]
public static FSharpList`1<TResult> Choose(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("splitAt")]
public static Tuple`2<FSharpList`1<T>, FSharpList`1<T>> SplitAt(int index, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("take")]
public static FSharpList`1<T> Take(int count, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("takeWhile")]
public static FSharpList`1<T> TakeWhile(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iteri")]
public static void IterateIndexed(FSharpFunc`2<int, FSharpFunc`2<T, Unit>> action, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("init")]
public static FSharpList`1<T> Initialize(int length, FSharpFunc`2<int, T> initializer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("replicate")]
public static FSharpList`1<T> Replicate(int count, T initial);
    internal static void loop@185-26(FSharpFunc`3<T1, T2, Unit> f, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter2")]
public static void Iterate2(FSharpFunc`2<T1, FSharpFunc`2<T2, Unit>> action, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    internal static void loop@196-27(FSharpFunc`4<int, T1, T2, Unit> f, int n, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iteri2")]
public static void IterateIndexed2(FSharpFunc`2<int, FSharpFunc`2<T1, FSharpFunc`2<T2, Unit>>> action, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map3")]
public static FSharpList`1<TResult> Map3(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> mapping, FSharpList`1<T1> list1, FSharpList`1<T2> list2, FSharpList`1<T3> list3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapi2")]
public static FSharpList`1<TResult> MapIndexed2(FSharpFunc`2<int, FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>>> mapping, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map2")]
public static FSharpList`1<TResult> Map2(FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> mapping, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold")]
public static TState Fold(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> folder, TState state, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("pairwise")]
public static FSharpList`1<Tuple`2<T, T>> Pairwise(FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("reduce")]
public static T Reduce(FSharpFunc`2<T, FSharpFunc`2<T, T>> reduction, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("scan")]
public static FSharpList`1<TState> Scan(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> folder, TState state, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("singleton")]
public static FSharpList`1<T> Singleton(T value);
    internal static TState loop@246-28(FSharpFunc`4<TState, T1, T2, TState> f, TState acc, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold2")]
public static TState Fold2(FSharpFunc`2<TState, FSharpFunc`2<T1, FSharpFunc`2<T2, TState>>> folder, TState state, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldArraySubRight(FSharpFunc`3<T, a, a> f, T[] arr, int start, int fin, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack")]
public static TState FoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> folder, FSharpList`1<T> list, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("reduceBack")]
public static T ReduceBack(FSharpFunc`2<T, FSharpFunc`2<T, T>> reduction, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TState> scanArraySubRight(FSharpFunc`3<T, TState, TState> f, T[] arr, int start, int fin, TState initState);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("scanBack")]
public static FSharpList`1<TState> ScanBack(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> folder, FSharpList`1<T> list, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c foldBack2UsingArrays(FSharpFunc`4<a, b, c, c> f, FSharpList`1<a> list1, FSharpList`1<b> list2, c acc);
    [CompilerGeneratedAttribute]
internal static TState foldBack2$cont@328(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<TState, TState>>> folder, FSharpList`1<T1> list1, FSharpList`1<T2> list2, TState state, FSharpList`1<T2> rest2, FSharpList`1<T1> rest1, T2 k1, T1 h1, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack2")]
public static TState FoldBack2(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<TState, TState>>> folder, FSharpList`1<T1> list1, FSharpList`1<T2> list2, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall2aux(FSharpFunc`3<a, b, bool> f, FSharpList`1<a> list1, FSharpList`1<b> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall2")]
public static bool ForAll2(FSharpFunc`2<T1, FSharpFunc`2<T2, bool>> predicate, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall")]
public static bool ForAll(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists")]
public static bool Exists(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("contains")]
public static bool Contains(T value, FSharpList`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists2aux(FSharpFunc`3<a, b, bool> f, FSharpList`1<a> list1, FSharpList`1<b> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists2")]
public static bool Exists2(FSharpFunc`2<T1, FSharpFunc`2<T2, bool>> predicate, FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("find")]
public static T Find(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFind")]
public static FSharpOption`1<T> TryFind(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findBack")]
public static T FindBack(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindBack")]
public static FSharpOption`1<T> TryFindBack(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryPick")]
public static FSharpOption`1<TResult> TryPick(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("pick")]
public static TResult Pick(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static FSharpList`1<T> Filter(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("except")]
public static FSharpList`1<T> Except(IEnumerable`1<T> itemsToExclude, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("where")]
public static FSharpList`1<T> Where(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TKey, FSharpList`1<T>>> groupByValueType(FSharpFunc`2<T, TKey> keyf, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TKey, FSharpList`1<T>>> groupByRefType(FSharpFunc`2<T, TKey> keyf, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("groupBy")]
public static FSharpList`1<Tuple`2<TKey, FSharpList`1<T>>> GroupBy(FSharpFunc`2<T, TKey> projection, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("partition")]
public static Tuple`2<FSharpList`1<T>, FSharpList`1<T>> Partition(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("unzip")]
public static Tuple`2<FSharpList`1<T1>, FSharpList`1<T2>> Unzip(FSharpList`1<Tuple`2<T1, T2>> list);
    [CompilationSourceNameAttribute("unzip3")]
public static Tuple`3<FSharpList`1<T1>, FSharpList`1<T2>, FSharpList`1<T3>> Unzip3(FSharpList`1<Tuple`3<T1, T2, T3>> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("windowed")]
public static FSharpList`1<FSharpList`1<T>> Windowed(int windowSize, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("chunkBySize")]
public static FSharpList`1<FSharpList`1<T>> ChunkBySize(int chunkSize, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("splitInto")]
public static FSharpList`1<FSharpList`1<T>> SplitInto(int count, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zip")]
public static FSharpList`1<Tuple`2<T1, T2>> Zip(FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zip3")]
public static FSharpList`1<Tuple`3<T1, T2, T3>> Zip3(FSharpList`1<T1> list1, FSharpList`1<T2> list2, FSharpList`1<T3> list3);
    internal static FSharpList`1<a> loop@474-29(int count, int i, FSharpList`1<a> lst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("skip")]
public static FSharpList`1<T> Skip(int count, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("skipWhile")]
public static FSharpList`1<T> SkipWhile(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortWith")]
public static FSharpList`1<T> SortWith(FSharpFunc`2<T, FSharpFunc`2<T, int>> comparer, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortBy")]
public static FSharpList`1<T> SortBy(FSharpFunc`2<T, TKey> projection, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("sort")]
public static FSharpList`1<T> Sort(FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortByDescending")]
public static FSharpList`1<T> SortByDescending(FSharpFunc`2<T, TKey> projection, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("sortDescending")]
public static FSharpList`1<T> SortDescending(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("ofSeq")]
public static FSharpList`1<T> OfSeq(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("toSeq")]
public static IEnumerable`1<T> ToSeq(FSharpList`1<T> list);
    internal static int loop@532-30(FSharpFunc`2<T, bool> predicate, int n, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findIndex")]
public static int FindIndex(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    internal static FSharpOption`1<int> loop@541-31(FSharpFunc`2<T, bool> predicate, int n, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindIndex")]
public static FSharpOption`1<int> TryFindIndex(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findIndexBack")]
public static int FindIndexBack(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindIndexBack")]
public static FSharpOption`1<int> TryFindIndexBack(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("sum")]
public static T Sum(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("sum")]
public static T Sum$W(FSharpFunc`2<Unit, T> get_Zero, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Addition, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sumBy")]
public static TResult SumBy(FSharpFunc`2<T, TResult> projection, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sumBy")]
public static TResult SumBy$W(FSharpFunc`2<Unit, TResult> get_Zero, FSharpFunc`2<TResult, FSharpFunc`2<TResult, TResult>> op_Addition, FSharpFunc`2<T, TResult> projection, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("max")]
public static T Max(FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("maxBy")]
public static T MaxBy(FSharpFunc`2<T, TResult> projection, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("min")]
public static T Min(FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("minBy")]
public static T MinBy(FSharpFunc`2<T, TResult> projection, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("average")]
public static T Average(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("average")]
public static T Average$W(FSharpFunc`2<T, FSharpFunc`2<int, T>> divideByInt, FSharpFunc`2<Unit, T> get_Zero, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Addition, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("averageBy")]
public static TResult AverageBy(FSharpFunc`2<T, TResult> projection, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("averageBy")]
public static TResult AverageBy$W(FSharpFunc`2<TResult, FSharpFunc`2<int, TResult>> divideByInt, FSharpFunc`2<Unit, TResult> get_Zero, FSharpFunc`2<TResult, FSharpFunc`2<TResult, TResult>> op_Addition, FSharpFunc`2<T, TResult> projection, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("collect")]
public static FSharpList`1<TResult> Collect(FSharpFunc`2<T, FSharpList`1<TResult>> mapping, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("allPairs")]
public static FSharpList`1<Tuple`2<T1, T2>> AllPairs(FSharpList`1<T1> list1, FSharpList`1<T2> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("compareWith")]
public static int CompareWith(FSharpFunc`2<T, FSharpFunc`2<T, int>> comparer, FSharpList`1<T> list1, FSharpList`1<T> list2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("permute")]
public static FSharpList`1<T> Permute(FSharpFunc`2<int, int> indexMap, FSharpList`1<T> list);
    [CompilationSourceNameAttribute("exactlyOne")]
public static T ExactlyOne(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("tryExactlyOne")]
public static FSharpOption`1<T> TryExactlyOne(FSharpList`1<T> list);
    [CompilationSourceNameAttribute("transpose")]
public static FSharpList`1<FSharpList`1<T>> Transpose(IEnumerable`1<FSharpList`1<T>> lists);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("truncate")]
public static FSharpList`1<T> Truncate(int count, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("unfold")]
public static FSharpList`1<T> Unfold(FSharpFunc`2<TState, FSharpOption`1<Tuple`2<T, TState>>> generator, TState state);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Collections.MapDebugView`2 : object {
    internal FSharpMap`2<TKey, TValue> v;
    [DebuggerBrowsableAttribute("3")]
internal KeyValuePairDebugFriendly`2[] Items { get; }
    public MapDebugView`2(FSharpMap`2<TKey, TValue> v);
    internal KeyValuePairDebugFriendly`2[] get_Items();
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.MapModule : object {
    [CompilationSourceNameAttribute("isEmpty")]
public static bool IsEmpty(FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("add")]
public static FSharpMap`2<TKey, T> Add(TKey key, T value, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("change")]
public static FSharpMap`2<TKey, T> Change(TKey key, FSharpFunc`2<FSharpOption`1<T>, FSharpOption`1<T>> f, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("find")]
public static T Find(TKey key, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFind")]
public static FSharpOption`1<T> TryFind(TKey key, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("remove")]
public static FSharpMap`2<TKey, T> Remove(TKey key, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("containsKey")]
public static bool ContainsKey(TKey key, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<TKey, FSharpFunc`2<T, Unit>> action, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryPick")]
public static FSharpOption`1<TResult> TryPick(FSharpFunc`2<TKey, FSharpFunc`2<T, FSharpOption`1<TResult>>> chooser, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("pick")]
public static TResult Pick(FSharpFunc`2<TKey, FSharpFunc`2<T, FSharpOption`1<TResult>>> chooser, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists")]
public static bool Exists(FSharpFunc`2<TKey, FSharpFunc`2<T, bool>> predicate, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static FSharpMap`2<TKey, T> Filter(FSharpFunc`2<TKey, FSharpFunc`2<T, bool>> predicate, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("partition")]
public static Tuple`2<FSharpMap`2<TKey, T>, FSharpMap`2<TKey, T>> Partition(FSharpFunc`2<TKey, FSharpFunc`2<T, bool>> predicate, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall")]
public static bool ForAll(FSharpFunc`2<TKey, FSharpFunc`2<T, bool>> predicate, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static FSharpMap`2<TKey, TResult> Map(FSharpFunc`2<TKey, FSharpFunc`2<T, TResult>> mapping, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold")]
public static TState Fold(FSharpFunc`2<TState, FSharpFunc`2<TKey, FSharpFunc`2<T, TState>>> folder, TState state, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack")]
public static TState FoldBack(FSharpFunc`2<TKey, FSharpFunc`2<T, FSharpFunc`2<TState, TState>>> folder, FSharpMap`2<TKey, T> table, TState state);
    [CompilationSourceNameAttribute("toSeq")]
public static IEnumerable`1<Tuple`2<TKey, T>> ToSeq(FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findKey")]
public static TKey FindKey(FSharpFunc`2<TKey, FSharpFunc`2<T, bool>> predicate, FSharpMap`2<TKey, T> table);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindKey")]
public static FSharpOption`1<TKey> TryFindKey(FSharpFunc`2<TKey, FSharpFunc`2<T, bool>> predicate, FSharpMap`2<TKey, T> table);
    [CompilationSourceNameAttribute("ofList")]
public static FSharpMap`2<TKey, T> OfList(FSharpList`1<Tuple`2<TKey, T>> elements);
    [CompilationSourceNameAttribute("ofSeq")]
public static FSharpMap`2<TKey, T> OfSeq(IEnumerable`1<Tuple`2<TKey, T>> elements);
    [CompilationSourceNameAttribute("ofArray")]
public static FSharpMap`2<TKey, T> OfArray(Tuple`2[] elements);
    [CompilationSourceNameAttribute("toList")]
public static FSharpList`1<Tuple`2<TKey, T>> ToList(FSharpMap`2<TKey, T> table);
    [CompilationSourceNameAttribute("toArray")]
public static Tuple`2[] ToArray(FSharpMap`2<TKey, T> table);
    [GeneralizableValueAttribute]
[CompilationSourceNameAttribute("empty")]
public static FSharpMap`2<TKey, T> Empty();
    [CompilationSourceNameAttribute("count")]
public static int Count(FSharpMap`2<TKey, T> table);
}
[CompilationRepresentationAttribute("8")]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("33")]
internal class Microsoft.FSharp.Collections.MapTree`2 : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static MapTree`2<TKey, TValue> MapEmpty { get; }
    [CompilationMappingAttribute("8", "0")]
internal static MapTree`2<TKey, TValue> get_MapEmpty();
    [CompilationMappingAttribute("8", "1")]
internal static MapTree`2<TKey, TValue> NewMapOne(TKey item1, TValue item2);
    [CompilationMappingAttribute("8", "2")]
internal static MapTree`2<TKey, TValue> NewMapNode(TKey item1, TValue item2, MapTree`2<TKey, TValue> item3, MapTree`2<TKey, TValue> item4, int item5);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int GetTag(MapTree`2<TKey, TValue> );
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Collections.MapTreeModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int sizeAux(int acc, MapTree`2<a, b> m);
    internal static int height(MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<TKey, TValue> mk(MapTree`2<TKey, TValue> l, TKey k, TValue v, MapTree`2<TKey, TValue> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<TKey, TValue> rebalance(MapTree`2<TKey, TValue> t1, TKey k, TValue v, MapTree`2<TKey, TValue> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<TKey, TValue> add(IComparer`1<TKey> comparer, TKey k, TValue v, MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tryGetValue(IComparer`1<TKey> comparer, TKey k, TValue& v, MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TValue find(IComparer`1<TKey> comparer, TKey k, MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TValue> tryFind(IComparer`1<TKey> comparer, TKey k, MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MapTree`2<TKey, a>, MapTree`2<TKey, a>> partition1(IComparer`1<TKey> comparer, FSharpFunc`3<TKey, a, bool> f, TKey k, a v, MapTree`2<TKey, a> acc1, MapTree`2<TKey, a> acc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MapTree`2<TKey, a>, MapTree`2<TKey, a>> partitionAux(IComparer`1<TKey> comparer, FSharpFunc`3<TKey, a, bool> f, MapTree`2<TKey, a> m, MapTree`2<TKey, a> acc_0, MapTree`2<TKey, a> acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MapTree`2<TKey, a>, MapTree`2<TKey, a>> partition(IComparer`1<TKey> comparer, FSharpFunc`2<TKey, FSharpFunc`2<a, bool>> f, MapTree`2<TKey, a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<TKey, a> filter1(IComparer`1<TKey> comparer, FSharpFunc`3<TKey, a, bool> f, TKey k, a v, MapTree`2<TKey, a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<TKey, a> filterAux(IComparer`1<TKey> comparer, FSharpFunc`3<TKey, a, bool> f, MapTree`2<TKey, a> m, MapTree`2<TKey, a> acc);
    internal static Tuple`3<TKey, TValue, MapTree`2<TKey, TValue>> spliceOutSuccessor(MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<TKey, TValue> remove(IComparer`1<TKey> comparer, TKey k, MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<TKey, TValue> change(IComparer`1<TKey> comparer, TKey k, FSharpFunc`2<FSharpOption`1<TValue>, FSharpOption`1<TValue>> u, MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool mem(IComparer`1<TKey> comparer, TKey k, MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iterOpt(FSharpFunc`3<TKey, TValue, Unit> f, MapTree`2<TKey, TValue> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<c> tryPickOpt(FSharpFunc`3<a, b, FSharpOption`1<c>> f, MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsOpt(FSharpFunc`3<a, b, bool> f, MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forallOpt(FSharpFunc`3<a, b, bool> f, MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<c, b> map(FSharpFunc`2<a, b> f, MapTree`2<c, a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, c> mapiOpt(FSharpFunc`3<a, b, c> f, MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c foldBackOpt(FSharpFunc`4<a, b, c, c> f, MapTree`2<a, b> m, c x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldOpt(FSharpFunc`4<a, b, c, a> f, a x, MapTree`2<b, c> m);
    internal static d foldFromTo@358(IComparer`1<TKey> comparer, TKey lo, TKey hi, FSharpFunc`4<TKey, c, d, d> f, MapTree`2<TKey, c> m, d x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b foldSectionOpt(IComparer`1<TKey> comparer, TKey lo, TKey hi, FSharpFunc`4<TKey, a, b, b> f, MapTree`2<TKey, a> m, b x);
    internal static FSharpList`1<Tuple`2<c, d>> loop@380-42(MapTree`2<c, d> m, FSharpList`1<Tuple`2<c, d>> acc);
    internal static FSharpList`1<Tuple`2<a, b>> toList(MapTree`2<a, b> m);
    internal static Tuple`2[] toArray(MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> ofList(IComparer`1<a> comparer, FSharpList`1<Tuple`2<a, b>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> mkFromEnumerator(IComparer`1<a> comparer, MapTree`2<a, b> acc, IEnumerator`1<Tuple`2<a, b>> e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> ofArray(IComparer`1<a> comparer, Tuple`2[] arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<TKey, T> ofSeq(IComparer`1<TKey> comparer, IEnumerable`1<Tuple`2<TKey, T>> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void copyToArray(MapTree`2<a, b> m, KeyValuePair`2[] arr, int i);
    internal static FSharpList`1<MapTree`2<a, b>> collapseLHS(FSharpList`1<MapTree`2<a, b>> stack);
    internal static MapIterator`2<a, b> mkIterator(MapTree`2<a, b> m);
    internal static a notStarted();
    internal static a alreadyFinished();
    internal static KeyValuePair`2<a, b> current(MapIterator`2<a, b> i);
    internal static bool moveNext(MapIterator`2<a, b> i);
    internal static IEnumerator`1<KeyValuePair`2<a, b>> mkIEnumerator(MapTree`2<a, b> m);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Collections.PrivateListHelpers : object {
    internal static a notStarted();
    internal static a alreadyFinished();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> appendToFreshConsTail(FSharpList`1<a> cons, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int lengthAcc(int acc, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a nth(FSharpList`1<a> l, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sliceFreshConsTail(FSharpList`1<a> cons, int n, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> sliceTake(int n, FSharpList`1<a> l);
    internal static FSharpList`1<b> loop@3675(int i, FSharpList`1<b> lst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> sliceSkip(int n, FSharpList`1<a> l);
}
[RequireQualifiedAccessAttribute]
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.SeqModule : object {
    internal static IEnumerable`1<T> mkDelayedSeq(FSharpFunc`2<Unit, IEnumerable`1<T>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<b> mkUnfoldSeq(FSharpFunc`2<a, FSharpOption`1<Tuple`2<b, a>>> f, a x);
    [CompilationSourceNameAttribute("delay")]
public static IEnumerable`1<T> Delay(FSharpFunc`2<Unit, IEnumerable`1<T>> generator);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("unfold")]
public static IEnumerable`1<T> Unfold(FSharpFunc`2<TState, FSharpOption`1<Tuple`2<T, TState>>> generator, TState state);
    [GeneralizableValueAttribute]
[CompilationSourceNameAttribute("empty")]
public static IEnumerable`1<T> Empty();
    [CompilationSourceNameAttribute("initInfinite")]
public static IEnumerable`1<T> InitializeInfinite(FSharpFunc`2<int, T> initializer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("init")]
public static IEnumerable`1<T> Initialize(int count, FSharpFunc`2<int, T> initializer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<T, Unit> action, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("item")]
public static T Item(int index, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryItem")]
public static FSharpOption`1<T> TryItem(int index, IEnumerable`1<T> source);
    [ObsoleteAttribute("please use Seq.item")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("nth")]
public static T Get(int index, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iteri")]
public static void IterateIndexed(FSharpFunc`2<int, FSharpFunc`2<T, Unit>> action, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists")]
public static bool Exists(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("contains")]
public static bool Contains(T value, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall")]
public static bool ForAll(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter2")]
public static void Iterate2(FSharpFunc`2<T1, FSharpFunc`2<T2, Unit>> action, IEnumerable`1<T1> source1, IEnumerable`1<T2> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iteri2")]
public static void IterateIndexed2(FSharpFunc`2<int, FSharpFunc`2<T1, FSharpFunc`2<T2, Unit>>> action, IEnumerable`1<T1> source1, IEnumerable`1<T2> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<b> revamp(FSharpFunc`2<IEnumerator`1<a>, IEnumerator`1<b>> f, IEnumerable`1<a> ie);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<c> revamp2(FSharpFunc`2<IEnumerator`1<a>, FSharpFunc`2<IEnumerator`1<b>, IEnumerator`1<c>>> f, IEnumerable`1<a> ie1, IEnumerable`1<b> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<d> revamp3(FSharpFunc`2<IEnumerator`1<a>, FSharpFunc`2<IEnumerator`1<b>, FSharpFunc`2<IEnumerator`1<c>, IEnumerator`1<d>>>> f, IEnumerable`1<a> ie1, IEnumerable`1<b> source2, IEnumerable`1<c> source3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static IEnumerable`1<T> Filter(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("where")]
public static IEnumerable`1<T> Where(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static IEnumerable`1<TResult> Map(FSharpFunc`2<T, TResult> mapping, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapi")]
public static IEnumerable`1<TResult> MapIndexed(FSharpFunc`2<int, FSharpFunc`2<T, TResult>> mapping, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapi2")]
public static IEnumerable`1<TResult> MapIndexed2(FSharpFunc`2<int, FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>>> mapping, IEnumerable`1<T1> source1, IEnumerable`1<T2> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map2")]
public static IEnumerable`1<TResult> Map2(FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> mapping, IEnumerable`1<T1> source1, IEnumerable`1<T2> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map3")]
public static IEnumerable`1<TResult> Map3(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> mapping, IEnumerable`1<T1> source1, IEnumerable`1<T2> source2, IEnumerable`1<T3> source3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("choose")]
public static IEnumerable`1<TResult> Choose(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("indexed")]
public static IEnumerable`1<Tuple`2<int, T>> Indexed(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zip")]
public static IEnumerable`1<Tuple`2<T1, T2>> Zip(IEnumerable`1<T1> source1, IEnumerable`1<T2> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zip3")]
public static IEnumerable`1<Tuple`3<T1, T2, T3>> Zip3(IEnumerable`1<T1> source1, IEnumerable`1<T2> source2, IEnumerable`1<T3> source3);
    [CompilationSourceNameAttribute("cast")]
public static IEnumerable`1<T> Cast(IEnumerable source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryPick")]
public static FSharpOption`1<TResult> TryPick(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("pick")]
public static TResult Pick(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFind")]
public static FSharpOption`1<T> TryFind(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("find")]
public static T Find(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("take")]
public static IEnumerable`1<T> Take(int count, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("isEmpty")]
public static bool IsEmpty(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("concat")]
public static IEnumerable`1<T> Concat(IEnumerable`1<TCollection> sources);
    [CompilationSourceNameAttribute("length")]
public static int Length(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold")]
public static TState Fold(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> folder, TState state, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold2")]
public static TState Fold2(FSharpFunc`2<TState, FSharpFunc`2<T1, FSharpFunc`2<T2, TState>>> folder, TState state, IEnumerable`1<T1> source1, IEnumerable`1<T2> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("reduce")]
public static T Reduce(FSharpFunc`2<T, FSharpFunc`2<T, T>> reduction, IEnumerable`1<T> source);
    internal static IEnumerable`1<b> fromGenerator(FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("replicate")]
public static IEnumerable`1<T> Replicate(int count, T initial);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("append")]
public static IEnumerable`1<T> Append(IEnumerable`1<T> source1, IEnumerable`1<T> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("collect")]
public static IEnumerable`1<TResult> Collect(FSharpFunc`2<T, TCollection> mapping, IEnumerable`1<T> source);
    internal static int go@784(IEnumerator`1<T> e1, IEnumerator`1<T> e2, FSharpFunc`3<T, T, int> f, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("compareWith")]
public static int CompareWith(FSharpFunc`2<T, FSharpFunc`2<T, int>> comparer, IEnumerable`1<T> source1, IEnumerable`1<T> source2);
    [CompilationSourceNameAttribute("ofList")]
public static IEnumerable`1<T> OfList(FSharpList`1<T> source);
    [CompilationSourceNameAttribute("toList")]
public static FSharpList`1<T> ToList(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("ofArray")]
public static IEnumerable`1<T> OfArray(T[] source);
    [CompilationSourceNameAttribute("toArray")]
public static T[] ToArray(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldArraySubRight(FSharpFunc`3<T, a, a> f, T[] arr, int start, int fin, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack")]
public static TState FoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> folder, IEnumerable`1<T> source, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack2")]
public static TState FoldBack2(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<TState, TState>>> folder, IEnumerable`1<T1> source1, IEnumerable`1<T2> source2, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("reduceBack")]
public static T ReduceBack(FSharpFunc`2<T, FSharpFunc`2<T, T>> reduction, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("singleton")]
public static IEnumerable`1<T> Singleton(T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("truncate")]
public static IEnumerable`1<T> Truncate(int count, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("pairwise")]
public static IEnumerable`1<Tuple`2<T, T>> Pairwise(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("scan")]
public static IEnumerable`1<TState> Scan(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> folder, TState state, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindBack")]
public static FSharpOption`1<T> TryFindBack(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findBack")]
public static T FindBack(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("scanBack")]
public static IEnumerable`1<TState> ScanBack(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> folder, IEnumerable`1<T> source, TState state);
    internal static int loop@913-21(FSharpFunc`2<T, bool> predicate, IEnumerator`1<T> ie, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findIndex")]
public static int FindIndex(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    internal static FSharpOption`1<int> loop@926-22(FSharpFunc`2<T, bool> predicate, IEnumerator`1<T> ie, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindIndex")]
public static FSharpOption`1<int> TryFindIndex(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindIndexBack")]
public static FSharpOption`1<int> TryFindIndexBack(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findIndexBack")]
public static int FindIndexBack(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("windowed")]
public static IEnumerable`1<T[]> Windowed(int windowSize, IEnumerable`1<T> source);
    [CompilerGeneratedAttribute]
internal static void action@4737-2(List`1<T> prefix, FSharpRef`1<FSharpOption`1<FSharpOption`1<IEnumerator`1<T>>>> enumeratorR, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<T, int>> action@4737-1(IEnumerable`1<T> source, List`1<T> prefix, FSharpRef`1<FSharpOption`1<FSharpOption`1<IEnumerator`1<T>>>> enumeratorR, int i, Unit unitVar0);
    internal static void oneStepTo@987(IEnumerable`1<T> source, List`1<T> prefix, FSharpRef`1<FSharpOption`1<FSharpOption`1<IEnumerator`1<T>>>> enumeratorR, int i);
    [CompilationSourceNameAttribute("cache")]
public static IEnumerable`1<T> Cache(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("allPairs")]
public static IEnumerable`1<Tuple`2<T1, T2>> AllPairs(IEnumerable`1<T1> source1, IEnumerable`1<T2> source2);
    [CompilationSourceNameAttribute("readonly")]
public static IEnumerable`1<T> ReadOnly(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Tuple`2<TKey, IEnumerable`1<T>>> groupByValueType(FSharpFunc`2<T, TKey> keyf, IEnumerable`1<T> seq);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Tuple`2<TKey, IEnumerable`1<T>>> groupByRefType(FSharpFunc`2<T, TKey> keyf, IEnumerable`1<T> seq);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("groupBy")]
public static IEnumerable`1<Tuple`2<TKey, IEnumerable`1<T>>> GroupBy(FSharpFunc`2<T, TKey> projection, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("transpose")]
public static IEnumerable`1<IEnumerable`1<T>> Transpose(IEnumerable`1<TCollection> source);
    [CompilationSourceNameAttribute("distinct")]
public static IEnumerable`1<T> Distinct(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("distinctBy")]
public static IEnumerable`1<T> DistinctBy(FSharpFunc`2<T, TKey> projection, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortBy")]
public static IEnumerable`1<T> SortBy(FSharpFunc`2<T, TKey> projection, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("sort")]
public static IEnumerable`1<T> Sort(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortWith")]
public static IEnumerable`1<T> SortWith(FSharpFunc`2<T, FSharpFunc`2<T, int>> comparer, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sortByDescending")]
public static IEnumerable`1<T> SortByDescending(FSharpFunc`2<T, TKey> projection, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("sortDescending")]
public static IEnumerable`1<T> SortDescending(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Tuple`2<TKey, int>> countByValueType(FSharpFunc`2<T, TKey> keyf, IEnumerable`1<T> seq);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Tuple`2<TKey, int>> countByRefType(FSharpFunc`2<T, TKey> keyf, IEnumerable`1<T> seq);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("countBy")]
public static IEnumerable`1<Tuple`2<TKey, int>> CountBy(FSharpFunc`2<T, TKey> projection, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("sum")]
public static T Sum(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("sum")]
public static T Sum$W(FSharpFunc`2<Unit, T> get_Zero, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Addition, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sumBy")]
public static TResult SumBy(FSharpFunc`2<T, TResult> projection, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sumBy")]
public static TResult SumBy$W(FSharpFunc`2<Unit, TResult> get_Zero, FSharpFunc`2<TResult, FSharpFunc`2<TResult, TResult>> op_Addition, FSharpFunc`2<T, TResult> projection, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("average")]
public static T Average(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("average")]
public static T Average$W(FSharpFunc`2<T, FSharpFunc`2<int, T>> divideByInt, FSharpFunc`2<Unit, T> get_Zero, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Addition, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("averageBy")]
public static TResult AverageBy(FSharpFunc`2<T, TResult> projection, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("averageBy")]
public static TResult AverageBy$W(FSharpFunc`2<TResult, FSharpFunc`2<int, TResult>> divideByInt, FSharpFunc`2<Unit, TResult> get_Zero, FSharpFunc`2<TResult, FSharpFunc`2<TResult, TResult>> op_Addition, FSharpFunc`2<T, TResult> projection, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("min")]
public static T Min(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("minBy")]
public static T MinBy(FSharpFunc`2<T, TResult> projection, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("max")]
public static T Max(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("maxBy")]
public static T MaxBy(FSharpFunc`2<T, TResult> projection, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("takeWhile")]
public static IEnumerable`1<T> TakeWhile(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("skip")]
public static IEnumerable`1<T> Skip(int count, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("skipWhile")]
public static IEnumerable`1<T> SkipWhile(FSharpFunc`2<T, bool> predicate, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall2")]
public static bool ForAll2(FSharpFunc`2<T1, FSharpFunc`2<T2, bool>> predicate, IEnumerable`1<T1> source1, IEnumerable`1<T2> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists2")]
public static bool Exists2(FSharpFunc`2<T1, FSharpFunc`2<T2, bool>> predicate, IEnumerable`1<T1> source1, IEnumerable`1<T2> source2);
    [CompilationSourceNameAttribute("head")]
public static T Head(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("tryHead")]
public static FSharpOption`1<T> TryHead(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("tail")]
public static IEnumerable`1<T> Tail(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("last")]
public static T Last(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("tryLast")]
public static FSharpOption`1<T> TryLast(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("exactlyOne")]
public static T ExactlyOne(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("tryExactlyOne")]
public static FSharpOption`1<T> TryExactlyOne(IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("rev")]
public static IEnumerable`1<T> Reverse(IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("permute")]
public static IEnumerable`1<T> Permute(FSharpFunc`2<int, int> indexMap, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapFold")]
public static Tuple`2<IEnumerable`1<TResult>, TState> MapFold(FSharpFunc`2<TState, FSharpFunc`2<T, Tuple`2<TResult, TState>>> mapping, TState state, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapFoldBack")]
public static Tuple`2<IEnumerable`1<TResult>, TState> MapFoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, Tuple`2<TResult, TState>>> mapping, IEnumerable`1<T> source, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("except")]
public static IEnumerable`1<T> Except(IEnumerable`1<T> itemsToExclude, IEnumerable`1<T> source);
    internal static T[] nextChunk@1470(int chunkSize, IEnumerator`1<T> e, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("chunkBySize")]
public static IEnumerable`1<T[]> ChunkBySize(int chunkSize, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("splitInto")]
public static IEnumerable`1<T[]> SplitInto(int count, IEnumerable`1<T> source);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Collections.SetDebugView`1 : object {
    internal FSharpSet`1<T> v;
    [DebuggerBrowsableAttribute("3")]
internal T[] Items { get; }
    public SetDebugView`1(FSharpSet`1<T> v);
    internal T[] get_Items();
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Collections.SetModule : object {
    [CompilationSourceNameAttribute("isEmpty")]
public static bool IsEmpty(FSharpSet`1<T> set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("contains")]
public static bool Contains(T element, FSharpSet`1<T> set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("add")]
public static FSharpSet`1<T> Add(T value, FSharpSet`1<T> set);
    [CompilationSourceNameAttribute("singleton")]
public static FSharpSet`1<T> Singleton(T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("remove")]
public static FSharpSet`1<T> Remove(T value, FSharpSet`1<T> set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("union")]
public static FSharpSet`1<T> Union(FSharpSet`1<T> set1, FSharpSet`1<T> set2);
    [CompilationSourceNameAttribute("unionMany")]
public static FSharpSet`1<T> UnionMany(IEnumerable`1<FSharpSet`1<T>> sets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("intersect")]
public static FSharpSet`1<T> Intersect(FSharpSet`1<T> set1, FSharpSet`1<T> set2);
    [CompilationSourceNameAttribute("intersectMany")]
public static FSharpSet`1<T> IntersectMany(IEnumerable`1<FSharpSet`1<T>> sets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<T, Unit> action, FSharpSet`1<T> set);
    [GeneralizableValueAttribute]
[CompilationSourceNameAttribute("empty")]
public static FSharpSet`1<T> Empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall")]
public static bool ForAll(FSharpFunc`2<T, bool> predicate, FSharpSet`1<T> set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists")]
public static bool Exists(FSharpFunc`2<T, bool> predicate, FSharpSet`1<T> set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static FSharpSet`1<T> Filter(FSharpFunc`2<T, bool> predicate, FSharpSet`1<T> set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("partition")]
public static Tuple`2<FSharpSet`1<T>, FSharpSet`1<T>> Partition(FSharpFunc`2<T, bool> predicate, FSharpSet`1<T> set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold")]
public static TState Fold(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> folder, TState state, FSharpSet`1<T> set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack")]
public static TState FoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> folder, FSharpSet`1<T> set, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static FSharpSet`1<TResult> Map(FSharpFunc`2<T, TResult> mapping, FSharpSet`1<T> set);
    [CompilationSourceNameAttribute("count")]
public static int Count(FSharpSet`1<T> set);
    [CompilationSourceNameAttribute("ofList")]
public static FSharpSet`1<T> OfList(FSharpList`1<T> elements);
    [CompilationSourceNameAttribute("ofArray")]
public static FSharpSet`1<T> OfArray(T[] array);
    [CompilationSourceNameAttribute("toList")]
public static FSharpList`1<T> ToList(FSharpSet`1<T> set);
    [CompilationSourceNameAttribute("toArray")]
public static T[] ToArray(FSharpSet`1<T> set);
    [CompilationSourceNameAttribute("toSeq")]
public static IEnumerable`1<T> ToSeq(FSharpSet`1<T> set);
    [CompilationSourceNameAttribute("ofSeq")]
public static FSharpSet`1<T> OfSeq(IEnumerable`1<T> elements);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("difference")]
public static FSharpSet`1<T> Difference(FSharpSet`1<T> set1, FSharpSet`1<T> set2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("isSubset")]
public static bool IsSubset(FSharpSet`1<T> set1, FSharpSet`1<T> set2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("isSuperset")]
public static bool IsSuperset(FSharpSet`1<T> set1, FSharpSet`1<T> set2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("isProperSubset")]
public static bool IsProperSubset(FSharpSet`1<T> set1, FSharpSet`1<T> set2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("isProperSuperset")]
public static bool IsProperSuperset(FSharpSet`1<T> set1, FSharpSet`1<T> set2);
    [CompilationSourceNameAttribute("minElement")]
public static T MinElement(FSharpSet`1<T> set);
    [CompilationSourceNameAttribute("maxElement")]
public static T MaxElement(FSharpSet`1<T> set);
}
[CompilationRepresentationAttribute("8")]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("33")]
internal class Microsoft.FSharp.Collections.SetTree`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static SetTree`1<T> SetEmpty { get; }
    [CompilationMappingAttribute("8", "0")]
internal static SetTree`1<T> get_SetEmpty();
    [CompilationMappingAttribute("8", "1")]
internal static SetTree`1<T> NewSetNode(T item1, SetTree`1<T> item2, SetTree`1<T> item3, int item4);
    [CompilationMappingAttribute("8", "2")]
internal static SetTree`1<T> NewSetOne(T item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int GetTag(SetTree`1<T> );
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Collections.SetTreeModule : object {
    internal static int tolerance { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int countAux(SetTree`1<a> s, int acc);
    internal static int height(SetTree`1<a> t);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_tolerance();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> mk(SetTree`1<a> l, a k, SetTree`1<a> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> rebalance(SetTree`1<a> t1, a k, SetTree`1<a> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> add(IComparer`1<T> comparer, T k, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> balance(IComparer`1<a> comparer, SetTree`1<a> t1, a k, SetTree`1<a> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<SetTree`1<T>, bool, SetTree`1<T>> split(IComparer`1<T> comparer, T pivot, SetTree`1<T> t);
    internal static Tuple`2<a, SetTree`1<a>> spliceOutSuccessor(SetTree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> remove(IComparer`1<T> comparer, T k, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool mem(IComparer`1<T> comparer, T k, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<a, Unit> f, SetTree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b foldBackOpt(FSharpFunc`3<a, b, b> f, SetTree`1<a> m, b x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldOpt(FSharpFunc`3<a, b, a> f, a x, SetTree`1<b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<a, bool> f, SetTree`1<a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<a, bool> f, SetTree`1<a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool subset(IComparer`1<a> comparer, SetTree`1<a> a, SetTree`1<a> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool properSubset(IComparer`1<a> comparer, SetTree`1<a> a, SetTree`1<a> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> filterAux(IComparer`1<a> comparer, FSharpFunc`2<a, bool> f, SetTree`1<a> s, SetTree`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> diffAux(IComparer`1<a> comparer, SetTree`1<a> m, SetTree`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> union(IComparer`1<a> comparer, SetTree`1<a> t1, SetTree`1<a> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> intersectionAux(IComparer`1<a> comparer, SetTree`1<a> b, SetTree`1<a> m, SetTree`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SetTree`1<a>, SetTree`1<a>> partition1(IComparer`1<a> comparer, FSharpFunc`2<a, bool> f, a k, SetTree`1<a> acc1, SetTree`1<a> acc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SetTree`1<a>, SetTree`1<a>> partitionAux(IComparer`1<a> comparer, FSharpFunc`2<a, bool> f, SetTree`1<a> s, SetTree`1<a> acc_0, SetTree`1<a> acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a minimumElementAux(SetTree`1<a> s, a n);
    internal static FSharpOption`1<a> minimumElementOpt(SetTree`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a maximumElementAux(SetTree`1<a> s, a n);
    internal static FSharpOption`1<a> maximumElementOpt(SetTree`1<a> s);
    internal static a minimumElement(SetTree`1<a> s);
    internal static a maximumElement(SetTree`1<a> s);
    internal static FSharpList`1<SetTree`1<a>> collapseLHS(FSharpList`1<SetTree`1<a>> stack);
    internal static SetIterator`1<a> mkIterator(SetTree`1<a> s);
    internal static a notStarted();
    internal static a alreadyFinished();
    internal static a current(SetIterator`1<a> i);
    internal static bool moveNext(SetIterator`1<a> i);
    internal static IEnumerator`1<a> mkIEnumerator(SetTree`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int compareStacks(IComparer`1<T> comparer, FSharpList`1<SetTree`1<T>> l1, FSharpList`1<SetTree`1<T>> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int compare(IComparer`1<a> comparer, SetTree`1<a> s1, SetTree`1<a> s2);
    internal static FSharpList`1<b> loop@481-44(SetTree`1<b> m, FSharpList`1<b> acc);
    internal static FSharpList`1<a> toList(SetTree`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void copyToArray(SetTree`1<a> s, a[] arr, int i);
    internal static a[] toArray(SetTree`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> mkFromEnumerator(IComparer`1<a> comparer, SetTree`1<a> acc, IEnumerator`1<a> e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> ofSeq(IComparer`1<a> comparer, IEnumerable`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> ofArray(IComparer`1<a> comparer, a[] l);
}
[StructAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Control.AsyncActivation`1 : ValueType {
    internal AsyncActivationContents`1<T> contents;
    internal AsyncActivationAux aux { get; }
    internal FSharpFunc`2<T, AsyncReturn> cont { get; }
    internal FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt { get; }
    internal FSharpFunc`2<OperationCanceledException, AsyncReturn> ccont { get; }
    internal CancellationToken token { get; }
    internal TrampolineHolder trampolineHolder { get; }
    public bool IsCancellationRequested { get; }
    internal AsyncActivation`1(AsyncActivationContents`1<T> contents);
    internal AsyncActivation`1<T> WithCancellationContinuation(FSharpFunc`2<OperationCanceledException, AsyncReturn> ccont);
    internal AsyncActivation`1<T> WithExceptionContinuation(FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt);
    internal AsyncActivation`1<TResult> WithContinuation(FSharpFunc`2<TResult, AsyncReturn> cont);
    internal AsyncActivation`1<TResult> WithContinuations(FSharpFunc`2<TResult, AsyncReturn> cont, FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt);
    internal AsyncActivation`1<T> WithContinuations(FSharpFunc`2<T, AsyncReturn> cont, FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt, FSharpFunc`2<OperationCanceledException, AsyncReturn> ccont);
    internal AsyncActivationAux get_aux();
    internal FSharpFunc`2<T, AsyncReturn> get_cont();
    internal FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> get_econt();
    internal FSharpFunc`2<OperationCanceledException, AsyncReturn> get_ccont();
    internal CancellationToken get_token();
    internal TrampolineHolder get_trampolineHolder();
    public bool get_IsCancellationRequested();
    public AsyncReturn OnCancellation();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal AsyncReturn HijackCheckThenCall(FSharpFunc`2<a, AsyncReturn> cont, a arg);
    public AsyncReturn OnSuccess(T result);
    public void OnExceptionRaised();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AsyncActivation`1<T> Create(CancellationToken cancellationToken, TrampolineHolder trampolineHolder, FSharpFunc`2<T, AsyncReturn> cont, FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt, FSharpFunc`2<OperationCanceledException, AsyncReturn> ccont);
    internal AsyncReturn QueueContinuationWithTrampoline(T result);
    internal AsyncReturn CallContinuation(T result);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute("34")]
internal class Microsoft.FSharp.Control.AsyncActivationAux : object {
    [DebuggerBrowsableAttribute("0")]
internal CancellationToken token@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<OperationCanceledException, AsyncReturn> ccont@;
    [DebuggerBrowsableAttribute("0")]
internal TrampolineHolder trampolineHolder@;
    [CompilationMappingAttribute("4", "0")]
internal CancellationToken token { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpFunc`2<OperationCanceledException, AsyncReturn> ccont { get; }
    [CompilationMappingAttribute("4", "3")]
internal TrampolineHolder trampolineHolder { get; }
    internal AsyncActivationAux(CancellationToken token, FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt, FSharpFunc`2<OperationCanceledException, AsyncReturn> ccont, TrampolineHolder trampolineHolder);
    internal CancellationToken get_token();
    internal FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> get_econt();
    internal FSharpFunc`2<OperationCanceledException, AsyncReturn> get_ccont();
    internal TrampolineHolder get_trampolineHolder();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute("34")]
internal class Microsoft.FSharp.Control.AsyncActivationContents`1 : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<T, AsyncReturn> cont@;
    [DebuggerBrowsableAttribute("0")]
internal AsyncActivationAux aux@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpFunc`2<T, AsyncReturn> cont { get; }
    [CompilationMappingAttribute("4", "1")]
internal AsyncActivationAux aux { get; }
    internal AsyncActivationContents`1(FSharpFunc`2<T, AsyncReturn> cont, AsyncActivationAux aux);
    internal FSharpFunc`2<T, AsyncReturn> get_cont();
    internal AsyncActivationAux get_aux();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Control.AsyncBuilderImpl : object {
    [CompilationMappingAttribute("9")]
internal static FSharpAsyncBuilder async { get; }
    internal static FSharpAsyncBuilder get_async();
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Control.AsyncHelpers : object {
    internal static void start@21-2(ResultCell`1<AsyncResult`1<FSharpChoice`2<a, b>>> resultCell, CancellationToken _arg1, FSharpAsync`1<c> a, FSharpFunc`2<c, FSharpChoice`2<a, b>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<FSharpChoice`2<a, b>> awaitEither(FSharpAsync`1<a> a1, FSharpAsync`1<b> a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<Unit> timeout(int msec, CancellationToken cancellationToken);
}
[SealedAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Control.AsyncPrimitives : object {
    [CompilationMappingAttribute("9")]
internal static CancellationTokenSource defaultCancellationTokenSource { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpAsync`1<CancellationToken> cancellationTokenAsync { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpAsync`1<Unit> unitAsync { get; }
    internal static CancellationTokenSource get_defaultCancellationTokenSource();
    internal static void set_defaultCancellationTokenSource(CancellationTokenSource value);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static AsyncReturn Invoke(FSharpAsync`1<T> computation, AsyncActivation`1<T> ctxt);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AsyncReturn CallThenContinue(FSharpFunc`2<a, b> userCode, a arg, AsyncActivation`1<b> ctxt);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static AsyncReturn CallThenInvoke(AsyncActivation`1<T> ctxt, TResult result1, FSharpFunc`2<TResult, FSharpAsync`1<T>> part2);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AsyncReturn CallThenInvokeNoHijackCheck(AsyncActivation`1<a> ctxt, FSharpFunc`2<b, FSharpAsync`1<a>> userCode, b result1);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AsyncReturn CallFilterThenInvoke(AsyncActivation`1<T> ctxt, FSharpFunc`2<Exception, FSharpOption`1<FSharpAsync`1<T>>> catchFilter, ExceptionDispatchInfo edi);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AsyncReturn ProtectedCode(AsyncActivation`1<T> ctxt, FSharpFunc`2<AsyncActivation`1<T>, AsyncReturn> userCode);
    [DebuggerHiddenAttribute]
public static FSharpAsync`1<T> MakeAsync(FSharpFunc`2<AsyncActivation`1<T>, AsyncReturn> body);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static AsyncReturn Bind(AsyncActivation`1<T> ctxt, FSharpAsync`1<TResult> part1, FSharpFunc`2<TResult, FSharpAsync`1<T>> part2);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static AsyncReturn TryFinally(AsyncActivation`1<T> ctxt, FSharpAsync`1<T> computation, FSharpFunc`2<Unit, Unit> finallyFunction);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static AsyncReturn TryWith(AsyncActivation`1<T> ctxt, FSharpAsync`1<T> computation, FSharpFunc`2<Exception, FSharpOption`1<FSharpAsync`1<T>>> catchFunction);
    internal static FSharpAsync`1<a> CreateProtectedAsync(FSharpFunc`2<AsyncActivation`1<a>, AsyncReturn> f);
    internal static FSharpAsync`1<T> CreateAsyncResultAsync(AsyncResult`1<T> res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<a> CreateWhenCancelledAsync(FSharpFunc`2<OperationCanceledException, Unit> finallyFunction, FSharpAsync`1<a> computation);
    internal static FSharpAsync`1<CancellationToken> get_cancellationTokenAsync();
    internal static FSharpAsync`1<Unit> get_unitAsync();
    internal static FSharpFunc`2<b, Unit> disposeFunction@582(T resource, FSharpRef`1<int> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<a> CreateUsingAsync(T resource, FSharpFunc`2<T, FSharpAsync`1<a>> computation);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<Unit> CreateWhileAsync(FSharpFunc`2<Unit, bool> guardFunc, FSharpAsync`1<Unit> computation);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<Unit> CreateForLoopAsync(IEnumerable`1<a> source, FSharpFunc`2<a, FSharpAsync`1<Unit>> computation);
    internal static FSharpAsync`1<Unit> CreateSwitchToAsync(SynchronizationContext syncCtxt);
    internal static FSharpAsync`1<Unit> CreateSwitchToNewThreadAsync();
    internal static FSharpAsync`1<Unit> CreateSwitchToThreadPoolAsync();
    internal static AsyncActivation`1<a> DelimitSyncContext(AsyncActivation`1<a> ctxt);
    internal static FSharpAsync`1<a> CreateDelimitedUserCodeAsync(FSharpFunc`2<AsyncActivation`1<a>, AsyncReturn> f);
    [CompilerGeneratedAttribute]
internal static WaitHandle action@4737-13(ResultCell`1<T> x, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void action@4737-14(ResultCell`1<T> x, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SuspendedAsync`1<T>> action@4737-15(ResultCell`1<T> x, T res, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<T> action@4737-16(ResultCell`1<T> x, AsyncActivation`1<T> ctxt, Unit unitVar0);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AsyncReturn QueueAsync(CancellationToken cancellationToken, FSharpFunc`2<a, AsyncReturn> cont, FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt, FSharpFunc`2<OperationCanceledException, AsyncReturn> ccont, FSharpAsync`1<a> computation);
    [DebuggerHiddenAttribute]
internal static a RunSynchronouslyInAnotherThread(CancellationToken token, FSharpAsync`1<a> computation, FSharpOption`1<int> timeout);
    [DebuggerHiddenAttribute]
internal static a RunSynchronouslyInCurrentThread(CancellationToken cancellationToken, FSharpAsync`1<a> computation);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T RunSynchronously(CancellationToken cancellationToken, FSharpAsync`1<T> computation, FSharpOption`1<int> timeout);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void Start(CancellationToken cancellationToken, FSharpAsync`1<Unit> computation);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void StartWithContinuations(CancellationToken cancellationToken, FSharpAsync`1<T> computation, FSharpFunc`2<T, Unit> cont, FSharpFunc`2<ExceptionDispatchInfo, Unit> econt, FSharpFunc`2<OperationCanceledException, Unit> ccont);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Task`1<T> StartAsTask(CancellationToken cancellationToken, FSharpAsync`1<T> computation, FSharpOption`1<TaskCreationOptions> taskCreationOptions);
    internal static void continuation@930(AsyncActivation`1<T> ctxt, bool useCcontForTaskCancellation, Task`1<T> completedTask);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AsyncReturn taskContinueWith(Task`1<T> task, AsyncActivation`1<T> ctxt, bool useCcontForTaskCancellation);
    internal static void continuation@949-2(AsyncActivation`1<Unit> ctxt, bool useCcontForTaskCancellation, Task completedTask);
    [DebuggerHiddenAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AsyncReturn taskContinueWithUnit(Task task, AsyncActivation`1<Unit> ctxt, bool useCcontForTaskCancellation);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("33")]
internal abstract class Microsoft.FSharp.Control.AsyncResult`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOk { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsError { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCanceled { get; }
    [CompilationMappingAttribute("8", "0")]
internal static AsyncResult`1<T> NewOk(T item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsOk();
    [CompilationMappingAttribute("8", "1")]
internal static AsyncResult`1<T> NewError(ExceptionDispatchInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsError();
    [CompilationMappingAttribute("8", "2")]
internal static AsyncResult`1<T> NewCanceled(OperationCanceledException item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCanceled();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [DebuggerHiddenAttribute]
internal T Commit();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("33")]
public class Microsoft.FSharp.Control.AsyncReturn : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AsyncReturn _unique_AsyncReturn;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static AsyncReturn AsyncReturn { get; }
    private static AsyncReturn();
    [CompilationMappingAttribute("8", "0")]
internal static AsyncReturn get_AsyncReturn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    internal static AsyncReturn Fake();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Control.CommonExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("AsyncRead")]
public static FSharpAsync`1<int> AsyncRead(Stream stream, Byte[] buffer, FSharpOption`1<int> offset, FSharpOption`1<int> count);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("AsyncRead")]
public static FSharpAsync`1<Byte[]> AsyncReadBytes(Stream stream, int count);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("AsyncWrite")]
public static FSharpAsync`1<Unit> AsyncWrite(Stream stream, Byte[] buffer, FSharpOption`1<int> offset, FSharpOption`1<int> count);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("Add")]
public static void AddToObservable(IObservable`1<T> x, FSharpFunc`2<T, Unit> callback);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("Subscribe")]
public static IDisposable SubscribeToObservable(IObservable`1<T> x, FSharpFunc`2<T, Unit> callback);
}
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Control.EventDelegee`1 : object {
    internal IObserver`1<TArgs> observer;
    internal static FSharpFunc`2<Object[], object> makeTuple;
    public EventDelegee`1(IObserver`1<TArgs> observer);
    private static EventDelegee`1();
    internal void Invoke(object _sender, TArgs args);
    internal void Invoke(object _sender, a a, b b);
    internal void Invoke(object _sender, a a, b b, c c);
    internal void Invoke(object _sender, a a, b b, c c, d d);
    internal void Invoke(object _sender, a a, b b, c c, d d, e e);
    internal void Invoke(object _sender, a a, b b, c c, d d, e e, f f);
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Control.EventModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static IEvent`2<FSharpHandler`1<TResult>, TResult> Map(FSharpFunc`2<T, TResult> mapping, IEvent`2<TDel, T> sourceEvent);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static IEvent`2<FSharpHandler`1<T>, T> Filter(FSharpFunc`2<T, bool> predicate, IEvent`2<TDel, T> sourceEvent);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("partition")]
public static Tuple`2<IEvent`2<FSharpHandler`1<T>, T>, IEvent`2<FSharpHandler`1<T>, T>> Partition(FSharpFunc`2<T, bool> predicate, IEvent`2<TDel, T> sourceEvent);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("choose")]
public static IEvent`2<FSharpHandler`1<TResult>, TResult> Choose(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, IEvent`2<TDel, T> sourceEvent);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("scan")]
public static IEvent`2<FSharpHandler`1<TResult>, TResult> Scan(FSharpFunc`2<TResult, FSharpFunc`2<T, TResult>> collector, TResult state, IEvent`2<TDel, T> sourceEvent);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("add")]
public static void Add(FSharpFunc`2<T, Unit> callback, IEvent`2<TDel, T> sourceEvent);
    [CompilationSourceNameAttribute("pairwise")]
public static IEvent`2<FSharpHandler`1<Tuple`2<T, T>>, Tuple`2<T, T>> Pairwise(IEvent`2<TDel, T> sourceEvent);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("merge")]
public static IEvent`2<FSharpHandler`1<T>, T> Merge(IEvent`2<TDel1, T> event1, IEvent`2<TDel2, T> event2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("split")]
public static Tuple`2<IEvent`2<FSharpHandler`1<TResult1>, TResult1>, IEvent`2<FSharpHandler`1<TResult2>, TResult2>> Split(FSharpFunc`2<T, FSharpChoice`2<TResult1, TResult2>> splitter, IEvent`2<TDel, T> sourceEvent);
}
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Control.EventWrapper`2 : MulticastDelegate {
    internal EventWrapper`2(object object, IntPtr method);
    internal virtual void Invoke(TDelegate , object , TArgs );
    internal virtual IAsyncResult BeginInvoke(TDelegate , object , TArgs , AsyncCallback callback, object objects);
    internal virtual void EndInvoke(IAsyncResult result);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Control.ExceptionDispatchInfoHelpers : object {
    [CompilationMappingAttribute("9")]
internal static ConditionalWeakTable`2<Exception, ExceptionDispatchInfo> associationTable { get; }
    internal static ConditionalWeakTable`2<Exception, ExceptionDispatchInfo> get_associationTable();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception ExceptionDispatchInfo.GetAssociatedSourceException(ExceptionDispatchInfo );
    [DebuggerHiddenAttribute]
internal static ExceptionDispatchInfo ExceptionDispatchInfo.RestoreOrCapture.Static(Exception exn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T ExceptionDispatchInfo.ThrowAny(ExceptionDispatchInfo );
}
[SealedAttribute]
[CompiledNameAttribute("FSharpAsync")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Control.FSharpAsync : object {
    public static FSharpAsync`1<CancellationToken> CancellationToken { get; }
    public static CancellationToken DefaultCancellationToken { get; }
    public static FSharpAsync`1<CancellationToken> get_CancellationToken();
    internal static FSharpAsync`1<Unit> CancelCheck();
    public static FSharpAsync`1<T> FromContinuations(FSharpFunc`2<Tuple`3<FSharpFunc`2<T, Unit>, FSharpFunc`2<Exception, Unit>, FSharpFunc`2<OperationCanceledException, Unit>>, Unit> callback);
    public static CancellationToken get_DefaultCancellationToken();
    public static void CancelDefaultToken();
    public static FSharpAsync`1<FSharpChoice`2<T, Exception>> Catch(FSharpAsync`1<T> computation);
    public static T RunSynchronously(FSharpAsync`1<T> computation, FSharpOption`1<int> timeout, FSharpOption`1<CancellationToken> cancellationToken);
    public static void Start(FSharpAsync`1<Unit> computation, FSharpOption`1<CancellationToken> cancellationToken);
    public static Task`1<T> StartAsTask(FSharpAsync`1<T> computation, FSharpOption`1<TaskCreationOptions> taskCreationOptions, FSharpOption`1<CancellationToken> cancellationToken);
    public static FSharpAsync`1<Task`1<T>> StartChildAsTask(FSharpAsync`1<T> computation, FSharpOption`1<TaskCreationOptions> taskCreationOptions);
    public static FSharpAsync`1<T[]> Parallel(IEnumerable`1<FSharpAsync`1<T>> computations);
    public static FSharpAsync`1<T[]> Parallel(IEnumerable`1<FSharpAsync`1<T>> computations, FSharpOption`1<int> maxDegreeOfParallelism);
    public static FSharpAsync`1<T[]> Sequential(IEnumerable`1<FSharpAsync`1<T>> computations);
    public static FSharpAsync`1<FSharpOption`1<T>> Choice(IEnumerable`1<FSharpAsync`1<FSharpOption`1<T>>> computations);
    internal static void StartWithContinuationsUsingDispatchInfo(FSharpAsync`1<T> computation, FSharpFunc`2<T, Unit> continuation, FSharpFunc`2<ExceptionDispatchInfo, Unit> exceptionContinuation, FSharpFunc`2<OperationCanceledException, Unit> cancellationContinuation, FSharpOption`1<CancellationToken> cancellationToken);
    public static void StartWithContinuations(FSharpAsync`1<T> computation, FSharpFunc`2<T, Unit> continuation, FSharpFunc`2<Exception, Unit> exceptionContinuation, FSharpFunc`2<OperationCanceledException, Unit> cancellationContinuation, FSharpOption`1<CancellationToken> cancellationToken);
    public static Task`1<T> StartImmediateAsTask(FSharpAsync`1<T> computation, FSharpOption`1<CancellationToken> cancellationToken);
    public static void StartImmediate(FSharpAsync`1<Unit> computation, FSharpOption`1<CancellationToken> cancellationToken);
    internal static FSharpAsync`1<Unit> Sleep(long millisecondsDueTime);
    public static FSharpAsync`1<Unit> Sleep(int millisecondsDueTime);
    public static FSharpAsync`1<Unit> Sleep(TimeSpan dueTime);
    public static FSharpAsync`1<bool> AwaitWaitHandle(WaitHandle waitHandle, FSharpOption`1<int> millisecondsTimeout);
    public static FSharpAsync`1<bool> AwaitIAsyncResult(IAsyncResult iar, FSharpOption`1<int> millisecondsTimeout);
    internal static FSharpAsync`1<T> BindResult(AsyncResult`1<T> result);
    internal static FSharpAsync`1<T> AwaitAndBindResult_NoDirectCancelOrTimeout(ResultCell`1<AsyncResult`1<T>> resultCell);
    internal static FSharpAsync`1<T> AwaitAndBindChildResult(CancellationTokenSource innerCTS, ResultCell`1<AsyncResult`1<T>> resultCell, FSharpOption`1<int> millisecondsTimeout);
    public static FSharpAsync`1<T> FromBeginEnd(FSharpFunc`2<Tuple`2<AsyncCallback, object>, IAsyncResult> beginAction, FSharpFunc`2<IAsyncResult, T> endAction, FSharpOption`1<FSharpFunc`2<Unit, Unit>> cancelAction);
    public static FSharpAsync`1<T> FromBeginEnd(TArg1 arg, FSharpFunc`2<Tuple`3<TArg1, AsyncCallback, object>, IAsyncResult> beginAction, FSharpFunc`2<IAsyncResult, T> endAction, FSharpOption`1<FSharpFunc`2<Unit, Unit>> cancelAction);
    public static FSharpAsync`1<T> FromBeginEnd(TArg1 arg1, TArg2 arg2, FSharpFunc`2<Tuple`4<TArg1, TArg2, AsyncCallback, object>, IAsyncResult> beginAction, FSharpFunc`2<IAsyncResult, T> endAction, FSharpOption`1<FSharpFunc`2<Unit, Unit>> cancelAction);
    public static FSharpAsync`1<T> FromBeginEnd(TArg1 arg1, TArg2 arg2, TArg3 arg3, FSharpFunc`2<Tuple`5<TArg1, TArg2, TArg3, AsyncCallback, object>, IAsyncResult> beginAction, FSharpFunc`2<IAsyncResult, T> endAction, FSharpOption`1<FSharpFunc`2<Unit, Unit>> cancelAction);
    public static Tuple`3<FSharpFunc`2<Tuple`3<TArg, AsyncCallback, object>, IAsyncResult>, FSharpFunc`2<IAsyncResult, T>, FSharpFunc`2<IAsyncResult, Unit>> AsBeginEnd(FSharpFunc`2<TArg, FSharpAsync`1<T>> computation);
    public static FSharpAsync`1<T> AwaitEvent(IEvent`2<TDel, T> event, FSharpOption`1<FSharpFunc`2<Unit, Unit>> cancelAction);
    public static FSharpAsync`1<Unit> Ignore(FSharpAsync`1<T> computation);
    public static FSharpAsync`1<Unit> SwitchToNewThread();
    public static FSharpAsync`1<Unit> SwitchToThreadPool();
    public static FSharpAsync`1<FSharpAsync`1<T>> StartChild(FSharpAsync`1<T> computation, FSharpOption`1<int> millisecondsTimeout);
    public static FSharpAsync`1<Unit> SwitchToContext(SynchronizationContext syncContext);
    public static FSharpAsync`1<IDisposable> OnCancel(FSharpFunc`2<Unit, Unit> interruption);
    public static FSharpAsync`1<T> TryCancelled(FSharpAsync`1<T> computation, FSharpFunc`2<OperationCanceledException, Unit> compensation);
    public static FSharpAsync`1<T> AwaitTask(Task`1<T> task);
    public static FSharpAsync`1<Unit> AwaitTask(Task task);
}
[SealedAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompiledNameAttribute("FSharpAsync`1")]
[CompilationMappingAttribute("34")]
public class Microsoft.FSharp.Control.FSharpAsync`1 : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<AsyncActivation`1<T>, AsyncReturn> Invoke@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpFunc`2<AsyncActivation`1<T>, AsyncReturn> Invoke { get; }
    internal FSharpAsync`1(FSharpFunc`2<AsyncActivation`1<T>, AsyncReturn> invoke);
    internal FSharpFunc`2<AsyncActivation`1<T>, AsyncReturn> get_Invoke();
}
[CompiledNameAttribute("FSharpAsyncBuilder")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Control.FSharpAsyncBuilder : object {
    public FSharpAsync`1<Unit> Zero();
    public FSharpAsync`1<T> Delay(FSharpFunc`2<Unit, FSharpAsync`1<T>> generator);
    public FSharpAsync`1<T> Return(T value);
    public FSharpAsync`1<T> ReturnFrom(FSharpAsync`1<T> computation);
    public FSharpAsync`1<TResult> Bind(FSharpAsync`1<T> computation, FSharpFunc`2<T, FSharpAsync`1<TResult>> binder);
    public FSharpAsync`1<TResult> Using(T resource, FSharpFunc`2<T, FSharpAsync`1<TResult>> binder);
    public FSharpAsync`1<Unit> While(FSharpFunc`2<Unit, bool> guard, FSharpAsync`1<Unit> computation);
    public FSharpAsync`1<Unit> For(IEnumerable`1<T> sequence, FSharpFunc`2<T, FSharpAsync`1<Unit>> body);
    public FSharpAsync`1<T> Combine(FSharpAsync`1<Unit> computation1, FSharpAsync`1<T> computation2);
    public FSharpAsync`1<T> TryFinally(FSharpAsync`1<T> computation, FSharpFunc`2<Unit, Unit> compensation);
    public FSharpAsync`1<T> TryWith(FSharpAsync`1<T> computation, FSharpFunc`2<Exception, FSharpAsync`1<T>> catchHandler);
}
[SealedAttribute]
[CompiledNameAttribute("FSharpAsyncReplyChannel`1")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Control.FSharpAsyncReplyChannel`1 : object {
    internal FSharpFunc`2<TReply, Unit> replyf;
    internal FSharpAsyncReplyChannel`1(FSharpFunc`2<TReply, Unit> replyf);
    public void Reply(TReply value);
}
[CompiledNameAttribute("FSharpDelegateEvent`1")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Control.FSharpDelegateEvent`1 : object {
    internal Delegate multicast;
    public IDelegateEvent`1<TDelegate> Publish { get; }
    public void Trigger(Object[] args);
    public IDelegateEvent`1<TDelegate> get_Publish();
}
[CompiledNameAttribute("FSharpEvent`1")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Control.FSharpEvent`1 : object {
    internal FSharpHandler`1<T> multicast;
    public IEvent`2<FSharpHandler`1<T>, T> Publish { get; }
    public void Trigger(T arg);
    public IEvent`2<FSharpHandler`1<T>, T> get_Publish();
}
[CompiledNameAttribute("FSharpEvent`2")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Control.FSharpEvent`2 : object {
    internal TDelegate multicast;
    internal static EventWrapper`2<TDelegate, TArgs> invoker;
    internal static MethodInfo invokeInfo;
    public IEvent`2<TDelegate, TArgs> Publish { get; }
    private static FSharpEvent`2();
    public void Trigger(object sender, TArgs args);
    public IEvent`2<TDelegate, TArgs> get_Publish();
}
[CompiledNameAttribute("FSharpHandler`1")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Control.FSharpHandler`1 : MulticastDelegate {
    public FSharpHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, T args);
    public virtual IAsyncResult BeginInvoke(object sender, T args, AsyncCallback callback, object objects);
    public virtual void EndInvoke(IAsyncResult result);
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompiledNameAttribute("FSharpMailboxProcessor`1")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Control.FSharpMailboxProcessor`1 : object {
    internal FSharpFunc`2<FSharpMailboxProcessor`1<TMsg>, FSharpAsync`1<Unit>> body;
    internal bool cancellationSupported;
    internal CancellationToken cancellationToken@334;
    internal Mailbox`1<TMsg> mailbox;
    internal int defaultTimeout;
    internal bool started;
    internal FSharpEvent`1<Exception> errorEvent;
    public int CurrentQueueLength { get; }
    public int DefaultTimeout { get; public set; }
    public FSharpMailboxProcessor`1(FSharpFunc`2<FSharpMailboxProcessor`1<TMsg>, FSharpAsync`1<Unit>> body, FSharpOption`1<CancellationToken> cancellationToken);
    public int get_CurrentQueueLength();
    public int get_DefaultTimeout();
    public void set_DefaultTimeout(int v);
    [CLIEventAttribute]
public void add_Error(FSharpHandler`1<Exception> handler);
    [CLIEventAttribute]
public void remove_Error(FSharpHandler`1<Exception> handler);
    public void Start();
    public void Post(TMsg message);
    public FSharpOption`1<TReply> TryPostAndReply(FSharpFunc`2<FSharpAsyncReplyChannel`1<TReply>, TMsg> buildMessage, FSharpOption`1<int> timeout);
    public TReply PostAndReply(FSharpFunc`2<FSharpAsyncReplyChannel`1<TReply>, TMsg> buildMessage, FSharpOption`1<int> timeout);
    public FSharpAsync`1<FSharpOption`1<TReply>> PostAndTryAsyncReply(FSharpFunc`2<FSharpAsyncReplyChannel`1<TReply>, TMsg> buildMessage, FSharpOption`1<int> timeout);
    public FSharpAsync`1<TReply> PostAndAsyncReply(FSharpFunc`2<FSharpAsyncReplyChannel`1<TReply>, TMsg> buildMessage, FSharpOption`1<int> timeout);
    public FSharpAsync`1<TMsg> Receive(FSharpOption`1<int> timeout);
    public FSharpAsync`1<FSharpOption`1<TMsg>> TryReceive(FSharpOption`1<int> timeout);
    public FSharpAsync`1<T> Scan(FSharpFunc`2<TMsg, FSharpOption`1<FSharpAsync`1<T>>> scanner, FSharpOption`1<int> timeout);
    public FSharpAsync`1<FSharpOption`1<T>> TryScan(FSharpFunc`2<TMsg, FSharpOption`1<FSharpAsync`1<T>>> scanner, FSharpOption`1<int> timeout);
    public static FSharpMailboxProcessor`1<TMsg> Start(FSharpFunc`2<FSharpMailboxProcessor`1<TMsg>, FSharpAsync`1<Unit>> body, FSharpOption`1<CancellationToken> cancellationToken);
    private virtual override void System.IDisposable.Dispose();
}
[CompilationMappingAttribute("3")]
public interface Microsoft.FSharp.Control.IDelegateEvent`1 {
    public abstract virtual void AddHandler(TDelegate handler);
    public abstract virtual void RemoveHandler(TDelegate handler);
}
[InterfaceAttribute]
[CompilationMappingAttribute("3")]
public interface Microsoft.FSharp.Control.IEvent`2 {
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Control.Latch : object {
    internal int i;
    internal bool Enter();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Control.LazyExtensions : object {
    [CompilationSourceNameAttribute("Create")]
public static Lazy`1<T> Create(FSharpFunc`2<Unit, T> creator);
    [CompilationSourceNameAttribute("CreateFromValue")]
public static Lazy`1<T> CreateFromValue(T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("get_IsDelayed")]
internal static bool Lazy`1.get_IsDelayed(Lazy`1<T> );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("get_IsForced")]
internal static bool Lazy`1.get_IsForced(Lazy`1<T> );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("Force")]
public static T Force(Lazy`1<T> );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("SynchronizedForce")]
internal static T SynchronizedForceDeprecated(Lazy`1<T> );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("UnsynchronizedForce")]
internal static T UnsynchronizedForceDeprecated(Lazy`1<T> );
}
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Control.LinkedSubSource : object {
    internal CancellationTokenSource failureCTS;
    internal CancellationTokenSource linkedCTS;
    internal CancellationToken Token { get; }
    public LinkedSubSource(CancellationToken cancellationToken);
    internal CancellationToken get_Token();
    internal void Cancel();
    internal void Dispose();
    private virtual override void System.IDisposable.Dispose();
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Control.Mailbox`1 : object {
    internal bool cancellationSupported;
    internal List`1<TMsg> inboxStore;
    internal Queue`1<TMsg> arrivals;
    internal Queue`1<TMsg> syncRoot;
    internal FSharpOption`1<FSharpFunc`2<bool, AsyncReturn>> savedCont;
    internal AutoResetEvent pulse;
    internal FSharpAsync`1<bool> waitOneNoTimeoutOrCancellation;
    internal List`1<TMsg> inbox { get; }
    internal int CurrentQueueLength { get; }
    public Mailbox`1(bool cancellationSupported);
    internal List`1<TMsg> get_inbox();
    internal int get_CurrentQueueLength();
    internal FSharpOption`1<a> ScanArrivalsUnsafe(FSharpFunc`2<TMsg, FSharpOption`1<a>> f);
    internal FSharpOption`1<a> ScanArrivals(FSharpFunc`2<TMsg, FSharpOption`1<a>> f);
    internal FSharpOption`1<a> ScanInbox(FSharpFunc`2<TMsg, FSharpOption`1<a>> f, int n);
    internal FSharpOption`1<TMsg> ReceiveFromArrivalsUnsafe();
    internal FSharpOption`1<TMsg> ReceiveFromArrivals();
    internal FSharpOption`1<TMsg> ReceiveFromInbox();
    internal void Post(TMsg msg);
    internal FSharpAsync`1<FSharpOption`1<T>> TryScan(FSharpFunc`2<TMsg, FSharpOption`1<FSharpAsync`1<T>>> f, int timeout);
    internal FSharpAsync`1<T> Scan(FSharpFunc`2<TMsg, FSharpOption`1<FSharpAsync`1<T>>> f, int timeout);
    internal FSharpAsync`1<FSharpOption`1<TMsg>> TryReceive(int timeout);
    internal FSharpAsync`1<TMsg> Receive(int timeout);
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
internal AutoResetEvent ensurePulse();
    [CompilerGeneratedAttribute]
internal FSharpAsync`1<bool> waitOneWithCancellation(int timeout);
    [CompilerGeneratedAttribute]
internal FSharpAsync`1<bool> waitOne(int timeout);
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Control.ObservableModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static IObservable`1<TResult> Map(FSharpFunc`2<T, TResult> mapping, IObservable`1<T> source);
    [CompilerGeneratedAttribute]
internal static void succeed@14(IObserver`1<TResult> observer, FSharpOption`1<TResult> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("choose")]
public static IObservable`1<TResult> Choose(FSharpFunc`2<T, FSharpOption`1<TResult>> chooser, IObservable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static IObservable`1<T> Filter(FSharpFunc`2<T, bool> predicate, IObservable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("partition")]
public static Tuple`2<IObservable`1<T>, IObservable`1<T>> Partition(FSharpFunc`2<T, bool> predicate, IObservable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("scan")]
public static IObservable`1<TResult> Scan(FSharpFunc`2<TResult, FSharpFunc`2<T, TResult>> collector, TResult state, IObservable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("add")]
public static void Add(FSharpFunc`2<T, Unit> callback, IObservable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("subscribe")]
public static IDisposable Subscribe(FSharpFunc`2<T, Unit> callback, IObservable`1<T> source);
    [CompilationSourceNameAttribute("pairwise")]
public static IObservable`1<Tuple`2<T, T>> Pairwise(IObservable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("merge")]
public static IObservable`1<T> Merge(IObservable`1<T> source1, IObservable`1<T> source2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("split")]
public static Tuple`2<IObservable`1<TResult1>, IObservable`1<TResult2>> Split(FSharpFunc`2<T, FSharpChoice`2<TResult1, TResult2>> splitter, IObservable`1<T> source);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Control.Once : object {
    internal Latch latch;
    internal void Do(FSharpFunc`2<Unit, Unit> f);
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Control.Trampoline : object {
    internal FSharpOption`1<FSharpFunc`2<Unit, AsyncReturn>> storedCont;
    internal FSharpOption`1<FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn>> storedExnCont;
    internal int bindCount;
    [ThreadStaticAttribute]
[DefaultValueAttribute]
internal static bool thisThreadHasTrampoline@;
    [CompilationMappingAttribute("4", "3")]
internal static bool thisThreadHasTrampoline { get; internal set; }
    internal static bool ThisThreadHasTrampoline { get; }
    private static Trampoline();
    internal static bool get_thisThreadHasTrampoline();
    internal static void set_thisThreadHasTrampoline(bool value);
    internal static bool get_ThisThreadHasTrampoline();
    [DebuggerHiddenAttribute]
internal AsyncReturn Execute(FSharpFunc`2<Unit, AsyncReturn> firstAction);
    internal bool IncrementBindCount();
    internal AsyncReturn Set(FSharpFunc`2<Unit, AsyncReturn> action);
    internal void OnExceptionRaised(FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> action);
}
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Control.TrampolineHolder : object {
    internal Trampoline trampoline;
    internal SendOrPostCallback sendOrPostCallbackWithTrampoline;
    internal WaitCallback waitCallbackForQueueWorkItemWithTrampoline;
    internal ParameterizedThreadStart threadStartCallbackForStartThreadWithTrampoline;
    internal int init@143;
    [DebuggerHiddenAttribute]
internal AsyncReturn ExecuteWithTrampoline(FSharpFunc`2<Unit, AsyncReturn> firstAction);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal AsyncReturn PostWithTrampoline(SynchronizationContext syncCtxt, FSharpFunc`2<Unit, AsyncReturn> f);
    internal AsyncReturn QueueWorkItemWithTrampoline(FSharpFunc`2<Unit, AsyncReturn> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal AsyncReturn PostOrQueueWithTrampoline(SynchronizationContext syncCtxt, FSharpFunc`2<Unit, AsyncReturn> f);
    internal AsyncReturn StartThreadWithTrampoline(FSharpFunc`2<Unit, AsyncReturn> f);
    internal void OnExceptionRaised(FSharpFunc`2<ExceptionDispatchInfo, AsyncReturn> econt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal AsyncReturn HijackCheckThenCall(FSharpFunc`2<T, AsyncReturn> cont, T res);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Control.WebExtensions : object {
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FSharpAsync`1<WebResponse>> catchFunction@554(FSharpRef`1<bool> canceled, Exception exn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("AsyncGetResponse")]
public static FSharpAsync`1<WebResponse> AsyncGetResponse(WebRequest );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<d> WebClient.Download(WebClient this, IEvent`2<T, a> event, FSharpFunc`2<FSharpFunc`2<b, FSharpFunc`2<c, Unit>>, T> handler, FSharpFunc`2<object, Unit> start, FSharpFunc`2<c, d> result);
    [CompilerGeneratedAttribute]
internal static DownloadStringCompletedEventHandler handler@1761-1(FSharpFunc`2<object, FSharpFunc`2<DownloadStringCompletedEventArgs, Unit>> action);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("AsyncDownloadString")]
public static FSharpAsync`1<string> AsyncDownloadString(WebClient this, Uri address);
    [CompilerGeneratedAttribute]
internal static DownloadDataCompletedEventHandler handler@1761-2(FSharpFunc`2<object, FSharpFunc`2<DownloadDataCompletedEventArgs, Unit>> action);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("AsyncDownloadData")]
public static FSharpAsync`1<Byte[]> AsyncDownloadData(WebClient this, Uri address);
    [CompilerGeneratedAttribute]
internal static AsyncCompletedEventHandler handler@1761-3(FSharpFunc`2<object, FSharpFunc`2<AsyncCompletedEventArgs, Unit>> action);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("AsyncDownloadFile")]
public static FSharpAsync`1<Unit> AsyncDownloadFile(WebClient this, Uri address, string fileName);
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.AbstractClassAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.AllowNullLiteralAttribute : Attribute {
    internal bool value;
    public bool Value { get; }
    public AllowNullLiteralAttribute(bool value);
    public bool get_Value();
}
[AttributeUsageAttribute("5")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.AutoOpenAttribute : Attribute {
    internal string path;
    public string Path { get; }
    public AutoOpenAttribute(string path);
    public string get_Path();
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.AutoSerializableAttribute : Attribute {
    internal bool value;
    public bool Value { get; }
    public AutoSerializableAttribute(bool value);
    public bool get_Value();
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Core.BasicInlinedOperations : object {
}
[CompilerMessageAttribute("This construct is for use in the FSharp.Core library and should not be used directly", "1204")]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.ByRefKinds : object {
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.ClassAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CLIEventAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CLIMutableAttribute : Attribute {
}
[AttributeUsageAttribute("16384")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.ComparisonConditionalOnAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilationArgumentCountsAttribute : Attribute {
    internal Int32[] counts;
    public IEnumerable`1<int> Counts { get; }
    public CompilationArgumentCountsAttribute(Int32[] counts);
    public IEnumerable`1<int> get_Counts();
}
[AttributeUsageAttribute("32767")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilationMappingAttribute : Attribute {
    internal int variantNumber;
    internal Type[] typeDefinitions;
    internal SourceConstructFlags sourceConstructFlags;
    internal int sequenceNumber;
    internal string resourceName;
    public SourceConstructFlags SourceConstructFlags { get; }
    public int SequenceNumber { get; }
    public int VariantNumber { get; }
    public Type[] TypeDefinitions { get; }
    public string ResourceName { get; }
    internal CompilationMappingAttribute(SourceConstructFlags sourceConstructFlags, int variantNumber, int sequenceNumber, string resourceName, Type[] typeDefinitions);
    public CompilationMappingAttribute(SourceConstructFlags sourceConstructFlags);
    public CompilationMappingAttribute(SourceConstructFlags sourceConstructFlags, int sequenceNumber);
    public CompilationMappingAttribute(SourceConstructFlags sourceConstructFlags, int variantNumber, int sequenceNumber);
    public CompilationMappingAttribute(string resourceName, Type[] typeDefinitions);
    public SourceConstructFlags get_SourceConstructFlags();
    public int get_SequenceNumber();
    public int get_VariantNumber();
    public Type[] get_TypeDefinitions();
    public string get_ResourceName();
}
[AttributeUsageAttribute("32767")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilationRepresentationAttribute : Attribute {
    internal CompilationRepresentationFlags flags;
    public CompilationRepresentationFlags Flags { get; }
    public CompilationRepresentationAttribute(CompilationRepresentationFlags flags);
    public CompilationRepresentationFlags get_Flags();
}
[FlagsAttribute]
[CompilationMappingAttribute("3")]
public enum Microsoft.FSharp.Core.CompilationRepresentationFlags : Enum {
    public int value__;
    public static CompilationRepresentationFlags None;
    public static CompilationRepresentationFlags Static;
    public static CompilationRepresentationFlags Instance;
    public static CompilationRepresentationFlags ModuleSuffix;
    public static CompilationRepresentationFlags UseNullAsTrueValue;
    public static CompilationRepresentationFlags Event;
}
[AttributeUsageAttribute("32767")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilationSourceNameAttribute : Attribute {
    internal string sourceName;
    public string SourceName { get; }
    public CompilationSourceNameAttribute(string sourceName);
    public string get_SourceName();
}
[AttributeUsageAttribute("5596")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompiledNameAttribute : Attribute {
    internal string compiledName;
    public string CompiledName { get; }
    public CompiledNameAttribute(string compiledName);
    public string get_CompiledName();
}
[AttributeUsageAttribute("32767")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerMessageAttribute : Attribute {
    internal int messageNumber;
    internal string message;
    internal bool isError;
    internal bool isHidden;
    public string Message { get; }
    public int MessageNumber { get; }
    public bool IsError { get; public set; }
    public bool IsHidden { get; public set; }
    public CompilerMessageAttribute(string message, int messageNumber);
    public string get_Message();
    public int get_MessageNumber();
    public bool get_IsError();
    public void set_IsError(bool v);
    public bool get_IsHidden();
    public void set_IsHidden(bool v);
}
[AbstractClassAttribute]
[CompilationMappingAttribute("3")]
public abstract class Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1 : object {
    internal GeneratedSequenceBase`1<T> redirectTo;
    internal bool redirect;
    public bool CheckClose { get; }
    public T LastGenerated { get; }
    public abstract virtual IEnumerator`1<T> GetFreshEnumerator();
    public abstract virtual int GenerateNext(IEnumerable`1& result);
    public abstract virtual void Close();
    public abstract virtual bool get_CheckClose();
    public abstract virtual T get_LastGenerated();
    internal bool MoveNextImpl();
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override T System.Collections.Generic.IEnumerator<'T>.get_Current();
    private virtual override void System.IDisposable.Dispose();
    private virtual override object System.Collections.IEnumerator.get_Current();
    private virtual override bool System.Collections.IEnumerator.MoveNext();
    private virtual override void System.Collections.IEnumerator.Reset();
}
[CompilationMappingAttribute("3")]
public interface Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace {
    public string NamespaceName { get; }
    public abstract virtual string get_NamespaceName();
    public abstract virtual IProvidedNamespace[] GetNestedNamespaces();
    public abstract virtual Type[] GetTypes();
    public abstract virtual Type ResolveTypeName(string typeName);
}
[CompilationMappingAttribute("3")]
public interface Microsoft.FSharp.Core.CompilerServices.ITypeProvider {
    public abstract virtual IProvidedNamespace[] GetNamespaces();
    public abstract virtual ParameterInfo[] GetStaticParameters(Type typeWithoutArguments);
    public abstract virtual Type ApplyStaticArguments(Type typeWithoutArguments, String[] typePathWithArguments, Object[] staticArguments);
    public abstract virtual FSharpExpr GetInvokerExpression(MethodBase syntheticMethodBase, FSharpExpr[] parameters);
    [CLIEventAttribute]
public abstract virtual void add_Invalidate(EventHandler );
    [CLIEventAttribute]
public abstract virtual void remove_Invalidate(EventHandler );
    public abstract virtual Byte[] GetGeneratedAssemblyContents(Assembly assembly);
}
[CompilationMappingAttribute("3")]
public interface Microsoft.FSharp.Core.CompilerServices.ITypeProvider2 {
    public abstract virtual ParameterInfo[] GetStaticParametersForMethod(MethodBase methodWithoutArguments);
    public abstract virtual MethodBase ApplyStaticArgumentsForMethod(MethodBase methodWithoutArguments, string methodNameWithArguments, Object[] staticArguments);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerServices.MeasureInverse`1 : object {
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerServices.MeasureOne : object {
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerServices.MeasureProduct`2 : object {
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<b> Generate(FSharpFunc`2<Unit, a> openf, FSharpFunc`2<a, FSharpOption`1<b>> compute, FSharpFunc`2<a, Unit> closef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<TResult> EnumerateFromFunctions(FSharpFunc`2<Unit, T> create, FSharpFunc`2<T, bool> moveNext, FSharpFunc`2<T, TResult> current);
    internal static void iter@238(FSharpList`1<FSharpFunc`2<Unit, Unit>> comps);
    internal static bool takeOuter@273(ConcatEnumerator`2<T, TResult> x, Unit unitVar0);
    internal static bool takeInner@266(ConcatEnumerator`2<T, TResult> x, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<TResult> EnumerateUsing(T resource, FSharpFunc`2<T, TCollection> source);
    internal static IEnumerable`1<T> mkConcatSeq(IEnumerable`1<?> sources);
    internal static void start@314-1(FSharpRef`1<bool> started, Unit unitVar0);
    internal static IEnumerable`1<T> getCurr@311-1(FSharpRef`1<bool> started, FSharpRef`1<FSharpOption`1<IEnumerable`1<T>>> curr, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<T> EnumerateWhile(FSharpFunc`2<Unit, bool> guard, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<T> EnumerateThenFinally(IEnumerable`1<T> source, FSharpFunc`2<Unit, Unit> compensation);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEvent`2<TDelegate, TArgs> CreateEvent(FSharpFunc`2<TDelegate, Unit> addHandler, FSharpFunc`2<TDelegate, Unit> removeHandler, FSharpFunc`2<FSharpFunc`2<object, FSharpFunc`2<TArgs, Unit>>, TDelegate> createHandler);
}
[AttributeUsageAttribute("1")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerServices.TypeProviderAssemblyAttribute : Attribute {
    internal string assemblyName;
    public string AssemblyName { get; }
    public TypeProviderAssemblyAttribute(string assemblyName);
    public string get_AssemblyName();
}
[AttributeUsageAttribute("4")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerServices.TypeProviderAttribute : Attribute {
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig : object {
    internal FSharpFunc`2<string, bool> systemRuntimeContainsType;
    internal string resolutionFolder;
    internal string runtimeAssembly;
    internal String[] referencedAssemblies;
    internal string temporaryFolder;
    internal bool isInvalidationSupported;
    internal bool useResolutionFolderAtRuntime;
    internal Version systemRuntimeAssemblyVersion;
    public string ResolutionFolder { get; public set; }
    public string RuntimeAssembly { get; public set; }
    public String[] ReferencedAssemblies { get; public set; }
    public string TemporaryFolder { get; public set; }
    public bool IsInvalidationSupported { get; public set; }
    public bool IsHostedExecution { get; public set; }
    public Version SystemRuntimeAssemblyVersion { get; public set; }
    public TypeProviderConfig(FSharpFunc`2<string, bool> systemRuntimeContainsType);
    public string get_ResolutionFolder();
    public void set_ResolutionFolder(string v);
    public string get_RuntimeAssembly();
    public void set_RuntimeAssembly(string v);
    public String[] get_ReferencedAssemblies();
    public void set_ReferencedAssemblies(String[] v);
    public string get_TemporaryFolder();
    public void set_TemporaryFolder(string v);
    public bool get_IsInvalidationSupported();
    public void set_IsInvalidationSupported(bool v);
    public bool get_IsHostedExecution();
    public void set_IsHostedExecution(bool v);
    public Version get_SystemRuntimeAssemblyVersion();
    public void set_SystemRuntimeAssemblyVersion(Version v);
    public bool SystemRuntimeContainsType(string typeName);
}
[AttributeUsageAttribute("32767")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerServices.TypeProviderDefinitionLocationAttribute : Attribute {
    internal string filePath;
    internal int line;
    internal int column;
    public string FilePath { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public string get_FilePath();
    public void set_FilePath(string v);
    public int get_Line();
    public void set_Line(int v);
    public int get_Column();
    public void set_Column(int v);
}
[AttributeUsageAttribute("5132")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerServices.TypeProviderEditorHideMethodsAttribute : Attribute {
}
[CompilationMappingAttribute("3")]
public enum Microsoft.FSharp.Core.CompilerServices.TypeProviderTypeAttributes : Enum {
    public int value__;
    public static TypeProviderTypeAttributes SuppressRelocate;
    public static TypeProviderTypeAttributes IsErased;
}
[AttributeUsageAttribute("32767")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CompilerServices.TypeProviderXmlDocAttribute : Attribute {
    internal string commentText;
    public string CommentText { get; }
    public TypeProviderXmlDocAttribute(string commentText);
    public string get_CommentText();
}
[AttributeUsageAttribute("12")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CustomComparisonAttribute : Attribute {
}
[AttributeUsageAttribute("12")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CustomEqualityAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.CustomOperationAttribute : Attribute {
    internal string name;
    internal bool isBinary;
    internal bool allowInto;
    internal bool isJoin;
    internal bool isGroupJoin;
    internal bool maintainsVarSpace;
    internal bool maintainsVarSpaceWithBind;
    internal string joinOnWord;
    public string Name { get; }
    public bool AllowIntoPattern { get; public set; }
    public bool IsLikeZip { get; public set; }
    public bool IsLikeJoin { get; public set; }
    public bool IsLikeGroupJoin { get; public set; }
    public string JoinConditionWord { get; public set; }
    public bool MaintainsVariableSpace { get; public set; }
    public bool MaintainsVariableSpaceUsingBind { get; public set; }
    public CustomOperationAttribute(string name);
    public string get_Name();
    public bool get_AllowIntoPattern();
    public void set_AllowIntoPattern(bool v);
    public bool get_IsLikeZip();
    public void set_IsLikeZip(bool v);
    public bool get_IsLikeJoin();
    public void set_IsLikeJoin(bool v);
    public bool get_IsLikeGroupJoin();
    public void set_IsLikeGroupJoin(bool v);
    public string get_JoinConditionWord();
    public void set_JoinConditionWord(string v);
    public bool get_MaintainsVariableSpace();
    public void set_MaintainsVariableSpace(bool v);
    public bool get_MaintainsVariableSpaceUsingBind();
    public void set_MaintainsVariableSpaceUsingBind(bool v);
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.DefaultAugmentationAttribute : Attribute {
    internal bool value;
    public bool Value { get; }
    public DefaultAugmentationAttribute(bool value);
    public bool get_Value();
}
[AttributeUsageAttribute("256")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.DefaultValueAttribute : Attribute {
    internal bool check;
    public bool Check { get; }
    public DefaultValueAttribute(bool check);
    public bool get_Check();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Core.DetailedExceptions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidArgFmt(string arg, string format, Object[] paramArray);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidOpFmt(string format, Object[] paramArray);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidArgDifferentListLength(string arg1, string arg2, int diff);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidArg3ListsDifferent(string arg1, string arg2, string arg3, int len1, int len2, int len3);
    internal static ? invalidOpListNotEnoughElements(int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidOpExceededSeqLength(string fnName, int diff, int len);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidArgInputMustBeNonNegative(string arg, int count);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidArgInputMustBePositive(string arg, int count);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidArgOutOfRange(string arg, int index, string text, int bound);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidArgDifferentArrayLength(string arg1, int len1, string arg2, int len2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ? invalidArg3ArraysDifferent(string arg1, string arg2, string arg3, int len1, int len2, int len3);
}
[AttributeUsageAttribute("64")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.EntryPointAttribute : Attribute {
}
[AttributeUsageAttribute("16384")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.EqualityConditionalOnAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.ExperimentalAttribute : Attribute {
    internal string message;
    public string Message { get; }
    public ExperimentalAttribute(string message);
    public string get_Message();
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Core.ExperimentalAttributeMessages : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string RequiresPreview;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string NotSupportedYet;
    private static ExperimentalAttributeMessages();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.ExtraTopLevelOperators : object {
    [CompiledNameAttribute("DefaultAsyncBuilder")]
[CompilationMappingAttribute("9")]
public static FSharpAsyncBuilder DefaultAsyncBuilder { get; }
    [CompilationMappingAttribute("9")]
public static QueryBuilder query { get; }
    [CompilationSourceNameAttribute("set")]
public static FSharpSet`1<T> CreateSet(IEnumerable`1<T> elements);
    internal static KeyValuePair`2<TKey, T> current@125-10(int endIndex, KeyValuePair`2[] kvps, FSharpRef`1<int> index, Unit unitVar0);
    internal static DictImpl`3<TKey, TKey, T> dictValueType(IEnumerable`1<Tuple`2<TKey, T>> l);
    internal static DictImpl`3<StructBox`1<TKey>, TKey, T> dictRefType(IEnumerable`1<Tuple`2<TKey, T>> l);
    [CompilationSourceNameAttribute("dict")]
public static IDictionary`2<TKey, TValue> CreateDictionary(IEnumerable`1<Tuple`2<TKey, TValue>> keyValuePairs);
    [CompilationSourceNameAttribute("readOnlyDict")]
public static IReadOnlyDictionary`2<TKey, TValue> CreateReadOnlyDictionary(IEnumerable`1<Tuple`2<TKey, TValue>> keyValuePairs);
    internal static T[] getArray(IEnumerable`1<T> vals);
    [CompilerGeneratedAttribute]
internal static T[0...,0...] array2D$cont@192(?[] rowsArr, int m, Unit unitVar);
    [CompilationSourceNameAttribute("array2D")]
public static T[0...,0...] CreateArray2D(IEnumerable`1<?> rows);
    [CompilationSourceNameAttribute("sprintf")]
public static T PrintFormatToString(PrintfFormat`4<T, Unit, string, string> format);
    [CompilationSourceNameAttribute("failwithf")]
public static T PrintFormatToStringThenFail(PrintfFormat`4<T, Unit, string, TResult> format);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fprintf")]
public static T PrintFormatToTextWriter(TextWriter textWriter, PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fprintfn")]
public static T PrintFormatLineToTextWriter(TextWriter textWriter, PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationSourceNameAttribute("printf")]
public static T PrintFormat(PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationSourceNameAttribute("eprintf")]
public static T PrintFormatToError(PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationSourceNameAttribute("printfn")]
public static T PrintFormatLine(PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationSourceNameAttribute("eprintfn")]
public static T PrintFormatLineToError(PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    public static FSharpAsyncBuilder get_DefaultAsyncBuilder();
    [CompilationSourceNameAttribute("single")]
public static float ToSingle(T value);
    [CompilationSourceNameAttribute("single")]
public static float ToSingle$W(FSharpFunc`2<T, float> op_Explicit, T value);
    [CompilationSourceNameAttribute("double")]
public static double ToDouble(T value);
    [CompilationSourceNameAttribute("double")]
public static double ToDouble$W(FSharpFunc`2<T, double> op_Explicit, T value);
    [CompilationSourceNameAttribute("uint8")]
public static byte ToByte(T value);
    [CompilationSourceNameAttribute("uint8")]
public static byte ToByte$W(FSharpFunc`2<T, byte> op_Explicit, T value);
    [CompilationSourceNameAttribute("int8")]
public static sbyte ToSByte(T value);
    [CompilationSourceNameAttribute("int8")]
public static sbyte ToSByte$W(FSharpFunc`2<T, sbyte> op_Explicit, T value);
    [CompilationSourceNameAttribute("op_Splice")]
public static T SpliceExpression(FSharpExpr`1<T> expression);
    [CompilationSourceNameAttribute("op_SpliceUntyped")]
public static T SpliceUntypedExpression(FSharpExpr expression);
    [CompilationSourceNameAttribute("|Lazy|")]
public static T LazyPattern(Lazy`1<T> input);
    public static QueryBuilder get_query();
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpChoice`2")]
[CompilationMappingAttribute("1")]
public abstract class Microsoft.FSharp.Core.FSharpChoice`2 : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice1Of2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice2Of2 { get; }
    [CompilationMappingAttribute("8", "0")]
public static FSharpChoice`2<T1, T2> NewChoice1Of2(T1 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice1Of2();
    [CompilationMappingAttribute("8", "1")]
public static FSharpChoice`2<T1, T2> NewChoice2Of2(T2 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice2Of2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpChoice`2<T1, T2> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpChoice`2<T1, T2> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpChoice`3")]
[CompilationMappingAttribute("1")]
public abstract class Microsoft.FSharp.Core.FSharpChoice`3 : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice1Of3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice2Of3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice3Of3 { get; }
    [CompilationMappingAttribute("8", "0")]
public static FSharpChoice`3<T1, T2, T3> NewChoice1Of3(T1 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice1Of3();
    [CompilationMappingAttribute("8", "1")]
public static FSharpChoice`3<T1, T2, T3> NewChoice2Of3(T2 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice2Of3();
    [CompilationMappingAttribute("8", "2")]
public static FSharpChoice`3<T1, T2, T3> NewChoice3Of3(T3 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice3Of3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpChoice`3<T1, T2, T3> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpChoice`3<T1, T2, T3> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpChoice`4")]
[CompilationMappingAttribute("1")]
public abstract class Microsoft.FSharp.Core.FSharpChoice`4 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice1Of4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice2Of4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice3Of4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice4Of4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpChoice`4(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpChoice`4<T1, T2, T3, T4> NewChoice1Of4(T1 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice1Of4();
    [CompilationMappingAttribute("8", "1")]
public static FSharpChoice`4<T1, T2, T3, T4> NewChoice2Of4(T2 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice2Of4();
    [CompilationMappingAttribute("8", "2")]
public static FSharpChoice`4<T1, T2, T3, T4> NewChoice3Of4(T3 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice3Of4();
    [CompilationMappingAttribute("8", "3")]
public static FSharpChoice`4<T1, T2, T3, T4> NewChoice4Of4(T4 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice4Of4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpChoice`4<T1, T2, T3, T4> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpChoice`4<T1, T2, T3, T4> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpChoice`5")]
[CompilationMappingAttribute("1")]
public abstract class Microsoft.FSharp.Core.FSharpChoice`5 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice1Of5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice2Of5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice3Of5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice4Of5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice5Of5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpChoice`5(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpChoice`5<T1, T2, T3, T4, T5> NewChoice1Of5(T1 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice1Of5();
    [CompilationMappingAttribute("8", "1")]
public static FSharpChoice`5<T1, T2, T3, T4, T5> NewChoice2Of5(T2 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice2Of5();
    [CompilationMappingAttribute("8", "2")]
public static FSharpChoice`5<T1, T2, T3, T4, T5> NewChoice3Of5(T3 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice3Of5();
    [CompilationMappingAttribute("8", "3")]
public static FSharpChoice`5<T1, T2, T3, T4, T5> NewChoice4Of5(T4 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice4Of5();
    [CompilationMappingAttribute("8", "4")]
public static FSharpChoice`5<T1, T2, T3, T4, T5> NewChoice5Of5(T5 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice5Of5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpChoice`5<T1, T2, T3, T4, T5> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpChoice`5<T1, T2, T3, T4, T5> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpChoice`6")]
[CompilationMappingAttribute("1")]
public abstract class Microsoft.FSharp.Core.FSharpChoice`6 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice1Of6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice2Of6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice3Of6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice4Of6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice5Of6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice6Of6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpChoice`6(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpChoice`6<T1, T2, T3, T4, T5, T6> NewChoice1Of6(T1 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice1Of6();
    [CompilationMappingAttribute("8", "1")]
public static FSharpChoice`6<T1, T2, T3, T4, T5, T6> NewChoice2Of6(T2 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice2Of6();
    [CompilationMappingAttribute("8", "2")]
public static FSharpChoice`6<T1, T2, T3, T4, T5, T6> NewChoice3Of6(T3 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice3Of6();
    [CompilationMappingAttribute("8", "3")]
public static FSharpChoice`6<T1, T2, T3, T4, T5, T6> NewChoice4Of6(T4 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice4Of6();
    [CompilationMappingAttribute("8", "4")]
public static FSharpChoice`6<T1, T2, T3, T4, T5, T6> NewChoice5Of6(T5 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice5Of6();
    [CompilationMappingAttribute("8", "5")]
public static FSharpChoice`6<T1, T2, T3, T4, T5, T6> NewChoice6Of6(T6 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice6Of6();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpChoice`6<T1, T2, T3, T4, T5, T6> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpChoice`6<T1, T2, T3, T4, T5, T6> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpChoice`7")]
[CompilationMappingAttribute("1")]
public abstract class Microsoft.FSharp.Core.FSharpChoice`7 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice1Of7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice2Of7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice3Of7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice4Of7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice5Of7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice6Of7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChoice7Of7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpChoice`7(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7> NewChoice1Of7(T1 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice1Of7();
    [CompilationMappingAttribute("8", "1")]
public static FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7> NewChoice2Of7(T2 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice2Of7();
    [CompilationMappingAttribute("8", "2")]
public static FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7> NewChoice3Of7(T3 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice3Of7();
    [CompilationMappingAttribute("8", "3")]
public static FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7> NewChoice4Of7(T4 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice4Of7();
    [CompilationMappingAttribute("8", "4")]
public static FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7> NewChoice5Of7(T5 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice5Of7();
    [CompilationMappingAttribute("8", "5")]
public static FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7> NewChoice6Of7(T6 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice6Of7();
    [CompilationMappingAttribute("8", "6")]
public static FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7> NewChoice7Of7(T7 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChoice7Of7();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AbstractClassAttribute]
[CompilationMappingAttribute("3")]
public abstract class Microsoft.FSharp.Core.FSharpFunc`2 : object {
    public abstract virtual TResult Invoke(T func);
    internal static FSharpFunc`2<T, TResult> op_Implicit(Func`2<T, TResult> converter);
    internal static Func`2<T, TResult> op_Implicit(FSharpFunc`2<T, TResult> func);
    public static FSharpFunc`2<T, TResult> op_Implicit(Converter`2<T, TResult> converter);
    public static Converter`2<T, TResult> op_Implicit(FSharpFunc`2<T, TResult> func);
    public static FSharpFunc`2<T, TResult> FromConverter(Converter`2<T, TResult> converter);
    public static Converter`2<T, TResult> ToConverter(FSharpFunc`2<T, TResult> func);
    public static V InvokeFast(FSharpFunc`2<T, FSharpFunc`2<TResult, V>> func, T arg1, TResult arg2);
    public static W InvokeFast(FSharpFunc`2<T, FSharpFunc`2<TResult, FSharpFunc`2<V, W>>> func, T arg1, TResult arg2, V arg3);
    public static X InvokeFast(FSharpFunc`2<T, FSharpFunc`2<TResult, FSharpFunc`2<V, FSharpFunc`2<W, X>>>> func, T arg1, TResult arg2, V arg3, W arg4);
    public static Y InvokeFast(FSharpFunc`2<T, FSharpFunc`2<TResult, FSharpFunc`2<V, FSharpFunc`2<W, FSharpFunc`2<X, Y>>>>> func, T arg1, TResult arg2, V arg3, W arg4, X arg5);
}
[AttributeUsageAttribute("1")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute : Attribute {
    internal int release;
    internal int minor;
    internal int major;
    public int Major { get; }
    public int Minor { get; }
    public int Release { get; }
    public FSharpInterfaceDataVersionAttribute(int major, int minor, int release);
    public int get_Major();
    public int get_Minor();
    public int get_Release();
}
[DefaultAugmentationAttribute("False")]
[CompilationRepresentationAttribute("8")]
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpOption`1")]
[DebuggerDisplayAttribute("{get_DebugDisplay(this),nq}")]
[CompilationMappingAttribute("1")]
public class Microsoft.FSharp.Core.FSharpOption`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T value;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpOption`1<T> None { get; }
    [CompilationMappingAttribute("4", "1", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T Value { get; }
    [DebuggerBrowsableAttribute("0")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool IsNone { get; }
    [DebuggerBrowsableAttribute("0")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool IsSome { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string DebugDisplay { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1(T value);
    [CompilationMappingAttribute("8", "0")]
public static FSharpOption`1<T> get_None();
    [CompilationMappingAttribute("8", "1")]
public static FSharpOption`1<T> Some(T value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int GetTag(FSharpOption`1<T> );
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpOption`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static bool get_IsNone(FSharpOption`1<T> );
    public static bool get_IsSome(FSharpOption`1<T> );
    public static FSharpOption`1<T> op_Implicit(T value);
    internal static string get_DebugDisplay(FSharpOption`1<T> );
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpOption`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpRef`1")]
[DebuggerDisplayAttribute("{contents}")]
[CompilationMappingAttribute("2")]
public class Microsoft.FSharp.Core.FSharpRef`1 : object {
    [DebuggerBrowsableAttribute("0")]
public T contents@;
    [DebuggerBrowsableAttribute("0")]
[CompilationMappingAttribute("4", "0")]
public T contents { get; public set; }
    public T Value { get; public set; }
    public FSharpRef`1(T contents);
    public T get_contents();
    public void set_contents(T value);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpRef`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public T get_Value();
    public void set_Value(T v);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpRef`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpResult`2")]
[StructAttribute]
[CompilationMappingAttribute("1")]
public class Microsoft.FSharp.Core.FSharpResult`2 : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T resultValue;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TError errorValue;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOk { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsError { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T ResultValue { get; }
    [CompilationMappingAttribute("4", "1", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TError ErrorValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpResult`2(T resultValue, int _tag, bool );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpResult`2(TError errorValue, int _tag, byte );
    [CompilationMappingAttribute("8", "0")]
public static FSharpResult`2<T, TError> NewOk(T resultValue);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOk();
    [CompilationMappingAttribute("8", "1")]
public static FSharpResult`2<T, TError> NewError(TError errorValue);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T get_ResultValue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TError get_ErrorValue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpResult`2<T, TError> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpResult`2<T, TError> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AbstractClassAttribute]
[CompilationMappingAttribute("3")]
public abstract class Microsoft.FSharp.Core.FSharpTypeFunc : object {
    public abstract virtual object Specialize();
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[CompiledNameAttribute("FSharpValueOption`1")]
[StructAttribute]
[DebuggerDisplayAttribute("{DebugDisplay,nq}")]
[CompilationMappingAttribute("1")]
public class Microsoft.FSharp.Core.FSharpValueOption`1 : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T item;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpValueOption`1<T> ValueNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsValueNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsValueSome { get; }
    [CompilationMappingAttribute("4", "1", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T Item { get; }
    public T Value { get; }
    [DebuggerBrowsableAttribute("0")]
public static FSharpValueOption`1<T> None { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsSome { get; }
    internal string DebugDisplay { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpValueOption`1(int _tag, bool );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpValueOption`1(T item, int _tag, byte );
    [CompilationMappingAttribute("8", "0")]
public static FSharpValueOption`1<T> get_ValueNone();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsValueNone();
    [CompilationMappingAttribute("8", "1")]
public static FSharpValueOption`1<T> NewValueSome(T item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsValueSome();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpValueOption`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public T get_Value();
    public static FSharpValueOption`1<T> get_None();
    public static FSharpValueOption`1<T> Some(T value);
    public bool get_IsNone();
    public bool get_IsSome();
    public static FSharpValueOption`1<T> op_Implicit(T value);
    internal string get_DebugDisplay();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpValueOption`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AbstractClassAttribute]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public static class Microsoft.FSharp.Core.FuncConvert : object {
    public static FSharpFunc`2<T, Unit> ToFSharpFunc(Action`1<T> action);
    public static FSharpFunc`2<T, TResult> ToFSharpFunc(Converter`2<T, TResult> converter);
    internal static FSharpFunc`2<a, b> ToFSharpFunc(Func`2<a, b> converter);
    public static FSharpFunc`2<Unit, T> FromFunc(Func`1<T> func);
    public static FSharpFunc`2<T, TResult> FromFunc(Func`2<T, TResult> func);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> FromFunc(Func`3<T1, T2, TResult> func);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> FromFunc(Func`4<T1, T2, T3, TResult> func);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, FSharpFunc`2<T4, TResult>>>> FromFunc(Func`5<T1, T2, T3, T4, TResult> func);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, FSharpFunc`2<T4, FSharpFunc`2<T5, TResult>>>>> FromFunc(Func`6<T1, T2, T3, T4, T5, TResult> func);
    public static FSharpFunc`2<Unit, Unit> FromAction(Action action);
    public static FSharpFunc`2<T, Unit> FromAction(Action`1<T> action);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, Unit>> FromAction(Action`2<T1, T2> action);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, Unit>>> FromAction(Action`3<T1, T2, T3> action);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, FSharpFunc`2<T4, Unit>>>> FromAction(Action`4<T1, T2, T3, T4> action);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, FSharpFunc`2<T4, FSharpFunc`2<T5, Unit>>>>> FromAction(Action`5<T1, T2, T3, T4, T5> action);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> FuncFromTupled(FSharpFunc`2<Tuple`2<T1, T2>, TResult> func);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> FuncFromTupled(FSharpFunc`2<Tuple`3<T1, T2, T3>, TResult> func);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, FSharpFunc`2<T4, TResult>>>> FuncFromTupled(FSharpFunc`2<Tuple`4<T1, T2, T3, T4>, TResult> func);
    public static FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, FSharpFunc`2<T4, FSharpFunc`2<T5, TResult>>>>> FuncFromTupled(FSharpFunc`2<Tuple`5<T1, T2, T3, T4, T5>, TResult> func);
}
[AttributeUsageAttribute("64")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.GeneralizableValueAttribute : Attribute {
}
[AttributeUsageAttribute("1024")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.InterfaceAttribute : Attribute {
}
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.LanguagePrimitives : object {
    [CompilationMappingAttribute("9")]
public static IComparer GenericComparer { get; }
    [CompilationMappingAttribute("9")]
public static IEqualityComparer GenericEqualityComparer { get; }
    [CompilationMappingAttribute("9")]
public static IEqualityComparer GenericEqualityERComparer { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<bool> BoolIEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<char> CharIEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<string> StringIEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<sbyte> SByteIEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<short> Int16IEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<int> Int32IEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<long> Int64IEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<IntPtr> IntPtrIEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<byte> ByteIEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<ushort> UInt16IEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<UInt32> UInt32IEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<ulong> UInt64IEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<UIntPtr> UIntPtrIEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<double> FloatIEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<float> Float32IEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<decimal> DecimalIEquality { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<char> CharComparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<string> StringComparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<sbyte> SByteComparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<short> Int16Comparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<int> Int32Comparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<long> Int64Comparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<IntPtr> IntPtrComparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<byte> ByteComparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ushort> UInt16Comparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<UInt32> UInt32Comparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ulong> UInt64Comparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<UIntPtr> UIntPtrComparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<double> FloatComparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<float> Float32Comparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<decimal> DecimalComparer { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<bool> BoolComparer { get; }
    internal static string anyToStringShowingNull(T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool GenericEquality(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool GenericEqualityER(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool GenericEqualityWithComparer(IEqualityComparer comp, T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int GenericComparison(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int GenericComparisonWithComparer(IComparer comp, T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool GenericLessThan(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool GenericGreaterThan(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool GenericLessOrEqual(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool GenericGreaterOrEqual(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T GenericMinimum(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T GenericMaximum(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool PhysicalEquality(T e1, T e2);
    public static int PhysicalHash(T obj);
    public static IComparer get_GenericComparer();
    public static IEqualityComparer get_GenericEqualityComparer();
    public static IEqualityComparer get_GenericEqualityERComparer();
    public static int GenericHash(T obj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int GenericLimitedHash(int limit, T obj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int GenericHashWithComparer(IEqualityComparer comparer, T obj);
    internal static IEqualityComparer`1<bool> get_BoolIEquality();
    internal static IEqualityComparer`1<char> get_CharIEquality();
    internal static IEqualityComparer`1<string> get_StringIEquality();
    internal static IEqualityComparer`1<sbyte> get_SByteIEquality();
    internal static IEqualityComparer`1<short> get_Int16IEquality();
    internal static IEqualityComparer`1<int> get_Int32IEquality();
    internal static IEqualityComparer`1<long> get_Int64IEquality();
    internal static IEqualityComparer`1<IntPtr> get_IntPtrIEquality();
    internal static IEqualityComparer`1<byte> get_ByteIEquality();
    internal static IEqualityComparer`1<ushort> get_UInt16IEquality();
    internal static IEqualityComparer`1<UInt32> get_UInt32IEquality();
    internal static IEqualityComparer`1<ulong> get_UInt64IEquality();
    internal static IEqualityComparer`1<UIntPtr> get_UIntPtrIEquality();
    internal static IEqualityComparer`1<double> get_FloatIEquality();
    internal static IEqualityComparer`1<float> get_Float32IEquality();
    internal static IEqualityComparer`1<decimal> get_DecimalIEquality();
    [CompilerGeneratedAttribute]
internal static IEqualityComparer`1<T> .cctor$cont@2055-1(Type matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEqualityComparer`1<T> .cctor$cont@2055(Type matchValue, Unit unitVar);
    [CompilerMessageAttribute("This function is a compiler intrinsic should not be used directly", "1204")]
public static IEqualityComparer`1<T> FastGenericEqualityComparerFromTable();
    public static IEqualityComparer`1<T> FastGenericEqualityComparer();
    public static IEqualityComparer`1<T> FastLimitedGenericEqualityComparer(int limit);
    internal static IComparer`1<char> get_CharComparer();
    internal static IComparer`1<string> get_StringComparer();
    internal static IComparer`1<sbyte> get_SByteComparer();
    internal static IComparer`1<short> get_Int16Comparer();
    internal static IComparer`1<int> get_Int32Comparer();
    internal static IComparer`1<long> get_Int64Comparer();
    internal static IComparer`1<IntPtr> get_IntPtrComparer();
    internal static IComparer`1<byte> get_ByteComparer();
    internal static IComparer`1<ushort> get_UInt16Comparer();
    internal static IComparer`1<UInt32> get_UInt32Comparer();
    internal static IComparer`1<ulong> get_UInt64Comparer();
    internal static IComparer`1<UIntPtr> get_UIntPtrComparer();
    internal static IComparer`1<double> get_FloatComparer();
    internal static IComparer`1<float> get_Float32Comparer();
    internal static IComparer`1<decimal> get_DecimalComparer();
    internal static IComparer`1<bool> get_BoolComparer();
    [CompilerGeneratedAttribute]
internal static IComparer`1<T> .cctor$cont@2171-4(Type matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IComparer`1<T> .cctor$cont@2171-3(Type matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IComparer`1<T> .cctor$cont@2151-2(Type matchValue, Unit unitVar);
    [CompilerMessageAttribute("This function is a compiler intrinsic should not be used directly", "1204")]
public static IComparer`1<T> FastGenericComparerFromTable();
    public static IComparer`1<T> FastGenericComparer();
    internal static IComparer`1<T> FastGenericComparerCanBeNull();
    public static TEnum EnumOfValue(T value);
    public static T EnumToValue(TEnum enum);
    public static double FloatWithMeasure(double input);
    public static float Float32WithMeasure(float input);
    public static decimal DecimalWithMeasure(decimal input);
    public static int Int32WithMeasure(int input);
    public static short Int16WithMeasure(short input);
    public static sbyte SByteWithMeasure(sbyte input);
    public static long Int64WithMeasure(long input);
    internal static bool isOXB(char c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool is0OXB(string s, int p, int l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static char get0OXB(string s, Int32& p, int l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int getSign32(string s, Int32& p, int l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static long getSign64(string s, Int32& p, int l);
    public static UInt32 ParseUInt32(string s);
    public static int ParseInt32(string s);
    public static long ParseInt64(string s);
    public static ulong ParseUInt64(string s);
    [CompilerGeneratedAttribute]
internal static T .cctor$cont@2399-5(Type aty, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static T .cctor$cont@2423-6(Type aty, Unit unitVar);
    [CompilerMessageAttribute("This function is for use by compiled F# code and should not be used directly", "1204")]
public static T GenericZeroDynamic();
    [CompilerMessageAttribute("This function is for use by compiled F# code and should not be used directly", "1204")]
public static T GenericOneDynamic();
    public static T GenericZero();
    public static T GenericZero$W(FSharpFunc`2<Unit, T> get_Zero);
    public static T GenericOne();
    public static T GenericOne$W(FSharpFunc`2<Unit, T> get_One);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo Type.GetSingleStaticMethodByTypes(Type this, string name, Type[] parameterTypes);
    internal static FSharpFunc`2<T, TResult> UnaryDynamicImpl(string nm);
    internal static FSharpFunc`2<T, FSharpFunc`2<TResult, V>> BinaryDynamicImpl(string nm);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult AdditionDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult SubtractionDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult MultiplyDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult DivisionDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult ModulusDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
public static TResult UnaryNegationDynamic(T value);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult CheckedAdditionDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult CheckedSubtractionDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult CheckedMultiplyDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
public static TResult CheckedUnaryNegationDynamic(T value);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult LeftShiftDynamic(T1 value, T2 shift);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult RightShiftDynamic(T1 value, T2 shift);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult BitwiseAndDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult BitwiseOrDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult ExclusiveOrDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
public static TResult LogicalNotDynamic(T value);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
public static TResult ExplicitDynamic(T value);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult LessThanDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult GreaterThanDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult LessThanOrEqualDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult GreaterThanOrEqualDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult EqualityDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult InequalityDynamic(T1 x, T2 y);
    [CompilerMessageAttribute("This function is for use by dynamic invocations of F# code and should not be used directly", "1204")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T DivideByIntDynamic(T x, int y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T DivideByInt(T x, int y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T DivideByInt$W(FSharpFunc`2<T, FSharpFunc`2<int, T>> divideByInt, T x, int y);
}
[AttributeUsageAttribute("256")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.LiteralAttribute : Attribute {
}
[CompilationMappingAttribute("5")]
public class Microsoft.FSharp.Core.MatchFailureException : Exception {
    internal string Data0@;
    internal int Data1@;
    internal int Data2@;
    [CompilationMappingAttribute("4", "0")]
public string Data0 { get; }
    [CompilationMappingAttribute("4", "1")]
public int Data1 { get; }
    [CompilationMappingAttribute("4", "2")]
public int Data2 { get; }
    public string Message { get; }
    public MatchFailureException(string data0, int data1, int data2);
    protected MatchFailureException(SerializationInfo info, StreamingContext context);
    public string get_Data0();
    public int get_Data1();
    public int get_Data2();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
internal bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute : Attribute {
}
[AttributeUsageAttribute("16388")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.MeasureAttribute : Attribute {
}
[AttributeUsageAttribute("5148")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.NoComparisonAttribute : Attribute {
}
[AttributeUsageAttribute("192")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.NoDynamicInvocationAttribute : Attribute {
    internal bool isLegacy;
    internal bool IsLegacy { get; }
    internal NoDynamicInvocationAttribute(bool isLegacy);
    internal bool get_IsLegacy();
}
[AttributeUsageAttribute("5148")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.NoEqualityAttribute : Attribute {
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.NumericLiterals : object {
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.Operators : object {
    [CompiledNameAttribute("Infinity")]
public static double Infinity { get; }
    [CompiledNameAttribute("NaN")]
public static double NaN { get; }
    [CompiledNameAttribute("InfinitySingle")]
public static float InfinitySingle { get; }
    [CompiledNameAttribute("NaNSingle")]
public static float NaNSingle { get; }
    [CompilationSourceNameAttribute("seq")]
public static IEnumerable`1<T> CreateSequence(IEnumerable`1<T> sequence);
    [CompilationSourceNameAttribute("unbox")]
public static T Unbox(object value);
    [CompilationSourceNameAttribute("box")]
public static object Box(T value);
    [CompilationSourceNameAttribute("tryUnbox")]
public static FSharpOption`1<T> TryUnbox(object value);
    [CompilationSourceNameAttribute("isNull")]
public static bool IsNull(T value);
    [CompilationSourceNameAttribute("isNotNull")]
internal static bool IsNotNull(T value);
    [CompilationSourceNameAttribute("raise")]
public static T Raise(Exception exn);
    public static Exception Failure(string message);
    [CompilationSourceNameAttribute("|Failure|_|")]
public static FSharpOption`1<string> FailurePattern(Exception error);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_LessThan(T x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_GreaterThan(T x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_GreaterThanOrEqual(T x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_LessThanOrEqual(T x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_Equality(T x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_Inequality(T x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("compare")]
public static int Compare(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("max")]
public static T Max(T e1, T e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("min")]
public static T Min(T e1, T e2);
    [CompilationSourceNameAttribute("failwith")]
public static T FailWith(string message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("invalidArg")]
public static T InvalidArg(string argumentName, string message);
    [CompilationSourceNameAttribute("nullArg")]
public static T NullArg(string argumentName);
    [CompilationSourceNameAttribute("invalidOp")]
public static T InvalidOp(string message);
    [ObsoleteAttribute("This function has been renamed to 'reraise'. Please adjust your code to reflect this", "True")]
[NoDynamicInvocationAttribute]
[CompilationSourceNameAttribute("rethrow")]
public static T Rethrow();
    [NoDynamicInvocationAttribute]
[CompilationSourceNameAttribute("reraise")]
public static T Reraise();
    [CompilationSourceNameAttribute("fst")]
public static T1 Fst(Tuple`2<T1, T2> tuple);
    [CompilationSourceNameAttribute("snd")]
public static T2 Snd(Tuple`2<T1, T2> tuple);
    [CompilationSourceNameAttribute("ignore")]
public static void Ignore(T value);
    [CompilationSourceNameAttribute("ref")]
public static FSharpRef`1<T> Ref(T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void op_ColonEquals(FSharpRef`1<T> cell, T value);
    public static T op_Dereference(FSharpRef`1<T> cell);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult op_PipeRight(T1 arg, FSharpFunc`2<T1, TResult> func);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult op_PipeRight2(T1 arg1, T2 arg2, FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> func);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult op_PipeRight3(T1 arg1, T2 arg2, T3 arg3, FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> func);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult op_PipeLeft(FSharpFunc`2<T, TResult> func, T arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult op_PipeLeft2(FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> func, T1 arg1, T2 arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TResult op_PipeLeft3(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> func, T1 arg1, T2 arg2, T3 arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<T1, T3> op_ComposeRight(FSharpFunc`2<T1, T2> func1, FSharpFunc`2<T2, T3> func2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<T1, T3> op_ComposeLeft(FSharpFunc`2<T2, T3> func2, FSharpFunc`2<T1, T2> func1);
    [CompilerMessageAttribute("This construct is for ML compatibility. Consider using the '+' operator instead. This may require a type annotation to indicate it acts on strings. This message can be disabled using '--nowarn:62' or '#nowarn "62"'.", "62")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_Concatenate(string s1, string s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("defaultArg")]
public static T DefaultArg(FSharpOption`1<T> arg, T defaultValue);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("defaultValueArg")]
public static T DefaultValueArg(FSharpValueOption`1<T> arg, T defaultValue);
    [NoDynamicInvocationAttribute("True")]
public static T op_UnaryNegation(T n);
    [NoDynamicInvocationAttribute("True")]
public static T op_UnaryNegation$W(FSharpFunc`2<T, T> op_UnaryNegation, T n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Addition(T1 x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Addition$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Addition, T1 x, T2 y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Subtraction(T1 x, T2 y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Subtraction$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Subtraction, T1 x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Multiply(T1 x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Multiply$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Multiply, T1 x, T2 y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Division(T1 x, T2 y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Division$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Division, T1 x, T2 y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Modulus(T1 x, T2 y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T3 op_Modulus$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Modulus, T1 x, T2 y);
    [NoDynamicInvocationAttribute("True")]
public static T op_UnaryPlus(T value);
    [NoDynamicInvocationAttribute("True")]
public static T op_UnaryPlus$W(FSharpFunc`2<T, T> op_UnaryPlus, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_LeftShift(T value, int shift);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_LeftShift$W(FSharpFunc`2<T, FSharpFunc`2<int, T>> op_LeftShift, T value, int shift);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_RightShift(T value, int shift);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_RightShift$W(FSharpFunc`2<T, FSharpFunc`2<int, T>> op_RightShift, T value, int shift);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_BitwiseAnd(T x, T y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_BitwiseAnd$W(FSharpFunc`2<T, FSharpFunc`2<T, T>> op_BitwiseAnd, T x, T y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_BitwiseOr(T x, T y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_BitwiseOr$W(FSharpFunc`2<T, FSharpFunc`2<T, T>> op_BitwiseOr, T x, T y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_ExclusiveOr(T x, T y);
    [NoDynamicInvocationAttribute("True")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_ExclusiveOr$W(FSharpFunc`2<T, FSharpFunc`2<T, T>> op_ExclusiveOr, T x, T y);
    [NoDynamicInvocationAttribute("True")]
public static T op_LogicalNot(T value);
    [NoDynamicInvocationAttribute("True")]
public static T op_LogicalNot$W(FSharpFunc`2<T, T> op_LogicalNot, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<T> op_Append(FSharpList`1<T> list1, FSharpList`1<T> list2);
    [CompilationSourceNameAttribute("incr")]
public static void Increment(FSharpRef`1<int> cell);
    [CompilationSourceNameAttribute("decr")]
public static void Decrement(FSharpRef`1<int> cell);
    [CompilationSourceNameAttribute("exit")]
public static T Exit(int exitcode);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("byte")]
public static byte ToByte(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("byte")]
public static byte ToByte$W(FSharpFunc`2<T, byte> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("sbyte")]
public static sbyte ToSByte(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("sbyte")]
public static sbyte ToSByte$W(FSharpFunc`2<T, sbyte> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("uint16")]
public static ushort ToUInt16(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("uint16")]
public static ushort ToUInt16$W(FSharpFunc`2<T, ushort> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("int16")]
public static short ToInt16(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("int16")]
public static short ToInt16$W(FSharpFunc`2<T, short> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("uint32")]
public static UInt32 ToUInt32(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("uint32")]
public static UInt32 ToUInt32$W(FSharpFunc`2<T, UInt32> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("int32")]
public static int ToInt32(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("int32")]
public static int ToInt32$W(FSharpFunc`2<T, int> op_Explicit, T value);
    [CompilationSourceNameAttribute("int")]
public static int ToInt(T value);
    [CompilationSourceNameAttribute("int")]
public static int ToInt$W(FSharpFunc`2<T, int> op_Explicit, T value);
    [CompilationSourceNameAttribute("uint")]
public static UInt32 ToUInt(T value);
    [CompilationSourceNameAttribute("uint")]
public static UInt32 ToUInt$W(FSharpFunc`2<T, UInt32> op_Explicit, T value);
    [CompilationSourceNameAttribute("enum")]
public static TResult ToEnum(int value);
    [CompilationSourceNameAttribute("|KeyValue|")]
public static Tuple`2<TKey, TValue> KeyValuePattern(KeyValuePair`2<TKey, TValue> keyValuePair);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static double get_Infinity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static double get_NaN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static float get_InfinitySingle();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static float get_NaNSingle();
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("uint64")]
public static ulong ToUInt64(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("uint64")]
public static ulong ToUInt64$W(FSharpFunc`2<T, ulong> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("int64")]
public static long ToInt64(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("int64")]
public static long ToInt64$W(FSharpFunc`2<T, long> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("float32")]
public static float ToSingle(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("float32")]
public static float ToSingle$W(FSharpFunc`2<T, float> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("float")]
public static double ToDouble(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("float")]
public static double ToDouble$W(FSharpFunc`2<T, double> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("decimal")]
public static decimal ToDecimal(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("decimal")]
public static decimal ToDecimal$W(FSharpFunc`2<T, decimal> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("unativeint")]
public static UIntPtr ToUIntPtr(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("unativeint")]
public static UIntPtr ToUIntPtr$W(FSharpFunc`2<T, UIntPtr> op_Explicit, T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("nativeint")]
public static IntPtr ToIntPtr(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("nativeint")]
public static IntPtr ToIntPtr$W(FSharpFunc`2<T, IntPtr> op_Explicit, T value);
    [CompilationSourceNameAttribute("string")]
public static string ToString(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("char")]
public static char ToChar(T value);
    [NoDynamicInvocationAttribute("True")]
[CompilationSourceNameAttribute("char")]
public static char ToChar$W(FSharpFunc`2<T, char> op_Explicit, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("lock")]
public static T Lock(TLock lockObject, FSharpFunc`2<Unit, T> action);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("using")]
public static TResult Using(T resource, FSharpFunc`2<T, TResult> action);
    [RequiresExplicitTypeArgumentsAttribute]
[CompilationSourceNameAttribute("typeof")]
public static Type TypeOf();
    [CompilerMessageAttribute("This construct is not supported by your version of the F# compiler", "3501")]
[CompilationSourceNameAttribute("nameof")]
public static string NameOf(T _arg1);
    [CompilationSourceNameAttribute("methodhandleof")]
internal static RuntimeMethodHandle MethodHandleOf(FSharpFunc`2<T, TResult> _call);
    [RequiresExplicitTypeArgumentsAttribute]
[CompilationSourceNameAttribute("typedefof")]
public static Type TypeDefOf();
    [RequiresExplicitTypeArgumentsAttribute]
[CompilationSourceNameAttribute("sizeof")]
public static int SizeOf();
    [CompilationSourceNameAttribute("hash")]
public static int Hash(T obj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int limitedHash(int limit, T obj);
    [CompilationSourceNameAttribute("id")]
public static T Identity(T x);
    [CompilationSourceNameAttribute("not")]
public static bool Not(bool value);
    [CompilationSourceNameAttribute("stdin")]
public static TextReader ConsoleIn();
    [CompilationSourceNameAttribute("stdout")]
public static TextWriter ConsoleOut();
    [CompilationSourceNameAttribute("stderr")]
public static TextWriter ConsoleError();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<T> op_Range(T start, T finish);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<T> op_Range$W(FSharpFunc`2<Unit, T> get_One, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Addition, T start, T finish);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<T> op_RangeStep(T start, TStep step, T finish);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<T> op_RangeStep$W(FSharpFunc`2<Unit, TStep> get_Zero, FSharpFunc`2<T, FSharpFunc`2<TStep, T>> op_Addition, T start, TStep step, T finish);
    [CompilationSourceNameAttribute("abs")]
public static T Abs(T value);
    [CompilationSourceNameAttribute("abs")]
public static T Abs$W(FSharpFunc`2<T, T> abs, T value);
    [CompilationSourceNameAttribute("acos")]
public static T Acos(T value);
    [CompilationSourceNameAttribute("acos")]
public static T Acos$W(FSharpFunc`2<T, T> acos, T value);
    [CompilationSourceNameAttribute("asin")]
public static T Asin(T value);
    [CompilationSourceNameAttribute("asin")]
public static T Asin$W(FSharpFunc`2<T, T> asin, T value);
    [CompilationSourceNameAttribute("atan")]
public static T Atan(T value);
    [CompilationSourceNameAttribute("atan")]
public static T Atan$W(FSharpFunc`2<T, T> atan, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("atan2")]
public static T2 Atan2(T1 y, T1 x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("atan2")]
public static T2 Atan2$W(FSharpFunc`2<T1, FSharpFunc`2<T1, T2>> atan2, T1 y, T1 x);
    [CompilationSourceNameAttribute("ceil")]
public static T Ceiling(T value);
    [CompilationSourceNameAttribute("ceil")]
public static T Ceiling$W(FSharpFunc`2<T, T> ceiling, T value);
    [CompilationSourceNameAttribute("exp")]
public static T Exp(T value);
    [CompilationSourceNameAttribute("exp")]
public static T Exp$W(FSharpFunc`2<T, T> exp, T value);
    [CompilationSourceNameAttribute("floor")]
public static T Floor(T value);
    [CompilationSourceNameAttribute("floor")]
public static T Floor$W(FSharpFunc`2<T, T> floor, T value);
    [CompilationSourceNameAttribute("truncate")]
public static T Truncate(T value);
    [CompilationSourceNameAttribute("truncate")]
public static T Truncate$W(FSharpFunc`2<T, T> truncate, T value);
    [CompilationSourceNameAttribute("round")]
public static T Round(T value);
    [CompilationSourceNameAttribute("round")]
public static T Round$W(FSharpFunc`2<T, T> round, T value);
    [CompilationSourceNameAttribute("sign")]
public static int Sign(T value);
    [CompilationSourceNameAttribute("sign")]
public static int Sign$W(FSharpFunc`2<T, int> get_Sign, T value);
    [CompilationSourceNameAttribute("log")]
public static T Log(T value);
    [CompilationSourceNameAttribute("log")]
public static T Log$W(FSharpFunc`2<T, T> log, T value);
    [CompilationSourceNameAttribute("log10")]
public static T Log10(T value);
    [CompilationSourceNameAttribute("log10")]
public static T Log10$W(FSharpFunc`2<T, T> log10, T value);
    [CompilationSourceNameAttribute("sqrt")]
public static TResult Sqrt(T value);
    [CompilationSourceNameAttribute("sqrt")]
public static TResult Sqrt$W(FSharpFunc`2<T, TResult> sqrt, T value);
    [CompilationSourceNameAttribute("cos")]
public static T Cos(T value);
    [CompilationSourceNameAttribute("cos")]
public static T Cos$W(FSharpFunc`2<T, T> cos, T value);
    [CompilationSourceNameAttribute("cosh")]
public static T Cosh(T value);
    [CompilationSourceNameAttribute("cosh")]
public static T Cosh$W(FSharpFunc`2<T, T> cosh, T value);
    [CompilationSourceNameAttribute("sin")]
public static T Sin(T value);
    [CompilationSourceNameAttribute("sin")]
public static T Sin$W(FSharpFunc`2<T, T> sin, T value);
    [CompilationSourceNameAttribute("sinh")]
public static T Sinh(T value);
    [CompilationSourceNameAttribute("sinh")]
public static T Sinh$W(FSharpFunc`2<T, T> sinh, T value);
    [CompilationSourceNameAttribute("tan")]
public static T Tan(T value);
    [CompilationSourceNameAttribute("tan")]
public static T Tan$W(FSharpFunc`2<T, T> tan, T value);
    [CompilationSourceNameAttribute("tanh")]
public static T Tanh(T value);
    [CompilationSourceNameAttribute("tanh")]
public static T Tanh$W(FSharpFunc`2<T, T> tanh, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_Exponentiation(T x, TResult y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T op_Exponentiation$W(FSharpFunc`2<T, FSharpFunc`2<TResult, T>> pow, T x, TResult y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("pown")]
public static T PowInteger(T x, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("pown")]
public static T PowInteger$W(FSharpFunc`2<Unit, T> get_One, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Division, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Multiply, T x, int n);
}
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.OptimizedClosures : object {
}
[AttributeUsageAttribute("2048")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.OptionalArgumentAttribute : Attribute {
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.OptionModule : object {
    [CompilationSourceNameAttribute("get")]
public static T GetValue(FSharpOption`1<T> option);
    [CompilationSourceNameAttribute("isSome")]
public static bool IsSome(FSharpOption`1<T> option);
    [CompilationSourceNameAttribute("isNone")]
public static bool IsNone(FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("defaultValue")]
public static T DefaultValue(T value, FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("defaultWith")]
public static T DefaultWith(FSharpFunc`2<Unit, T> defThunk, FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("orElse")]
public static FSharpOption`1<T> OrElse(FSharpOption`1<T> ifNone, FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("orElseWith")]
public static FSharpOption`1<T> OrElseWith(FSharpFunc`2<Unit, FSharpOption`1<T>> ifNoneThunk, FSharpOption`1<T> option);
    [CompilationSourceNameAttribute("count")]
public static int Count(FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold")]
public static TState Fold(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> folder, TState state, FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack")]
public static TState FoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> folder, FSharpOption`1<T> option, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists")]
public static bool Exists(FSharpFunc`2<T, bool> predicate, FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall")]
public static bool ForAll(FSharpFunc`2<T, bool> predicate, FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("contains")]
public static bool Contains(T value, FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<T, Unit> action, FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static FSharpOption`1<TResult> Map(FSharpFunc`2<T, TResult> mapping, FSharpOption`1<T> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map2")]
public static FSharpOption`1<TResult> Map2(FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> mapping, FSharpOption`1<T1> option1, FSharpOption`1<T2> option2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map3")]
public static FSharpOption`1<TResult> Map3(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> mapping, FSharpOption`1<T1> option1, FSharpOption`1<T2> option2, FSharpOption`1<T3> option3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("bind")]
public static FSharpOption`1<TResult> Bind(FSharpFunc`2<T, FSharpOption`1<TResult>> binder, FSharpOption`1<T> option);
    [CompilationSourceNameAttribute("flatten")]
public static FSharpOption`1<T> Flatten(FSharpOption`1<FSharpOption`1<T>> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static FSharpOption`1<T> Filter(FSharpFunc`2<T, bool> predicate, FSharpOption`1<T> option);
    [CompilationSourceNameAttribute("toArray")]
public static T[] ToArray(FSharpOption`1<T> option);
    [CompilationSourceNameAttribute("toList")]
public static FSharpList`1<T> ToList(FSharpOption`1<T> option);
    [CompilationSourceNameAttribute("toNullable")]
public static Nullable`1<T> ToNullable(FSharpOption`1<T> option);
    [CompilationSourceNameAttribute("ofNullable")]
public static FSharpOption`1<T> OfNullable(Nullable`1<T> value);
    [CompilationSourceNameAttribute("ofObj")]
public static FSharpOption`1<T> OfObj(T value);
    [CompilationSourceNameAttribute("toObj")]
public static T ToObj(FSharpOption`1<T> value);
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.PrintfFormat`4 : object {
    internal string value;
    internal Object[] captures;
    internal Type[] captureTys;
    public string Value { get; }
    [ExperimentalAttribute("Experimental library feature, requires '--langversion:preview'")]
public Object[] Captures { get; }
    [ExperimentalAttribute("Experimental library feature, requires '--langversion:preview'")]
public Type[] CaptureTypes { get; }
    [ExperimentalAttribute("Experimental library feature, requires '--langversion:preview'")]
public PrintfFormat`4(string value, Object[] captures, Type[] captureTys);
    public PrintfFormat`4(string value);
    public string get_Value();
    public Object[] get_Captures();
    public Type[] get_CaptureTypes();
    public virtual string ToString();
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.PrintfFormat`5 : PrintfFormat`4<TPrinter, TState, TResidue, TResult> {
    [ExperimentalAttribute("Experimental library feature, requires '--langversion:preview'")]
public PrintfFormat`5(string value, Object[] captures, Type[] captureTys);
    public PrintfFormat`5(string value);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Core.PrintfImpl : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int StarValue;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int NotSpecifiedValue;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int MaxArgumentsInSpecialization;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int DefaultPrecision;
    internal static BindingFlags NonPublicStatics { get; }
    [CompilationMappingAttribute("9")]
internal static MethodInfo mi_GenericToString { get; }
    internal static int MAX_CAPTURE { get; }
    private static PrintfImpl();
    internal static string valueOf@120(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T[] revToArray(int extra, FSharpList`1<T> args);
    internal static int normalizePrecision(int prec);
    internal static ValueConverter basicFloatToString(FormatSpecifier spec);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_NonPublicStatics();
    internal static MethodInfo get_mi_GenericToString();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueConverter getValueConverter(Type ty, FormatSpecifier spec);
    internal static Tuple`2<Type[], Type> go@1004-3(int n, Type[] buf, Type ty, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Type[], Type> extractCurriedArguments(Type ty, int n);
    internal static PrintfEnv`3<Unit, string, string> StringPrintfEnv(int blockSize);
    internal static PrintfEnv`3<StringBuilder, Unit, TResult> StringBuilderPrintfEnv(FSharpFunc`2<Unit, TResult> k, StringBuilder buf);
    internal static PrintfEnv`3<TextWriter, Unit, TResult> TextWriterPrintfEnv(FSharpFunc`2<Unit, TResult> k, TextWriter tw);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_MAX_CAPTURE();
    [CompilerGeneratedAttribute]
internal static Tuple`5<object, bool, Type[], Type, FSharpOption`1<object>> buildCaptureFunc$cont@1088(Type retTy, Type[] argTys, a allSteps, Type nextRetTy, FSharpOption`1<object> nextNextOpt, bool nextCanCombine, Type[] nextArgTys, object next, int matchValue_0, int matchValue_1, Unit unitVar);
    internal static FSharpFunc`2<a, FSharpFunc`2<Type, string>> convFunc@1149(FormatSpecifier spec);
    [CompilerGeneratedAttribute]
internal static Step buildStep$cont@1128(FormatSpecifier spec, Type[] argTys, string prefix, Unit unitVar);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.PrintfModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TPrinter gprintf(FSharpFunc`2<int, a> envf, PrintfFormat`4<TPrinter, TState, TResidue, TResult> format);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("ksprintf")]
public static T PrintFormatToStringThen(FSharpFunc`2<string, TResult> continuation, PrintfFormat`4<T, Unit, string, TResult> format);
    [CompilationSourceNameAttribute("sprintf")]
public static T PrintFormatToStringThen(PrintfFormat`4<T, Unit, string, string> format);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("kprintf")]
public static T PrintFormatThen(FSharpFunc`2<string, TResult> continuation, PrintfFormat`4<T, Unit, string, TResult> format);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("kbprintf")]
public static T PrintFormatToStringBuilderThen(FSharpFunc`2<Unit, TResult> continuation, StringBuilder builder, PrintfFormat`4<T, StringBuilder, Unit, TResult> format);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("kfprintf")]
public static T PrintFormatToTextWriterThen(FSharpFunc`2<Unit, TResult> continuation, TextWriter textWriter, PrintfFormat`4<T, TextWriter, Unit, TResult> format);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("bprintf")]
public static T PrintFormatToStringBuilder(StringBuilder builder, PrintfFormat`4<T, StringBuilder, Unit, Unit> format);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fprintf")]
public static T PrintFormatToTextWriter(TextWriter textWriter, PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fprintfn")]
public static T PrintFormatLineToTextWriter(TextWriter textWriter, PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationSourceNameAttribute("failwithf")]
public static T PrintFormatToStringThenFail(PrintfFormat`4<T, Unit, string, TResult> format);
    [CompilationSourceNameAttribute("printf")]
public static T PrintFormat(PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationSourceNameAttribute("eprintf")]
public static T PrintFormatToError(PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationSourceNameAttribute("printfn")]
public static T PrintFormatLine(PrintfFormat`4<T, TextWriter, Unit, Unit> format);
    [CompilationSourceNameAttribute("eprintfn")]
public static T PrintFormatLineToError(PrintfFormat`4<T, TextWriter, Unit, Unit> format);
}
[AttributeUsageAttribute("2048")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.ProjectionParameterAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.ReferenceEqualityAttribute : Attribute {
}
[AttributeUsageAttribute("2276")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.ReflectedDefinitionAttribute : Attribute {
    internal bool includeValue;
    public bool IncludeValue { get; }
    public ReflectedDefinitionAttribute(bool includeValue);
    public bool get_IncludeValue();
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.RequireQualifiedAccessAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute : Attribute {
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.ResultModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static FSharpResult`2<TResult, TError> Map(FSharpFunc`2<T, TResult> mapping, FSharpResult`2<T, TError> result);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapError")]
public static FSharpResult`2<T, TResult> MapError(FSharpFunc`2<TError, TResult> mapping, FSharpResult`2<T, TError> result);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("bind")]
public static FSharpResult`2<TResult, TError> Bind(FSharpFunc`2<T, FSharpResult`2<TResult, TError>> binder, FSharpResult`2<T, TError> result);
}
[AttributeUsageAttribute("4")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.SealedAttribute : Attribute {
    internal bool value;
    public bool Value { get; }
    public SealedAttribute(bool value);
    public bool get_Value();
}
[CompilationMappingAttribute("3")]
public enum Microsoft.FSharp.Core.SourceConstructFlags : Enum {
    public int value__;
    public static SourceConstructFlags None;
    public static SourceConstructFlags SumType;
    public static SourceConstructFlags RecordType;
    public static SourceConstructFlags ObjectType;
    public static SourceConstructFlags Field;
    public static SourceConstructFlags Exception;
    public static SourceConstructFlags Closure;
    public static SourceConstructFlags Module;
    public static SourceConstructFlags UnionCase;
    public static SourceConstructFlags Value;
    public static SourceConstructFlags KindMask;
    public static SourceConstructFlags NonPublicRepresentation;
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Core.SR : object {
    [CompilationMappingAttribute("9")]
internal static CultureInfo Culture { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static ResourceManager ResourceManager { get; }
    internal static string matchCasesIncomplete { get; }
    internal static string addressOpNotFirstClass { get; }
    internal static string arraysHadDifferentLengths { get; }
    internal static string arrayWasEmpty { get; }
    internal static string badFormatString { get; }
    internal static string delegateExpected { get; }
    internal static string dyInvDivByIntCoerce { get; }
    internal static string dyInvOpAddCoerce { get; }
    internal static string dyInvOpAddOverload { get; }
    internal static string dyInvOpMultCoerce { get; }
    internal static string dyInvOpMultOverload { get; }
    internal static string endCannotBeNaN { get; }
    internal static string enumerationAlreadyFinished { get; }
    internal static string enumerationNotStarted { get; }
    internal static string setContainsNoElements { get; }
    internal static string enumerationPastIntMaxValue { get; }
    internal static string failedReadEnoughBytes { get; }
    internal static string genericCompareFail1 { get; }
    internal static string indexOutOfBounds { get; }
    internal static string inputListWasEmpty { get; }
    internal static string inputMustBeNonNegative { get; }
    internal static string inputMustBePositive { get; }
    internal static string inputSequenceEmpty { get; }
    internal static string invalidTupleTypes { get; }
    internal static string keyNotFound { get; }
    internal static string listsHadDifferentLengths { get; }
    internal static string mailboxProcessorAlreadyStarted { get; }
    internal static string mailboxProcessorPostAndAsyncReplyTimedOut { get; }
    internal static string mailboxProcessorPostAndReplyTimedOut { get; }
    internal static string mailboxReceiveTimedOut { get; }
    internal static string mailboxScanTimedOut { get; }
    internal static string mapCannotBeMutated { get; }
    internal static string mismatchIARCancel { get; }
    internal static string mismatchIAREnd { get; }
    internal static string noNegateMinValue { get; }
    internal static string checkInit { get; }
    internal static string checkStaticInit { get; }
    internal static string nonZeroBasedDisallowed { get; }
    internal static string notAFunctionType { get; }
    internal static string notAnExceptionType { get; }
    internal static string notAPermutation { get; }
    internal static string notARecordType { get; }
    internal static string notATupleType { get; }
    internal static string notAUnionType { get; }
    internal static string notComparable { get; }
    internal static string notEnoughElements { get; }
    internal static string notUsedForHashing { get; }
    internal static string nullsNotAllowedInArray { get; }
    internal static string objIsNotARecord { get; }
    internal static string objIsNullAndNoType { get; }
    internal static string outOfRange { get; }
    internal static string privateExceptionType { get; }
    internal static string privateRecordType { get; }
    internal static string privateUnionType { get; }
    internal static string QexpectedOneType { get; }
    internal static string QexpectedTwoTypes { get; }
    internal static string QinvalidCaseIndex { get; }
    internal static string QmissingRecordField { get; }
    internal static string QmissingUnionCase { get; }
    internal static string QtmmBadFieldType { get; }
    internal static string QtmmBodyMustBeUnit { get; }
    internal static string QtmmCondMustBeBool { get; }
    internal static string QtmmExpectedFunction { get; }
    internal static string QtmmExprNotMatchTuple { get; }
    internal static string QtmmExprTypeMismatch { get; }
    internal static string QtmmFunctionArgTypeMismatch { get; }
    internal static string QtmmGuardMustBeBool { get; }
    internal static string QtmmIncorrectArgForRecord { get; }
    internal static string QtmmIncorrectArgForUnion { get; }
    internal static string QtmmInitArray { get; }
    internal static string QtmmInvalidParam { get; }
    internal static string QtmmLoopBodyMustBeLambdaTakingInteger { get; }
    internal static string QtmmLowerUpperBoundMustBeInt { get; }
    internal static string QtmmTrueAndFalseMustMatch { get; }
    internal static string QtmmTuple { get; }
    internal static string QtmmVarTypeNotMatchRHS { get; }
    internal static string QunexpectedHole { get; }
    internal static string QunrecognizedMethodCall { get; }
    internal static string resetNotSupported { get; }
    internal static string startCannotBeNaN { get; }
    internal static string stepCannotBeNaN { get; }
    internal static string stepCannotBeZero { get; }
    internal static string syncContextNull { get; }
    internal static string tupleIndexOutOfRange { get; }
    internal static string QfailedToBindConstructor { get; }
    internal static string QfailedToBindField { get; }
    internal static string QfailedToBindProperty { get; }
    internal static string QfailedToBindTypeInAssembly { get; }
    internal static string QincompatibleRecordLength { get; }
    internal static string QincorrectInstanceType { get; }
    internal static string QincorrectNumArgs { get; }
    internal static string QincorrectType { get; }
    internal static string QinvalidFuncType { get; }
    internal static string QnonStaticNoReceiverObject { get; }
    internal static string QparentCannotBeNull { get; }
    internal static string QreadingSetOnly { get; }
    internal static string QstaticWithReceiverObject { get; }
    internal static string QtmmExprHasWrongType { get; }
    internal static string QtmmFunTypeNotMatchDelegate { get; }
    internal static string QtmmRaw { get; }
    internal static string QtupleAccessOutOfRange { get; }
    internal static string QtupleLengthsDiffer { get; }
    internal static string QunionNeedsDiffNumArgs { get; }
    internal static string QwritingGetOnly { get; }
    internal static string QwrongNumOfTypeArgs { get; }
    internal static string keyNotFoundAlt { get; }
    internal static string constructorForUnionCaseNotFound { get; }
    internal static string firstClassUsesOfSplice { get; }
    internal static string moveNextNotCalledOrFinished { get; }
    internal static string multipleCompilationMappings { get; }
    internal static string printfBadFloatValue { get; }
    internal static string printfBadFormatSpecifier { get; }
    internal static string printfBadIntegerForDynamicFomatter { get; }
    internal static string printfExpectedPrecision { get; }
    internal static string printfExpectedWidth { get; }
    internal static string printfHashFormatSpecifierIllegal { get; }
    internal static string printfMissingFormatSpecifier { get; }
    internal static string printfNotAFunType { get; }
    internal static string printfPrecisonSpecifierIllegal { get; }
    internal static string printfSpecifierAfterIllegal { get; }
    internal static string printfWidthSpecifierIllegal { get; }
    internal static string QcannotBindFunction { get; }
    internal static string QcannotBindProperty { get; }
    internal static string QcannotBindToMethod { get; }
    internal static string QcannotTakeAddress { get; }
    internal static string QfailedToBindAssembly { get; }
    internal static string QillFormedAppOrLet { get; }
    internal static string QtypeArgumentOutOfRange { get; }
    internal static string thisValueCannotBeMutated { get; }
    internal static string optionValueWasNone { get; }
    internal static string controlContinuationInvokedMultipleTimes { get; }
    internal static string invalidRecordTypeConstructorNotDefined { get; }
    internal static string invalidTupleTypeConstructorNotDefined { get; }
    internal static string inputSequenceTooLong { get; }
    internal static string thenByError { get; }
    internal static string failDueToUnsupportedInputTypeInSumByOrAverageBy { get; }
    internal static string unsupportedIfThenElse { get; }
    internal static string unsupportedQueryConstruct { get; }
    internal static string unsupportedQueryCall { get; }
    internal static string unsupportedQueryProperty { get; }
    internal static string unsupportedQueryConstructKind { get; }
    internal static string maxDegreeOfParallelismNotPositive { get; }
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static ResourceManager get_ResourceManager();
    internal static string GetString(string name);
    internal static object GetObject(string name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_matchCasesIncomplete();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_addressOpNotFirstClass();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_arraysHadDifferentLengths();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_arrayWasEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_badFormatString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_delegateExpected();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_dyInvDivByIntCoerce();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_dyInvOpAddCoerce();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_dyInvOpAddOverload();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_dyInvOpMultCoerce();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_dyInvOpMultOverload();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_endCannotBeNaN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_enumerationAlreadyFinished();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_enumerationNotStarted();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_setContainsNoElements();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_enumerationPastIntMaxValue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_failedReadEnoughBytes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_genericCompareFail1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_indexOutOfBounds();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_inputListWasEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_inputMustBeNonNegative();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_inputMustBePositive();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_inputSequenceEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_invalidTupleTypes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_keyNotFound();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_listsHadDifferentLengths();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_mailboxProcessorAlreadyStarted();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_mailboxProcessorPostAndAsyncReplyTimedOut();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_mailboxProcessorPostAndReplyTimedOut();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_mailboxReceiveTimedOut();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_mailboxScanTimedOut();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_mapCannotBeMutated();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_mismatchIARCancel();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_mismatchIAREnd();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_noNegateMinValue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_checkInit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_checkStaticInit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_nonZeroBasedDisallowed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notAFunctionType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notAnExceptionType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notAPermutation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notARecordType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notATupleType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notAUnionType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notComparable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notEnoughElements();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notUsedForHashing();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_nullsNotAllowedInArray();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_objIsNotARecord();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_objIsNullAndNoType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_outOfRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_privateExceptionType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_privateRecordType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_privateUnionType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QexpectedOneType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QexpectedTwoTypes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QinvalidCaseIndex();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QmissingRecordField();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QmissingUnionCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmBadFieldType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmBodyMustBeUnit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmCondMustBeBool();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmExpectedFunction();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmExprNotMatchTuple();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmExprTypeMismatch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmFunctionArgTypeMismatch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmGuardMustBeBool();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmIncorrectArgForRecord();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmIncorrectArgForUnion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmInitArray();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmInvalidParam();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmLoopBodyMustBeLambdaTakingInteger();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmLowerUpperBoundMustBeInt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmTrueAndFalseMustMatch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmTuple();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmVarTypeNotMatchRHS();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QunexpectedHole();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QunrecognizedMethodCall();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_resetNotSupported();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_startCannotBeNaN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_stepCannotBeNaN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_stepCannotBeZero();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_syncContextNull();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tupleIndexOutOfRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QfailedToBindConstructor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QfailedToBindField();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QfailedToBindProperty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QfailedToBindTypeInAssembly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QincompatibleRecordLength();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QincorrectInstanceType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QincorrectNumArgs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QincorrectType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QinvalidFuncType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QnonStaticNoReceiverObject();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QparentCannotBeNull();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QreadingSetOnly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QstaticWithReceiverObject();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmExprHasWrongType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmFunTypeNotMatchDelegate();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtmmRaw();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtupleAccessOutOfRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtupleLengthsDiffer();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QunionNeedsDiffNumArgs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QwritingGetOnly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QwrongNumOfTypeArgs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_keyNotFoundAlt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_constructorForUnionCaseNotFound();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_firstClassUsesOfSplice();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_moveNextNotCalledOrFinished();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_multipleCompilationMappings();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfBadFloatValue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfBadFormatSpecifier();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfBadIntegerForDynamicFomatter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfExpectedPrecision();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfExpectedWidth();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfHashFormatSpecifierIllegal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfMissingFormatSpecifier();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfNotAFunType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfPrecisonSpecifierIllegal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfSpecifierAfterIllegal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printfWidthSpecifierIllegal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QcannotBindFunction();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QcannotBindProperty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QcannotBindToMethod();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QcannotTakeAddress();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QfailedToBindAssembly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QillFormedAppOrLet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_QtypeArgumentOutOfRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_thisValueCannotBeMutated();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_optionValueWasNone();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_controlContinuationInvokedMultipleTimes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_invalidRecordTypeConstructorNotDefined();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_invalidTupleTypeConstructorNotDefined();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_inputSequenceTooLong();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_thenByError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_failDueToUnsupportedInputTypeInSumByOrAverageBy();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_unsupportedIfThenElse();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_unsupportedQueryConstruct();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_unsupportedQueryCall();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_unsupportedQueryProperty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_unsupportedQueryConstructKind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_maxDegreeOfParallelismNotPositive();
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.StringModule : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int LOH_CHAR_THRESHOLD;
    [CompilationSourceNameAttribute("length")]
public static int Length(string str);
    internal static string concatArray@27(string sep, String[] strings);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("concat")]
public static string Concat(string sep, IEnumerable`1<string> strings);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<char, Unit> action, string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iteri")]
public static void IterateIndexed(FSharpFunc`2<int, FSharpFunc`2<char, Unit>> action, string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static string Map(FSharpFunc`2<char, char> mapping, string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapi")]
public static string MapIndexed(FSharpFunc`2<int, FSharpFunc`2<char, char>> mapping, string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static string Filter(FSharpFunc`2<char, bool> predicate, string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("collect")]
public static string Collect(FSharpFunc`2<char, string> mapping, string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("init")]
public static string Initialize(int count, FSharpFunc`2<int, string> initializer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("replicate")]
public static string Replicate(int count, string str);
    internal static bool check@173-4(FSharpFunc`2<char, bool> predicate, string str, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall")]
public static bool ForAll(FSharpFunc`2<char, bool> predicate, string str);
    internal static bool check@181-5(FSharpFunc`2<char, bool> predicate, string str, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists")]
public static bool Exists(FSharpFunc`2<char, bool> predicate, string str);
}
[AttributeUsageAttribute("8")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.StructAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.StructuralComparisonAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.StructuralEqualityAttribute : Attribute {
}
[AttributeUsageAttribute("5148")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.StructuredFormatDisplayAttribute : Attribute {
    internal string value;
    public string Value { get; }
    public StructuredFormatDisplayAttribute(string value);
    public string get_Value();
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Core.TupleUtils : object {
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.Unit : object {
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private virtual override int System.IComparable.CompareTo(object _obj);
}
[AttributeUsageAttribute("192")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.UnverifiableAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Core.ValueAsStaticPropertyAttribute : Attribute {
}
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Core.ValueOption : object {
    [CompilationSourceNameAttribute("get")]
public static T GetValue(FSharpValueOption`1<T> voption);
    [CompilationSourceNameAttribute("isSome")]
public static bool IsSome(FSharpValueOption`1<T> voption);
    [CompilationSourceNameAttribute("isNone")]
public static bool IsNone(FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("defaultValue")]
public static T DefaultValue(T value, FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("defaultWith")]
public static T DefaultWith(FSharpFunc`2<Unit, T> defThunk, FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("orElse")]
public static FSharpValueOption`1<T> OrElse(FSharpValueOption`1<T> ifNone, FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("orElseWith")]
public static FSharpValueOption`1<T> OrElseWith(FSharpFunc`2<Unit, FSharpValueOption`1<T>> ifNoneThunk, FSharpValueOption`1<T> voption);
    [CompilationSourceNameAttribute("count")]
public static int Count(FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold")]
public static TState Fold(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> folder, TState state, FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack")]
public static TState FoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> folder, FSharpValueOption`1<T> voption, TState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists")]
public static bool Exists(FSharpFunc`2<T, bool> predicate, FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall")]
public static bool ForAll(FSharpFunc`2<T, bool> predicate, FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("contains")]
public static bool Contains(T value, FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<T, Unit> action, FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static FSharpValueOption`1<TResult> Map(FSharpFunc`2<T, TResult> mapping, FSharpValueOption`1<T> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map2")]
public static FSharpValueOption`1<TResult> Map2(FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> mapping, FSharpValueOption`1<T1> voption1, FSharpValueOption`1<T2> voption2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map3")]
public static FSharpValueOption`1<TResult> Map3(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> mapping, FSharpValueOption`1<T1> voption1, FSharpValueOption`1<T2> voption2, FSharpValueOption`1<T3> voption3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("bind")]
public static FSharpValueOption`1<TResult> Bind(FSharpFunc`2<T, FSharpValueOption`1<TResult>> binder, FSharpValueOption`1<T> voption);
    [CompilationSourceNameAttribute("flatten")]
public static FSharpValueOption`1<T> Flatten(FSharpValueOption`1<FSharpValueOption`1<T>> voption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static FSharpValueOption`1<T> Filter(FSharpFunc`2<T, bool> predicate, FSharpValueOption`1<T> voption);
    [CompilationSourceNameAttribute("toArray")]
public static T[] ToArray(FSharpValueOption`1<T> voption);
    [CompilationSourceNameAttribute("toList")]
public static FSharpList`1<T> ToList(FSharpValueOption`1<T> voption);
    [CompilationSourceNameAttribute("toNullable")]
public static Nullable`1<T> ToNullable(FSharpValueOption`1<T> voption);
    [CompilationSourceNameAttribute("ofNullable")]
public static FSharpValueOption`1<T> OfNullable(Nullable`1<T> value);
    [CompilationSourceNameAttribute("ofObj")]
public static FSharpValueOption`1<T> OfObj(T value);
    [CompilationSourceNameAttribute("toObj")]
public static T ToObj(FSharpValueOption`1<T> value);
}
[AttributeUsageAttribute("256")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Core.VolatileFieldAttribute : Attribute {
}
[MeasureAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.ampere : object {
}
[MeasureAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.candela : object {
}
[MeasureAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.kelvin : object {
}
[MeasureAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.kilogram : object {
}
[MeasureAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.metre : object {
}
[MeasureAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.mole : object {
}
[MeasureAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.second : object {
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Linq.ForwardDeclarations : object {
    [CompilationMappingAttribute("9")]
internal static IQueryMethods Query { get; internal set; }
    internal static IQueryMethods get_Query();
    internal static void set_Query(IQueryMethods value);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Linq.Helpers : object {
    internal static IOrderedEnumerable`1<T> checkThenBySource(IEnumerable`1<T> source);
}
[CompilationRepresentationAttribute("4")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Linq.NullableModule : object {
    [CompilationSourceNameAttribute("uint8")]
public static Nullable`1<byte> ToUInt8(Nullable`1<T> value);
    [CompilationSourceNameAttribute("uint8")]
public static Nullable`1<byte> ToUInt8$W(FSharpFunc`2<T, byte> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("int8")]
public static Nullable`1<sbyte> ToInt8(Nullable`1<T> value);
    [CompilationSourceNameAttribute("int8")]
public static Nullable`1<sbyte> ToInt8$W(FSharpFunc`2<T, sbyte> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("byte")]
public static Nullable`1<byte> ToByte(Nullable`1<T> value);
    [CompilationSourceNameAttribute("byte")]
public static Nullable`1<byte> ToByte$W(FSharpFunc`2<T, byte> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("sbyte")]
public static Nullable`1<sbyte> ToSByte(Nullable`1<T> value);
    [CompilationSourceNameAttribute("sbyte")]
public static Nullable`1<sbyte> ToSByte$W(FSharpFunc`2<T, sbyte> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("int16")]
public static Nullable`1<short> ToInt16(Nullable`1<T> value);
    [CompilationSourceNameAttribute("int16")]
public static Nullable`1<short> ToInt16$W(FSharpFunc`2<T, short> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("uint16")]
public static Nullable`1<ushort> ToUInt16(Nullable`1<T> value);
    [CompilationSourceNameAttribute("uint16")]
public static Nullable`1<ushort> ToUInt16$W(FSharpFunc`2<T, ushort> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("int")]
public static Nullable`1<int> ToInt(Nullable`1<T> value);
    [CompilationSourceNameAttribute("int")]
public static Nullable`1<int> ToInt$W(FSharpFunc`2<T, int> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("uint")]
public static Nullable`1<UInt32> ToUInt(Nullable`1<T> value);
    [CompilationSourceNameAttribute("uint")]
public static Nullable`1<UInt32> ToUInt$W(FSharpFunc`2<T, UInt32> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("enum")]
public static Nullable`1<TResult> ToEnum(Nullable`1<int> value);
    [CompilationSourceNameAttribute("int32")]
public static Nullable`1<int> ToInt32(Nullable`1<T> value);
    [CompilationSourceNameAttribute("int32")]
public static Nullable`1<int> ToInt32$W(FSharpFunc`2<T, int> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("uint32")]
public static Nullable`1<UInt32> ToUInt32(Nullable`1<T> value);
    [CompilationSourceNameAttribute("uint32")]
public static Nullable`1<UInt32> ToUInt32$W(FSharpFunc`2<T, UInt32> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("int64")]
public static Nullable`1<long> ToInt64(Nullable`1<T> value);
    [CompilationSourceNameAttribute("int64")]
public static Nullable`1<long> ToInt64$W(FSharpFunc`2<T, long> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("uint64")]
public static Nullable`1<ulong> ToUInt64(Nullable`1<T> value);
    [CompilationSourceNameAttribute("uint64")]
public static Nullable`1<ulong> ToUInt64$W(FSharpFunc`2<T, ulong> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("float32")]
public static Nullable`1<float> ToFloat32(Nullable`1<T> value);
    [CompilationSourceNameAttribute("float32")]
public static Nullable`1<float> ToFloat32$W(FSharpFunc`2<T, float> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("float")]
public static Nullable`1<double> ToFloat(Nullable`1<T> value);
    [CompilationSourceNameAttribute("float")]
public static Nullable`1<double> ToFloat$W(FSharpFunc`2<T, double> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("single")]
public static Nullable`1<float> ToSingle(Nullable`1<T> value);
    [CompilationSourceNameAttribute("single")]
public static Nullable`1<float> ToSingle$W(FSharpFunc`2<T, float> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("double")]
public static Nullable`1<double> ToDouble(Nullable`1<T> value);
    [CompilationSourceNameAttribute("double")]
public static Nullable`1<double> ToDouble$W(FSharpFunc`2<T, double> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("nativeint")]
public static Nullable`1<IntPtr> ToIntPtr(Nullable`1<T> value);
    [CompilationSourceNameAttribute("nativeint")]
public static Nullable`1<IntPtr> ToIntPtr$W(FSharpFunc`2<T, IntPtr> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("unativeint")]
public static Nullable`1<UIntPtr> ToUIntPtr(Nullable`1<T> value);
    [CompilationSourceNameAttribute("unativeint")]
public static Nullable`1<UIntPtr> ToUIntPtr$W(FSharpFunc`2<T, UIntPtr> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("decimal")]
public static Nullable`1<decimal> ToDecimal(Nullable`1<T> value);
    [CompilationSourceNameAttribute("decimal")]
public static Nullable`1<decimal> ToDecimal$W(FSharpFunc`2<T, decimal> op_Explicit, Nullable`1<T> value);
    [CompilationSourceNameAttribute("char")]
public static Nullable`1<char> ToChar(Nullable`1<T> value);
    [CompilationSourceNameAttribute("char")]
public static Nullable`1<char> ToChar$W(FSharpFunc`2<T, char> op_Explicit, Nullable`1<T> value);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Linq.NullableOperators : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkGreaterEquals(Nullable`1<T> x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkGreater(Nullable`1<T> x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkLessEquals(Nullable`1<T> x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkLess(Nullable`1<T> x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkEquals(Nullable`1<T> x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkLessGreater(Nullable`1<T> x, T y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_GreaterEqualsQmark(T x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_GreaterQmark(T x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_LessEqualsQmark(T x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_LessQmark(T x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_EqualsQmark(T x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_LessGreaterQmark(T x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkGreaterEqualsQmark(Nullable`1<T> x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkGreaterQmark(Nullable`1<T> x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkLessEqualsQmark(Nullable`1<T> x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkLessQmark(Nullable`1<T> x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkEqualsQmark(Nullable`1<T> x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_QmarkLessGreaterQmark(Nullable`1<T> x, Nullable`1<T> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkPlus(Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkPlus$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Addition, Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_PlusQmark(T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_PlusQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Addition, T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkPlusQmark(Nullable`1<T1> x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkPlusQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Addition, Nullable`1<T1> x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkMinus(Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkMinus$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Subtraction, Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_MinusQmark(T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_MinusQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Subtraction, T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkMinusQmark(Nullable`1<T1> x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkMinusQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Subtraction, Nullable`1<T1> x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkMultiply(Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkMultiply$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Multiply, Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_MultiplyQmark(T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_MultiplyQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Multiply, T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkMultiplyQmark(Nullable`1<T1> x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkMultiplyQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Multiply, Nullable`1<T1> x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkPercent(Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkPercent$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Modulus, Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_PercentQmark(T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_PercentQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Modulus, T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkPercentQmark(Nullable`1<T1> x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkPercentQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Modulus, Nullable`1<T1> x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkDivide(Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkDivide$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Division, Nullable`1<T1> x, T2 y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_DivideQmark(T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_DivideQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Division, T1 x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkDivideQmark(Nullable`1<T1> x, Nullable`1<T2> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Nullable`1<T3> op_QmarkDivideQmark$W(FSharpFunc`2<T1, FSharpFunc`2<T2, T3>> op_Division, Nullable`1<T1> x, Nullable`1<T2> y);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.QueryBuilder : object {
    public QuerySource`2<TResult, Q> For(QuerySource`2<T, Q> source, FSharpFunc`2<T, QuerySource`2<TResult, Q2>> body);
    public QuerySource`2<T, Q> Zero();
    public QuerySource`2<T, Q> Yield(T value);
    public QuerySource`2<T, Q> YieldFrom(QuerySource`2<T, Q> computation);
    public FSharpExpr`1<T> Quote(FSharpExpr`1<T> quotation);
    public QuerySource`2<T, Q> Source(IQueryable`1<T> source);
    public QuerySource`2<T, IEnumerable> Source(IEnumerable`1<T> source);
    [CustomOperationAttribute("contains")]
public bool Contains(QuerySource`2<T, Q> source, T key);
    [CustomOperationAttribute("select")]
public QuerySource`2<TResult, Q> Select(QuerySource`2<T, Q> source, FSharpFunc`2<T, TResult> projection);
    [CustomOperationAttribute("where")]
public QuerySource`2<T, Q> Where(QuerySource`2<T, Q> source, FSharpFunc`2<T, bool> predicate);
    [CustomOperationAttribute("last")]
public T Last(QuerySource`2<T, Q> source);
    [CustomOperationAttribute("lastOrDefault")]
public T LastOrDefault(QuerySource`2<T, Q> source);
    [CustomOperationAttribute("exactlyOne")]
public T ExactlyOne(QuerySource`2<T, Q> source);
    [CustomOperationAttribute("exactlyOneOrDefault")]
public T ExactlyOneOrDefault(QuerySource`2<T, Q> source);
    [CustomOperationAttribute("count")]
public int Count(QuerySource`2<T, Q> source);
    [CustomOperationAttribute("distinct")]
public QuerySource`2<T, Q> Distinct(QuerySource`2<T, Q> source);
    [CustomOperationAttribute("exists")]
public bool Exists(QuerySource`2<T, Q> source, FSharpFunc`2<T, bool> predicate);
    [CustomOperationAttribute("all")]
public bool All(QuerySource`2<T, Q> source, FSharpFunc`2<T, bool> predicate);
    [CustomOperationAttribute("head")]
public T Head(QuerySource`2<T, Q> source);
    [CustomOperationAttribute("nth")]
public T Nth(QuerySource`2<T, Q> source, int index);
    [CustomOperationAttribute("skip")]
public QuerySource`2<T, Q> Skip(QuerySource`2<T, Q> source, int count);
    [CustomOperationAttribute("skipWhile")]
public QuerySource`2<T, Q> SkipWhile(QuerySource`2<T, Q> source, FSharpFunc`2<T, bool> predicate);
    [CustomOperationAttribute("take")]
public QuerySource`2<T, Q> Take(QuerySource`2<T, Q> source, int count);
    [CustomOperationAttribute("takeWhile")]
public QuerySource`2<T, Q> TakeWhile(QuerySource`2<T, Q> source, FSharpFunc`2<T, bool> predicate);
    [CustomOperationAttribute("find")]
public T Find(QuerySource`2<T, Q> source, FSharpFunc`2<T, bool> predicate);
    [CustomOperationAttribute("headOrDefault")]
public T HeadOrDefault(QuerySource`2<T, Q> source);
    [CustomOperationAttribute("minBy")]
public TValue MinBy(QuerySource`2<T, Q> source, FSharpFunc`2<T, TValue> valueSelector);
    [CustomOperationAttribute("maxBy")]
public TValue MaxBy(QuerySource`2<T, Q> source, FSharpFunc`2<T, TValue> valueSelector);
    [CustomOperationAttribute("minByNullable")]
public Nullable`1<TValue> MinByNullable(QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TValue>> valueSelector);
    [CustomOperationAttribute("maxByNullable")]
public Nullable`1<TValue> MaxByNullable(QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TValue>> valueSelector);
    [CustomOperationAttribute("sumByNullable")]
public Nullable`1<TValue> SumByNullable(QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TValue>> valueSelector);
    [CustomOperationAttribute("sumByNullable")]
public Nullable`1<TValue> SumByNullable$W(FSharpFunc`2<Unit, TValue> get_Zero, FSharpFunc`2<TValue, FSharpFunc`2<TValue, TValue>> op_Addition, QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TValue>> valueSelector);
    [CustomOperationAttribute("averageByNullable")]
public Nullable`1<TValue> AverageByNullable(QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TValue>> projection);
    [CustomOperationAttribute("averageByNullable")]
public Nullable`1<TValue> AverageByNullable$W(FSharpFunc`2<TValue, FSharpFunc`2<int, TValue>> divideByInt, FSharpFunc`2<Unit, TValue> get_Zero, FSharpFunc`2<TValue, FSharpFunc`2<TValue, TValue>> op_Addition, QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TValue>> projection);
    [CustomOperationAttribute("averageBy")]
public TValue AverageBy(QuerySource`2<T, Q> source, FSharpFunc`2<T, TValue> projection);
    [CustomOperationAttribute("averageBy")]
public TValue AverageBy$W(FSharpFunc`2<TValue, FSharpFunc`2<int, TValue>> divideByInt, FSharpFunc`2<Unit, TValue> get_Zero, FSharpFunc`2<TValue, FSharpFunc`2<TValue, TValue>> op_Addition, QuerySource`2<T, Q> source, FSharpFunc`2<T, TValue> projection);
    [CustomOperationAttribute("sumBy")]
public TValue SumBy(QuerySource`2<T, Q> source, FSharpFunc`2<T, TValue> projection);
    [CustomOperationAttribute("sumBy")]
public TValue SumBy$W(FSharpFunc`2<Unit, TValue> get_Zero, FSharpFunc`2<TValue, FSharpFunc`2<TValue, TValue>> op_Addition, QuerySource`2<T, Q> source, FSharpFunc`2<T, TValue> projection);
    [CustomOperationAttribute("groupBy")]
public QuerySource`2<IGrouping`2<TKey, T>, Q> GroupBy(QuerySource`2<T, Q> source, FSharpFunc`2<T, TKey> keySelector);
    [CustomOperationAttribute("sortBy")]
public QuerySource`2<T, Q> SortBy(QuerySource`2<T, Q> source, FSharpFunc`2<T, TKey> keySelector);
    [CustomOperationAttribute("sortByDescending")]
public QuerySource`2<T, Q> SortByDescending(QuerySource`2<T, Q> source, FSharpFunc`2<T, TKey> keySelector);
    [CustomOperationAttribute("thenBy")]
public QuerySource`2<T, Q> ThenBy(QuerySource`2<T, Q> source, FSharpFunc`2<T, TKey> keySelector);
    [CustomOperationAttribute("thenByDescending")]
public QuerySource`2<T, Q> ThenByDescending(QuerySource`2<T, Q> source, FSharpFunc`2<T, TKey> keySelector);
    [CustomOperationAttribute("sortByNullable")]
public QuerySource`2<T, Q> SortByNullable(QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TKey>> keySelector);
    [CustomOperationAttribute("sortByNullableDescending")]
public QuerySource`2<T, Q> SortByNullableDescending(QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TKey>> keySelector);
    [CustomOperationAttribute("thenByNullable")]
public QuerySource`2<T, Q> ThenByNullable(QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TKey>> keySelector);
    [CustomOperationAttribute("thenByNullableDescending")]
public QuerySource`2<T, Q> ThenByNullableDescending(QuerySource`2<T, Q> source, FSharpFunc`2<T, Nullable`1<TKey>> keySelector);
    [CustomOperationAttribute("groupValBy")]
public QuerySource`2<IGrouping`2<TKey, TValue>, Q> GroupValBy(QuerySource`2<T, Q> source, FSharpFunc`2<T, TValue> resultSelector, FSharpFunc`2<T, TKey> keySelector);
    [CustomOperationAttribute("join")]
public QuerySource`2<TResult, Q> Join(QuerySource`2<TOuter, Q> outerSource, QuerySource`2<TInner, Q> innerSource, FSharpFunc`2<TOuter, TKey> outerKeySelector, FSharpFunc`2<TInner, TKey> innerKeySelector, FSharpFunc`2<TOuter, FSharpFunc`2<TInner, TResult>> resultSelector);
    [CustomOperationAttribute("groupJoin")]
public QuerySource`2<TResult, Q> GroupJoin(QuerySource`2<TOuter, Q> outerSource, QuerySource`2<TInner, Q> innerSource, FSharpFunc`2<TOuter, TKey> outerKeySelector, FSharpFunc`2<TInner, TKey> innerKeySelector, FSharpFunc`2<TOuter, FSharpFunc`2<IEnumerable`1<TInner>, TResult>> resultSelector);
    [CustomOperationAttribute("leftOuterJoin")]
public QuerySource`2<TResult, Q> LeftOuterJoin(QuerySource`2<TOuter, Q> outerSource, QuerySource`2<TInner, Q> innerSource, FSharpFunc`2<TOuter, TKey> outerKeySelector, FSharpFunc`2<TInner, TKey> innerKeySelector, FSharpFunc`2<TOuter, FSharpFunc`2<IEnumerable`1<TInner>, TResult>> resultSelector);
    internal T RunQueryAsValue(FSharpExpr`1<T> q);
    internal IEnumerable`1<T> RunQueryAsEnumerable(FSharpExpr`1<QuerySource`2<T, IEnumerable>> q);
    internal IQueryable`1<T> RunQueryAsQueryable(FSharpExpr`1<QuerySource`2<T, IQueryable>> q);
    public IQueryable`1<T> Run(FSharpExpr`1<QuerySource`2<T, IQueryable>> q);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Linq.QueryModule : object {
    [CompilationMappingAttribute("9")]
internal static MethodInfo ImplicitExpressionConversionHelperMethodInfo { get; }
    [CompilationMappingAttribute("9")]
internal static Type NT { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-23 { get; }
    [CompilationMappingAttribute("9")]
internal static Type FT1 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-24 { get; }
    [CompilationMappingAttribute("9")]
internal static Type FT2 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-25 { get; }
    internal static Type boolTy { get; }
    [CompilationMappingAttribute("9")]
internal static Type IEnumerableTypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-26 { get; }
    [CompilationMappingAttribute("9")]
internal static Type IQueryableTypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-27 { get; }
    [CompilationMappingAttribute("9")]
internal static Type QuerySourceTypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-28 { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`4<bool, Type, object, FSharpExpr>, object>> patternInput@475 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> MakeContains { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, Type, object, FSharpExpr>, object> CallContains { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`4<bool, Type, object, FSharpExpr>, object>> patternInput@480-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> MakeElementAt { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, Type, object, FSharpExpr>, object> CallElementAt { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object>> patternInput@507-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeMinBy { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object> CallMinBy { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object>> patternInput@512-3 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeMaxBy { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object> CallMaxBy { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object>> patternInput@517-4 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeMinByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object> CallMinByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object>> patternInput@523-5 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeMaxByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object> CallMaxByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object>> patternInput@550-6 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeAny { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object> CallAny { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object>> patternInput@555-7 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeAll { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object> CallAll { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object>> patternInput@560-8 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeFirstFind { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object> CallFirstFind { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object>> patternInput@656-9 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_double@657 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_single@658 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_decimal@659 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_int32@660 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_int64@661 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_double@662 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_single@663 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_decimal@664 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_int32@665 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_int64@666 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE@667 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeAverageBy { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object> CallAverageBy { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object>> patternInput@670-10 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_double@671-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_single@672-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_decimal@673-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_int32@674-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_int64@675-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_double@676-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_single@677-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_decimal@678-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_int32@679-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_int64@680-1 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE@681-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeAverageByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object> CallAverageByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object>> patternInput@685-11 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_double@686-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_single@687-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_decimal@688-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_int32@689-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_int64@690-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_double@691-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_single@692-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_decimal@693-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_int32@694-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_int64@695-2 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE@696-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeSumBy { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object> CallSumBy { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object>> patternInput@699-12 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_double@700-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_single@701-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_decimal@702-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_int32@703-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FQ_int64@704-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_double@705-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_single@706-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_decimal@707-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_int32@708-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE_int64@709-3 { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle FE@710-3 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeSumByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object> CallSumByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> patternInput@724-13 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> MakeFirst { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> CallFirst { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> patternInput@726-14 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> MakeFirstOrDefault { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> CallFirstOrDefault { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> patternInput@728-15 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> MakeLast { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> CallLast { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> patternInput@730-16 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> MakeLastOrDefault { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> CallLastOrDefault { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> patternInput@732-17 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> MakeSingle { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> CallSingle { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> patternInput@734-18 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> MakeSingleOrDefault { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> CallSingleOrDefault { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> patternInput@736-19 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> MakeCount { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> CallCount { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> MakeDefaultIfEmpty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`5<CanEliminate, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeSelect { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FQ@748 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FE@749-4 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> MakeAppend { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FQ@768-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FE@769-5 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<Type, FSharpExpr>, FSharpExpr> MakeAsQueryable { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> F@777 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Type, FSharpExpr> MakeEnumerableEmpty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> F@782-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`7<bool, Type, FSharpExpr, FSharpVar, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeSelectMany { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FQ@791-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FE@792-6 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeWhere { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FQ@807-3 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FE@808-7 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeOrderBy { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeOrderByDescending { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeThenBy { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeThenByDescending { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeOrderByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeOrderByNullableDescending { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeThenByNullable { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeThenByNullableDescending { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> MakeSkip { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> MakeTake { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeSkipWhile { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeTakeWhile { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> MakeDistinct { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FQ@900-4 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FE@901-8 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> MakeGroupBy { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FQ@909-5 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FE@910-9 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`8<bool, Type, Type, Type, FSharpExpr, FSharpVar, FSharpExpr, Tuple`2<FSharpVar, FSharpExpr>>, FSharpExpr> MakeGroupValBy { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FQ@923-6 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FE@924-10 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`8<bool, Type, Type, Type, Type, FSharpExpr, FSharpExpr, Tuple`7<FSharpVar, FSharpExpr, FSharpVar, FSharpExpr, FSharpVar, FSharpVar, FSharpExpr>>, FSharpExpr> MakeJoin { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FQ@937-7 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FE@938-11 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`8<bool, Type, Type, Type, Type, FSharpExpr, FSharpExpr, Tuple`7<FSharpVar, FSharpExpr, FSharpVar, FSharpExpr, FSharpVar, FSharpVar, FSharpExpr>>, FSharpExpr> MakeGroupJoin { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FQ@953-8 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> FE@954-12 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CallQueryBuilderRunQueryable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CallQueryBuilderRunValue|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CallQueryBuilderRunEnumerable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CallQueryBuilderFor|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallQueryBuilderYield|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CallQueryBuilderYieldFrom|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CallQueryBuilderZero|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallQueryBuilderSourceIQueryable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallQueryBuilderSourceIEnumerable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallSortBy|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallSortByDescending|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallThenBy|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallThenByDescending|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallSortByNullable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallSortByNullableDescending|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallThenByNullable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallThenByNullableDescending|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallGroupBy|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`5<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr, FSharpExpr>>> |CallGroupValBy|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallMinBy|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallMaxBy|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallMinByNullable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallMaxByNullable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallWhere|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallHeadOrDefault|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallLast|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallLastOrDefault|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallExactlyOne|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallExactlyOneOrDefault|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallSelect|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallExists|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallForAll|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallDistinct|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallTake|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallTakeWhile|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallContains|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallNth|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallSkip|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallSkipWhile|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CallJoin|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CallGroupJoin|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CallLeftOuterJoin|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallAverageBy|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallSumBy|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallAverageByNullable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallSumByNullable|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallCount|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |CallHead|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |CallFind|_| { get; }
    internal static FSharpOption`1<MethodInfo> |Getter|_|(PropertyInfo prop);
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> |SpecificCall1|_|(RuntimeMethodHandle q);
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> |SpecificCall2|_|(RuntimeMethodHandle q);
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`5<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr, FSharpExpr>>> |SpecificCall3|_|(RuntimeMethodHandle q);
    internal static Tuple`2<FSharpList`1<Tuple`2<FSharpVar, FSharpExpr>>, FSharpExpr> stripSuccessiveProjLets@343-1(FSharpVar p, int n, FSharpExpr expr);
    internal static FSharpOption`1<Tuple`3<FSharpVar, FSharpList`1<Tuple`2<FSharpVar, FSharpExpr>>, FSharpExpr>> |LambdaNoDetupling|_|(FSharpExpr lam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr restoreTupleProjections(FSharpList`1<Tuple`2<FSharpVar, a>> projs, FSharpExpr b);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<FSharpVar>, FSharpExpr>> loop@359-49(FSharpList`1<FSharpVar> rvs, FSharpList`1<FSharpList`1<Tuple`2<FSharpVar, FSharpExpr>>> rprojs, FSharpExpr e);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<FSharpVar>, FSharpExpr>> |LambdasNoDetupling|_|(FSharpExpr inpExpr);
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> CallGenericStaticMethod(RuntimeMethodHandle methHandle);
    internal static FSharpFunc`2<Tuple`3<object, FSharpList`1<Type>, FSharpList`1<object>>, object> CallGenericInstanceMethod(RuntimeMethodHandle methHandle);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo BindGenericStaticMethod(MethodInfo methInfo, FSharpList`1<Type> tyargs);
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> MakeGenericStaticMethod(RuntimeMethodHandle methHandle);
    internal static FSharpFunc`2<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> MakeGenericInstanceMethod(RuntimeMethodHandle methHandle);
    internal static MethodInfo get_ImplicitExpressionConversionHelperMethodInfo();
    internal static FSharpExpr MakeImplicitExpressionConversion(FSharpExpr x);
    internal static Type get_NT();
    internal static Type get_ty@455-23();
    internal static Type get_FT1();
    internal static Type get_ty@455-24();
    internal static Type get_FT2();
    internal static Type get_ty@455-25();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Type get_boolTy();
    internal static Type get_IEnumerableTypeDef();
    internal static Type get_ty@455-26();
    internal static Type get_IQueryableTypeDef();
    internal static Type get_ty@455-27();
    internal static Type get_QuerySourceTypeDef();
    internal static Type get_ty@455-28();
    internal static bool IsQuerySourceTy(Type ty);
    internal static bool IsIQueryableTy(Type ty);
    internal static bool qTyIsIQueryable(Type ty);
    internal static FSharpExpr FuncExprToDelegateExpr(Type srcTy, Type targetTy, FSharpVar v, FSharpExpr body);
    internal static Tuple`2<FSharpFunc`2<Tuple`3<a, FSharpList`1<Type>, FSharpList`1<object>>, object>, FSharpFunc`2<Tuple`3<b, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr>> MakersCallersInstance(RuntimeMethodHandle F);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object>, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr>>, Tuple`2<FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object>, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr>>> MakersCallers2(RuntimeMethodHandle FQ, RuntimeMethodHandle FE);
    internal static object Call@469(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> CQ, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> CE, bool tupledArg0, Type tupledArg1, object tupledArg2, FSharpExpr tupledArg3);
    internal static FSharpExpr Make@462(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> MQ, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> ME, bool tupledArg0, Type tupledArg1, FSharpExpr tupledArg2, FSharpExpr tupledArg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, a, b, c>, FSharpExpr>, FSharpFunc`2<Tuple`4<bool, d, e, f>, object>> MakeOrCallContainsOrElementAt(RuntimeMethodHandle FQ, RuntimeMethodHandle FE);
    internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`4<bool, Type, object, FSharpExpr>, object>> get_patternInput@475();
    internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> get_MakeContains();
    internal static FSharpFunc`2<Tuple`4<bool, Type, object, FSharpExpr>, object> get_CallContains();
    internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`4<bool, Type, object, FSharpExpr>, object>> get_patternInput@480-1();
    internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> get_MakeElementAt();
    internal static FSharpFunc`2<Tuple`4<bool, Type, object, FSharpExpr>, object> get_CallElementAt();
    internal static object Call@498-1(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> CQ, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> CE, bool tupledArg0, Type tupledArg1, Type tupledArg2, object tupledArg3, Type tupledArg4, FSharpVar tupledArg5, FSharpExpr tupledArg6);
    internal static FSharpExpr Make@487-1(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> MQ, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> ME, bool tupledArg0, FSharpExpr tupledArg1, FSharpVar tupledArg2, FSharpExpr tupledArg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, a, FSharpVar, b>, FSharpExpr>, FSharpFunc`2<Tuple`7<bool, c, d, e, f, FSharpVar, g>, object>> MakeOrCallMinByOrMaxBy(RuntimeMethodHandle FQ, RuntimeMethodHandle FE);
    internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object>> get_patternInput@507-2();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeMinBy();
    internal static FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object> get_CallMinBy();
    internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object>> get_patternInput@512-3();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeMaxBy();
    internal static FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object> get_CallMaxBy();
    internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object>> get_patternInput@517-4();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeMinByNullable();
    internal static FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object> get_CallMinByNullable();
    internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object>> get_patternInput@523-5();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeMaxByNullable();
    internal static FSharpFunc`2<Tuple`7<bool, Type, Type, object, Type, FSharpVar, FSharpExpr>, object> get_CallMaxByNullable();
    internal static object Call@541-2(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> CQ, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> CE, bool tupledArg0, Type tupledArg1, object tupledArg2, FSharpVar tupledArg3, FSharpExpr tupledArg4);
    internal static FSharpExpr Make@531-2(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> MQ, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> ME, bool tupledArg0, FSharpExpr tupledArg1, FSharpVar tupledArg2, FSharpExpr tupledArg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, a, FSharpVar, b>, FSharpExpr>, FSharpFunc`2<Tuple`5<bool, c, d, FSharpVar, e>, object>> MakeOrCallAnyOrAllOrFirstFind(RuntimeMethodHandle FQ, RuntimeMethodHandle FE);
    internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object>> get_patternInput@550-6();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeAny();
    internal static FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object> get_CallAny();
    internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object>> get_patternInput@555-7();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeAll();
    internal static FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object> get_CallAll();
    internal static Tuple`2<FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object>> get_patternInput@560-8();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeFirstFind();
    internal static FSharpFunc`2<Tuple`5<bool, Type, object, FSharpVar, FSharpExpr>, object> get_CallFirstFind();
    [CompilerGeneratedAttribute]
internal static object Call$cont@628(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_double, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_single, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_decimal, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_int32, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_int64, FSharpFunc`2<Tuple`3<object, FSharpList`1<Type>, FSharpList`1<object>>, object> CE, FSharpVar v, Type srcItemTy, object src, Type resTyNoNullable, Type resTy, FSharpExpr res, object qb, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpExpr Make$cont@599(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> me_int32, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> me_int64, FSharpFunc`2<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> ME, FSharpVar v, FSharpExpr src, FSharpExpr res, FSharpExpr qb, Type srcItemTy, Type resTyNoNullable, FSharpExpr selector, Unit unitVar);
    internal static object Call@614-3(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> cq_double, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_double, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> cq_single, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_single, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> cq_decimal, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_decimal, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> cq_int32, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_int32, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> cq_int64, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> ce_int64, FSharpFunc`2<Tuple`3<object, FSharpList`1<Type>, FSharpList`1<object>>, object> CE, object tupledArg0, bool tupledArg1, Type tupledArg2, Type tupledArg3, object tupledArg4, Type tupledArg5, FSharpVar tupledArg6, FSharpExpr tupledArg7);
    internal static FSharpExpr Make@575-3(bool isNullable, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> mq_double, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> me_double, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> mq_single, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> me_single, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> mq_decimal, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> me_decimal, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> mq_int32, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> me_int32, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> mq_int64, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> me_int64, FSharpFunc`2<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> ME, FSharpExpr tupledArg0, bool tupledArg1, FSharpExpr tupledArg2, FSharpVar tupledArg3, FSharpExpr tupledArg4);
    internal static j failDueToUnsupportedInputTypeInSumByOrAverageBy@573(Unit unitVar0);
    internal static Tuple`2<FSharpFunc`2<Tuple`5<a, bool, b, FSharpVar, c>, FSharpExpr>, FSharpFunc`2<Tuple`8<d, bool, e, f, g, h, FSharpVar, Tuple`1<i>>, object>> MakeOrCallAverageByOrSumByGeneric(bool isNullable, RuntimeMethodHandle fq_double, RuntimeMethodHandle fq_single, RuntimeMethodHandle fq_decimal, RuntimeMethodHandle fq_int32, RuntimeMethodHandle fq_int64, RuntimeMethodHandle fe_double, RuntimeMethodHandle fe_single, RuntimeMethodHandle fe_decimal, RuntimeMethodHandle fe_int32, RuntimeMethodHandle fe_int64, RuntimeMethodHandle FE);
    internal static Tuple`2<FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object>> get_patternInput@656-9();
    internal static RuntimeMethodHandle get_FQ_double@657();
    internal static RuntimeMethodHandle get_FQ_single@658();
    internal static RuntimeMethodHandle get_FQ_decimal@659();
    internal static RuntimeMethodHandle get_FQ_int32@660();
    internal static RuntimeMethodHandle get_FQ_int64@661();
    internal static RuntimeMethodHandle get_FE_double@662();
    internal static RuntimeMethodHandle get_FE_single@663();
    internal static RuntimeMethodHandle get_FE_decimal@664();
    internal static RuntimeMethodHandle get_FE_int32@665();
    internal static RuntimeMethodHandle get_FE_int64@666();
    internal static RuntimeMethodHandle get_FE@667();
    internal static FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeAverageBy();
    internal static FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object> get_CallAverageBy();
    internal static Tuple`2<FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object>> get_patternInput@670-10();
    internal static RuntimeMethodHandle get_FQ_double@671-1();
    internal static RuntimeMethodHandle get_FQ_single@672-1();
    internal static RuntimeMethodHandle get_FQ_decimal@673-1();
    internal static RuntimeMethodHandle get_FQ_int32@674-1();
    internal static RuntimeMethodHandle get_FQ_int64@675-1();
    internal static RuntimeMethodHandle get_FE_double@676-1();
    internal static RuntimeMethodHandle get_FE_single@677-1();
    internal static RuntimeMethodHandle get_FE_decimal@678-1();
    internal static RuntimeMethodHandle get_FE_int32@679-1();
    internal static RuntimeMethodHandle get_FE_int64@680-1();
    internal static RuntimeMethodHandle get_FE@681-1();
    internal static FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeAverageByNullable();
    internal static FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object> get_CallAverageByNullable();
    internal static Tuple`2<FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object>> get_patternInput@685-11();
    internal static RuntimeMethodHandle get_FQ_double@686-2();
    internal static RuntimeMethodHandle get_FQ_single@687-2();
    internal static RuntimeMethodHandle get_FQ_decimal@688-2();
    internal static RuntimeMethodHandle get_FQ_int32@689-2();
    internal static RuntimeMethodHandle get_FQ_int64@690-2();
    internal static RuntimeMethodHandle get_FE_double@691-2();
    internal static RuntimeMethodHandle get_FE_single@692-2();
    internal static RuntimeMethodHandle get_FE_decimal@693-2();
    internal static RuntimeMethodHandle get_FE_int32@694-2();
    internal static RuntimeMethodHandle get_FE_int64@695-2();
    internal static RuntimeMethodHandle get_FE@696-2();
    internal static FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeSumBy();
    internal static FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object> get_CallSumBy();
    internal static Tuple`2<FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object>> get_patternInput@699-12();
    internal static RuntimeMethodHandle get_FQ_double@700-3();
    internal static RuntimeMethodHandle get_FQ_single@701-3();
    internal static RuntimeMethodHandle get_FQ_decimal@702-3();
    internal static RuntimeMethodHandle get_FQ_int32@703-3();
    internal static RuntimeMethodHandle get_FQ_int64@704-3();
    internal static RuntimeMethodHandle get_FE_double@705-3();
    internal static RuntimeMethodHandle get_FE_single@706-3();
    internal static RuntimeMethodHandle get_FE_decimal@707-3();
    internal static RuntimeMethodHandle get_FE_int32@708-3();
    internal static RuntimeMethodHandle get_FE_int64@709-3();
    internal static RuntimeMethodHandle get_FE@710-3();
    internal static FSharpFunc`2<Tuple`5<FSharpExpr, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeSumByNullable();
    internal static FSharpFunc`2<Tuple`8<FSharpExpr, bool, Type, Type, object, Type, FSharpVar, Tuple`1<FSharpExpr>>, object> get_CallSumByNullable();
    internal static object Call@720-4(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> CQ, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<object>>, object> CE, Tuple`3<bool, Type, e> tupledArg);
    internal static FSharpExpr Make@715-4(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> MQ, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> ME, bool tupledArg0, Type tupledArg1, FSharpExpr tupledArg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, a, b>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, c, d>, object>> MakeOrCallSimpleOp(RuntimeMethodHandle FQ, RuntimeMethodHandle FE);
    internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> get_patternInput@724-13();
    internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> get_MakeFirst();
    internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> get_CallFirst();
    internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> get_patternInput@726-14();
    internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> get_MakeFirstOrDefault();
    internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> get_CallFirstOrDefault();
    internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> get_patternInput@728-15();
    internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> get_MakeLast();
    internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> get_CallLast();
    internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> get_patternInput@730-16();
    internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> get_MakeLastOrDefault();
    internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> get_CallLastOrDefault();
    internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> get_patternInput@732-17();
    internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> get_MakeSingle();
    internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> get_CallSingle();
    internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> get_patternInput@734-18();
    internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> get_MakeSingleOrDefault();
    internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> get_CallSingleOrDefault();
    internal static Tuple`2<FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr>, FSharpFunc`2<Tuple`3<bool, Type, object>, object>> get_patternInput@736-19();
    internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> get_MakeCount();
    internal static FSharpFunc`2<Tuple`3<bool, Type, object>, object> get_CallCount();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_MakeDefaultIfEmpty();
    internal static FSharpFunc`2<Tuple`5<CanEliminate, bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeSelect();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FQ@748();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FE@749-4();
    internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> get_MakeAppend();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FQ@768-1();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FE@769-5();
    internal static FSharpFunc`2<Tuple`2<Type, FSharpExpr>, FSharpExpr> get_MakeAsQueryable();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_F@777();
    internal static FSharpFunc`2<Type, FSharpExpr> get_MakeEnumerableEmpty();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_F@782-1();
    internal static FSharpFunc`2<Tuple`7<bool, Type, FSharpExpr, FSharpVar, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeSelectMany();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FQ@791-2();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FE@792-6();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeWhere();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FQ@807-3();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FE@808-7();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, a> MakeOrderByOrThenBy(FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, a> FQ, FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, a> FE);
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeOrderBy();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeOrderByDescending();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeThenBy();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeThenByDescending();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeOrderByNullable();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeOrderByNullableDescending();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeThenByNullable();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeThenByNullableDescending();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> GenMakeSkipWhileOrTakeWhile(RuntimeMethodHandle FQ, RuntimeMethodHandle FE);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> MakeSkipOrTake(RuntimeMethodHandle FQ, RuntimeMethodHandle FE);
    internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> get_MakeSkip();
    internal static FSharpFunc`2<Tuple`4<bool, Type, FSharpExpr, FSharpExpr>, FSharpExpr> get_MakeTake();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeSkipWhile();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeTakeWhile();
    internal static FSharpFunc`2<Tuple`3<bool, Type, FSharpExpr>, FSharpExpr> get_MakeDistinct();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FQ@900-4();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FE@901-8();
    internal static FSharpFunc`2<Tuple`4<bool, FSharpExpr, FSharpVar, FSharpExpr>, FSharpExpr> get_MakeGroupBy();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FQ@909-5();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FE@910-9();
    internal static FSharpFunc`2<Tuple`8<bool, Type, Type, Type, FSharpExpr, FSharpVar, FSharpExpr, Tuple`2<FSharpVar, FSharpExpr>>, FSharpExpr> get_MakeGroupValBy();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FQ@923-6();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FE@924-10();
    internal static FSharpFunc`2<Tuple`8<bool, Type, Type, Type, Type, FSharpExpr, FSharpExpr, Tuple`7<FSharpVar, FSharpExpr, FSharpVar, FSharpExpr, FSharpVar, FSharpVar, FSharpExpr>>, FSharpExpr> get_MakeJoin();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FQ@937-7();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FE@938-11();
    internal static FSharpFunc`2<Tuple`8<bool, Type, Type, Type, Type, FSharpExpr, FSharpExpr, Tuple`7<FSharpVar, FSharpExpr, FSharpVar, FSharpExpr, FSharpVar, FSharpVar, FSharpExpr>>, FSharpExpr> get_MakeGroupJoin();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FQ@953-8();
    internal static FSharpFunc`2<Tuple`2<FSharpList`1<Type>, FSharpList`1<FSharpExpr>>, FSharpExpr> get_FE@954-12();
    internal static FSharpExpr walk@968-1(FSharpFunc`2<FSharpFunc`2<a, FSharpExpr>, FSharpFunc`2<FSharpExpr, FSharpOption`1<FSharpExpr>>> f, FSharpExpr p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr RewriteExpr(FSharpFunc`2<FSharpFunc`2<a, FSharpExpr>, FSharpFunc`2<FSharpExpr, FSharpOption`1<FSharpExpr>>> f, FSharpExpr q);
    internal static FSharpOption`1<FSharpExpr> |LetExprReduction|_|(FSharpExpr p);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FSharpExpr> |MacroReduction|_|$cont@988-1(FSharpExpr p, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FSharpExpr> |MacroReduction|_|$cont@988(FSharpExpr p, Unit unitVar);
    internal static FSharpOption`1<FSharpExpr> |MacroReduction|_|(FSharpExpr p);
    internal static FSharpExpr MacroExpand(FSharpExpr q);
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CallQueryBuilderRunQueryable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CallQueryBuilderRunValue|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CallQueryBuilderRunEnumerable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CallQueryBuilderFor|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallQueryBuilderYield|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CallQueryBuilderYieldFrom|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CallQueryBuilderZero|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallQueryBuilderSourceIQueryable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallQueryBuilderSourceIEnumerable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallSortBy|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallSortByDescending|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallThenBy|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallThenByDescending|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallSortByNullable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallSortByNullableDescending|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallThenByNullable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallThenByNullableDescending|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallGroupBy|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`5<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr, FSharpExpr>>> get_|CallGroupValBy|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallMinBy|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallMaxBy|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallMinByNullable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallMaxByNullable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallWhere|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallHeadOrDefault|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallLast|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallLastOrDefault|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallExactlyOne|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallExactlyOneOrDefault|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallSelect|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallExists|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallForAll|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallDistinct|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallTake|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallTakeWhile|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallContains|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallNth|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallSkip|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallSkipWhile|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CallJoin|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CallGroupJoin|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CallLeftOuterJoin|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallAverageBy|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallSumBy|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallAverageByNullable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallSumByNullable|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallCount|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<Type>, FSharpExpr>>> get_|CallHead|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`4<FSharpExpr, FSharpList`1<Type>, FSharpExpr, FSharpExpr>>> get_|CallFind|_|();
    internal static FSharpOption`1<Unit> |ZeroOnElseBranch|_|(FSharpExpr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr ConvMutableToImmutable(ConversionDescription conv, FSharpExpr mutExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpVar, FSharpExpr> ConvertImmutableConsumerToMutableConsumer(ConversionDescription conv, FSharpVar immutConsumingVar, FSharpExpr immutConsumingExpr);
    internal static FSharpOption`1<FSharpExpr> |AnyNestedQuery|_|(FSharpExpr e);
    internal static FSharpOption`1<FSharpExpr> |EnumerableNestedQuery|_|(FSharpExpr e);
    internal static FSharpExpr CommitTransInnerResult(TransInnerResult c);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TransInnerResult, ConversionDescription> TransInner$cont@1274-4(bool check, FSharpExpr immutQuery, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TransInnerResult, ConversionDescription> TransInner$cont@1274-3(bool check, FSharpExpr immutQuery, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TransInnerResult, ConversionDescription> TransInner$cont@1274-2(bool check, FSharpExpr immutQuery, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TransInnerResult, ConversionDescription> TransInner$cont@1528-1(bool check, Type qTy, FSharpExpr immutOuterSource, FSharpVar immutOuterResultGroupVar, FSharpVar immutOuterKeyVar, FSharpExpr immutOuterKeySelector, Type immutInnerSourceTy, FSharpExpr immutInnerSource, FSharpVar immutInnerResultGroupVar, FSharpVar immutInnerKeyVar, FSharpExpr immutInnerKeySelector, FSharpExpr immutElementSelector, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TransInnerResult, ConversionDescription> TransInner$cont@1501(bool check, Type qTy, FSharpExpr immutOuterSource, FSharpVar immutOuterResultGroupVar, FSharpVar immutOuterKeyVar, FSharpExpr immutOuterKeySelector, FSharpExpr immutInnerSource, FSharpVar immutInnerResultGroupVar, FSharpVar immutInnerKeyVar, FSharpExpr immutInnerKeySelector, FSharpExpr immutElementSelector, Unit unitVar);
    internal static Tuple`2<TransInnerResult, ConversionDescription> TransFor@1294(CanEliminate canElim, bool check, Type qTy, FSharpVar immutSelectorVar, Type immutResElemTy, ConversionDescription sourceConv, TransInnerResult mutSource, FSharpExpr immutSelector);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TransInnerResult, ConversionDescription> TransInner(CanEliminate canElim, bool check, FSharpExpr immutQuery);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpExpr, ConversionDescription> TransInnerAndCommit(CanEliminate canElim, bool check, FSharpExpr x);
    internal static Tuple`2<FSharpExpr, ConversionDescription> TransInnerNoCheck(FSharpExpr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<FSharpExpr, ConversionDescription, FSharpExpr, ConversionDescription, FSharpVar, FSharpExpr, FSharpVar, Tuple`1<FSharpExpr>> TransJoinInputs(bool check, FSharpExpr immutOuterSource, FSharpExpr immutInnerSource, FSharpVar immutOuterKeyVar, FSharpExpr immutOuterKeySelector, FSharpVar immutInnerKeyVar, FSharpExpr immutInnerKeySelector);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<TransInnerResult, ConversionDescription, FSharpVar, FSharpExpr> TransInnerApplicative(bool check, FSharpExpr source, FSharpVar immutConsumingVar, FSharpExpr immutConsumingExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpExpr, ConversionDescription, FSharpVar, FSharpExpr> TransInnerApplicativeAndCommit(bool check, FSharpExpr source, FSharpVar immutConsumingVar, FSharpExpr immutConsumingExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr TransInnerWithFinalConsume(CanEliminate canElim, FSharpExpr immutSource);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpExpr, FSharpVar, FSharpExpr> TransNestedInnerWithConsumer(FSharpExpr immutSource, FSharpVar immutConsumingVar, FSharpExpr immutConsumingExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr TransNestedOuter(CanEliminate canElim, FSharpExpr quot);
    internal static FSharpExpr EliminateNestedQueries(FSharpExpr q);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object EvalNonNestedInner(CanEliminate canElim, FSharpExpr queryProducingSequence);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object EvalNonNestedOuter(CanEliminate canElim, FSharpExpr tm);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Linq.QueryRunExtensions.HighPriority : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("Run")]
public static IEnumerable`1<T> RunQueryAsEnumerable(QueryBuilder this, FSharpExpr`1<QuerySource`2<T, IEnumerable>> q);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Linq.QueryRunExtensions.LowPriority : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("Run")]
public static T RunQueryAsValue(QueryBuilder this, FSharpExpr`1<T> q);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.QuerySource`2 : object {
    internal IEnumerable`1<T> source;
    public IEnumerable`1<T> Source { get; }
    public QuerySource`2(IEnumerable`1<T> source);
    public IEnumerable`1<T> get_Source();
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Linq.RuntimeHelpers.Adapters : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Type, bool> isPartiallyImmutableRecord { get; }
    [CompilationMappingAttribute("9")]
internal static MethodInfo MemberInitializationHelperMeth { get; }
    [CompilationMappingAttribute("9")]
internal static MethodInfo NewAnonymousObjectHelperMeth { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2[] tupleTypes { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-7 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-8 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-9 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-10 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-11 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-12 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-13 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-14 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-15 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-16 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-17 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-18 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-19 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-20 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-21 { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-22 { get; }
    [CompilationMappingAttribute("9")]
internal static Type[] anonObjectTypes { get; }
    [CompilationMappingAttribute("9")]
internal static Type[] res@261 { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<Type, Type> tupleToAnonTypeMap { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<Type, Type> t@104 { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<Type, Type> anonToTupleTypeMap { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<Type, Type> t@109-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, bool> IsNewAnonymousObjectHelperQ { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@218-109 { get; }
    [CompilationMappingAttribute("9")]
internal static MethodInfo minfo@219 { get; }
    [CompilationMappingAttribute("9")]
internal static MethodInfo gmd@220 { get; }
    internal static FSharpFunc`2<Type, b> memoize(FSharpFunc`2<Type, b> f);
    internal static FSharpFunc`2<Type, bool> get_isPartiallyImmutableRecord();
    internal static MethodInfo get_MemberInitializationHelperMeth();
    internal static MethodInfo get_NewAnonymousObjectHelperMeth();
    internal static FSharpList`1<FSharpExpr> leftSequentialSeries@59(FSharpList`1<FSharpExpr> acc, FSharpExpr e);
    internal static FSharpList`1<FSharpExpr> |LeftSequentialSeries|(FSharpExpr e);
    internal static FSharpOption`1<FSharpList`1<a>> propSetList@69(FSharpVar varArg, FSharpList`1<a> acc, FSharpList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<FSharpExpr>> |PropSetList|_|(FSharpVar varArg, FSharpList`1<FSharpExpr> list);
    internal static FSharpOption`1<Tuple`3<FSharpVar, FSharpExpr, FSharpList`1<FSharpExpr>>> |ObjectConstruction|_|(FSharpExpr e);
    internal static Tuple`2[] get_tupleTypes();
    internal static Type get_ty@455-7();
    internal static Type get_ty@455-8();
    internal static Type get_ty@455-9();
    internal static Type get_ty@455-10();
    internal static Type get_ty@455-11();
    internal static Type get_ty@455-12();
    internal static Type get_ty@455-13();
    internal static Type get_ty@455-14();
    internal static Type get_ty@455-15();
    internal static Type get_ty@455-16();
    internal static Type get_ty@455-17();
    internal static Type get_ty@455-18();
    internal static Type get_ty@455-19();
    internal static Type get_ty@455-20();
    internal static Type get_ty@455-21();
    internal static Type get_ty@455-22();
    internal static Type[] get_anonObjectTypes();
    internal static Type[] get_res@261();
    internal static Dictionary`2<Type, Type> get_tupleToAnonTypeMap();
    internal static Dictionary`2<Type, Type> get_t@104();
    internal static Dictionary`2<Type, Type> get_anonToTupleTypeMap();
    internal static Dictionary`2<Type, Type> get_t@109-1();
    internal static FSharpOption`1<Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>> |NewAnonymousObject|_|(FSharpExpr e);
    internal static FSharpExpr OneNewAnonymousObject(FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr NewAnonymousObject(FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr walk@143(int i, FSharpExpr inst, Type newType);
    internal static FSharpExpr AnonymousObjectGet(FSharpExpr e, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type RewriteTupleType(Type ty, FSharpFunc`2<FSharpList`1<Type>, FSharpList`1<Type>> conv);
    internal static FSharpOption`1<FSharpExpr> |RecordFieldGetSimplification|_|(FSharpExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type ConvImmutableTypeToMutableType(ConversionDescription conv, Type ty);
    internal static FSharpFunc`2<FSharpExpr, bool> get_IsNewAnonymousObjectHelperQ();
    internal static RuntimeMethodHandle get_mhandle@218-109();
    internal static MethodInfo get_minfo@219();
    internal static MethodInfo get_gmd@220();
    internal static FSharpExpr CleanupLeaf(FSharpExpr expr);
    internal static FSharpExpr SimplifyConsumingExpr(FSharpExpr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpExpr, ConversionDescription> ProduceMoreMutables(FSharpFunc`2<FSharpExpr, Tuple`2<FSharpExpr, ConversionDescription>> tipf, FSharpExpr expr);
    internal static ConversionDescription MakeSeqConv(ConversionDescription conv);
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`1 : object {
    internal T1 item1@;
    [CompilationMappingAttribute("4", "0")]
internal T1 item1 { get; }
    public T1 Item1 { get; }
    public AnonymousObject`1(T1 Item1);
    internal T1 get_item1();
    public T1 get_Item1();
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`2 : object {
    internal T1 item1@;
    internal T2 item2@;
    [CompilationMappingAttribute("4", "0")]
internal T1 item1 { get; }
    [CompilationMappingAttribute("4", "1")]
internal T2 item2 { get; }
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public AnonymousObject`2(T1 Item1, T2 Item2);
    internal T1 get_item1();
    internal T2 get_item2();
    public T1 get_Item1();
    public T2 get_Item2();
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`3 : object {
    internal T1 item1@;
    internal T2 item2@;
    internal T3 item3@;
    [CompilationMappingAttribute("4", "0")]
internal T1 item1 { get; }
    [CompilationMappingAttribute("4", "1")]
internal T2 item2 { get; }
    [CompilationMappingAttribute("4", "2")]
internal T3 item3 { get; }
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public AnonymousObject`3(T1 Item1, T2 Item2, T3 Item3);
    internal T1 get_item1();
    internal T2 get_item2();
    internal T3 get_item3();
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`4 : object {
    internal T1 item1@;
    internal T2 item2@;
    internal T3 item3@;
    internal T4 item4@;
    [CompilationMappingAttribute("4", "0")]
internal T1 item1 { get; }
    [CompilationMappingAttribute("4", "1")]
internal T2 item2 { get; }
    [CompilationMappingAttribute("4", "2")]
internal T3 item3 { get; }
    [CompilationMappingAttribute("4", "3")]
internal T4 item4 { get; }
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public AnonymousObject`4(T1 Item1, T2 Item2, T3 Item3, T4 Item4);
    internal T1 get_item1();
    internal T2 get_item2();
    internal T3 get_item3();
    internal T4 get_item4();
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`5 : object {
    internal T1 item1@;
    internal T2 item2@;
    internal T3 item3@;
    internal T4 item4@;
    internal T5 item5@;
    [CompilationMappingAttribute("4", "0")]
internal T1 item1 { get; }
    [CompilationMappingAttribute("4", "1")]
internal T2 item2 { get; }
    [CompilationMappingAttribute("4", "2")]
internal T3 item3 { get; }
    [CompilationMappingAttribute("4", "3")]
internal T4 item4 { get; }
    [CompilationMappingAttribute("4", "4")]
internal T5 item5 { get; }
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public AnonymousObject`5(T1 Item1, T2 Item2, T3 Item3, T4 Item4, T5 Item5);
    internal T1 get_item1();
    internal T2 get_item2();
    internal T3 get_item3();
    internal T4 get_item4();
    internal T5 get_item5();
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`6 : object {
    internal T1 item1@;
    internal T2 item2@;
    internal T3 item3@;
    internal T4 item4@;
    internal T5 item5@;
    internal T6 item6@;
    [CompilationMappingAttribute("4", "0")]
internal T1 item1 { get; }
    [CompilationMappingAttribute("4", "1")]
internal T2 item2 { get; }
    [CompilationMappingAttribute("4", "2")]
internal T3 item3 { get; }
    [CompilationMappingAttribute("4", "3")]
internal T4 item4 { get; }
    [CompilationMappingAttribute("4", "4")]
internal T5 item5 { get; }
    [CompilationMappingAttribute("4", "5")]
internal T6 item6 { get; }
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public AnonymousObject`6(T1 Item1, T2 Item2, T3 Item3, T4 Item4, T5 Item5, T6 Item6);
    internal T1 get_item1();
    internal T2 get_item2();
    internal T3 get_item3();
    internal T4 get_item4();
    internal T5 get_item5();
    internal T6 get_item6();
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`7 : object {
    internal T1 item1@;
    internal T2 item2@;
    internal T3 item3@;
    internal T4 item4@;
    internal T5 item5@;
    internal T6 item6@;
    internal T7 item7@;
    [CompilationMappingAttribute("4", "0")]
internal T1 item1 { get; }
    [CompilationMappingAttribute("4", "1")]
internal T2 item2 { get; }
    [CompilationMappingAttribute("4", "2")]
internal T3 item3 { get; }
    [CompilationMappingAttribute("4", "3")]
internal T4 item4 { get; }
    [CompilationMappingAttribute("4", "4")]
internal T5 item5 { get; }
    [CompilationMappingAttribute("4", "5")]
internal T6 item6 { get; }
    [CompilationMappingAttribute("4", "6")]
internal T7 item7 { get; }
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public AnonymousObject`7(T1 Item1, T2 Item2, T3 Item3, T4 Item4, T5 Item5, T6 Item6, T7 Item7);
    internal T1 get_item1();
    internal T2 get_item2();
    internal T3 get_item3();
    internal T4 get_item4();
    internal T5 get_item5();
    internal T6 get_item6();
    internal T7 get_item7();
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`8 : object {
    internal T1 item1@;
    internal T2 item2@;
    internal T3 item3@;
    internal T4 item4@;
    internal T5 item5@;
    internal T6 item6@;
    internal T7 item7@;
    internal T8 item8@;
    [CompilationMappingAttribute("4", "0")]
internal T1 item1 { get; }
    [CompilationMappingAttribute("4", "1")]
internal T2 item2 { get; }
    [CompilationMappingAttribute("4", "2")]
internal T3 item3 { get; }
    [CompilationMappingAttribute("4", "3")]
internal T4 item4 { get; }
    [CompilationMappingAttribute("4", "4")]
internal T5 item5 { get; }
    [CompilationMappingAttribute("4", "5")]
internal T6 item6 { get; }
    [CompilationMappingAttribute("4", "6")]
internal T7 item7 { get; }
    [CompilationMappingAttribute("4", "7")]
internal T8 item8 { get; }
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public T8 Item8 { get; }
    public AnonymousObject`8(T1 Item1, T2 Item2, T3 Item3, T4 Item4, T5 Item5, T6 Item6, T7 Item7, T8 Item8);
    internal T1 get_item1();
    internal T2 get_item2();
    internal T3 get_item3();
    internal T4 get_item4();
    internal T5 get_item5();
    internal T6 get_item6();
    internal T7 get_item7();
    internal T8 get_item8();
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public T8 get_Item8();
}
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Linq.RuntimeHelpers.Grouping`2 : object {
    internal IEnumerable`1<T> values;
    internal K key;
    public Grouping`2(K key, IEnumerable`1<T> values);
    private virtual override K System.Linq.IGrouping<'K, 'T>.get_Key();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
}
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter : object {
    internal static BindingFlags bindingFlags { get; }
    internal static BindingFlags instanceBindingFlags { get; }
    [CompilationMappingAttribute("9")]
internal static MethodInfo StringConcat { get; }
    internal static BindingFlags showAll { get; }
    [CompilationMappingAttribute("9")]
internal static ConstructorInfo NullableConstructor { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-6 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |GenericEqualityQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |EqualsQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |GreaterQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |GreaterEqQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-3 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |LessQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-4 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |LessEqQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-5 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NotEqQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-6 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |StaticEqualsQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-7 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |StaticGreaterQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-8 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |StaticGreaterEqQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-9 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |StaticLessQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-10 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |StaticLessEqQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-11 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |StaticNotEqQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-12 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableEqualsQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-13 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableNotEqQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-14 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableGreaterQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-15 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableGreaterEqQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-16 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableLessQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-17 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableLessEqQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-18 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableEqualsNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-19 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableNotEqNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-20 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableGreaterNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-21 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableGreaterEqNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-22 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableLessNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-23 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableLessEqNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-24 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |EqualsNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-25 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NotEqNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-26 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |GreaterNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-27 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |GreaterEqNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-28 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |LessNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-29 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |LessEqNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-30 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |MakeDecimalQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-31 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullablePlusQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-32 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullablePlusNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-33 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |PlusNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-34 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableMinusQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-35 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableMinusNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-36 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |MinusNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-37 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableMultiplyQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-38 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableMultiplyNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-39 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |MultiplyNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-40 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableDivideQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-41 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableDivideNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-42 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |DivideNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-43 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableModuloQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-44 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NullableModuloNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-45 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ModuloNullableQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-46 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NotQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-47 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NegQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-48 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |PlusQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-49 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |DivideQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-50 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |MinusQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-51 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |MultiplyQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-52 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ModuloQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-53 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ShiftLeftQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-54 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ShiftRightQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-55 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |BitwiseAndQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-56 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |BitwiseOrQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-57 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |BitwiseXorQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-58 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |BitwiseNotQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-59 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedNeg|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-60 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedPlusQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-61 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedMinusQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-62 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedMultiplyQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-63 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvCharQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-64 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvDecimalQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-65 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvFloatQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-66 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvFloat32Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-67 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvSByteQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-68 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvInt16Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-69 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvInt32Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-70 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvIntQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-71 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvInt64Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-72 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvByteQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-73 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvUInt16Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-74 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvUInt32Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-75 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvUInt64Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-76 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvInt8Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvUInt8Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvDoubleQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvSingleQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableCharQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-77 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableDecimalQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-78 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableFloatQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-79 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableDoubleQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-80 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableFloat32Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-81 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableSingleQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-82 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableSByteQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-83 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableInt8Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-84 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableInt16Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-85 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableInt32Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-86 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableIntQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-87 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableInt64Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-88 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableByteQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-89 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableUInt8Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-90 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableUInt16Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-91 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableUInt32Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-92 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ConvNullableUInt64Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-93 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |UnboxGeneric|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-94 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |TypeTestGeneric|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-95 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvCharQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-96 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvSByteQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-97 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvInt8Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvUInt8Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvInt16Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-98 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvInt32Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-99 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvInt64Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-100 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvByteQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-101 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvUInt16Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-102 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvUInt32Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-103 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |CheckedConvUInt64Q|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-104 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ImplicitExpressionConversionHelperQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-105 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |MemberInitializationHelperQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-106 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |NewAnonymousObjectHelperQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-107 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |ArrayLookupQ|_| { get; }
    [CompilationMappingAttribute("9")]
internal static RuntimeMethodHandle mhandle@94-108 { get; }
    [CompilationMappingAttribute("9")]
internal static MethodInfo substHelperMeth { get; }
    [CompilationMappingAttribute("9")]
internal static MethodInfo substHelperRawMeth { get; }
    public static T MemberInitializationHelper(T _x);
    public static T NewAnonymousObjectHelper(T _x);
    public static Expression`1<T> ImplicitExpressionConversionHelper(T _x);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_bindingFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_instanceBindingFlags();
    internal static bool isNamedType(Type typ);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equivHeadTypes(Type ty1, Type ty2);
    internal static Tuple`2<Type, Type> getFunctionType(Type typ);
    internal static MethodInfo get_StringConcat();
    public static FSharpExpr SubstHelperRaw(FSharpExpr q, FSharpVar[] x, Object[] y);
    public static FSharpExpr`1<T> SubstHelper(FSharpExpr q, FSharpVar[] x, Object[] y);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_showAll();
    internal static ConstructorInfo get_NullableConstructor();
    internal static Type get_ty@455-6();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> SpecificCallToMethodInfo(MethodInfo minfo);
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> |SpecificCallToMethod|_|(RuntimeMethodHandle mhandle);
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|GenericEqualityQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|EqualsQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-1();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|GreaterQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-2();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|GreaterEqQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-3();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|LessQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-4();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|LessEqQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-5();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NotEqQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-6();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|StaticEqualsQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-7();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|StaticGreaterQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-8();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|StaticGreaterEqQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-9();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|StaticLessQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-10();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|StaticLessEqQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-11();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|StaticNotEqQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-12();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableEqualsQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-13();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableNotEqQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-14();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableGreaterQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-15();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableGreaterEqQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-16();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableLessQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-17();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableLessEqQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-18();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableEqualsNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-19();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableNotEqNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-20();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableGreaterNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-21();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableGreaterEqNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-22();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableLessNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-23();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableLessEqNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-24();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|EqualsNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-25();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NotEqNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-26();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|GreaterNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-27();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|GreaterEqNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-28();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|LessNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-29();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|LessEqNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-30();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|MakeDecimalQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-31();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullablePlusQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-32();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullablePlusNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-33();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|PlusNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-34();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableMinusQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-35();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableMinusNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-36();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|MinusNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-37();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableMultiplyQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-38();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableMultiplyNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-39();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|MultiplyNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-40();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableDivideQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-41();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableDivideNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-42();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|DivideNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-43();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableModuloQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-44();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NullableModuloNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-45();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ModuloNullableQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-46();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NotQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-47();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NegQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-48();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|PlusQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-49();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|DivideQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-50();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|MinusQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-51();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|MultiplyQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-52();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ModuloQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-53();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ShiftLeftQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-54();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ShiftRightQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-55();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|BitwiseAndQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-56();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|BitwiseOrQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-57();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|BitwiseXorQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-58();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|BitwiseNotQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-59();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedNeg|_|();
    internal static RuntimeMethodHandle get_mhandle@94-60();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedPlusQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-61();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedMinusQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-62();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedMultiplyQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-63();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvCharQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-64();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvDecimalQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-65();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvFloatQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-66();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvFloat32Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-67();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvSByteQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-68();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvInt16Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-69();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvInt32Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-70();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvIntQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-71();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvInt64Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-72();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvByteQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-73();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvUInt16Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-74();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvUInt32Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-75();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvUInt64Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-76();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvInt8Q|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvUInt8Q|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvDoubleQ|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvSingleQ|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableCharQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-77();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableDecimalQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-78();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableFloatQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-79();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableDoubleQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-80();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableFloat32Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-81();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableSingleQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-82();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableSByteQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-83();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableInt8Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-84();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableInt16Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-85();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableInt32Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-86();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableIntQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-87();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableInt64Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-88();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableByteQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-89();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableUInt8Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-90();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableUInt16Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-91();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableUInt32Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-92();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ConvNullableUInt64Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-93();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|UnboxGeneric|_|();
    internal static RuntimeMethodHandle get_mhandle@94-94();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|TypeTestGeneric|_|();
    internal static RuntimeMethodHandle get_mhandle@94-95();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvCharQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-96();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvSByteQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-97();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvInt8Q|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvUInt8Q|_|();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvInt16Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-98();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvInt32Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-99();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvInt64Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-100();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvByteQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-101();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvUInt16Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-102();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvUInt32Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-103();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|CheckedConvUInt64Q|_|();
    internal static RuntimeMethodHandle get_mhandle@94-104();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ImplicitExpressionConversionHelperQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-105();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|MemberInitializationHelperQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-106();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|NewAnonymousObjectHelperQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-107();
    internal static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> get_|ArrayLookupQ|_|();
    internal static RuntimeMethodHandle get_mhandle@94-108();
    internal static MethodInfo get_substHelperMeth();
    internal static MethodInfo get_substHelperRawMeth();
    internal static Tuple`2<FSharpList`1<FSharpExpr>, FSharpExpr> |Sequentials|(FSharpExpr _arg1);
    internal static FSharpOption`1<Tuple`2<FSharpExpr, FSharpList`1<FSharpExpr>>> |MemberInitializationQ|_|(FSharpExpr _arg1);
    internal static FSharpOption`1<Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>> |NewAnonymousObjectQ|_|(FSharpExpr _arg1);
    internal static FSharpOption`1<FSharpExpr> |NullableConstruction|_|(FSharpExpr _arg1);
    internal static Expression build@610-1(Type ty, Expression[] argsP);
    internal static Expression build@311(Type ty, Expression argP, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expression ConvExprToLinqInContext(ConvEnv env, FSharpExpr inp);
    internal static Expression failConvert(FSharpExpr inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expression transBinOp(FSharpExpr inp, ConvEnv env, bool addConvertLeft, FSharpList`1<FSharpExpr> args, bool addConvertRight, FSharpFunc`2<Tuple`2<Expression, Expression>, BinaryExpression> exprErasedConstructor);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expression ConvObjArg(ConvEnv env, FSharpOption`1<FSharpExpr> objOpt, FSharpOption`1<Type> coerceTo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expression[] ConvExprsToLinq(ConvEnv env, FSharpList`1<FSharpExpr> es);
    internal static ParameterExpression ConvVarToLinq(FSharpVar v);
    public static Expression QuotationToExpression(FSharpExpr e);
    public static Expression`1<T> QuotationToLambdaExpression(FSharpExpr`1<T> e);
    public static object EvaluateQuotation(FSharpExpr e);
}
[RequireQualifiedAccessAttribute]
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.NativeInterop.NativePtrModule : object {
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationSourceNameAttribute("ofNativeInt")]
public static IntPtr OfNativeIntInlined(IntPtr address);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationSourceNameAttribute("toNativeInt")]
public static IntPtr ToNativeIntInlined(IntPtr address);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationSourceNameAttribute("toVoidPtr")]
public static Void* ToVoidPtrInlined(IntPtr address);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationSourceNameAttribute("ofVoidPtr")]
public static IntPtr OfVoidPtrInlined(Void* address);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("add")]
public static IntPtr AddPointerInlined(IntPtr address, int index);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("get")]
public static T GetPointerInlined(IntPtr address, int index);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("set")]
public static void SetPointerInlined(IntPtr address, int index, T value);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationSourceNameAttribute("read")]
public static T ReadPointerInlined(IntPtr address);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("write")]
public static void WritePointerInlined(IntPtr address, T value);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationSourceNameAttribute("stackalloc")]
public static IntPtr StackAllocate(int count);
    [UnverifiableAttribute]
[NoDynamicInvocationAttribute]
[CompilationSourceNameAttribute("toByRef")]
public static T& ToByRefInlined(IntPtr address);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Primitives.Basics.Array : object {
    internal static T[] zeroCreateUnchecked(int count);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T[] init(int count, FSharpFunc`2<int, T> f);
    internal static T loop@1007-17(FSharpFunc`2<T, bool> predicate, T[] array, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T findBack(FSharpFunc`2<T, bool> predicate, T[] array);
    internal static FSharpOption`1<T> loop@1014-18(FSharpFunc`2<T, bool> predicate, T[] array, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<T> tryFindBack(FSharpFunc`2<T, bool> predicate, T[] array);
    internal static int loop@1021-19(FSharpFunc`2<T, bool> predicate, T[] array, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int findIndexBack(FSharpFunc`2<T, bool> predicate, T[] array);
    internal static FSharpOption`1<int> loop@1028-20(FSharpFunc`2<T, bool> predicate, T[] array, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<int> tryFindIndexBack(FSharpFunc`2<T, bool> predicate, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T[] permute(FSharpFunc`2<int, int> indexMap, T[] arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TResult[], TState> mapFold(FSharpFunc`2<TState, FSharpFunc`2<T, Tuple`2<TResult, TState>>> f, TState acc, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TResult[], TState> mapFoldBack(FSharpFunc`2<T, FSharpFunc`2<TState, Tuple`2<TResult, TState>>> f, T[] array, TState acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TState[] scanSubRight(FSharpFunc`2<T, FSharpFunc`2<TState, TState>> f, T[] array, int start, int fin, TState initState);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void unstableSortInPlaceBy(FSharpFunc`2<T, TKey> projection, T[] array);
    internal static void unstableSortInPlace(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void stableSortWithKeysAndComparer(IComparer`1<TKey> cFast, IComparer`1<TKey> c, T[] array, TKey[] keys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void stableSortInPlaceBy(FSharpFunc`2<T, TKey> projection, T[] array);
    internal static void stableSortInPlace(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void stableSortInPlaceWith(FSharpFunc`2<T, FSharpFunc`2<T, int>> comparer, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T[] subUnchecked(int startIndex, int count, T[] array);
    [CompilerGeneratedAttribute]
internal static T[][] splitInto$cont@1174(int count, T[] array, int len, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T[][] splitInto(int count, T[] array);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Primitives.Basics.List : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void distinctToFreshConsTail(FSharpList`1<a> cons, HashSet`1<a> hashSet, FSharpList`1<a> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> distinctWithComparer(IEqualityComparer`1<T> comparer, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void distinctByToFreshConsTail(FSharpList`1<a> cons, HashSet`1<b> hashSet, FSharpFunc`2<a, b> keyf, FSharpList`1<a> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> distinctByWithComparer(IEqualityComparer`1<TKey> comparer, FSharpFunc`2<T, TKey> keyf, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<T2, int>> countBy(Dictionary`2<T1, int> dict, FSharpFunc`2<T1, T2> keyf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pairwiseToFreshConsTail(FSharpList`1<Tuple`2<a, a>> cons, FSharpList`1<a> list, a lastvalue);
    internal static FSharpList`1<Tuple`2<T, T>> pairwise(FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void chooseToFreshConsTail(FSharpList`1<a> cons, FSharpFunc`2<b, FSharpOption`1<a>> f, FSharpList`1<b> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TResult> choose(FSharpFunc`2<T, FSharpOption`1<TResult>> f, FSharpList`1<T> xs);
    internal static void loop@204-15(FSharpFunc`2<T, TSafeKey> keyf, Dictionary`2<TSafeKey, FSharpList`1[]> dict, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TKey, FSharpList`1<T>>> groupBy(IEqualityComparer`1<TSafeKey> comparer, FSharpFunc`2<T, TSafeKey> keyf, FSharpFunc`2<TSafeKey, TKey> getKey, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void mapToFreshConsTail(FSharpList`1<a> cons, FSharpFunc`2<b, a> f, FSharpList`1<b> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TResult> map(FSharpFunc`2<T, TResult> mapping, FSharpList`1<T> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void mapiToFreshConsTail(FSharpList`1<a> cons, FSharpFunc`3<int, b, a> f, FSharpList`1<b> x, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TResult> mapi(FSharpFunc`2<int, FSharpFunc`2<T, TResult>> f, FSharpList`1<T> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void map2ToFreshConsTail(FSharpList`1<a> cons, FSharpFunc`3<b, c, a> f, FSharpList`1<b> xs1, FSharpList`1<c> xs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TResult> map2(FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>> mapping, FSharpList`1<T1> xs1, FSharpList`1<T2> xs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void map3ToFreshConsTail(FSharpList`1<a> cons, FSharpFunc`4<b, c, d, a> f, FSharpList`1<b> xs1, FSharpList`1<c> xs2, FSharpList`1<d> xs3, int cut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TResult> map3(FSharpFunc`2<T1, FSharpFunc`2<T2, FSharpFunc`2<T3, TResult>>> mapping, FSharpList`1<T1> xs1, FSharpList`1<T2> xs2, FSharpList`1<T3> xs3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void mapi2ToFreshConsTail(int n, FSharpList`1<a> cons, FSharpFunc`4<int, b, c, a> f, FSharpList`1<b> xs1, FSharpList`1<c> xs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TResult> mapi2(FSharpFunc`2<int, FSharpFunc`2<T1, FSharpFunc`2<T2, TResult>>> f, FSharpList`1<T1> xs1, FSharpList`1<T2> xs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void scanToFreshConsTail(FSharpList`1<a> cons, FSharpList`1<b> xs, a s, FSharpFunc`3<a, b, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TState> scan(FSharpFunc`2<TState, FSharpFunc`2<T, TState>> f, TState s, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void indexedToFreshConsTail(FSharpList`1<Tuple`2<int, a>> cons, FSharpList`1<a> xs, int i);
    internal static FSharpList`1<Tuple`2<int, T>> indexed(FSharpList`1<T> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TState mapFoldToFreshConsTail(FSharpList`1<TResult> cons, FSharpFunc`3<TState, T, Tuple`2<TResult, TState>> f, TState acc, FSharpList`1<T> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TResult>, TState> mapFold(FSharpFunc`2<TState, FSharpFunc`2<T, Tuple`2<TResult, TState>>> f, TState acc, FSharpList`1<T> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> revAcc(FSharpList`1<a> xs, FSharpList`1<a> acc);
    internal static FSharpList`1<T> rev(FSharpList`1<T> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> appendToFreshConsTail(FSharpList`1<a> cons, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void collectToFreshConsTail(FSharpFunc`2<T, FSharpList`1<TResult>> f, FSharpList`1<T> list, FSharpList`1<TResult> cons);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TResult> collect(FSharpFunc`2<T, FSharpList`1<TResult>> f, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<a, b>> allPairsToFreshConsTailSingle(a x, FSharpList`1<b> ys, FSharpList`1<Tuple`2<a, b>> cons);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void allPairsToFreshConsTail(FSharpList`1<a> xs, FSharpList`1<b> ys, FSharpList`1<Tuple`2<a, b>> cons);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<T1, T2>> allPairs(FSharpList`1<T1> xs, FSharpList`1<T2> ys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void filterToFreshConsTail(FSharpList`1<a> cons, FSharpFunc`2<a, bool> f, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> filter(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void concatToFreshConsTail(FSharpList`1<a> cons, FSharpList`1<a> h1, FSharpList`1<FSharpList`1<a>> l);
    internal static FSharpList`1<a> concatToEmpty(FSharpList`1<FSharpList`1<a>> l);
    internal static void loop@521-16(T[] res, int i, FSharpList`1<T> l);
    internal static T[] toArray(FSharpList`1<T> l);
    internal static FSharpList`1<T> ofArray(T[] arr);
    internal static FSharpList`1<T> ofSeq(IEnumerable`1<T> e);
    internal static FSharpList`1<T> concat(IEnumerable`1<FSharpList`1<T>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void initToFreshConsTail(FSharpList`1<a> cons, int i, int n, FSharpFunc`2<int, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> init(int count, FSharpFunc`2<int, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void takeFreshConsTail(FSharpList`1<a> cons, int n, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> take(int n, FSharpList`1<T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> splitAtFreshConsTail(FSharpList`1<a> cons, int index, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<T>, FSharpList`1<T>> splitAt(int index, FSharpList`1<T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void partitionToFreshConsTails(FSharpList`1<a> consL, FSharpList`1<a> consR, FSharpFunc`2<a, bool> p, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> partitionToFreshConsTailLeft(FSharpList`1<a> consL, FSharpFunc`2<a, bool> p, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> partitionToFreshConsTailRight(FSharpList`1<a> consR, FSharpFunc`2<a, bool> p, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<T>, FSharpList`1<T>> partition(FSharpFunc`2<T, bool> predicate, FSharpList`1<T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int transposeGetHeadsFreshConsTail(FSharpList`1<a> headsCons, FSharpList`1<FSharpList`1<a>> tailsCons, FSharpList`1<FSharpList`1<a>> list, int headCount);
    internal static Tuple`3<FSharpList`1<a>, FSharpList`1<FSharpList`1<a>>, int> transposeGetHeads(FSharpList`1<FSharpList`1<a>> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void transposeToFreshConsTail(FSharpList`1<FSharpList`1<a>> cons, FSharpList`1<FSharpList`1<a>> list);
    internal static FSharpList`1<FSharpList`1<T>> transpose(FSharpList`1<FSharpList`1<T>> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void truncateToFreshConsTail(FSharpList`1<a> cons, int count, FSharpList`1<a> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> truncate(int count, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void unfoldToFreshConsTail(FSharpList`1<a> cons, FSharpFunc`2<b, FSharpOption`1<Tuple`2<a, b>>> f, b s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> unfold(FSharpFunc`2<TState, FSharpOption`1<Tuple`2<T, TState>>> f, TState s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void unzipToFreshConsTail(FSharpList`1<a> cons1a, FSharpList`1<b> cons1b, FSharpList`1<Tuple`2<a, b>> x);
    internal static Tuple`2<FSharpList`1<T1>, FSharpList`1<T2>> unzip(FSharpList`1<Tuple`2<T1, T2>> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void unzip3ToFreshConsTail(FSharpList`1<a> cons1a, FSharpList`1<b> cons1b, FSharpList`1<c> cons1c, FSharpList`1<Tuple`3<a, b, c>> x);
    internal static Tuple`3<FSharpList`1<T1>, FSharpList`1<T2>, FSharpList`1<T3>> unzip3(FSharpList`1<Tuple`3<T1, T2, T3>> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void windowedToFreshConsTail(FSharpList`1<FSharpList`1<a>> cons, int windowSize, int i, FSharpList`1<a> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<T>> windowed(int windowSize, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void chunkBySizeToFreshConsTail(FSharpList`1<a> chunkCons, FSharpList`1<FSharpList`1<a>> resCons, int chunkSize, int i, FSharpList`1<a> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<T>> chunkBySize(int chunkSize, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void splitIntoToFreshConsTail(FSharpList`1<a> chunkCons, FSharpList`1<FSharpList`1<a>> resCons, int lenDivCount, int lenModCount, int i, int j, FSharpList`1<a> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<T>> splitInto(int count, FSharpList`1<T> list);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void zipToFreshConsTail(FSharpList`1<Tuple`2<a, b>> cons, FSharpList`1<a> xs1, FSharpList`1<b> xs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<T1, T2>> zip(FSharpList`1<T1> xs1, FSharpList`1<T2> xs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void zip3ToFreshConsTail(FSharpList`1<Tuple`3<a, b, c>> cons, FSharpList`1<a> xs1, FSharpList`1<b> xs2, FSharpList`1<c> xs3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`3<T1, T2, T3>> zip3(FSharpList`1<T1> xs1, FSharpList`1<T2> xs2, FSharpList`1<T3> xs3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void takeWhileFreshConsTail(FSharpList`1<a> cons, FSharpFunc`2<a, bool> p, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> takeWhile(FSharpFunc`2<T, bool> p, FSharpList`1<T> l);
    internal static FSharpValueOption`1<T> tryLastV(FSharpList`1<T> list);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Primitives.Basics.Seq : object {
    internal static FSharpValueOption`1<T> tryLastV(IEnumerable`1<T> source);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Quotations.DerivedPatternsModule : object {
    [CompilationMappingAttribute("9")]
internal static MethodInfo new_decimal_info { get; }
    [CompilationSourceNameAttribute("|Bool|_|")]
public static FSharpOption`1<bool> BoolPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|String|_|")]
public static FSharpOption`1<string> StringPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Single|_|")]
public static FSharpOption`1<float> SinglePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Double|_|")]
public static FSharpOption`1<double> DoublePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Char|_|")]
public static FSharpOption`1<char> CharPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|SByte|_|")]
public static FSharpOption`1<sbyte> SBytePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Byte|_|")]
public static FSharpOption`1<byte> BytePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Int16|_|")]
public static FSharpOption`1<short> Int16Pattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|UInt16|_|")]
public static FSharpOption`1<ushort> UInt16Pattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Int32|_|")]
public static FSharpOption`1<int> Int32Pattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|UInt32|_|")]
public static FSharpOption`1<UInt32> UInt32Pattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Int64|_|")]
public static FSharpOption`1<long> Int64Pattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|UInt64|_|")]
public static FSharpOption`1<ulong> UInt64Pattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Unit|_|")]
public static FSharpOption`1<Unit> UnitPattern(FSharpExpr input);
    internal static Tuple`2<FSharpList`1<FSharpVar>, FSharpExpr> stripSuccessiveProjLets@2155(FSharpVar p, int n, FSharpExpr expr);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<FSharpVar>, FSharpExpr>> |TupledLambda|_|(FSharpExpr lam);
    internal static FSharpOption`1<Tuple`2<FSharpExpr, FSharpList`1<FSharpExpr>>> |TupledApplication|_|(FSharpExpr e);
    [CompilationSourceNameAttribute("|Lambdas|_|")]
public static FSharpOption`1<Tuple`2<FSharpList`1<FSharpList`1<FSharpVar>>, FSharpExpr>> LambdasPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Applications|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpList`1<FSharpList`1<FSharpExpr>>>> ApplicationsPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|AndAlso|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> AndAlsoPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|OrElse|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> OrElsePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|SpecificCall|_|")]
public static FSharpFunc`2<FSharpExpr, FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpList`1<Type>, FSharpList`1<FSharpExpr>>>> SpecificCallPattern(FSharpExpr templateParameter);
    internal static MethodInfo get_new_decimal_info();
    [CompilationSourceNameAttribute("|Decimal|_|")]
public static FSharpOption`1<decimal> DecimalPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|MethodWithReflectedDefinition|_|")]
public static FSharpOption`1<FSharpExpr> MethodWithReflectedDefinitionPattern(MethodBase methodBase);
    [CompilationSourceNameAttribute("|PropertyGetterWithReflectedDefinition|_|")]
public static FSharpOption`1<FSharpExpr> PropertyGetterWithReflectedDefinitionPattern(PropertyInfo propertyInfo);
    [CompilationSourceNameAttribute("|PropertySetterWithReflectedDefinition|_|")]
public static FSharpOption`1<FSharpExpr> PropertySetterWithReflectedDefinitionPattern(PropertyInfo propertyInfo);
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("33")]
internal class Microsoft.FSharp.Quotations.ExprConstInfo : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_AppOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_IfThenElseOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_LetRecOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_LetRecCombOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_LetOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_SequentialOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_AddressOfOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_VarSetOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_AddressSetOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_TryWithOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_TryFinallyOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_ForIntegerRangeLoopOp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprConstInfo _unique_WhileLoopOp;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo AppOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAppOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo IfThenElseOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsIfThenElseOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo LetRecOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLetRecOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo LetRecCombOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLetRecCombOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo LetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewRecordOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewUnionCaseOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCaseTestOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewTupleOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTupleGetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInstancePropGetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStaticPropGetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInstancePropSetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStaticPropSetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInstanceFieldGetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStaticFieldGetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInstanceFieldSetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStaticFieldSetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewObjectOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInstanceMethodCallOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStaticMethodCallOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInstanceMethodCallWOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStaticMethodCallWOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCoerceOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewArrayOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewDelegateOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsQuoteOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo SequentialOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSequentialOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo AddressOfOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAddressOfOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo VarSetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsVarSetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo AddressSetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAddressSetOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTypeTestOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo TryWithOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTryWithOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo TryFinallyOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTryFinallyOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo ForIntegerRangeLoopOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsForIntegerRangeLoopOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprConstInfo WhileLoopOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWhileLoopOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsValueOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWithValueOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDefaultValueOp { get; }
    private static ExprConstInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ExprConstInfo(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static ExprConstInfo get_AppOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAppOp();
    [CompilationMappingAttribute("8", "1")]
internal static ExprConstInfo get_IfThenElseOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsIfThenElseOp();
    [CompilationMappingAttribute("8", "2")]
internal static ExprConstInfo get_LetRecOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLetRecOp();
    [CompilationMappingAttribute("8", "3")]
internal static ExprConstInfo get_LetRecCombOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLetRecCombOp();
    [CompilationMappingAttribute("8", "4")]
internal static ExprConstInfo get_LetOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLetOp();
    [CompilationMappingAttribute("8", "5")]
internal static ExprConstInfo NewNewRecordOp(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewRecordOp();
    [CompilationMappingAttribute("8", "6")]
internal static ExprConstInfo NewNewUnionCaseOp(UnionCaseInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewUnionCaseOp();
    [CompilationMappingAttribute("8", "7")]
internal static ExprConstInfo NewUnionCaseTestOp(UnionCaseInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCaseTestOp();
    [CompilationMappingAttribute("8", "8")]
internal static ExprConstInfo NewNewTupleOp(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewTupleOp();
    [CompilationMappingAttribute("8", "9")]
internal static ExprConstInfo NewTupleGetOp(Type item1, int item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTupleGetOp();
    [CompilationMappingAttribute("8", "10")]
internal static ExprConstInfo NewInstancePropGetOp(PropertyInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInstancePropGetOp();
    [CompilationMappingAttribute("8", "11")]
internal static ExprConstInfo NewStaticPropGetOp(PropertyInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStaticPropGetOp();
    [CompilationMappingAttribute("8", "12")]
internal static ExprConstInfo NewInstancePropSetOp(PropertyInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInstancePropSetOp();
    [CompilationMappingAttribute("8", "13")]
internal static ExprConstInfo NewStaticPropSetOp(PropertyInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStaticPropSetOp();
    [CompilationMappingAttribute("8", "14")]
internal static ExprConstInfo NewInstanceFieldGetOp(FieldInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInstanceFieldGetOp();
    [CompilationMappingAttribute("8", "15")]
internal static ExprConstInfo NewStaticFieldGetOp(FieldInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStaticFieldGetOp();
    [CompilationMappingAttribute("8", "16")]
internal static ExprConstInfo NewInstanceFieldSetOp(FieldInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInstanceFieldSetOp();
    [CompilationMappingAttribute("8", "17")]
internal static ExprConstInfo NewStaticFieldSetOp(FieldInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStaticFieldSetOp();
    [CompilationMappingAttribute("8", "18")]
internal static ExprConstInfo NewNewObjectOp(ConstructorInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewObjectOp();
    [CompilationMappingAttribute("8", "19")]
internal static ExprConstInfo NewInstanceMethodCallOp(MethodInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInstanceMethodCallOp();
    [CompilationMappingAttribute("8", "20")]
internal static ExprConstInfo NewStaticMethodCallOp(MethodInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStaticMethodCallOp();
    [CompilationMappingAttribute("8", "21")]
internal static ExprConstInfo NewInstanceMethodCallWOp(MethodInfo item1, MethodInfo item2, int item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInstanceMethodCallWOp();
    [CompilationMappingAttribute("8", "22")]
internal static ExprConstInfo NewStaticMethodCallWOp(MethodInfo item1, MethodInfo item2, int item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStaticMethodCallWOp();
    [CompilationMappingAttribute("8", "23")]
internal static ExprConstInfo NewCoerceOp(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCoerceOp();
    [CompilationMappingAttribute("8", "24")]
internal static ExprConstInfo NewNewArrayOp(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewArrayOp();
    [CompilationMappingAttribute("8", "25")]
internal static ExprConstInfo NewNewDelegateOp(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewDelegateOp();
    [CompilationMappingAttribute("8", "26")]
internal static ExprConstInfo NewQuoteOp(bool item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsQuoteOp();
    [CompilationMappingAttribute("8", "27")]
internal static ExprConstInfo get_SequentialOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSequentialOp();
    [CompilationMappingAttribute("8", "28")]
internal static ExprConstInfo get_AddressOfOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAddressOfOp();
    [CompilationMappingAttribute("8", "29")]
internal static ExprConstInfo get_VarSetOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsVarSetOp();
    [CompilationMappingAttribute("8", "30")]
internal static ExprConstInfo get_AddressSetOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAddressSetOp();
    [CompilationMappingAttribute("8", "31")]
internal static ExprConstInfo NewTypeTestOp(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTypeTestOp();
    [CompilationMappingAttribute("8", "32")]
internal static ExprConstInfo get_TryWithOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTryWithOp();
    [CompilationMappingAttribute("8", "33")]
internal static ExprConstInfo get_TryFinallyOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTryFinallyOp();
    [CompilationMappingAttribute("8", "34")]
internal static ExprConstInfo get_ForIntegerRangeLoopOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsForIntegerRangeLoopOp();
    [CompilationMappingAttribute("8", "35")]
internal static ExprConstInfo get_WhileLoopOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWhileLoopOp();
    [CompilationMappingAttribute("8", "36")]
internal static ExprConstInfo NewValueOp(object item1, Type item2, FSharpOption`1<string> item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsValueOp();
    [CompilationMappingAttribute("8", "37")]
internal static ExprConstInfo NewWithValueOp(object item1, Type item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWithValueOp();
    [CompilationMappingAttribute("8", "38")]
internal static ExprConstInfo NewDefaultValueOp(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDefaultValueOp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ExprConstInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Quotations.ExprShapeModule : object {
    [CompilerGeneratedAttribute]
internal static FSharpExpr e$cont@2257(FSharpList`1<FSharpExpr> arguments, ExprConstInfo op, Unit unitVar);
    public static FSharpExpr RebuildShapeCombination(object shape, FSharpList`1<FSharpExpr> arguments);
    internal static FSharpChoice`3<FSharpVar, Tuple`2<FSharpVar, FSharpExpr>, Tuple`2<object, FSharpList`1<FSharpExpr>>> loop@2304-48(FSharpExpr expr);
    [CompilationSourceNameAttribute("|ShapeVar|ShapeLambda|ShapeCombination|")]
public static FSharpChoice`3<FSharpVar, Tuple`2<FSharpVar, FSharpExpr>, Tuple`2<object, FSharpList`1<FSharpExpr>>> ShapePattern(FSharpExpr input);
}
[CompiledNameAttribute("FSharpExpr")]
[ClassAttribute]
[StructuredFormatDisplayAttribute("{DebugText}")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Quotations.FSharpExpr : object {
    internal Tree term;
    internal FSharpList`1<FSharpExpr> attribs;
    internal Tree Tree { get; }
    public FSharpList`1<FSharpExpr> CustomAttributes { get; }
    internal string DebugText { get; }
    public Type Type { get; }
    internal FSharpExpr(Tree term, FSharpList`1<FSharpExpr> attribs);
    internal Tree get_Tree();
    public FSharpList`1<FSharpExpr> get_CustomAttributes();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(bool full);
    internal string get_DebugText();
    internal Layout GetLayout(bool long);
    public FSharpExpr Substitute(FSharpFunc`2<FSharpVar, FSharpOption`1<FSharpExpr>> substitution);
    public IEnumerable`1<FSharpVar> GetFreeVars();
    public Type get_Type();
    public static FSharpExpr AddressOf(FSharpExpr target);
    public static FSharpExpr AddressSet(FSharpExpr target, FSharpExpr value);
    public static FSharpExpr Application(FSharpExpr functionExpr, FSharpExpr argument);
    public static FSharpExpr Applications(FSharpExpr functionExpr, FSharpList`1<FSharpList`1<FSharpExpr>> arguments);
    public static FSharpExpr Call(MethodInfo methodInfo, FSharpList`1<FSharpExpr> arguments);
    public static FSharpExpr Call(FSharpExpr obj, MethodInfo methodInfo, FSharpList`1<FSharpExpr> arguments);
    public static FSharpExpr CallWithWitnesses(MethodInfo methodInfo, MethodInfo methodInfoWithWitnesses, FSharpList`1<FSharpExpr> witnesses, FSharpList`1<FSharpExpr> arguments);
    public static FSharpExpr CallWithWitnesses(FSharpExpr obj, MethodInfo methodInfo, MethodInfo methodInfoWithWitnesses, FSharpList`1<FSharpExpr> witnesses, FSharpList`1<FSharpExpr> arguments);
    public static FSharpExpr Coerce(FSharpExpr source, Type target);
    public static FSharpExpr IfThenElse(FSharpExpr guard, FSharpExpr thenExpr, FSharpExpr elseExpr);
    public static FSharpExpr ForIntegerRangeLoop(FSharpVar loopVariable, FSharpExpr start, FSharpExpr endExpr, FSharpExpr body);
    public static FSharpExpr FieldGet(FieldInfo fieldInfo);
    public static FSharpExpr FieldGet(FSharpExpr obj, FieldInfo fieldInfo);
    public static FSharpExpr FieldSet(FieldInfo fieldInfo, FSharpExpr value);
    public static FSharpExpr FieldSet(FSharpExpr obj, FieldInfo fieldInfo, FSharpExpr value);
    public static FSharpExpr Lambda(FSharpVar parameter, FSharpExpr body);
    public static FSharpExpr Let(FSharpVar letVariable, FSharpExpr letExpr, FSharpExpr body);
    public static FSharpExpr LetRecursive(FSharpList`1<Tuple`2<FSharpVar, FSharpExpr>> bindings, FSharpExpr body);
    public static FSharpExpr NewObject(ConstructorInfo constructorInfo, FSharpList`1<FSharpExpr> arguments);
    public static FSharpExpr DefaultValue(Type expressionType);
    public static FSharpExpr NewTuple(FSharpList`1<FSharpExpr> elements);
    public static FSharpExpr NewStructTuple(Assembly asm, FSharpList`1<FSharpExpr> elements);
    public static FSharpExpr NewRecord(Type recordType, FSharpList`1<FSharpExpr> elements);
    public static FSharpExpr NewArray(Type elementType, FSharpList`1<FSharpExpr> elements);
    public static FSharpExpr NewDelegate(Type delegateType, FSharpList`1<FSharpVar> parameters, FSharpExpr body);
    public static FSharpExpr NewUnionCase(UnionCaseInfo unionCase, FSharpList`1<FSharpExpr> arguments);
    public static FSharpExpr PropertyGet(FSharpExpr obj, PropertyInfo property, FSharpOption`1<FSharpList`1<FSharpExpr>> indexerArgs);
    public static FSharpExpr PropertyGet(PropertyInfo property, FSharpOption`1<FSharpList`1<FSharpExpr>> indexerArgs);
    public static FSharpExpr PropertySet(FSharpExpr obj, PropertyInfo property, FSharpExpr value, FSharpOption`1<FSharpList`1<FSharpExpr>> indexerArgs);
    public static FSharpExpr PropertySet(PropertyInfo property, FSharpExpr value, FSharpOption`1<FSharpList`1<FSharpExpr>> indexerArgs);
    [ObsoleteAttribute("Please use Expr.QuoteTyped or Expr.QuoteRaw to distinguish between typed and raw quotation literals")]
public static FSharpExpr Quote(FSharpExpr inner);
    public static FSharpExpr QuoteRaw(FSharpExpr inner);
    public static FSharpExpr QuoteTyped(FSharpExpr inner);
    public static FSharpExpr Sequential(FSharpExpr first, FSharpExpr second);
    public static FSharpExpr TryWith(FSharpExpr body, FSharpVar filterVar, FSharpExpr filterBody, FSharpVar catchVar, FSharpExpr catchBody);
    public static FSharpExpr TryFinally(FSharpExpr body, FSharpExpr compensation);
    public static FSharpExpr TupleGet(FSharpExpr tuple, int index);
    public static FSharpExpr TypeTest(FSharpExpr source, Type target);
    public static FSharpExpr UnionCaseTest(FSharpExpr source, UnionCaseInfo unionCase);
    public static FSharpExpr Value(T value);
    public static FSharpExpr Value(object value, Type expressionType);
    public static FSharpExpr ValueWithName(T value, string name);
    public static FSharpExpr ValueWithName(object value, Type expressionType, string name);
    public static FSharpExpr`1<T> WithValue(T value, FSharpExpr`1<T> definition);
    public static FSharpExpr WithValue(object value, Type expressionType, FSharpExpr definition);
    public static FSharpExpr Var(FSharpVar variable);
    public static FSharpExpr VarSet(FSharpVar variable, FSharpExpr value);
    public static FSharpExpr WhileLoop(FSharpExpr guard, FSharpExpr body);
    public static FSharpOption`1<FSharpExpr> TryGetReflectedDefinition(MethodBase methodBase);
    public static FSharpExpr`1<T> Cast(FSharpExpr source);
    public static FSharpExpr Deserialize(Type qualifyingType, FSharpList`1<Type> spliceTypes, FSharpList`1<FSharpExpr> spliceExprs, Byte[] bytes);
    public static FSharpExpr Deserialize40(Type qualifyingType, Type[] referencedTypes, Type[] spliceTypes, FSharpExpr[] spliceExprs, Byte[] bytes);
    public static void RegisterReflectedDefinitions(Assembly assembly, string resource, Byte[] serializedValue);
    public static void RegisterReflectedDefinitions(Assembly assembly, string resource, Byte[] serializedValue, Type[] referencedTypes);
    public static FSharpExpr`1<T> GlobalVar(string name);
}
[CompiledNameAttribute("FSharpExpr`1")]
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Quotations.FSharpExpr`1 : FSharpExpr {
    public FSharpExpr Raw { get; }
    internal FSharpExpr`1(Tree term, FSharpList`1<FSharpExpr> attribs);
    public FSharpExpr get_Raw();
}
[SealedAttribute]
[CompiledNameAttribute("FSharpVar")]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Quotations.FSharpVar : object {
    internal Type typ;
    internal string name;
    internal static FSharpFunc`2<Unit, long> getStamp;
    internal static Dictionary`2<Tuple`2<string, Type>, FSharpVar> globals;
    internal long stamp;
    internal bool isMutable@92;
    public string Name { get; }
    public bool IsMutable { get; }
    public Type Type { get; }
    internal long Stamp { get; }
    public FSharpVar(string name, Type typ, FSharpOption`1<bool> isMutable);
    private static FSharpVar();
    public string get_Name();
    public bool get_IsMutable();
    public Type get_Type();
    internal long get_Stamp();
    public static FSharpVar Global(string name, Type typ);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private virtual override int System.IComparable.CompareTo(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Quotations.Helpers : object {
    internal static BindingFlags staticBindingFlags { get; }
    internal static BindingFlags staticOrInstanceBindingFlags { get; }
    internal static BindingFlags instanceBindingFlags { get; }
    internal static BindingFlags publicOrPrivateBindingFlags { get; }
    internal static FSharpOption`1<Tuple`2<FSharpList`1<b>, a>> queryAcc@29(FSharpFunc`2<a, FSharpOption`1<Tuple`2<b, a>>> q, FSharpList`1<b> rvs, a e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpList`1<b>, a>> qOneOrMoreRLinear(FSharpFunc`2<a, FSharpOption`1<Tuple`2<b, a>>> q, a inp);
    internal static FSharpOption`1<Tuple`2<a, FSharpList`1<b>>> queryAcc@39-1(FSharpFunc`2<a, FSharpOption`1<Tuple`2<a, b>>> q, a e, FSharpList`1<b> rvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<a, FSharpList`1<b>>> qOneOrMoreLLinear(FSharpFunc`2<a, FSharpOption`1<Tuple`2<a, b>>> q, a inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b mkRLinear(FSharpFunc`2<Tuple`2<a, b>, b> mk, FSharpList`1<a> vs, b body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a mkLLinear(FSharpFunc`2<Tuple`2<a, b>, a> mk, a body, FSharpList`1<b> vs);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_staticBindingFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_staticOrInstanceBindingFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_instanceBindingFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_publicOrPrivateBindingFlags();
    internal static bool isDelegateType(Type typ);
    internal static MethodInfo getDelegateInvoke(Type ty);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Quotations.PatternsModule : object {
    [CompilationMappingAttribute("9")]
internal static Type funTyC { get; }
    [CompilationMappingAttribute("9")]
internal static Type exprTyC { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-5 { get; }
    internal static Type voidTy { get; }
    internal static Type unitTy { get; }
    internal static Type rawExprTy { get; }
    internal static string ReflectedDefinitionsResourceNameBase { get; }
    [CompilationMappingAttribute("9")]
internal static Assembly mscorlib { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<InputState, Tuple`2<MethodBase, FSharpFunc`2<BindingEnv, FSharpExpr>>> u_ReflectedDefinition { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<InputState, FSharpList`1<Tuple`2<MethodBase, FSharpFunc`2<BindingEnv, FSharpExpr>>>> u_ReflectedDefinitions { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<Tuple`2<Assembly, string>, int> decodedTopResources { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<ReflectedDefinitionTableKey, ReflectedDefinitionTableEntry> reflectedDefinitionTable { get; }
    internal static FSharpOption`1<Tuple`2<FSharpList`1<b>, b>> loop@382-46(FSharpList`1<b> acc, FSharpList`1<b> xs);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<a>, a>> |FrontAndBack|_|(FSharpList`1<a> es);
    internal static Type get_funTyC();
    internal static Type get_exprTyC();
    internal static Type get_ty@455-5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Type get_voidTy();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Type get_unitTy();
    internal static Type removeVoid(Type a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type mkFunTy(Type a, Type b);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Type get_rawExprTy();
    internal static FSharpOption`1<ExprConstInfo> |Comb0|_|(FSharpExpr _arg1);
    internal static FSharpOption`1<Tuple`2<ExprConstInfo, FSharpExpr>> |Comb1|_|(FSharpExpr _arg1);
    internal static FSharpOption`1<Tuple`3<ExprConstInfo, FSharpExpr, FSharpExpr>> |Comb2|_|(FSharpExpr _arg1);
    internal static FSharpOption`1<Tuple`4<ExprConstInfo, FSharpExpr, FSharpExpr, FSharpExpr>> |Comb3|_|(FSharpExpr _arg1);
    [CompilationSourceNameAttribute("|Var|_|")]
public static FSharpOption`1<FSharpVar> VarPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Application|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> ApplicationPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Lambda|_|")]
public static FSharpOption`1<Tuple`2<FSharpVar, FSharpExpr>> LambdaPattern(FSharpExpr input);
    [ObsoleteAttribute("Please use QuoteTyped or QuoteRaw to distinguish between typed and raw quotation literals")]
[CompilationSourceNameAttribute("|Quote|_|")]
public static FSharpOption`1<FSharpExpr> QuotePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|QuoteRaw|_|")]
public static FSharpOption`1<FSharpExpr> QuoteRawPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|QuoteTyped|_|")]
public static FSharpOption`1<FSharpExpr> QuoteTypedPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|IfThenElse|_|")]
public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpExpr, FSharpExpr>> IfThenElsePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|NewTuple|_|")]
public static FSharpOption`1<FSharpList`1<FSharpExpr>> NewTuplePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|NewStructTuple|_|")]
public static FSharpOption`1<FSharpList`1<FSharpExpr>> NewStructTuplePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|DefaultValue|_|")]
public static FSharpOption`1<Type> DefaultValuePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|NewRecord|_|")]
public static FSharpOption`1<Tuple`2<Type, FSharpList`1<FSharpExpr>>> NewRecordPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|NewUnionCase|_|")]
public static FSharpOption`1<Tuple`2<UnionCaseInfo, FSharpList`1<FSharpExpr>>> NewUnionCasePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|UnionCaseTest|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, UnionCaseInfo>> UnionCaseTestPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|TupleGet|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, int>> TupleGetPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Coerce|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, Type>> CoercePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|TypeTest|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, Type>> TypeTestPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|NewArray|_|")]
public static FSharpOption`1<Tuple`2<Type, FSharpList`1<FSharpExpr>>> NewArrayPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|AddressSet|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> AddressSetPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|TryFinally|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> TryFinallyPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|TryWith|_|")]
public static FSharpOption`1<Tuple`5<FSharpExpr, FSharpVar, FSharpExpr, FSharpVar, FSharpExpr>> TryWithPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|VarSet|_|")]
public static FSharpOption`1<Tuple`2<FSharpVar, FSharpExpr>> VarSetPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Value|_|")]
public static FSharpOption`1<Tuple`2<object, Type>> ValuePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|ValueObj|_|")]
internal static FSharpOption`1<object> ValueObjPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|ValueWithName|_|")]
public static FSharpOption`1<Tuple`3<object, Type, string>> ValueWithNamePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|WithValue|_|")]
public static FSharpOption`1<Tuple`3<object, Type, FSharpExpr>> WithValuePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|AddressOf|_|")]
public static FSharpOption`1<FSharpExpr> AddressOfPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Sequential|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> SequentialPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|ForIntegerRangeLoop|_|")]
public static FSharpOption`1<Tuple`4<FSharpVar, FSharpExpr, FSharpExpr, FSharpExpr>> ForIntegerRangeLoopPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|WhileLoop|_|")]
public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> WhileLoopPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|PropertyGet|_|")]
public static FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, PropertyInfo, FSharpList`1<FSharpExpr>>> PropertyGetPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|PropertySet|_|")]
public static FSharpOption`1<Tuple`4<FSharpOption`1<FSharpExpr>, PropertyInfo, FSharpList`1<FSharpExpr>, FSharpExpr>> PropertySetPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|FieldGet|_|")]
public static FSharpOption`1<Tuple`2<FSharpOption`1<FSharpExpr>, FieldInfo>> FieldGetPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|FieldSet|_|")]
public static FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FieldInfo, FSharpExpr>> FieldSetPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|NewObject|_|")]
public static FSharpOption`1<Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>> NewObjectPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|Call|_|")]
public static FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, MethodInfo, FSharpList`1<FSharpExpr>>> CallPattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|CallWithWitnesses|_|")]
public static FSharpOption`1<Tuple`5<FSharpOption`1<FSharpExpr>, MethodInfo, MethodInfo, FSharpList`1<FSharpExpr>, FSharpList`1<FSharpExpr>>> CallWithWitnessesPattern(FSharpExpr input);
    internal static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> |LetRaw|_|(FSharpExpr input);
    internal static FSharpOption`1<FSharpExpr> |LetRecRaw|_|(FSharpExpr input);
    [CompilationSourceNameAttribute("|Let|_|")]
public static FSharpOption`1<Tuple`3<FSharpVar, FSharpExpr, FSharpExpr>> LetPattern(FSharpExpr input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpList`1<FSharpVar>, FSharpExpr>> |NLambdas|_|(int n, FSharpExpr e);
    [CompilationSourceNameAttribute("|NewDelegate|_|")]
public static FSharpOption`1<Tuple`3<Type, FSharpList`1<FSharpVar>, FSharpExpr>> NewDelegatePattern(FSharpExpr input);
    [CompilationSourceNameAttribute("|LetRecursive|_|")]
public static FSharpOption`1<Tuple`2<FSharpList`1<Tuple`2<FSharpVar, FSharpExpr>>, FSharpExpr>> LetRecursivePattern(FSharpExpr input);
    internal static PropertyInfo getRecordProperty(Type ty, string fieldName);
    internal static UnionCaseInfo getUnionCaseInfo(Type ty, string unionCaseName);
    internal static PropertyInfo getUnionCaseInfoField(UnionCaseInfo unionCase, int index);
    internal static Type typeOfAppliedLambda(FSharpExpr f);
    internal static Type typeOf(T e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr mkFEN(ExprConstInfo op, FSharpList`1<FSharpExpr> l);
    internal static FSharpExpr mkFE0(ExprConstInfo op);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr mkFE1(ExprConstInfo op, FSharpExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr mkFE2(ExprConstInfo op, FSharpExpr x, FSharpExpr y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr mkFE3(ExprConstInfo op, FSharpExpr x, FSharpExpr y, FSharpExpr z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkTypesSR(Type expectedType, Type receivedType, a name, string threeHoleSR);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkTypesWeakSR(Type expectedType, Type receivedType, a name, string threeHoleSR);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkArgs(ParameterInfo[] paramInfos, FSharpList`1<FSharpExpr> args);
    internal static Type loop@759-47(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkObj(MemberInfo membInfo, FSharpExpr obj);
    internal static void checkAppliedLambda(FSharpExpr f, FSharpExpr v);
    internal static void checkBind(FSharpVar v, FSharpExpr e);
    internal static FSharpExpr mkVar(FSharpVar v);
    internal static FSharpExpr mkQuote(FSharpExpr a, bool isTyped);
    internal static FSharpExpr mkValue(a v, Type ty);
    internal static FSharpExpr mkValueWithName(a v, Type ty, string nm);
    internal static ExprConstInfo mkLiftedValueOpG(a v, Type ty);
    internal static FSharpExpr mkLambda(FSharpVar var, FSharpExpr body);
    internal static FSharpExpr mkTryWith(FSharpExpr e1, FSharpVar v1, FSharpExpr e2, FSharpVar v2, FSharpExpr e3);
    internal static FSharpExpr mkApplication(FSharpExpr v_0, FSharpExpr v_1);
    internal static FSharpExpr mkLetRawWithCheck(FSharpExpr _arg1_0, FSharpExpr _arg1_1);
    internal static FSharpExpr mkNewTupleWithType(Type ty, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkNewTuple(FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkNewStructTuple(Assembly asm, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkTupleGet(Type ty, int n, FSharpExpr x);
    internal static FSharpExpr mkNewRecord(Type ty, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkNewUnionCase(UnionCaseInfo unionCase, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkUnionCaseTest(UnionCaseInfo unionCase, FSharpExpr expr);
    internal static FSharpExpr mkIfThenElse(FSharpExpr e, FSharpExpr t, FSharpExpr f);
    [CompilerGeneratedAttribute]
internal static void action@103-7(Type ty, FSharpExpr a);
    internal static FSharpExpr mkNewArray(Type ty, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkInstanceFieldGet(FSharpExpr obj, FieldInfo finfo);
    internal static FSharpExpr mkStaticFieldGet(FieldInfo finfo);
    internal static FSharpExpr mkStaticFieldSet(FieldInfo finfo, FSharpExpr value);
    internal static FSharpExpr mkInstanceFieldSet(FSharpExpr obj, FieldInfo finfo, FSharpExpr value);
    internal static FSharpExpr mkCtorCall(ConstructorInfo ci, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkStaticPropGet(PropertyInfo pinfo, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkInstancePropGet(FSharpExpr obj, PropertyInfo pinfo, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkStaticPropSet(PropertyInfo pinfo, FSharpList`1<FSharpExpr> args, FSharpExpr value);
    internal static FSharpExpr mkInstancePropSet(FSharpExpr obj, PropertyInfo pinfo, FSharpList`1<FSharpExpr> args, FSharpExpr value);
    internal static FSharpExpr mkInstanceMethodCall(FSharpExpr obj, MethodInfo minfo, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkInstanceMethodCallW(FSharpExpr obj, MethodInfo minfo, MethodInfo minfoW, int nWitnesses, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkStaticMethodCall(MethodInfo minfo, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkStaticMethodCallW(MethodInfo minfo, MethodInfo minfoW, int nWitnesses, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkForLoop(FSharpVar v, FSharpExpr lowerBound, FSharpExpr upperBound, FSharpExpr body);
    internal static FSharpExpr mkWhileLoop(FSharpExpr guard, FSharpExpr body);
    internal static FSharpExpr mkNewDelegate(Type ty, FSharpExpr e);
    internal static FSharpExpr mkLet(FSharpVar v, FSharpExpr e, FSharpExpr b);
    internal static FSharpExpr mkTupledApplication(FSharpExpr f, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr mkLetRec(FSharpList`1<Tuple`2<FSharpVar, FSharpExpr>> ves, FSharpExpr body);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_ReflectedDefinitionsResourceNameBase();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typesEqual(FSharpList`1<Type> ss, FSharpList`1<Type> tt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T instFormal(Type[] typarEnv, FSharpFunc`2<FSharpFunc`2<int, Type>, T> ty);
    internal static Type[] getGenericArguments(Type tc);
    internal static int getNumGenericArguments(Type tc);
    internal static MethodInfo bindMethodBySearch(Type parentT, string nm, int marity, FSharpList`1<FSharpFunc`2<FSharpFunc`2<int, Type>, Type>> argtys, FSharpFunc`2<FSharpFunc`2<int, Type>, Type> rty);
    internal static MethodInfo bindMethodHelper(Type parentT, string nm, int marity, FSharpList`1<FSharpFunc`2<FSharpFunc`2<int, Type>, Type>> argtys, FSharpFunc`2<FSharpFunc`2<int, Type>, Type> rty);
    internal static PropertyInfo bindModuleProperty(Type ty, string nm);
    internal static int iter@1151-1(Type[] argTypes, Type[] tyArgs, ParameterInfo[] parameters, int i, int acc);
    internal static int weight@1149(Type[] argTypes, Type[] tyArgs, MethodInfo mi);
    internal static a fail@1118(Type ty, string nm, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static MethodInfo bindModuleFunctionWithCallSiteArgs$cont@1110(Type ty, string nm, Type[] argTypes, Type[] tyArgs, Unit unitVar);
    internal static MethodInfo bindModuleFunctionWithCallSiteArgs(Type ty, string nm, FSharpList`1<Type> argTypes, FSharpList`1<Type> tyArgs);
    internal static Type mkNamedType(Type tc, FSharpList`1<Type> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T inst(FSharpList`1<Type> tyargs, FSharpFunc`2<FSharpFunc`2<int, Type>, T> i);
    internal static PropertyInfo bindProp(Type tc, string propName, FSharpFunc`2<FSharpFunc`2<int, Type>, a> retType, FSharpFunc`2<FSharpFunc`2<int, Type>, FSharpList`1<Type>> argTypes, FSharpList`1<Type> tyargs);
    internal static FieldInfo bindField(Type tc, string fldName, FSharpList`1<Type> tyargs);
    internal static ConstructorInfo bindGenericCctor(Type tc);
    internal static ConstructorInfo bindGenericCtor(Type tc, FSharpFunc`2<FSharpFunc`2<int, Type>, FSharpList`1<Type>> argTypes);
    internal static ConstructorInfo bindCtor(Type tc, FSharpFunc`2<FSharpFunc`2<int, Type>, FSharpList`1<Type>> argTypes, FSharpList`1<Type> tyargs);
    internal static Tuple`2<FSharpList`1<b>, FSharpList`1<b>> split@1246(int l0, FSharpList`1<b> l1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<a>, FSharpList`1<a>> chop(int n, FSharpList`1<a> xs);
    internal static MethodInfo instMeth(MethodInfo ngmeth, FSharpList`1<Type> methTypeArgs);
    internal static MethodInfo bindMeth(Tuple`5<Type, FSharpList`1<FSharpFunc`2<FSharpFunc`2<int, Type>, Type>>, FSharpFunc`2<FSharpFunc`2<int, Type>, Type>, string, int> _arg1, FSharpList`1<Type> tyargs);
    internal static bool pinfoIsStatic(PropertyInfo pinfo);
    internal static Type decodeFunTy(FSharpList`1<Type> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type decodeArrayTy(int n, FSharpList`1<Type> tys);
    internal static Type mkNamedTycon(string tcName, Assembly assembly);
    internal static Assembly get_mscorlib();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Assembly decodeAssemblyRef(InputState st, string a);
    internal static Type u_NamedType(InputState st);
    internal static FSharpFunc`2<FSharpList`1<Type>, Type> u_tyconstSpec(InputState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<b> appL(FSharpList`1<FSharpFunc`2<a, b>> fs, a env);
    internal static FSharpFunc`2<FSharpFunc`2<int, Type>, Type> u_dtype(InputState st);
    internal static void |NoTyArgs|(FSharpList`1<a> input);
    internal static a |OneTyArg|(FSharpList`1<a> input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static BindingEnv addVar(BindingEnv env, FSharpVar v);
    internal static FSharpFunc`2<int, Type> mkTyparSubst(Type[] tyargs);
    internal static FSharpFunc`2<BindingEnv, FSharpExpr> u_Expr(InputState st);
    internal static FSharpFunc`2<BindingEnv, FSharpVar> u_VarDecl(InputState st);
    internal static FSharpFunc`2<BindingEnv, FSharpVar> u_VarRef(InputState st);
    internal static FSharpFunc`2<FSharpList`1<Type>, PropertyInfo> u_RecdField(InputState st);
    internal static FSharpFunc`2<FSharpList`1<Type>, UnionCaseInfo> u_UnionCaseInfo(InputState st);
    internal static FSharpFunc`2<FSharpList`1<Type>, PropertyInfo> u_UnionCaseField(InputState st);
    [CompilerGeneratedAttribute]
internal static ModuleDefinitionBindingResult`2<ExprConstInfo, FSharpFunc`2<FSharpList`1<Type>, FSharpFunc`2<FSharpList`1<Type>, ExprConstInfo>>> u_ModuleDefn$cont@1552(FSharpOption`1<Tuple`2<string, int>> witnessInfo, Type patternInput_0, string patternInput_1, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleDefinitionBindingResult`2<ExprConstInfo, FSharpFunc`2<FSharpList`1<Type>, FSharpFunc`2<FSharpList`1<Type>, ExprConstInfo>>> u_ModuleDefn(FSharpOption`1<Tuple`2<string, int>> witnessInfo, InputState st);
    internal static Tuple`5<Type, FSharpList`1<FSharpFunc`2<FSharpFunc`2<int, Type>, Type>>, FSharpFunc`2<FSharpFunc`2<int, Type>, Type>, string, int> u_MethodInfoData(InputState st);
    internal static Tuple`4<Type, string, FSharpFunc`2<FSharpFunc`2<int, Type>, Type>, FSharpFunc`2<FSharpFunc`2<int, Type>, FSharpList`1<Type>>> u_PropInfoData(InputState st);
    internal static Tuple`2<Type, FSharpFunc`2<FSharpFunc`2<int, Type>, FSharpList`1<Type>>> u_CtorInfoData(InputState st);
    internal static MethodBase u_MethodBase(InputState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprConstInfo instModuleDefnOp(ExprConstInfo r, FSharpList`1<Type> tyargs);
    internal static ModuleDefinitionBindingResult`2<FSharpFunc`2<FSharpList`1<Type>, ExprConstInfo>, FSharpFunc`2<FSharpList`1<Type>, FSharpFunc`2<FSharpList`1<Type>, ExprConstInfo>>> u_constSpec(InputState st);
    internal static FSharpFunc`2<InputState, Tuple`2<MethodBase, FSharpFunc`2<BindingEnv, FSharpExpr>>> get_u_ReflectedDefinition();
    internal static FSharpFunc`2<InputState, FSharpList`1<Tuple`2<MethodBase, FSharpFunc`2<BindingEnv, FSharpExpr>>>> get_u_ReflectedDefinitions();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<BindingEnv, FSharpExpr> unpickleExpr(Type localType, Type[] referencedTypes, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr fillHolesInRawExpr(FSharpExpr[] l, FSharpExpr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpSet`1<FSharpVar> freeInExprAcc(FSharpSet`1<FSharpVar> bvs, FSharpSet`1<FSharpVar> acc, FSharpExpr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr substituteInExpr(FSharpSet`1<FSharpVar> bvs, FSharpFunc`2<FSharpVar, FSharpOption`1<FSharpExpr>> tmsubst, FSharpExpr _arg1);
    internal static Byte[] readToEnd(Stream s);
    internal static Dictionary`2<Tuple`2<Assembly, string>, int> get_decodedTopResources();
    internal static Dictionary`2<ReflectedDefinitionTableKey, ReflectedDefinitionTableEntry> get_reflectedDefinitionTable();
    internal static void action@103-8(MethodBase tupledArg0, FSharpFunc`2<BindingEnv, FSharpExpr> tupledArg1);
    internal static void registerReflectedDefinitions(Assembly assem, string resourceName, Byte[] bytes, Type[] referencedTypes);
    internal static void action@103-11(MethodBase tupledArg0, FSharpFunc`2<BindingEnv, FSharpExpr> tupledArg1);
    internal static void action@103-10(Assembly assem, string tupledArg0, FSharpList`1<Tuple`2<MethodBase, FSharpFunc`2<BindingEnv, FSharpExpr>>> tupledArg1);
    [CompilerGeneratedAttribute]
internal static Tuple`2<bool, ReflectedDefinitionTableEntry> action@4737-9(Assembly assem, ReflectedDefinitionTableKey key, FSharpList`1<Tuple`2<string, FSharpList`1<Tuple`2<MethodBase, FSharpFunc`2<BindingEnv, FSharpExpr>>>>> qdataResources, Unit unitVar0);
    internal static FSharpOption`1<FSharpExpr> tryGetReflectedDefinition(MethodBase methodBase, Type[] tyargs);
    internal static FSharpOption`1<FSharpExpr> tryGetReflectedDefinitionInstantiated(MethodBase methodBase);
    internal static FSharpExpr deserialize(Type localAssembly, Type[] referencedTypeDefs, Type[] spliceTypes, FSharpExpr[] spliceExprs, Byte[] bytes);
    internal static FSharpExpr`1<T> cast(FSharpExpr expr);
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("33")]
internal abstract class Microsoft.FSharp.Quotations.Tree : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCombTerm { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsVarTerm { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLambdaTerm { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsHoleTerm { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Tree(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static Tree NewCombTerm(ExprConstInfo item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCombTerm();
    [CompilationMappingAttribute("8", "1")]
internal static Tree NewVarTerm(FSharpVar item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsVarTerm();
    [CompilationMappingAttribute("8", "2")]
internal static Tree NewLambdaTerm(FSharpVar item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLambdaTerm();
    [CompilationMappingAttribute("8", "3")]
internal static Tree NewHoleTerm(Type item1, int item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsHoleTerm();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Tree obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class Microsoft.FSharp.Reflection.DynamicFunction`2 : FSharpFunc`2<FSharpFunc`2<object, object>, object> {
    public virtual object Invoke(FSharpFunc`2<object, object> impl);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Microsoft.FSharp.Reflection.FSharpReflectionExtensions : object {
    public static PropertyInfo[] FSharpType.GetExceptionFields.Static(Type exceptionType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static bool FSharpType.IsExceptionRepresentation.Static(Type exceptionType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static UnionCaseInfo[] FSharpType.GetUnionCases.Static(Type unionType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static PropertyInfo[] FSharpType.GetRecordFields.Static(Type recordType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static bool FSharpType.IsUnion.Static(Type typ, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static bool FSharpType.IsRecord.Static(Type typ, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static object FSharpValue.MakeRecord.Static(Type recordType, Object[] values, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static Object[] FSharpValue.GetRecordFields.Static(object record, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static FSharpFunc`2<object, Object[]> FSharpValue.PreComputeRecordReader.Static(Type recordType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static FSharpFunc`2<Object[], object> FSharpValue.PreComputeRecordConstructor.Static(Type recordType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static ConstructorInfo FSharpValue.PreComputeRecordConstructorInfo.Static(Type recordType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static object FSharpValue.MakeUnion.Static(UnionCaseInfo unionCase, Object[] args, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static FSharpFunc`2<Object[], object> FSharpValue.PreComputeUnionConstructor.Static(UnionCaseInfo unionCase, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static MethodInfo FSharpValue.PreComputeUnionConstructorInfo.Static(UnionCaseInfo unionCase, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static MemberInfo FSharpValue.PreComputeUnionTagMemberInfo.Static(Type unionType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static Tuple`2<UnionCaseInfo, Object[]> FSharpValue.GetUnionFields.Static(object value, Type unionType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static FSharpFunc`2<object, int> FSharpValue.PreComputeUnionTagReader.Static(Type unionType, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static FSharpFunc`2<object, Object[]> FSharpValue.PreComputeUnionReader.Static(UnionCaseInfo unionCase, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
    public static Object[] FSharpValue.GetExceptionFields.Static(object exn, FSharpOption`1<bool> allowAccessToPrivateRepresentation);
}
[AbstractClassAttribute]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public static class Microsoft.FSharp.Reflection.FSharpType : object {
    public static bool IsTuple(Type typ);
    public static bool IsRecord(Type typ, FSharpOption`1<BindingFlags> bindingFlags);
    public static bool IsUnion(Type typ, FSharpOption`1<BindingFlags> bindingFlags);
    public static bool IsFunction(Type typ);
    public static bool IsModule(Type typ);
    public static Type MakeFunctionType(Type domain, Type range);
    public static Type MakeTupleType(Type[] types);
    public static Type MakeTupleType(Assembly asm, Type[] types);
    public static Type MakeStructTupleType(Assembly asm, Type[] types);
    public static Type[] GetTupleElements(Type tupleType);
    public static Tuple`2<Type, Type> GetFunctionElements(Type functionType);
    public static PropertyInfo[] GetRecordFields(Type recordType, FSharpOption`1<BindingFlags> bindingFlags);
    public static UnionCaseInfo[] GetUnionCases(Type unionType, FSharpOption`1<BindingFlags> bindingFlags);
    public static bool IsExceptionRepresentation(Type exceptionType, FSharpOption`1<BindingFlags> bindingFlags);
    public static PropertyInfo[] GetExceptionFields(Type exceptionType, FSharpOption`1<BindingFlags> bindingFlags);
}
[AbstractClassAttribute]
[SealedAttribute]
[CompilationMappingAttribute("3")]
public static class Microsoft.FSharp.Reflection.FSharpValue : object {
    public static object MakeRecord(Type recordType, Object[] values, FSharpOption`1<BindingFlags> bindingFlags);
    public static object GetRecordField(object record, PropertyInfo info);
    public static Object[] GetRecordFields(object record, FSharpOption`1<BindingFlags> bindingFlags);
    public static FSharpFunc`2<object, object> PreComputeRecordFieldReader(PropertyInfo info);
    public static FSharpFunc`2<object, Object[]> PreComputeRecordReader(Type recordType, FSharpOption`1<BindingFlags> bindingFlags);
    public static FSharpFunc`2<Object[], object> PreComputeRecordConstructor(Type recordType, FSharpOption`1<BindingFlags> bindingFlags);
    public static ConstructorInfo PreComputeRecordConstructorInfo(Type recordType, FSharpOption`1<BindingFlags> bindingFlags);
    public static object MakeFunction(Type functionType, FSharpFunc`2<object, object> implementation);
    public static object MakeTuple(Object[] tupleElements, Type tupleType);
    public static Object[] GetTupleFields(object tuple);
    public static object GetTupleField(object tuple, int index);
    public static FSharpFunc`2<object, Object[]> PreComputeTupleReader(Type tupleType);
    public static Tuple`2<PropertyInfo, FSharpOption`1<Tuple`2<Type, int>>> PreComputeTuplePropertyInfo(Type tupleType, int index);
    public static FSharpFunc`2<Object[], object> PreComputeTupleConstructor(Type tupleType);
    public static Tuple`2<ConstructorInfo, FSharpOption`1<Type>> PreComputeTupleConstructorInfo(Type tupleType);
    public static object MakeUnion(UnionCaseInfo unionCase, Object[] args, FSharpOption`1<BindingFlags> bindingFlags);
    public static FSharpFunc`2<Object[], object> PreComputeUnionConstructor(UnionCaseInfo unionCase, FSharpOption`1<BindingFlags> bindingFlags);
    public static MethodInfo PreComputeUnionConstructorInfo(UnionCaseInfo unionCase, FSharpOption`1<BindingFlags> bindingFlags);
    public static Tuple`2<UnionCaseInfo, Object[]> GetUnionFields(object value, Type unionType, FSharpOption`1<BindingFlags> bindingFlags);
    public static FSharpFunc`2<object, int> PreComputeUnionTagReader(Type unionType, FSharpOption`1<BindingFlags> bindingFlags);
    public static MemberInfo PreComputeUnionTagMemberInfo(Type unionType, FSharpOption`1<BindingFlags> bindingFlags);
    public static FSharpFunc`2<object, Object[]> PreComputeUnionReader(UnionCaseInfo unionCase, FSharpOption`1<BindingFlags> bindingFlags);
    public static Object[] GetExceptionFields(object exn, FSharpOption`1<BindingFlags> bindingFlags);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Reflection.Impl : object {
    [CompilationMappingAttribute("9")]
internal static Type func { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455 { get; }
    internal static BindingFlags instanceFieldFlags { get; }
    internal static BindingFlags instancePropertyFlags { get; }
    internal static BindingFlags staticPropertyFlags { get; }
    internal static BindingFlags staticFieldFlags { get; }
    internal static BindingFlags staticMethodFlags { get; }
    [CompilationMappingAttribute("9")]
internal static string cmaName { get; }
    [CompilationMappingAttribute("9")]
internal static string assemblyName { get; }
    [CompilationMappingAttribute("9")]
internal static String[] tupleNames { get; }
    [CompilationMappingAttribute("9")]
internal static String[] simpleTupleNames { get; }
    internal static int maxTuple { get; }
    internal static int tupleEncField { get; }
    [CompilationMappingAttribute("9")]
internal static object dictionaryLock { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<Assembly, Type[]> refTupleTypes { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<Assembly, Type[]> valueTupleTypes { get; }
    internal static bool isNamedType(Type typ);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equivHeadTypes(Type ty1, Type ty2);
    internal static Type get_func();
    internal static Type get_ty@455();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_instanceFieldFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_instancePropertyFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_staticPropertyFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_staticFieldFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_staticMethodFlags();
    internal static PropertyInfo[] getInstancePropertyInfos(Type typ, String[] names, BindingFlags bindingFlags);
    internal static FSharpOption`1<FSharpFunc`2<object, object>> getInstancePropertyReader(Type typ, string propName, BindingFlags bindingFlags);
    internal static Func`2<object, object> compilePropGetterFunc(PropertyInfo prop);
    internal static Func`2<object, Object[]> compileRecordOrUnionCaseReaderFunc(Type typ, PropertyInfo[] props);
    internal static Func`2<Object[], object> compileRecordConstructorFunc(ConstructorInfo ctorInfo);
    internal static Func`2<Object[], object> compileUnionCaseConstructorFunc(MethodInfo methodInfo);
    internal static Func`2<object, int> compileUnionTagReaderFunc(FSharpChoice`2<MethodInfo, PropertyInfo> info);
    internal static FSharpOption`1<Tuple`3<SourceConstructFlags, int, int>> tryFindCompilationMappingAttribute(Object[] attrs);
    internal static Tuple`3<SourceConstructFlags, int, int> findCompilationMappingAttribute(Object[] attrs);
    internal static string get_cmaName();
    internal static string get_assemblyName();
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`3<SourceConstructFlags, int, int>> tryFindCompilationMappingAttributeFromData$cont@183(IList`1<CustomAttributeData> attrs, Unit unitVar);
    internal static FSharpOption`1<Tuple`3<SourceConstructFlags, int, int>> tryFindCompilationMappingAttributeFromData(IList`1<CustomAttributeData> attrs);
    internal static Tuple`3<SourceConstructFlags, int, int> findCompilationMappingAttributeFromData(IList`1<CustomAttributeData> attrs);
    internal static FSharpOption`1<Tuple`3<SourceConstructFlags, int, int>> tryFindCompilationMappingAttributeFromType(Type typ);
    internal static FSharpOption`1<Tuple`3<SourceConstructFlags, int, int>> tryFindCompilationMappingAttributeFromMemberInfo(MemberInfo info);
    internal static Tuple`3<SourceConstructFlags, int, int> findCompilationMappingAttributeFromMemberInfo(MemberInfo info);
    internal static bool isFieldProperty(PropertyInfo prop);
    internal static FSharpOption`1<SourceConstructFlags> tryFindSourceConstructFlagsOfType(Type typ);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<int, string>> getUnionTypeTagNameMap$cont@261(Type typ, MethodInfo minfo, int n, Unit unitVar);
    internal static Tuple`2[] getUnionTypeTagNameMap(Type typ, BindingFlags bindingFlags);
    internal static Type getUnionCaseTyp(Type typ, int tag, BindingFlags bindingFlags);
    internal static FSharpFunc`2<int, string> getUnionTagConverter(Type typ, BindingFlags bindingFlags);
    internal static bool isUnionType(Type typ, BindingFlags bindingFlags);
    internal static bool get@327-1(BindingFlags bindingFlags, Type typ);
    internal static bool isConstructorRepr(Type typ, BindingFlags bindingFlags);
    internal static Type get@331-2(BindingFlags bindingFlags, Type typ);
    internal static Type unionTypeOfUnionCaseType(Type typ, BindingFlags bindingFlags);
    internal static PropertyInfo[] fieldsPropsOfUnionCase(Type typ, int tag, BindingFlags bindingFlags);
    internal static FSharpFunc`2<object, Object[]> getUnionCaseRecordReader(Type typ, int tag, BindingFlags bindingFlags);
    internal static FSharpFunc`2<a, Object[]> getUnionCaseRecordReaderCompiled(Type typ, int tag, BindingFlags bindingFlags);
    internal static FSharpFunc`2<object, int> getUnionTagReader(Type typ, BindingFlags bindingFlags);
    internal static FSharpFunc`2<object, int> getUnionTagReaderCompiled(Type typ, BindingFlags bindingFlags);
    internal static MemberInfo getUnionTagMemberInfo(Type typ, BindingFlags bindingFlags);
    internal static MethodInfo getUnionCaseConstructorMethod(Type typ, int tag, BindingFlags bindingFlags);
    internal static FSharpFunc`2<Object[], object> getUnionCaseConstructor(Type typ, int tag, BindingFlags bindingFlags);
    internal static FSharpFunc`2<Object[], object> getUnionCaseConstructorCompiled(Type typ, int tag, BindingFlags bindingFlags);
    internal static void checkUnionType(Type unionType, BindingFlags bindingFlags);
    internal static String[] get_tupleNames();
    internal static String[] get_simpleTupleNames();
    internal static bool isTupleType(Type typ);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_maxTuple();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_tupleEncField();
    internal static object get_dictionaryLock();
    internal static Dictionary`2<Assembly, Type[]> get_refTupleTypes();
    internal static Dictionary`2<Assembly, Type[]> get_valueTupleTypes();
    internal static string tupleFullName@491(bool isStruct, int n);
    [CompilerGeneratedAttribute]
internal static void action@4737-3(Assembly asm, Dictionary`2<Assembly, Type[]> tables, FSharpRef`1<Type[]> a, Unit unitVar0);
    internal static Type makeIt@490(bool isStruct, Assembly asm, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type mkTupleType(bool isStruct, Assembly asm, Type[] tys);
    internal static Type[] getTupleTypeInfo(Type typ);
    internal static PropertyInfo[] orderTupleProperties(PropertyInfo[] props);
    internal static FieldInfo[] orderTupleFields(FieldInfo[] fields);
    internal static ConstructorInfo getTupleConstructorMethod(Type typ);
    internal static FSharpFunc`2<Object[], object> getTupleCtor(Type typ);
    internal static FSharpFunc`2<object, Object[]> getTupleReader(Type typ);
    internal static FSharpFunc`2<Object[], object> getTupleConstructor(Type typ);
    internal static Tuple`2<ConstructorInfo, FSharpOption`1<Type>> getTupleConstructorInfo(Type typ);
    internal static PropertyInfo get@652-3(Type typ, int index);
    internal static Tuple`2<PropertyInfo, FSharpOption`1<Tuple`2<Type, int>>> getTupleReaderInfo(Type typ, int index);
    internal static Tuple`2<Type, Type> getFunctionTypeInfo(Type typ);
    internal static bool isModuleType(Type typ);
    internal static bool isClosureRepr(Type typ);
    internal static bool isRecordType(Type typ, BindingFlags bindingFlags);
    internal static PropertyInfo[] fieldPropsOfRecordType(Type typ, BindingFlags bindingFlags);
    internal static FSharpFunc`2<object, Object[]> getRecordReader(Type typ, BindingFlags bindingFlags);
    internal static FSharpFunc`2<a, Object[]> getRecordReaderCompiled(Type typ, BindingFlags bindingFlags);
    internal static ConstructorInfo getRecordConstructorMethod(Type typ, BindingFlags bindingFlags);
    internal static FSharpFunc`2<Object[], object> getRecordConstructor(Type typ, BindingFlags bindingFlags);
    internal static FSharpFunc`2<Object[], object> getRecordConstructorCompiled(Type typ, BindingFlags bindingFlags);
    internal static bool isExceptionRepr(Type typ, BindingFlags bindingFlags);
    internal static Type get@745-4(Type typ);
    internal static Type getTypeOfReprType(Type typ, BindingFlags bindingFlags);
    internal static void checkExnType(Type exceptionType, BindingFlags bindingFlags);
    internal static void checkRecordType(string argName, Type recordType, BindingFlags bindingFlags);
    internal static void checkTupleType(string argName, Type tupleType);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Reflection.ReflectionUtils : object {
    internal static BindingFlags toBindingFlags(bool allowAccessToNonPublicMembers);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class Microsoft.FSharp.Reflection.UnionCaseInfo : object {
    internal Type typ;
    internal int tag;
    internal FSharpOption`1<FSharpFunc`2<int, string>> names;
    public string Name { get; }
    public Type DeclaringType { get; }
    public int Tag { get; }
    internal UnionCaseInfo(Type typ, int tag);
    public string get_Name();
    public Type get_DeclaringType();
    public PropertyInfo[] GetFields();
    public Object[] GetCustomAttributes();
    public Object[] GetCustomAttributes(Type attributeType);
    public IList`1<CustomAttributeData> GetCustomAttributesData();
    public int get_Tag();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
internal MethodInfo getMethInfo();
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Text.StructuredPrintfImpl.Display : object {
    internal static int chunkN { get; }
    [CompilationMappingAttribute("9")]
internal static Layout structL { get; }
    [CompilationMappingAttribute("9")]
internal static Layout nullL { get; }
    [CompilationMappingAttribute("9")]
internal static Layout unitL { get; }
    internal static bool typeUsesSystemObjectToString(Type ty);
    internal static FSharpChoice`2<a, Exception> catchExn(FSharpFunc`2<Unit, a> f);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_chunkN();
    [CompilerGeneratedAttribute]
internal static int initializer@41-1(Int32[] stack, int next, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Breaks pushBreak(int saving, Breaks _arg1);
    internal static Tuple`2<Breaks, bool> popBreak(Breaks _arg1);
    internal static FSharpOption`1<Tuple`2<Breaks, int>> forceBreak(Breaks _arg1);
    internal static Tuple`4<Breaks, Layout, int, int> fitLeaf@563(int maxWidth, Layout layout, int textWidth, Breaks breaks, int pos);
    internal static Tuple`4<Breaks, Layout, int, int> fit@539(int maxWidth, FSharpFunc`2<object, TaggedText> leafFormatter, Breaks breaks, int tupledArg0, Layout tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout squashToAux(int maxWidth, FSharpFunc`2<object, TaggedText> leafFormatter, Layout layout);
    internal static Tuple`2<FSharpList`1<string>, int> addL@633(FormatOptions opts, FSharpFunc`2<object, string> leafFormatter, Tuple`2<FSharpList`1<string>, int> z, int pos, Layout layout);
    internal static Tuple`2<FSharpList`1<string>, int> newLine@626(FSharpList`1<string> tupledArg0, a tupledArg1, int n);
    internal static Tuple`2<FSharpList`1<string>, int> addText@623(FSharpList`1<string> tupledArg0, int tupledArg1, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string showL(FormatOptions opts, FSharpFunc`2<object, string> leafFormatter, Layout layout);
    internal static int addL@678-1(FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, a>>> outAttribute, FSharpFunc`2<object, b> leafFormatter, TaggedTextWriter chan, int z, int pos, Layout layout);
    internal static int newLine@671-1(TaggedTextWriter chan, c _arg1, int n);
    internal static FSharpFunc`2<TaggedText, int> addText@670-1(TaggedTextWriter chan, int z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outL(FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, a>>> outAttribute, FSharpFunc`2<object, b> leafFormatter, TaggedTextWriter chan, Layout layout);
    internal static Tuple`2<b, b> unpackCons(Tuple`2[] recd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Tuple`2<object, Type>, Tuple`2<object, Type>>> getListValueInfo(BindingFlags bindingFlags, object x, Type ty);
    internal static Layout get_structL();
    internal static Layout get_nullL();
    internal static Layout get_unitL();
    internal static Layout itemL@727(TaggedText tupledArg0, Layout tupledArg1);
    internal static Layout makeRecordL(FSharpList`1<Tuple`2<a, Layout>> nameXs);
    internal static Layout itemL@736-1(TaggedText tupledArg0, FSharpOption`1<Layout> tupledArg1);
    internal static Layout makePropertiesL(FSharpList`1<Tuple`2<a, FSharpOption`1<Layout>>> nameXs);
    internal static Layout makeListL(FSharpList`1<Layout> itemLs);
    internal static Layout makeArrayL(FSharpList`1<Layout> xs);
    internal static Layout makeArray2L(FSharpList`1<Layout> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string formatChar(bool isChar, char c);
    internal static string conv@779(string s, int i, FSharpList`1<string> acc);
    internal static bool check@778-6(string s, int i);
    internal static string formatString(string s);
    internal static bool isSetOrMapType(Type ty);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>>> clo0@1216(ObjectGraphFormatter _, ShowMode showMode);
    internal static FSharpOption`1<Layout> buildObjMessageL@892(ObjectGraphFormatter this, ShowMode showMode, Type ty, int depthLim, object obj, string txt, FSharpList`1<Layout> layouts);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>> clo0@980-2(ObjectGraphFormatter this, int depthLim);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>> clo0@979-1(ObjectGraphFormatter this, int depthLim);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>> clo0@986-3(ObjectGraphFormatter this, int depthLim);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>> clo0@995-4(ObjectGraphFormatter this, int depthLim);
    internal static Tuple`2<TaggedText, Layout> itemL@993-2(ObjectGraphFormatter this, int depthLim, Tuple`3<string, a, Type> tupledArg);
    internal static FSharpFunc`2<Tuple`2<a, Type>, FSharpOption`1<Tuple`2<Tuple`2<object, Type>, Tuple`2<object, Type>>>> project@1002(ObjectGraphFormatter this);
    internal static FSharpFunc`2<int, FSharpOption`1<Tuple`2<Tuple`2<object, Type>, int>>> project2@1063(Array arr, Type ty, int n1, int n2, int b1, int b2, int x);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>> clo0@1084-6(ObjectGraphFormatter this, int depthLim);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>> clo0@1081-5(ObjectGraphFormatter this, int depthLim);
    internal static FSharpFunc`2<o, Layout> possibleKeyValueL@1075(ObjectGraphFormatter this, int depthLim, string word);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TaggedText, FSharpOption`1<Layout>> mapping@259-1(ObjectGraphFormatter this, Type ty, object obj, int nDepth, MemberInfo m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedText leafFormatter(FormatOptions opts, object obj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout squash_layout(FormatOptions opts, Layout l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string layout_to_string(FormatOptions options, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string anyToStringForPrintf(FormatOptions options, BindingFlags bindingFlags, T value, Type xty);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("34")]
internal class Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions : object {
    [DebuggerBrowsableAttribute("0")]
internal string FloatingPointFormat@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> AttributeProcessor@;
    [DebuggerBrowsableAttribute("0")]
internal IFormatProvider FormatProvider@;
    [DebuggerBrowsableAttribute("0")]
internal BindingFlags BindingFlags@;
    [DebuggerBrowsableAttribute("0")]
internal int PrintWidth@;
    [DebuggerBrowsableAttribute("0")]
internal int PrintDepth@;
    [DebuggerBrowsableAttribute("0")]
internal int PrintLength@;
    [DebuggerBrowsableAttribute("0")]
internal int PrintSize@;
    [DebuggerBrowsableAttribute("0")]
internal bool ShowProperties@;
    [DebuggerBrowsableAttribute("0")]
internal bool ShowIEnumerable@;
    [CompilationMappingAttribute("4", "0")]
internal string FloatingPointFormat { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> AttributeProcessor { get; }
    [CompilationMappingAttribute("4", "2")]
internal IFormatProvider FormatProvider { get; }
    [CompilationMappingAttribute("4", "3")]
internal BindingFlags BindingFlags { get; }
    [CompilationMappingAttribute("4", "4")]
internal int PrintWidth { get; }
    [CompilationMappingAttribute("4", "5")]
internal int PrintDepth { get; }
    [CompilationMappingAttribute("4", "6")]
internal int PrintLength { get; }
    [CompilationMappingAttribute("4", "7")]
internal int PrintSize { get; }
    [CompilationMappingAttribute("4", "8")]
internal bool ShowProperties { get; }
    [CompilationMappingAttribute("4", "9")]
internal bool ShowIEnumerable { get; }
    internal static FormatOptions Default { get; }
    internal FormatOptions(string floatingPointFormat, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> attributeProcessor, IFormatProvider formatProvider, BindingFlags bindingFlags, int printWidth, int printDepth, int printLength, int printSize, bool showProperties, bool showIEnumerable);
    internal string get_FloatingPointFormat();
    internal FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> get_AttributeProcessor();
    internal IFormatProvider get_FormatProvider();
    internal BindingFlags get_BindingFlags();
    internal int get_PrintWidth();
    internal int get_PrintDepth();
    internal int get_PrintLength();
    internal int get_PrintSize();
    internal bool get_ShowProperties();
    internal bool get_ShowIEnumerable();
    internal static FormatOptions get_Default();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
internal interface Microsoft.FSharp.Text.StructuredPrintfImpl.IEnvironment {
    public int MaxColumns { get; }
    public int MaxRows { get; }
    public abstract virtual Layout GetLayout(object );
    public abstract virtual int get_MaxColumns();
    public abstract virtual int get_MaxRows();
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("33")]
internal abstract class Microsoft.FSharp.Text.StructuredPrintfImpl.Joint : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Joint _unique_Unbreakable;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static Joint Unbreakable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnbreakable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsBreakable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsBroken { get; }
    private static Joint();
    [CompilationMappingAttribute("8", "0")]
internal static Joint get_Unbreakable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnbreakable();
    [CompilationMappingAttribute("8", "1")]
internal static Joint NewBreakable(int _indentation);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsBreakable();
    [CompilationMappingAttribute("8", "2")]
internal static Joint NewBroken(int _indentation);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsBroken();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Joint obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("33")]
internal abstract class Microsoft.FSharp.Text.StructuredPrintfImpl.Layout : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsObjLeaf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLeaf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAttr { get; }
    internal bool JuxtapositionLeft { get; }
    internal bool JuxtapositionRight { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Layout(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static Layout NewObjLeaf(bool _juxtLeft, object _object, bool _juxtRight);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsObjLeaf();
    [CompilationMappingAttribute("8", "1")]
internal static Layout NewLeaf(bool _juxtLeft, TaggedText _text, bool _justRight);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLeaf();
    [CompilationMappingAttribute("8", "2")]
internal static Layout NewNode(Layout _leftLayout, Layout _rightLayout, Joint _joint);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNode();
    [CompilationMappingAttribute("8", "3")]
internal static Layout NewAttr(string _text, FSharpList`1<Tuple`2<string, string>> _attributes, Layout _layout);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAttr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    internal bool get_JuxtapositionLeft();
    internal static bool JuxtapositionMiddle(Layout left, Layout right);
    internal bool get_JuxtapositionRight();
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps : object {
    [CompilationMappingAttribute("9")]
internal static Layout emptyL { get; }
    internal static Layout objL(object value);
    internal static Layout wordL(TaggedText text);
    internal static Layout sepL(TaggedText text);
    internal static Layout rightL(TaggedText text);
    internal static Layout leftL(TaggedText text);
    internal static Layout get_emptyL();
    internal static bool isEmptyL(Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout aboveL(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout tagAttrL(string text, FSharpList`1<Tuple`2<string, string>> maps, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout apply2(FSharpFunc`2<Layout, FSharpFunc`2<Layout, Layout>> f, Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_HatHat(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_PlusPlus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_MinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_MinusMinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_AtAt(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_AtAtMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_AtAtMinusMinus(Layout layout1, Layout layout2);
    internal static Layout process'@262(FSharpFunc`2<Layout, Layout> tagger, Layout prefixL, FSharpList`1<Layout> yl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout tagListL(FSharpFunc`2<Layout, Layout> tagger, FSharpList`1<Layout> els);
    internal static Layout commaListL(FSharpList`1<Layout> layouts);
    internal static Layout semiListL(FSharpList`1<Layout> layouts);
    internal static Layout spaceListL(FSharpList`1<Layout> layouts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout sepListL(Layout layout1, FSharpList`1<Layout> layouts);
    internal static Layout bracketL(Layout layout);
    internal static Layout tupleL(FSharpList`1<Layout> layouts);
    internal static Layout aboveListL(FSharpList`1<Layout> layouts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout optionL(FSharpFunc`2<T, Layout> selector, FSharpOption`1<T> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout listL(FSharpFunc`2<T, Layout> selector, FSharpList`1<T> value);
    internal static Layout squareBracketL(Layout layout);
    internal static Layout braceL(Layout layout);
    internal static FSharpList`1<Layout> consume@307(FSharpFunc`2<a, Layout> itemL, FSharpFunc`2<z, FSharpOption`1<Tuple`2<a, z>>> project, FSharpFunc`2<z, bool> stopShort, int n, z z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Layout> boundedUnfoldL(FSharpFunc`2<a, Layout> itemL, FSharpFunc`2<z, FSharpOption`1<Tuple`2<a, z>>> project, FSharpFunc`2<z, bool> stopShort, z z, int maxLength);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Layout> unfoldL(FSharpFunc`2<T, Layout> selector, FSharpFunc`2<TState, FSharpOption`1<Tuple`2<T, TState>>> folder, TState state, int count);
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("33")]
internal class Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutTag : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_ActivePatternCase;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_ActivePatternResult;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Alias;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Union;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_UnionCase;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Delegate;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Enum;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Event;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Field;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Keyword;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_LineBreak;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Local;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Record;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_RecordField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Method;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Member;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_ModuleBinding;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_NumericLiteral;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Operator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Parameter;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Space;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_StringLiteral;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Struct;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_TypeParameter;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Text;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Punctuation;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_UnknownType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_UnknownEntity;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag ActivePatternCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsActivePatternCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag ActivePatternResult { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsActivePatternResult { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Alias { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAlias { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Union { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag UnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Delegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDelegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Enum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsEnum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Event { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Field { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Keyword { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsKeyword { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag LineBreak { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLineBreak { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Local { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLocal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Record { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag RecordField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsRecordField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Method { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Member { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag ModuleBinding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsModuleBinding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag NumericLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNumericLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Operator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Parameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Space { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSpace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag StringLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStringLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Struct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStruct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag TypeParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTypeParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Text { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsText { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag Punctuation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPunctuation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag UnknownType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnknownType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static LayoutTag UnknownEntity { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnknownEntity { get; }
    private static LayoutTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal LayoutTag(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static LayoutTag get_ActivePatternCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsActivePatternCase();
    [CompilationMappingAttribute("8", "1")]
internal static LayoutTag get_ActivePatternResult();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsActivePatternResult();
    [CompilationMappingAttribute("8", "2")]
internal static LayoutTag get_Alias();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAlias();
    [CompilationMappingAttribute("8", "3")]
internal static LayoutTag get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsClass();
    [CompilationMappingAttribute("8", "4")]
internal static LayoutTag get_Union();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnion();
    [CompilationMappingAttribute("8", "5")]
internal static LayoutTag get_UnionCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCase();
    [CompilationMappingAttribute("8", "6")]
internal static LayoutTag get_Delegate();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDelegate();
    [CompilationMappingAttribute("8", "7")]
internal static LayoutTag get_Enum();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsEnum();
    [CompilationMappingAttribute("8", "8")]
internal static LayoutTag get_Event();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsEvent();
    [CompilationMappingAttribute("8", "9")]
internal static LayoutTag get_Field();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsField();
    [CompilationMappingAttribute("8", "10")]
internal static LayoutTag get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInterface();
    [CompilationMappingAttribute("8", "11")]
internal static LayoutTag get_Keyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsKeyword();
    [CompilationMappingAttribute("8", "12")]
internal static LayoutTag get_LineBreak();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLineBreak();
    [CompilationMappingAttribute("8", "13")]
internal static LayoutTag get_Local();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLocal();
    [CompilationMappingAttribute("8", "14")]
internal static LayoutTag get_Record();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsRecord();
    [CompilationMappingAttribute("8", "15")]
internal static LayoutTag get_RecordField();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsRecordField();
    [CompilationMappingAttribute("8", "16")]
internal static LayoutTag get_Method();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsMethod();
    [CompilationMappingAttribute("8", "17")]
internal static LayoutTag get_Member();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsMember();
    [CompilationMappingAttribute("8", "18")]
internal static LayoutTag get_ModuleBinding();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsModuleBinding();
    [CompilationMappingAttribute("8", "19")]
internal static LayoutTag get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsModule();
    [CompilationMappingAttribute("8", "20")]
internal static LayoutTag get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNamespace();
    [CompilationMappingAttribute("8", "21")]
internal static LayoutTag get_NumericLiteral();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNumericLiteral();
    [CompilationMappingAttribute("8", "22")]
internal static LayoutTag get_Operator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsOperator();
    [CompilationMappingAttribute("8", "23")]
internal static LayoutTag get_Parameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsParameter();
    [CompilationMappingAttribute("8", "24")]
internal static LayoutTag get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsProperty();
    [CompilationMappingAttribute("8", "25")]
internal static LayoutTag get_Space();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSpace();
    [CompilationMappingAttribute("8", "26")]
internal static LayoutTag get_StringLiteral();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStringLiteral();
    [CompilationMappingAttribute("8", "27")]
internal static LayoutTag get_Struct();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStruct();
    [CompilationMappingAttribute("8", "28")]
internal static LayoutTag get_TypeParameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTypeParameter();
    [CompilationMappingAttribute("8", "29")]
internal static LayoutTag get_Text();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsText();
    [CompilationMappingAttribute("8", "30")]
internal static LayoutTag get_Punctuation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPunctuation();
    [CompilationMappingAttribute("8", "31")]
internal static LayoutTag get_UnknownType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnknownType();
    [CompilationMappingAttribute("8", "32")]
internal static LayoutTag get_UnknownEntity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnknownEntity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LayoutTag obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Text.StructuredPrintfImpl.ReflectUtils : object {
    [CompilationMappingAttribute("9")]
internal static Type option { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-1 { get; }
    [CompilationMappingAttribute("9")]
internal static Type func { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@455-2 { get; }
    internal static bool isNamedType(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equivHeadTypes(Type ty1, Type ty2);
    internal static Type get_option();
    internal static Type get_ty@455-1();
    internal static Type get_func();
    internal static Type get_ty@455-2();
    internal static bool isListType(Type ty);
}
[CompilationMappingAttribute("3")]
internal interface Microsoft.FSharp.Text.StructuredPrintfImpl.TaggedText {
    public LayoutTag Tag { get; }
    public string Text { get; }
    public abstract virtual LayoutTag get_Tag();
    public abstract virtual string get_Text();
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Text.StructuredPrintfImpl.TaggedTextOps : object {
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> keywordFunctions { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> keywordTypes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> arg@3859 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedText mkTag(LayoutTag tag, string text);
    internal static TaggedText tagAlias(string t);
    internal static FSharpSet`1<string> get_keywordFunctions();
    internal static FSharpSet`1<string> get_keywordTypes();
    internal static FSharpList`1<string> get_arg@3859();
    internal static TaggedText tagClass(string name);
    internal static TaggedText tagUnionCase(string t);
    internal static TaggedText tagDelegate(string t);
    internal static TaggedText tagEnum(string t);
    internal static TaggedText tagEvent(string t);
    internal static TaggedText tagField(string t);
    internal static TaggedText tagInterface(string t);
    internal static TaggedText tagKeyword(string t);
    internal static TaggedText tagLineBreak(string t);
    internal static TaggedText tagLocal(string t);
    internal static TaggedText tagRecord(string t);
    internal static TaggedText tagRecordField(string t);
    internal static TaggedText tagMethod(string t);
    internal static TaggedText tagModule(string t);
    internal static TaggedText tagModuleBinding(string name);
    internal static TaggedText tagNamespace(string t);
    internal static TaggedText tagNumericLiteral(string t);
    internal static TaggedText tagOperator(string t);
    internal static TaggedText tagParameter(string t);
    internal static TaggedText tagProperty(string t);
    internal static TaggedText tagSpace(string t);
    internal static TaggedText tagStringLiteral(string t);
    internal static TaggedText tagStruct(string t);
    internal static TaggedText tagTypeParameter(string t);
    internal static TaggedText tagText(string t);
    internal static TaggedText tagPunctuation(string t);
}
[CompilationMappingAttribute("3")]
internal interface Microsoft.FSharp.Text.StructuredPrintfImpl.TaggedTextWriter {
    public abstract virtual void Write(TaggedText t);
    public abstract virtual void WriteLine();
}
