public enum Jint.DeclarationBindingType : Enum {
    public int value__;
    public static DeclarationBindingType GlobalCode;
    public static DeclarationBindingType FunctionCode;
    public static DeclarationBindingType EvalCode;
}
public class Jint.Engine : object {
    private ExpressionInterpreter _expressions;
    private StatementInterpreter _statements;
    private Stack`1<ExecutionContext> _executionContexts;
    private JsValue _completionValue;
    private int _statementsCount;
    private long _timeoutTicks;
    private SyntaxNode _lastSyntaxNode;
    public ITypeConverter ClrTypeConverter;
    internal Dictionary`2<string, Type> TypeCache;
    internal static Dictionary`2<Type, Func`3<Engine, object, JsValue>> TypeMappers;
    internal JintCallStack CallStack;
    public LexicalEnvironment GlobalEnvironment;
    [CompilerGeneratedAttribute]
private GlobalObject <Global>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectConstructor <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionConstructor <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayConstructor <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private StringConstructor <String>k__BackingField;
    [CompilerGeneratedAttribute]
private RegExpConstructor <RegExp>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanConstructor <Boolean>k__BackingField;
    [CompilerGeneratedAttribute]
private NumberConstructor <Number>k__BackingField;
    [CompilerGeneratedAttribute]
private DateConstructor <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private MathInstance <Math>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonInstance <Json>k__BackingField;
    [CompilerGeneratedAttribute]
private EvalFunctionInstance <Eval>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorConstructor <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorConstructor <EvalError>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorConstructor <SyntaxError>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorConstructor <TypeError>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorConstructor <RangeError>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorConstructor <ReferenceError>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorConstructor <UriError>k__BackingField;
    [CompilerGeneratedAttribute]
private Options <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugStepDelegate Step;
    [CompilerGeneratedAttribute]
private BreakDelegate Break;
    [CompilerGeneratedAttribute]
private DebugHandler <DebugHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BreakPoint> <BreakPoints>k__BackingField;
    public GlobalObject Global { get; private set; }
    public ObjectConstructor Object { get; private set; }
    public FunctionConstructor Function { get; private set; }
    public ArrayConstructor Array { get; private set; }
    public StringConstructor String { get; private set; }
    public RegExpConstructor RegExp { get; private set; }
    public BooleanConstructor Boolean { get; private set; }
    public NumberConstructor Number { get; private set; }
    public DateConstructor Date { get; private set; }
    public MathInstance Math { get; private set; }
    public JsonInstance Json { get; private set; }
    public EvalFunctionInstance Eval { get; private set; }
    public ErrorConstructor Error { get; private set; }
    public ErrorConstructor EvalError { get; private set; }
    public ErrorConstructor SyntaxError { get; private set; }
    public ErrorConstructor TypeError { get; private set; }
    public ErrorConstructor RangeError { get; private set; }
    public ErrorConstructor ReferenceError { get; private set; }
    public ErrorConstructor UriError { get; private set; }
    public ExecutionContext ExecutionContext { get; }
    internal Options Options { get; private set; }
    internal DebugHandler DebugHandler { get; private set; }
    public List`1<BreakPoint> BreakPoints { get; private set; }
    public Engine(Action`1<Options> options);
    private static Engine();
    [CompilerGeneratedAttribute]
public GlobalObject get_Global();
    [CompilerGeneratedAttribute]
private void set_Global(GlobalObject value);
    [CompilerGeneratedAttribute]
public ObjectConstructor get_Object();
    [CompilerGeneratedAttribute]
private void set_Object(ObjectConstructor value);
    [CompilerGeneratedAttribute]
public FunctionConstructor get_Function();
    [CompilerGeneratedAttribute]
private void set_Function(FunctionConstructor value);
    [CompilerGeneratedAttribute]
public ArrayConstructor get_Array();
    [CompilerGeneratedAttribute]
private void set_Array(ArrayConstructor value);
    [CompilerGeneratedAttribute]
public StringConstructor get_String();
    [CompilerGeneratedAttribute]
private void set_String(StringConstructor value);
    [CompilerGeneratedAttribute]
public RegExpConstructor get_RegExp();
    [CompilerGeneratedAttribute]
private void set_RegExp(RegExpConstructor value);
    [CompilerGeneratedAttribute]
public BooleanConstructor get_Boolean();
    [CompilerGeneratedAttribute]
private void set_Boolean(BooleanConstructor value);
    [CompilerGeneratedAttribute]
public NumberConstructor get_Number();
    [CompilerGeneratedAttribute]
private void set_Number(NumberConstructor value);
    [CompilerGeneratedAttribute]
public DateConstructor get_Date();
    [CompilerGeneratedAttribute]
private void set_Date(DateConstructor value);
    [CompilerGeneratedAttribute]
public MathInstance get_Math();
    [CompilerGeneratedAttribute]
private void set_Math(MathInstance value);
    [CompilerGeneratedAttribute]
public JsonInstance get_Json();
    [CompilerGeneratedAttribute]
private void set_Json(JsonInstance value);
    [CompilerGeneratedAttribute]
public EvalFunctionInstance get_Eval();
    [CompilerGeneratedAttribute]
private void set_Eval(EvalFunctionInstance value);
    [CompilerGeneratedAttribute]
public ErrorConstructor get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(ErrorConstructor value);
    [CompilerGeneratedAttribute]
public ErrorConstructor get_EvalError();
    [CompilerGeneratedAttribute]
private void set_EvalError(ErrorConstructor value);
    [CompilerGeneratedAttribute]
public ErrorConstructor get_SyntaxError();
    [CompilerGeneratedAttribute]
private void set_SyntaxError(ErrorConstructor value);
    [CompilerGeneratedAttribute]
public ErrorConstructor get_TypeError();
    [CompilerGeneratedAttribute]
private void set_TypeError(ErrorConstructor value);
    [CompilerGeneratedAttribute]
public ErrorConstructor get_RangeError();
    [CompilerGeneratedAttribute]
private void set_RangeError(ErrorConstructor value);
    [CompilerGeneratedAttribute]
public ErrorConstructor get_ReferenceError();
    [CompilerGeneratedAttribute]
private void set_ReferenceError(ErrorConstructor value);
    [CompilerGeneratedAttribute]
public ErrorConstructor get_UriError();
    [CompilerGeneratedAttribute]
private void set_UriError(ErrorConstructor value);
    public ExecutionContext get_ExecutionContext();
    [CompilerGeneratedAttribute]
internal Options get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(Options value);
    [CompilerGeneratedAttribute]
public void add_Step(DebugStepDelegate value);
    [CompilerGeneratedAttribute]
public void remove_Step(DebugStepDelegate value);
    [CompilerGeneratedAttribute]
public void add_Break(BreakDelegate value);
    [CompilerGeneratedAttribute]
public void remove_Break(BreakDelegate value);
    [CompilerGeneratedAttribute]
internal DebugHandler get_DebugHandler();
    [CompilerGeneratedAttribute]
private void set_DebugHandler(DebugHandler value);
    [CompilerGeneratedAttribute]
public List`1<BreakPoint> get_BreakPoints();
    [CompilerGeneratedAttribute]
private void set_BreakPoints(List`1<BreakPoint> value);
    internal Nullable`1<StepMode> InvokeStepEvent(DebugInformation info);
    internal Nullable`1<StepMode> InvokeBreakEvent(DebugInformation info);
    public ExecutionContext EnterExecutionContext(LexicalEnvironment lexicalEnvironment, LexicalEnvironment variableEnvironment, JsValue thisBinding);
    public Engine SetValue(string name, Delegate value);
    public Engine SetValue(string name, string value);
    public Engine SetValue(string name, double value);
    public Engine SetValue(string name, bool value);
    public Engine SetValue(string name, JsValue value);
    public Engine SetValue(string name, object obj);
    public void LeaveExecutionContext();
    public void ResetStatementsCount();
    public void ResetTimeoutTicks();
    public void ResetCallStack();
    public Engine Execute(string source);
    public Engine Execute(string source, ParserOptions parserOptions);
    public Engine Execute(Program program);
    private void ResetLastStatement();
    public JsValue GetCompletionValue();
    public Completion ExecuteStatement(Statement statement);
    public object EvaluateExpression(Expression expression);
    public JsValue GetValue(object value);
    public void PutValue(Reference reference, JsValue value);
    public void PutPrimitiveBase(JsValue b, string name, JsValue value, bool throwOnError);
    public JsValue Invoke(string propertyName, Object[] arguments);
    public JsValue Invoke(string propertyName, object thisObj, Object[] arguments);
    public JsValue Invoke(JsValue value, Object[] arguments);
    public JsValue Invoke(JsValue value, object thisObj, Object[] arguments);
    public JsValue GetValue(string propertyName);
    public SyntaxNode GetLastSyntaxNode();
    public JsValue GetValue(JsValue scope, string propertyName);
    public void DeclarationBindingInstantiation(DeclarationBindingType declarationBindingType, IList`1<FunctionDeclaration> functionDeclarations, IList`1<VariableDeclaration> variableDeclarations, FunctionInstance functionInstance, JsValue[] arguments);
    [CompilerGeneratedAttribute]
private JsValue <.ctor>b__12_0(JsValue thisObj, JsValue[] arguments);
    [CompilerGeneratedAttribute]
private JsValue <Invoke>b__138_0(object x);
}
public class Jint.EvalCodeScope : object {
    private bool _eval;
    private bool _force;
    private int _forcedRefCount;
    [ThreadStaticAttribute]
private static int _refCount;
    public static bool IsEvalCode { get; }
    public static int RefCount { get; public set; }
    public EvalCodeScope(bool eval, bool force);
    public sealed virtual void Dispose();
    public static bool get_IsEvalCode();
    public static int get_RefCount();
    public static void set_RefCount(int value);
}
public class Jint.Native.Argument.ArgumentsInstance : ObjectInstance {
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    private Action`1<ArgumentsInstance> _initializer;
    private bool _initialized;
    [CompilerGeneratedAttribute]
private ObjectInstance <ParameterMap>k__BackingField;
    public bool Strict { get; public set; }
    public ObjectInstance ParameterMap { get; public set; }
    public string Class { get; }
    private ArgumentsInstance(Engine engine, Action`1<ArgumentsInstance> initializer);
    [CompilerGeneratedAttribute]
public bool get_Strict();
    [CompilerGeneratedAttribute]
public void set_Strict(bool value);
    protected virtual void EnsureInitialized();
    public static ArgumentsInstance CreateArgumentsObject(Engine engine, FunctionInstance func, String[] names, JsValue[] args, EnvironmentRecord env, bool strict);
    [CompilerGeneratedAttribute]
public ObjectInstance get_ParameterMap();
    [CompilerGeneratedAttribute]
public void set_ParameterMap(ObjectInstance value);
    public virtual string get_Class();
    public virtual PropertyDescriptor GetOwnProperty(string propertyName);
    public virtual void Put(string propertyName, JsValue value, bool throwOnError);
    public virtual bool DefineOwnProperty(string propertyName, PropertyDescriptor desc, bool throwOnError);
    public virtual bool Delete(string propertyName, bool throwOnError);
}
public class Jint.Native.Array.ArrayConstructor : FunctionInstance {
    [CompilerGeneratedAttribute]
private ArrayPrototype <PrototypeObject>k__BackingField;
    public ArrayPrototype PrototypeObject { get; private set; }
    private ArrayConstructor(Engine engine);
    [CompilerGeneratedAttribute]
public ArrayPrototype get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(ArrayPrototype value);
    public static ArrayConstructor CreateArrayConstructor(Engine engine);
    public void Configure();
    private JsValue IsArray(JsValue thisObj, JsValue[] arguments);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
}
public class Jint.Native.Array.ArrayInstance : ObjectInstance {
    private Engine _engine;
    private IDictionary`2<UInt32, PropertyDescriptor> _array;
    private PropertyDescriptor _length;
    public string Class { get; }
    public ArrayInstance(Engine engine);
    public virtual string get_Class();
    public virtual void Put(string propertyName, JsValue value, bool throwOnError);
    public virtual bool DefineOwnProperty(string propertyName, PropertyDescriptor desc, bool throwOnError);
    public UInt32 GetLength();
    [IteratorStateMachineAttribute("Jint.Native.Array.ArrayInstance/<GetOwnProperties>d__9")]
public virtual IEnumerable`1<KeyValuePair`2<string, PropertyDescriptor>> GetOwnProperties();
    public virtual PropertyDescriptor GetOwnProperty(string propertyName);
    protected virtual void SetOwnProperty(string propertyName, PropertyDescriptor desc);
    public virtual bool HasOwnProperty(string p);
    public virtual void RemoveOwnProperty(string p);
    public static bool IsArrayIndex(JsValue p, UInt32& index);
    internal static UInt32 ParseArrayIndex(string p);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<KeyValuePair`2<string, PropertyDescriptor>> <>n__0();
}
public class Jint.Native.Array.ArrayPrototype : ArrayInstance {
    private ArrayPrototype(Engine engine);
    public static ArrayPrototype CreatePrototypeObject(Engine engine, ArrayConstructor arrayConstructor);
    public void Configure();
    private JsValue LastIndexOf(JsValue thisObj, JsValue[] arguments);
    private JsValue Reduce(JsValue thisObj, JsValue[] arguments);
    private JsValue Filter(JsValue thisObj, JsValue[] arguments);
    private JsValue Map(JsValue thisObj, JsValue[] arguments);
    private JsValue ForEach(JsValue thisObj, JsValue[] arguments);
    private JsValue Some(JsValue thisObj, JsValue[] arguments);
    private JsValue Every(JsValue thisObj, JsValue[] arguments);
    private JsValue IndexOf(JsValue thisObj, JsValue[] arguments);
    private JsValue Splice(JsValue thisObj, JsValue[] arguments);
    private JsValue Unshift(JsValue thisObj, JsValue[] arguments);
    private JsValue Sort(JsValue thisObj, JsValue[] arguments);
    private JsValue Slice(JsValue thisObj, JsValue[] arguments);
    private JsValue Shift(JsValue thisObj, JsValue[] arg2);
    private JsValue Reverse(JsValue thisObj, JsValue[] arguments);
    private JsValue Join(JsValue thisObj, JsValue[] arguments);
    private JsValue ToLocaleString(JsValue thisObj, JsValue[] arguments);
    private JsValue Concat(JsValue thisObj, JsValue[] arguments);
    private JsValue ToString(JsValue thisObj, JsValue[] arguments);
    private JsValue ReduceRight(JsValue thisObj, JsValue[] arguments);
    public JsValue Push(JsValue thisObject, JsValue[] arguments);
    public JsValue Pop(JsValue thisObject, JsValue[] arguments);
    [CompilerGeneratedAttribute]
private void <Reduce>b__4_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <Filter>b__5_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <Map>b__6_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <ForEach>b__7_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <Some>b__8_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <Every>b__9_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <Sort>b__13_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <ToLocaleString>b__18_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <ToLocaleString>b__18_1(JsValue x);
    [CompilerGeneratedAttribute]
private void <ReduceRight>b__21_0(JsValue x);
}
public class Jint.Native.Boolean.BooleanConstructor : FunctionInstance {
    [CompilerGeneratedAttribute]
private BooleanPrototype <PrototypeObject>k__BackingField;
    public BooleanPrototype PrototypeObject { get; private set; }
    private BooleanConstructor(Engine engine);
    public static BooleanConstructor CreateBooleanConstructor(Engine engine);
    public void Configure();
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    [CompilerGeneratedAttribute]
public BooleanPrototype get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(BooleanPrototype value);
    public BooleanInstance Construct(bool value);
}
public class Jint.Native.Boolean.BooleanInstance : ObjectInstance {
    [CompilerGeneratedAttribute]
private JsValue <PrimitiveValue>k__BackingField;
    public string Class { get; }
    private Types Jint.Native.IPrimitiveInstance.Type { get; }
    private JsValue Jint.Native.IPrimitiveInstance.PrimitiveValue { get; }
    public JsValue PrimitiveValue { get; public set; }
    public BooleanInstance(Engine engine);
    public virtual string get_Class();
    private sealed virtual override Types Jint.Native.IPrimitiveInstance.get_Type();
    private sealed virtual override JsValue Jint.Native.IPrimitiveInstance.get_PrimitiveValue();
    [CompilerGeneratedAttribute]
public JsValue get_PrimitiveValue();
    [CompilerGeneratedAttribute]
public void set_PrimitiveValue(JsValue value);
}
public class Jint.Native.Boolean.BooleanPrototype : BooleanInstance {
    private BooleanPrototype(Engine engine);
    public static BooleanPrototype CreatePrototypeObject(Engine engine, BooleanConstructor booleanConstructor);
    public void Configure();
    private JsValue ValueOf(JsValue thisObj, JsValue[] arguments);
    private JsValue ToBooleanString(JsValue thisObj, JsValue[] arguments);
}
public class Jint.Native.Date.DateConstructor : FunctionInstance {
    internal static DateTime Epoch;
    [CompilerGeneratedAttribute]
private DatePrototype <PrototypeObject>k__BackingField;
    public DatePrototype PrototypeObject { get; private set; }
    public DateConstructor(Engine engine);
    private static DateConstructor();
    public static DateConstructor CreateDateConstructor(Engine engine);
    public void Configure();
    private JsValue Parse(JsValue thisObj, JsValue[] arguments);
    private JsValue Utc(JsValue thisObj, JsValue[] arguments);
    private JsValue Now(JsValue thisObj, JsValue[] arguments);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    private double ConstructTimeValue(JsValue[] arguments, bool useUtc);
    [CompilerGeneratedAttribute]
public DatePrototype get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(DatePrototype value);
    public DateInstance Construct(DateTimeOffset value);
    public DateInstance Construct(DateTime value);
    public DateInstance Construct(double time);
    public static double TimeClip(double time);
    public double FromDateTime(DateTime dt);
}
public class Jint.Native.Date.DateInstance : ObjectInstance {
    internal static double Max;
    internal static double Min;
    [CompilerGeneratedAttribute]
private double <PrimitiveValue>k__BackingField;
    public string Class { get; }
    public double PrimitiveValue { get; public set; }
    public DateInstance(Engine engine);
    private static DateInstance();
    public virtual string get_Class();
    public DateTime ToDateTime();
    [CompilerGeneratedAttribute]
public double get_PrimitiveValue();
    [CompilerGeneratedAttribute]
public void set_PrimitiveValue(double value);
}
public class Jint.Native.Date.DatePrototype : DateInstance {
    public static double HoursPerDay;
    public static double MinutesPerHour;
    public static double SecondsPerMinute;
    public static double MsPerSecond;
    public static double MsPerMinute;
    public static double MsPerHour;
    public static double MsPerDay;
    public double LocalTza { get; }
    private DatePrototype(Engine engine);
    public static DatePrototype CreatePrototypeObject(Engine engine, DateConstructor dateConstructor);
    public void Configure();
    private JsValue ValueOf(JsValue thisObj, JsValue[] arguments);
    private DateInstance EnsureDateInstance(JsValue thisObj);
    public JsValue ToString(JsValue thisObj, JsValue[] arg2);
    private JsValue ToDateString(JsValue thisObj, JsValue[] arguments);
    private JsValue ToTimeString(JsValue thisObj, JsValue[] arguments);
    private JsValue ToLocaleString(JsValue thisObj, JsValue[] arguments);
    private JsValue ToLocaleDateString(JsValue thisObj, JsValue[] arguments);
    private JsValue ToLocaleTimeString(JsValue thisObj, JsValue[] arguments);
    private JsValue GetTime(JsValue thisObj, JsValue[] arguments);
    private JsValue GetFullYear(JsValue thisObj, JsValue[] arguments);
    private JsValue GetYear(JsValue thisObj, JsValue[] arguments);
    private JsValue GetUTCFullYear(JsValue thisObj, JsValue[] arguments);
    private JsValue GetMonth(JsValue thisObj, JsValue[] arguments);
    private JsValue GetUTCMonth(JsValue thisObj, JsValue[] arguments);
    private JsValue GetDate(JsValue thisObj, JsValue[] arguments);
    private JsValue GetUTCDate(JsValue thisObj, JsValue[] arguments);
    private JsValue GetDay(JsValue thisObj, JsValue[] arguments);
    private JsValue GetUTCDay(JsValue thisObj, JsValue[] arguments);
    private JsValue GetHours(JsValue thisObj, JsValue[] arguments);
    private JsValue GetUTCHours(JsValue thisObj, JsValue[] arguments);
    private JsValue GetMinutes(JsValue thisObj, JsValue[] arguments);
    private JsValue GetUTCMinutes(JsValue thisObj, JsValue[] arguments);
    private JsValue GetSeconds(JsValue thisObj, JsValue[] arguments);
    private JsValue GetUTCSeconds(JsValue thisObj, JsValue[] arguments);
    private JsValue GetMilliseconds(JsValue thisObj, JsValue[] arguments);
    private JsValue GetUTCMilliseconds(JsValue thisObj, JsValue[] arguments);
    private JsValue GetTimezoneOffset(JsValue thisObj, JsValue[] arguments);
    private JsValue SetTime(JsValue thisObj, JsValue[] arguments);
    private JsValue SetMilliseconds(JsValue thisObj, JsValue[] arguments);
    private JsValue SetUTCMilliseconds(JsValue thisObj, JsValue[] arguments);
    private JsValue SetSeconds(JsValue thisObj, JsValue[] arguments);
    private JsValue SetUTCSeconds(JsValue thisObj, JsValue[] arguments);
    private JsValue SetMinutes(JsValue thisObj, JsValue[] arguments);
    private JsValue SetUTCMinutes(JsValue thisObj, JsValue[] arguments);
    private JsValue SetHours(JsValue thisObj, JsValue[] arguments);
    private JsValue SetUTCHours(JsValue thisObj, JsValue[] arguments);
    private JsValue SetDate(JsValue thisObj, JsValue[] arguments);
    private JsValue SetUTCDate(JsValue thisObj, JsValue[] arguments);
    private JsValue SetMonth(JsValue thisObj, JsValue[] arguments);
    private JsValue SetUTCMonth(JsValue thisObj, JsValue[] arguments);
    private JsValue SetFullYear(JsValue thisObj, JsValue[] arguments);
    private JsValue SetYear(JsValue thisObj, JsValue[] arguments);
    private JsValue SetUTCFullYear(JsValue thisObj, JsValue[] arguments);
    private JsValue ToUtcString(JsValue thisObj, JsValue[] arguments);
    private JsValue ToISOString(JsValue thisObj, JsValue[] arguments);
    private JsValue ToJSON(JsValue thisObj, JsValue[] arguments);
    public static double Day(double t);
    public static double TimeWithinDay(double t);
    public static double DaysInYear(double y);
    public static double DayFromYear(double y);
    public static double TimeFromYear(double y);
    public static double YearFromTime(double t);
    public static double InLeapYear(double t);
    public static double MonthFromTime(double t);
    public static double DayWithinYear(double t);
    public static double DateFromTime(double t);
    public static double WeekDay(double t);
    public double get_LocalTza();
    public double DaylightSavingTa(double t);
    public DateTimeOffset ToLocalTime(DateTime t);
    public double LocalTime(double t);
    public double Utc(double t);
    public static double HourFromTime(double t);
    public static double MinFromTime(double t);
    public static double SecFromTime(double t);
    public static double MsFromTime(double t);
    public static double DayFromMonth(double year, double month);
    public static double DaysInMonth(double month, double leap);
    public static double MakeTime(double hour, double min, double sec, double ms);
    public static double MakeDay(double year, double month, double date);
    public static double MakeDate(double day, double time);
    public static double TimeClip(double time);
    private static bool AreFinite(Double[] values);
    [CompilerGeneratedAttribute]
private void <EnsureDateInstance>b__4_0(JsValue value);
    [CompilerGeneratedAttribute]
private void <ToUtcString>b__46_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <ToISOString>b__47_0(JsValue x);
}
public class Jint.Native.Error.ErrorConstructor : FunctionInstance {
    private string _name;
    [CompilerGeneratedAttribute]
private ErrorPrototype <PrototypeObject>k__BackingField;
    public ErrorPrototype PrototypeObject { get; private set; }
    public ErrorConstructor(Engine engine);
    public static ErrorConstructor CreateErrorConstructor(Engine engine, string name);
    public void Configure();
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    [CompilerGeneratedAttribute]
public ErrorPrototype get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(ErrorPrototype value);
}
public class Jint.Native.Error.ErrorInstance : ObjectInstance {
    public string Class { get; }
    public ErrorInstance(Engine engine, string name);
    public virtual string get_Class();
    public virtual string ToString();
}
public class Jint.Native.Error.ErrorPrototype : ErrorInstance {
    private ErrorPrototype(Engine engine, string name);
    public static ErrorPrototype CreatePrototypeObject(Engine engine, ErrorConstructor errorConstructor, string name);
    public void Configure();
    public JsValue ToString(JsValue thisObject, JsValue[] arguments);
}
public class Jint.Native.Function.BindFunctionInstance : FunctionInstance {
    [CompilerGeneratedAttribute]
private JsValue <TargetFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private JsValue <BoundThis>k__BackingField;
    [CompilerGeneratedAttribute]
private JsValue[] <BoundArgs>k__BackingField;
    public JsValue TargetFunction { get; public set; }
    public JsValue BoundThis { get; public set; }
    public JsValue[] BoundArgs { get; public set; }
    public BindFunctionInstance(Engine engine);
    [CompilerGeneratedAttribute]
public JsValue get_TargetFunction();
    [CompilerGeneratedAttribute]
public void set_TargetFunction(JsValue value);
    [CompilerGeneratedAttribute]
public JsValue get_BoundThis();
    [CompilerGeneratedAttribute]
public void set_BoundThis(JsValue value);
    [CompilerGeneratedAttribute]
public JsValue[] get_BoundArgs();
    [CompilerGeneratedAttribute]
public void set_BoundArgs(JsValue[] value);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    public virtual bool HasInstance(JsValue v);
    [CompilerGeneratedAttribute]
private void <Call>b__13_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <Construct>b__14_0(JsValue x);
    [CompilerGeneratedAttribute]
private void <HasInstance>b__15_0(JsValue x);
}
public class Jint.Native.Function.EvalFunctionInstance : FunctionInstance {
    private Engine _engine;
    public EvalFunctionInstance(Engine engine, String[] parameters, LexicalEnvironment scope, bool strict);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public JsValue Call(JsValue thisObject, JsValue[] arguments, bool directCall);
}
public class Jint.Native.Function.FunctionConstructor : FunctionInstance {
    [CompilerGeneratedAttribute]
private FunctionPrototype <PrototypeObject>k__BackingField;
    private FunctionInstance _throwTypeError;
    public FunctionPrototype PrototypeObject { get; private set; }
    public FunctionInstance ThrowTypeError { get; }
    private FunctionConstructor(Engine engine);
    public static FunctionConstructor CreateFunctionConstructor(Engine engine);
    public void Configure();
    [CompilerGeneratedAttribute]
public FunctionPrototype get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(FunctionPrototype value);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    private String[] ParseArgumentNames(string parameterDeclaration);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    public FunctionInstance CreateFunctionObject(FunctionDeclaration functionDeclaration);
    public FunctionInstance get_ThrowTypeError();
    public object Apply(JsValue thisObject, JsValue[] arguments);
}
public abstract class Jint.Native.Function.FunctionInstance : ObjectInstance {
    private Engine _engine;
    [CompilerGeneratedAttribute]
private LexicalEnvironment <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FormalParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    public LexicalEnvironment Scope { get; private set; }
    public String[] FormalParameters { get; private set; }
    public bool Strict { get; private set; }
    public string Class { get; }
    protected FunctionInstance(Engine engine, String[] parameters, LexicalEnvironment scope, bool strict);
    public abstract virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    [CompilerGeneratedAttribute]
public LexicalEnvironment get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(LexicalEnvironment value);
    [CompilerGeneratedAttribute]
public String[] get_FormalParameters();
    [CompilerGeneratedAttribute]
private void set_FormalParameters(String[] value);
    [CompilerGeneratedAttribute]
public bool get_Strict();
    [CompilerGeneratedAttribute]
private void set_Strict(bool value);
    public virtual bool HasInstance(JsValue v);
    public virtual string get_Class();
    public virtual JsValue Get(string propertyName);
}
public class Jint.Native.Function.FunctionPrototype : FunctionInstance {
    private FunctionPrototype(Engine engine);
    public static FunctionPrototype CreatePrototypeObject(Engine engine);
    public void Configure();
    private JsValue Bind(JsValue thisObj, JsValue[] arguments);
    private JsValue ToString(JsValue thisObj, JsValue[] arguments);
    public JsValue Apply(JsValue thisObject, JsValue[] arguments);
    public JsValue CallImpl(JsValue thisObject, JsValue[] arguments);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    [CompilerGeneratedAttribute]
private void <Bind>b__3_0(JsValue x);
}
public class Jint.Native.Function.FunctionShim : FunctionInstance {
    public FunctionShim(Engine engine, String[] parameters, LexicalEnvironment scope);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
}
public class Jint.Native.Function.ScriptFunctionInstance : FunctionInstance {
    private IFunctionDeclaration _functionDeclaration;
    [CompilerGeneratedAttribute]
private ObjectInstance <PrototypeObject>k__BackingField;
    public ObjectInstance PrototypeObject { get; private set; }
    public ScriptFunctionInstance(Engine engine, IFunctionDeclaration functionDeclaration, LexicalEnvironment scope, bool strict);
    public virtual JsValue Call(JsValue thisArg, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    [CompilerGeneratedAttribute]
public ObjectInstance get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(ObjectInstance value);
}
public class Jint.Native.Function.ThrowTypeError : FunctionInstance {
    private Engine _engine;
    public ThrowTypeError(Engine engine);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
}
public class Jint.Native.Global.GlobalObject : ObjectInstance {
    private static Char[] UriReserved;
    private static Char[] UriUnescaped;
    private static string HexaMap;
    private GlobalObject(Engine engine);
    private static GlobalObject();
    public static GlobalObject CreateGlobalObject(Engine engine);
    public void Configure();
    public static JsValue ParseInt(JsValue thisObject, JsValue[] arguments);
    private static JsValue Parse(string number, int radix);
    public static JsValue ParseFloat(JsValue thisObject, JsValue[] arguments);
    public static JsValue IsNaN(JsValue thisObject, JsValue[] arguments);
    public static JsValue IsFinite(JsValue thisObject, JsValue[] arguments);
    private static bool IsValidHexaChar(char c);
    public JsValue EncodeUri(JsValue thisObject, JsValue[] arguments);
    public JsValue EncodeUriComponent(JsValue thisObject, JsValue[] arguments);
    private string Encode(string uriString, Char[] unescapedUriSet);
    public JsValue DecodeUri(JsValue thisObject, JsValue[] arguments);
    public JsValue DecodeUriComponent(JsValue thisObject, JsValue[] arguments);
    public string Decode(string uriString, Char[] reservedSet);
    public JsValue Escape(JsValue thisObject, JsValue[] arguments);
    public JsValue Unescape(JsValue thisObject, JsValue[] arguments);
}
public interface Jint.Native.ICallable {
    public abstract virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
}
public interface Jint.Native.IConstructor {
    public abstract virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public abstract virtual ObjectInstance Construct(JsValue[] arguments);
}
public interface Jint.Native.IPrimitiveInstance {
    public Types Type { get; }
    public JsValue PrimitiveValue { get; }
    public abstract virtual Types get_Type();
    public abstract virtual JsValue get_PrimitiveValue();
}
public class Jint.Native.Json.JsonInstance : ObjectInstance {
    private Engine _engine;
    public string Class { get; }
    private JsonInstance(Engine engine);
    public virtual string get_Class();
    public static JsonInstance CreateJsonObject(Engine engine);
    public void Configure();
    public JsValue Parse(JsValue thisObject, JsValue[] arguments);
    public JsValue Stringify(JsValue thisObject, JsValue[] arguments);
}
public class Jint.Native.Json.JsonParser : object {
    private Engine _engine;
    private Extra _extra;
    private int _index;
    private int _length;
    private int _lineNumber;
    private int _lineStart;
    private Location _location;
    private Token _lookahead;
    private string _source;
    private State _state;
    public JsonParser(Engine engine);
    private static bool IsDecimalDigit(char ch);
    private static bool IsHexDigit(char ch);
    private static bool IsOctalDigit(char ch);
    private static bool IsWhiteSpace(char ch);
    private static bool IsLineTerminator(char ch);
    private static bool IsNullChar(char ch);
    private static bool IsTrueOrFalseChar(char ch);
    private char ScanHexEscape(char prefix);
    private void SkipWhiteSpace();
    private Token ScanPunctuator();
    private Token ScanNumericLiteral();
    private Token ScanBooleanLiteral();
    private Token ScanNullLiteral();
    private Token ScanStringLiteral();
    private Token Advance();
    private Token CollectToken();
    private Token Lex();
    private void Peek();
    private void MarkStart();
    private T MarkEnd(T node);
    public T MarkEndIf(T node);
    public SyntaxNode PostProcess(SyntaxNode node);
    public ObjectInstance CreateArrayInstance(IEnumerable`1<JsValue> values);
    private void ThrowError(Token token, string messageFormat, Object[] arguments);
    private void ThrowUnexpected(Token token);
    private void Expect(string value);
    private bool Match(string value);
    private ObjectInstance ParseJsonArray();
    public ObjectInstance ParseJsonObject();
    private bool PropertyNameContainsInvalidChar0To31(string s);
    private JsValue ParseJsonValue();
    public JsValue Parse(string code);
    public JsValue Parse(string code, ParserOptions options);
}
public class Jint.Native.Json.JsonSerializer : object {
    private Engine _engine;
    private Stack`1<object> _stack;
    private string _indent;
    private string _gap;
    private List`1<string> _propertyList;
    private JsValue _replacerFunction;
    public JsonSerializer(Engine engine);
    public JsValue Serialize(JsValue value, JsValue replacer, JsValue space);
    private JsValue Str(string key, ObjectInstance holder);
    private string Quote(string value);
    private string SerializeArray(ArrayInstance value);
    private void EnsureNonCyclicity(object value);
    private string SerializeObject(ObjectInstance value);
}
[DebuggerTypeProxyAttribute("Jint.Native.JsValue/JsValueDebugView")]
public class Jint.Native.JsValue : object {
    public static JsValue Undefined;
    public static JsValue Null;
    public static JsValue False;
    public static JsValue True;
    private double _double;
    private object _object;
    private Types _type;
    public Types Type { get; }
    public JsValue(bool value);
    public JsValue(double value);
    public JsValue(string value);
    public JsValue(ObjectInstance value);
    private JsValue(Types type);
    private static JsValue();
    public bool IsPrimitive();
    public bool IsUndefined();
    public bool IsArray();
    public bool IsDate();
    public bool IsRegExp();
    public bool IsObject();
    public bool IsString();
    public bool IsNumber();
    public bool IsBoolean();
    public bool IsNull();
    public ObjectInstance AsObject();
    public ArrayInstance AsArray();
    public DateInstance AsDate();
    public RegExpInstance AsRegExp();
    public T TryCast(Action`1<JsValue> fail);
    public bool Is();
    public T As();
    public bool AsBoolean();
    public string AsString();
    public double AsNumber();
    public sealed virtual bool Equals(JsValue other);
    public Types get_Type();
    public static JsValue FromObject(Engine engine, object value);
    public object ToObject();
    public JsValue Invoke(JsValue[] arguments);
    public JsValue Invoke(JsValue thisObj, JsValue[] arguments);
    public virtual string ToString();
    public static bool op_Equality(JsValue a, JsValue b);
    public static bool op_Inequality(JsValue a, JsValue b);
    public static JsValue op_Implicit(double value);
    public static JsValue op_Implicit(bool value);
    public static JsValue op_Implicit(string value);
    public static JsValue op_Implicit(ObjectInstance value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Jint.Native.Math.MathInstance : ObjectInstance {
    private static Random _random;
    public string Class { get; }
    private MathInstance(Engine engine);
    private static MathInstance();
    public virtual string get_Class();
    public static MathInstance CreateMathObject(Engine engine);
    public void Configure();
    private static JsValue Abs(JsValue thisObject, JsValue[] arguments);
    private static JsValue Acos(JsValue thisObject, JsValue[] arguments);
    private static JsValue Asin(JsValue thisObject, JsValue[] arguments);
    private static JsValue Atan(JsValue thisObject, JsValue[] arguments);
    private static JsValue Atan2(JsValue thisObject, JsValue[] arguments);
    private static JsValue Ceil(JsValue thisObject, JsValue[] arguments);
    private static JsValue Cos(JsValue thisObject, JsValue[] arguments);
    private static JsValue Exp(JsValue thisObject, JsValue[] arguments);
    private static JsValue Floor(JsValue thisObject, JsValue[] arguments);
    private static JsValue Log(JsValue thisObject, JsValue[] arguments);
    private static JsValue Max(JsValue thisObject, JsValue[] arguments);
    private static JsValue Min(JsValue thisObject, JsValue[] arguments);
    private static JsValue Pow(JsValue thisObject, JsValue[] arguments);
    private static JsValue Random(JsValue thisObject, JsValue[] arguments);
    private static JsValue Round(JsValue thisObject, JsValue[] arguments);
    private static JsValue Sin(JsValue thisObject, JsValue[] arguments);
    private static JsValue Sqrt(JsValue thisObject, JsValue[] arguments);
    private static JsValue Tan(JsValue thisObject, JsValue[] arguments);
}
public static class Jint.Native.Null : object {
    public static JsValue Instance;
    public static string Text;
    private static Null();
}
public class Jint.Native.Number.Dtoa.CachedPowers : object {
    private static double Kd1Log210;
    private static int CachedPowersSpacing;
    private static CachedPower[] CACHED_POWERS;
    private static int GrisuCacheOffset;
    private static CachedPowers();
    internal static int GetCachedPower(int e, int alpha, int gamma, DiyFp cMk);
}
internal class Jint.Native.Number.Dtoa.DiyFp : object {
    internal static int KSignificandSize;
    private static ulong KUint64MSB;
    [CompilerGeneratedAttribute]
private long <F>k__BackingField;
    [CompilerGeneratedAttribute]
private int <E>k__BackingField;
    public long F { get; public set; }
    public int E { get; public set; }
    internal DiyFp(long f, int e);
    [CompilerGeneratedAttribute]
public long get_F();
    [CompilerGeneratedAttribute]
public void set_F(long value);
    [CompilerGeneratedAttribute]
public int get_E();
    [CompilerGeneratedAttribute]
public void set_E(int value);
    private static bool Uint64Gte(long a, long b);
    private void Subtract(DiyFp other);
    internal static DiyFp Minus(DiyFp a, DiyFp b);
    private void Multiply(DiyFp other);
    internal static DiyFp Times(DiyFp a, DiyFp b);
    internal void Normalize();
    public virtual string ToString();
}
public class Jint.Native.Number.Dtoa.DoubleHelper : object {
    private static long KExponentMask;
    private static long KSignificandMask;
    private static long KHiddenBit;
    private static int KSignificandSize;
    private static int KExponentBias;
    private static int KDenormalExponent;
    private static DiyFp AsDiyFp(long d64);
    internal static DiyFp AsNormalizedDiyFp(long d64);
    private static int Exponent(long d64);
    private static long Significand(long d64);
    private static bool IsDenormal(long d64);
    private static bool IsSpecial(long d64);
    internal static void NormalizedBoundaries(long d64, DiyFp mMinus, DiyFp mPlus);
}
public class Jint.Native.Number.Dtoa.FastDtoa : object {
    public static int KFastDtoaMaximalLength;
    private static int MinimalTargetExponent;
    private static int MaximalTargetExponent;
    private static int KTen4;
    private static int KTen5;
    private static int KTen6;
    private static int KTen7;
    private static int KTen8;
    private static int KTen9;
    private static bool RoundWeed(FastDtoaBuilder buffer, long distanceTooHighW, long unsafeInterval, long rest, long tenKappa, long unit);
    private static long BiggestPowerTen(int number, int numberBits);
    private static bool DigitGen(DiyFp low, DiyFp w, DiyFp high, FastDtoaBuilder buffer, int mk);
    private static bool Grisu3(double v, FastDtoaBuilder buffer);
    public static bool Dtoa(double v, FastDtoaBuilder buffer);
    public static string NumberToString(double v);
    public static bool NumberToString(double v, FastDtoaBuilder buffer);
}
public class Jint.Native.Number.Dtoa.FastDtoaBuilder : object {
    private Char[] _chars;
    internal int End;
    internal int Point;
    private bool _formatted;
    private static Char[] Digits;
    private static FastDtoaBuilder();
    internal void Append(char c);
    internal void DecreaseLast();
    public void Reset();
    public virtual string ToString();
    public string Format();
    private void ToFixedFormat(int firstDigit, int decPoint);
    private void ToExponentialFormat(int firstDigit, int decPoint);
    private void Fill(T[] array, int fromIndex, int toIndex, T val);
}
[ExtensionAttribute]
public static class Jint.Native.Number.Dtoa.NumberExtensions : object {
    [ExtensionAttribute]
public static long UnsignedShift(long l, int shift);
}
public class Jint.Native.Number.NumberConstructor : FunctionInstance {
    [CompilerGeneratedAttribute]
private NumberPrototype <PrototypeObject>k__BackingField;
    public NumberPrototype PrototypeObject { get; private set; }
    public NumberConstructor(Engine engine);
    public static NumberConstructor CreateNumberConstructor(Engine engine);
    public void Configure();
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    [CompilerGeneratedAttribute]
public NumberPrototype get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(NumberPrototype value);
    public NumberInstance Construct(double value);
}
public class Jint.Native.Number.NumberInstance : ObjectInstance {
    private static long NegativeZeroBits;
    [CompilerGeneratedAttribute]
private JsValue <PrimitiveValue>k__BackingField;
    public string Class { get; }
    private Types Jint.Native.IPrimitiveInstance.Type { get; }
    private JsValue Jint.Native.IPrimitiveInstance.PrimitiveValue { get; }
    public JsValue PrimitiveValue { get; public set; }
    public NumberInstance(Engine engine);
    private static NumberInstance();
    public virtual string get_Class();
    private sealed virtual override Types Jint.Native.IPrimitiveInstance.get_Type();
    private sealed virtual override JsValue Jint.Native.IPrimitiveInstance.get_PrimitiveValue();
    [CompilerGeneratedAttribute]
public JsValue get_PrimitiveValue();
    [CompilerGeneratedAttribute]
public void set_PrimitiveValue(JsValue value);
    public static bool IsNegativeZero(double x);
    public static bool IsPositiveZero(double x);
}
public class Jint.Native.Number.NumberPrototype : NumberInstance {
    private static double Ten21;
    private NumberPrototype(Engine engine);
    public static NumberPrototype CreatePrototypeObject(Engine engine, NumberConstructor numberConstructor);
    public void Configure();
    private JsValue ToLocaleString(JsValue thisObject, JsValue[] arguments);
    private JsValue ValueOf(JsValue thisObj, JsValue[] arguments);
    private JsValue ToFixed(JsValue thisObj, JsValue[] arguments);
    private JsValue ToExponential(JsValue thisObj, JsValue[] arguments);
    private JsValue ToPrecision(JsValue thisObj, JsValue[] arguments);
    private JsValue ToNumberString(JsValue thisObject, JsValue[] arguments);
    public static string ToBase(long n, int radix);
    public static string ToFractionBase(double n, int radix);
    public static string ToNumberString(double m);
}
public class Jint.Native.Object.ObjectConstructor : FunctionInstance {
    private Engine _engine;
    [CompilerGeneratedAttribute]
private ObjectPrototype <PrototypeObject>k__BackingField;
    public ObjectPrototype PrototypeObject { get; private set; }
    private ObjectConstructor(Engine engine);
    public static ObjectConstructor CreateObjectConstructor(Engine engine);
    public void Configure();
    [CompilerGeneratedAttribute]
public ObjectPrototype get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(ObjectPrototype value);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    public JsValue GetPrototypeOf(JsValue thisObject, JsValue[] arguments);
    public JsValue GetOwnPropertyDescriptor(JsValue thisObject, JsValue[] arguments);
    public JsValue GetOwnPropertyNames(JsValue thisObject, JsValue[] arguments);
    public JsValue Create(JsValue thisObject, JsValue[] arguments);
    public JsValue DefineProperty(JsValue thisObject, JsValue[] arguments);
    public JsValue DefineProperties(JsValue thisObject, JsValue[] arguments);
    public JsValue Seal(JsValue thisObject, JsValue[] arguments);
    public JsValue Freeze(JsValue thisObject, JsValue[] arguments);
    public JsValue PreventExtensions(JsValue thisObject, JsValue[] arguments);
    public JsValue IsSealed(JsValue thisObject, JsValue[] arguments);
    public JsValue IsFrozen(JsValue thisObject, JsValue[] arguments);
    public JsValue IsExtensible(JsValue thisObject, JsValue[] arguments);
    public JsValue Keys(JsValue thisObject, JsValue[] arguments);
}
public class Jint.Native.Object.ObjectInstance : object {
    [CompilerGeneratedAttribute]
private Engine <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, PropertyDescriptor> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectInstance <Prototype>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Extensible>k__BackingField;
    public Engine Engine { get; public set; }
    protected IDictionary`2<string, PropertyDescriptor> Properties { get; private set; }
    public ObjectInstance Prototype { get; public set; }
    public bool Extensible { get; public set; }
    public string Class { get; }
    public ObjectInstance(Engine engine);
    [CompilerGeneratedAttribute]
public Engine get_Engine();
    [CompilerGeneratedAttribute]
public void set_Engine(Engine value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, PropertyDescriptor> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, PropertyDescriptor> value);
    [CompilerGeneratedAttribute]
public ObjectInstance get_Prototype();
    [CompilerGeneratedAttribute]
public void set_Prototype(ObjectInstance value);
    [CompilerGeneratedAttribute]
public bool get_Extensible();
    [CompilerGeneratedAttribute]
public void set_Extensible(bool value);
    public virtual string get_Class();
    public virtual IEnumerable`1<KeyValuePair`2<string, PropertyDescriptor>> GetOwnProperties();
    public virtual bool HasOwnProperty(string p);
    public virtual void RemoveOwnProperty(string p);
    public virtual JsValue Get(string propertyName);
    public virtual PropertyDescriptor GetOwnProperty(string propertyName);
    protected virtual void SetOwnProperty(string propertyName, PropertyDescriptor desc);
    public PropertyDescriptor GetProperty(string propertyName);
    public virtual void Put(string propertyName, JsValue value, bool throwOnError);
    public bool CanPut(string propertyName);
    public bool HasProperty(string propertyName);
    public virtual bool Delete(string propertyName, bool throwOnError);
    public JsValue DefaultValue(Types hint);
    public virtual bool DefineOwnProperty(string propertyName, PropertyDescriptor desc, bool throwOnError);
    public void FastAddProperty(string name, JsValue value, bool writable, bool enumerable, bool configurable);
    public void FastSetProperty(string name, PropertyDescriptor value);
    protected virtual void EnsureInitialized();
    public virtual string ToString();
}
public class Jint.Native.Object.ObjectPrototype : ObjectInstance {
    private ObjectPrototype(Engine engine);
    public static ObjectPrototype CreatePrototypeObject(Engine engine, ObjectConstructor objectConstructor);
    public void Configure();
    private JsValue PropertyIsEnumerable(JsValue thisObject, JsValue[] arguments);
    private JsValue ValueOf(JsValue thisObject, JsValue[] arguments);
    private JsValue IsPrototypeOf(JsValue thisObject, JsValue[] arguments);
    private JsValue ToLocaleString(JsValue thisObject, JsValue[] arguments);
    public JsValue ToObjectString(JsValue thisObject, JsValue[] arguments);
    public JsValue HasOwnProperty(JsValue thisObject, JsValue[] arguments);
    [CompilerGeneratedAttribute]
private void <ToLocaleString>b__6_0(JsValue x);
}
public class Jint.Native.RegExp.RegExpConstructor : FunctionInstance {
    [CompilerGeneratedAttribute]
private RegExpPrototype <PrototypeObject>k__BackingField;
    public RegExpPrototype PrototypeObject { get; private set; }
    public RegExpConstructor(Engine engine);
    public static RegExpConstructor CreateRegExpConstructor(Engine engine);
    public void Configure();
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    public RegExpInstance Construct(string regExp);
    private RegexOptions ParseOptions(RegExpInstance r, string flags);
    [CompilerGeneratedAttribute]
public RegExpPrototype get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(RegExpPrototype value);
}
public class Jint.Native.RegExp.RegExpInstance : ObjectInstance {
    [CompilerGeneratedAttribute]
private Regex <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Global>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Multiline>k__BackingField;
    public string Class { get; }
    public Regex Value { get; public set; }
    public string Source { get; public set; }
    public string Flags { get; public set; }
    public bool Global { get; public set; }
    public bool IgnoreCase { get; public set; }
    public bool Multiline { get; public set; }
    public RegExpInstance(Engine engine);
    public virtual string get_Class();
    [CompilerGeneratedAttribute]
public Regex get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Regex value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(string value);
    [CompilerGeneratedAttribute]
public bool get_Global();
    [CompilerGeneratedAttribute]
public void set_Global(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public bool get_Multiline();
    [CompilerGeneratedAttribute]
public void set_Multiline(bool value);
    public Match Match(string input, double start);
}
public class Jint.Native.RegExp.RegExpPrototype : RegExpInstance {
    private RegExpPrototype(Engine engine);
    public static RegExpPrototype CreatePrototypeObject(Engine engine, RegExpConstructor regExpConstructor);
    public void Configure();
    private JsValue ToRegExpString(JsValue thisObj, JsValue[] arguments);
    private JsValue Test(JsValue thisObj, JsValue[] arguments);
    internal JsValue Exec(JsValue thisObj, JsValue[] arguments);
    private static ObjectInstance InitReturnValueArray(ObjectInstance array, string inputValue, int lengthValue, int indexValue);
}
public class Jint.Native.String.StringConstructor : FunctionInstance {
    [CompilerGeneratedAttribute]
private StringPrototype <PrototypeObject>k__BackingField;
    public StringPrototype PrototypeObject { get; private set; }
    public StringConstructor(Engine engine);
    public static StringConstructor CreateStringConstructor(Engine engine);
    public void Configure();
    private static JsValue FromCharCode(JsValue thisObj, JsValue[] arguments);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    [CompilerGeneratedAttribute]
public StringPrototype get_PrototypeObject();
    [CompilerGeneratedAttribute]
private void set_PrototypeObject(StringPrototype value);
    public StringInstance Construct(string value);
}
public class Jint.Native.String.StringInstance : ObjectInstance {
    [CompilerGeneratedAttribute]
private JsValue <PrimitiveValue>k__BackingField;
    public string Class { get; }
    private Types Jint.Native.IPrimitiveInstance.Type { get; }
    private JsValue Jint.Native.IPrimitiveInstance.PrimitiveValue { get; }
    public JsValue PrimitiveValue { get; public set; }
    public StringInstance(Engine engine);
    public virtual string get_Class();
    private sealed virtual override Types Jint.Native.IPrimitiveInstance.get_Type();
    private sealed virtual override JsValue Jint.Native.IPrimitiveInstance.get_PrimitiveValue();
    [CompilerGeneratedAttribute]
public JsValue get_PrimitiveValue();
    [CompilerGeneratedAttribute]
public void set_PrimitiveValue(JsValue value);
    private static bool IsInt(double d);
    public virtual PropertyDescriptor GetOwnProperty(string propertyName);
}
public class Jint.Native.String.StringPrototype : StringInstance {
    private static char BOM_CHAR;
    private static char MONGOLIAN_VOWEL_SEPARATOR;
    private StringPrototype(Engine engine);
    public static StringPrototype CreatePrototypeObject(Engine engine, StringConstructor stringConstructor);
    public void Configure();
    private JsValue ToStringString(JsValue thisObj, JsValue[] arguments);
    private static bool IsWhiteSpaceEx(char c);
    public static string TrimEndEx(string s);
    public static string TrimStartEx(string s);
    public static string TrimEx(string s);
    private JsValue Trim(JsValue thisObj, JsValue[] arguments);
    private static JsValue ToLocaleUpperCase(JsValue thisObj, JsValue[] arguments);
    private static JsValue ToUpperCase(JsValue thisObj, JsValue[] arguments);
    private static JsValue ToLocaleLowerCase(JsValue thisObj, JsValue[] arguments);
    private static JsValue ToLowerCase(JsValue thisObj, JsValue[] arguments);
    private static int ToIntegerSupportInfinity(JsValue numberVal);
    private JsValue Substring(JsValue thisObj, JsValue[] arguments);
    private JsValue Substr(JsValue thisObj, JsValue[] arguments);
    private JsValue Split(JsValue thisObj, JsValue[] arguments);
    private JsValue Slice(JsValue thisObj, JsValue[] arguments);
    private JsValue Search(JsValue thisObj, JsValue[] arguments);
    private JsValue Replace(JsValue thisObj, JsValue[] arguments);
    private JsValue Match(JsValue thisObj, JsValue[] arguments);
    private JsValue LocaleCompare(JsValue thisObj, JsValue[] arguments);
    private JsValue LastIndexOf(JsValue thisObj, JsValue[] arguments);
    private JsValue IndexOf(JsValue thisObj, JsValue[] arguments);
    private JsValue Concat(JsValue thisObj, JsValue[] arguments);
    private JsValue CharCodeAt(JsValue thisObj, JsValue[] arguments);
    private JsValue CharAt(JsValue thisObj, JsValue[] arguments);
    private JsValue ValueOf(JsValue thisObj, JsValue[] arguments);
    private JsValue PadStart(JsValue thisObj, JsValue[] arguments);
    private JsValue PadEnd(JsValue thisObj, JsValue[] arguments);
    private JsValue Pad(JsValue thisObj, JsValue[] arguments, bool padStart);
}
public static class Jint.Native.Undefined : object {
    public static JsValue Instance;
    public static string Text;
    private static Undefined();
}
public class Jint.Options : object {
    private bool _discardGlobal;
    private bool _strict;
    private bool _allowDebuggerStatement;
    private bool _debugMode;
    private bool _allowClr;
    private List`1<IObjectConverter> _objectConverters;
    private int _maxStatements;
    private int _maxRecursionDepth;
    private TimeSpan _timeoutInterval;
    private CultureInfo _culture;
    private TimeZoneInfo _localTimeZone;
    private List`1<Assembly> _lookupAssemblies;
    private Predicate`1<Exception> _clrExceptionsHandler;
    private IReferenceResolver _referenceResolver;
    internal bool _IsGlobalDiscarded { get; }
    internal bool _IsStrict { get; }
    internal bool _IsDebuggerStatementAllowed { get; }
    internal bool _IsDebugMode { get; }
    internal bool _IsClrAllowed { get; }
    internal Predicate`1<Exception> _ClrExceptionsHandler { get; }
    internal IList`1<Assembly> _LookupAssemblies { get; }
    internal IEnumerable`1<IObjectConverter> _ObjectConverters { get; }
    internal int _MaxStatements { get; }
    internal int _MaxRecursionDepth { get; }
    internal TimeSpan _TimeoutInterval { get; }
    internal CultureInfo _Culture { get; }
    internal TimeZoneInfo _LocalTimeZone { get; }
    internal IReferenceResolver _ReferenceResolver { get; }
    public Options DiscardGlobal(bool discard);
    public Options Strict(bool strict);
    public Options AllowDebuggerStatement(bool allowDebuggerStatement);
    public Options DebugMode(bool debugMode);
    public Options AddObjectConverter(IObjectConverter objectConverter);
    public Options AllowClr(Assembly[] assemblies);
    public Options CatchClrExceptions();
    public Options CatchClrExceptions(Predicate`1<Exception> handler);
    public Options MaxStatements(int maxStatements);
    public Options TimeoutInterval(TimeSpan timeoutInterval);
    public Options LimitRecursion(int maxRecursionDepth);
    public Options Culture(CultureInfo cultureInfo);
    public Options LocalTimeZone(TimeZoneInfo timeZoneInfo);
    public Options SetReferencesResolver(IReferenceResolver resolver);
    internal bool get__IsGlobalDiscarded();
    internal bool get__IsStrict();
    internal bool get__IsDebuggerStatementAllowed();
    internal bool get__IsDebugMode();
    internal bool get__IsClrAllowed();
    internal Predicate`1<Exception> get__ClrExceptionsHandler();
    internal IList`1<Assembly> get__LookupAssemblies();
    internal IEnumerable`1<IObjectConverter> get__ObjectConverters();
    internal int get__MaxStatements();
    internal int get__MaxRecursionDepth();
    internal TimeSpan get__TimeoutInterval();
    internal CultureInfo get__Culture();
    internal TimeZoneInfo get__LocalTimeZone();
    internal IReferenceResolver get__ReferenceResolver();
}
public class Jint.Parser.Ast.ArrayExpression : Expression {
    public IEnumerable`1<Expression> Elements;
}
public class Jint.Parser.Ast.AssignmentExpression : Expression {
    public AssignmentOperator Operator;
    public Expression Left;
    public Expression Right;
    public static AssignmentOperator ParseAssignmentOperator(string op);
}
public enum Jint.Parser.Ast.AssignmentOperator : Enum {
    public int value__;
    public static AssignmentOperator Assign;
    public static AssignmentOperator PlusAssign;
    public static AssignmentOperator MinusAssign;
    public static AssignmentOperator TimesAssign;
    public static AssignmentOperator DivideAssign;
    public static AssignmentOperator ModuloAssign;
    public static AssignmentOperator BitwiseAndAssign;
    public static AssignmentOperator BitwiseOrAssign;
    public static AssignmentOperator BitwiseXOrAssign;
    public static AssignmentOperator LeftShiftAssign;
    public static AssignmentOperator RightShiftAssign;
    public static AssignmentOperator UnsignedRightShiftAssign;
}
public class Jint.Parser.Ast.BinaryExpression : Expression {
    public BinaryOperator Operator;
    public Expression Left;
    public Expression Right;
    public static BinaryOperator ParseBinaryOperator(string op);
}
public enum Jint.Parser.Ast.BinaryOperator : Enum {
    public int value__;
    public static BinaryOperator Plus;
    public static BinaryOperator Minus;
    public static BinaryOperator Times;
    public static BinaryOperator Divide;
    public static BinaryOperator Modulo;
    public static BinaryOperator Equal;
    public static BinaryOperator NotEqual;
    public static BinaryOperator Greater;
    public static BinaryOperator GreaterOrEqual;
    public static BinaryOperator Less;
    public static BinaryOperator LessOrEqual;
    public static BinaryOperator StrictlyEqual;
    public static BinaryOperator StricltyNotEqual;
    public static BinaryOperator BitwiseAnd;
    public static BinaryOperator BitwiseOr;
    public static BinaryOperator BitwiseXOr;
    public static BinaryOperator LeftShift;
    public static BinaryOperator RightShift;
    public static BinaryOperator UnsignedRightShift;
    public static BinaryOperator InstanceOf;
    public static BinaryOperator In;
}
public class Jint.Parser.Ast.BlockStatement : Statement {
    public IEnumerable`1<Statement> Body;
}
public class Jint.Parser.Ast.BreakStatement : Statement {
    public Identifier Label;
}
public class Jint.Parser.Ast.CallExpression : Expression {
    public Expression Callee;
    public IList`1<Expression> Arguments;
    public bool Cached;
    public bool CanBeCached;
    public JsValue[] CachedArguments;
}
public class Jint.Parser.Ast.CatchClause : Statement {
    public Identifier Param;
    public BlockStatement Body;
}
public class Jint.Parser.Ast.ConditionalExpression : Expression {
    public Expression Test;
    public Expression Consequent;
    public Expression Alternate;
}
public class Jint.Parser.Ast.ContinueStatement : Statement {
    public Identifier Label;
}
public class Jint.Parser.Ast.DebuggerStatement : Statement {
}
public class Jint.Parser.Ast.DoWhileStatement : Statement {
    public Statement Body;
    public Expression Test;
}
public class Jint.Parser.Ast.EmptyStatement : Statement {
}
public class Jint.Parser.Ast.Expression : SyntaxNode {
}
public class Jint.Parser.Ast.ExpressionStatement : Statement {
    public Expression Expression;
}
public class Jint.Parser.Ast.ForInStatement : Statement {
    public SyntaxNode Left;
    public Expression Right;
    public Statement Body;
    public bool Each;
}
public class Jint.Parser.Ast.ForStatement : Statement {
    public SyntaxNode Init;
    public Expression Test;
    public Expression Update;
    public Statement Body;
}
public class Jint.Parser.Ast.FunctionDeclaration : Statement {
    [CompilerGeneratedAttribute]
private Identifier <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Identifier> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<VariableDeclaration> <VariableDeclarations>k__BackingField;
    public IEnumerable`1<Expression> Defaults;
    public SyntaxNode Rest;
    public bool Generator;
    public bool Expression;
    [CompilerGeneratedAttribute]
private IList`1<FunctionDeclaration> <FunctionDeclarations>k__BackingField;
    public Identifier Id { get; public set; }
    public IEnumerable`1<Identifier> Parameters { get; public set; }
    public Statement Body { get; public set; }
    public bool Strict { get; public set; }
    public IList`1<VariableDeclaration> VariableDeclarations { get; public set; }
    public IList`1<FunctionDeclaration> FunctionDeclarations { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Identifier get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Identifier value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Identifier> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IEnumerable`1<Identifier> value);
    [CompilerGeneratedAttribute]
public sealed virtual Statement get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(Statement value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Strict();
    [CompilerGeneratedAttribute]
public void set_Strict(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<VariableDeclaration> get_VariableDeclarations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VariableDeclarations(IList`1<VariableDeclaration> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<FunctionDeclaration> get_FunctionDeclarations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FunctionDeclarations(IList`1<FunctionDeclaration> value);
}
public class Jint.Parser.Ast.FunctionExpression : Expression {
    [CompilerGeneratedAttribute]
private Identifier <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Identifier> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<VariableDeclaration> <VariableDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FunctionDeclaration> <FunctionDeclarations>k__BackingField;
    public IEnumerable`1<Expression> Defaults;
    public SyntaxNode Rest;
    public bool Generator;
    public bool Expression;
    public Identifier Id { get; public set; }
    public IEnumerable`1<Identifier> Parameters { get; public set; }
    public Statement Body { get; public set; }
    public bool Strict { get; public set; }
    public IList`1<VariableDeclaration> VariableDeclarations { get; public set; }
    public IList`1<FunctionDeclaration> FunctionDeclarations { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Identifier get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Identifier value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Identifier> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IEnumerable`1<Identifier> value);
    [CompilerGeneratedAttribute]
public sealed virtual Statement get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(Statement value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Strict();
    [CompilerGeneratedAttribute]
public void set_Strict(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<VariableDeclaration> get_VariableDeclarations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VariableDeclarations(IList`1<VariableDeclaration> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<FunctionDeclaration> get_FunctionDeclarations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FunctionDeclarations(IList`1<FunctionDeclaration> value);
}
public class Jint.Parser.Ast.Identifier : Expression {
    public string Name;
    public sealed virtual string GetKey();
}
public class Jint.Parser.Ast.IfStatement : Statement {
    public Expression Test;
    public Statement Consequent;
    public Statement Alternate;
}
public interface Jint.Parser.Ast.IPropertyKeyExpression {
    public abstract virtual string GetKey();
}
public class Jint.Parser.Ast.LabelledStatement : Statement {
    public Identifier Label;
    public Statement Body;
}
public class Jint.Parser.Ast.Literal : Expression {
    public object Value;
    public string Raw;
    public bool Cached;
    public JsValue CachedValue;
    public sealed virtual string GetKey();
}
public class Jint.Parser.Ast.LogicalExpression : Expression {
    public LogicalOperator Operator;
    public Expression Left;
    public Expression Right;
    public static LogicalOperator ParseLogicalOperator(string op);
}
public enum Jint.Parser.Ast.LogicalOperator : Enum {
    public int value__;
    public static LogicalOperator LogicalAnd;
    public static LogicalOperator LogicalOr;
}
public class Jint.Parser.Ast.MemberExpression : Expression {
    public Expression Object;
    public Expression Property;
    public bool Computed;
}
public class Jint.Parser.Ast.NewExpression : Expression {
    public Expression Callee;
    public IEnumerable`1<Expression> Arguments;
}
public class Jint.Parser.Ast.ObjectExpression : Expression {
    public IEnumerable`1<Property> Properties;
}
public class Jint.Parser.Ast.Program : Statement {
    public ICollection`1<Statement> Body;
    public List`1<Comment> Comments;
    public List`1<Token> Tokens;
    public List`1<ParserException> Errors;
    public bool Strict;
    [CompilerGeneratedAttribute]
private IList`1<VariableDeclaration> <VariableDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FunctionDeclaration> <FunctionDeclarations>k__BackingField;
    public IList`1<VariableDeclaration> VariableDeclarations { get; public set; }
    public IList`1<FunctionDeclaration> FunctionDeclarations { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<VariableDeclaration> get_VariableDeclarations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VariableDeclarations(IList`1<VariableDeclaration> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<FunctionDeclaration> get_FunctionDeclarations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FunctionDeclarations(IList`1<FunctionDeclaration> value);
}
public class Jint.Parser.Ast.Property : Expression {
    public PropertyKind Kind;
    public IPropertyKeyExpression Key;
    public Expression Value;
}
[FlagsAttribute]
public enum Jint.Parser.Ast.PropertyKind : Enum {
    public int value__;
    public static PropertyKind Data;
    public static PropertyKind Get;
    public static PropertyKind Set;
}
public class Jint.Parser.Ast.RegExpLiteral : Expression {
    public object Value;
    public string Raw;
    public string Flags;
    public sealed virtual string GetKey();
}
public class Jint.Parser.Ast.ReturnStatement : Statement {
    public Expression Argument;
}
public class Jint.Parser.Ast.SequenceExpression : Expression {
    public IList`1<Expression> Expressions;
}
public class Jint.Parser.Ast.Statement : SyntaxNode {
    public string LabelSet;
}
public class Jint.Parser.Ast.SwitchCase : SyntaxNode {
    public Expression Test;
    public IEnumerable`1<Statement> Consequent;
}
public class Jint.Parser.Ast.SwitchStatement : Statement {
    public Expression Discriminant;
    public IEnumerable`1<SwitchCase> Cases;
}
public class Jint.Parser.Ast.SyntaxNode : object {
    public SyntaxNodes Type;
    public Int32[] Range;
    public Location Location;
    [DebuggerStepThroughAttribute]
public T As();
}
public enum Jint.Parser.Ast.SyntaxNodes : Enum {
    public int value__;
    public static SyntaxNodes AssignmentExpression;
    public static SyntaxNodes ArrayExpression;
    public static SyntaxNodes BlockStatement;
    public static SyntaxNodes BinaryExpression;
    public static SyntaxNodes BreakStatement;
    public static SyntaxNodes CallExpression;
    public static SyntaxNodes CatchClause;
    public static SyntaxNodes ConditionalExpression;
    public static SyntaxNodes ContinueStatement;
    public static SyntaxNodes DoWhileStatement;
    public static SyntaxNodes DebuggerStatement;
    public static SyntaxNodes EmptyStatement;
    public static SyntaxNodes ExpressionStatement;
    public static SyntaxNodes ForStatement;
    public static SyntaxNodes ForInStatement;
    public static SyntaxNodes FunctionDeclaration;
    public static SyntaxNodes FunctionExpression;
    public static SyntaxNodes Identifier;
    public static SyntaxNodes IfStatement;
    public static SyntaxNodes Literal;
    public static SyntaxNodes RegularExpressionLiteral;
    public static SyntaxNodes LabeledStatement;
    public static SyntaxNodes LogicalExpression;
    public static SyntaxNodes MemberExpression;
    public static SyntaxNodes NewExpression;
    public static SyntaxNodes ObjectExpression;
    public static SyntaxNodes Program;
    public static SyntaxNodes Property;
    public static SyntaxNodes ReturnStatement;
    public static SyntaxNodes SequenceExpression;
    public static SyntaxNodes SwitchStatement;
    public static SyntaxNodes SwitchCase;
    public static SyntaxNodes ThisExpression;
    public static SyntaxNodes ThrowStatement;
    public static SyntaxNodes TryStatement;
    public static SyntaxNodes UnaryExpression;
    public static SyntaxNodes UpdateExpression;
    public static SyntaxNodes VariableDeclaration;
    public static SyntaxNodes VariableDeclarator;
    public static SyntaxNodes WhileStatement;
    public static SyntaxNodes WithStatement;
}
public class Jint.Parser.Ast.ThisExpression : Expression {
}
public class Jint.Parser.Ast.ThrowStatement : Statement {
    public Expression Argument;
}
public class Jint.Parser.Ast.TryStatement : Statement {
    public Statement Block;
    public IEnumerable`1<Statement> GuardedHandlers;
    public IEnumerable`1<CatchClause> Handlers;
    public Statement Finalizer;
}
public class Jint.Parser.Ast.UnaryExpression : Expression {
    public UnaryOperator Operator;
    public Expression Argument;
    public bool Prefix;
    public static UnaryOperator ParseUnaryOperator(string op);
}
public enum Jint.Parser.Ast.UnaryOperator : Enum {
    public int value__;
    public static UnaryOperator Plus;
    public static UnaryOperator Minus;
    public static UnaryOperator BitwiseNot;
    public static UnaryOperator LogicalNot;
    public static UnaryOperator Delete;
    public static UnaryOperator Void;
    public static UnaryOperator TypeOf;
    public static UnaryOperator Increment;
    public static UnaryOperator Decrement;
}
public class Jint.Parser.Ast.UpdateExpression : UnaryExpression {
}
public class Jint.Parser.Ast.VariableDeclaration : Statement {
    public IEnumerable`1<VariableDeclarator> Declarations;
    public string Kind;
}
public class Jint.Parser.Ast.VariableDeclarator : Expression {
    public Identifier Id;
    public Expression Init;
}
public class Jint.Parser.Ast.WhileStatement : Statement {
    public Expression Test;
    public Statement Body;
}
public class Jint.Parser.Ast.WithStatement : Statement {
    public Expression Object;
    public Statement Body;
}
public class Jint.Parser.Comment : object {
    public Location Location;
    public Int32[] Range;
    public string Type;
    public string Value;
}
public class Jint.Parser.FunctionScope : object {
    [CompilerGeneratedAttribute]
private IList`1<FunctionDeclaration> <FunctionDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<VariableDeclaration> <VariableDeclarations>k__BackingField;
    public IList`1<FunctionDeclaration> FunctionDeclarations { get; public set; }
    public IList`1<VariableDeclaration> VariableDeclarations { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<FunctionDeclaration> get_FunctionDeclarations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FunctionDeclarations(IList`1<FunctionDeclaration> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<VariableDeclaration> get_VariableDeclarations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VariableDeclarations(IList`1<VariableDeclaration> value);
}
public interface Jint.Parser.IFunctionDeclaration {
    public Identifier Id { get; }
    public IEnumerable`1<Identifier> Parameters { get; }
    public Statement Body { get; }
    public bool Strict { get; }
    public abstract virtual Identifier get_Id();
    public abstract virtual IEnumerable`1<Identifier> get_Parameters();
    public abstract virtual Statement get_Body();
    public abstract virtual bool get_Strict();
}
public interface Jint.Parser.IFunctionScope {
    public IList`1<FunctionDeclaration> FunctionDeclarations { get; public set; }
    public abstract virtual IList`1<FunctionDeclaration> get_FunctionDeclarations();
    public abstract virtual void set_FunctionDeclarations(IList`1<FunctionDeclaration> value);
}
public interface Jint.Parser.IVariableScope {
    public IList`1<VariableDeclaration> VariableDeclarations { get; public set; }
    public abstract virtual IList`1<VariableDeclaration> get_VariableDeclarations();
    public abstract virtual void set_VariableDeclarations(IList`1<VariableDeclaration> value);
}
public class Jint.Parser.JavaScriptParser : object {
    private static HashSet`1<string> Keywords;
    private static HashSet`1<string> StrictModeReservedWords;
    private static HashSet`1<string> FutureReservedWords;
    private Extra _extra;
    private int _index;
    private int _length;
    private int _lineNumber;
    private int _lineStart;
    private Location _location;
    private Token _lookahead;
    private string _source;
    private State _state;
    private bool _strict;
    private Stack`1<IVariableScope> _variableScopes;
    private Stack`1<IFunctionScope> _functionScopes;
    public JavaScriptParser(bool strict);
    private static JavaScriptParser();
    private static bool IsDecimalDigit(char ch);
    private static bool IsHexDigit(char ch);
    private static bool IsOctalDigit(char ch);
    private static bool IsWhiteSpace(char ch);
    private static bool IsLineTerminator(char ch);
    private static bool IsIdentifierStart(char ch);
    private static bool IsIdentifierPart(char ch);
    private static bool IsFutureReservedWord(string id);
    private static bool IsStrictModeReservedWord(string id);
    private static bool IsRestrictedWord(string id);
    private bool IsKeyword(string id);
    private void AddComment(string type, string value, int start, int end, Location location);
    private void SkipSingleLineComment(int offset);
    private void SkipMultiLineComment();
    private void SkipComment();
    private bool ScanHexEscape(char prefix, Char& result);
    private string GetEscapedIdentifier();
    private string GetIdentifier();
    private Token ScanIdentifier();
    private Token ScanPunctuator();
    private Token ScanHexLiteral(int start);
    private Token ScanOctalLiteral(int start);
    private Token ScanNumericLiteral();
    private Token ScanStringLiteral();
    private Token ScanRegExp();
    private Token CollectRegex();
    private bool IsIdentifierName(Token token);
    private Token Advance();
    private Token CollectToken();
    private Token Lex();
    private void Peek();
    private void MarkStart();
    private T MarkEnd(T node);
    public T MarkEndIf(T node);
    public SyntaxNode PostProcess(SyntaxNode node);
    public ArrayExpression CreateArrayExpression(IEnumerable`1<Expression> elements);
    public AssignmentExpression CreateAssignmentExpression(string op, Expression left, Expression right);
    public Expression CreateBinaryExpression(string op, Expression left, Expression right);
    public BlockStatement CreateBlockStatement(IEnumerable`1<Statement> body);
    public BreakStatement CreateBreakStatement(Identifier label);
    public CallExpression CreateCallExpression(Expression callee, IList`1<Expression> args);
    public CatchClause CreateCatchClause(Identifier param, BlockStatement body);
    public ConditionalExpression CreateConditionalExpression(Expression test, Expression consequent, Expression alternate);
    public ContinueStatement CreateContinueStatement(Identifier label);
    public DebuggerStatement CreateDebuggerStatement();
    public DoWhileStatement CreateDoWhileStatement(Statement body, Expression test);
    public EmptyStatement CreateEmptyStatement();
    public ExpressionStatement CreateExpressionStatement(Expression expression);
    public ForStatement CreateForStatement(SyntaxNode init, Expression test, Expression update, Statement body);
    public ForInStatement CreateForInStatement(SyntaxNode left, Expression right, Statement body);
    public FunctionDeclaration CreateFunctionDeclaration(Identifier id, IEnumerable`1<Identifier> parameters, IEnumerable`1<Expression> defaults, Statement body, bool strict);
    public FunctionExpression CreateFunctionExpression(Identifier id, IEnumerable`1<Identifier> parameters, IEnumerable`1<Expression> defaults, Statement body, bool strict);
    public Identifier CreateIdentifier(string name);
    public IfStatement CreateIfStatement(Expression test, Statement consequent, Statement alternate);
    public LabelledStatement CreateLabeledStatement(Identifier label, Statement body);
    public Literal CreateLiteral(Token token);
    public MemberExpression CreateMemberExpression(char accessor, Expression obj, Expression property);
    public NewExpression CreateNewExpression(Expression callee, IEnumerable`1<Expression> args);
    public ObjectExpression CreateObjectExpression(IEnumerable`1<Property> properties);
    public UpdateExpression CreatePostfixExpression(string op, Expression argument);
    public Program CreateProgram(ICollection`1<Statement> body, bool strict);
    public Property CreateProperty(PropertyKind kind, IPropertyKeyExpression key, Expression value);
    public ReturnStatement CreateReturnStatement(Expression argument);
    public SequenceExpression CreateSequenceExpression(IList`1<Expression> expressions);
    public SwitchCase CreateSwitchCase(Expression test, IEnumerable`1<Statement> consequent);
    public SwitchStatement CreateSwitchStatement(Expression discriminant, IEnumerable`1<SwitchCase> cases);
    public ThisExpression CreateThisExpression();
    public ThrowStatement CreateThrowStatement(Expression argument);
    public TryStatement CreateTryStatement(Statement block, IEnumerable`1<Statement> guardedHandlers, IEnumerable`1<CatchClause> handlers, Statement finalizer);
    public UnaryExpression CreateUnaryExpression(string op, Expression argument);
    public VariableDeclaration CreateVariableDeclaration(IEnumerable`1<VariableDeclarator> declarations, string kind);
    public VariableDeclarator CreateVariableDeclarator(Identifier id, Expression init);
    public WhileStatement CreateWhileStatement(Expression test, Statement body);
    public WithStatement CreateWithStatement(Expression obj, Statement body);
    private bool PeekLineTerminator();
    private void ThrowError(Token token, string messageFormat, Object[] arguments);
    private void ThrowErrorTolerant(Token token, string messageFormat, Object[] arguments);
    private void ThrowUnexpected(Token token);
    private void Expect(string value);
    private void ExpectKeyword(string keyword);
    private bool Match(string value);
    private bool MatchKeyword(object keyword);
    private bool MatchAssign();
    private void ConsumeSemicolon();
    private bool isLeftHandSide(Expression expr);
    private ArrayExpression ParseArrayInitialiser();
    private FunctionExpression ParsePropertyFunction(Identifier[] parameters, Token first);
    private IPropertyKeyExpression ParseObjectPropertyKey();
    private Property ParseObjectProperty();
    private ObjectExpression ParseObjectInitialiser();
    private Expression ParseGroupExpression();
    private Expression ParsePrimaryExpression();
    private IList`1<Expression> ParseArguments();
    private Identifier ParseNonComputedProperty();
    private Identifier ParseNonComputedMember();
    private Expression ParseComputedMember();
    private NewExpression ParseNewExpression();
    private Expression ParseLeftHandSideExpressionAllowCall();
    private Expression ParseLeftHandSideExpression();
    private Expression ParsePostfixExpression();
    private Expression ParseUnaryExpression();
    private int binaryPrecedence(Token token, bool allowIn);
    private Expression ParseBinaryExpression();
    private Expression ParseConditionalExpression();
    private Expression ParseAssignmentExpression();
    private Expression ParseExpression();
    private IEnumerable`1<Statement> ParseStatementList();
    private BlockStatement ParseBlock();
    private Identifier ParseVariableIdentifier();
    private VariableDeclarator ParseVariableDeclaration(string kind);
    private IEnumerable`1<VariableDeclarator> ParseVariableDeclarationList(string kind);
    private VariableDeclaration ParseVariableStatement();
    private VariableDeclaration ParseConstLetDeclaration(string kind);
    private EmptyStatement ParseEmptyStatement();
    private ExpressionStatement ParseExpressionStatement();
    private IfStatement ParseIfStatement();
    private DoWhileStatement ParseDoWhileStatement();
    private WhileStatement ParseWhileStatement();
    private VariableDeclaration ParseForVariableDeclaration();
    private Statement ParseForStatement();
    private Statement ParseContinueStatement();
    private BreakStatement ParseBreakStatement();
    private ReturnStatement ParseReturnStatement();
    private WithStatement ParseWithStatement();
    private SwitchCase ParseSwitchCase();
    private SwitchStatement ParseSwitchStatement();
    private ThrowStatement ParseThrowStatement();
    private CatchClause ParseCatchClause();
    private TryStatement ParseTryStatement();
    private DebuggerStatement ParseDebuggerStatement();
    private Statement ParseStatement();
    private Statement ParseFunctionSourceElements();
    private ParsedParameters ParseParams(Token firstRestricted);
    private Statement ParseFunctionDeclaration();
    private void EnterVariableScope();
    private IList`1<VariableDeclaration> LeaveVariableScope();
    private void EnterFunctionScope();
    private IList`1<FunctionDeclaration> LeaveFunctionScope();
    private FunctionExpression ParseFunctionExpression();
    private Statement ParseSourceElement();
    private ICollection`1<Statement> ParseSourceElements();
    private Program ParseProgram();
    private LocationMarker CreateLocationMarker();
    public Program Parse(string code);
    public Program Parse(string code, ParserOptions options);
    public FunctionExpression ParseFunctionExpression(string functionExpression);
}
public class Jint.Parser.Location : object {
    public Position Start;
    public Position End;
    public string Source;
}
public class Jint.Parser.Messages : object {
    public static string UnexpectedToken;
    public static string UnexpectedNumber;
    public static string UnexpectedString;
    public static string UnexpectedIdentifier;
    public static string UnexpectedReserved;
    public static string UnexpectedEOS;
    public static string NewlineAfterThrow;
    public static string InvalidRegExp;
    public static string UnterminatedRegExp;
    public static string InvalidLHSInAssignment;
    public static string InvalidLHSInForIn;
    public static string MultipleDefaultsInSwitch;
    public static string NoCatchOrFinally;
    public static string UnknownLabel;
    public static string Redeclaration;
    public static string IllegalContinue;
    public static string IllegalBreak;
    public static string IllegalReturn;
    public static string StrictModeWith;
    public static string StrictCatchVariable;
    public static string StrictVarName;
    public static string StrictParamName;
    public static string StrictParamDupe;
    public static string StrictFunctionName;
    public static string StrictOctalLiteral;
    public static string StrictDelete;
    public static string StrictDuplicateProperty;
    public static string AccessorDataProperty;
    public static string AccessorGetSet;
    public static string StrictLHSAssignment;
    public static string StrictLHSPostfix;
    public static string StrictLHSPrefix;
    public static string StrictReservedWord;
    private static Messages();
}
public class Jint.Parser.ParserException : Exception {
    public int Column;
    public string Description;
    public int Index;
    public int LineNumber;
    public ParserException(string message);
}
[ExtensionAttribute]
public static class Jint.Parser.ParserExtensions : object {
    [ExtensionAttribute]
public static string Slice(string source, int start, int end);
    [ExtensionAttribute]
public static char CharCodeAt(string source, int index);
    [ExtensionAttribute]
public static T Pop(List`1<T> list);
    [ExtensionAttribute]
public static void Push(List`1<T> list, T item);
}
public class Jint.Parser.ParserOptions : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Tolerant>k__BackingField;
    public string Source { get; public set; }
    public bool Tokens { get; public set; }
    public bool Comment { get; public set; }
    public bool Tolerant { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public bool get_Tokens();
    [CompilerGeneratedAttribute]
public void set_Tokens(bool value);
    [CompilerGeneratedAttribute]
public bool get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(bool value);
    [CompilerGeneratedAttribute]
public bool get_Tolerant();
    [CompilerGeneratedAttribute]
public void set_Tolerant(bool value);
}
public class Jint.Parser.Position : ValueType {
    public int Line;
    public int Column;
}
public class Jint.Parser.State : ValueType {
    public int LastCommentStart;
    public bool AllowIn;
    public HashSet`1<string> LabelSet;
    public bool InFunctionBody;
    public bool InIteration;
    public bool InSwitch;
    public Stack`1<int> MarkerStack;
}
public class Jint.Parser.Token : object {
    public static Token Empty;
    public Tokens Type;
    public string Literal;
    public object Value;
    public Int32[] Range;
    public Nullable`1<int> LineNumber;
    public int LineStart;
    public bool Octal;
    public Location Location;
    public int Precedence;
    private static Token();
}
public enum Jint.Parser.Tokens : Enum {
    public int value__;
    public static Tokens BooleanLiteral;
    public static Tokens EOF;
    public static Tokens Identifier;
    public static Tokens Keyword;
    public static Tokens NullLiteral;
    public static Tokens NumericLiteral;
    public static Tokens Punctuator;
    public static Tokens StringLiteral;
    public static Tokens RegularExpression;
}
public class Jint.Parser.VariableScope : object {
    [CompilerGeneratedAttribute]
private IList`1<VariableDeclaration> <VariableDeclarations>k__BackingField;
    public IList`1<VariableDeclaration> VariableDeclarations { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<VariableDeclaration> get_VariableDeclarations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VariableDeclarations(IList`1<VariableDeclaration> value);
}
[ExtensionAttribute]
internal static class Jint.ReflectionExtensions : object {
    [ExtensionAttribute]
internal static bool IsEnum(Type type);
    [ExtensionAttribute]
internal static bool IsGenericType(Type type);
    [ExtensionAttribute]
internal static bool IsValueType(Type type);
    [ExtensionAttribute]
internal static bool HasAttribute(ParameterInfo member);
    [ExtensionAttribute]
internal static MethodInfo GetMethodInfo(Delegate d);
}
[ExtensionAttribute]
public static class Jint.Runtime.Arguments : object {
    public static JsValue[] Empty;
    private static Arguments();
    public static JsValue[] From(JsValue[] o);
    [ExtensionAttribute]
public static JsValue At(JsValue[] args, int index, JsValue undefinedValue);
    [ExtensionAttribute]
public static JsValue At(JsValue[] args, int index);
}
public class Jint.Runtime.CallStack.CallStackElementComparer : object {
    public sealed virtual bool Equals(CallStackElement x, CallStackElement y);
    public sealed virtual int GetHashCode(CallStackElement obj);
}
public class Jint.Runtime.CallStack.JintCallStack : object {
    private Stack`1<CallStackElement> _stack;
    private Dictionary`2<CallStackElement, int> _statistics;
    public int Push(CallStackElement item);
    public CallStackElement Pop();
    public void Clear();
    public sealed virtual IEnumerator`1<CallStackElement> GetEnumerator();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Jint.Runtime.CallStackElement : object {
    private string _shortDescription;
    [CompilerGeneratedAttribute]
private CallExpression <CallExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private JsValue <Function>k__BackingField;
    public CallExpression CallExpression { get; private set; }
    public JsValue Function { get; private set; }
    public CallStackElement(CallExpression callExpression, JsValue function, string shortDescription);
    [CompilerGeneratedAttribute]
public CallExpression get_CallExpression();
    [CompilerGeneratedAttribute]
private void set_CallExpression(CallExpression value);
    [CompilerGeneratedAttribute]
public JsValue get_Function();
    [CompilerGeneratedAttribute]
private void set_Function(JsValue value);
    public virtual string ToString();
}
public class Jint.Runtime.Completion : object {
    public static string Normal;
    public static string Break;
    public static string Continue;
    public static string Return;
    public static string Throw;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private JsValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    public string Type { get; private set; }
    public JsValue Value { get; private set; }
    public string Identifier { get; private set; }
    public Location Location { get; public set; }
    public Completion(string type, JsValue value, string identifier);
    private static Completion();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    [CompilerGeneratedAttribute]
public JsValue get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(JsValue value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
private void set_Identifier(string value);
    public JsValue GetValueOrDefault();
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(Location value);
}
public class Jint.Runtime.Debugger.BreakPoint : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Char>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public int Line { get; public set; }
    public int Char { get; public set; }
    public string Condition { get; public set; }
    public BreakPoint(int line, int character);
    public BreakPoint(int line, int character, string condition);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Char();
    [CompilerGeneratedAttribute]
public void set_Char(int value);
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
internal class Jint.Runtime.Debugger.DebugHandler : object {
    private Stack`1<string> _debugCallStack;
    private StepMode _stepMode;
    private int _callBackStepOverDepth;
    private Engine _engine;
    public DebugHandler(Engine engine);
    internal void PopDebugCallStack();
    internal void AddToDebugCallStack(CallExpression callExpression);
    internal void OnStep(Statement statement);
    private bool BpTest(Statement statement, BreakPoint breakpoint);
    private DebugInformation CreateDebugInformation(Statement statement);
    private static Dictionary`2<string, JsValue> GetLocalVariables(LexicalEnvironment lex);
    private static Dictionary`2<string, JsValue> GetGlobalVariables(LexicalEnvironment lex);
    private static void AddRecordsFromEnvironment(LexicalEnvironment lex, Dictionary`2<string, JsValue> locals);
}
public class Jint.Runtime.Debugger.DebugInformation : EventArgs {
    [CompilerGeneratedAttribute]
private Stack`1<string> <CallStack>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <CurrentStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsValue> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsValue> <Globals>k__BackingField;
    public Stack`1<string> CallStack { get; public set; }
    public Statement CurrentStatement { get; public set; }
    public Dictionary`2<string, JsValue> Locals { get; public set; }
    public Dictionary`2<string, JsValue> Globals { get; public set; }
    [CompilerGeneratedAttribute]
public Stack`1<string> get_CallStack();
    [CompilerGeneratedAttribute]
public void set_CallStack(Stack`1<string> value);
    [CompilerGeneratedAttribute]
public Statement get_CurrentStatement();
    [CompilerGeneratedAttribute]
public void set_CurrentStatement(Statement value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsValue> get_Locals();
    [CompilerGeneratedAttribute]
public void set_Locals(Dictionary`2<string, JsValue> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsValue> get_Globals();
    [CompilerGeneratedAttribute]
public void set_Globals(Dictionary`2<string, JsValue> value);
}
public enum Jint.Runtime.Debugger.StepMode : Enum {
    public int value__;
    public static StepMode None;
    public static StepMode Over;
    public static StepMode Into;
    public static StepMode Out;
}
public class Jint.Runtime.Descriptors.PropertyDescriptor : object {
    public static PropertyDescriptor Undefined;
    [CompilerGeneratedAttribute]
private JsValue <Get>k__BackingField;
    [CompilerGeneratedAttribute]
private JsValue <Set>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enumerable>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Configurable>k__BackingField;
    [CompilerGeneratedAttribute]
private JsValue <Value>k__BackingField;
    public JsValue Get { get; public set; }
    public JsValue Set { get; public set; }
    public Nullable`1<bool> Enumerable { get; public set; }
    public Nullable`1<bool> Writable { get; public set; }
    public Nullable`1<bool> Configurable { get; public set; }
    public JsValue Value { get; public set; }
    public PropertyDescriptor(JsValue value, Nullable`1<bool> writable, Nullable`1<bool> enumerable, Nullable`1<bool> configurable);
    public PropertyDescriptor(JsValue get, JsValue set, Nullable`1<bool> enumerable, Nullable`1<bool> configurable);
    public PropertyDescriptor(PropertyDescriptor descriptor);
    private static PropertyDescriptor();
    [CompilerGeneratedAttribute]
public JsValue get_Get();
    [CompilerGeneratedAttribute]
public void set_Get(JsValue value);
    [CompilerGeneratedAttribute]
public JsValue get_Set();
    [CompilerGeneratedAttribute]
public void set_Set(JsValue value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enumerable();
    [CompilerGeneratedAttribute]
public void set_Enumerable(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Configurable();
    [CompilerGeneratedAttribute]
public void set_Configurable(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public virtual JsValue get_Value();
    [CompilerGeneratedAttribute]
public virtual void set_Value(JsValue value);
    public bool IsAccessorDescriptor();
    public bool IsDataDescriptor();
    public bool IsGenericDescriptor();
    public static PropertyDescriptor ToPropertyDescriptor(Engine engine, JsValue o);
    public static JsValue FromPropertyDescriptor(Engine engine, PropertyDescriptor desc);
}
public class Jint.Runtime.Descriptors.Specialized.ClrAccessDescriptor : PropertyDescriptor {
    public ClrAccessDescriptor(Engine engine, Func`2<JsValue, JsValue> get);
    public ClrAccessDescriptor(Engine engine, Func`2<JsValue, JsValue> get, Action`2<JsValue, JsValue> set);
}
public class Jint.Runtime.Descriptors.Specialized.FieldInfoDescriptor : PropertyDescriptor {
    private Engine _engine;
    private FieldInfo _fieldInfo;
    private object _item;
    public JsValue Value { get; public set; }
    public FieldInfoDescriptor(Engine engine, FieldInfo fieldInfo, object item);
    public virtual JsValue get_Value();
    public virtual void set_Value(JsValue value);
}
public class Jint.Runtime.Descriptors.Specialized.IndexDescriptor : PropertyDescriptor {
    private Engine _engine;
    private object _key;
    private object _item;
    private PropertyInfo _indexer;
    private MethodInfo _containsKey;
    public JsValue Value { get; public set; }
    public IndexDescriptor(Engine engine, Type targetType, string key, object item);
    public IndexDescriptor(Engine engine, string key, object item);
    public virtual JsValue get_Value();
    public virtual void set_Value(JsValue value);
}
public class Jint.Runtime.Descriptors.Specialized.PropertyInfoDescriptor : PropertyDescriptor {
    private Engine _engine;
    private PropertyInfo _propertyInfo;
    private object _item;
    public JsValue Value { get; public set; }
    public PropertyInfoDescriptor(Engine engine, PropertyInfo propertyInfo, object item);
    public virtual JsValue get_Value();
    public virtual void set_Value(JsValue value);
}
public class Jint.Runtime.Environments.Binding : object {
    public JsValue Value;
    public bool CanBeDeleted;
    public bool Mutable;
}
public class Jint.Runtime.Environments.DeclarativeEnvironmentRecord : EnvironmentRecord {
    private Engine _engine;
    private IDictionary`2<string, Binding> _bindings;
    public DeclarativeEnvironmentRecord(Engine engine);
    public virtual bool HasBinding(string name);
    public virtual void CreateMutableBinding(string name, bool canBeDeleted);
    public virtual void SetMutableBinding(string name, JsValue value, bool strict);
    public virtual JsValue GetBindingValue(string name, bool strict);
    public virtual bool DeleteBinding(string name);
    public virtual JsValue ImplicitThisValue();
    public void CreateImmutableBinding(string name);
    public void InitializeImmutableBinding(string name, JsValue value);
    public virtual String[] GetAllBindingNames();
}
public abstract class Jint.Runtime.Environments.EnvironmentRecord : ObjectInstance {
    protected EnvironmentRecord(Engine engine);
    public abstract virtual bool HasBinding(string name);
    public abstract virtual void CreateMutableBinding(string name, bool canBeDeleted);
    public abstract virtual void SetMutableBinding(string name, JsValue value, bool strict);
    public abstract virtual JsValue GetBindingValue(string name, bool strict);
    public abstract virtual bool DeleteBinding(string name);
    public abstract virtual JsValue ImplicitThisValue();
    public abstract virtual String[] GetAllBindingNames();
}
public class Jint.Runtime.Environments.ExecutionContext : object {
    [CompilerGeneratedAttribute]
private LexicalEnvironment <LexicalEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private LexicalEnvironment <VariableEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private JsValue <ThisBinding>k__BackingField;
    public LexicalEnvironment LexicalEnvironment { get; public set; }
    public LexicalEnvironment VariableEnvironment { get; public set; }
    public JsValue ThisBinding { get; public set; }
    [CompilerGeneratedAttribute]
public LexicalEnvironment get_LexicalEnvironment();
    [CompilerGeneratedAttribute]
public void set_LexicalEnvironment(LexicalEnvironment value);
    [CompilerGeneratedAttribute]
public LexicalEnvironment get_VariableEnvironment();
    [CompilerGeneratedAttribute]
public void set_VariableEnvironment(LexicalEnvironment value);
    [CompilerGeneratedAttribute]
public JsValue get_ThisBinding();
    [CompilerGeneratedAttribute]
public void set_ThisBinding(JsValue value);
}
public class Jint.Runtime.Environments.LexicalEnvironment : object {
    private EnvironmentRecord _record;
    private LexicalEnvironment _outer;
    public EnvironmentRecord Record { get; }
    public LexicalEnvironment Outer { get; }
    public LexicalEnvironment(EnvironmentRecord record, LexicalEnvironment outer);
    public EnvironmentRecord get_Record();
    public LexicalEnvironment get_Outer();
    public static Reference GetIdentifierReference(LexicalEnvironment lex, string name, bool strict);
    public static LexicalEnvironment NewDeclarativeEnvironment(Engine engine, LexicalEnvironment outer);
    public static LexicalEnvironment NewObjectEnvironment(Engine engine, ObjectInstance objectInstance, LexicalEnvironment outer, bool provideThis);
}
public class Jint.Runtime.Environments.ObjectEnvironmentRecord : EnvironmentRecord {
    private Engine _engine;
    private ObjectInstance _bindingObject;
    private bool _provideThis;
    public ObjectEnvironmentRecord(Engine engine, ObjectInstance bindingObject, bool provideThis);
    public virtual bool HasBinding(string name);
    public virtual void CreateMutableBinding(string name, bool configurable);
    public virtual void SetMutableBinding(string name, JsValue value, bool strict);
    public virtual JsValue GetBindingValue(string name, bool strict);
    public virtual bool DeleteBinding(string name);
    public virtual JsValue ImplicitThisValue();
    public virtual String[] GetAllBindingNames();
}
public class Jint.Runtime.ExpressionInterpreter : object {
    private Engine _engine;
    public ExpressionInterpreter(Engine engine);
    private object EvaluateExpression(Expression expression);
    public JsValue EvaluateConditionalExpression(ConditionalExpression conditionalExpression);
    public JsValue EvaluateAssignmentExpression(AssignmentExpression assignmentExpression);
    private JsValue Divide(JsValue lval, JsValue rval);
    public JsValue EvaluateBinaryExpression(BinaryExpression expression);
    public JsValue EvaluateLogicalExpression(LogicalExpression logicalExpression);
    public static bool Equal(JsValue x, JsValue y);
    public static bool StrictlyEqual(JsValue x, JsValue y);
    public static bool SameValue(JsValue x, JsValue y);
    public static JsValue Compare(JsValue x, JsValue y, bool leftFirst);
    public Reference EvaluateIdentifier(Identifier identifier);
    public JsValue EvaluateLiteral(Literal literal);
    public JsValue EvaluateObjectExpression(ObjectExpression objectExpression);
    public Reference EvaluateMemberExpression(MemberExpression memberExpression);
    public JsValue EvaluateFunctionExpression(FunctionExpression functionExpression);
    public JsValue EvaluateCallExpression(CallExpression callExpression);
    public JsValue EvaluateSequenceExpression(SequenceExpression sequenceExpression);
    public JsValue EvaluateUpdateExpression(UpdateExpression updateExpression);
    public JsValue EvaluateThisExpression(ThisExpression thisExpression);
    public JsValue EvaluateNewExpression(NewExpression newExpression);
    public JsValue EvaluateArrayExpression(ArrayExpression arrayExpression);
    public JsValue EvaluateUnaryExpression(UnaryExpression unaryExpression);
}
public class Jint.Runtime.Interop.ClrFunctionInstance : FunctionInstance {
    private Func`3<JsValue, JsValue[], JsValue> _func;
    public ClrFunctionInstance(Engine engine, Func`3<JsValue, JsValue[], JsValue> func, int length);
    public ClrFunctionInstance(Engine engine, Func`3<JsValue, JsValue[], JsValue> func);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
}
public class Jint.Runtime.Interop.DefaultTypeConverter : object {
    private Engine _engine;
    private static Dictionary`2<string, bool> _knownConversions;
    private static object _lockObject;
    private static MethodInfo convertChangeType;
    private static MethodInfo jsValueFromObject;
    private static MethodInfo jsValueToObject;
    public DefaultTypeConverter(Engine engine);
    private static DefaultTypeConverter();
    public virtual object Convert(object value, Type type, IFormatProvider formatProvider);
    public virtual bool TryConvert(object value, Type type, IFormatProvider formatProvider, Object& converted);
    [CompilerGeneratedAttribute]
private MethodCallExpression <Convert>b__7_0(ParameterExpression p);
    [CompilerGeneratedAttribute]
private MethodCallExpression <Convert>b__7_2(ParameterExpression p);
}
public class Jint.Runtime.Interop.DelegateWrapper : FunctionInstance {
    private Delegate _d;
    public DelegateWrapper(Engine engine, Delegate d);
    public virtual JsValue Call(JsValue thisObject, JsValue[] jsArguments);
}
public class Jint.Runtime.Interop.GetterFunctionInstance : FunctionInstance {
    private Func`2<JsValue, JsValue> _getter;
    public GetterFunctionInstance(Engine engine, Func`2<JsValue, JsValue> getter);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
}
public interface Jint.Runtime.Interop.IObjectConverter {
    public abstract virtual bool TryConvert(object value, JsValue& result);
}
public interface Jint.Runtime.Interop.IObjectWrapper {
    public object Target { get; }
    public abstract virtual object get_Target();
}
public interface Jint.Runtime.Interop.IReferenceResolver {
    public abstract virtual bool TryUnresolvableReference(Engine engine, Reference reference, JsValue& value);
    public abstract virtual bool TryPropertyReference(Engine engine, Reference reference, JsValue& value);
    public abstract virtual bool TryGetCallable(Engine engine, object callee, JsValue& value);
    public abstract virtual bool CheckCoercible(JsValue value);
}
public interface Jint.Runtime.Interop.ITypeConverter {
    public abstract virtual object Convert(object value, Type type, IFormatProvider formatProvider);
    public abstract virtual bool TryConvert(object value, Type type, IFormatProvider formatProvider, Object& converted);
}
public class Jint.Runtime.Interop.MethodInfoFunctionInstance : FunctionInstance {
    private MethodInfo[] _methods;
    public MethodInfoFunctionInstance(Engine engine, MethodInfo[] methods);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public JsValue Invoke(MethodInfo[] methodInfos, JsValue thisObject, JsValue[] jsArguments);
    private JsValue[] ProcessParamsArrays(JsValue[] jsArguments, IEnumerable`1<MethodInfo> methodInfos);
}
public class Jint.Runtime.Interop.NamespaceReference : ObjectInstance {
    private string _path;
    public NamespaceReference(Engine engine, string path);
    public virtual bool DefineOwnProperty(string propertyName, PropertyDescriptor desc, bool throwOnError);
    public virtual bool Delete(string propertyName, bool throwOnError);
    public sealed virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public virtual JsValue Get(string propertyName);
    public JsValue GetPath(string path);
    private static Type GetType(Assembly assembly, string typeName);
    private static IEnumerable`1<Type> GetAllNestedTypes(Type type);
    private static void AddNestedTypesRecursively(List`1<Type> types, Type type);
    public virtual PropertyDescriptor GetOwnProperty(string propertyName);
    public virtual string ToString();
}
public class Jint.Runtime.Interop.ObjectWrapper : ObjectInstance {
    [CompilerGeneratedAttribute]
private object <Target>k__BackingField;
    public object Target { get; public set; }
    public ObjectWrapper(Engine engine, object obj);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(object value);
    public virtual void Put(string propertyName, JsValue value, bool throwOnError);
    public virtual PropertyDescriptor GetOwnProperty(string propertyName);
    private bool EqualsIgnoreCasing(string s1, string s2);
}
public class Jint.Runtime.Interop.SetterFunctionInstance : FunctionInstance {
    private Action`2<JsValue, JsValue> _setter;
    public SetterFunctionInstance(Engine engine, Action`2<JsValue, JsValue> setter);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
}
public class Jint.Runtime.Interop.TypeReference : FunctionInstance {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; public set; }
    public object Target { get; }
    public string Class { get; }
    private TypeReference(Engine engine);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    public static TypeReference CreateTypeReference(Engine engine, Type type);
    public virtual JsValue Call(JsValue thisObject, JsValue[] arguments);
    public sealed virtual ObjectInstance Construct(JsValue[] arguments);
    public virtual bool HasInstance(JsValue v);
    public virtual bool DefineOwnProperty(string propertyName, PropertyDescriptor desc, bool throwOnError);
    public virtual bool Delete(string propertyName, bool throwOnError);
    public virtual void Put(string propertyName, JsValue value, bool throwOnError);
    public virtual PropertyDescriptor GetOwnProperty(string propertyName);
    public sealed virtual object get_Target();
    public virtual string get_Class();
}
public class Jint.Runtime.JavaScriptException : Exception {
    private JsValue _errorObject;
    private string _callStack;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    public JsValue Error { get; }
    public string CallStack { get; public set; }
    public Location Location { get; public set; }
    public int LineNumber { get; }
    public int Column { get; }
    public JavaScriptException(ErrorConstructor errorConstructor);
    public JavaScriptException(ErrorConstructor errorConstructor, string message);
    public JavaScriptException(JsValue error);
    public JavaScriptException SetCallstack(Engine engine, Location location);
    private static string GetErrorMessage(JsValue error);
    public JsValue get_Error();
    public virtual string ToString();
    public string get_CallStack();
    public void set_CallStack(string value);
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(Location value);
    public int get_LineNumber();
    public int get_Column();
}
[DefaultMemberAttribute("Item")]
public class Jint.Runtime.MruPropertyCache`2 : object {
    private IDictionary`2<TKey, TValue> _dictionary;
    private LinkedList`1<KeyValuePair`2<TKey, TValue>> _list;
    private UInt32 _length;
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public MruPropertyCache`2(UInt32 length);
    private bool Find(TKey key, LinkedListNode`1& result);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class Jint.Runtime.MruPropertyCache2`2 : object {
    private IDictionary`2<TKey, TValue> _dictionary;
    private bool _set;
    private TKey _key;
    private TValue _value;
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Jint.Runtime.RecursionDepthOverflowException : Exception {
    [CompilerGeneratedAttribute]
private string <CallChain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CallExpressionReference>k__BackingField;
    public string CallChain { get; private set; }
    public string CallExpressionReference { get; private set; }
    public RecursionDepthOverflowException(JintCallStack currentStack, string currentExpressionReference);
    [CompilerGeneratedAttribute]
public string get_CallChain();
    [CompilerGeneratedAttribute]
private void set_CallChain(string value);
    [CompilerGeneratedAttribute]
public string get_CallExpressionReference();
    [CompilerGeneratedAttribute]
private void set_CallExpressionReference(string value);
}
public class Jint.Runtime.References.Reference : object {
    private JsValue _baseValue;
    private string _name;
    private bool _strict;
    public Reference(JsValue baseValue, string name, bool strict);
    public JsValue GetBase();
    public string GetReferencedName();
    public bool IsStrict();
    public bool HasPrimitiveBase();
    public bool IsUnresolvableReference();
    public bool IsPropertyReference();
}
public class Jint.Runtime.StatementInterpreter : object {
    private Engine _engine;
    public StatementInterpreter(Engine engine);
    private Completion ExecuteStatement(Statement statement);
    public Completion ExecuteEmptyStatement(EmptyStatement emptyStatement);
    public Completion ExecuteExpressionStatement(ExpressionStatement expressionStatement);
    public Completion ExecuteIfStatement(IfStatement ifStatement);
    public Completion ExecuteLabelledStatement(LabelledStatement labelledStatement);
    public Completion ExecuteDoWhileStatement(DoWhileStatement doWhileStatement);
    public Completion ExecuteWhileStatement(WhileStatement whileStatement);
    public Completion ExecuteForStatement(ForStatement forStatement);
    public Completion ExecuteForInStatement(ForInStatement forInStatement);
    public Completion ExecuteContinueStatement(ContinueStatement continueStatement);
    public Completion ExecuteBreakStatement(BreakStatement breakStatement);
    public Completion ExecuteReturnStatement(ReturnStatement statement);
    public Completion ExecuteWithStatement(WithStatement withStatement);
    public Completion ExecuteSwitchStatement(SwitchStatement switchStatement);
    public Completion ExecuteSwitchBlock(IEnumerable`1<SwitchCase> switchBlock, JsValue input);
    public Completion ExecuteStatementList(IEnumerable`1<Statement> statementList);
    public Completion ExecuteThrowStatement(ThrowStatement throwStatement);
    public Completion ExecuteTryStatement(TryStatement tryStatement);
    public Completion ExecuteProgram(Program program);
    public Completion ExecuteVariableDeclaration(VariableDeclaration statement);
    public Completion ExecuteBlockStatement(BlockStatement blockStatement);
    public Completion ExecuteDebuggerStatement(DebuggerStatement debuggerStatement);
}
public class Jint.Runtime.StatementsCountOverflowException : Exception {
}
public class Jint.Runtime.TypeConverter : object {
    public static JsValue ToPrimitive(JsValue input, Types preferredType);
    public static bool ToBoolean(JsValue o);
    public static double ToNumber(JsValue o);
    public static double ToInteger(JsValue o);
    public static int ToInt32(JsValue o);
    public static UInt32 ToUint32(JsValue o);
    public static ushort ToUint16(JsValue o);
    public static string ToString(JsValue o);
    public static ObjectInstance ToObject(Engine engine, JsValue value);
    public static Types GetPrimitiveType(JsValue value);
    public static void CheckObjectCoercible(Engine engine, JsValue o, MemberExpression expression, object baseReference);
    public static void CheckObjectCoercible(Engine engine, JsValue o);
    [IteratorStateMachineAttribute("Jint.Runtime.TypeConverter/<FindBestMatch>d__12")]
public static IEnumerable`1<MethodBase> FindBestMatch(Engine engine, MethodBase[] methods, JsValue[] arguments);
    public static bool TypeIsNullable(Type type);
}
public enum Jint.Runtime.Types : Enum {
    public int value__;
    public static Types None;
    public static Types Undefined;
    public static Types Null;
    public static Types Boolean;
    public static Types String;
    public static Types Number;
    public static Types Object;
}
public class Jint.StrictModeScope : object {
    private bool _strict;
    private bool _force;
    private int _forcedRefCount;
    [ThreadStaticAttribute]
private static int _refCount;
    public static bool IsStrictModeCode { get; }
    public static int RefCount { get; public set; }
    public StrictModeScope(bool strict, bool force);
    public sealed virtual void Dispose();
    public static bool get_IsStrictModeCode();
    public static int get_RefCount();
    public static void set_RefCount(int value);
}
